{"files":[{"patch":"@@ -169,1 +169,1 @@\n-      DISABLED_WARNINGS=\"unknown-warning-option unused-parameter unused\"\n+      DISABLED_WARNINGS=\"unknown-warning-option unused-parameter unused format-nonliteral\"\n","filename":"make\/autoconf\/flags-cflags.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -128,0 +128,3 @@\n+    # The expected format for <version> is either nn.n.n or nn.nn.nn. See\n+    # \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/AvailabilityVersions.h\n+\n@@ -133,1 +136,5 @@\n-    MACOSX_VERSION_MIN=10.9.0\n+    if test \"x$OPENJDK_TARGET_CPU_ARCH\" = xaarch64; then\n+      MACOSX_VERSION_MIN=11.00.00\n+    else\n+      MACOSX_VERSION_MIN=10.9.0\n+    fi\n@@ -139,2 +146,1 @@\n-    # link to macosx APIs that are newer than the given OS version. The expected\n-    # format for <version> is either nn.n.n or nn.nn.nn. See \/usr\/include\/AvailabilityMacros.h.\n+    # link to macosx APIs that are newer than the given OS version.\n","filename":"make\/autoconf\/flags.m4","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -245,1 +245,1 @@\n-      AC_MSG_RESULT([no, $OPENJDK_TARGET_CPU])\n+      AC_MSG_RESULT([no, $OPENJDK_TARGET_OS-$OPENJDK_TARGET_CPU])\n@@ -267,1 +267,3 @@\n-    if test \"x$OPENJDK_TARGET_OS\" != xaix; then\n+    if test \"x$OPENJDK_TARGET_OS\" != xaix && \\\n+        !( test \"x$OPENJDK_TARGET_OS\" = \"xmacosx\" && \\\n+        test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\" ) ; then\n","filename":"make\/autoconf\/jvm-features.m4","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -58,4 +58,17 @@\n-      VAR_CPU=arm\n-      VAR_CPU_ARCH=arm\n-      VAR_CPU_BITS=32\n-      VAR_CPU_ENDIAN=little\n+      # Second argument is the os name from the trip\/quad.\n+      # on macos-aarch64, triplet returned by autoconf is\n+      # arm-darwin*, but on darwin only aarch64 is present.\n+      case \"$2\" in\n+        *darwin*)\n+          VAR_CPU=aarch64\n+          VAR_CPU_ARCH=aarch64\n+          VAR_CPU_BITS=64\n+          VAR_CPU_ENDIAN=little\n+        ;;\n+        *)\n+          VAR_CPU=arm\n+          VAR_CPU_ARCH=arm\n+          VAR_CPU_BITS=32\n+          VAR_CPU_ENDIAN=little\n+        ;;\n+      esac\n@@ -260,1 +273,1 @@\n-  PLATFORM_EXTRACT_VARS_FROM_CPU($build_cpu)\n+  PLATFORM_EXTRACT_VARS_FROM_CPU($build_cpu, $build_os)\n@@ -298,1 +311,1 @@\n-  PLATFORM_EXTRACT_VARS_FROM_CPU($host_cpu)\n+  PLATFORM_EXTRACT_VARS_FROM_CPU($host_cpu, $host_os)\n","filename":"make\/autoconf\/platform.m4","additions":19,"deletions":6,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1180,1 +1180,1 @@\n-\t\t  $(CODESIGN) -s \"$(MACOSX_CODESIGN_IDENTITY)\" --timestamp --options runtime \\\n+\t\t  $(CODESIGN) -f -s \"$(MACOSX_CODESIGN_IDENTITY)\" --timestamp --options runtime \\\n","filename":"make\/common\/NativeCompilation.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -91,0 +91,3 @@\n+    ifeq ($(HOTSPOT_TARGET_CPU_ARCH), aarch64)\n+      ADLCFLAGS += -DR18_RESERVED\n+    endif\n","filename":"make\/hotspot\/gensrc\/GensrcAdlc.gmk","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -573,0 +573,1 @@\n+    DISABLED_WARNINGS_clang := deprecated-declarations, \\\n@@ -797,1 +798,2 @@\n-      DISABLED_WARNINGS_clang := incompatible-pointer-types sign-compare, \\\n+      DISABLED_WARNINGS_clang := incompatible-pointer-types sign-compare \\\n+          deprecated-declarations, \\\n","filename":"make\/modules\/java.desktop\/lib\/Awt2dLibraries.gmk","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-  SA_CFLAGS := -Damd64 -D_GNU_SOURCE -mno-omit-leaf-frame-pointer \\\n+  SA_CFLAGS := -D_GNU_SOURCE -mno-omit-leaf-frame-pointer \\\n","filename":"make\/modules\/jdk.hotspot.agent\/Lib.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -323,1 +323,1 @@\n-  str(zr, Address(rthread, JavaThread::saved_fp_address_offset()));\n+  str(zr, Address(rthread, JavaFrameAnchor::saved_fp_address_offset()));\n@@ -5271,1 +5271,1 @@\n-  RegSet saved_regs = RegSet::range(r0, r1) + lr - dst;\n+  RegSet saved_regs = RegSet::range(r0, r1) + BSD_ONLY(RegSet::range(r2, r17)) + lr - dst;\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -808,0 +808,5 @@\n+#ifdef __APPLE__\n+          \/\/ Less-than word types are stored one after another.\n+          \/\/ The code unable to handle this, bailout.\n+          return -1;\n+#endif\n@@ -830,0 +835,5 @@\n+#ifdef __APPLE__\n+          \/\/ Less-than word types are stored one after another.\n+          \/\/ The code unable to handle this, bailout.\n+          return -1;\n+#endif\n@@ -1363,0 +1373,4 @@\n+  if (out_arg_slots < 0) {\n+    return NULL;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+#include \"runtime\/stubRoutines.inline.hpp\"\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -213,0 +213,2 @@\n+#elif defined(AARCH64)\n+static char cpu_arch[] = \"aarch64\";\n@@ -2232,1 +2234,1 @@\n-#ifdef __APPLE__\n+#if defined(__APPLE__) && defined(__x86_64__)\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1297,1 +1297,1 @@\n-                                EXC_MASK_BAD_ACCESS | EXC_MASK_ARITHMETIC,\n+                                EXC_MASK_BAD_ACCESS | EXC_MASK_BAD_INSTRUCTION | EXC_MASK_ARITHMETIC,\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-#include \"runtime\/stubRoutines.hpp\"\n+#include \"runtime\/stubRoutines.inline.hpp\"\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_BSD_AARCH64_ORDERACCESS_BSD_AARCH64_HPP\n+#define OS_CPU_BSD_AARCH64_ORDERACCESS_BSD_AARCH64_HPP\n+\n+\/\/ Included in orderAccess.hpp header file.\n+\n+\/\/ Implementation of class OrderAccess.\n+\n+inline void OrderAccess::loadload()   { acquire(); }\n+inline void OrderAccess::storestore() { release(); }\n+inline void OrderAccess::loadstore()  { acquire(); }\n+inline void OrderAccess::storeload()  { fence(); }\n+\n+#define FULL_MEM_BARRIER  __sync_synchronize()\n+#define READ_MEM_BARRIER  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n+#define WRITE_MEM_BARRIER __atomic_thread_fence(__ATOMIC_RELEASE);\n+\n+inline void OrderAccess::acquire() {\n+  READ_MEM_BARRIER;\n+}\n+\n+inline void OrderAccess::release() {\n+  WRITE_MEM_BARRIER;\n+}\n+\n+inline void OrderAccess::fence() {\n+  FULL_MEM_BARRIER;\n+}\n+\n+inline void OrderAccess::cross_modify_fence_impl() {\n+  asm volatile(\"isb\" : : : \"memory\");\n+}\n+\n+#endif \/\/ OS_CPU_BSD_AARCH64_ORDERACCESS_BSD_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/orderAccess_bsd_aarch64.hpp","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,736 @@\n+\/*\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ no precompiled headers\n+#include \"jvm.h\"\n+#include \"asm\/macroAssembler.hpp\"\n+#include \"classfile\/classLoader.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n+#include \"code\/codeCache.hpp\"\n+#include \"code\/icBuffer.hpp\"\n+#include \"code\/vtableStubs.hpp\"\n+#include \"interpreter\/interpreter.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"os_share_bsd.hpp\"\n+#include \"prims\/jniFastGetField.hpp\"\n+#include \"prims\/jvm_misc.hpp\"\n+#include \"runtime\/arguments.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/java.hpp\"\n+#include \"runtime\/javaCalls.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/osThread.hpp\"\n+#include \"runtime\/safepointMechanism.hpp\"\n+#include \"runtime\/sharedRuntime.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/timer.hpp\"\n+#include \"signals_posix.hpp\"\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/events.hpp\"\n+#include \"utilities\/vmError.hpp\"\n+\n+\/\/ put OS-includes here\n+# include <sys\/types.h>\n+# include <sys\/mman.h>\n+# include <pthread.h>\n+# include <signal.h>\n+# include <errno.h>\n+# include <dlfcn.h>\n+# include <stdlib.h>\n+# include <stdio.h>\n+# include <unistd.h>\n+# include <sys\/resource.h>\n+# include <pthread.h>\n+# include <sys\/stat.h>\n+# include <sys\/time.h>\n+# include <sys\/utsname.h>\n+# include <sys\/socket.h>\n+# include <sys\/wait.h>\n+# include <pwd.h>\n+# include <poll.h>\n+#ifndef __OpenBSD__\n+# include <ucontext.h>\n+#endif\n+\n+#if !defined(__APPLE__) && !defined(__NetBSD__)\n+# include <pthread_np.h>\n+#endif\n+\n+\/\/ needed by current_stack_region() workaround for Mavericks\n+#if defined(__APPLE__)\n+# include <errno.h>\n+# include <sys\/types.h>\n+# include <sys\/sysctl.h>\n+# define DEFAULT_MAIN_THREAD_STACK_PAGES 2048\n+# define OS_X_10_9_0_KERNEL_MAJOR_VERSION 13\n+#endif\n+\n+#define SPELL_REG_SP \"sp\"\n+#define SPELL_REG_FP \"fp\"\n+\n+#ifdef __APPLE__\n+\/\/ see darwin-xnu\/osfmk\/mach\/arm\/_structs.h\n+\n+# if __DARWIN_UNIX03 && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)\n+  \/\/ 10.5 UNIX03 member name prefixes\n+  #define DU3_PREFIX(s, m) __ ## s.__ ## m\n+# else\n+  #define DU3_PREFIX(s, m) s ## . ## m\n+# endif\n+#endif\n+\n+#define context_x    uc_mcontext->DU3_PREFIX(ss,x)\n+#define context_fp   uc_mcontext->DU3_PREFIX(ss,fp)\n+#define context_lr   uc_mcontext->DU3_PREFIX(ss,lr)\n+#define context_sp   uc_mcontext->DU3_PREFIX(ss,sp)\n+#define context_pc   uc_mcontext->DU3_PREFIX(ss,pc)\n+#define context_cpsr uc_mcontext->DU3_PREFIX(ss,cpsr)\n+#define context_esr  uc_mcontext->DU3_PREFIX(es,esr)\n+\n+address os::current_stack_pointer() {\n+#if defined(__clang__) || defined(__llvm__)\n+  void *sp;\n+  __asm__(\"mov %0, \" SPELL_REG_SP : \"=r\"(sp));\n+  return (address) sp;\n+#else\n+  register void *sp __asm__ (SPELL_REG_SP);\n+  return (address) sp;\n+#endif\n+}\n+\n+char* os::non_memory_address_word() {\n+  \/\/ Must never look like an address returned by reserve_memory,\n+  \/\/ even in its subfields (as defined by the CPU immediate fields,\n+  \/\/ if the CPU splits constants across multiple instructions).\n+\n+  \/\/ the return value used in computation of Universe::non_oop_word(), which\n+  \/\/ is loaded by cpu\/aarch64 by MacroAssembler::movptr(Register, uintptr_t)\n+  return (char*) 0xffffffffffff;\n+}\n+\n+address os::Posix::ucontext_get_pc(const ucontext_t * uc) {\n+  return (address)uc->context_pc;\n+}\n+\n+void os::Posix::ucontext_set_pc(ucontext_t * uc, address pc) {\n+  uc->context_pc = (intptr_t)pc ;\n+}\n+\n+intptr_t* os::Bsd::ucontext_get_sp(const ucontext_t * uc) {\n+  return (intptr_t*)uc->context_sp;\n+}\n+\n+intptr_t* os::Bsd::ucontext_get_fp(const ucontext_t * uc) {\n+  return (intptr_t*)uc->context_fp;\n+}\n+\n+address os::fetch_frame_from_context(const void* ucVoid,\n+                    intptr_t** ret_sp, intptr_t** ret_fp) {\n+\n+  address epc;\n+  const ucontext_t* uc = (const ucontext_t*)ucVoid;\n+\n+  if (uc != NULL) {\n+    epc = os::Posix::ucontext_get_pc(uc);\n+    if (ret_sp) *ret_sp = os::Bsd::ucontext_get_sp(uc);\n+    if (ret_fp) *ret_fp = os::Bsd::ucontext_get_fp(uc);\n+  } else {\n+    epc = NULL;\n+    if (ret_sp) *ret_sp = (intptr_t *)NULL;\n+    if (ret_fp) *ret_fp = (intptr_t *)NULL;\n+  }\n+\n+  return epc;\n+}\n+\n+frame os::fetch_frame_from_context(const void* ucVoid) {\n+  intptr_t* sp;\n+  intptr_t* fp;\n+  address epc = fetch_frame_from_context(ucVoid, &sp, &fp);\n+  return frame(sp, fp, epc);\n+}\n+\n+frame os::fetch_compiled_frame_from_context(const void* ucVoid) {\n+  const ucontext_t* uc = (const ucontext_t*)ucVoid;\n+  \/\/ In compiled code, the stack banging is performed before LR\n+  \/\/ has been saved in the frame.  LR is live, and SP and FP\n+  \/\/ belong to the caller.\n+  intptr_t* fp = os::Bsd::ucontext_get_fp(uc);\n+  intptr_t* sp = os::Bsd::ucontext_get_sp(uc);\n+  address pc = (address)(uc->context_lr\n+                         - NativeInstruction::instruction_size);\n+  return frame(sp, fp, pc);\n+}\n+\n+\/\/ By default, gcc always saves frame pointer rfp on this stack. This\n+\/\/ may get turned off by -fomit-frame-pointer.\n+frame os::get_sender_for_C_frame(frame* fr) {\n+  return frame(fr->link(), fr->link(), fr->sender_pc());\n+}\n+\n+NOINLINE frame os::current_frame() {\n+  intptr_t *fp = *(intptr_t **)__builtin_frame_address(0);\n+  frame myframe((intptr_t*)os::current_stack_pointer(),\n+                (intptr_t*)fp,\n+                CAST_FROM_FN_PTR(address, os::current_frame));\n+  if (os::is_first_C_frame(&myframe)) {\n+    \/\/ stack is not walkable\n+    return frame();\n+  } else {\n+    return os::get_sender_for_C_frame(&myframe);\n+  }\n+}\n+\n+bool PosixSignals::pd_hotspot_signal_handler(int sig, siginfo_t* info,\n+                                             ucontext_t* uc, JavaThread* thread) {\n+\n+\/*\n+  NOTE: does not seem to work on bsd.\n+  if (info == NULL || info->si_code <= 0 || info->si_code == SI_NOINFO) {\n+    \/\/ can't decode this kind of signal\n+    info = NULL;\n+  } else {\n+    assert(sig == info->si_signo, \"bad siginfo\");\n+  }\n+*\/\n+  \/\/ decide if this trap can be handled by a stub\n+  address stub = NULL;\n+\n+  address pc          = NULL;\n+\n+  \/\/%note os_trap_1\n+  if (info != NULL && uc != NULL && thread != NULL) {\n+    pc = (address) os::Posix::ucontext_get_pc(uc);\n+\n+    if (StubRoutines::is_safefetch_fault(pc)) {\n+      os::Posix::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));\n+      return true;\n+    }\n+\n+    \/\/ Handle ALL stack overflow variations here\n+    if (sig == SIGSEGV || sig == SIGBUS) {\n+      address addr = (address) info->si_addr;\n+\n+      \/\/ Make sure the high order byte is sign extended, as it may be masked away by the hardware.\n+      if ((uintptr_t(addr) & (uintptr_t(1) << 55)) != 0) {\n+        addr = address(uintptr_t(addr) | (uintptr_t(0xFF) << 56));\n+      }\n+\n+      \/\/ check if fault address is within thread stack\n+      if (thread->is_in_full_stack(addr)) {\n+        Thread::WXWriteFromExecSetter wx_write;\n+        \/\/ stack overflow\n+        if (os::Posix::handle_stack_overflow(thread, addr, pc, uc, &stub)) {\n+          return true; \/\/ continue\n+        }\n+      }\n+    }\n+\n+    \/\/ We test if stub is already set (by the stack overflow code\n+    \/\/ above) so it is not overwritten by the code that follows. This\n+    \/\/ check is not required on other platforms, because on other\n+    \/\/ platforms we check for SIGSEGV only or SIGBUS only, where here\n+    \/\/ we have to check for both SIGSEGV and SIGBUS.\n+    if (thread->thread_state() == _thread_in_Java && stub == NULL) {\n+      \/\/ Java thread running in Java code => find exception handler if any\n+      \/\/ a fault inside compiled code, the interpreter, or a stub\n+      Thread::WXWriteFromExecSetter wx_write;\n+\n+      \/\/ Handle signal from NativeJump::patch_verified_entry().\n+      if ((sig == SIGILL)\n+          && nativeInstruction_at(pc)->is_sigill_zombie_not_entrant()) {\n+        if (TraceTraps) {\n+          tty->print_cr(\"trap: zombie_not_entrant\");\n+        }\n+        stub = SharedRuntime::get_handle_wrong_method_stub();\n+      } else if ((sig == SIGSEGV || sig == SIGBUS) && SafepointMechanism::is_poll_address((address)info->si_addr)) {\n+        stub = SharedRuntime::get_poll_stub(pc);\n+#if defined(__APPLE__)\n+      \/\/ 32-bit Darwin reports a SIGBUS for nearly all memory access exceptions.\n+      \/\/ 64-bit Darwin may also use a SIGBUS (seen with compressed oops).\n+      \/\/ Catching SIGBUS here prevents the implicit SIGBUS NULL check below from\n+      \/\/ being called, so only do so if the implicit NULL check is not necessary.\n+      } else if (sig == SIGBUS && !MacroAssembler::uses_implicit_null_check(info->si_addr)) {\n+#else\n+      } else if (sig == SIGBUS \/* && info->si_code == BUS_OBJERR *\/) {\n+#endif\n+        \/\/ BugId 4454115: A read from a MappedByteBuffer can fault\n+        \/\/ here if the underlying file has been truncated.\n+        \/\/ Do not crash the VM in such a case.\n+        CodeBlob* cb = CodeCache::find_blob_unsafe(pc);\n+        CompiledMethod* nm = (cb != NULL) ? cb->as_compiled_method_or_null() : NULL;\n+        bool is_unsafe_arraycopy = (thread->doing_unsafe_access() && UnsafeCopyMemory::contains_pc(pc));\n+        if ((nm != NULL && nm->has_unsafe_access()) || is_unsafe_arraycopy) {\n+          address next_pc = pc + NativeCall::instruction_size;\n+          if (is_unsafe_arraycopy) {\n+            next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);\n+          }\n+          stub = SharedRuntime::handle_unsafe_access(thread, next_pc);\n+        }\n+      } else if (sig == SIGILL && nativeInstruction_at(pc)->is_stop()) {\n+        \/\/ Pull a pointer to the error message out of the instruction\n+        \/\/ stream.\n+        const uint64_t *detail_msg_ptr\n+          = (uint64_t*)(pc + NativeInstruction::instruction_size);\n+        const char *detail_msg = (const char *)*detail_msg_ptr;\n+        const char *msg = \"stop\";\n+        if (TraceTraps) {\n+          tty->print_cr(\"trap: %s: (SIGILL)\", msg);\n+        }\n+\n+        return false;\n+      }\n+      else\n+\n+      if (sig == SIGFPE  &&\n+          (info->si_code == FPE_INTDIV || info->si_code == FPE_FLTDIV)) {\n+        stub =\n+          SharedRuntime::\n+          continuation_for_implicit_exception(thread,\n+                                              pc,\n+                                              SharedRuntime::\n+                                              IMPLICIT_DIVIDE_BY_ZERO);\n+#ifdef __APPLE__\n+      } else if (sig == SIGFPE && info->si_code == FPE_NOOP) {\n+        Unimplemented();\n+#endif \/* __APPLE__ *\/\n+\n+      } else if ((sig == SIGSEGV || sig == SIGBUS) &&\n+                 MacroAssembler::uses_implicit_null_check(info->si_addr)) {\n+          \/\/ Determination of interpreter\/vtable stub\/compiled code null exception\n+          stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);\n+      }\n+    } else if ((thread->thread_state() == _thread_in_vm ||\n+                 thread->thread_state() == _thread_in_native) &&\n+               sig == SIGBUS && \/* info->si_code == BUS_OBJERR && *\/\n+               thread->doing_unsafe_access()) {\n+      address next_pc = pc + NativeCall::instruction_size;\n+      if (UnsafeCopyMemory::contains_pc(pc)) {\n+        next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);\n+      }\n+      stub = SharedRuntime::handle_unsafe_access(thread, next_pc);\n+    }\n+\n+    \/\/ jni_fast_Get<Primitive>Field can trap at certain pc's if a GC kicks in\n+    \/\/ and the heap gets shrunk before the field access.\n+    if ((sig == SIGSEGV) || (sig == SIGBUS)) {\n+      address addr = JNI_FastGetField::find_slowcase_pc(pc);\n+      if (addr != (address)-1) {\n+        stub = addr;\n+      }\n+    }\n+  }\n+\n+#if defined(ASSERT) && defined(__APPLE__)\n+  \/\/ Execution protection violation\n+  \/\/\n+  \/\/ This should be kept as the last step in the triage.  We don't\n+  \/\/ have a dedicated trap number for a no-execute fault, so be\n+  \/\/ conservative and allow other handlers the first shot.\n+  if (UnguardOnExecutionViolation > 0 &&\n+      (sig == SIGBUS)) {\n+    static __thread address last_addr = (address) -1;\n+\n+    address addr = (address) info->si_addr;\n+    address pc = os::Posix::ucontext_get_pc(uc);\n+\n+    if (pc != addr && uc->context_esr == 0x9200004F) { \/\/TODO: figure out what this value means\n+      \/\/ We are faulting trying to write a R-X page\n+      pthread_jit_write_protect_np(false);\n+\n+      log_debug(os)(\"Writing protection violation \"\n+                    \"at \" INTPTR_FORMAT\n+                    \", unprotecting\", p2i(addr));\n+\n+      stub = pc;\n+\n+      last_addr = (address) -1;\n+    } else if (pc == addr && uc->context_esr == 0x8200000f) { \/\/TODO: figure out what this value means\n+      \/\/ We are faulting trying to execute a RW- page\n+\n+      if (addr != last_addr) {\n+        pthread_jit_write_protect_np(true);\n+\n+        log_debug(os)(\"Execution protection violation \"\n+                      \"at \" INTPTR_FORMAT\n+                      \", protecting\", p2i(addr));\n+\n+        stub = pc;\n+\n+        \/\/ Set last_addr so if we fault again at the same address, we don't end\n+        \/\/ up in an endless loop.\n+        last_addr = addr;\n+      }\n+    }\n+  }\n+#endif\n+\n+  if (stub != NULL) {\n+    \/\/ save all thread context in case we need to restore it\n+    if (thread != NULL) thread->set_saved_exception_pc(pc);\n+\n+    os::Posix::ucontext_set_pc(uc, stub);\n+    return true;\n+  }\n+\n+  return false; \/\/ Mute compiler\n+}\n+\n+void os::Bsd::init_thread_fpu_state(void) {\n+}\n+\n+bool os::is_allocatable(size_t bytes) {\n+  return true;\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ thread stack\n+\n+\/\/ Minimum usable stack sizes required to get to user code. Space for\n+\/\/ HotSpot guard pages is added later.\n+size_t os::Posix::_compiler_thread_min_stack_allowed = 72 * K;\n+size_t os::Posix::_java_thread_min_stack_allowed = 72 * K;\n+size_t os::Posix::_vm_internal_thread_min_stack_allowed = 72 * K;\n+\n+\/\/ return default stack size for thr_type\n+size_t os::Posix::default_stack_size(os::ThreadType thr_type) {\n+  \/\/ default stack size (compiler thread needs larger stack)\n+  size_t s = (thr_type == os::compiler_thread ? 4 * M : 1 * M);\n+  return s;\n+}\n+\n+\n+\/\/ Java thread:\n+\/\/\n+\/\/   Low memory addresses\n+\/\/    +------------------------+\n+\/\/    |                        |\\  Java thread created by VM does not have glibc\n+\/\/    |    glibc guard page    | - guard, attached Java thread usually has\n+\/\/    |                        |\/  1 glibc guard page.\n+\/\/ P1 +------------------------+ Thread::stack_base() - Thread::stack_size()\n+\/\/    |                        |\\\n+\/\/    |  HotSpot Guard Pages   | - red, yellow and reserved pages\n+\/\/    |                        |\/\n+\/\/    +------------------------+ JavaThread::stack_reserved_zone_base()\n+\/\/    |                        |\\\n+\/\/    |      Normal Stack      | -\n+\/\/    |                        |\/\n+\/\/ P2 +------------------------+ Thread::stack_base()\n+\/\/\n+\/\/ Non-Java thread:\n+\/\/\n+\/\/   Low memory addresses\n+\/\/    +------------------------+\n+\/\/    |                        |\\\n+\/\/    |  glibc guard page      | - usually 1 page\n+\/\/    |                        |\/\n+\/\/ P1 +------------------------+ Thread::stack_base() - Thread::stack_size()\n+\/\/    |                        |\\\n+\/\/    |      Normal Stack      | -\n+\/\/    |                        |\/\n+\/\/ P2 +------------------------+ Thread::stack_base()\n+\/\/\n+\/\/ ** P1 (aka bottom) and size ( P2 = P1 - size) are the address and stack size returned from\n+\/\/    pthread_attr_getstack()\n+\n+static void current_stack_region(address * bottom, size_t * size) {\n+#ifdef __APPLE__\n+  pthread_t self = pthread_self();\n+  void *stacktop = pthread_get_stackaddr_np(self);\n+  *size = pthread_get_stacksize_np(self);\n+  \/\/ workaround for OS X 10.9.0 (Mavericks)\n+  \/\/ pthread_get_stacksize_np returns 128 pages even though the actual size is 2048 pages\n+  if (pthread_main_np() == 1) {\n+    \/\/ At least on Mac OS 10.12 we have observed stack sizes not aligned\n+    \/\/ to pages boundaries. This can be provoked by e.g. setrlimit() (ulimit -s xxxx in the\n+    \/\/ shell). Apparently Mac OS actually rounds upwards to next multiple of page size,\n+    \/\/ however, we round downwards here to be on the safe side.\n+    *size = align_down(*size, getpagesize());\n+\n+    if ((*size) < (DEFAULT_MAIN_THREAD_STACK_PAGES * (size_t)getpagesize())) {\n+      char kern_osrelease[256];\n+      size_t kern_osrelease_size = sizeof(kern_osrelease);\n+      int ret = sysctlbyname(\"kern.osrelease\", kern_osrelease, &kern_osrelease_size, NULL, 0);\n+      if (ret == 0) {\n+        \/\/ get the major number, atoi will ignore the minor amd micro portions of the version string\n+        if (atoi(kern_osrelease) >= OS_X_10_9_0_KERNEL_MAJOR_VERSION) {\n+          *size = (DEFAULT_MAIN_THREAD_STACK_PAGES*getpagesize());\n+        }\n+      }\n+    }\n+  }\n+  *bottom = (address) stacktop - *size;\n+#elif defined(__OpenBSD__)\n+  stack_t ss;\n+  int rslt = pthread_stackseg_np(pthread_self(), &ss);\n+\n+  if (rslt != 0)\n+    fatal(\"pthread_stackseg_np failed with error = %d\", rslt);\n+\n+  *bottom = (address)((char *)ss.ss_sp - ss.ss_size);\n+  *size   = ss.ss_size;\n+#else\n+  pthread_attr_t attr;\n+\n+  int rslt = pthread_attr_init(&attr);\n+\n+  \/\/ JVM needs to know exact stack location, abort if it fails\n+  if (rslt != 0)\n+    fatal(\"pthread_attr_init failed with error = %d\", rslt);\n+\n+  rslt = pthread_attr_get_np(pthread_self(), &attr);\n+\n+  if (rslt != 0)\n+    fatal(\"pthread_attr_get_np failed with error = %d\", rslt);\n+\n+  if (pthread_attr_getstackaddr(&attr, (void **)bottom) != 0 ||\n+    pthread_attr_getstacksize(&attr, size) != 0) {\n+    fatal(\"Can not locate current stack attributes!\");\n+  }\n+\n+  pthread_attr_destroy(&attr);\n+#endif\n+  assert(os::current_stack_pointer() >= *bottom &&\n+         os::current_stack_pointer() < *bottom + *size, \"just checking\");\n+}\n+\n+address os::current_stack_base() {\n+  address bottom;\n+  size_t size;\n+  current_stack_region(&bottom, &size);\n+  return (bottom + size);\n+}\n+\n+size_t os::current_stack_size() {\n+  \/\/ stack size includes normal stack and HotSpot guard pages\n+  address bottom;\n+  size_t size;\n+  current_stack_region(&bottom, &size);\n+  return size;\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ helper functions for fatal error handler\n+\n+void os::print_context(outputStream *st, const void *context) {\n+  if (context == NULL) return;\n+\n+  const ucontext_t *uc = (const ucontext_t*)context;\n+  st->print_cr(\"Registers:\");\n+  st->print( \" x0=\" INTPTR_FORMAT, (intptr_t)uc->context_x[ 0]);\n+  st->print(\"  x1=\" INTPTR_FORMAT, (intptr_t)uc->context_x[ 1]);\n+  st->print(\"  x2=\" INTPTR_FORMAT, (intptr_t)uc->context_x[ 2]);\n+  st->print(\"  x3=\" INTPTR_FORMAT, (intptr_t)uc->context_x[ 3]);\n+  st->cr();\n+  st->print( \" x4=\" INTPTR_FORMAT, (intptr_t)uc->context_x[ 4]);\n+  st->print(\"  x5=\" INTPTR_FORMAT, (intptr_t)uc->context_x[ 5]);\n+  st->print(\"  x6=\" INTPTR_FORMAT, (intptr_t)uc->context_x[ 6]);\n+  st->print(\"  x7=\" INTPTR_FORMAT, (intptr_t)uc->context_x[ 7]);\n+  st->cr();\n+  st->print( \" x8=\" INTPTR_FORMAT, (intptr_t)uc->context_x[ 8]);\n+  st->print(\"  x9=\" INTPTR_FORMAT, (intptr_t)uc->context_x[ 9]);\n+  st->print(\" x10=\" INTPTR_FORMAT, (intptr_t)uc->context_x[10]);\n+  st->print(\" x11=\" INTPTR_FORMAT, (intptr_t)uc->context_x[11]);\n+  st->cr();\n+  st->print( \"x12=\" INTPTR_FORMAT, (intptr_t)uc->context_x[12]);\n+  st->print(\" x13=\" INTPTR_FORMAT, (intptr_t)uc->context_x[13]);\n+  st->print(\" x14=\" INTPTR_FORMAT, (intptr_t)uc->context_x[14]);\n+  st->print(\" x15=\" INTPTR_FORMAT, (intptr_t)uc->context_x[15]);\n+  st->cr();\n+  st->print( \"x16=\" INTPTR_FORMAT, (intptr_t)uc->context_x[16]);\n+  st->print(\" x17=\" INTPTR_FORMAT, (intptr_t)uc->context_x[17]);\n+  st->print(\" x18=\" INTPTR_FORMAT, (intptr_t)uc->context_x[18]);\n+  st->print(\" x19=\" INTPTR_FORMAT, (intptr_t)uc->context_x[19]);\n+  st->cr();\n+  st->print( \"x20=\" INTPTR_FORMAT, (intptr_t)uc->context_x[20]);\n+  st->print(\" x21=\" INTPTR_FORMAT, (intptr_t)uc->context_x[21]);\n+  st->print(\" x22=\" INTPTR_FORMAT, (intptr_t)uc->context_x[22]);\n+  st->print(\" x23=\" INTPTR_FORMAT, (intptr_t)uc->context_x[23]);\n+  st->cr();\n+  st->print( \"x24=\" INTPTR_FORMAT, (intptr_t)uc->context_x[24]);\n+  st->print(\" x25=\" INTPTR_FORMAT, (intptr_t)uc->context_x[25]);\n+  st->print(\" x26=\" INTPTR_FORMAT, (intptr_t)uc->context_x[26]);\n+  st->print(\" x27=\" INTPTR_FORMAT, (intptr_t)uc->context_x[27]);\n+  st->cr();\n+  st->print( \"x28=\" INTPTR_FORMAT, (intptr_t)uc->context_x[28]);\n+  st->print(\"  fp=\" INTPTR_FORMAT, (intptr_t)uc->context_fp);\n+  st->print(\"  lr=\" INTPTR_FORMAT, (intptr_t)uc->context_lr);\n+  st->print(\"  sp=\" INTPTR_FORMAT, (intptr_t)uc->context_sp);\n+  st->cr();\n+  st->print(  \"pc=\" INTPTR_FORMAT,  (intptr_t)uc->context_pc);\n+  st->print(\" cpsr=\" INTPTR_FORMAT, (intptr_t)uc->context_cpsr);\n+  st->cr();\n+\n+  intptr_t *sp = (intptr_t *)os::Bsd::ucontext_get_sp(uc);\n+  st->print_cr(\"Top of Stack: (sp=\" INTPTR_FORMAT \")\", (intptr_t)sp);\n+  print_hex_dump(st, (address)sp, (address)(sp + 8*sizeof(intptr_t)), sizeof(intptr_t));\n+  st->cr();\n+\n+  \/\/ Note: it may be unsafe to inspect memory near pc. For example, pc may\n+  \/\/ point to garbage if entry point in an nmethod is corrupted. Leave\n+  \/\/ this at the end, and hope for the best.\n+  address pc = os::Posix::ucontext_get_pc(uc);\n+  print_instructions(st, pc, 4\/*native instruction size*\/);\n+  st->cr();\n+}\n+\n+void os::print_register_info(outputStream *st, const void *context) {\n+  if (context == NULL) return;\n+\n+  const ucontext_t *uc = (const ucontext_t*)context;\n+\n+  st->print_cr(\"Register to memory mapping:\");\n+  st->cr();\n+\n+  \/\/ this is horrendously verbose but the layout of the registers in the\n+  \/\/ context does not match how we defined our abstract Register set, so\n+  \/\/ we can't just iterate through the gregs area\n+\n+  \/\/ this is only for the \"general purpose\" registers\n+\n+  st->print(\" x0=\"); print_location(st, uc->context_x[ 0]);\n+  st->print(\" x1=\"); print_location(st, uc->context_x[ 1]);\n+  st->print(\" x2=\"); print_location(st, uc->context_x[ 2]);\n+  st->print(\" x3=\"); print_location(st, uc->context_x[ 3]);\n+  st->print(\" x4=\"); print_location(st, uc->context_x[ 4]);\n+  st->print(\" x5=\"); print_location(st, uc->context_x[ 5]);\n+  st->print(\" x6=\"); print_location(st, uc->context_x[ 6]);\n+  st->print(\" x7=\"); print_location(st, uc->context_x[ 7]);\n+  st->print(\" x8=\"); print_location(st, uc->context_x[ 8]);\n+  st->print(\" x9=\"); print_location(st, uc->context_x[ 9]);\n+  st->print(\"x10=\"); print_location(st, uc->context_x[10]);\n+  st->print(\"x11=\"); print_location(st, uc->context_x[11]);\n+  st->print(\"x12=\"); print_location(st, uc->context_x[12]);\n+  st->print(\"x13=\"); print_location(st, uc->context_x[13]);\n+  st->print(\"x14=\"); print_location(st, uc->context_x[14]);\n+  st->print(\"x15=\"); print_location(st, uc->context_x[15]);\n+  st->print(\"x16=\"); print_location(st, uc->context_x[16]);\n+  st->print(\"x17=\"); print_location(st, uc->context_x[17]);\n+  st->print(\"x18=\"); print_location(st, uc->context_x[18]);\n+  st->print(\"x19=\"); print_location(st, uc->context_x[19]);\n+  st->print(\"x20=\"); print_location(st, uc->context_x[20]);\n+  st->print(\"x21=\"); print_location(st, uc->context_x[21]);\n+  st->print(\"x22=\"); print_location(st, uc->context_x[22]);\n+  st->print(\"x23=\"); print_location(st, uc->context_x[23]);\n+  st->print(\"x24=\"); print_location(st, uc->context_x[24]);\n+  st->print(\"x25=\"); print_location(st, uc->context_x[25]);\n+  st->print(\"x26=\"); print_location(st, uc->context_x[26]);\n+  st->print(\"x27=\"); print_location(st, uc->context_x[27]);\n+  st->print(\"x28=\"); print_location(st, uc->context_x[28]);\n+\n+  st->cr();\n+}\n+\n+void os::setup_fpu() {\n+}\n+\n+#ifndef PRODUCT\n+void os::verify_stack_alignment() {\n+  assert(((intptr_t)os::current_stack_pointer() & (StackAlignmentInBytes-1)) == 0, \"incorrect stack alignment\");\n+}\n+#endif\n+\n+int os::extra_bang_size_in_bytes() {\n+  \/\/ AArch64 does not require the additional stack bang.\n+  return 0;\n+}\n+\n+void os::current_thread_enable_wx_impl(WXMode mode) {\n+  pthread_jit_write_protect_np(mode == WXExec);\n+}\n+\n+extern \"C\" {\n+  int SpinPause() {\n+    return 0;\n+  }\n+\n+  void _Copy_conjoint_jshorts_atomic(const jshort* from, jshort* to, size_t count) {\n+    if (from > to) {\n+      const jshort *end = from + count;\n+      while (from < end)\n+        *(to++) = *(from++);\n+    }\n+    else if (from < to) {\n+      const jshort *end = from;\n+      from += count - 1;\n+      to   += count - 1;\n+      while (from >= end)\n+        *(to--) = *(from--);\n+    }\n+  }\n+  void _Copy_conjoint_jints_atomic(const jint* from, jint* to, size_t count) {\n+    if (from > to) {\n+      const jint *end = from + count;\n+      while (from < end)\n+        *(to++) = *(from++);\n+    }\n+    else if (from < to) {\n+      const jint *end = from;\n+      from += count - 1;\n+      to   += count - 1;\n+      while (from >= end)\n+        *(to--) = *(from--);\n+    }\n+  }\n+  void _Copy_conjoint_jlongs_atomic(const jlong* from, jlong* to, size_t count) {\n+    if (from > to) {\n+      const jlong *end = from + count;\n+      while (from < end)\n+        os::atomic_copy64(from++, to++);\n+    }\n+    else if (from < to) {\n+      const jlong *end = from;\n+      from += count - 1;\n+      to   += count - 1;\n+      while (from >= end)\n+        os::atomic_copy64(from--, to--);\n+    }\n+  }\n+\n+  void _Copy_arrayof_conjoint_bytes(const HeapWord* from,\n+                                    HeapWord* to,\n+                                    size_t    count) {\n+    memmove(to, from, count);\n+  }\n+  void _Copy_arrayof_conjoint_jshorts(const HeapWord* from,\n+                                      HeapWord* to,\n+                                      size_t    count) {\n+    memmove(to, from, count * 2);\n+  }\n+  void _Copy_arrayof_conjoint_jints(const HeapWord* from,\n+                                    HeapWord* to,\n+                                    size_t    count) {\n+    memmove(to, from, count * 4);\n+  }\n+  void _Copy_arrayof_conjoint_jlongs(const HeapWord* from,\n+                                     HeapWord* to,\n+                                     size_t    count) {\n+    memmove(to, from, count * 8);\n+  }\n+};\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/os_bsd_aarch64.cpp","additions":736,"deletions":0,"binary":false,"changes":736,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_BSD_AARCH64_THREAD_BSD_AARCH64_HPP\n+#define OS_CPU_BSD_AARCH64_THREAD_BSD_AARCH64_HPP\n+\n+ private:\n+  void pd_initialize() {\n+    _anchor.clear();\n+  }\n+\n+  frame pd_last_frame();\n+\n+ public:\n+  static ByteSize last_Java_fp_offset()          {\n+    return byte_offset_of(JavaThread, _anchor) + JavaFrameAnchor::last_Java_fp_offset();\n+  }\n+\n+  static ByteSize saved_fp_address_offset() {\n+    return byte_offset_of(JavaThread, _anchor) + JavaFrameAnchor::saved_fp_address_offset();\n+  }\n+\n+  bool pd_get_top_frame_for_signal_handler(frame* fr_addr, void* ucontext,\n+    bool isInJava);\n+\n+  bool pd_get_top_frame_for_profiling(frame* fr_addr, void* ucontext, bool isInJava);\n+\n+private:\n+  bool pd_get_top_frame(frame* fr_addr, void* ucontext, bool isInJava);\n+public:\n+\n+  static Thread *aarch64_get_thread_helper() {\n+    return Thread::current();\n+  }\n+\n+#endif \/\/ OS_CPU_BSD_AARCH64_THREAD_BSD_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/thread_bsd_aarch64.hpp","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -36,0 +36,6 @@\n+private:\n+\n+  static void current_thread_enable_wx_impl(WXMode mode) { }\n+\n+public:\n+\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/os_windows_aarch64.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1271,0 +1271,2 @@\n+  Thread::WXWriteFromExecSetter wx_write;\n+\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+  Thread::WXWriteVerifier __wx_write;       \\\n@@ -47,0 +48,1 @@\n+  Thread::WXWriteVerifier __wx_write;       \\\n","filename":"src\/hotspot\/share\/ci\/ciUtilities.inline.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -295,0 +295,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;\n@@ -341,0 +342,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;\n@@ -753,0 +755,1 @@\n+        Thread::WXExecFromWriteSetter wx_exec;\n@@ -803,0 +806,1 @@\n+          Thread::WXExecFromWriteSetter wx_exec;\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -417,0 +417,1 @@\n+    Thread::WXExecFromWriteSetter wx_exec;\n@@ -445,0 +446,1 @@\n+    Thread::WXExecFromWriteSetter wx_exec;\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -318,0 +318,1 @@\n+    Thread::WXExecFromWriteSetter wx_exec;\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1798,0 +1798,1 @@\n+    Thread::WXWriteVerifier wx_write;\n@@ -2093,0 +2094,1 @@\n+    Thread::WXWriteVerifier wx_write;\n@@ -2283,0 +2285,1 @@\n+    Thread::WXWriteVerifier wx_write;\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -934,0 +934,1 @@\n+      Thread::WXWriteVerifier wx_write;\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -128,0 +128,1 @@\n+  Thread::WXWriteFromExecSetter __wx_write;   \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -870,0 +870,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;                              \\\n@@ -1030,0 +1031,1 @@\n+    Thread::WXExecFromWriteSetter wx_exec;\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,2 +35,1 @@\n-  friend class LogStreamTest_TestLineBufferAllocation_vm_Test;\n-  friend class LogStreamTest_TestLineBufferAllocationCap_vm_Test;\n+  friend class LogStreamTest;\n","filename":"src\/hotspot\/share\/logging\/logStream.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1429,0 +1429,2 @@\n+  Thread::WXWriteFromExecSetter wx_write;\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3643,0 +3643,1 @@\n+    Thread::enable_wx_from_write(WXExec);\n@@ -3734,0 +3735,1 @@\n+  Thread::enable_wx_from_exec(WXWrite);\n@@ -3794,0 +3796,1 @@\n+  thread->init_wx();\n@@ -3867,0 +3870,1 @@\n+  Thread::enable_wx_from_write(WXExec);\n@@ -3921,0 +3925,1 @@\n+  Thread::enable_wx_from_exec(WXWrite);\n@@ -3934,0 +3939,4 @@\n+  \/\/ Go to the execute mode, the initial state of the thread on creation.\n+  \/\/ Use os interface as the thread is not a java one anymore.\n+  os::current_thread_enable_wx(WXExec);\n+\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+      Thread::WXWriteFromExecSetter __wx_write;                        \\\n","filename":"src\/hotspot\/share\/prims\/jniCheck.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3430,0 +3430,1 @@\n+    Thread::WXWriteVerifier wx_write;\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -436,0 +436,2 @@\n+    <xsl:text>Thread::WXWriteFromExecSetter __wx_write;<\/xsl:text>\n+    <xsl:value-of select=\"$space\"\/>\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnter.xsl","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -180,0 +180,1 @@\n+    Thread::WXExecVerifier __wx_exec;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -93,0 +93,1 @@\n+  Thread::WXExecFromWriteSetter _wx_exec;\n@@ -99,0 +100,1 @@\n+    _wx_exec(),\n@@ -108,0 +110,1 @@\n+  Thread::WXExecFromWriteSetter _wx_exec;\n@@ -112,1 +115,1 @@\n-  JvmtiThreadEventTransition(Thread *thread) : _rm(), _hm(thread) {\n+  JvmtiThreadEventTransition(Thread *thread) : _rm(), _hm(thread), _wx_exec() {\n@@ -402,0 +405,1 @@\n+    Thread::WXExecVerifier __wx_exec;\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -87,0 +87,1 @@\n+    Thread::WXExecFromWriteSetter wx_exec;\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1580,0 +1580,1 @@\n+    Thread::WXExecFromWriteSetter wx_exec;\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -415,0 +415,1 @@\n+  Thread::WXWriteVerifier wx_write;\n","filename":"src\/hotspot\/share\/prims\/nativeLookup.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -183,0 +183,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;\n","filename":"src\/hotspot\/share\/prims\/scopedMemoryAccess.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -407,0 +407,1 @@\n+    Thread::WXExecFromWriteSetter wx_exec;\n@@ -720,0 +721,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;\n@@ -905,0 +907,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;\n@@ -1160,0 +1163,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -761,0 +761,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;\n@@ -1149,0 +1150,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;\n@@ -1163,0 +1165,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;\n@@ -1203,0 +1206,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;\n@@ -1224,0 +1228,1 @@\n+    Thread::WXExecFromWriteSetter wx_exec;\n@@ -1233,0 +1238,1 @@\n+    Thread::WXExecFromWriteSetter wx_exec;\n@@ -1242,0 +1248,1 @@\n+    Thread::WXExecFromWriteSetter wx_exec;\n@@ -1251,0 +1258,1 @@\n+    Thread::WXExecFromWriteSetter wx_exec;\n@@ -1260,0 +1268,1 @@\n+    Thread::WXExecFromWriteSetter wx_exec;\n@@ -1269,0 +1278,1 @@\n+    Thread::WXExecFromWriteSetter wx_exec;\n@@ -1278,0 +1288,1 @@\n+    Thread::WXExecFromWriteSetter wx_exec;\n@@ -1287,0 +1298,1 @@\n+    Thread::WXExecFromWriteSetter wx_exec;\n@@ -1296,0 +1308,1 @@\n+    Thread::WXExecFromWriteSetter wx_exec;\n@@ -1345,0 +1358,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;\n@@ -1356,0 +1370,1 @@\n+    Thread::WXWriteFromExecSetter wx_write;\n@@ -1421,0 +1436,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;\n@@ -1493,0 +1509,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;\n@@ -1576,0 +1593,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;\n@@ -1606,0 +1624,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;\n@@ -1826,0 +1845,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;\n@@ -1844,0 +1864,1 @@\n+    Thread::WXExecFromWriteSetter wx_exec;\n@@ -1854,0 +1875,1 @@\n+    Thread::WXExecFromWriteSetter wx_exec;\n@@ -1864,0 +1886,1 @@\n+    Thread::WXExecFromWriteSetter wx_exec;\n@@ -1874,0 +1897,1 @@\n+    Thread::WXExecFromWriteSetter wx_exec;\n@@ -1884,0 +1908,1 @@\n+    Thread::WXExecFromWriteSetter wx_exec;\n@@ -1894,0 +1919,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;\n@@ -2106,0 +2132,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;\n@@ -2137,0 +2164,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;\n@@ -2142,0 +2170,1 @@\n+    Thread::WXExecVerifier wx_exec;\n@@ -2162,0 +2191,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;\n@@ -2183,0 +2213,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;\n@@ -2316,0 +2347,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2465,0 +2465,1 @@\n+  Thread::WXWriteFromExecSetter wx_write;\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1849,1 +1849,1 @@\n-          \"Unguard page and retry on no-execute fault (Win32 only) \"        \\\n+          \"Unguard page and retry on no-execute fault \"                     \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -292,0 +292,1 @@\n+  Thread::WXWriteVerifier _wx_write;\n@@ -293,1 +294,1 @@\n-  ThreadInVMfromJavaNoAsyncException(JavaThread* thread) : ThreadStateTransition(thread) {\n+  ThreadInVMfromJavaNoAsyncException(JavaThread* thread) : ThreadStateTransition(thread), _wx_write() {\n@@ -360,0 +361,1 @@\n+    Thread::WXWriteFromExecSetter __wx_write;                        \\\n@@ -386,0 +388,1 @@\n+    Thread::WXWriteFromExecSetter __wx_write;                        \\\n@@ -394,0 +397,1 @@\n+    Thread::WXWriteFromExecSetter __wx_write;                        \\\n@@ -423,0 +427,1 @@\n+    Thread::WXWriteFromExecSetter __wx_write;                        \\\n@@ -433,0 +438,1 @@\n+    Thread::WXWriteFromExecSetter __wx_write;                        \\\n@@ -447,0 +453,1 @@\n+    Thread::WXWriteFromExecSetter __wx_write;                        \\\n@@ -456,0 +463,1 @@\n+    Thread::WXWriteFromExecSetter __wx_write;                        \\\n@@ -465,0 +473,1 @@\n+    Thread::WXWriteFromExecSetter __wx_write;                        \\\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.inline.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -82,1 +82,0 @@\n-\n@@ -112,0 +111,2 @@\n+\n+  Thread::enable_wx_from_write(WXExec);\n@@ -118,0 +119,2 @@\n+  Thread::enable_wx_from_exec(WXWrite);\n+\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-#include \"runtime\/stubRoutines.hpp\"\n+#include \"runtime\/stubRoutines.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-#include \"runtime\/stubRoutines.hpp\"\n+#include \"runtime\/stubRoutines.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,0 +80,5 @@\n+enum WXMode {\n+  WXWrite,\n+  WXExec\n+};\n+\n@@ -930,0 +935,6 @@\n+  \/\/ If the JVM is running in W^X mode, enable write or execute access to\n+  \/\/ writeable and executable pages. No-op otherwise.\n+  static inline void current_thread_enable_wx(WXMode mode) {\n+    current_thread_enable_wx_impl(mode);\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -761,0 +761,2 @@\n+  Thread::WXWriteFromExecSetter wx_write;\n+\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -538,0 +538,1 @@\n+  Thread::WXWriteFromExecSetter wx_write;\n@@ -1948,0 +1949,2 @@\n+  Thread::WXWriteFromExecSetter wx_write;\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"runtime\/stubRoutines.hpp\"\n+#include \"runtime\/stubRoutines.inline.hpp\"\n@@ -289,0 +289,2 @@\n+  os::current_thread_enable_wx(WXExec);\n+\n@@ -362,0 +364,2 @@\n+  os::current_thread_enable_wx(WXWrite);\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -491,20 +491,0 @@\n-\/\/ Safefetch allows to load a value from a location that's not known\n-\/\/ to be valid. If the load causes a fault, the error value is returned.\n-inline int SafeFetch32(int* adr, int errValue) {\n-  assert(StubRoutines::SafeFetch32_stub(), \"stub not yet generated\");\n-  return StubRoutines::SafeFetch32_stub()(adr, errValue);\n-}\n-inline intptr_t SafeFetchN(intptr_t* adr, intptr_t errValue) {\n-  assert(StubRoutines::SafeFetchN_stub(), \"stub not yet generated\");\n-  return StubRoutines::SafeFetchN_stub()(adr, errValue);\n-}\n-\n-\n-\/\/ returns true if SafeFetch32 and SafeFetchN can be used safely (stubroutines are already generated)\n-inline bool CanUseSafeFetch32() {\n-  return StubRoutines::SafeFetch32_stub() ? true : false;\n-}\n-\n-inline bool CanUseSafeFetchN() {\n-  return StubRoutines::SafeFetchN_stub() ? true : false;\n-}\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -327,0 +327,2 @@\n+\n+  DEBUG_ONLY(_wx_init = false);\n@@ -390,0 +392,2 @@\n+  this->init_wx();\n+\n@@ -2510,0 +2514,2 @@\n+  Thread::WXWriteFromExecSetter wx_write;\n+\n@@ -3446,0 +3452,2 @@\n+  os::current_thread_enable_wx(WXWrite);\n+\n@@ -3549,0 +3557,1 @@\n+  main_thread->init_wx();\n@@ -3983,0 +3992,1 @@\n+      Thread::WXExecFromWriteSetter wx_exec;\n@@ -4002,0 +4012,1 @@\n+      Thread::WXExecFromWriteSetter wx_exec;\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -841,0 +841,75 @@\n+\n+private:\n+#ifdef ASSERT\n+  bool _wx_init;\n+  WXMode _wx_state;\n+  static inline void verify_wx_init(WXMode state) {\n+    Thread* current = Thread::current();\n+    assert(!current->_wx_init, \"second init\");\n+    current->_wx_init = true;\n+    current->_wx_state = state;\n+  }\n+  static inline void verify_wx_transition(WXMode from, WXMode to) {\n+    Thread* current = Thread::current();\n+    assert(current->_wx_init, \"no init\");\n+    assert(current->_wx_state == from, \"wrong state\");\n+    current->_wx_init = true;\n+    current->_wx_state = to;\n+  }\n+  static inline void verify_wx_state(WXMode now) {\n+    Thread* current = Thread::current();\n+    assert(current->_wx_init, \"no init\");\n+    assert(current->_wx_state == now, \"wrong state\");\n+  }\n+#else\n+  static inline void verify_wx_init(WXMode state) { }\n+  static inline void verify_wx_transition(WXMode from, WXMode to) { }\n+  static inline void verify_wx_state(WXMode now) { }\n+#endif \/\/ ASSERT\n+public:\n+  void init_wx() {\n+    WXMode init_mode = WXWrite;\n+    verify_wx_init(init_mode);\n+    os::current_thread_enable_wx(init_mode);\n+  }\n+  static inline void enable_wx_from_write(WXMode to) {\n+    verify_wx_transition(WXWrite, to);\n+    os::current_thread_enable_wx(to);\n+  }\n+  static inline void enable_wx_from_exec(WXMode to) {\n+    verify_wx_transition(WXExec, to);\n+    os::current_thread_enable_wx(to);\n+  }\n+\n+  class WXWriteFromExecSetter {\n+  public:\n+    WXWriteFromExecSetter() {\n+      enable_wx_from_exec(WXWrite);\n+    }\n+    ~WXWriteFromExecSetter() {\n+      enable_wx_from_write(WXExec);\n+    }\n+  };\n+\n+  class WXExecFromWriteSetter {\n+  public:\n+    WXExecFromWriteSetter() {\n+      enable_wx_from_write(WXExec);\n+    }\n+    ~WXExecFromWriteSetter() {\n+      enable_wx_from_exec(WXWrite);\n+    }\n+  };\n+\n+  class WXWriteVerifier {\n+  public:\n+    WXWriteVerifier() {\n+      verify_wx_state(WXWrite);\n+    }\n+  };\n+  class WXExecVerifier {\n+  public:\n+    WXExecVerifier() {\n+      verify_wx_state(WXExec);\n+    }\n+  };\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":75,"deletions":0,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -1092,0 +1092,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-#if (defined(_NMT_NOINLINE_) || defined(_WINDOWS) || !defined(_LP64) || defined(PPC64))\n+#if (defined(_NMT_NOINLINE_) || defined(_WINDOWS) || !defined(_LP64) || defined(PPC64) || (defined(BSD) && defined (__aarch64__)))\n","filename":"src\/hotspot\/share\/utilities\/nativeCallStack.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"runtime\/stubRoutines.inline.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import sun.jvm.hotspot.runtime.bsd_aarch64.BsdAARCH64JavaThreadPDAccess;\n@@ -135,0 +136,2 @@\n+            } else if (cpu.equals(\"aarch64\")) {\n+                access = new BsdAARCH64JavaThreadPDAccess();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/Threads.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,0 +34,6 @@\n+  const char* current_line_buffer(LogStream& ls) {\n+    return ls._current_line.buffer();\n+  }\n+  void current_line_reset(LogStream& ls) {\n+    ls._current_line.reset();\n+  }\n@@ -83,1 +89,1 @@\n-      const char* const line_buffer = ls._current_line.buffer();\n+      const char* const line_buffer = current_line_buffer(ls);\n@@ -99,1 +105,1 @@\n-  const char* const line_buffer = ls._current_line.buffer();\n+  const char* const line_buffer = current_line_buffer(ls);\n@@ -102,1 +108,1 @@\n-  ls._current_line.reset();\n+  current_line_reset(ls);\n","filename":"test\/hotspot\/gtest\/logging\/test_logStream.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"runtime\/stubRoutines.hpp\"\n+#include \"runtime\/stubRoutines.inline.hpp\"\n","filename":"test\/hotspot\/gtest\/runtime\/test_safefetch.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -79,1 +79,12 @@\n-#define TEST_VM(category, name) GTEST_TEST(category, CONCAT(name, _vm))\n+#define TEST_VM(category, name)                                     \\\n+  class category ## _  ## name ## _vm : public ::testing::Test {    \\\n+  public:                                                           \\\n+    static void do_test();                                          \\\n+  };                                                                \\\n+                                                                    \\\n+  GTEST_TEST(category, CONCAT(name, _vm)) {                         \\\n+    Thread::WXWriteFromExecSetter wx_write;                         \\\n+    category ## _ ## name ## _vm::do_test();                        \\\n+  }                                                                 \\\n+                                                                    \\\n+  void category ## _ ## name ## _vm::do_test()\n@@ -82,2 +93,20 @@\n-  GTEST_TEST_(test_fixture, name ## _vm, test_fixture,              \\\n-              ::testing::internal::GetTypeId<test_fixture>())\n+  class test_fixture ## _  ## name ## _vm_f : public test_fixture { \\\n+  public:                                                           \\\n+    void SetUp() {                                                  \\\n+      Thread::WXWriteFromExecSetter wx_write;                       \\\n+      test_fixture::SetUp();                                        \\\n+    }                                                               \\\n+  protected:                                                        \\\n+    void do_test();                                                 \\\n+  };                                                                \\\n+                                                                    \\\n+  GTEST_TEST_(test_fixture ## _ ## name,                            \\\n+      name ## _vm,                                                  \\\n+      test_fixture ## _ ## name ## _vm_f,                           \\\n+      ::testing::internal::GetTypeId<                               \\\n+        test_fixture ## _ ## name ## _vm_f>()) {                    \\\n+    Thread::WXWriteFromExecSetter wx_write;                         \\\n+    do_test();                                                      \\\n+  }                                                                 \\\n+                                                                    \\\n+  void test_fixture ## _ ## name ## _vm_f::do_test()\n@@ -89,0 +118,1 @@\n+    Thread::WXWriteFromExecSetter wx_write;                         \\\n@@ -108,0 +138,1 @@\n+    Thread::WXWriteFromExecSetter wx_write;                         \\\n@@ -130,0 +161,1 @@\n+    Thread::WXWriteFromExecSetter wx_write;                         \\\n","filename":"test\/hotspot\/gtest\/unittest.hpp","additions":35,"deletions":3,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <stdbool.h>\n+\n+#include <string.h>\n+\n+#include \"jni.h\"\n+\n+#if defined(__APPLE__) && defined(__aarch64__)\n+\n+#include <pthread.h>\n+#include <sys\/mman.h>\n+\n+JavaVM* jvm;\n+\n+static void* codegen;\n+\n+static int thread_start2(int val) {\n+  JNIEnv *env;\n+  jclass class_id;\n+  jmethodID method_id;\n+  int res;\n+\n+  printf(\"Native thread is running and attaching ...\\n\");\n+\n+  res = (*jvm)->AttachCurrentThread(jvm, (void **)&env, NULL);\n+  if (res != JNI_OK) {\n+    fprintf(stderr, \"Test ERROR. Can't attach current thread: %d\\n\", res);\n+    exit(1);\n+  }\n+\n+  res = (*jvm)->DetachCurrentThread(jvm);\n+  if (res != JNI_OK) {\n+    fprintf(stderr, \"Test ERROR. Can't detach current thread: %d\\n\", res);\n+    exit(1);\n+  }\n+\n+  printf(\"Native thread is about to finish\\n\");\n+  return 1 + val;\n+}\n+\n+static int trampoline(int(*fn)(int), int arg) {\n+  int val = fn(arg);\n+  \/\/ ensure code in MAP_JIT area after target function returns\n+  return 1 + val;\n+}\n+\n+static void * thread_start(void* unused) {\n+  int val = ((int(*)(int(*)(int),int))codegen)(thread_start2, 10);\n+  printf(\"return val = %d\\n\", val);\n+  return NULL;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_TestCodegenAttach_testCodegenAttach\n+(JNIEnv *env, jclass cls) {\n+\n+  codegen = mmap(NULL, 0x1000,\n+      PROT_READ | PROT_WRITE | PROT_EXEC,\n+      MAP_PRIVATE | MAP_ANONYMOUS | MAP_JIT, -1, 0);\n+  if (codegen == MAP_FAILED) {\n+    perror(\"mmap\");\n+    exit(1);\n+  }\n+\n+  pthread_jit_write_protect_np(false);\n+\n+  memcpy(codegen, trampoline, 128);\n+\n+  pthread_jit_write_protect_np(true);\n+\n+  pthread_t thread;\n+  int res = (*env)->GetJavaVM(env, &jvm);\n+  if (res != JNI_OK) {\n+    fprintf(stderr, \"Test ERROR. Can't extract JavaVM: %d\\n\", res);\n+    exit(1);\n+  }\n+\n+  if ((res = pthread_create(&thread, NULL, thread_start, NULL)) != 0) {\n+    fprintf(stderr, \"TEST ERROR: pthread_create failed: %s (%d)\\n\", strerror(res), res);\n+    exit(1);\n+  }\n+\n+  if ((res = pthread_join(thread, NULL)) != 0) {\n+    fprintf(stderr, \"TEST ERROR: pthread_join failed: %s (%d)\\n\", strerror(res), res);\n+    exit(1);\n+  }\n+}\n+\n+#else\n+\n+JNIEXPORT void JNICALL\n+Java_TestCodegenAttach_testCodegenAttach\n+(JNIEnv *env, jclass cls) {\n+  printf(\"should not reach here\\n\");\n+  exit(1);\n+}\n+\n+#endif \/\/ __APPLE__ && __aarch64__\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/codegenAttachThread\/libcodegenAttach.c","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"}]}