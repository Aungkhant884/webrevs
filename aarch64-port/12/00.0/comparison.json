{"files":[{"patch":"@@ -133,0 +133,1 @@\n+      BUILD_CC_DISABLE_WARNING_PREFIX=\"-wd\"\n@@ -145,0 +146,1 @@\n+      BUILD_CC_DISABLE_WARNING_PREFIX=\"-Wno-\"\n@@ -156,1 +158,0 @@\n-      BUILD_CC_DISABLE_WARNING_PREFIX=\"-Wno-\"\n@@ -753,0 +754,12 @@\n+  if test \"x$TOOLCHAIN_TYPE\" = xmicrosoft && test \"x$ENABLE_REPRODUCIBLE_BUILD\" = xtrue; then\n+    # Enabling deterministic creates warnings if __DATE__ or __TIME__ are\n+    # used, and since we are, silence that warning.\n+    REPRODUCIBLE_CFLAGS=\"-experimental:deterministic -wd5048\"\n+    FLAGS_COMPILER_CHECK_ARGUMENTS(ARGUMENT: [${REPRODUCIBLE_CFLAGS}],\n+        PREFIX: $3,\n+        IF_FALSE: [\n+            REPRODUCIBLE_CFLAGS=\n+        ]\n+    )\n+  fi\n+\n@@ -771,0 +784,23 @@\n+    elif test \"x$TOOLCHAIN_TYPE\" = xmicrosoft &&\n+        test \"x$ENABLE_REPRODUCIBLE_BUILD\" = xtrue; then\n+      # There is a known issue with the pathmap if the mapping is made to the\n+      # empty string. Add a minimal string \"s\" as prefix to work around this.\n+      workspace_root_win=`$FIXPATH_BASE print \"${WORKSPACE_ROOT%\/}\"`\n+      # PATHMAP_FLAGS is also added to LDFLAGS in flags-ldflags.m4.\n+      PATHMAP_FLAGS=\"-pathmap:${workspace_root_win\/\/\\\/\/\\\\\\\\}=s \\\n+          -pathmap:${workspace_root_win}=s\"\n+      FILE_MACRO_CFLAGS=\"$PATHMAP_FLAGS\"\n+      FLAGS_COMPILER_CHECK_ARGUMENTS(ARGUMENT: [${FILE_MACRO_CFLAGS}],\n+          PREFIX: $3,\n+          IF_FALSE: [\n+              PATHMAP_FLAGS=\n+              FILE_MACRO_CFLAGS=\n+          ]\n+      )\n+    fi\n+\n+    AC_MSG_CHECKING([how to prevent absolute paths in output])\n+    if test \"x$FILE_MACRO_CFLAGS\" != x; then\n+      AC_MSG_RESULT([using compiler options])\n+    else\n+      AC_MSG_RESULT([using relative paths])\n@@ -779,1 +815,2 @@\n-      $WARNING_CFLAGS $WARNING_CFLAGS_JVM $JVM_PICFLAG $FILE_MACRO_CFLAGS\"\n+      $WARNING_CFLAGS $WARNING_CFLAGS_JVM $JVM_PICFLAG $FILE_MACRO_CFLAGS \\\n+      $REPRODUCIBLE_CFLAGS\"\n@@ -784,1 +821,1 @@\n-      $FILE_MACRO_CFLAGS\"\n+      $FILE_MACRO_CFLAGS $REPRODUCIBLE_CFLAGS\"\n","filename":"make\/autoconf\/flags-cflags.m4","additions":40,"deletions":3,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -235,0 +235,8 @@\n+  # For the microsoft toolchain, we need to get the SYSROOT flags from the\n+  # Visual Studio environment. Currently we cannot handle this as a separate\n+  # build toolchain.\n+  if test \"x$1\" = x && test \"x$OPENJDK_BUILD_OS\" = \"xwindows\" \\\n+      && test \"x$TOOLCHAIN_TYPE\" = \"xmicrosoft\"; then\n+    TOOLCHAIN_SETUP_VISUAL_STUDIO_ENV\n+  fi\n+\n@@ -243,0 +251,1 @@\n+\n@@ -267,4 +276,0 @@\n-  AC_SUBST(GLOBAL_CFLAGS)\n-  AC_SUBST(GLOBAL_CXXFLAGS)\n-  AC_SUBST(GLOBAL_LDFLAGS)\n-  AC_SUBST(GLOBAL_CPPFLAGS)\n@@ -289,0 +294,8 @@\n+\n+  if test \"x$TOOLCHAIN_TYPE\" = xmicrosoft; then\n+    # When autoconf sends both compiler and linker flags to cl.exe at the same\n+    # time, linker flags must be last at the command line. Achieve this by\n+    # moving them to LIBS.\n+    LIBS=\"$LIBS -link $LDFLAGS\"\n+    LDFLAGS=\"\"\n+  fi\n@@ -379,3 +392,0 @@\n-  AC_SUBST(BUILD_SYSROOT_CFLAGS)\n-  AC_SUBST(BUILD_SYSROOT_LDFLAGS)\n-\n","filename":"make\/autoconf\/flags.m4","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-        [--enable-jvm-feature-FEATURE], \n+        [--enable-jvm-feature-FEATURE],\n@@ -481,1 +481,1 @@\n-        epsilongc g1gc graal jvmci minimal shenandoahgc zgc\"\n+        graal jvmci minimal zgc\"\n","filename":"make\/autoconf\/jvm-features.m4","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -222,1 +222,1 @@\n-    *mingw*)\n+    *msys*)\n@@ -224,1 +224,1 @@\n-      VAR_OS_ENV=windows.msys\n+      VAR_OS_ENV=windows.msys2\n","filename":"make\/autoconf\/platform.m4","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -75,2 +75,2 @@\n-      \"directory\": \"$(strip $2)\"$(COMMA) \\\n-      \"file\": \"$(strip $3)\"$(COMMA) \\\n+      \"directory\": \"$(strip $(call FixPath, $2))\"$(COMMA) \\\n+      \"file\": \"$(strip $(call FixPath, $3))\"$(COMMA) \\\n@@ -78,1 +78,1 @@\n-        $(subst $(FIXPATH),,$4))))\" \\\n+        $(subst $(FIXPATH),,$(call FixPath, $4)))))\" \\\n@@ -178,6 +178,0 @@\n-ifeq ($(call isBuildOsEnv, windows.cygwin), true)\n-  UNIX_PATH_PREFIX := \/cygdrive\n-else ifeq ($(call isBuildOsEnv, windows.msys), true)\n-  UNIX_PATH_PREFIX :=\n-endif\n-\n@@ -191,1 +185,1 @@\n-    -e 's|^\\([a-zA-Z]\\):|$(UNIX_PATH_PREFIX)\/\\1|g' \\\n+    -e 's|^\\([a-zA-Z]\\):|$(WINENV_PREFIX)\/\\1|g' \\\n@@ -240,2 +234,11 @@\n-  # When compiling with relative paths, the deps file comes out with relative\n-  # paths.\n+  # When compiling with relative paths, the deps file may come out with relative\n+  # paths, and that path may start with '.\/'. First remove any leading .\/, then\n+  # add WORKSPACE_ROOT to any line not starting with \/, while allowing for\n+  # leading spaces. There may also be multiple entries on the same line, so start\n+  # with splitting such lines.\n+  # Non GNU sed (BSD on macosx) cannot substitue in literal \\n using regex.\n+  # Instead use a bash escaped literal newline. To avoid having unmatched quotes\n+  # ruin the ability for an editor to properly syntax highlight this file, define\n+  # that newline sequence as a separate variable and add the closing quote behind\n+  # a comment.\n+  sed_newline := \\'$$'\\n''#'\n@@ -243,1 +246,7 @@\n-\t$(SED) -e 's|^\\([ ]*\\)|\\1$(WORKSPACE_ROOT)|' $1.tmp > $1\n+\t$(SED) \\\n+\t    -e 's|\\([^ ]\\) \\{1,\\}\\([^\\\\:]\\)|\\1 \\\\$(sed_newline) \\2|g' \\\n+\t    $1.tmp \\\n+\t    | $(SED) \\\n+\t        -e 's|^\\([ ]*\\)\\.\/|\\1|' \\\n+\t        -e '\/^[ ]*[^\/ ]\/s|^\\([ ]*\\)|\\1$(WORKSPACE_ROOT)\/|' \\\n+\t        > $1\n@@ -530,1 +539,1 @@\n-      $1_SUFFIX := $(EXE_SUFFIX)\n+      $1_SUFFIX := $(EXECUTABLE_SUFFIX)\n@@ -808,1 +817,2 @@\n-            $$($1_OPT_CFLAGS) -x c++-header -c $(C_FLAG_DEPS) $$($1_PCH_DEPS_FILE)\n+            $$($1_OPT_CFLAGS) -x c++-header -c $(C_FLAG_DEPS) \\\n+            $$(addsuffix .tmp, $$($1_PCH_DEPS_FILE))\n@@ -815,0 +825,1 @@\n+\t\t$$(call fix-deps-file, $$($1_PCH_DEPS_FILE))\n@@ -1149,0 +1160,3 @@\n+                 ifeq ($(call isBuildOsEnv, windows.wsl2), true)\n+\t\t    $$(CHMOD) +x $$($1_TARGET)\n+                 endif\n","filename":"make\/common\/NativeCompilation.gmk","additions":29,"deletions":15,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -174,1 +174,1 @@\n-\t$(NAWK) $(INSERT_FILENAME_AWK_SCRIPT) $^ > $@\n+\t$(AWK) $(INSERT_FILENAME_AWK_SCRIPT) $^ > $@\n@@ -211,1 +211,1 @@\n-\t$(NAWK) \\\n+\t$(AWK) \\\n","filename":"make\/hotspot\/gensrc\/GensrcAdlc.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -477,0 +477,5 @@\n+  # Early re-canonizing has to be disabled to workaround an internal XlC compiler error\n+  # when building libharfbuzz\n+  ifeq ($(call isTargetOs, aix), true)\n+    LIBHARFBUZZ_CFLAGS += -qdebug=necan\n+  endif\n","filename":"make\/modules\/java.desktop\/lib\/Awt2dLibraries.gmk","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-  SA_CFLAGS := -D_WINDOWS -D_DEBUG -D_CONSOLE -D_MBCS -EHsc\n+  SA_CFLAGS := -D_WINDOWS -D_DEBUG -D_CONSOLE -EHsc\n@@ -68,1 +68,1 @@\n-    LDFLAGS := $(LDFLAGS_JDKLIB), \\\n+    LDFLAGS := $(LDFLAGS_JDKLIB) $(call SET_SHARED_LIBRARY_ORIGIN), \\\n@@ -70,0 +70,1 @@\n+    LIBS_unix := -ljava, \\\n@@ -73,1 +74,1 @@\n-    LIBS_windows := dbgeng.lib, \\\n+    LIBS_windows := dbgeng.lib $(WIN_JAVA_LIB), \\\n","filename":"make\/modules\/jdk.hotspot.agent\/Lib.gmk","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Red Hat Inc. All rights reserved.\n@@ -36,0 +36,1 @@\n+#include \"gc\/shared\/tlab_globals.hpp\"\n@@ -49,0 +50,1 @@\n+#include \"runtime\/stubRoutines.hpp\"\n@@ -304,1 +306,1 @@\n-    tbnz(rscratch1, exact_log2(SafepointMechanism::poll_bit()), slow_path);\n+    tbnz(rscratch1, log2i_exact(SafepointMechanism::poll_bit()), slow_path);\n@@ -320,0 +322,2 @@\n+\n+  str(zr, Address(rthread, JavaFrameAnchor::saved_fp_address_offset()));\n@@ -1384,1 +1388,0 @@\n-  maybe_isb();\n@@ -2636,1 +2639,1 @@\n-  regs += r18_reserved;\n+  regs += r18_tls;\n@@ -2663,0 +2666,2 @@\n+  reinitialize_ptrue();\n+\n@@ -2699,0 +2704,5 @@\n+\n+  if (restore_vectors) {\n+    reinitialize_ptrue();\n+  }\n+\n@@ -3997,1 +4007,1 @@\n-      (1ULL << log2_intptr(CompressedKlassPointers::range())) - 1;\n+      (1ULL << log2i(CompressedKlassPointers::range())) - 1;\n@@ -4390,4 +4400,9 @@\n-  InstructionMark im(this);\n-  code_section()->relocate(inst_mark(), rtype);\n-  ldrw(zr, Address(r, 0));\n-  return inst_mark();\n+  address mark;\n+  {\n+    InstructionMark im(this);\n+    code_section()->relocate(inst_mark(), rtype);\n+    ldrw(zr, Address(r, 0));\n+    mark = inst_mark();\n+  }\n+  verify_cross_modify_fence_not_required();\n+  return mark;\n@@ -4428,12 +4443,3 @@\n-  if (is_valid_AArch64_address((address)byte_map_base)) {\n-    \/\/ Strictly speaking the byte_map_base isn't an address at all,\n-    \/\/ and it might even be negative.\n-    uint64_t offset;\n-    adrp(reg, ExternalAddress((address)byte_map_base), offset);\n-    \/\/ We expect offset to be zero with most collectors.\n-    if (offset != 0) {\n-      add(reg, reg, offset);\n-    }\n-  } else {\n-    mov(reg, (uint64_t)byte_map_base);\n-  }\n+  \/\/ Strictly speaking the byte_map_base isn't an address at all, and it might\n+  \/\/ even be negative. It is thus materialised as a constant.\n+  mov(reg, (uint64_t)byte_map_base);\n@@ -4458,0 +4464,1 @@\n+  verify_cross_modify_fence_not_required();\n@@ -5299,0 +5306,2 @@\n+  \/\/ Make sure that native code does not change SVE vector length.\n+  if (!UseSVE) return;\n@@ -5300,1 +5309,0 @@\n-  assert(UseSVE > 0, \"should only be used for SVE\");\n@@ -5311,1 +5319,3 @@\n-  assert(UseSVE > 0, \"should only be used for SVE\");\n+  if (!UseSVE) {\n+    return;\n+  }\n@@ -5318,0 +5328,26 @@\n+\n+void MacroAssembler::safepoint_isb() {\n+  isb();\n+#ifndef PRODUCT\n+  if (VerifyCrossModifyFence) {\n+    \/\/ Clear the thread state.\n+    strb(zr, Address(rthread, in_bytes(JavaThread::requires_cross_modify_fence_offset())));\n+  }\n+#endif\n+}\n+\n+#ifndef PRODUCT\n+void MacroAssembler::verify_cross_modify_fence_not_required() {\n+  if (VerifyCrossModifyFence) {\n+    \/\/ Check if thread needs a cross modify fence.\n+    ldrb(rscratch1, Address(rthread, in_bytes(JavaThread::requires_cross_modify_fence_offset())));\n+    Label fence_not_required;\n+    cbz(rscratch1, fence_not_required);\n+    \/\/ If it does then fail.\n+    lea(rscratch1, CAST_FROM_FN_PTR(address, JavaThread::verify_cross_modify_fence_failure));\n+    mov(c_rarg0, rthread);\n+    blr(rscratch1);\n+    bind(fence_not_required);\n+  }\n+}\n+#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":60,"deletions":24,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Red Hat Inc. All rights reserved.\n@@ -44,0 +44,1 @@\n+#include \"runtime\/stubRoutines.hpp\"\n@@ -279,2 +280,1 @@\n-                                           int total_args_passed,\n-                                           int is_outgoing) {\n+                                           int total_args_passed) {\n@@ -377,1 +377,4 @@\n-  __ maybe_isb();\n+\n+  \/\/ Explicit isb required because fixup_callers_callsite may change the code\n+  \/\/ stream.\n+  __ safepoint_isb();\n@@ -1164,1 +1167,0 @@\n-    __ maybe_isb();\n@@ -1207,1 +1209,1 @@\n-  } else if (iid == vmIntrinsics::_invokeBasic) {\n+  } else if (iid == vmIntrinsics::_invokeBasic || iid == vmIntrinsics::_linkToNative) {\n@@ -1210,1 +1212,1 @@\n-    fatal(\"unexpected intrinsic id %d\", iid);\n+    fatal(\"unexpected intrinsic id %d\", vmIntrinsics::as_int(iid));\n@@ -1514,5 +1516,1 @@\n-  if (UseStackBanging) {\n-    __ bang_stack_with_offset(checked_cast<int>(StackOverflow::stack_shadow_zone_size()));\n-  } else {\n-    Unimplemented();\n-  }\n+  __ bang_stack_with_offset(checked_cast<int>(StackOverflow::stack_shadow_zone_size()));\n@@ -1870,4 +1868,1 @@\n-  if (UseSVE > 0) {\n-    \/\/ Make sure that jni code does not change SVE vector length.\n-    __ verify_sve_vector_length();\n-  }\n+  __ verify_sve_vector_length();\n@@ -1875,1 +1870,1 @@\n-  \/\/ check for safepoint operation in progress and\/or pending suspend requests\n+  \/\/ Check for safepoint operation in progress and\/or pending suspend requests.\n@@ -2099,1 +2094,1 @@\n-    __ maybe_isb();\n+\n@@ -2431,4 +2426,2 @@\n-  if (UseStackBanging) {\n-    __ ldrw(r19, Address(r5, Deoptimization::UnrollBlock::total_frame_sizes_offset_in_bytes()));\n-    __ bang_stack_size(r19, r2);\n-  }\n+  __ ldrw(r19, Address(r5, Deoptimization::UnrollBlock::total_frame_sizes_offset_in_bytes()));\n+  __ bang_stack_size(r19, r2);\n@@ -2539,0 +2532,9 @@\n+\/\/ Number of stack slots between incoming argument block and the start of\n+\/\/ a new frame.  The PROLOG must add this many slots to the stack.  The\n+\/\/ EPILOG must remove this many slots. aarch64 needs two slots for\n+\/\/ return address and fp.\n+\/\/ TODO think this is correct but check\n+uint SharedRuntime::in_preserve_stack_slots() {\n+  return 4;\n+}\n+\n@@ -2639,6 +2641,4 @@\n-  if (UseStackBanging) {\n-    __ ldrw(r1, Address(r4,\n-                        Deoptimization::UnrollBlock::\n-                        total_frame_sizes_offset_in_bytes()));\n-    __ bang_stack_size(r1, r2);\n-  }\n+  __ ldrw(r1, Address(r4,\n+                      Deoptimization::UnrollBlock::\n+                      total_frame_sizes_offset_in_bytes()));\n+  __ bang_stack_size(r1, r2);\n@@ -2796,1 +2796,0 @@\n-  __ maybe_isb();\n@@ -2799,6 +2798,0 @@\n-  if (UseSVE > 0 && save_vectors) {\n-    \/\/ Reinitialize the ptrue predicate register, in case the external runtime\n-    \/\/ call clobbers ptrue reg, as we may return to SVE compiled code.\n-    __ reinitialize_ptrue();\n-  }\n-\n@@ -2903,2 +2896,0 @@\n-  __ maybe_isb();\n-\n@@ -3026,1 +3017,5 @@\n-  __ maybe_isb();\n+  \/\/ handle_exception_C is a special VM call which does not require an explicit\n+  \/\/ instruction sync afterwards.\n+\n+  \/\/ May jump to SVE compiled code\n+  __ reinitialize_ptrue();\n@@ -3078,0 +3073,166 @@\n+\n+\/\/ ---------------------------------------------------------------\n+\n+class NativeInvokerGenerator : public StubCodeGenerator {\n+  address _call_target;\n+  int _shadow_space_bytes;\n+\n+  const GrowableArray<VMReg>& _input_registers;\n+  const GrowableArray<VMReg>& _output_registers;\n+public:\n+  NativeInvokerGenerator(CodeBuffer* buffer,\n+                         address call_target,\n+                         int shadow_space_bytes,\n+                         const GrowableArray<VMReg>& input_registers,\n+                         const GrowableArray<VMReg>& output_registers)\n+   : StubCodeGenerator(buffer, PrintMethodHandleStubs),\n+     _call_target(call_target),\n+     _shadow_space_bytes(shadow_space_bytes),\n+     _input_registers(input_registers),\n+     _output_registers(output_registers) {}\n+  void generate();\n+\n+private:\n+#ifdef ASSERT\n+  bool target_uses_register(VMReg reg) {\n+    return _input_registers.contains(reg) || _output_registers.contains(reg);\n+  }\n+#endif\n+};\n+\n+static const int native_invoker_code_size = 1024;\n+\n+BufferBlob* SharedRuntime::make_native_invoker(address call_target,\n+                                               int shadow_space_bytes,\n+                                               const GrowableArray<VMReg>& input_registers,\n+                                               const GrowableArray<VMReg>& output_registers) {\n+  BufferBlob* _invoke_native_blob =\n+    BufferBlob::create(\"nep_invoker_blob\", native_invoker_code_size);\n+  if (_invoke_native_blob == NULL)\n+    return NULL; \/\/ allocation failure\n+\n+  CodeBuffer code(_invoke_native_blob);\n+  NativeInvokerGenerator g(&code, call_target, shadow_space_bytes, input_registers, output_registers);\n+  g.generate();\n+  code.log_section_sizes(\"nep_invoker_blob\");\n+\n+  return _invoke_native_blob;\n+}\n+\n+void NativeInvokerGenerator::generate() {\n+  assert(!(target_uses_register(rscratch1->as_VMReg())\n+           || target_uses_register(rscratch2->as_VMReg())\n+           || target_uses_register(rthread->as_VMReg())),\n+         \"Register conflict\");\n+\n+  MacroAssembler* masm = _masm;\n+\n+  __ set_last_Java_frame(sp, noreg, lr, rscratch1);\n+\n+  __ enter();\n+\n+  \/\/ Store a pointer to the previous R29 (RFP) saved on the stack as it\n+  \/\/ may contain an oop if PreserveFramePointer is off. This value is\n+  \/\/ retrieved later by frame::sender_for_entry_frame() when the stack\n+  \/\/ is walked.\n+  __ mov(rscratch1, sp);\n+  __ str(rscratch1, Address(rthread, JavaThread::saved_fp_address_offset()));\n+\n+  \/\/ State transition\n+  __ mov(rscratch1, _thread_in_native);\n+  __ lea(rscratch2, Address(rthread, JavaThread::thread_state_offset()));\n+  __ stlrw(rscratch1, rscratch2);\n+\n+  assert(_shadow_space_bytes == 0, \"not expecting shadow space on AArch64\");\n+\n+  rt_call(masm, _call_target);\n+\n+  __ mov(rscratch1, _thread_in_native_trans);\n+  __ strw(rscratch1, Address(rthread, JavaThread::thread_state_offset()));\n+\n+  \/\/ Force this write out before the read below\n+  __ membar(Assembler::LoadLoad | Assembler::LoadStore |\n+            Assembler::StoreLoad | Assembler::StoreStore);\n+\n+  __ verify_sve_vector_length();\n+\n+  Label L_after_safepoint_poll;\n+  Label L_safepoint_poll_slow_path;\n+\n+  __ safepoint_poll(L_safepoint_poll_slow_path, true \/* at_return *\/, true \/* acquire *\/, false \/* in_nmethod *\/);\n+\n+  __ ldrw(rscratch1, Address(rthread, JavaThread::suspend_flags_offset()));\n+  __ cbnzw(rscratch1, L_safepoint_poll_slow_path);\n+\n+  __ bind(L_after_safepoint_poll);\n+\n+  \/\/ change thread state\n+  __ mov(rscratch1, _thread_in_Java);\n+  __ lea(rscratch2, Address(rthread, JavaThread::thread_state_offset()));\n+  __ stlrw(rscratch1, rscratch2);\n+\n+  __ block_comment(\"reguard stack check\");\n+  Label L_reguard;\n+  Label L_after_reguard;\n+  __ ldrb(rscratch1, Address(rthread, JavaThread::stack_guard_state_offset()));\n+  __ cmpw(rscratch1, StackOverflow::stack_guard_yellow_reserved_disabled);\n+  __ br(Assembler::EQ, L_reguard);\n+  __ bind(L_after_reguard);\n+\n+  __ reset_last_Java_frame(true);\n+\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ ret(lr);\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+  __ block_comment(\"{ L_safepoint_poll_slow_path\");\n+  __ bind(L_safepoint_poll_slow_path);\n+\n+  \/\/ Need to save the native result registers around any runtime calls.\n+  RegSet spills;\n+  FloatRegSet fp_spills;\n+  for (int i = 0; i < _output_registers.length(); i++) {\n+    VMReg output = _output_registers.at(i);\n+    if (output->is_Register()) {\n+      spills += RegSet::of(output->as_Register());\n+    } else if (output->is_FloatRegister()) {\n+      fp_spills += FloatRegSet::of(output->as_FloatRegister());\n+    }\n+  }\n+\n+  __ push(spills, sp);\n+  __ push_fp(fp_spills, sp);\n+\n+  __ mov(c_rarg0, rthread);\n+  assert(frame::arg_reg_save_area_bytes == 0, \"not expecting frame reg save area\");\n+  __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans)));\n+  __ blr(rscratch1);\n+\n+  __ pop_fp(fp_spills, sp);\n+  __ pop(spills, sp);\n+\n+  __ b(L_after_safepoint_poll);\n+  __ block_comment(\"} L_safepoint_poll_slow_path\");\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+  __ block_comment(\"{ L_reguard\");\n+  __ bind(L_reguard);\n+\n+  __ push(spills, sp);\n+  __ push_fp(fp_spills, sp);\n+\n+  rt_call(masm, CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages));\n+\n+  __ pop_fp(fp_spills, sp);\n+  __ pop(spills, sp);\n+\n+  __ b(L_after_reguard);\n+\n+  __ block_comment(\"} L_reguard\");\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+  __ flush();\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":200,"deletions":39,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"jvmtifiles\/jvmti.h\"\n@@ -1443,19 +1444,0 @@\n-void os::print_signal_handlers(outputStream* st, char* buf, size_t buflen) {\n-  st->print_cr(\"Signal Handlers:\");\n-  PosixSignals::print_signal_handler(st, SIGSEGV, buf, buflen);\n-  PosixSignals::print_signal_handler(st, SIGBUS , buf, buflen);\n-  PosixSignals::print_signal_handler(st, SIGFPE , buf, buflen);\n-  PosixSignals::print_signal_handler(st, SIGPIPE, buf, buflen);\n-  PosixSignals::print_signal_handler(st, SIGXFSZ, buf, buflen);\n-  PosixSignals::print_signal_handler(st, SIGILL , buf, buflen);\n-  PosixSignals::print_signal_handler(st, SR_signum, buf, buflen);\n-  PosixSignals::print_signal_handler(st, SHUTDOWN1_SIGNAL, buf, buflen);\n-  PosixSignals::print_signal_handler(st, SHUTDOWN2_SIGNAL , buf, buflen);\n-  PosixSignals::print_signal_handler(st, SHUTDOWN3_SIGNAL , buf, buflen);\n-  PosixSignals::print_signal_handler(st, BREAK_SIGNAL, buf, buflen);\n-  PosixSignals::print_signal_handler(st, SIGTRAP, buf, buflen);\n-  \/\/ We also want to know if someone else adds a SIGDANGER handler because\n-  \/\/ that will interfere with OOM killling.\n-  PosixSignals::print_signal_handler(st, SIGDANGER, buf, buflen);\n-}\n-\n@@ -2057,1 +2039,1 @@\n-char* os::pd_reserve_memory(size_t bytes, bool executable) {\n+char* os::pd_reserve_memory(size_t bytes, bool exec) {\n@@ -2258,1 +2240,1 @@\n-char* os::pd_attempt_reserve_memory_at(char* requested_addr, size_t bytes) {\n+char* os::pd_attempt_reserve_memory_at(char* requested_addr, size_t bytes, bool exec) {\n@@ -2463,1 +2445,1 @@\n-  _page_sizes[0] = 0;\n+  _page_sizes.add(Aix::_page_size);\n@@ -2486,2 +2468,0 @@\n-  init_random(1234567);\n-\n@@ -2521,3 +2501,1 @@\n-  \/\/ initialize suspend\/resume support - must do this before signal_sets_init()\n-  if (PosixSignals::SR_initialize() != 0) {\n-    perror(\"SR_initialize failed\");\n+  if (PosixSignals::init() == JNI_ERR) {\n@@ -2527,7 +2505,0 @@\n-  PosixSignals::signal_sets_init();\n-  PosixSignals::install_signal_handlers();\n-  \/\/ Initialize data for jdk.internal.misc.Signal\n-  if (!ReduceSignalUsage) {\n-    PosixSignals::jdk_misc_signal_init();\n-  }\n-\n@@ -2603,8 +2574,0 @@\n-void os::SuspendedThreadTask::internal_do_task() {\n-  if (PosixSignals::do_suspend(_thread->osthread())) {\n-    SuspendedThreadTaskContext context(_thread, _thread->osthread()->ucontext());\n-    do_task(context);\n-    PosixSignals::do_resume(_thread->osthread());\n-  }\n-}\n-\n@@ -3329,0 +3292,3 @@\n+\n+void os::print_memory_mappings(char* addr, size_t bytes, outputStream* st) {}\n+\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":8,"deletions":42,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"jvmtifiles\/jvmti.h\"\n@@ -1544,15 +1545,0 @@\n-void os::print_signal_handlers(outputStream* st, char* buf, size_t buflen) {\n-  st->print_cr(\"Signal Handlers:\");\n-  PosixSignals::print_signal_handler(st, SIGSEGV, buf, buflen);\n-  PosixSignals::print_signal_handler(st, SIGBUS , buf, buflen);\n-  PosixSignals::print_signal_handler(st, SIGFPE , buf, buflen);\n-  PosixSignals::print_signal_handler(st, SIGPIPE, buf, buflen);\n-  PosixSignals::print_signal_handler(st, SIGXFSZ, buf, buflen);\n-  PosixSignals::print_signal_handler(st, SIGILL , buf, buflen);\n-  PosixSignals::print_signal_handler(st, SR_signum, buf, buflen);\n-  PosixSignals::print_signal_handler(st, SHUTDOWN1_SIGNAL, buf, buflen);\n-  PosixSignals::print_signal_handler(st, SHUTDOWN2_SIGNAL , buf, buflen);\n-  PosixSignals::print_signal_handler(st, SHUTDOWN3_SIGNAL , buf, buflen);\n-  PosixSignals::print_signal_handler(st, BREAK_SIGNAL, buf, buflen);\n-}\n-\n@@ -1704,2 +1690,11 @@\n-  if (::mprotect(addr, size, prot) == 0) {\n-    return true;\n+  if (exec) {\n+    \/\/ Do not replace MAP_JIT mappings, see JDK-8234930\n+    if (::mprotect(addr, size, prot) == 0) {\n+      return true;\n+    }\n+  } else {\n+    uintptr_t res = (uintptr_t) ::mmap(addr, size, prot,\n+                                       MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0);\n+    if (res != (uintptr_t) MAP_FAILED) {\n+      return true;\n+    }\n@@ -1819,1 +1814,1 @@\n-  return os::uncommit_memory(addr, size, !ExecMem);\n+  return os::uncommit_memory(addr, size);\n@@ -1825,1 +1820,1 @@\n-static char* anon_mmap(char* requested_addr, size_t bytes, bool executable) {\n+static char* anon_mmap(char* requested_addr, size_t bytes, bool exec) {\n@@ -1827,6 +1822,2 @@\n-  int flags = MAP_PRIVATE | MAP_NORESERVE | MAP_ANONYMOUS;\n-#ifdef __APPLE__\n-  if (executable) {\n-    flags |= MAP_JIT;\n-  }\n-#endif\n+  const int flags = MAP_PRIVATE | MAP_NORESERVE | MAP_ANONYMOUS\n+      MACOS_ONLY(| (exec ? MAP_JIT : 0));\n@@ -1846,2 +1837,2 @@\n-char* os::pd_reserve_memory(size_t bytes, bool executable) {\n-  return anon_mmap(NULL \/* addr *\/, bytes, executable);\n+char* os::pd_reserve_memory(size_t bytes, bool exec) {\n+  return anon_mmap(NULL \/* addr *\/, bytes, exec);\n@@ -1932,1 +1923,1 @@\n-  char* result = pd_attempt_reserve_memory_at(requested_addr, bytes);\n+  char* result = pd_attempt_reserve_memory_at(requested_addr, bytes, !ExecMem);\n@@ -1944,1 +1935,1 @@\n-char* os::pd_attempt_reserve_memory_at(char* requested_addr, size_t bytes) {\n+char* os::pd_attempt_reserve_memory_at(char* requested_addr, size_t bytes, bool exec) {\n@@ -1957,1 +1948,1 @@\n-  char * addr = anon_mmap(requested_addr, bytes, false\/*executable*\/);\n+  char * addr = anon_mmap(requested_addr, bytes, exec);\n@@ -2128,2 +2119,0 @@\n-  init_random(1234567);\n-\n@@ -2134,1 +2123,1 @@\n-  init_page_sizes((size_t) Bsd::page_size());\n+  _page_sizes.add(Bsd::page_size());\n@@ -2163,3 +2152,1 @@\n-  \/\/ initialize suspend\/resume support - must do this before signal_sets_init()\n-  if (PosixSignals::SR_initialize() != 0) {\n-    perror(\"SR_initialize failed\");\n+  if (PosixSignals::init() == JNI_ERR) {\n@@ -2169,7 +2156,0 @@\n-  PosixSignals::signal_sets_init();\n-  PosixSignals::install_signal_handlers();\n-  \/\/ Initialize data for jdk.internal.misc.Signal\n-  if (!ReduceSignalUsage) {\n-    PosixSignals::jdk_misc_signal_init();\n-  }\n-\n@@ -2306,8 +2286,0 @@\n-void os::SuspendedThreadTask::internal_do_task() {\n-  if (PosixSignals::do_suspend(_thread->osthread())) {\n-    SuspendedThreadTaskContext context(_thread, _thread->osthread()->ucontext());\n-    do_task(context);\n-    PosixSignals::do_resume(_thread->osthread());\n-  }\n-}\n-\n@@ -2842,0 +2814,3 @@\n+\n+void os::print_memory_mappings(char* addr, size_t bytes, outputStream* st) {}\n+\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":26,"deletions":51,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-#include \"precompiled\/precompiled.hpp\"\n+#include \"precompiled.hpp\"\n@@ -32,0 +32,1 @@\n+#include \"runtime\/java.hpp\"\n@@ -34,0 +35,1 @@\n+#include \"runtime\/stubRoutines.hpp\"\n@@ -40,0 +42,8 @@\n+#ifdef ZERO\n+\/\/ See stubGenerator_zero.cpp\n+#include <setjmp.h>\n+extern sigjmp_buf* get_jmp_buf_for_continuation();\n+#endif\n+\n+#include <signal.h>\n+\n@@ -47,9 +57,7 @@\n-\/\/ glibc on Bsd platform uses non-documented flag\n-\/\/ to indicate, that some special sort of signal\n-\/\/ trampoline is used.\n-\/\/ We will never set this flag, and we should\n-\/\/ ignore this flag in our diagnostic\n-#ifdef SIGNIFICANT_SIGNAL_MASK\n-  #undef SIGNIFICANT_SIGNAL_MASK\n-#endif\n-#define SIGNIFICANT_SIGNAL_MASK (~0x04000000)\n+\/\/ Glibc on Linux uses the SA_RESTORER flag to indicate\n+\/\/ the use of a \"signal trampoline\". We have no interest\n+\/\/ in this flag and need to ignore it when checking our\n+\/\/ own flag settings.\n+\/\/ Note: SA_RESTORER is not exposed through signal.h so we\n+\/\/ have to hardwire its 0x04000000 value in the mask.\n+LINUX_ONLY(const int SA_RESTORER_FLAG_MASK = ~0x04000000;)\n@@ -94,0 +102,4 @@\n+\/\/ Signal number used to suspend\/resume a thread\n+\/\/ do not use any signal number less than SIGSEGV, see 4355769\n+int PosixSignals::SR_signum = SIGUSR2;\n+\n@@ -266,1 +278,1 @@\n-void PosixSignals::jdk_misc_signal_init() {\n+void jdk_misc_signal_init() {\n@@ -544,1 +556,2 @@\n-  if ((sig == SIGSEGV || sig == SIGBUS) && info != NULL && info->si_addr == g_assert_poison) {\n+  if (!signal_was_handled &&\n+      ((sig == SIGSEGV || sig == SIGBUS) && info != NULL && info->si_addr == g_assert_poison)) {\n@@ -549,0 +562,21 @@\n+  if (!signal_was_handled) {\n+    \/\/ Handle SafeFetch access.\n+#ifndef ZERO\n+    if (uc != NULL) {\n+      address pc = os::Posix::ucontext_get_pc(uc);\n+      if (StubRoutines::is_safefetch_fault(pc)) {\n+        os::Posix::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));\n+        signal_was_handled = true;\n+      }\n+    }\n+#else\n+    \/\/ See JDK-8076185\n+    if (sig == SIGSEGV || sig == SIGBUS) {\n+      sigjmp_buf* const pjb = get_jmp_buf_for_continuation();\n+      if (pjb) {\n+        siglongjmp(*pjb, 1);\n+      }\n+    }\n+#endif \/\/ ZERO\n+  }\n+\n@@ -550,1 +584,2 @@\n-  if (sig == SIGPIPE || sig == SIGXFSZ) {\n+  if (!signal_was_handled &&\n+      (sig == SIGPIPE || sig == SIGXFSZ)) {\n@@ -576,0 +611,6 @@\n+      } else if (ZERO_ONLY(true) NOT_ZERO(false)) {\n+        \/\/ Non-arch-specific Zero code does not really know the pc.\n+        \/\/ This can be alleviated by making arch-specific os::Posix::ucontext_get_pc\n+        \/\/ available for Zero for known architectures. But for generic Zero\n+        \/\/ code, it would still remain unknown.\n+        pc = NULL;\n@@ -577,1 +618,1 @@\n-        pc = PosixSignals::ucontext_get_pc(uc);\n+        pc = os::Posix::ucontext_get_pc(uc);\n@@ -580,16 +621,6 @@\n-#if defined(ZERO) && !defined(PRODUCT)\n-    char buf[64];\n-    VMError::report_and_die(t, sig, pc, info, ucVoid,\n-          \"\\n#\"\n-          \"\\n#    \/--------------------\\\\\"\n-          \"\\n#    |      %-7s       |\"\n-          \"\\n#    \\\\---\\\\ \/--------------\/\"\n-          \"\\n#        \/\"\n-          \"\\n#    [-]        |\\\\_\/|    \"\n-          \"\\n#    (+)=C      |o o|__  \"\n-          \"\\n#    | |        =-*-=__\\\\ \"\n-          \"\\n#    OOO        c_c_(___)\",\n-          get_signal_name(sig, buf, sizeof(buf)));\n-#else\n-    VMError::report_and_die(t, sig, pc, info, ucVoid);\n-#endif\n+    \/\/ For Zero, we ignore the crash context, because:\n+    \/\/  a) The crash would be in C++ interpreter code, so context is not really relevant;\n+    \/\/  b) Generic Zero code would not be able to parse it, so when generic error\n+    \/\/     reporting code asks e.g. about frames on stack, Zero would experience\n+    \/\/     a secondary ShouldNotCallThis() crash.\n+    VMError::report_and_die(t, sig, pc, info, NOT_ZERO(ucVoid) ZERO_ONLY(NULL));\n@@ -622,23 +653,7 @@\n-static const char* get_signal_handler_name(address handler,\n-                                           char* buf, int buflen) {\n-  int offset = 0;\n-  bool found = os::dll_address_to_library_name(handler, buf, buflen, &offset);\n-  if (found) {\n-    \/\/ skip directory names\n-    const char *p1, *p2;\n-    p1 = buf;\n-    size_t len = strlen(os::file_separator());\n-    while ((p2 = strstr(p1, os::file_separator())) != NULL) p1 = p2 + len;\n-#if !defined(AIX)\n-    jio_snprintf(buf, buflen, \"%s+0x%x\", p1, offset);\n-#else\n-    \/\/ The way os::dll_address_to_library_name is implemented on Aix\n-    \/\/ right now, it always returns -1 for the offset which is not\n-    \/\/ terribly informative.\n-    \/\/ Will fix that. For now, omit the offset.\n-    jio_snprintf(buf, buflen, \"%s\", p1);\n-#endif\n-  } else {\n-    jio_snprintf(buf, buflen, PTR_FORMAT, handler);\n-  }\n-  return buf;\n+static void print_signal_handler_name(outputStream* os, address handler, char* buf, size_t buflen) {\n+  \/\/ We demangle, but omit arguments - signal handlers should have always the same prototype.\n+  os::print_function_and_library_name(os, handler, buf, buflen,\n+                                       true, \/\/ shorten_path\n+                                       true, \/\/ demangle\n+                                       true  \/\/ omit arguments\n+                                       );\n@@ -663,0 +678,10 @@\n+  const unsigned int unknown_flag = ~(SA_NOCLDSTOP |\n+                                      SA_ONSTACK   |\n+                                      SA_NOCLDSTOP |\n+                                      SA_RESTART   |\n+                                      SA_SIGINFO   |\n+                                      SA_NOCLDWAIT |\n+                                      SA_NODEFER\n+                                      AIX_ONLY(| SA_OLDSTYLE)\n+                                      );\n+\n@@ -665,1 +690,1 @@\n-    \/\/ systems 0x80000000, which is implicitly unsigned.  Assignining\n+    \/\/ systems 0x80000000, which is implicitly unsigned.  Assigning\n@@ -681,1 +706,1 @@\n-    { 0, NULL }\n+    { unknown_flag, \"NOT USED\"     }\n@@ -684,1 +709,1 @@\n-  for (idx = 0; flaginfo[idx].s && remaining > 1; idx++) {\n+  for (idx = 0; flaginfo[idx].i != unknown_flag && remaining > 1; idx++) {\n@@ -697,0 +722,4 @@\n+  unsigned int unknowns = flags & unknown_flag;\n+  if (unknowns != 0) {\n+    jio_snprintf(p, remaining, \"|Unknown_flags:%x\", unknowns);\n+  }\n@@ -722,0 +751,11 @@\n+\/\/ Implementation may use the same storage for both the sa_sigaction field and the sa_handler field,\n+\/\/ so check for \"sigAct.sa_flags == SA_SIGINFO\"\n+static address get_signal_handler(const struct sigaction* action) {\n+  bool siginfo_flag_set = (action->sa_flags & SA_SIGINFO) != 0;\n+  if (siginfo_flag_set) {\n+    return CAST_FROM_FN_PTR(address, action->sa_sigaction);\n+  } else {\n+    return CAST_FROM_FN_PTR(address, action->sa_handler);\n+  }\n+}\n+\n@@ -740,0 +780,2 @@\n+  \/\/ See comment for SA_RESTORER_FLAG_MASK\n+  LINUX_ONLY(act.sa_flags &= SA_RESTORER_FLAG_MASK;)\n@@ -741,6 +783,1 @@\n-  act.sa_flags &= SIGNIFICANT_SIGNAL_MASK;\n-\n-  address thisHandler = (act.sa_flags & SA_SIGINFO)\n-    ? CAST_FROM_FN_PTR(address, act.sa_sigaction)\n-    : CAST_FROM_FN_PTR(address, act.sa_handler);\n-\n+  address thisHandler = get_signal_handler(&act);\n@@ -766,1 +803,1 @@\n-    if (sig == SR_signum) {\n+    if (sig == PosixSignals::SR_signum) {\n@@ -776,2 +813,4 @@\n-    tty->print(\"expected:%s\", get_signal_handler_name(jvmHandler, buf, O_BUFLEN));\n-    tty->print_cr(\"  found:%s\", get_signal_handler_name(thisHandler, buf, O_BUFLEN));\n+    tty->print_raw(\"expected:\");\n+    print_signal_handler_name(tty, jvmHandler, buf, O_BUFLEN);\n+    tty->print_raw(\"  found:\");\n+    print_signal_handler_name(tty, thisHandler, buf, O_BUFLEN);\n@@ -867,1 +906,1 @@\n-  do_signal_check(SR_signum);\n+  do_signal_check(PosixSignals::SR_signum);\n@@ -1167,3 +1206,1 @@\n-  void* oldhand = oldAct.sa_sigaction\n-                ? CAST_FROM_FN_PTR(void*,  oldAct.sa_sigaction)\n-                : CAST_FROM_FN_PTR(void*,  oldAct.sa_handler);\n+  void* oldhand = get_signal_handler(&oldAct);\n@@ -1212,3 +1249,1 @@\n-  void* oldhand2  = oldAct.sa_sigaction\n-                  ? CAST_FROM_FN_PTR(void*, oldAct.sa_sigaction)\n-                  : CAST_FROM_FN_PTR(void*, oldAct.sa_handler);\n+  void* oldhand2  = get_signal_handler(&oldAct);\n@@ -1220,2 +1255,1 @@\n-void PosixSignals::install_signal_handlers() {\n-\n+void install_signal_handlers() {\n@@ -1320,2 +1354,2 @@\n-  \/\/ See comment for SIGNIFICANT_SIGNAL_MASK define\n-  sa.sa_flags &= SIGNIFICANT_SIGNAL_MASK;\n+  \/\/ See comment for SA_RESTORER_FLAG_MASK\n+  LINUX_ONLY(sa.sa_flags &= SA_RESTORER_FLAG_MASK;)\n@@ -1323,1 +1357,1 @@\n-  st->print(\"%s: \", os::exception_name(sig, buf, buflen));\n+  st->print(\"%10s: \", os::exception_name(sig, buf, buflen));\n@@ -1325,3 +1359,1 @@\n-  address handler = (sa.sa_flags & SA_SIGINFO)\n-    ? CAST_FROM_FN_PTR(address, sa.sa_sigaction)\n-    : CAST_FROM_FN_PTR(address, sa.sa_handler);\n+  address handler = get_signal_handler(&sa);\n@@ -1334,1 +1366,1 @@\n-    st->print(\"[%s]\", get_signal_handler_name(handler, buf, buflen));\n+    print_signal_handler_name(st, handler, buf, O_BUFLEN);\n@@ -1344,1 +1376,2 @@\n-    sa.sa_flags = VMError::get_resetted_sigflags(sig) & SIGNIFICANT_SIGNAL_MASK;\n+    \/\/ See comment for SA_RESTORER_FLAG_MASK\n+    sa.sa_flags = VMError::get_resetted_sigflags(sig) LINUX_ONLY(& SA_RESTORER_FLAG_MASK);\n@@ -1365,0 +1398,23 @@\n+void os::print_signal_handlers(outputStream* st, char* buf, size_t buflen) {\n+  st->print_cr(\"Signal Handlers:\");\n+  PosixSignals::print_signal_handler(st, SIGSEGV, buf, buflen);\n+  PosixSignals::print_signal_handler(st, SIGBUS , buf, buflen);\n+  PosixSignals::print_signal_handler(st, SIGFPE , buf, buflen);\n+  PosixSignals::print_signal_handler(st, SIGPIPE, buf, buflen);\n+  PosixSignals::print_signal_handler(st, SIGXFSZ, buf, buflen);\n+  PosixSignals::print_signal_handler(st, SIGILL , buf, buflen);\n+  PosixSignals::print_signal_handler(st, PosixSignals::SR_signum, buf, buflen);\n+  PosixSignals::print_signal_handler(st, SHUTDOWN1_SIGNAL, buf, buflen);\n+  PosixSignals::print_signal_handler(st, SHUTDOWN2_SIGNAL , buf, buflen);\n+  PosixSignals::print_signal_handler(st, SHUTDOWN3_SIGNAL , buf, buflen);\n+  PosixSignals::print_signal_handler(st, BREAK_SIGNAL, buf, buflen);\n+#if defined(SIGDANGER)\n+  \/\/ We also want to know if someone else adds a SIGDANGER handler because\n+  \/\/ that will interfere with OOM killling.\n+  PosixSignals::print_signal_handler(st, SIGDANGER, buf, buflen);\n+#endif\n+#if defined(SIGTRAP)\n+  PosixSignals::print_signal_handler(st, SIGTRAP, buf, buflen);\n+#endif\n+}\n+\n@@ -1368,2 +1424,1 @@\n-  void* ohlr = oact.sa_sigaction ? CAST_FROM_FN_PTR(void*,  oact.sa_sigaction)\n-                                 : CAST_FROM_FN_PTR(void*,  oact.sa_handler);\n+  void* ohlr = get_signal_handler(&oact);\n@@ -1377,25 +1432,1 @@\n-address PosixSignals::ucontext_get_pc(const ucontext_t* ctx) {\n-#if defined(AIX)\n-   return os::Aix::ucontext_get_pc(ctx);\n-#elif defined(BSD)\n-   return os::Bsd::ucontext_get_pc(ctx);\n-#elif defined(LINUX)\n-   return os::Linux::ucontext_get_pc(ctx);\n-#else\n-   VMError::report_and_die(\"unimplemented ucontext_get_pc\");\n-#endif\n-}\n-\n-void PosixSignals::ucontext_set_pc(ucontext_t* ctx, address pc) {\n-#if defined(AIX)\n-   os::Aix::ucontext_set_pc(ctx, pc);\n-#elif defined(BSD)\n-   os::Bsd::ucontext_set_pc(ctx, pc);\n-#elif defined(LINUX)\n-   os::Linux::ucontext_set_pc(ctx, pc);\n-#else\n-   VMError::report_and_die(\"unimplemented ucontext_set_pc\");\n-#endif\n-}\n-\n-void PosixSignals::signal_sets_init() {\n+static void signal_sets_init() {\n@@ -1425,1 +1456,1 @@\n-  sigaddset(&unblocked_sigs, SR_signum);\n+  sigaddset(&unblocked_sigs, PosixSignals::SR_signum);\n@@ -1575,1 +1606,1 @@\n-      sigdelset(&suspend_set, SR_signum);\n+      sigdelset(&suspend_set, PosixSignals::SR_signum);\n@@ -1611,1 +1642,1 @@\n-int PosixSignals::SR_initialize() {\n+int SR_initialize() {\n@@ -1619,1 +1650,1 @@\n-      SR_signum = sig;\n+      PosixSignals::SR_signum = sig;\n@@ -1622,1 +1653,1 @@\n-              sig, MAX2(SIGSEGV, SIGBUS)+1, NSIG-1, SR_signum);\n+              sig, MAX2(SIGSEGV, SIGBUS)+1, NSIG-1, PosixSignals::SR_signum);\n@@ -1626,1 +1657,1 @@\n-  assert(SR_signum > SIGSEGV && SR_signum > SIGBUS,\n+  assert(PosixSignals::SR_signum > SIGSEGV && PosixSignals::SR_signum > SIGBUS,\n@@ -1630,1 +1661,1 @@\n-  sigaddset(&SR_sigset, SR_signum);\n+  sigaddset(&SR_sigset, PosixSignals::SR_signum);\n@@ -1640,1 +1671,1 @@\n-  if (sigaction(SR_signum, &act, 0) == -1) {\n+  if (sigaction(PosixSignals::SR_signum, &act, 0) == -1) {\n@@ -1645,1 +1676,1 @@\n-  set_our_sigflags(SR_signum, act.sa_flags);\n+  set_our_sigflags(PosixSignals::SR_signum, act.sa_flags);\n@@ -1650,1 +1681,1 @@\n-  int status = pthread_kill(osthread->pthread_id(), SR_signum);\n+  int status = pthread_kill(osthread->pthread_id(), PosixSignals::SR_signum);\n@@ -1720,0 +1751,27 @@\n+\n+void os::SuspendedThreadTask::internal_do_task() {\n+  if (PosixSignals::do_suspend(_thread->osthread())) {\n+    os::SuspendedThreadTaskContext context(_thread, _thread->osthread()->ucontext());\n+    do_task(context);\n+    PosixSignals::do_resume(_thread->osthread());\n+  }\n+}\n+\n+int PosixSignals::init() {\n+  \/\/ initialize suspend\/resume support - must do this before signal_sets_init()\n+  if (SR_initialize() != 0) {\n+    vm_exit_during_initialization(\"SR_initialize failed\");\n+    return JNI_ERR;\n+  }\n+\n+  signal_sets_init();\n+\n+  install_signal_handlers();\n+\n+  \/\/ Initialize data for jdk.internal.misc.Signal\n+  if (!ReduceSignalUsage) {\n+    jdk_misc_signal_init();\n+  }\n+\n+  return JNI_OK;\n+}\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":177,"deletions":119,"binary":false,"changes":296,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+#include \"jvmtifiles\/jvmti.h\"\n@@ -64,1 +65,1 @@\n-#include \"runtime\/stubRoutines.hpp\"\n+#include \"runtime\/stubRoutines.inline.hpp\"\n@@ -180,0 +181,85 @@\n+#define RANGE_FORMAT                \"[\" PTR_FORMAT \"-\" PTR_FORMAT \")\"\n+#define RANGE_FORMAT_ARGS(p, len)   p2i(p), p2i((address)p + len)\n+\n+\/\/ A number of wrappers for more frequently used system calls, to add standard logging.\n+\n+struct PreserveLastError {\n+  const DWORD v;\n+  PreserveLastError() : v(::GetLastError()) {}\n+  ~PreserveLastError() { ::SetLastError(v); }\n+};\n+\n+\/\/ Logging wrapper for VirtualAlloc\n+static LPVOID virtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect) {\n+  LPVOID result = ::VirtualAlloc(lpAddress, dwSize, flAllocationType, flProtect);\n+  if (result != NULL) {\n+    log_trace(os)(\"VirtualAlloc(\" PTR_FORMAT \", \" SIZE_FORMAT \", %x, %x) returned \" PTR_FORMAT \"%s.\",\n+                  p2i(lpAddress), dwSize, flAllocationType, flProtect, p2i(result),\n+                  ((lpAddress != NULL && result != lpAddress) ? \" <different base!>\" : \"\"));\n+  } else {\n+    PreserveLastError ple;\n+    log_info(os)(\"VirtualAlloc(\" PTR_FORMAT \", \" SIZE_FORMAT \", %x, %x) failed (%u).\",\n+                  p2i(lpAddress), dwSize, flAllocationType, flProtect, ple.v);\n+  }\n+  return result;\n+}\n+\n+\/\/ Logging wrapper for VirtualFree\n+static BOOL virtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD  dwFreeType) {\n+  BOOL result = ::VirtualFree(lpAddress, dwSize, dwFreeType);\n+  if (result != FALSE) {\n+    log_trace(os)(\"VirtualFree(\" PTR_FORMAT \", \" SIZE_FORMAT \", %x) succeeded\",\n+                  p2i(lpAddress), dwSize, dwFreeType);\n+  } else {\n+    PreserveLastError ple;\n+    log_info(os)(\"VirtualFree(\" PTR_FORMAT \", \" SIZE_FORMAT \", %x) failed (%u).\",\n+                 p2i(lpAddress), dwSize, dwFreeType, ple.v);\n+  }\n+  return result;\n+}\n+\n+\/\/ Logging wrapper for VirtualAllocExNuma\n+static LPVOID virtualAllocExNuma(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD  flAllocationType,\n+                                 DWORD  flProtect, DWORD  nndPreferred) {\n+  LPVOID result = ::VirtualAllocExNuma(hProcess, lpAddress, dwSize, flAllocationType, flProtect, nndPreferred);\n+  if (result != NULL) {\n+    log_trace(os)(\"VirtualAllocExNuma(\" PTR_FORMAT \", \" SIZE_FORMAT \", %x, %x, %x) returned \" PTR_FORMAT \"%s.\",\n+                  p2i(lpAddress), dwSize, flAllocationType, flProtect, nndPreferred, p2i(result),\n+                  ((lpAddress != NULL && result != lpAddress) ? \" <different base!>\" : \"\"));\n+  } else {\n+    PreserveLastError ple;\n+    log_info(os)(\"VirtualAllocExNuma(\" PTR_FORMAT \", \" SIZE_FORMAT \", %x, %x, %x) failed (%u).\",\n+                 p2i(lpAddress), dwSize, flAllocationType, flProtect, nndPreferred, ple.v);\n+  }\n+  return result;\n+}\n+\n+\/\/ Logging wrapper for MapViewOfFileEx\n+static LPVOID mapViewOfFileEx(HANDLE hFileMappingObject, DWORD  dwDesiredAccess, DWORD  dwFileOffsetHigh,\n+                              DWORD  dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress) {\n+  LPVOID result = ::MapViewOfFileEx(hFileMappingObject, dwDesiredAccess, dwFileOffsetHigh,\n+                                    dwFileOffsetLow, dwNumberOfBytesToMap, lpBaseAddress);\n+  if (result != NULL) {\n+    log_trace(os)(\"MapViewOfFileEx(\" PTR_FORMAT \", \" SIZE_FORMAT \") returned \" PTR_FORMAT \"%s.\",\n+                  p2i(lpBaseAddress), dwNumberOfBytesToMap, p2i(result),\n+                  ((lpBaseAddress != NULL && result != lpBaseAddress) ? \" <different base!>\" : \"\"));\n+  } else {\n+    PreserveLastError ple;\n+    log_info(os)(\"MapViewOfFileEx(\" PTR_FORMAT \", \" SIZE_FORMAT \") failed (%u).\",\n+                 p2i(lpBaseAddress), dwNumberOfBytesToMap, ple.v);\n+  }\n+  return result;\n+}\n+\n+\/\/ Logging wrapper for UnmapViewOfFile\n+static BOOL unmapViewOfFile(LPCVOID lpBaseAddress) {\n+  BOOL result = ::UnmapViewOfFile(lpBaseAddress);\n+  if (result != FALSE) {\n+    log_trace(os)(\"UnmapViewOfFile(\" PTR_FORMAT \") succeeded\", p2i(lpBaseAddress));\n+  } else {\n+    PreserveLastError ple;\n+    log_info(os)(\"UnmapViewOfFile(\" PTR_FORMAT \") failed (%u).\",  p2i(lpBaseAddress), ple.v);\n+  }\n+  return result;\n+}\n+\n@@ -342,1 +428,0 @@\n-\n@@ -430,0 +515,1 @@\n+JNIEXPORT\n@@ -770,1 +856,1 @@\n-bool os::has_allocatable_memory_limit(julong* limit) {\n+bool os::has_allocatable_memory_limit(size_t* limit) {\n@@ -775,1 +861,1 @@\n-  *limit = (julong)ms.ullAvailVirtual;\n+  *limit = (size_t)ms.ullAvailVirtual;\n@@ -779,1 +865,1 @@\n-  *limit = MIN2((julong)1400*M, (julong)ms.ullAvailVirtual);\n+  *limit = MIN2((size_t)1400*M, (size_t)ms.ullAvailVirtual);\n@@ -2160,1 +2246,1 @@\n-  \/\/ Save pc in thread\n+\n@@ -2162,6 +2248,1 @@\n-  \/\/ Do not blow up if no thread info available.\n-  if (thread) {\n-    thread->as_Java_thread()->set_saved_exception_pc((address)(DWORD_PTR)exceptionInfo->ContextRecord->Pc);\n-  }\n-  \/\/ Set pc to handler\n-  exceptionInfo->ContextRecord->Pc = (DWORD64)handler;\n+  #define PC_NAME Pc\n@@ -2169,6 +2250,3 @@\n-  \/\/ Do not blow up if no thread info available.\n-  if (thread != NULL) {\n-    thread->as_Java_thread()->set_saved_exception_pc((address)(DWORD_PTR)exceptionInfo->ContextRecord->Rip);\n-  }\n-  \/\/ Set pc to handler\n-  exceptionInfo->ContextRecord->Rip = (DWORD64)handler;\n+  #define PC_NAME Rip\n+#elif defined(_M_IX86)\n+  #define PC_NAME Eip\n@@ -2176,3 +2254,6 @@\n-  \/\/ Do not blow up if no thread info available.\n-  if (thread != NULL) {\n-    thread->as_Java_thread()->set_saved_exception_pc((address)(DWORD_PTR)exceptionInfo->ContextRecord->Eip);\n+  #error unknown architecture\n+#endif\n+\n+  \/\/ Save pc in thread\n+  if (thread != nullptr && thread->is_Java_thread()) {\n+    thread->as_Java_thread()->set_saved_exception_pc((address)(DWORD_PTR)exceptionInfo->ContextRecord->PC_NAME);\n@@ -2180,0 +2261,1 @@\n+\n@@ -2181,2 +2263,1 @@\n-  exceptionInfo->ContextRecord->Eip = (DWORD)(DWORD_PTR)handler;\n-#endif\n+  exceptionInfo->ContextRecord->PC_NAME = (DWORD64)handler;\n@@ -2364,0 +2445,1 @@\n+JNIEXPORT\n@@ -2902,1 +2984,1 @@\n-  p_buf = (char *) VirtualAlloc(addr,\n+  p_buf = (char *) virtualAlloc(addr,\n@@ -2948,1 +3030,1 @@\n-        p_new = (char *) VirtualAlloc(next_alloc_addr,\n+        p_new = (char *) virtualAlloc(next_alloc_addr,\n@@ -2956,1 +3038,1 @@\n-        p_new = (char *)VirtualAllocExNuma(hProc, next_alloc_addr, bytes_to_rq, flags, prot, node);\n+        p_new = (char *)virtualAllocExNuma(hProc, next_alloc_addr, bytes_to_rq, flags, prot, node);\n@@ -3036,1 +3118,0 @@\n-\n@@ -3039,3 +3120,1 @@\n-    _page_sizes[0] = _large_page_size;\n-    _page_sizes[1] = default_page_size;\n-    _page_sizes[2] = 0;\n+    _page_sizes.add(_large_page_size);\n@@ -3102,1 +3181,1 @@\n-  LPVOID addr = MapViewOfFileEx(fileMapping, FILE_MAP_WRITE, 0, 0, size, base);\n+  LPVOID addr = mapViewOfFileEx(fileMapping, FILE_MAP_WRITE, 0, 0, size, base);\n@@ -3117,22 +3196,0 @@\n-\/\/ On win32, one cannot release just a part of reserved memory, it's an\n-\/\/ all or nothing deal.  When we split a reservation, we must break the\n-\/\/ reservation into two reservations.\n-void os::split_reserved_memory(char *base, size_t size, size_t split) {\n-\n-  char* const split_address = base + split;\n-  assert(size > 0, \"Sanity\");\n-  assert(size > split, \"Sanity\");\n-  assert(split > 0, \"Sanity\");\n-  assert(is_aligned(base, os::vm_allocation_granularity()), \"Sanity\");\n-  assert(is_aligned(split_address, os::vm_allocation_granularity()), \"Sanity\");\n-\n-  release_memory(base, size);\n-  attempt_reserve_memory_at(base, split);\n-  attempt_reserve_memory_at(split_address, size - split);\n-\n-  \/\/ NMT: nothing to do here. Since Windows implements the split by\n-  \/\/  releasing and re-reserving memory, the parts are already registered\n-  \/\/  as individual mappings with NMT.\n-\n-}\n-\n@@ -3151,0 +3208,1 @@\n+  static const int max_attempts = 20;\n@@ -3152,4 +3210,3 @@\n-  do {\n-    char* extra_base = file_desc != -1 ?\n-      os::map_memory_to_file(extra_size, file_desc) :\n-      os::reserve_memory(extra_size);\n+  for (int attempt = 0; attempt < max_attempts && aligned_base == NULL; attempt ++) {\n+    char* extra_base = file_desc != -1 ? os::map_memory_to_file(extra_size, file_desc) :\n+                                         os::reserve_memory(extra_size);\n@@ -3162,4 +3219,5 @@\n-    if (file_desc != -1) {\n-      os::unmap_memory(extra_base, extra_size);\n-    } else {\n-      os::release_memory(extra_base, extra_size);\n+    bool rc = (file_desc != -1) ? os::unmap_memory(extra_base, extra_size) :\n+                                  os::release_memory(extra_base, extra_size);\n+    assert(rc, \"release failed\");\n+    if (!rc) {\n+      return NULL;\n@@ -3168,3 +3226,5 @@\n-    aligned_base = file_desc != -1 ?\n-      os::attempt_map_memory_to_file_at(aligned_base, size, file_desc) :\n-      os::attempt_reserve_memory_at(aligned_base, size);\n+    \/\/ Attempt to map, into the just vacated space, the slightly smaller aligned area.\n+    \/\/ Which may fail, hence the loop.\n+    aligned_base = file_desc != -1 ? os::attempt_map_memory_to_file_at(aligned_base, size, file_desc) :\n+                                     os::attempt_reserve_memory_at(aligned_base, size);\n+  }\n@@ -3172,1 +3232,1 @@\n-  } while (aligned_base == NULL);\n+  assert(aligned_base != NULL, \"Did not manage to re-map after %d attempts?\", max_attempts);\n@@ -3177,1 +3237,2 @@\n-char* os::reserve_memory_aligned(size_t size, size_t alignment) {\n+char* os::reserve_memory_aligned(size_t size, size_t alignment, bool exec) {\n+  \/\/ exec can be ignored\n@@ -3185,2 +3246,2 @@\n-char* os::pd_reserve_memory(size_t bytes, bool executable) {\n-  return pd_attempt_reserve_memory_at(NULL \/* addr *\/, bytes);\n+char* os::pd_reserve_memory(size_t bytes, bool exec) {\n+  return pd_attempt_reserve_memory_at(NULL \/* addr *\/, bytes, exec);\n@@ -3191,1 +3252,1 @@\n-char* os::pd_attempt_reserve_memory_at(char* addr, size_t bytes) {\n+char* os::pd_attempt_reserve_memory_at(char* addr, size_t bytes, bool exec) {\n@@ -3200,1 +3261,1 @@\n-    res = (char*)VirtualAlloc(addr, bytes, MEM_RESERVE, PAGE_READWRITE);\n+    res = (char*)virtualAlloc(addr, bytes, MEM_RESERVE, PAGE_READWRITE);\n@@ -3279,1 +3340,1 @@\n-    char * res = (char *)VirtualAlloc(addr, bytes, flag, prot);\n+    char * res = (char *)virtualAlloc(addr, bytes, flag, prot);\n@@ -3316,1 +3377,1 @@\n-    if (VirtualAlloc(addr, bytes, MEM_COMMIT, PAGE_READWRITE) == NULL) {\n+    if (virtualAlloc(addr, bytes, MEM_COMMIT, PAGE_READWRITE) == NULL) {\n@@ -3341,1 +3402,1 @@\n-      if (VirtualAlloc(next_alloc_addr, bytes_to_rq, MEM_COMMIT,\n+      if (virtualAlloc(next_alloc_addr, bytes_to_rq, MEM_COMMIT,\n@@ -3393,1 +3454,1 @@\n-  return (VirtualFree(addr, bytes, MEM_DECOMMIT) != 0);\n+  return (virtualFree(addr, bytes, MEM_DECOMMIT) == TRUE);\n@@ -3397,1 +3458,51 @@\n-  return VirtualFree(addr, 0, MEM_RELEASE) != 0;\n+  \/\/ Given a range we are to release, we require a mapping to start at the beginning of that range;\n+  \/\/  if NUMA or LP we allow the range to contain multiple mappings, which have to cover the range\n+  \/\/  completely; otherwise the range must match an OS mapping exactly.\n+  address start = (address)addr;\n+  address end = start + bytes;\n+  os::win32::mapping_info_t mi;\n+  const bool multiple_mappings_allowed = UseLargePagesIndividualAllocation || UseNUMAInterleaving;\n+  address p = start;\n+  bool first_mapping = true;\n+\n+  do {\n+    \/\/ Find mapping and check it\n+    const char* err = NULL;\n+    if (!os::win32::find_mapping(p, &mi)) {\n+      err = \"no mapping found\";\n+    } else {\n+      if (first_mapping) {\n+        if (mi.base != start) {\n+          err = \"base address mismatch\";\n+        }\n+        if (multiple_mappings_allowed ? (mi.size > bytes) : (mi.size != bytes)) {\n+          err = \"size mismatch\";\n+        }\n+      } else {\n+        assert(p == mi.base && mi.size > 0, \"Sanity\");\n+        if (mi.base + mi.size > end) {\n+          err = \"mapping overlaps end\";\n+        }\n+        if (mi.size == 0) {\n+          err = \"zero length mapping?\"; \/\/ Should never happen; just to prevent endlessly looping in release.\n+        }\n+      }\n+    }\n+    \/\/ Handle mapping error. We assert in debug, unconditionally print a warning in release.\n+    if (err != NULL) {\n+      log_warning(os)(\"bad release: [\" PTR_FORMAT \"-\" PTR_FORMAT \"): %s\", p2i(start), p2i(end), err);\n+#ifdef ASSERT\n+      os::print_memory_mappings((char*)start, bytes, tty);\n+      assert(false, \"bad release: [\" PTR_FORMAT \"-\" PTR_FORMAT \"): %s\", p2i(start), p2i(end), err);\n+#endif\n+      return false;\n+    }\n+    \/\/ Free this range\n+    if (virtualFree(p, 0, MEM_RELEASE) == FALSE) {\n+      return false;\n+    }\n+    first_mapping = false;\n+    p = mi.base + mi.size;\n+  } while (p < end);\n+\n+  return true;\n@@ -3405,1 +3516,1 @@\n-  return os::uncommit_memory(addr, size, !ExecMem);\n+  return os::uncommit_memory(addr, size);\n@@ -4024,2 +4135,0 @@\n-  init_random(1234567);\n-\n@@ -4028,1 +4137,1 @@\n-  init_page_sizes((size_t) win32::vm_page_size());\n+  _page_sizes.add(win32::vm_page_size());\n@@ -4077,13 +4186,7 @@\n-  if (ForceFloatExceptions) {\n-#ifndef  _WIN64\n-    static long fp_control_word = 0;\n-    __asm { fstcw fp_control_word }\n-    \/\/ see Intel PPro Manual, Vol. 2, p 7-16\n-    const long precision = 0x20;\n-    const long underflow = 0x10;\n-    const long overflow  = 0x08;\n-    const long zero_div  = 0x04;\n-    const long denorm    = 0x02;\n-    const long invalid   = 0x01;\n-    fp_control_word |= invalid;\n-    __asm { fldcw fp_control_word }\n+#if defined(ASSERT) && !defined(_WIN64)\n+  static long fp_control_word = 0;\n+  __asm { fstcw fp_control_word }\n+  \/\/ see Intel PPro Manual, Vol. 2, p 7-16\n+  const long invalid   = 0x01;\n+  fp_control_word |= invalid;\n+  __asm { fldcw fp_control_word }\n@@ -4091,1 +4194,0 @@\n-  }\n@@ -4943,1 +5045,1 @@\n-    base = (char*) VirtualAlloc(addr, bytes, MEM_COMMIT | MEM_RESERVE,\n+    base = (char*) virtualAlloc(addr, bytes, MEM_COMMIT | MEM_RESERVE,\n@@ -4946,1 +5048,0 @@\n-      log_info(os)(\"VirtualAlloc() failed: GetLastError->%ld.\", GetLastError());\n@@ -4978,1 +5079,1 @@\n-    base = (char*)MapViewOfFileEx(hMap, access, 0, (DWORD)file_offset,\n+    base = (char*)mapViewOfFileEx(hMap, access, 0, (DWORD)file_offset,\n@@ -4981,1 +5082,0 @@\n-      log_info(os)(\"MapViewOfFileEx() failed: GetLastError->%ld.\", GetLastError());\n@@ -5053,1 +5153,1 @@\n-  BOOL result = UnmapViewOfFile(addr);\n+  BOOL result = unmapViewOfFile(addr);\n@@ -5055,1 +5155,0 @@\n-    log_info(os)(\"UnmapViewOfFile() failed: GetLastError->%ld.\", GetLastError());\n@@ -5786,0 +5885,228 @@\n+\n+#ifdef ASSERT\n+static void check_meminfo(MEMORY_BASIC_INFORMATION* minfo) {\n+  assert(minfo->State == MEM_FREE || minfo->State == MEM_COMMIT || minfo->State == MEM_RESERVE, \"Invalid state\");\n+  if (minfo->State != MEM_FREE) {\n+    assert(minfo->AllocationBase != NULL && minfo->BaseAddress >= minfo->AllocationBase, \"Invalid pointers\");\n+    assert(minfo->RegionSize > 0, \"Invalid region size\");\n+  }\n+}\n+#endif\n+\n+\n+static bool checkedVirtualQuery(address addr, MEMORY_BASIC_INFORMATION* minfo) {\n+  ZeroMemory(minfo, sizeof(MEMORY_BASIC_INFORMATION));\n+  if (::VirtualQuery(addr, minfo, sizeof(MEMORY_BASIC_INFORMATION)) == sizeof(MEMORY_BASIC_INFORMATION)) {\n+    DEBUG_ONLY(check_meminfo(minfo);)\n+    return true;\n+  }\n+  return false;\n+}\n+\n+\/\/ Given a pointer pointing into an allocation (an area allocated with VirtualAlloc),\n+\/\/  return information about that allocation.\n+bool os::win32::find_mapping(address addr, mapping_info_t* mi) {\n+  \/\/ Query at addr to find allocation base; then, starting at allocation base,\n+  \/\/  query all regions, until we either find the next allocation or a free area.\n+  ZeroMemory(mi, sizeof(mapping_info_t));\n+  MEMORY_BASIC_INFORMATION minfo;\n+  address allocation_base = NULL;\n+  address allocation_end = NULL;\n+  bool rc = false;\n+  if (checkedVirtualQuery(addr, &minfo)) {\n+    if (minfo.State != MEM_FREE) {\n+      allocation_base = (address)minfo.AllocationBase;\n+      allocation_end = allocation_base;\n+      \/\/ Iterate through all regions in this allocation to find its end. While we are here, also count things.\n+      for (;;) {\n+        bool rc = checkedVirtualQuery(allocation_end, &minfo);\n+        if (rc == false ||                                       \/\/ VirtualQuery error, end of allocation?\n+           minfo.State == MEM_FREE ||                            \/\/ end of allocation, free memory follows\n+           (address)minfo.AllocationBase != allocation_base)     \/\/ end of allocation, a new one starts\n+        {\n+          break;\n+        }\n+        const size_t region_size = minfo.RegionSize;\n+        mi->regions ++;\n+        if (minfo.State == MEM_COMMIT) {\n+          mi->committed_size += minfo.RegionSize;\n+        }\n+        allocation_end += region_size;\n+      }\n+      if (allocation_base != NULL && allocation_end > allocation_base) {\n+        mi->base = allocation_base;\n+        mi->size = allocation_end - allocation_base;\n+        rc = true;\n+      }\n+    }\n+  }\n+#ifdef ASSERT\n+  if (rc) {\n+    assert(mi->size > 0 && mi->size >= mi->committed_size, \"Sanity\");\n+    assert(addr >= mi->base && addr < mi->base + mi->size, \"Sanity\");\n+    assert(mi->regions > 0, \"Sanity\");\n+  }\n+#endif\n+  return rc;\n+}\n+\n+\/\/ Helper for print_one_mapping: print n words, both as hex and ascii.\n+\/\/ Use Safefetch for all values.\n+static void print_snippet(const void* p, outputStream* st) {\n+  static const int num_words = LP64_ONLY(3) NOT_LP64(6);\n+  static const int num_bytes = num_words * sizeof(int);\n+  intptr_t v[num_words];\n+  const int errval = 0xDE210244;\n+  for (int i = 0; i < num_words; i++) {\n+    v[i] = SafeFetchN((intptr_t*)p + i, errval);\n+    if (v[i] == errval &&\n+        SafeFetchN((intptr_t*)p + i, ~errval) == ~errval) {\n+      return;\n+    }\n+  }\n+  st->put('[');\n+  for (int i = 0; i < num_words; i++) {\n+    st->print(INTPTR_FORMAT \" \", v[i]);\n+  }\n+  const char* b = (char*)v;\n+  st->put('\\\"');\n+  for (int i = 0; i < num_bytes; i++) {\n+    st->put(::isgraph(b[i]) ? b[i] : '.');\n+  }\n+  st->put('\\\"');\n+  st->put(']');\n+}\n+\n+\/\/ Helper function for print_memory_mappings:\n+\/\/  Given a MEMORY_BASIC_INFORMATION, containing information about a non-free region:\n+\/\/  print out all regions in that allocation. If any of those regions\n+\/\/  fall outside the given range [start, end), indicate that in the output.\n+\/\/ Return the pointer to the end of the allocation.\n+static address print_one_mapping(MEMORY_BASIC_INFORMATION* minfo, address start, address end, outputStream* st) {\n+  \/\/ Print it like this:\n+  \/\/\n+  \/\/ Base: <xxxxx>: [xxxx - xxxx], state=MEM_xxx, prot=x, type=MEM_xxx       (region 1)\n+  \/\/                [xxxx - xxxx], state=MEM_xxx, prot=x, type=MEM_xxx       (region 2)\n+  assert(minfo->State != MEM_FREE, \"Not inside an allocation.\");\n+  address allocation_base = (address)minfo->AllocationBase;\n+  #define IS_IN(p) (p >= start && p < end)\n+  bool first_line = true;\n+  bool is_dll = false;\n+  for(;;) {\n+    if (first_line) {\n+      st->print(\"Base \" PTR_FORMAT \": \", p2i(allocation_base));\n+    } else {\n+      st->print_raw(NOT_LP64 (\"                 \")\n+                    LP64_ONLY(\"                         \"));\n+    }\n+    address region_start = (address)minfo->BaseAddress;\n+    address region_end = region_start + minfo->RegionSize;\n+    assert(region_end > region_start, \"Sanity\");\n+    if (region_end <= start) {\n+      st->print(\"<outside range> \");\n+    } else if (region_start >= end) {\n+      st->print(\"<outside range> \");\n+    } else if (!IS_IN(region_start) || !IS_IN(region_end - 1)) {\n+      st->print(\"<partly outside range> \");\n+    }\n+    st->print(\"[\" PTR_FORMAT \"-\" PTR_FORMAT \"), state=\", p2i(region_start), p2i(region_end));\n+    switch (minfo->State) {\n+      case MEM_COMMIT:  st->print_raw(\"MEM_COMMIT \"); break;\n+      case MEM_FREE:    st->print_raw(\"MEM_FREE   \"); break;\n+      case MEM_RESERVE: st->print_raw(\"MEM_RESERVE\"); break;\n+      default: st->print(\"%x?\", (unsigned)minfo->State);\n+    }\n+    st->print(\", prot=%3x, type=\", (unsigned)minfo->Protect);\n+    switch (minfo->Type) {\n+      case MEM_IMAGE:   st->print_raw(\"MEM_IMAGE  \"); break;\n+      case MEM_MAPPED:  st->print_raw(\"MEM_MAPPED \"); break;\n+      case MEM_PRIVATE: st->print_raw(\"MEM_PRIVATE\"); break;\n+      default: st->print(\"%x?\", (unsigned)minfo->State);\n+    }\n+    \/\/ At the start of every allocation, print some more information about this mapping.\n+    \/\/ Notes:\n+    \/\/  - this could be beefed up a lot, similar to os::print_location\n+    \/\/  - for now we just query the allocation start point. This may be confusing for cases where\n+    \/\/    the kernel merges multiple mappings.\n+    if (first_line) {\n+      char buf[MAX_PATH];\n+      if (os::dll_address_to_library_name(allocation_base, buf, sizeof(buf), nullptr)) {\n+        st->print(\", %s\", buf);\n+        is_dll = true;\n+      }\n+    }\n+    \/\/ If memory is accessible, and we do not know anything else about it, print a snippet\n+    if (!is_dll &&\n+        minfo->State == MEM_COMMIT &&\n+        !(minfo->Protect & PAGE_NOACCESS || minfo->Protect & PAGE_GUARD)) {\n+      st->print_raw(\", \");\n+      print_snippet(region_start, st);\n+    }\n+    st->cr();\n+    \/\/ Next region...\n+    bool rc = checkedVirtualQuery(region_end, minfo);\n+    if (rc == false ||                                         \/\/ VirtualQuery error, end of allocation?\n+       (minfo->State == MEM_FREE) ||                           \/\/ end of allocation, free memory follows\n+       ((address)minfo->AllocationBase != allocation_base) ||  \/\/ end of allocation, a new one starts\n+       (region_end > end))                                     \/\/ end of range to print.\n+    {\n+      return region_end;\n+    }\n+    first_line = false;\n+  }\n+  #undef IS_IN\n+  ShouldNotReachHere();\n+  return NULL;\n+}\n+\n+void os::print_memory_mappings(char* addr, size_t bytes, outputStream* st) {\n+  MEMORY_BASIC_INFORMATION minfo;\n+  address start = (address)addr;\n+  address end = start + bytes;\n+  address p = start;\n+  if (p == nullptr) { \/\/ Lets skip the zero pages.\n+    p += os::vm_allocation_granularity();\n+  }\n+  address p2 = p; \/\/ guard against wraparounds\n+  int fuse = 0;\n+\n+  while (p < end && p >= p2) {\n+    p2 = p;\n+    \/\/ Probe for the next mapping.\n+    if (checkedVirtualQuery(p, &minfo)) {\n+      if (minfo.State != MEM_FREE) {\n+        \/\/ Found one. Print it out.\n+        address p2 = print_one_mapping(&minfo, start, end, st);\n+        assert(p2 > p, \"Sanity\");\n+        p = p2;\n+      } else {\n+        \/\/ Note: for free regions, most of MEMORY_BASIC_INFORMATION is undefined.\n+        \/\/  Only region dimensions are not: use those to jump to the end of\n+        \/\/  the free range.\n+        address region_start = (address)minfo.BaseAddress;\n+        address region_end = region_start + minfo.RegionSize;\n+        assert(p >= region_start && p < region_end, \"Sanity\");\n+        p = region_end;\n+      }\n+    } else {\n+      \/\/ MSDN doc on VirtualQuery is unclear about what it means if it returns an error.\n+      \/\/  In particular, whether querying an address outside any mappings would report\n+      \/\/  a MEM_FREE region or just return an error. From experiments, it seems to return\n+      \/\/  a MEM_FREE region for unmapped areas in valid address space and an error if we\n+      \/\/  are outside valid address space.\n+      \/\/ Here, we advance the probe pointer by alloc granularity. But if the range to print\n+      \/\/  is large, this may take a long time. Therefore lets stop right away if the address\n+      \/\/  is outside of what we know are valid addresses on Windows. Also, add a loop fuse.\n+      static const address end_virt = (address)(LP64_ONLY(0x7ffffffffffULL) NOT_LP64(3*G));\n+      if (p >= end_virt) {\n+        break;\n+      } else {\n+        \/\/ Advance probe pointer, but with a fuse to break long loops.\n+        if (fuse++ == 100000) {\n+          break;\n+        }\n+        p += os::vm_allocation_granularity();\n+      }\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":427,"deletions":100,"binary":false,"changes":527,"status":"modified"},{"patch":"@@ -54,1 +54,3 @@\n-inline void OrderAccess::cross_modify_fence() { }\n+inline void OrderAccess::cross_modify_fence_impl() {\n+  asm volatile(\"isb\" : : : \"memory\");\n+}\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/orderAccess_bsd_aarch64.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-address os::Bsd::ucontext_get_pc(const ucontext_t * uc) {\n+address os::Posix::ucontext_get_pc(const ucontext_t * uc) {\n@@ -141,1 +141,1 @@\n-void os::Bsd::ucontext_set_pc(ucontext_t * uc, address pc) {\n+void os::Posix::ucontext_set_pc(ucontext_t * uc, address pc) {\n@@ -160,1 +160,1 @@\n-    epc = os::Bsd::ucontext_get_pc(uc);\n+    epc = os::Posix::ucontext_get_pc(uc);\n@@ -229,1 +229,1 @@\n-    pc = (address) os::Bsd::ucontext_get_pc(uc);\n+    pc = (address) os::Posix::ucontext_get_pc(uc);\n@@ -232,1 +232,1 @@\n-      os::Bsd::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));\n+      os::Posix::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));\n@@ -361,1 +361,1 @@\n-    address pc = os::Bsd::ucontext_get_pc(uc);\n+    address pc = os::Posix::ucontext_get_pc(uc);\n@@ -398,1 +398,1 @@\n-    os::Bsd::ucontext_set_pc(uc, stub);\n+    os::Posix::ucontext_set_pc(uc, stub);\n@@ -598,1 +598,1 @@\n-  address pc = os::Bsd::ucontext_get_pc(uc);\n+  address pc = os::Posix::ucontext_get_pc(uc);\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/os_bsd_aarch64.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -41,0 +41,4 @@\n+  static ByteSize saved_fp_address_offset() {\n+    return byte_offset_of(JavaThread, _anchor) + JavaFrameAnchor::saved_fp_address_offset();\n+  }\n+\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/thread_bsd_aarch64.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,6 @@\n+private:\n+\n+  static void current_thread_enable_wx_impl(WXMode mode) { }\n+\n+public:\n+\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/os_windows_aarch64.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,1 @@\n+#include \"oops\/klass.inline.hpp\"\n@@ -58,0 +59,1 @@\n+#include \"prims\/jvmtiExport.hpp\"\n@@ -67,0 +69,1 @@\n+#include \"runtime\/stubRoutines.hpp\"\n@@ -530,5 +533,14 @@\n-#ifdef ASSERT\n-  \/\/ Check that exception is a subclass of Throwable, otherwise we have a VerifyError\n-  if (!(exception->is_a(SystemDictionary::Throwable_klass()))) {\n-    if (ExitVMOnVerifyError) vm_exit(-1);\n-    ShouldNotReachHere();\n+  \/\/ Check that exception is a subclass of Throwable\n+  assert(exception->is_a(SystemDictionary::Throwable_klass()),\n+         \"Exception not subclass of Throwable\");\n+\n+  \/\/ debugging support\n+  \/\/ tracing\n+  if (log_is_enabled(Info, exceptions)) {\n+    ResourceMark rm;\n+    stringStream tempst;\n+    assert(nm->method() != NULL, \"Unexpected NULL method()\");\n+    tempst.print(\"C1 compiled method <%s>\\n\"\n+                 \" at PC\" INTPTR_FORMAT \" for thread \" INTPTR_FORMAT,\n+                 nm->method()->print_value_string(), p2i(pc), p2i(thread));\n+    Exceptions::log_exception(exception, tempst.as_string());\n@@ -537,1 +549,2 @@\n-#endif\n+  \/\/ for AbortVMOnException flag\n+  Exceptions::debug_check_abort(exception);\n@@ -585,14 +598,0 @@\n-    \/\/ debugging support\n-    \/\/ tracing\n-    if (log_is_enabled(Info, exceptions)) {\n-      ResourceMark rm;\n-      stringStream tempst;\n-      assert(nm->method() != NULL, \"Unexpected NULL method()\");\n-      tempst.print(\"compiled method <%s>\\n\"\n-                   \" at PC\" INTPTR_FORMAT \" for thread \" INTPTR_FORMAT,\n-                   nm->method()->print_value_string(), p2i(pc), p2i(thread));\n-      Exceptions::log_exception(exception, tempst.as_string());\n-    }\n-    \/\/ for AbortVMOnException flag\n-    Exceptions::debug_check_abort(exception);\n-\n@@ -644,1 +643,1 @@\n-  DEBUG_ONLY(ResetNoHandleMark rnhm);\n+  DEBUG_ONLY(NoHandleMark nhm);\n@@ -1313,1 +1312,0 @@\n-\n@@ -1332,1 +1330,0 @@\n-\n@@ -1351,1 +1348,0 @@\n-\n@@ -1371,5 +1367,6 @@\n-\/\/\n-\/\/ NOTE: we are still in Java\n-\/\/\n-  Thread* THREAD = thread;\n-  debug_only(NoHandleMark nhm;)\n+  \/\/\n+  \/\/ NOTE: we are still in Java\n+  \/\/\n+  \/\/ Handles created in this function will be deleted by the\n+  \/\/ HandleMarkCleaner in the transition to the VM.\n+  NoHandleMark nhm;\n@@ -1378,1 +1375,0 @@\n-\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":27,"deletions":31,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,0 @@\n-  ResetNoHandleMark rnhm;                   \\\n","filename":"src\/hotspot\/share\/ci\/ciUtilities.inline.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,1 @@\n+#include \"oops\/klass.inline.hpp\"\n@@ -143,2 +144,3 @@\n-ClassPathEntry* ClassLoader::_first_append_entry = NULL;\n-ClassPathEntry* ClassLoader::_last_append_entry  = NULL;\n+\n+ClassPathEntry* volatile ClassLoader::_first_append_entry_list = NULL;\n+ClassPathEntry* volatile ClassLoader::_last_append_entry  = NULL;\n@@ -821,1 +823,1 @@\n-  ClassPathEntry* e = _first_append_entry;\n+  ClassPathEntry* e = first_append_entry();\n@@ -832,0 +834,1 @@\n+\/\/ The boot append entries are added with a lock, and read lock free.\n@@ -834,0 +837,1 @@\n+    MutexLocker ml(Bootclasspath_lock, Mutex::_no_safepoint_check_flag);\n@@ -835,2 +839,3 @@\n-      assert(_first_append_entry == NULL, \"boot loader's append class path entry list not empty\");\n-      _first_append_entry = _last_append_entry = new_entry;\n+      _last_append_entry = new_entry;\n+      assert(first_append_entry() == NULL, \"boot loader's append class path entry list not empty\");\n+      Atomic::release_store(&_first_append_entry_list, new_entry);\n@@ -950,1 +955,1 @@\n-  e = _first_append_entry;\n+  e = first_append_entry();\n@@ -1258,1 +1263,1 @@\n-    e = _first_append_entry;\n+    e = first_append_entry();\n@@ -1433,1 +1438,1 @@\n-\/\/ it can be appended to and is by jvmti and the kernel vm.\n+\/\/ it can be appended to and is by jvmti.\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"classfile\/javaThreadStatus.hpp\"\n@@ -46,1 +47,1 @@\n-#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/instanceKlass.inline.hpp\"\n@@ -49,0 +50,1 @@\n+#include \"oops\/klass.inline.hpp\"\n@@ -894,1 +896,1 @@\n-  if (k->is_shared() && k->has_raw_archived_mirror()) {\n+  if (k->is_shared() && k->has_archived_mirror_index()) {\n@@ -901,1 +903,1 @@\n-      k->clear_has_raw_archived_mirror();\n+      k->clear_archived_mirror_index();\n@@ -1167,3 +1169,3 @@\n-  if (k->has_raw_archived_mirror()) {\n-    assert(k->archived_java_mirror_raw() != NULL, \"no archived mirror\");\n-    return k->archived_java_mirror_raw();\n+  if (k->has_archived_mirror_index()) {\n+    assert(k->archived_java_mirror() != NULL, \"no archived mirror\");\n+    return k->archived_java_mirror();\n@@ -1201,3 +1203,1 @@\n-  k->set_archived_java_mirror_raw(archived_mirror);\n-\n-  k->set_has_raw_archived_mirror();\n+  k->set_archived_java_mirror(archived_mirror);\n@@ -1321,4 +1321,5 @@\n-  oop m = HeapShared::materialize_archived_object(k->archived_java_mirror_raw_narrow());\n-  if (m == NULL) {\n-    return false;\n-  }\n+  oop m = k->archived_java_mirror();\n+  assert(m != NULL, \"must have stored non-null archived mirror\");\n+\n+  \/\/ Sanity: clear it now to prevent re-initialization if any of the following fails\n+  k->clear_archived_mirror_index();\n@@ -1350,1 +1351,0 @@\n-  k->clear_has_raw_archived_mirror();\n@@ -1820,2 +1820,2 @@\n-                                         java_lang_Thread::ThreadStatus status) {\n-  java_thread->int_field_put(_thread_status_offset, status);\n+                                         JavaThreadStatus status) {\n+  java_thread->int_field_put(_thread_status_offset, static_cast<int>(status));\n@@ -1825,1 +1825,1 @@\n-java_lang_Thread::ThreadStatus java_lang_Thread::get_thread_status(oop java_thread) {\n+JavaThreadStatus java_lang_Thread::get_thread_status(oop java_thread) {\n@@ -1831,1 +1831,1 @@\n-  return (java_lang_Thread::ThreadStatus)java_thread->int_field(_thread_status_offset);\n+  return static_cast<JavaThreadStatus>(java_thread->int_field(_thread_status_offset));\n@@ -1844,1 +1844,1 @@\n-  ThreadStatus status = (java_lang_Thread::ThreadStatus)java_thread->int_field(_thread_status_offset);\n+  JavaThreadStatus status = static_cast<JavaThreadStatus>(java_thread->int_field(_thread_status_offset));\n@@ -1846,9 +1846,9 @@\n-    case NEW                      : return \"NEW\";\n-    case RUNNABLE                 : return \"RUNNABLE\";\n-    case SLEEPING                 : return \"TIMED_WAITING (sleeping)\";\n-    case IN_OBJECT_WAIT           : return \"WAITING (on object monitor)\";\n-    case IN_OBJECT_WAIT_TIMED     : return \"TIMED_WAITING (on object monitor)\";\n-    case PARKED                   : return \"WAITING (parking)\";\n-    case PARKED_TIMED             : return \"TIMED_WAITING (parking)\";\n-    case BLOCKED_ON_MONITOR_ENTER : return \"BLOCKED (on object monitor)\";\n-    case TERMINATED               : return \"TERMINATED\";\n+    case JavaThreadStatus::NEW                      : return \"NEW\";\n+    case JavaThreadStatus::RUNNABLE                 : return \"RUNNABLE\";\n+    case JavaThreadStatus::SLEEPING                 : return \"TIMED_WAITING (sleeping)\";\n+    case JavaThreadStatus::IN_OBJECT_WAIT           : return \"WAITING (on object monitor)\";\n+    case JavaThreadStatus::IN_OBJECT_WAIT_TIMED     : return \"TIMED_WAITING (on object monitor)\";\n+    case JavaThreadStatus::PARKED                   : return \"WAITING (parking)\";\n+    case JavaThreadStatus::PARKED_TIMED             : return \"TIMED_WAITING (parking)\";\n+    case JavaThreadStatus::BLOCKED_ON_MONITOR_ENTER : return \"BLOCKED (on object monitor)\";\n+    case JavaThreadStatus::TERMINATED               : return \"TERMINATED\";\n@@ -2002,1 +2002,1 @@\n-  PRESERVE_EXCEPTION_MARK;  \/\/ Keep original exception\n+  PreserveExceptionMark pm(Thread::current());\n@@ -2192,1 +2192,1 @@\n-  void set_has_hidden_top_frame(TRAPS) {\n+  void set_has_hidden_top_frame() {\n@@ -2530,1 +2530,1 @@\n-          bt.set_has_hidden_top_frame(CHECK);\n+          bt.set_has_hidden_top_frame();\n@@ -2557,1 +2557,2 @@\n-  PRESERVE_EXCEPTION_MARK;\n+  JavaThread* THREAD = JavaThread::current();\n+  PreserveExceptionMark pm(THREAD);\n@@ -2559,3 +2560,3 @@\n-  JavaThread* thread = JavaThread::active();\n-  fill_in_stack_trace(throwable, method, thread);\n-  \/\/ ignore exceptions thrown during stack trace filling\n+  fill_in_stack_trace(throwable, method, THREAD);\n+  \/\/ Ignore exceptions thrown during stack trace filling (OOM) and reinstall the\n+  \/\/ original exception via the PreserveExceptionMark destructor.\n@@ -3821,0 +3822,59 @@\n+int jdk_internal_invoke_NativeEntryPoint::_addr_offset;\n+int jdk_internal_invoke_NativeEntryPoint::_shadow_space_offset;\n+int jdk_internal_invoke_NativeEntryPoint::_argMoves_offset;\n+int jdk_internal_invoke_NativeEntryPoint::_returnMoves_offset;\n+int jdk_internal_invoke_NativeEntryPoint::_need_transition_offset;\n+int jdk_internal_invoke_NativeEntryPoint::_method_type_offset;\n+int jdk_internal_invoke_NativeEntryPoint::_name_offset;\n+\n+#define NEP_FIELDS_DO(macro) \\\n+  macro(_addr_offset,            k, \"addr\",           long_signature, false); \\\n+  macro(_shadow_space_offset,    k, \"shadowSpace\",    int_signature, false); \\\n+  macro(_argMoves_offset,        k, \"argMoves\",       long_array_signature, false); \\\n+  macro(_returnMoves_offset,     k, \"returnMoves\",    long_array_signature, false); \\\n+  macro(_need_transition_offset, k, \"needTransition\", bool_signature, false); \\\n+  macro(_method_type_offset,     k, \"methodType\",     java_lang_invoke_MethodType_signature, false); \\\n+  macro(_name_offset,            k, \"name\",           string_signature, false);\n+\n+bool jdk_internal_invoke_NativeEntryPoint::is_instance(oop obj) {\n+  return obj != NULL && is_subclass(obj->klass());\n+}\n+\n+void jdk_internal_invoke_NativeEntryPoint::compute_offsets() {\n+  InstanceKlass* k = SystemDictionary::NativeEntryPoint_klass();\n+  NEP_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n+}\n+\n+#if INCLUDE_CDS\n+void jdk_internal_invoke_NativeEntryPoint::serialize_offsets(SerializeClosure* f) {\n+  NEP_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n+}\n+#endif\n+\n+address jdk_internal_invoke_NativeEntryPoint::addr(oop entry) {\n+  return (address)entry->long_field(_addr_offset);\n+}\n+\n+jint jdk_internal_invoke_NativeEntryPoint::shadow_space(oop entry) {\n+  return entry->int_field(_shadow_space_offset);\n+}\n+\n+oop jdk_internal_invoke_NativeEntryPoint::argMoves(oop entry) {\n+  return entry->obj_field(_argMoves_offset);\n+}\n+\n+oop jdk_internal_invoke_NativeEntryPoint::returnMoves(oop entry) {\n+  return entry->obj_field(_returnMoves_offset);\n+}\n+\n+jboolean jdk_internal_invoke_NativeEntryPoint::need_transition(oop entry) {\n+  return entry->bool_field(_need_transition_offset);\n+}\n+\n+oop jdk_internal_invoke_NativeEntryPoint::method_type(oop entry) {\n+  return entry->obj_field(_method_type_offset);\n+}\n+\n+oop jdk_internal_invoke_NativeEntryPoint::name(oop entry) {\n+  return entry->obj_field(_name_offset);\n+}\n@@ -4173,1 +4233,0 @@\n-  \/\/ whitelist AccessControlContexts created by the JVM\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":96,"deletions":37,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -45,1 +45,2 @@\n-#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/instanceKlass.inline.hpp\"\n+#include \"oops\/klass.inline.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"classfile\/javaClasses.hpp\"\n@@ -49,0 +50,1 @@\n+#include \"prims\/jvmtiExport.hpp\"\n@@ -1587,2 +1589,2 @@\n-  if (excluded || (CompilerOracle::has_option_value(method, \"CompileThresholdScaling\", scale) && scale == 0)) {\n-    bool quietly = CompilerOracle::should_exclude_quietly();\n+  if (excluded || (CompilerOracle::has_option_value(method, CompileCommand::CompileThresholdScaling, scale) && scale == 0)) {\n+    bool quietly = CompilerOracle::be_quiet();\n@@ -1805,1 +1807,0 @@\n-    ResetNoHandleMark rnhm;\n@@ -2725,7 +2726,0 @@\n-#if INCLUDE_JVMCI\n-  \/\/ In hosted mode, print the JVMCI compiler specific counters manually.\n-  if (EnableJVMCI && !UseJVMCICompiler) {\n-    JVMCICompiler::print_compilation_timers();\n-  }\n-#endif\n-\n@@ -2781,0 +2775,7 @@\n+#if INCLUDE_JVMCI\n+  if (EnableJVMCI) {\n+    tty->cr();\n+    JVMCICompiler::print_hosted_timers();\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+#include \"oops\/klass.inline.hpp\"\n+#include \"prims\/jvmtiExport.hpp\"\n@@ -947,0 +949,4 @@\n+  if (_has_auto_box) {\n+    JavaThread* THREAD = JavaThread::current();\n+    JVMCI::ensure_box_caches_initialized(CHECK_(JVMCI::ok));\n+  }\n@@ -1030,0 +1036,3 @@\n+    if (is_auto_box) {\n+      _has_auto_box = true;\n+    }\n@@ -1051,0 +1060,1 @@\n+\n@@ -1193,0 +1203,1 @@\n+  const bool is_opt_native         = false;\n@@ -1195,1 +1206,1 @@\n-  _debug_recorder->describe_scope(pc_offset, method, NULL, bci, reexecute, throw_exception, is_mh_invoke, return_oop,\n+  _debug_recorder->describe_scope(pc_offset, method, NULL, bci, reexecute, throw_exception, is_mh_invoke, is_opt_native, return_oop,\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+#include \"oops\/instanceKlass.inline.hpp\"\n@@ -46,0 +47,1 @@\n+#include \"prims\/jvmtiExport.hpp\"\n@@ -128,1 +130,0 @@\n-  ResetNoHandleMark rnhm;                     \\\n@@ -135,1 +136,0 @@\n-  TRACE_CALL(result_type, jvmci_ ## name signature)  \\\n@@ -840,1 +840,1 @@\n-  TraceTime install_time(\"installCode\", JVMCICompiler::codeInstallTimer());\n+  TraceTime install_time(\"installCode\", JVMCICompiler::codeInstallTimer(!thread->is_Compiler_thread()));\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+#include \"oops\/klass.inline.hpp\"\n@@ -41,0 +42,1 @@\n+#include \"prims\/jvmtiExport.hpp\"\n@@ -52,1 +54,1 @@\n-#include \"gc\/g1\/g1ThreadLocalData.hpp\"\n+#include \"gc\/g1\/g1BarrierSetRuntime.hpp\"\n@@ -258,1 +260,0 @@\n-#ifdef ASSERT\n@@ -261,4 +262,14 @@\n-  \/\/ Check that exception is a subclass of Throwable, otherwise we have a VerifyError\n-  if (!(exception->is_a(SystemDictionary::Throwable_klass()))) {\n-    if (ExitVMOnVerifyError) vm_exit(-1);\n-    ShouldNotReachHere();\n+  \/\/ Check that exception is a subclass of Throwable\n+  assert(exception->is_a(SystemDictionary::Throwable_klass()),\n+         \"Exception not subclass of Throwable\");\n+\n+  \/\/ debugging support\n+  \/\/ tracing\n+  if (log_is_enabled(Info, exceptions)) {\n+    ResourceMark rm;\n+    stringStream tempst;\n+    assert(cm->method() != NULL, \"Unexpected null method()\");\n+    tempst.print(\"JVMCI compiled method <%s>\\n\"\n+                 \" at PC\" INTPTR_FORMAT \" for thread \" INTPTR_FORMAT,\n+                 cm->method()->print_value_string(), p2i(pc), p2i(thread));\n+    Exceptions::log_exception(exception, tempst.as_string());\n@@ -266,1 +277,2 @@\n-#endif\n+  \/\/ for AbortVMOnException flag\n+  Exceptions::debug_check_abort(exception);\n@@ -314,14 +326,0 @@\n-    \/\/ debugging support\n-    \/\/ tracing\n-    if (log_is_enabled(Info, exceptions)) {\n-      ResourceMark rm;\n-      stringStream tempst;\n-      assert(cm->method() != NULL, \"Unexpected null method()\");\n-      tempst.print(\"compiled method <%s>\\n\"\n-                   \" at PC\" INTPTR_FORMAT \" for thread \" INTPTR_FORMAT,\n-                   cm->method()->print_value_string(), p2i(pc), p2i(thread));\n-      Exceptions::log_exception(exception, tempst.as_string());\n-    }\n-    \/\/ for AbortVMOnException flag\n-    NOT_PRODUCT(Exceptions::debug_check_abort(exception));\n-\n@@ -373,1 +371,1 @@\n-  DEBUG_ONLY(ResetNoHandleMark rnhm);\n+  DEBUG_ONLY(NoHandleMark nhm);\n@@ -483,3 +481,3 @@\n-JRT_LEAF(void, JVMCIRuntime::write_barrier_pre(JavaThread* thread, oopDesc* obj))\n-  G1ThreadLocalData::satb_mark_queue(thread).enqueue(obj);\n-JRT_END\n+void JVMCIRuntime::write_barrier_pre(JavaThread* thread, oopDesc* obj) {\n+  G1BarrierSetRuntime::write_ref_field_pre_entry(obj, thread);\n+}\n@@ -487,3 +485,3 @@\n-JRT_LEAF(void, JVMCIRuntime::write_barrier_post(JavaThread* thread, void* card_addr))\n-  G1ThreadLocalData::dirty_card_queue(thread).enqueue(card_addr);\n-JRT_END\n+void JVMCIRuntime::write_barrier_post(JavaThread* thread, volatile CardValue* card_addr) {\n+  G1BarrierSetRuntime::write_ref_field_post_entry(card_addr, thread);\n+}\n@@ -715,0 +713,6 @@\n+\n+  if (_nmethod_mirror_index != -1 && nm->is_unloaded()) {\n+    \/\/ Drop the reference to the nmethod mirror object but don't clear the actual oop reference.  Otherwise\n+    \/\/ it would appear that the nmethod didn't need to be unloaded in the first place.\n+    _nmethod_mirror_index = -1;\n+  }\n@@ -1087,1 +1091,1 @@\n-void JVMCIRuntime::exit_on_pending_exception(JVMCIEnv* JVMCIENV, const char* message) {\n+void JVMCIRuntime::fatal_exception(JVMCIEnv* JVMCIENV, const char* message) {\n@@ -1103,3 +1107,1 @@\n-\n-  before_exit(THREAD);\n-  vm_exit(-1);\n+  fatal(\"Fatal exception in JVMCI: %s\", message);\n@@ -1459,13 +1461,0 @@\n-\/\/ Reports a pending exception and exits the VM.\n-static void fatal_exception_in_compile(JVMCIEnv* JVMCIENV, JavaThread* thread, const char* msg) {\n-  \/\/ Only report a fatal JVMCI compilation exception once\n-  static volatile int report_init_failure = 0;\n-  if (!report_init_failure && Atomic::cmpxchg(&report_init_failure, 0, 1) == 0) {\n-      tty->print_cr(\"%s:\", msg);\n-      JVMCIENV->describe_pending_exception(true);\n-  }\n-  JVMCIENV->clear_pending_exception();\n-  before_exit(thread);\n-  vm_exit(-1);\n-}\n-\n@@ -1492,1 +1481,1 @@\n-    fatal_exception_in_compile(JVMCIENV, thread, \"Exception during HotSpotJVMCIRuntime initialization\");\n+    fatal_exception(JVMCIENV, \"Exception during HotSpotJVMCIRuntime initialization\");\n@@ -1527,1 +1516,1 @@\n-    fatal_exception_in_compile(JVMCIENV, thread, \"Exception during JVMCI compiler initialization\");\n+    fatal_exception(JVMCIENV, \"Exception during JVMCI compiler initialization\");\n@@ -1534,0 +1523,9 @@\n+bool JVMCIRuntime::is_gc_supported(JVMCIEnv* JVMCIENV, CollectedHeap::Name name) {\n+  JVMCI_EXCEPTION_CONTEXT\n+\n+  JVMCIObject receiver = get_HotSpotJVMCIRuntime(JVMCIENV);\n+  if (JVMCIENV->has_pending_exception()) {\n+    fatal_exception(JVMCIENV, \"Exception during HotSpotJVMCIRuntime initialization\");\n+  }\n+  return JVMCIENV->call_HotSpotJVMCIRuntime_isGCSupported(receiver, (int) name);\n+}\n@@ -1631,1 +1629,1 @@\n-                                 compiler, comp_level,\n+                                 compiler, comp_level, GrowableArrayView<BufferBlob*>::EMPTY,\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":47,"deletions":49,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -35,2 +35,1 @@\n-  friend class LogStreamTest_TestLineBufferAllocation_vm_Test;\n-  friend class LogStreamTest_TestLineBufferAllocationCap_vm_Test;\n+  friend class LogStreamTest;\n","filename":"src\/hotspot\/share\/logging\/logStream.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+#include \"prims\/jvmtiExport.hpp\"\n@@ -788,3 +789,0 @@\n-  if (Matcher::pass_original_key_for_aes()) {\n-    num_args = 4;\n-  }\n@@ -797,3 +795,0 @@\n-  if (Matcher::pass_original_key_for_aes()) {\n-    fields[argp++] = TypePtr::NOTNULL;    \/\/ original k array\n-  }\n@@ -881,3 +876,0 @@\n-  if (Matcher::pass_original_key_for_aes()) {\n-    num_args = 6;\n-  }\n@@ -892,3 +884,0 @@\n-  if (Matcher::pass_original_key_for_aes()) {\n-    fields[argp++] = TypePtr::NOTNULL;    \/\/ original k array\n-  }\n@@ -909,3 +898,0 @@\n-  if (Matcher::pass_original_key_for_aes()) {\n-     num_args = 5;\n-  }\n@@ -919,3 +905,0 @@\n-  if (Matcher::pass_original_key_for_aes()) {\n-     fields[argp++] = TypePtr::NOTNULL;    \/\/ original k array\n-  }\n@@ -936,3 +919,0 @@\n-  if (Matcher::pass_original_key_for_aes()) {\n-    num_args = 8;\n-  }\n@@ -949,3 +929,0 @@\n-  if (Matcher::pass_original_key_for_aes()) {\n-    fields[argp++] = TypePtr::NOTNULL; \/\/ original k array\n-  }\n@@ -1197,0 +1174,21 @@\n+\/\/ Base64 decode function\n+const TypeFunc* OptoRuntime::base64_decodeBlock_Type() {\n+  int argcnt = 6;\n+\n+  const Type** fields = TypeTuple::fields(argcnt);\n+  int argp = TypeFunc::Parms;\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ src array\n+  fields[argp++] = TypeInt::INT;        \/\/ src offset\n+  fields[argp++] = TypeInt::INT;        \/\/ src length\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ dest array\n+  fields[argp++] = TypeInt::INT;        \/\/ dest offset\n+  fields[argp++] = TypeInt::BOOL;       \/\/ isURL\n+  assert(argp == TypeFunc::Parms + argcnt, \"correct decoding\");\n+  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);\n+\n+  \/\/ result type needed\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms + 0] = TypeInt::INT; \/\/ count of bytes written to dst\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);\n+  return TypeFunc::make(domain, range);\n+}\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":22,"deletions":24,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+#include \"classfile\/javaThreadStatus.hpp\"\n@@ -40,0 +41,1 @@\n+#include \"compiler\/compiler_globals.hpp\"\n@@ -51,1 +53,1 @@\n-#include \"oops\/arrayOop.inline.hpp\"\n+#include \"oops\/arrayOop.hpp\"\n@@ -54,0 +56,1 @@\n+#include \"oops\/klass.inline.hpp\"\n@@ -87,1 +90,0 @@\n-#include \"utilities\/histogram.hpp\"\n@@ -261,43 +263,0 @@\n-\/\/ Wrapper to trace JNI functions\n-\n-#ifdef ASSERT\n-  Histogram* JNIHistogram;\n-  static volatile int JNIHistogram_lock = 0;\n-\n-  class JNIHistogramElement : public HistogramElement {\n-    public:\n-     JNIHistogramElement(const char* name);\n-  };\n-\n-  JNIHistogramElement::JNIHistogramElement(const char* elementName) {\n-    _name = elementName;\n-    uintx count = 0;\n-\n-    while (Atomic::cmpxchg(&JNIHistogram_lock, 0, 1) != 0) {\n-      while (Atomic::load_acquire(&JNIHistogram_lock) != 0) {\n-        count +=1;\n-        if ( (WarnOnStalledSpinLock > 0)\n-          && (count % WarnOnStalledSpinLock == 0)) {\n-          warning(\"JNIHistogram_lock seems to be stalled\");\n-        }\n-      }\n-     }\n-\n-\n-    if(JNIHistogram == NULL)\n-      JNIHistogram = new Histogram(\"JNI Call Counts\",100);\n-\n-    JNIHistogram->add_element(this);\n-    Atomic::dec(&JNIHistogram_lock);\n-  }\n-\n-  #define JNICountWrapper(arg)                                     \\\n-     static JNIHistogramElement* e = new JNIHistogramElement(arg); \\\n-      \/* There is a MT-race condition in VC++. So we need to make sure that that e has been initialized *\/ \\\n-     if (e != NULL) e->increment_count()\n-  #define JNIWrapper(arg) JNICountWrapper(arg);\n-#else\n-  #define JNIWrapper(arg)\n-#endif\n-\n-\n@@ -311,2 +270,0 @@\n-  JNIWrapper(\"DefineClass\");\n-\n@@ -357,2 +314,0 @@\n-  JNIWrapper(\"FindClass\");\n-\n@@ -413,2 +368,0 @@\n-  JNIWrapper(\"FromReflectedMethod\");\n-\n@@ -446,2 +399,0 @@\n-  JNIWrapper(\"FromReflectedField\");\n-\n@@ -488,2 +439,0 @@\n-  JNIWrapper(\"ToReflectedMethod\");\n-\n@@ -511,2 +460,0 @@\n-  JNIWrapper(\"GetSuperclass\");\n-\n@@ -542,2 +489,0 @@\n-  JNIWrapper(\"IsSubclassOf\");\n-\n@@ -570,2 +515,0 @@\n-  JNIWrapper(\"Throw\");\n-\n@@ -587,2 +530,0 @@\n-  JNIWrapper(\"ThrowNew\");\n-\n@@ -619,2 +560,0 @@\n-  JNIWrapper(\"ExceptionOccurred\");\n-\n@@ -633,2 +572,0 @@\n-  JNIWrapper(\"ExceptionDescribe\");\n-\n@@ -677,2 +614,0 @@\n-  JNIWrapper(\"ExceptionClear\");\n-\n@@ -694,2 +629,0 @@\n-  JNIWrapper(\"FatalError\");\n-\n@@ -705,2 +638,0 @@\n-  JNIWrapper(\"PushLocalFrame\");\n-\n@@ -727,2 +658,0 @@\n-  JNIWrapper(\"PopLocalFrame\");\n-\n@@ -751,2 +680,0 @@\n-  JNIWrapper(\"NewGlobalRef\");\n-\n@@ -764,2 +691,0 @@\n-  JNIWrapper(\"DeleteGlobalRef\");\n-\n@@ -774,2 +699,0 @@\n-  JNIWrapper(\"DeleteLocalRef\");\n-\n@@ -784,2 +707,0 @@\n-  JNIWrapper(\"IsSameObject\");\n-\n@@ -796,2 +717,0 @@\n-  JNIWrapper(\"NewLocalRef\");\n-\n@@ -808,2 +727,0 @@\n-  JNIWrapper(\"EnsureLocalCapacity\");\n-\n@@ -826,2 +743,0 @@\n-  JNIWrapper(\"GetObjectRefType\");\n-\n@@ -871,1 +786,0 @@\n- protected:\n@@ -907,0 +821,4 @@\n+  ~JNI_ArgumentPusherVaArg() {\n+    va_end(_ap);\n+  }\n+\n@@ -1049,2 +967,0 @@\n-  JNIWrapper(\"AllocObject\");\n-\n@@ -1065,2 +981,0 @@\n-  JNIWrapper(\"NewObjectA\");\n-\n@@ -1085,2 +999,0 @@\n-  JNIWrapper(\"NewObjectV\");\n-\n@@ -1105,2 +1017,0 @@\n-  JNIWrapper(\"NewObject\");\n-\n@@ -1125,2 +1035,0 @@\n-  JNIWrapper(\"GetObjectClass\");\n-\n@@ -1138,2 +1046,0 @@\n-  JNIWrapper(\"IsInstanceOf\");\n-\n@@ -1213,1 +1119,0 @@\n-  JNIWrapper(\"GetMethodID\");\n@@ -1223,1 +1128,0 @@\n-  JNIWrapper(\"GetStaticMethodID\");\n@@ -1245,1 +1149,0 @@\n-  JNIWrapper(\"Call\" XSTR(Result) \"Method\"); \\\n@@ -1301,1 +1204,0 @@\n-  JNIWrapper(\"Call\" XSTR(Result) \"MethodV\"); \\\n@@ -1354,1 +1256,0 @@\n-  JNIWrapper(\"Call\" XSTR(Result) \"MethodA\"); \\\n@@ -1404,1 +1305,0 @@\n-  JNIWrapper(\"CallVoidMethod\");\n@@ -1418,1 +1318,0 @@\n-  JNIWrapper(\"CallVoidMethodV\");\n@@ -1429,1 +1328,0 @@\n-  JNIWrapper(\"CallVoidMethodA\");\n@@ -1448,1 +1346,0 @@\n-  JNIWrapper(\"CallNonvitual\" XSTR(Result) \"Method\"); \\\n@@ -1504,1 +1401,0 @@\n-  JNIWrapper(\"CallNonvitual\" XSTR(Result) \"MethodV\"); \\\n@@ -1557,1 +1453,0 @@\n-  JNIWrapper(\"CallNonvitual\" XSTR(Result) \"MethodA\"); \\\n@@ -1610,2 +1505,0 @@\n-  JNIWrapper(\"CallNonvirtualVoidMethod\");\n-\n@@ -1625,2 +1518,0 @@\n-  JNIWrapper(\"CallNonvirtualVoidMethodV\");\n-\n@@ -1638,1 +1529,0 @@\n-  JNIWrapper(\"CallNonvirtualVoidMethodA\");\n@@ -1657,1 +1547,0 @@\n-  JNIWrapper(\"CallStatic\" XSTR(Result) \"Method\"); \\\n@@ -1713,1 +1602,0 @@\n-  JNIWrapper(\"CallStatic\" XSTR(Result) \"MethodV\"); \\\n@@ -1770,1 +1658,0 @@\n-  JNIWrapper(\"CallStatic\" XSTR(Result) \"MethodA\"); \\\n@@ -1823,1 +1710,0 @@\n-  JNIWrapper(\"CallStaticVoidMethod\");\n@@ -1837,1 +1723,0 @@\n-  JNIWrapper(\"CallStaticVoidMethodV\");\n@@ -1848,1 +1733,0 @@\n-  JNIWrapper(\"CallStaticVoidMethodA\");\n@@ -1868,1 +1752,0 @@\n-  JNIWrapper(\"GetFieldID\");\n@@ -1903,1 +1786,0 @@\n-  JNIWrapper(\"GetObjectField\");\n@@ -1928,1 +1810,0 @@\n-  JNIWrapper(\"Get\" XSTR(Result) \"Field\"); \\\n@@ -1938,3 +1819,1 @@\n-  \/* jni_GetField_probe_nh() assumes that is not okay to create handles *\/ \\\n-  \/* and creates a ResetNoHandleMark.                                   *\/ \\\n-    o = JvmtiExport::jni_GetField_probe_nh(thread, obj, o, k, fieldID, false); \\\n+    o = JvmtiExport::jni_GetField_probe(thread, obj, o, k, fieldID, false); \\\n@@ -1999,1 +1878,0 @@\n-  JNIWrapper(\"SetObjectField\");\n@@ -2005,2 +1883,0 @@\n-  \/\/ jni_SetField_probe_nh() assumes that is not okay to create handles\n-  \/\/ and creates a ResetNoHandleMark.\n@@ -2010,1 +1886,1 @@\n-    o = JvmtiExport::jni_SetField_probe_nh(thread, obj, o, k, fieldID, false, JVM_SIGNATURE_CLASS, (jvalue *)&field_value);\n+    o = JvmtiExport::jni_SetField_probe(thread, obj, o, k, fieldID, false, JVM_SIGNATURE_CLASS, (jvalue *)&field_value);\n@@ -2021,1 +1897,0 @@\n-  JNIWrapper(\"Set\" XSTR(Result) \"Field\"); \\\n@@ -2029,2 +1904,0 @@\n-  \/* jni_SetField_probe_nh() assumes that is not okay to create handles *\/ \\\n-  \/* and creates a ResetNoHandleMark.                                   *\/ \\\n@@ -2034,1 +1907,1 @@\n-    o = JvmtiExport::jni_SetField_probe_nh(thread, obj, o, k, fieldID, false, SigType, (jvalue *)&field_value); \\\n+    o = JvmtiExport::jni_SetField_probe(thread, obj, o, k, fieldID, false, SigType, (jvalue *)&field_value); \\\n@@ -2071,1 +1944,0 @@\n-  JNIWrapper(\"ToReflectedField\");\n@@ -2107,1 +1979,0 @@\n-  JNIWrapper(\"GetStaticFieldID\");\n@@ -2142,1 +2013,0 @@\n-  JNIWrapper(\"GetStaticObjectField\");\n@@ -2167,1 +2037,0 @@\n-  JNIWrapper(\"GetStatic\" XSTR(Result) \"Field\"); \\\n@@ -2202,1 +2071,0 @@\n-  JNIWrapper(\"SetStaticObjectField\");\n@@ -2223,1 +2091,0 @@\n-  JNIWrapper(\"SetStatic\" XSTR(Result) \"Field\"); \\\n@@ -2276,1 +2143,0 @@\n-  JNIWrapper(\"NewString\");\n@@ -2287,1 +2153,0 @@\n-  JNIWrapper(\"GetStringLength\");\n@@ -2299,1 +2164,0 @@\n-  JNIWrapper(\"GetStringChars\");\n@@ -2333,1 +2197,0 @@\n-  JNIWrapper(\"ReleaseStringChars\");\n@@ -2351,1 +2214,0 @@\n-  JNIWrapper(\"NewStringUTF\");\n@@ -2363,1 +2225,0 @@\n-  JNIWrapper(\"GetStringUTFLength\");\n@@ -2373,1 +2234,0 @@\n-  JNIWrapper(\"GetStringUTFChars\");\n@@ -2395,1 +2255,0 @@\n-  JNIWrapper(\"ReleaseStringUTFChars\");\n@@ -2405,1 +2264,0 @@\n-  JNIWrapper(\"GetArrayLength\");\n@@ -2423,1 +2281,0 @@\n-  JNIWrapper(\"NewObjectArray\");\n@@ -2445,1 +2302,0 @@\n-  JNIWrapper(\"GetObjectArrayElement\");\n@@ -2465,1 +2321,0 @@\n-  JNIWrapper(\"SetObjectArrayElement\");\n@@ -2505,1 +2360,0 @@\n-  JNIWrapper(\"New\" XSTR(Result) \"Array\"); \\\n@@ -2563,1 +2417,0 @@\n-  JNIWrapper(\"Get\" XSTR(Result) \"ArrayElements\"); \\\n@@ -2626,1 +2479,0 @@\n-  JNIWrapper(\"Release\" XSTR(Result) \"ArrayElements\"); \\\n@@ -2688,1 +2540,0 @@\n-  JNIWrapper(\"Get\" XSTR(Result) \"ArrayRegion\"); \\\n@@ -2732,1 +2583,0 @@\n-  JNIWrapper(\"Set\" XSTR(Result) \"ArrayRegion\"); \\\n@@ -2774,1 +2624,0 @@\n-  JNIWrapper(\"RegisterNatives\");\n@@ -2841,1 +2690,0 @@\n-  JNIWrapper(\"UnregisterNatives\");\n@@ -2909,1 +2757,0 @@\n-  JNIWrapper(\"GetStringRegion\");\n@@ -2936,1 +2783,0 @@\n-  JNIWrapper(\"GetStringUTFRegion\");\n@@ -2979,1 +2825,0 @@\n-  JNIWrapper(\"GetPrimitiveArrayCritical\");\n@@ -2999,1 +2844,0 @@\n-  JNIWrapper(\"ReleasePrimitiveArrayCritical\");\n@@ -3007,1 +2851,0 @@\n-  JNIWrapper(\"GetStringCritical\");\n@@ -3036,1 +2879,0 @@\n-  JNIWrapper(\"ReleaseStringCritical\");\n@@ -3052,1 +2894,0 @@\n-  JNIWrapper(\"jni_NewWeakGlobalRef\");\n@@ -3065,1 +2906,0 @@\n-  JNIWrapper(\"jni_DeleteWeakGlobalRef\");\n@@ -3073,1 +2913,0 @@\n-  JNIWrapper(\"jni_ExceptionCheck\");\n@@ -3183,1 +3022,0 @@\n-  JNIWrapper(\"jni_NewDirectByteBuffer\");\n@@ -3211,1 +3049,0 @@\n-  JNIWrapper(\"jni_GetDirectBufferAddress\");\n@@ -3238,1 +3075,0 @@\n-  JNIWrapper(\"jni_GetDirectBufferCapacity\");\n@@ -3265,1 +3101,0 @@\n-  JNIWrapper(\"GetVersion\");\n@@ -3274,1 +3109,0 @@\n-  JNIWrapper(\"jni_GetJavaVM\");\n@@ -3283,1 +3117,0 @@\n-  JNIWrapper(\"GetModule\");\n@@ -3592,1 +3425,1 @@\n-  if (UseFastJNIAccessors && !VerifyJNIFields && !CountJNICalls && !CheckJNICalls) {\n+  if (UseFastJNIAccessors && !VerifyJNIFields && !CheckJNICalls) {\n@@ -3798,0 +3631,1 @@\n+#endif\n@@ -3799,0 +3633,1 @@\n+#ifdef ASSERT\n@@ -3801,1 +3636,3 @@\n-    VMError::test_error_handler();\n+    if (ErrorHandlerTest != 0) {\n+      VMError::controlled_crash(ErrorHandlerTest);\n+    }\n@@ -3858,3 +3695,0 @@\n-  \/\/ See bug 4367188, the wrapper can sometimes cause VM crashes\n-  \/\/ JNIWrapper(\"GetCreatedJavaVMs\");\n-\n@@ -3888,1 +3722,0 @@\n-  JNIWrapper(\"DestroyJavaVM\");\n@@ -4020,1 +3853,1 @@\n-              java_lang_Thread::RUNNABLE);\n+              JavaThreadStatus::RUNNABLE);\n@@ -4053,1 +3886,0 @@\n-  JNIWrapper(\"AttachCurrentThread\");\n@@ -4067,2 +3899,0 @@\n-  JNIWrapper(\"DetachCurrentThread\");\n-\n@@ -4181,1 +4011,0 @@\n-  JNIWrapper(\"AttachCurrentThreadAsDaemon\");\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":19,"deletions":190,"binary":false,"changes":209,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,1 @@\n+#include \"utilities\/formatBuffer.hpp\"\n@@ -403,6 +404,4 @@\n-    tty->print_cr(\"ReleasePrimitiveArrayCritical: release array failed bounds \"\n-        \"check, incorrect pointer returned ? array: \" PTR_FORMAT \" carray: \"\n-        PTR_FORMAT, p2i(obj), p2i(carray));\n-    guarded.print_on(tty);\n-    NativeReportJNIFatalError(thr, \"ReleasePrimitiveArrayCritical: \"\n-        \"failed bounds check\");\n+    tty->print_cr(\"%s: release array failed bounds check, incorrect pointer returned ? array: \"\n+                  PTR_FORMAT \" carray: \" PTR_FORMAT, fn_name, p2i(obj), p2i(carray));\n+    DEBUG_ONLY(guarded.print_on(tty);) \/\/ This may crash.\n+    NativeReportJNIFatalError(thr, err_msg(\"%s: failed bounds check\", fn_name));\n@@ -411,5 +410,4 @@\n-    tty->print_cr(\"ReleasePrimitiveArrayCritical: unrecognized elements. array: \"\n-        PTR_FORMAT \" carray: \" PTR_FORMAT, p2i(obj), p2i(carray));\n-    guarded.print_on(tty);\n-    NativeReportJNIFatalError(thr, \"ReleasePrimitiveArrayCritical: \"\n-        \"unrecognized elements\");\n+    tty->print_cr(\"%s: unrecognized elements. array: \" PTR_FORMAT \" carray: \" PTR_FORMAT,\n+                  fn_name, p2i(obj), p2i(carray));\n+    DEBUG_ONLY(guarded.print_on(tty);) \/\/ This may crash.\n+    NativeReportJNIFatalError(thr, err_msg(\"%s: unrecognized elements\", fn_name));\n@@ -424,1 +422,1 @@\n-    void* obj, void* carray, jint mode) {\n+                                         void* obj, void* carray, jint mode, jboolean is_critical) {\n@@ -428,1 +426,3 @@\n-  \/\/ As we never make copies, mode 0 and JNI_COMMIT are the same.\n+    memcpy(orig_result, carray, sz);\n+    GuardedMemory::free_copy(carray);\n+    break;\n@@ -432,0 +432,5 @@\n+    if (is_critical) {\n+      \/\/ For ReleasePrimitiveArrayCritical we must free the internal buffer\n+      \/\/ allocated through GuardedMemory.\n+      GuardedMemory::free_copy(carray);\n+    }\n@@ -434,0 +439,1 @@\n+    GuardedMemory::free_copy(carray);\n@@ -437,1 +443,1 @@\n-        PTR_FORMAT \" elements \" PTR_FORMAT, fn_name, mode, p2i(obj), p2i(carray));\n+                  PTR_FORMAT \" elements \" PTR_FORMAT, fn_name, mode, p2i(obj), p2i(carray));\n@@ -440,2 +446,0 @@\n-  \/\/ We always need to release the copy we made with GuardedMemory\n-  GuardedMemory::free_copy(carray);\n@@ -1719,1 +1723,1 @@\n-        thr, \"checked_jni_Release\"#Result\"ArrayElements\", array, elems, mode); \\\n+        thr, \"checked_jni_Release\"#Result\"ArrayElements\", array, elems, mode, JNI_FALSE); \\\n@@ -1888,1 +1892,2 @@\n-    void* orig_result = check_wrapped_array_release(thr, \"ReleasePrimitiveArrayCritical\", array, carray, mode);\n+    void* orig_result = check_wrapped_array_release(thr, \"ReleasePrimitiveArrayCritical\",\n+                                                    array, carray, mode, JNI_TRUE);\n","filename":"src\/hotspot\/share\/prims\/jniCheck.cpp","additions":24,"deletions":19,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,1 @@\n+#include \"oops\/klass.inline.hpp\"\n@@ -96,1 +97,0 @@\n-#include \"utilities\/histogram.hpp\"\n@@ -116,2 +116,0 @@\n-          JVMWrapper(\"JVM_GetClassDeclaredFields\");\n-\n@@ -231,41 +229,0 @@\n-\/\/ Wrapper to trace JVM functions\n-\n-#ifdef ASSERT\n-  Histogram* JVMHistogram;\n-  volatile int JVMHistogram_lock = 0;\n-\n-  class JVMHistogramElement : public HistogramElement {\n-    public:\n-     JVMHistogramElement(const char* name);\n-  };\n-\n-  JVMHistogramElement::JVMHistogramElement(const char* elementName) {\n-    _name = elementName;\n-    uintx count = 0;\n-\n-    while (Atomic::cmpxchg(&JVMHistogram_lock, 0, 1) != 0) {\n-      while (Atomic::load_acquire(&JVMHistogram_lock) != 0) {\n-        count +=1;\n-        if ( (WarnOnStalledSpinLock > 0)\n-          && (count % WarnOnStalledSpinLock == 0)) {\n-          warning(\"JVMHistogram_lock seems to be stalled\");\n-        }\n-      }\n-     }\n-\n-    if(JVMHistogram == NULL)\n-      JVMHistogram = new Histogram(\"JVM Call Counts\",100);\n-\n-    JVMHistogram->add_element(this);\n-    Atomic::dec(&JVMHistogram_lock);\n-  }\n-\n-  #define JVMCountWrapper(arg) \\\n-      static JVMHistogramElement* e = new JVMHistogramElement(arg); \\\n-      if (e != NULL) e->increment_count();  \/\/ Due to bug in VC++, we need a NULL check here eventhough it should never happen!\n-\n-  #define JVMWrapper(arg) JVMCountWrapper(arg);\n-#else\n-  #define JVMWrapper(arg)\n-#endif\n-\n@@ -285,1 +242,0 @@\n-  JVMWrapper(\"JVM_CurrentTimeMillis\");\n@@ -290,1 +246,0 @@\n-  JVMWrapper(\"JVM_NanoTime\");\n@@ -302,1 +257,0 @@\n-  JVMWrapper(\"JVM_GetNanoTimeAdjustment\");\n@@ -339,1 +293,0 @@\n-  JVMWrapper(\"JVM_ArrayCopy\");\n@@ -378,1 +331,0 @@\n-  JVMWrapper(\"JVM_GetProperties\");\n@@ -467,1 +419,0 @@\n-  JVMWrapper(\"JVM_GetTemporaryDirectory\");\n@@ -480,1 +431,0 @@\n-  JVMWrapper(\"JVM_BeforeHalt\");\n@@ -500,1 +450,0 @@\n-  JVMWrapper(\"JVM_GC\");\n@@ -508,1 +457,0 @@\n-  JVMWrapper(\"JVM_MaxObjectInspectionAge\");\n@@ -520,1 +468,0 @@\n-  JVMWrapper(\"JVM_TotalMemory\");\n@@ -527,1 +474,0 @@\n-  JVMWrapper(\"JVM_FreeMemory\");\n@@ -534,1 +480,0 @@\n-  JVMWrapper(\"JVM_MaxMemory\");\n@@ -541,1 +486,0 @@\n-  JVMWrapper(\"JVM_ActiveProcessorCount\");\n@@ -546,1 +490,0 @@\n-  JVMWrapper(\"JVM_IsUseContainerSupport\");\n@@ -558,1 +501,0 @@\n-  JVMWrapper(\"JVM_FillInStackTrace\");\n@@ -593,1 +535,0 @@\n-  JVMWrapper(\"JVM_InitStackTraceElementArray\");\n@@ -603,1 +544,0 @@\n-  JVMWrapper(\"JVM_InitStackTraceElement\");\n@@ -616,1 +556,0 @@\n-  JVMWrapper(\"JVM_CallStackWalk\");\n@@ -643,2 +582,0 @@\n-  JVMWrapper(\"JVM_MoreStackWalk\");\n-\n@@ -665,1 +602,0 @@\n-  JVMWrapper(\"JVM_IHashCode\");\n@@ -672,1 +608,0 @@\n-  JVMWrapper(\"JVM_MonitorWait\");\n@@ -689,1 +624,0 @@\n-  JVMWrapper(\"JVM_MonitorNotify\");\n@@ -696,1 +630,0 @@\n-  JVMWrapper(\"JVM_MonitorNotifyAll\");\n@@ -703,1 +636,0 @@\n-  JVMWrapper(\"JVM_Clone\");\n@@ -757,1 +689,0 @@\n-  JVMWrapper(\"JVM_NativePath\");\n@@ -766,2 +697,0 @@\n-  JVMWrapper(\"JVM_GetCallerClass\");\n-\n@@ -807,1 +736,0 @@\n-  JVMWrapper(\"JVM_FindPrimitiveClass\");\n@@ -826,2 +754,0 @@\n-  JVMWrapper(\"JVM_FindClassFromBootLoader\");\n-\n@@ -852,2 +778,0 @@\n-  JVMWrapper(\"JVM_FindClassFromCaller throws ClassNotFoundException\");\n-\n@@ -884,1 +808,0 @@\n-  JVMWrapper(\"JVM_FindClassFromClass\");\n@@ -1113,2 +1036,0 @@\n-  JVMWrapper(\"JVM_DefineClass\");\n-\n@@ -1131,1 +1052,0 @@\n-  JVMWrapper(\"JVM_LookupDefineClass\");\n@@ -1143,1 +1063,0 @@\n-  JVMWrapper(\"JVM_DefineClassWithSource\");\n@@ -1149,1 +1068,0 @@\n-  JVMWrapper(\"JVM_FindLoadedClass\");\n@@ -1204,1 +1122,0 @@\n-  JVMWrapper(\"JVM_DefineModule\");\n@@ -1209,1 +1126,0 @@\n-  JVMWrapper(\"JVM_SetBootLoaderUnnamedModule\");\n@@ -1214,1 +1130,0 @@\n-  JVMWrapper(\"JVM_AddModuleExports\");\n@@ -1219,1 +1134,0 @@\n-  JVMWrapper(\"JVM_AddModuleExportsToAllUnnamed\");\n@@ -1224,1 +1138,0 @@\n-  JVMWrapper(\"JVM_AddModuleExportsToAll\");\n@@ -1229,1 +1142,0 @@\n-  JVMWrapper(\"JVM_AddReadsModule\");\n@@ -1234,1 +1146,0 @@\n-  JVMWrapper(\"JVM_DefineArchivedModules\");\n@@ -1242,1 +1153,0 @@\n-  JVMWrapper(\"JVM_InitClassName\");\n@@ -1253,1 +1163,0 @@\n-  JVMWrapper(\"JVM_GetClassInterfaces\");\n@@ -1294,1 +1203,0 @@\n-  JVMWrapper(\"JVM_IsInterface\");\n@@ -1309,1 +1217,0 @@\n-  JVMWrapper(\"JVM_IsHiddenClass\");\n@@ -1319,1 +1226,0 @@\n-  JVMWrapper(\"JVM_GetClassSigners\");\n@@ -1346,1 +1252,0 @@\n-  JVMWrapper(\"JVM_SetClassSigners\");\n@@ -1361,1 +1266,0 @@\n-  JVMWrapper(\"JVM_GetProtectionDomain\");\n@@ -1379,1 +1283,0 @@\n-  JVMWrapper(\"JVM_GetInheritedAccessControlContext\");\n@@ -1385,1 +1288,0 @@\n-  JVMWrapper(\"JVM_GetStackAccessControlContext\");\n@@ -1462,1 +1364,0 @@\n-  JVMWrapper(\"JVM_IsArrayClass\");\n@@ -1469,1 +1370,0 @@\n-  JVMWrapper(\"JVM_IsPrimitiveClass\");\n@@ -1476,1 +1376,0 @@\n-  JVMWrapper(\"JVM_GetClassModifiers\");\n@@ -1605,1 +1504,0 @@\n-  JVMWrapper(\"JVM_GetClassSignature\");\n@@ -1625,1 +1523,0 @@\n-  JVMWrapper(\"JVM_GetClassAnnotations\");\n@@ -1695,1 +1592,0 @@\n-  JVMWrapper(\"JVM_GetClassTypeAnnotations\");\n@@ -1713,2 +1609,0 @@\n-  JVMWrapper(\"JVM_GetMethodTypeAnnotations\");\n-\n@@ -1732,2 +1626,0 @@\n-  JVMWrapper(\"JVM_GetFieldTypeAnnotations\");\n-\n@@ -1751,1 +1643,0 @@\n-  JVMWrapper(\"JVM_GetMethodParameters\");\n@@ -1805,1 +1696,0 @@\n-  JVMWrapper(\"JVM_GetClassDeclaredFields\");\n@@ -1853,0 +1743,2 @@\n+\/\/ A class is a record if and only if it is final and a direct subclass of\n+\/\/ java.lang.Record and has a Record attribute; otherwise, it is not a record.\n@@ -1855,1 +1747,0 @@\n-  JVMWrapper(\"JVM_IsRecord\");\n@@ -1866,0 +1757,5 @@\n+\/\/ Returns an array containing the components of the Record attribute,\n+\/\/ or NULL if the attribute is not present.\n+\/\/\n+\/\/ Note that this function returns the components of the Record attribute\n+\/\/ even if the class is not a record.\n@@ -1868,1 +1764,0 @@\n-  JVMWrapper(\"JVM_GetRecordComponents\");\n@@ -1873,19 +1768,15 @@\n-  if (ik->is_record()) {\n-    Array<RecordComponent*>* components = ik->record_components();\n-    assert(components != NULL, \"components should not be NULL\");\n-    {\n-      JvmtiVMObjectAllocEventCollector oam;\n-      constantPoolHandle cp(THREAD, ik->constants());\n-      int length = components->length();\n-      assert(length >= 0, \"unexpected record_components length\");\n-      objArrayOop record_components =\n-        oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), length, CHECK_NULL);\n-      objArrayHandle components_h (THREAD, record_components);\n-\n-      for (int x = 0; x < length; x++) {\n-        RecordComponent* component = components->at(x);\n-        assert(component != NULL, \"unexpected NULL record component\");\n-        oop component_oop = java_lang_reflect_RecordComponent::create(ik, component, CHECK_NULL);\n-        components_h->obj_at_put(x, component_oop);\n-      }\n-      return (jobjectArray)JNIHandles::make_local(THREAD, components_h());\n+  Array<RecordComponent*>* components = ik->record_components();\n+  if (components != NULL) {\n+    JvmtiVMObjectAllocEventCollector oam;\n+    constantPoolHandle cp(THREAD, ik->constants());\n+    int length = components->length();\n+    assert(length >= 0, \"unexpected record_components length\");\n+    objArrayOop record_components =\n+      oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), length, CHECK_NULL);\n+    objArrayHandle components_h (THREAD, record_components);\n+\n+    for (int x = 0; x < length; x++) {\n+      RecordComponent* component = components->at(x);\n+      assert(component != NULL, \"unexpected NULL record component\");\n+      oop component_oop = java_lang_reflect_RecordComponent::create(ik, component, CHECK_NULL);\n+      components_h->obj_at_put(x, component_oop);\n@@ -1893,0 +1784,1 @@\n+    return (jobjectArray)JNIHandles::make_local(THREAD, components_h());\n@@ -1895,3 +1787,1 @@\n-  \/\/ Return empty array if ofClass is not a record.\n-  objArrayOop result = oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), 0, CHECK_NULL);\n-  return (jobjectArray)JNIHandles::make_local(THREAD, result);\n+  return NULL;\n@@ -1981,1 +1871,0 @@\n-  JVMWrapper(\"JVM_GetClassDeclaredMethods\");\n@@ -1990,1 +1879,0 @@\n-  JVMWrapper(\"JVM_GetClassDeclaredConstructors\");\n@@ -1999,1 +1887,0 @@\n-  JVMWrapper(\"JVM_GetClassAccessFlags\");\n@@ -2013,1 +1900,0 @@\n-  JVMWrapper(\"JVM_AreNestMates\");\n@@ -2027,1 +1913,0 @@\n-  JVMWrapper(\"JVM_GetNestHost\");\n@@ -2040,1 +1925,0 @@\n-  JVMWrapper(\"JVM_GetNestMembers\");\n@@ -2120,1 +2004,0 @@\n-  JVMWrapper(\"JVM_GetPermittedSubclasses\");\n@@ -2126,1 +2009,4 @@\n-  {\n+  ResourceMark rm(THREAD);\n+  log_trace(class, sealed)(\"Calling GetPermittedSubclasses for %s type %s\",\n+                           ik->is_sealed() ? \"sealed\" : \"non-sealed\", ik->external_name());\n+  if (ik->is_sealed()) {\n@@ -2129,2 +2015,5 @@\n-    int length = subclasses == NULL ? 0 : subclasses->length();\n-    objArrayOop r = oopFactory::new_objArray(SystemDictionary::String_klass(),\n+    int length = subclasses->length();\n+\n+    log_trace(class, sealed)(\" - sealed class has %d permitted subclasses\", length);\n+\n+    objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(),\n@@ -2133,0 +2022,1 @@\n+    int count = 0;\n@@ -2135,5 +2025,30 @@\n-      \/\/ This returns <package-name>\/<class-name>.\n-      Symbol* klass_name = ik->constants()->klass_name_at(cp_index);\n-      assert(klass_name != NULL, \"Unexpected null klass_name\");\n-      Handle perm_subtype_h = java_lang_String::create_from_symbol(klass_name, CHECK_NULL);\n-      result->obj_at_put(i, perm_subtype_h());\n+      Klass* k = ik->constants()->klass_at(cp_index, THREAD);\n+      if (HAS_PENDING_EXCEPTION) {\n+        if (PENDING_EXCEPTION->is_a(SystemDictionary::VirtualMachineError_klass())) {\n+          return NULL; \/\/ propagate VMEs\n+        }\n+        if (log_is_enabled(Trace, class, sealed)) {\n+          stringStream ss;\n+          char* permitted_subclass = ik->constants()->klass_name_at(cp_index)->as_C_string();\n+          ss.print(\" - resolution of permitted subclass %s failed: \", permitted_subclass);\n+          java_lang_Throwable::print(PENDING_EXCEPTION, &ss);\n+          log_trace(class, sealed)(\"%s\", ss.as_string());\n+        }\n+\n+        CLEAR_PENDING_EXCEPTION;\n+        continue;\n+      }\n+      if (k->is_instance_klass()) {\n+        result->obj_at_put(count++, k->java_mirror());\n+        log_trace(class, sealed)(\" - [%d] = %s\", count, k->external_name());\n+      }\n+    }\n+    if (count < length) {\n+      \/\/ we had invalid entries so we need to compact the array\n+      objArrayOop r2 = oopFactory::new_objArray(SystemDictionary::Class_klass(),\n+                                                count, CHECK_NULL);\n+      objArrayHandle result2(THREAD, r2);\n+      for (int i = 0; i < count; i++) {\n+        result2->obj_at_put(i, result->obj_at(i));\n+      }\n+      return (jobjectArray)JNIHandles::make_local(THREAD, result2());\n@@ -2142,0 +2057,2 @@\n+  } else {\n+    return NULL;\n@@ -2150,1 +2067,0 @@\n-  JVMWrapper(\"JVM_GetClassConstantPool\");\n@@ -2170,1 +2086,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetSize\");\n@@ -2179,1 +2094,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetClassAt\");\n@@ -2193,1 +2107,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetClassAtIfLoaded\");\n@@ -2237,1 +2150,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetMethodAt\");\n@@ -2248,1 +2160,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetMethodAtIfLoaded\");\n@@ -2284,1 +2195,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetFieldAt\");\n@@ -2295,1 +2205,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetFieldAtIfLoaded\");\n@@ -2306,1 +2215,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetMemberRefInfoAt\");\n@@ -2332,1 +2240,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetClassRefIndexAt\");\n@@ -2346,1 +2253,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetNameAndTypeRefIndexAt\");\n@@ -2360,1 +2266,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetNameAndTypeRefInfoAt\");\n@@ -2382,1 +2287,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetIntAt\");\n@@ -2395,1 +2299,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetLongAt\");\n@@ -2408,1 +2311,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetFloatAt\");\n@@ -2421,1 +2323,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetDoubleAt\");\n@@ -2434,1 +2335,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetStringAt\");\n@@ -2448,1 +2348,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetUTF8At\");\n@@ -2464,1 +2363,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetTagAt\");\n@@ -2490,1 +2388,0 @@\n-  JVMWrapper(\"JVM_DesiredAssertionStatus\");\n@@ -2512,1 +2409,0 @@\n-  JVMWrapper(\"JVM_AssertionStatusDirectives\");\n@@ -2531,1 +2427,0 @@\n-  JVMWrapper(\"JVM_GetClassNameUTF\");\n@@ -2539,1 +2434,0 @@\n-  JVMWrapper(\"JVM_GetClassCPTypes\");\n@@ -2555,1 +2449,0 @@\n-  JVMWrapper(\"JVM_GetClassCPEntriesCount\");\n@@ -2563,1 +2456,0 @@\n-  JVMWrapper(\"JVM_GetClassFieldsCount\");\n@@ -2571,1 +2463,0 @@\n-  JVMWrapper(\"JVM_GetClassMethodsCount\");\n@@ -2584,1 +2475,0 @@\n-  JVMWrapper(\"JVM_GetMethodIxExceptionIndexes\");\n@@ -2599,1 +2489,0 @@\n-  JVMWrapper(\"JVM_GetMethodIxExceptionsCount\");\n@@ -2608,1 +2497,0 @@\n-  JVMWrapper(\"JVM_GetMethodIxByteCode\");\n@@ -2617,1 +2505,0 @@\n-  JVMWrapper(\"JVM_GetMethodIxByteCodeLength\");\n@@ -2626,1 +2513,0 @@\n-  JVMWrapper(\"JVM_GetMethodIxExceptionTableEntry\");\n@@ -2639,1 +2525,0 @@\n-  JVMWrapper(\"JVM_GetMethodIxExceptionTableLength\");\n@@ -2648,1 +2533,0 @@\n-  JVMWrapper(\"JVM_GetMethodIxModifiers\");\n@@ -2657,1 +2541,0 @@\n-  JVMWrapper(\"JVM_GetFieldIxModifiers\");\n@@ -2665,1 +2548,0 @@\n-  JVMWrapper(\"JVM_GetMethodIxLocalsCount\");\n@@ -2674,1 +2556,0 @@\n-  JVMWrapper(\"JVM_GetMethodIxArgsSize\");\n@@ -2683,1 +2564,0 @@\n-  JVMWrapper(\"JVM_GetMethodIxMaxStack\");\n@@ -2692,1 +2572,0 @@\n-  JVMWrapper(\"JVM_IsConstructorIx\");\n@@ -2702,1 +2581,0 @@\n-  JVMWrapper(\"JVM_IsVMGeneratedMethodIx\");\n@@ -2711,1 +2589,0 @@\n-  JVMWrapper(\"JVM_GetMethodIxIxUTF\");\n@@ -2720,1 +2597,0 @@\n-  JVMWrapper(\"JVM_GetMethodIxSignatureUTF\");\n@@ -2736,1 +2612,0 @@\n-  JVMWrapper(\"JVM_GetCPFieldNameUTF\");\n@@ -2752,1 +2627,0 @@\n-  JVMWrapper(\"JVM_GetCPMethodNameUTF\");\n@@ -2769,1 +2643,0 @@\n-  JVMWrapper(\"JVM_GetCPMethodSignatureUTF\");\n@@ -2786,1 +2659,0 @@\n-  JVMWrapper(\"JVM_GetCPFieldSignatureUTF\");\n@@ -2802,1 +2674,0 @@\n-  JVMWrapper(\"JVM_GetCPClassNameUTF\");\n@@ -2812,1 +2683,0 @@\n-  JVMWrapper(\"JVM_GetCPFieldClassNameUTF\");\n@@ -2831,1 +2701,0 @@\n-  JVMWrapper(\"JVM_GetCPMethodClassNameUTF\");\n@@ -2851,1 +2720,0 @@\n-  JVMWrapper(\"JVM_GetCPFieldModifiers\");\n@@ -2879,1 +2747,0 @@\n-  JVMWrapper(\"JVM_GetCPMethodModifiers\");\n@@ -2916,1 +2783,0 @@\n-  JVMWrapper(\"JVM_IsSameClassPackage\");\n@@ -3016,1 +2882,0 @@\n-  JVMWrapper(\"JVM_StartThread\");\n@@ -3104,2 +2969,0 @@\n-  JVMWrapper(\"JVM_StopThread\");\n-\n@@ -3143,2 +3006,0 @@\n-  JVMWrapper(\"JVM_IsThreadAlive\");\n-\n@@ -3151,2 +3012,0 @@\n-  JVMWrapper(\"JVM_SuspendThread\");\n-\n@@ -3188,2 +3047,0 @@\n-  JVMWrapper(\"JVM_ResumeThread\");\n-\n@@ -3217,2 +3074,0 @@\n-  JVMWrapper(\"JVM_SetThreadPriority\");\n-\n@@ -3236,1 +3091,0 @@\n-  JVMWrapper(\"JVM_Yield\");\n@@ -3250,2 +3104,0 @@\n-  JVMWrapper(\"JVM_Sleep\");\n-\n@@ -3295,1 +3147,0 @@\n-  JVMWrapper(\"JVM_CurrentThread\");\n@@ -3302,2 +3153,0 @@\n-  JVMWrapper(\"JVM_Interrupt\");\n-\n@@ -3317,1 +3166,0 @@\n-  JVMWrapper(\"JVM_HoldsLock\");\n@@ -3327,1 +3175,0 @@\n-  JVMWrapper(\"JVM_DumpAllStacks\");\n@@ -3336,2 +3183,0 @@\n-  JVMWrapper(\"JVM_SetNativeThreadName\");\n-\n@@ -3355,1 +3200,0 @@\n-  JVMWrapper(\"JVM_GetClassContext\");\n@@ -3397,1 +3241,0 @@\n-  JVMWrapper(\"JVM_GetSystemPackage\");\n@@ -3407,1 +3250,0 @@\n-  JVMWrapper(\"JVM_GetSystemPackages\");\n@@ -3418,2 +3260,0 @@\n-  JVMWrapper(\"JVM_GetAndClearReferencePendingList\");\n-\n@@ -3429,1 +3269,0 @@\n-  JVMWrapper(\"JVM_HasReferencePendingList\");\n@@ -3435,1 +3274,0 @@\n-  JVMWrapper(\"JVM_WaitForReferencePendingList\");\n@@ -3443,1 +3281,0 @@\n-  JVMWrapper(\"JVM_ReferenceRefersTo\");\n@@ -3449,0 +3286,18 @@\n+JVM_ENTRY(void, JVM_ReferenceClear(JNIEnv* env, jobject ref))\n+  oop ref_oop = JNIHandles::resolve_non_null(ref);\n+  \/\/ FinalReference has it's own implementation of clear().\n+  assert(!java_lang_ref_Reference::is_final(ref_oop), \"precondition\");\n+  if (java_lang_ref_Reference::unknown_referent_no_keepalive(ref_oop) == NULL) {\n+    \/\/ If the referent has already been cleared then done.\n+    \/\/ However, if the referent is dead but has not yet been cleared by\n+    \/\/ concurrent reference processing, it should NOT be cleared here.\n+    \/\/ Instead, clearing should be left to the GC.  Clearing it here could\n+    \/\/ detectably lose an expected notification, which is impossible with\n+    \/\/ STW reference processing.  The clearing in enqueue() doesn't have\n+    \/\/ this problem, since the enqueue covers the notification, but it's not\n+    \/\/ worth the effort to handle that case specially.\n+    return;\n+  }\n+  java_lang_ref_Reference::clear_referent(ref_oop);\n+JVM_END\n+\n@@ -3454,1 +3309,0 @@\n-  JVMWrapper(\"JVM_PhantomReferenceRefersTo\");\n@@ -3497,1 +3351,0 @@\n-  JVMWrapper(\"JVM_GetArrayLength\");\n@@ -3504,1 +3357,0 @@\n-  JVMWrapper(\"JVM_Array_Get\");\n@@ -3515,1 +3367,0 @@\n-  JVMWrapper(\"JVM_GetPrimitiveArrayElement\");\n@@ -3530,1 +3381,0 @@\n-  JVMWrapper(\"JVM_SetArrayElement\");\n@@ -3547,1 +3397,0 @@\n-  JVMWrapper(\"JVM_SetPrimitiveArrayElement\");\n@@ -3556,1 +3405,0 @@\n-  JVMWrapper(\"JVM_NewArray\");\n@@ -3565,1 +3413,0 @@\n-  JVMWrapper(\"JVM_NewMultiArray\");\n@@ -3579,1 +3426,0 @@\n-  JVMWrapper(\"JVM_LoadLibrary\");\n@@ -3607,1 +3453,0 @@\n-  JVMWrapper(\"JVM_UnloadLibrary\");\n@@ -3614,1 +3459,0 @@\n-  JVMWrapper(\"JVM_FindLibraryEntry\");\n@@ -3626,1 +3470,0 @@\n-  JVMWrapper(\"JVM_IsSupportedJNIVersion\");\n@@ -3634,1 +3477,0 @@\n-  JVMWrapper(\"JVM_InternString\");\n@@ -3654,1 +3496,0 @@\n-  JVMWrapper(\"JVM_RawMonitorCreate\");\n@@ -3661,1 +3502,0 @@\n-  JVMWrapper(\"JVM_RawMonitorDestroy\");\n@@ -3668,1 +3508,0 @@\n-  JVMWrapper(\"JVM_RawMonitorEnter\");\n@@ -3676,1 +3515,0 @@\n-  JVMWrapper(\"JVM_RawMonitorExit\");\n@@ -3705,1 +3543,0 @@\n-  JVMWrapper(\"JVM_InvokeMethod\");\n@@ -3730,1 +3567,0 @@\n-  JVMWrapper(\"JVM_NewInstanceFromConstructor\");\n@@ -3744,1 +3580,0 @@\n-  JVMWrapper(\"JVM_SupportsCX8\");\n@@ -3749,1 +3584,0 @@\n-  JVMWrapper(\"JVM_InitializeFromArchive\");\n@@ -3763,1 +3597,0 @@\n-  JVMWrapper(\"JVM_RegisterLambdaProxyClassForArchiving\");\n@@ -3810,3 +3643,1 @@\n-                                                        jobject instantiatedMethodType,\n-                                                        jboolean initialize))\n-  JVMWrapper(\"JVM_LookupLambdaProxyClassFromArchive\");\n+                                                        jobject instantiatedMethodType))\n@@ -3845,1 +3676,1 @@\n-    InstanceKlass* loaded_lambda = SystemDictionaryShared::prepare_shared_lambda_proxy_class(lambda_ik, caller_ik, initialize, THREAD);\n+    InstanceKlass* loaded_lambda = SystemDictionaryShared::prepare_shared_lambda_proxy_class(lambda_ik, caller_ik, THREAD);\n@@ -3855,1 +3686,0 @@\n-    JVMWrapper(\"JVM_IsCDSDumpingEnabled\");\n@@ -3860,1 +3690,0 @@\n-    JVMWrapper(\"JVM_IsSharingEnable\");\n@@ -3865,1 +3694,0 @@\n-  JVMWrapper(\"JVM_GetRandomSeedForDumping\");\n@@ -3888,1 +3716,0 @@\n-  JVMWrapper(\"JVM_IsDumpingClassList\");\n@@ -3897,1 +3724,0 @@\n-  JVMWrapper(\"JVM_LogLambdaFormInvoker\");\n@@ -3935,1 +3761,0 @@\n-  JVMWrapper(\"JVM_DumpThreads\");\n@@ -3982,1 +3807,0 @@\n-  JVMWrapper(\"JVM_InitAgentProperties\");\n@@ -3995,1 +3819,0 @@\n-  JVMWrapper(\"JVM_GetEnclosingMethodInfo\");\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":88,"deletions":265,"binary":false,"changes":353,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -447,1 +447,1 @@\n-      <xsl:text>CautiouslyPreserveExceptionMark __em(this_thread);<\/xsl:text>\n+      <xsl:text>PreserveExceptionMark __em(this_thread);<\/xsl:text>\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnter.xsl","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+#include \"oops\/klass.inline.hpp\"\n@@ -662,7 +663,0 @@\n-    \/\/ lock the loader\n-    Thread* thread = Thread::current();\n-    HandleMark hm(thread);\n-    Handle loader_lock = Handle(thread, SystemDictionary::system_loader_lock());\n-\n-    ObjectLocker ol(loader_lock, thread);\n-\n@@ -1206,4 +1200,0 @@\n-  \/\/ growable array of jvmti monitors info on the C-heap\n-  GrowableArray<jvmtiMonitorStackDepthInfo*> *owned_monitors_list =\n-      new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<jvmtiMonitorStackDepthInfo*>(1, mtServiceability);\n-\n@@ -1215,0 +1205,4 @@\n+  \/\/ growable array of jvmti monitors info on the C-heap\n+  GrowableArray<jvmtiMonitorStackDepthInfo*> *owned_monitors_list =\n+      new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<jvmtiMonitorStackDepthInfo*>(1, mtServiceability);\n+\n@@ -1256,4 +1250,0 @@\n-  \/\/ growable array of jvmti monitors info on the C-heap\n-  GrowableArray<jvmtiMonitorStackDepthInfo*> *owned_monitors_list =\n-         new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<jvmtiMonitorStackDepthInfo*>(1, mtServiceability);\n-\n@@ -1265,0 +1255,4 @@\n+  \/\/ growable array of jvmti monitors info on the C-heap\n+  GrowableArray<jvmtiMonitorStackDepthInfo*> *owned_monitors_list =\n+         new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<jvmtiMonitorStackDepthInfo*>(1, mtServiceability);\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":10,"deletions":16,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -40,0 +41,1 @@\n+#include \"oops\/klass.inline.hpp\"\n@@ -68,0 +70,1 @@\n+#include \"runtime\/vm_version.hpp\"\n@@ -687,0 +690,1 @@\n+static OopStorage* _weak_tag_storage = NULL;\n@@ -693,0 +697,5 @@\n+OopStorage* JvmtiExport::weak_tag_storage() {\n+  assert(_weak_tag_storage != NULL, \"not yet initialized\");\n+  return _weak_tag_storage;\n+}\n+\n@@ -697,0 +706,2 @@\n+  _weak_tag_storage  = OopStorageSet::create_weak(\"JVMTI Tag Weak OopStorage\");\n+  _weak_tag_storage->register_num_dead_callback(&JvmtiTagMap::gc_notification);\n@@ -1486,1 +1497,0 @@\n-  assert(SafepointSynchronize::is_at_safepoint(), \"must be executed at safepoint\");\n@@ -1871,18 +1881,1 @@\n-    \/\/ At least one field access watch is set so we have more work\n-    \/\/ to do. This wrapper is used by entry points that allow us\n-    \/\/ to create handles in post_field_access_by_jni().\n-    post_field_access_by_jni(thread, obj, klass, fieldID, is_static);\n-    \/\/ event posting can block so refetch oop if we were passed a jobj\n-    if (jobj != NULL) return JNIHandles::resolve_non_null(jobj);\n-  }\n-  return obj;\n-}\n-\n-oop JvmtiExport::jni_GetField_probe_nh(JavaThread *thread, jobject jobj, oop obj,\n-                                       Klass* klass, jfieldID fieldID, bool is_static) {\n-  if (*((int *)get_field_access_count_addr()) > 0 && thread->has_last_Java_frame()) {\n-    \/\/ At least one field access watch is set so we have more work\n-    \/\/ to do. This wrapper is used by \"quick\" entry points that don't\n-    \/\/ allow us to create handles in post_field_access_by_jni(). We\n-    \/\/ override that with a ResetNoHandleMark.\n-    ResetNoHandleMark rnhm;\n+    \/\/ At least one field access watch is set so we have more work to do.\n@@ -1965,19 +1958,1 @@\n-    \/\/ At least one field modification watch is set so we have more work\n-    \/\/ to do. This wrapper is used by entry points that allow us\n-    \/\/ to create handles in post_field_modification_by_jni().\n-    post_field_modification_by_jni(thread, obj, klass, fieldID, is_static, sig_type, value);\n-    \/\/ event posting can block so refetch oop if we were passed a jobj\n-    if (jobj != NULL) return JNIHandles::resolve_non_null(jobj);\n-  }\n-  return obj;\n-}\n-\n-oop JvmtiExport::jni_SetField_probe_nh(JavaThread *thread, jobject jobj, oop obj,\n-                                       Klass* klass, jfieldID fieldID, bool is_static,\n-                                       char sig_type, jvalue *value) {\n-  if (*((int *)get_field_modification_count_addr()) > 0 && thread->has_last_Java_frame()) {\n-    \/\/ At least one field modification watch is set so we have more work\n-    \/\/ to do. This wrapper is used by \"quick\" entry points that don't\n-    \/\/ allow us to create handles in post_field_modification_by_jni(). We\n-    \/\/ override that with a ResetNoHandleMark.\n-    ResetNoHandleMark rnhm;\n+    \/\/ At least one field modification watch is set so we have more work to do.\n@@ -2643,4 +2618,0 @@\n-void JvmtiExport::weak_oops_do(BoolObjectClosure* is_alive, OopClosure* f) {\n-  JvmtiTagMap::weak_oops_do(is_alive, f);\n-}\n-\n@@ -2737,0 +2708,3 @@\n+        if (!agent_lib->is_static_lib()) {\n+          os::dll_unload(library);\n+        }\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":17,"deletions":43,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"classfile\/javaClasses.hpp\"\n@@ -38,0 +39,1 @@\n+#include \"oops\/oopHandle.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"oops\/klass.inline.hpp\"\n@@ -422,1 +423,1 @@\n-  assert(is_signature_polymorphic_intrinsic(iid), \"%d %s\", iid, vmIntrinsics::name_at(iid));\n+  assert(is_signature_polymorphic_intrinsic(iid), \"%d %s\", vmIntrinsics::as_int(iid), vmIntrinsics::name_at(iid));\n@@ -429,0 +430,1 @@\n+  case vmIntrinsics::_linkToNative:     return vmSymbols::linkToNative_name();\n@@ -430,1 +432,1 @@\n-    fatal(\"unexpected intrinsic id: %d %s\", iid, vmIntrinsics::name_at(iid));\n+    fatal(\"unexpected intrinsic id: %d %s\", vmIntrinsics::as_int(iid), vmIntrinsics::name_at(iid));\n@@ -451,0 +453,1 @@\n+  case vmIntrinsics::_linkToNative:     return 0;\n@@ -456,1 +459,1 @@\n-    fatal(\"unexpected intrinsic id: %d %s\", iid, vmIntrinsics::name_at(iid));\n+    fatal(\"unexpected intrinsic id: %d %s\", vmIntrinsics::as_int(iid), vmIntrinsics::name_at(iid));\n@@ -474,0 +477,1 @@\n+  case VM_SYMBOL_ENUM_NAME(linkToNative_name):     return vmIntrinsics::_linkToNative;\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"oops\/klass.inline.hpp\"\n@@ -39,0 +40,1 @@\n+#include \"prims\/jvmtiExport.hpp\"\n@@ -41,0 +43,1 @@\n+#include \"prims\/scopedMemoryAccess.hpp\"\n@@ -217,0 +220,5 @@\n+  void JNICALL JVM_RegisterReferencesMethods(JNIEnv *env, jclass unsafecls);\n+  void JNICALL JVM_RegisterUpcallHandlerMethods(JNIEnv *env, jclass unsafecls);\n+  void JNICALL JVM_RegisterProgrammableUpcallHandlerMethods(JNIEnv *env, jclass unsafecls);\n+  void JNICALL JVM_RegisterProgrammableInvokerMethods(JNIEnv *env, jclass unsafecls);\n+  void JNICALL JVM_RegisterNativeEntryPointMethods(JNIEnv *env, jclass unsafecls);\n@@ -232,0 +240,4 @@\n+  { CC\"Java_jdk_internal_foreign_abi_UpcallStubs_registerNatives\",      NULL, FN_PTR(JVM_RegisterUpcallHandlerMethods) },\n+  { CC\"Java_jdk_internal_foreign_abi_ProgrammableUpcallHandler_registerNatives\",      NULL, FN_PTR(JVM_RegisterProgrammableUpcallHandlerMethods) },\n+  { CC\"Java_jdk_internal_foreign_abi_ProgrammableInvoker_registerNatives\",      NULL, FN_PTR(JVM_RegisterProgrammableInvokerMethods) },\n+  { CC\"Java_jdk_internal_invoke_NativeEntryPoint_registerNatives\",      NULL, FN_PTR(JVM_RegisterNativeEntryPointMethods) },\n@@ -242,0 +254,1 @@\n+  { CC\"Java_jdk_internal_misc_ScopedMemoryAccess_registerNatives\", NULL, FN_PTR(JVM_RegisterJDKInternalMiscScopedMemoryAccessMethods) },\n","filename":"src\/hotspot\/share\/prims\/nativeLookup.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,187 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"jni.h\"\n+#include \"jvm.h\"\n+#include \"classfile\/vmSymbols.hpp\"\n+#include \"oops\/access.inline.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"runtime\/jniHandles.inline.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/sharedRuntime.hpp\"\n+#include \"runtime\/vframe.inline.hpp\"\n+#include \"runtime\/deoptimization.hpp\"\n+#include \"prims\/stackwalk.hpp\"\n+\n+\n+class CloseScopedMemoryFindOopClosure : public OopClosure {\n+  oop _deopt;\n+  bool _found;\n+\n+public:\n+  CloseScopedMemoryFindOopClosure(jobject deopt) :\n+      _deopt(JNIHandles::resolve(deopt)),\n+      _found(false) {}\n+\n+  template <typename T>\n+  void do_oop_work(T* p) {\n+    if (_found) {\n+      return;\n+    }\n+    if (RawAccess<>::oop_load(p) == _deopt) {\n+      _found = true;\n+    }\n+  }\n+\n+  virtual void do_oop(oop* p) {\n+    do_oop_work(p);\n+  }\n+\n+  virtual void do_oop(narrowOop* p) {\n+    do_oop_work(p);\n+  }\n+\n+  bool found() {\n+    return _found;\n+  }\n+};\n+\n+class CloseScopedMemoryClosure : public HandshakeClosure {\n+  jobject _deopt;\n+  jobject _exception;\n+\n+public:\n+  jboolean _found;\n+\n+  CloseScopedMemoryClosure(jobject deopt, jobject exception)\n+    : HandshakeClosure(\"CloseScopedMemory\")\n+    , _deopt(deopt)\n+    , _exception(exception)\n+    , _found(false) {}\n+\n+  void do_thread(Thread* thread) {\n+\n+    JavaThread* jt = (JavaThread*)thread;\n+\n+    if (!jt->has_last_Java_frame()) {\n+      return;\n+    }\n+\n+    frame last_frame = jt->last_frame();\n+    RegisterMap register_map(jt, true);\n+\n+    if (last_frame.is_safepoint_blob_frame()) {\n+      last_frame = last_frame.sender(&register_map);\n+    }\n+\n+    ResourceMark rm;\n+    if (_deopt != NULL && last_frame.is_compiled_frame() && last_frame.can_be_deoptimized()) {\n+      CloseScopedMemoryFindOopClosure cl(_deopt);\n+      CompiledMethod* cm = last_frame.cb()->as_compiled_method();\n+\n+      \/* FIXME: this doesn't work if reachability fences are violated by C2\n+      last_frame.oops_do(&cl, NULL, &register_map);\n+      if (cl.found()) {\n+           \/\/Found the deopt oop in a compiled method; deoptimize.\n+           Deoptimization::deoptimize(jt, last_frame);\n+      }\n+      so... we unconditionally deoptimize, for now: *\/\n+      Deoptimization::deoptimize(jt, last_frame);\n+    }\n+\n+    const int max_critical_stack_depth = 10;\n+    int depth = 0;\n+    for (vframeStream stream(jt); !stream.at_end(); stream.next()) {\n+      Method* m = stream.method();\n+      if (m->is_scoped()) {\n+        StackValueCollection* locals = stream.asJavaVFrame()->locals();\n+        for (int i = 0; i < locals->size(); i++) {\n+          StackValue* var = locals->at(i);\n+          if (var->type() == T_OBJECT) {\n+            if (var->get_obj() == JNIHandles::resolve(_deopt)) {\n+              assert(depth < max_critical_stack_depth, \"can't have more than %d critical frames\", max_critical_stack_depth);\n+              _found = true;\n+              return;\n+            }\n+          }\n+        }\n+        break;\n+      }\n+      depth++;\n+#ifndef ASSERT\n+      if (depth >= max_critical_stack_depth) {\n+        break;\n+      }\n+#endif\n+    }\n+  }\n+};\n+\n+\/*\n+ * This function issues a global handshake operation with all\n+ * Java threads. This is useful for implementing asymmetric\n+ * dekker synchronization schemes, where expensive synchronization\n+ * in performance sensitive common paths, may be shifted to\n+ * a less common slow path instead.\n+ * Top frames containg obj will be deoptimized.\n+ *\/\n+JVM_ENTRY(jboolean, ScopedMemoryAccess_closeScope(JNIEnv *env, jobject receiver, jobject deopt, jobject exception))\n+  CloseScopedMemoryClosure cl(deopt, exception);\n+  Handshake::execute(&cl);\n+  return !cl._found;\n+JVM_END\n+\n+\/\/\/ JVM_RegisterUnsafeMethods\n+\n+#define PKG \"Ljdk\/internal\/misc\/\"\n+\n+#define MEMACCESS \"ScopedMemoryAccess\"\n+#define SCOPE PKG MEMACCESS \"$Scope;\"\n+#define SCOPED_ERR PKG MEMACCESS \"$Scope$ScopedAccessError;\"\n+\n+#define CC (char*)  \/*cast a literal from (const char*)*\/\n+#define FN_PTR(f) CAST_FROM_FN_PTR(void*, &f)\n+\n+static JNINativeMethod jdk_internal_misc_ScopedMemoryAccess_methods[] = {\n+    {CC \"closeScope0\",   CC \"(\" SCOPE SCOPED_ERR \")Z\",           FN_PTR(ScopedMemoryAccess_closeScope)},\n+};\n+\n+#undef CC\n+#undef FN_PTR\n+\n+#undef PKG\n+#undef MEMACCESS\n+#undef SCOPE\n+#undef SCOPED_EXC\n+\n+\/\/ This function is exported, used by NativeLookup.\n+\n+JVM_ENTRY(void, JVM_RegisterJDKInternalMiscScopedMemoryAccessMethods(JNIEnv *env, jclass scopedMemoryAccessClass))\n+  ThreadToNativeFromVM ttnfv(thread);\n+  Thread::WXExecFromWriteSetter wx_exec;\n+\n+  int ok = env->RegisterNatives(scopedMemoryAccessClass, jdk_internal_misc_ScopedMemoryAccess_methods, sizeof(jdk_internal_misc_ScopedMemoryAccess_methods)\/sizeof(JNINativeMethod));\n+  guarantee(ok == 0, \"register jdk.internal.misc.ScopedMemoryAccess natives\");\n+JVM_END\n","filename":"src\/hotspot\/share\/prims\/scopedMemoryAccess.cpp","additions":187,"deletions":0,"binary":false,"changes":187,"status":"added"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"oops\/klass.inline.hpp\"\n@@ -50,0 +51,1 @@\n+#include \"runtime\/stubRoutines.hpp\"\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -57,0 +58,1 @@\n+#include \"oops\/klass.inline.hpp\"\n@@ -99,0 +101,1 @@\n+#include \"gc\/g1\/heapRegionManager.hpp\"\n@@ -100,1 +103,0 @@\n-#include \"gc\/g1\/heterogeneousHeapRegionManager.hpp\"\n@@ -110,0 +112,4 @@\n+#if INCLUDE_JVMCI\n+#include \"jvmci\/jvmciEnv.hpp\"\n+#include \"jvmci\/jvmciRuntime.hpp\"\n+#endif\n@@ -302,1 +308,0 @@\n-  os::init_random(seed);\n@@ -357,0 +362,10 @@\n+WB_ENTRY(jboolean, WB_IsGCSupportedByJVMCICompiler(JNIEnv* env, jobject o, jint name))\n+#if INCLUDE_JVMCI\n+  if (EnableJVMCI) {\n+    JVMCIEnv jvmciEnv(thread, env, __FILE__, __LINE__);\n+    return jvmciEnv.runtime()->is_gc_supported(&jvmciEnv, (CollectedHeap::Name)name);\n+  }\n+#endif\n+  return false;\n+WB_END\n+\n@@ -508,5 +523,1 @@\n-#endif \/\/ INCLUDE_G1GC\n-\n-#if INCLUDE_G1GC || INCLUDE_PARALLELGC\n-WB_ENTRY(jlong, WB_DramReservedStart(JNIEnv* env, jobject o))\n-#if INCLUDE_G1GC\n+WB_ENTRY(jboolean, WB_G1HasRegionsToUncommit(JNIEnv* env, jobject o))\n@@ -514,19 +525,1 @@\n-    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n-    HeapWord* base = g1h->reserved().start();\n-    if (g1h->is_heterogeneous_heap()) {\n-      uint start_region = HeterogeneousHeapRegionManager::manager()->start_index_of_dram();\n-      return (jlong)(base + start_region * HeapRegion::GrainBytes);\n-    } else {\n-      return (jlong)base;\n-    }\n-  }\n-#endif \/\/ INCLUDE_G1GC\n-#if INCLUDE_PARALLELGC\n-  if (UseParallelGC) {\n-    ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();\n-    if (AllocateOldGenAt != NULL) {\n-      MemRegion reserved = ps_heap->young_gen()->reserved();\n-      return (jlong)reserved.start();\n-    } else {\n-      return (jlong)ps_heap->base();\n-    }\n+    return G1CollectedHeap::heap()->has_uncommittable_regions();\n@@ -534,2 +527,1 @@\n-#endif \/\/ INCLUDE_PARALLELGC\n-  THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), \"WB_DramReservedStart: enabled only for G1 and Parallel GC\");\n+  THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), \"WB_G1HasRegionsToUncommit: G1 GC is not enabled\");\n@@ -538,79 +530,0 @@\n-WB_ENTRY(jlong, WB_DramReservedEnd(JNIEnv* env, jobject o))\n-#if INCLUDE_G1GC\n-  if (UseG1GC) {\n-    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n-    HeapWord* base = g1h->reserved().start();\n-    if (g1h->is_heterogeneous_heap()) {\n-      uint end_region = HeterogeneousHeapRegionManager::manager()->end_index_of_dram();\n-      return (jlong)(base + (end_region + 1) * HeapRegion::GrainBytes - 1);\n-    } else {\n-      return (jlong)base + G1Arguments::heap_max_size_bytes();\n-    }\n-  }\n-#if INCLUDE_PARALLELGC\n-  if (UseParallelGC) {\n-    ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();\n-    if (AllocateOldGenAt != NULL) {\n-      MemRegion reserved = ps_heap->young_gen()->reserved();\n-      return (jlong)reserved.end();\n-    } else {\n-      return (jlong)ps_heap->reserved_region().end();\n-    }\n-  }\n-#endif \/\/ INCLUDE_PARALLELGC\n-  THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), \"WB_DramReservedEnd: enabled only for G1 and Parallel GC\");\n-WB_END\n-\n-WB_ENTRY(jlong, WB_NvdimmReservedStart(JNIEnv* env, jobject o))\n-#if INCLUDE_G1GC\n-  if (UseG1GC) {\n-    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n-    if (g1h->is_heterogeneous_heap()) {\n-      uint start_region = HeterogeneousHeapRegionManager::manager()->start_index_of_nvdimm();\n-      return (jlong)(g1h->reserved().start() + start_region * HeapRegion::GrainBytes);\n-    } else {\n-      THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), \"WB_NvdimmReservedStart: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag\");\n-    }\n-  }\n-#endif \/\/ INCLUDE_G1GC\n-#if INCLUDE_PARALLELGC\n-  if (UseParallelGC) {\n-    ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();\n-    if (AllocateOldGenAt != NULL) {\n-      MemRegion reserved = ps_heap->old_gen()->reserved();\n-      return (jlong)reserved.start();\n-    } else {\n-      THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), \"WB_NvdimmReservedStart: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag\");\n-    }\n-  }\n-#endif \/\/ INCLUDE_PARALLELGC\n-  THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), \"WB_NvdimmReservedStart: enabled only for G1 and Parallel GC\");\n-WB_END\n-\n-WB_ENTRY(jlong, WB_NvdimmReservedEnd(JNIEnv* env, jobject o))\n-#if INCLUDE_G1GC\n-  if (UseG1GC) {\n-    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n-    if (g1h->is_heterogeneous_heap()) {\n-      uint end_region = HeterogeneousHeapRegionManager::manager()->start_index_of_nvdimm();\n-      return (jlong)(g1h->reserved().start() + (end_region + 1) * HeapRegion::GrainBytes - 1);\n-    } else {\n-      THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), \"WB_NvdimmReservedEnd: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag\");\n-    }\n-  }\n-#endif \/\/ INCLUDE_G1GC\n-#if INCLUDE_PARALLELGC\n-  if (UseParallelGC) {\n-    ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();\n-    if (AllocateOldGenAt != NULL) {\n-      MemRegion reserved = ps_heap->old_gen()->reserved();\n-      return (jlong)reserved.end();\n-      } else {\n-      THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), \"WB_NvdimmReservedEnd: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag\");\n-    }\n-  }\n-#endif \/\/ INCLUDE_PARALLELGC\n-  THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), \"WB_NvdimmReservedEnd: enabled only for G1 and Parallel GC\");\n-WB_END\n-\n-#endif \/\/ INCLUDE_G1GC || INCLUDE_PARALLELGC\n@@ -785,1 +698,1 @@\n-  os::uncommit_memory((char *)(uintptr_t)addr, size, !ExecMem);\n+  os::uncommit_memory((char *)(uintptr_t)addr, size);\n@@ -1162,1 +1075,1 @@\n-  BasicMatcher* m = BasicMatcher::parse_method_pattern(method_str, error_msg);\n+  BasicMatcher* m = BasicMatcher::parse_method_pattern(method_str, error_msg, false);\n@@ -1935,1 +1848,1 @@\n-  bool result =  CompilerOracle::has_option_value(mh, flag_name, *value);\n+  enum CompileCommand option = CompilerOracle::string_to_option(flag_name);\n@@ -1937,1 +1850,7 @@\n-  return result;\n+  if (option == CompileCommand::Unknown) {\n+    return false;\n+  }\n+  if (!CompilerOracle::option_matches_type(option, *value)) {\n+    return false;\n+  }\n+  return CompilerOracle::has_option_value(mh, option, *value);\n@@ -2070,0 +1989,8 @@\n+WB_ENTRY(jboolean, WB_IsJVMCISupportedByGC(JNIEnv* env))\n+#if INCLUDE_JVMCI\n+  return JVMCIGlobals::gc_supports_jvmci();\n+#else\n+  return false;\n+#endif\n+WB_END\n+\n@@ -2391,0 +2318,19 @@\n+WB_ENTRY(void, WB_VerifyFrames(JNIEnv* env, jobject wb, jboolean log))\n+  intx tty_token = -1;\n+  if (log) {\n+    tty_token = ttyLocker::hold_tty();\n+    tty->print_cr(\"[WhiteBox::VerifyFrames] Walking Frames\");\n+  }\n+  for (StackFrameStream fst(JavaThread::current(), true, true); !fst.is_done(); fst.next()) {\n+    frame* current_frame = fst.current();\n+    if (log) {\n+      current_frame->print_value();\n+    }\n+    current_frame->verify(fst.register_map());\n+  }\n+  if (log) {\n+    tty->print_cr(\"[WhiteBox::VerifyFrames] Done\");\n+    ttyLocker::release_tty(tty_token);\n+  }\n+WB_END\n+\n@@ -2447,0 +2393,1 @@\n+  {CC\"g1HasRegionsToUncommit\",  CC\"()Z\",              (void*)&WB_G1HasRegionsToUncommit},\n@@ -2453,6 +2400,0 @@\n-#if INCLUDE_G1GC || INCLUDE_PARALLELGC\n-  {CC\"dramReservedStart\",   CC\"()J\",                  (void*)&WB_DramReservedStart },\n-  {CC\"dramReservedEnd\",     CC\"()J\",                  (void*)&WB_DramReservedEnd },\n-  {CC\"nvdimmReservedStart\", CC\"()J\",                  (void*)&WB_NvdimmReservedStart },\n-  {CC\"nvdimmReservedEnd\",   CC\"()J\",                  (void*)&WB_NvdimmReservedEnd },\n-#endif \/\/ INCLUDE_G1GC || INCLUDE_PARALLELGC\n@@ -2625,0 +2566,1 @@\n+  {CC\"isJVMCISupportedByGC\",              CC\"()Z\",    (void*)&WB_IsJVMCISupportedByGC},\n@@ -2632,0 +2574,1 @@\n+  {CC\"verifyFrames\",                CC\"(Z)V\",            (void*)&WB_VerifyFrames },\n@@ -2636,0 +2579,1 @@\n+  {CC\"isGCSupportedByJVMCICompiler\", CC\"(I)Z\",        (void*)&WB_IsGCSupportedByJVMCICompiler},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":61,"deletions":117,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,0 +52,1 @@\n+#include \"prims\/jvmtiExport.hpp\"\n@@ -65,0 +66,1 @@\n+#include \"runtime\/keepStackGCProcessed.hpp\"\n@@ -151,4 +153,3 @@\n-\/\/ analysis, The method was changed from JRT_LEAF to JRT_BLOCK_ENTRY and\n-\/\/ ResetNoHandleMark and HandleMark were removed from it. The actual reallocation\n-\/\/ of previously eliminated objects occurs in realloc_objects, which is\n-\/\/ called from the method fetch_unroll_info_helper below.\n+\/\/ analysis, the method was changed from JRT_LEAF to JRT_BLOCK_ENTRY.\n+\/\/ The actual reallocation of previously eliminated objects occurs in realloc_objects,\n+\/\/ which is called from the method fetch_unroll_info_helper below.\n@@ -156,4 +157,0 @@\n-  \/\/ It is actually ok to allocate handles in a leaf method. It causes no safepoints,\n-  \/\/ but makes the entry a little slower. There is however a little dance we have to\n-  \/\/ do in debug mode to get around the NoHandleMark code in the JRT_LEAF macro\n-\n@@ -690,4 +687,7 @@\n-  \/\/ It is actually ok to allocate handles in a leaf method. It causes no safepoints,\n-  \/\/ but makes the entry a little slower. There is however a little dance we have to\n-  \/\/ do in debug mode to get around the NoHandleMark code in the JRT_LEAF macro\n-  ResetNoHandleMark rnhm; \/\/ No-op in release\/product versions\n+  \/\/ JRT_LEAF methods don't normally allocate handles and there is a\n+  \/\/ NoHandleMark to enforce that. It is actually safe to use Handles\n+  \/\/ in a JRT_LEAF method, and sometimes desirable, but to do so we\n+  \/\/ must use ResetNoHandleMark to bypass the NoHandleMark, and\n+  \/\/ then use a HandleMark to ensure any Handles we do create are\n+  \/\/ cleaned up in this scope.\n+  ResetNoHandleMark rnhm;\n@@ -740,1 +740,1 @@\n-    PRESERVE_EXCEPTION_MARK;\n+    PreserveExceptionMark pm(thread);\n@@ -1653,4 +1653,1 @@\n-  if (deoptee_thread != thread) {\n-    \/\/ Process stack of deoptee thread as we will access oops during object deoptimization.\n-    StackWatermarkSet::start_processing(deoptee_thread, StackWatermarkKind::gc);\n-  }\n+  assert(KeepStackGCProcessedMark::stack_is_kept_gc_processed(deoptee_thread), \"must be\");\n@@ -1735,0 +1732,12 @@\n+  vframe* vf = vframe::new_vframe(&caller_frame, &reg_map, thread);\n+  compiledVFrame* cvf = compiledVFrame::cast(vf);\n+  ScopeDesc* imm_scope = cvf->scope();\n+  MethodData* imm_mdo = get_method_data(thread, methodHandle(thread, imm_scope->method()), true);\n+  if (imm_mdo != NULL) {\n+    ProfileData* pdata = imm_mdo->allocate_bci_to_data(imm_scope->bci(), NULL);\n+    if (pdata != NULL && pdata->is_BitData()) {\n+      BitData* bit_data = (BitData*) pdata;\n+      bit_data->set_exception_seen();\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":27,"deletions":18,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,1 @@\n-#include \"compiler\/compiler_globals.hpp\"\n-#include \"gc\/shared\/gc_globals.hpp\"\n+#include \"compiler\/compiler_globals_pd.hpp\"\n@@ -171,3 +170,0 @@\n-  develop(bool, CleanChunkPoolAsync, true,                                  \\\n-          \"Clean the chunk pool asynchronously\")                            \\\n-                                                                            \\\n@@ -200,4 +196,0 @@\n-  product(bool, UseLargePagesInMetaspace, false,                            \\\n-          \"(Deprecated) Use large page memory in metaspace. \"               \\\n-          \"Only used if UseLargePages is enabled.\")                         \\\n-                                                                            \\\n@@ -372,0 +364,1 @@\n+         constraint(DisableIntrinsicConstraintFunc,AfterErgo)               \\\n@@ -376,0 +369,1 @@\n+         constraint(ControlIntrinsicConstraintFunc,AfterErgo)               \\\n@@ -467,3 +461,0 @@\n-  develop(bool, ForceFloatExceptions, trueInDebug,                          \\\n-          \"Force exceptions on FP stack under\/overflow\")                    \\\n-                                                                            \\\n@@ -500,1 +491,4 @@\n-  notproduct(uintx, ErrorHandlerTest, 0,                                    \\\n+  product(bool, ExecutingUnitTests, false,                                  \\\n+          \"Whether the JVM is running unit tests or not\")                   \\\n+                                                                            \\\n+  develop(uintx, ErrorHandlerTest, 0,                                       \\\n@@ -502,1 +496,1 @@\n-          \"determines which error to provoke. See test_error_handler() \"    \\\n+          \"determines which error to provoke. See controlled_crash() \"      \\\n@@ -504,0 +498,1 @@\n+          range(0, 17)                                                      \\\n@@ -505,1 +500,1 @@\n-  notproduct(uintx, TestCrashInErrorHandler, 0,                             \\\n+  develop(uintx, TestCrashInErrorHandler, 0,                                \\\n@@ -507,1 +502,2 @@\n-          \"crash). see test_error_handler() in vmError.cpp\")                \\\n+          \"crash). see controlled_crash() in vmError.cpp\")                  \\\n+          range(0, 17)                                                      \\\n@@ -509,1 +505,1 @@\n-  notproduct(bool, TestSafeFetchInErrorHandler, false,                      \\\n+  develop(bool, TestSafeFetchInErrorHandler, false   ,                      \\\n@@ -512,1 +508,1 @@\n-  notproduct(bool, TestUnresponsiveErrorHandler, false,                     \\\n+  develop(bool, TestUnresponsiveErrorHandler, false,                        \\\n@@ -543,1 +539,2 @@\n-          \"Run user-defined commands on first java.lang.OutOfMemoryError\")  \\\n+          \"Run user-defined commands on first java.lang.OutOfMemoryError \"  \\\n+          \"thrown from JVM\")                                                \\\n@@ -552,1 +549,2 @@\n-          \"Dump heap to file when java.lang.OutOfMemoryError is thrown\")    \\\n+          \"Dump heap to file when java.lang.OutOfMemoryError is thrown \"    \\\n+          \"from JVM\")                                                       \\\n@@ -559,3 +557,0 @@\n-  develop(bool, BreakAtWarning, false,                                      \\\n-          \"Execute breakpoint upon encountering VM warning\")                \\\n-                                                                            \\\n@@ -665,3 +660,0 @@\n-  notproduct(uintx, WarnOnStalledSpinLock, 0,                               \\\n-          \"Print warnings for stalled SpinLocks\")                           \\\n-                                                                            \\\n@@ -676,4 +668,0 @@\n-  develop(bool, IgnoreRewrites, false,                                      \\\n-          \"Suppress rewrites of bytecodes in the oopmap generator. \"        \\\n-          \"This is unsafe!\")                                                \\\n-                                                                            \\\n@@ -695,4 +683,0 @@\n-  develop(bool, DisableStartThread, false,                                  \\\n-          \"Disable starting of additional Java threads \"                    \\\n-          \"(for debugging only)\")                                           \\\n-                                                                            \\\n@@ -709,2 +693,2 @@\n-          \"Require the VM to acquire the class loader lock before calling \" \\\n-          \"loadClass() even for class loaders registering \"                 \\\n+          \"(Deprecated) Require the VM to acquire the class loader lock \"   \\\n+          \"before calling loadClass() even for class loaders registering \"  \\\n@@ -731,0 +715,12 @@\n+  product(size_t, AvgMonitorsPerThreadEstimate, 1024, DIAGNOSTIC,           \\\n+          \"Used to estimate a variable ceiling based on number of threads \" \\\n+          \"for use with MonitorUsedDeflationThreshold (0 is off).\")         \\\n+          range(0, max_uintx)                                               \\\n+                                                                            \\\n+  \/* notice: the max range value here is max_jint, not max_intx  *\/         \\\n+  \/* because of overflow issue                                   *\/         \\\n+  product(intx, MonitorDeflationMax, 1000000, DIAGNOSTIC,                   \\\n+          \"The maximum number of monitors to deflate, unlink and delete \"   \\\n+          \"at one time (minimum is 1024).\")                      \\\n+          range(1024, max_jint)                                             \\\n+                                                                            \\\n@@ -737,0 +733,5 @@\n+  product(uintx, NoAsyncDeflationProgressMax, 3, DIAGNOSTIC,                \\\n+          \"Max number of no progress async deflation attempts to tolerate \" \\\n+          \"before adjusting the in_use_list_ceiling up (0 is off).\")        \\\n+          range(0, max_uintx)                                               \\\n+                                                                            \\\n@@ -844,1 +845,1 @@\n-  product(intx, DiagnoseSyncOnPrimitiveWrappers, 0, DIAGNOSTIC,             \\\n+  product(intx, DiagnoseSyncOnValueBasedClasses, 0, DIAGNOSTIC,             \\\n@@ -846,1 +847,1 @@\n-             \"primitive wrappers. Modes: \"                                  \\\n+             \"value based classes. Modes: \"                                 \\\n@@ -850,1 +851,1 @@\n-             \"   -Xlog:primitivewrappers. If JFR is running it will \"       \\\n+             \"   -Xlog:valuebasedclasses. If JFR is running it will \"       \\\n@@ -855,1 +856,2 @@\n-          \"JVM exits on the first occurrence of an out-of-memory error\")    \\\n+          \"JVM exits on the first occurrence of an out-of-memory error \"    \\\n+          \"thrown from JVM\")                                                \\\n@@ -859,1 +861,1 @@\n-          \"first occurrence of an out-of-memory error\")                     \\\n+          \"first occurrence of an out-of-memory error thrown from JVM\")     \\\n@@ -869,9 +871,5 @@\n-  \/* This option can change an EMCP method into an obsolete method. *\/      \\\n-  \/* This can affect tests that except specific methods to be EMCP. *\/      \\\n-  \/* This option should be used with caution.                       *\/      \\\n-  product(bool, StressLdcRewrite, false,                                    \\\n-          \"Force ldc -> ldc_w rewrite during RedefineClasses\")              \\\n-                                                                            \\\n-  \/* change to false by default sometime after Mustang *\/                   \\\n-  product(bool, VerifyMergedCPBytecodes, true,                              \\\n-          \"Verify bytecodes after RedefineClasses constant pool merging\")   \\\n+  product(bool, StressLdcRewrite, false, DIAGNOSTIC,                        \\\n+          \"Force ldc -> ldc_w rewrite during RedefineClasses. \"             \\\n+          \"This option can change an EMCP method into an obsolete method \"  \\\n+          \"and can affect tests that expect specific methods to be EMCP. \"  \\\n+          \"This option should be used with caution.\")                       \\\n@@ -939,5 +937,0 @@\n-  product(size_t, InitialBootClassLoaderMetaspaceSize,                      \\\n-          NOT_LP64(2200*K) LP64_ONLY(4*M),                                  \\\n-          \"(Deprecated) Initial size of the boot class loader data metaspace\") \\\n-          range(30*K, max_uintx\/BytesPerWord)                               \\\n-                                                                            \\\n@@ -957,3 +950,0 @@\n-  product(bool, TraceJVMTIObjectTagging, false, DIAGNOSTIC,                 \\\n-          \"Trace JVMTI object tagging calls\")                               \\\n-                                                                            \\\n@@ -963,43 +953,0 @@\n-  \/* compiler interface *\/                                                  \\\n-                                                                            \\\n-  develop(bool, CIPrintCompilerName, false,                                 \\\n-          \"when CIPrint is active, print the name of the active compiler\")  \\\n-                                                                            \\\n-  product(bool, CIPrintCompileQueue, false, DIAGNOSTIC,                     \\\n-          \"display the contents of the compile queue whenever a \"           \\\n-          \"compilation is enqueued\")                                        \\\n-                                                                            \\\n-  develop(bool, CIPrintRequests, false,                                     \\\n-          \"display every request for compilation\")                          \\\n-                                                                            \\\n-  product(bool, CITime, false,                                              \\\n-          \"collect timing information for compilation\")                     \\\n-                                                                            \\\n-  develop(bool, CITimeVerbose, false,                                       \\\n-          \"be more verbose in compilation timings\")                         \\\n-                                                                            \\\n-  develop(bool, CITimeEach, false,                                          \\\n-          \"display timing information after each successful compilation\")   \\\n-                                                                            \\\n-  develop(bool, CICountOSR, false,                                          \\\n-          \"use a separate counter when assigning ids to osr compilations\")  \\\n-                                                                            \\\n-  develop(bool, CICompileNatives, true,                                     \\\n-          \"compile native methods if supported by the compiler\")            \\\n-                                                                            \\\n-  develop_pd(bool, CICompileOSR,                                            \\\n-          \"compile on stack replacement methods if supported by the \"       \\\n-          \"compiler\")                                                       \\\n-                                                                            \\\n-  develop(bool, CIPrintMethodCodes, false,                                  \\\n-          \"print method bytecodes of the compiled code\")                    \\\n-                                                                            \\\n-  develop(bool, CIPrintTypeFlow, false,                                     \\\n-          \"print the results of ciTypeFlow analysis\")                       \\\n-                                                                            \\\n-  develop(bool, CITraceTypeFlow, false,                                     \\\n-          \"detailed per-bytecode tracing of ciTypeFlow analysis\")           \\\n-                                                                            \\\n-  develop(intx, OSROnlyBCI, -1,                                             \\\n-          \"OSR only at this bci.  Negative values mean exclude that bci\")   \\\n-                                                                            \\\n@@ -1029,5 +976,0 @@\n-  develop(bool, UseStackBanging, true,                                      \\\n-          \"use stack banging for stack overflow checks (required for \"      \\\n-          \"proper StackOverflow handling; disable only to measure cost \"    \\\n-          \"of stackbanging)\")                                               \\\n-                                                                            \\\n@@ -1185,4 +1127,0 @@\n-  notproduct(bool, ExitVMOnVerifyError, false,                              \\\n-          \"standard exit from VM if bytecode verify error \"                 \\\n-          \"(only in debug mode)\")                                           \\\n-                                                                            \\\n@@ -1254,13 +1192,0 @@\n-  notproduct(bool, CountRuntimeCalls, false,                                \\\n-          \"Count VM runtime calls\")                                         \\\n-                                                                            \\\n-  develop(bool, CountJNICalls, false,                                       \\\n-          \"Count jni method invocations\")                                   \\\n-                                                                            \\\n-  notproduct(bool, CountJVMCalls, false,                                    \\\n-          \"Count jvm method invocations\")                                   \\\n-                                                                            \\\n-  notproduct(bool, CountRemovableExceptions, false,                         \\\n-          \"Count exceptions that could be replaced by branches due to \"     \\\n-          \"inlining\")                                                       \\\n-                                                                            \\\n@@ -1380,20 +1305,0 @@\n-  product(bool, DontCompileHugeMethods, true,                               \\\n-          \"Do not compile methods > HugeMethodLimit\")                       \\\n-                                                                            \\\n-  \/* Bytecode escape analysis estimation. *\/                                \\\n-  product(bool, EstimateArgEscape, true,                                    \\\n-          \"Analyze bytecodes to estimate escape state of arguments\")        \\\n-                                                                            \\\n-  product(intx, BCEATraceLevel, 0,                                          \\\n-          \"How much tracing to do of bytecode escape analysis estimates \"   \\\n-          \"(0-3)\")                                                          \\\n-          range(0, 3)                                                       \\\n-                                                                            \\\n-  product(intx, MaxBCEAEstimateLevel, 5,                                    \\\n-          \"Maximum number of nested calls that are analyzed by BC EA\")      \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, MaxBCEAEstimateSize, 150,                                   \\\n-          \"Maximum bytecode size of a method to be analyzed by BC EA\")      \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n@@ -1775,71 +1680,0 @@\n-  \/* compiler interface *\/                                                  \\\n-  develop(intx, CIStart, 0,                                                 \\\n-          \"The id of the first compilation to permit\")                      \\\n-                                                                            \\\n-  develop(intx, CIStop, max_jint,                                           \\\n-          \"The id of the last compilation to permit\")                       \\\n-                                                                            \\\n-  develop(intx, CIStartOSR, 0,                                              \\\n-          \"The id of the first osr compilation to permit \"                  \\\n-          \"(CICountOSR must be on)\")                                        \\\n-                                                                            \\\n-  develop(intx, CIStopOSR, max_jint,                                        \\\n-          \"The id of the last osr compilation to permit \"                   \\\n-          \"(CICountOSR must be on)\")                                        \\\n-                                                                            \\\n-  develop(intx, CIBreakAtOSR, -1,                                           \\\n-          \"The id of osr compilation to break at\")                          \\\n-                                                                            \\\n-  develop(intx, CIBreakAt, -1,                                              \\\n-          \"The id of compilation to break at\")                              \\\n-                                                                            \\\n-  product(ccstrlist, CompileOnly, \"\",                                       \\\n-          \"List of methods (pkg\/class.name) to restrict compilation to\")    \\\n-                                                                            \\\n-  product(ccstr, CompileCommandFile, NULL,                                  \\\n-          \"Read compiler commands from this file [.hotspot_compiler]\")      \\\n-                                                                            \\\n-  product(ccstr, CompilerDirectivesFile, NULL, DIAGNOSTIC,                  \\\n-          \"Read compiler directives from this file\")                        \\\n-                                                                            \\\n-  product(ccstrlist, CompileCommand, \"\",                                    \\\n-          \"Prepend to .hotspot_compiler; e.g. log,java\/lang\/String.<init>\") \\\n-                                                                            \\\n-  develop(bool, ReplayCompiles, false,                                      \\\n-          \"Enable replay of compilations from ReplayDataFile\")              \\\n-                                                                            \\\n-  product(ccstr, ReplayDataFile, NULL,                                      \\\n-          \"File containing compilation replay information\"                  \\\n-          \"[default: .\/replay_pid%p.log] (%p replaced with pid)\")           \\\n-                                                                            \\\n-  product(ccstr, InlineDataFile, NULL,                                      \\\n-          \"File containing inlining replay information\"                     \\\n-          \"[default: .\/inline_pid%p.log] (%p replaced with pid)\")           \\\n-                                                                            \\\n-  develop(intx, ReplaySuppressInitializers, 2,                              \\\n-          \"Control handling of class initialization during replay: \"        \\\n-          \"0 - don't do anything special; \"                                 \\\n-          \"1 - treat all class initializers as empty; \"                     \\\n-          \"2 - treat class initializers for application classes as empty; \" \\\n-          \"3 - allow all class initializers to run during bootstrap but \"   \\\n-          \"    pretend they are empty after starting replay\")               \\\n-          range(0, 3)                                                       \\\n-                                                                            \\\n-  develop(bool, ReplayIgnoreInitErrors, false,                              \\\n-          \"Ignore exceptions thrown during initialization for replay\")      \\\n-                                                                            \\\n-  product(bool, DumpReplayDataOnError, true,                                \\\n-          \"Record replay data for crashing compiler threads\")               \\\n-                                                                            \\\n-  product(bool, CICompilerCountPerCPU, false,                               \\\n-          \"1 compiler thread for log(N CPUs)\")                              \\\n-                                                                            \\\n-  notproduct(intx, CICrashAt, -1,                                           \\\n-          \"id of compilation to trigger assert in compiler thread for \"     \\\n-          \"the purpose of testing, e.g. generation of replay data\")         \\\n-  notproduct(bool, CIObjectFactoryVerify, false,                            \\\n-          \"enable potentially expensive verification in ciObjectFactory\")   \\\n-                                                                            \\\n-  product(bool, AbortVMOnCompilationFailure, false, DIAGNOSTIC,             \\\n-          \"Abort VM when method had failed to compile.\")                    \\\n-                                                                            \\\n@@ -1943,224 +1777,0 @@\n-  product(double, CompileThresholdScaling, 1.0,                             \\\n-          \"Factor to control when first compilation happens \"               \\\n-          \"(both with and without tiered compilation): \"                    \\\n-          \"values greater than 1.0 delay counter overflow, \"                \\\n-          \"values between 0 and 1.0 rush counter overflow, \"                \\\n-          \"value of 1.0 leaves compilation thresholds unchanged \"           \\\n-          \"value of 0.0 is equivalent to -Xint. \"                           \\\n-          \"\"                                                                \\\n-          \"Flag can be set as per-method option. \"                          \\\n-          \"If a value is specified for a method, compilation thresholds \"   \\\n-          \"for that method are scaled by both the value of the global flag \"\\\n-          \"and the value of the per-method flag.\")                          \\\n-          range(0.0, DBL_MAX)                                               \\\n-                                                                            \\\n-  product(intx, Tier0InvokeNotifyFreqLog, 7,                                \\\n-          \"Interpreter (tier 0) invocation notification frequency\")         \\\n-          range(0, 30)                                                      \\\n-                                                                            \\\n-  product(intx, Tier2InvokeNotifyFreqLog, 11,                               \\\n-          \"C1 without MDO (tier 2) invocation notification frequency\")      \\\n-          range(0, 30)                                                      \\\n-                                                                            \\\n-  product(intx, Tier3InvokeNotifyFreqLog, 10,                               \\\n-          \"C1 with MDO profiling (tier 3) invocation notification \"         \\\n-          \"frequency\")                                                      \\\n-          range(0, 30)                                                      \\\n-                                                                            \\\n-  product(intx, Tier23InlineeNotifyFreqLog, 20,                             \\\n-          \"Inlinee invocation (tiers 2 and 3) notification frequency\")      \\\n-          range(0, 30)                                                      \\\n-                                                                            \\\n-  product(intx, Tier0BackedgeNotifyFreqLog, 10,                             \\\n-          \"Interpreter (tier 0) invocation notification frequency\")         \\\n-          range(0, 30)                                                      \\\n-                                                                            \\\n-  product(intx, Tier2BackedgeNotifyFreqLog, 14,                             \\\n-          \"C1 without MDO (tier 2) invocation notification frequency\")      \\\n-          range(0, 30)                                                      \\\n-                                                                            \\\n-  product(intx, Tier3BackedgeNotifyFreqLog, 13,                             \\\n-          \"C1 with MDO profiling (tier 3) invocation notification \"         \\\n-          \"frequency\")                                                      \\\n-          range(0, 30)                                                      \\\n-                                                                            \\\n-  product(intx, Tier2CompileThreshold, 0,                                   \\\n-          \"threshold at which tier 2 compilation is invoked\")               \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier2BackEdgeThreshold, 0,                                  \\\n-          \"Back edge threshold at which tier 2 compilation is invoked\")     \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier3InvocationThreshold, 200,                              \\\n-          \"Compile if number of method invocations crosses this \"           \\\n-          \"threshold\")                                                      \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier3MinInvocationThreshold, 100,                           \\\n-          \"Minimum invocation to compile at tier 3\")                        \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier3CompileThreshold, 2000,                                \\\n-          \"Threshold at which tier 3 compilation is invoked (invocation \"   \\\n-          \"minimum must be satisfied)\")                                     \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier3BackEdgeThreshold,  60000,                             \\\n-          \"Back edge threshold at which tier 3 OSR compilation is invoked\") \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier3AOTInvocationThreshold, 10000,                         \\\n-          \"Compile if number of method invocations crosses this \"           \\\n-          \"threshold if coming from AOT\")                                   \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier3AOTMinInvocationThreshold, 1000,                       \\\n-          \"Minimum invocation to compile at tier 3 if coming from AOT\")     \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier3AOTCompileThreshold, 15000,                            \\\n-          \"Threshold at which tier 3 compilation is invoked (invocation \"   \\\n-          \"minimum must be satisfied) if coming from AOT\")                  \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier3AOTBackEdgeThreshold,  120000,                         \\\n-          \"Back edge threshold at which tier 3 OSR compilation is invoked \" \\\n-          \"if coming from AOT\")                                             \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier0AOTInvocationThreshold, 200, DIAGNOSTIC,               \\\n-          \"Switch to interpreter to profile if the number of method \"       \\\n-          \"invocations crosses this threshold if coming from AOT \"          \\\n-          \"(applicable only with \"                                          \\\n-          \"CompilationMode=high-only|high-only-quick-internal)\")            \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier0AOTMinInvocationThreshold, 100, DIAGNOSTIC,            \\\n-          \"Minimum number of invocations to switch to interpreter \"         \\\n-          \"to profile if coming from AOT \"                                  \\\n-          \"(applicable only with \"                                          \\\n-          \"CompilationMode=high-only|high-only-quick-internal)\")            \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier0AOTCompileThreshold, 2000, DIAGNOSTIC,                 \\\n-          \"Threshold at which to switch to interpreter to profile \"         \\\n-          \"if coming from AOT \"                                             \\\n-          \"(invocation minimum must be satisfied, \"                         \\\n-          \"applicable only with \"                                           \\\n-          \"CompilationMode=high-only|high-only-quick-internal)\")            \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier0AOTBackEdgeThreshold,  60000, DIAGNOSTIC,              \\\n-          \"Back edge threshold at which to switch to interpreter \"          \\\n-          \"to profile if coming from AOT \"                                  \\\n-          \"(applicable only with \"                                          \\\n-          \"CompilationMode=high-only|high-only-quick-internal)\")            \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier4InvocationThreshold, 5000,                             \\\n-          \"Compile if number of method invocations crosses this \"           \\\n-          \"threshold\")                                                      \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier4MinInvocationThreshold, 600,                           \\\n-          \"Minimum invocation to compile at tier 4\")                        \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier4CompileThreshold, 15000,                               \\\n-          \"Threshold at which tier 4 compilation is invoked (invocation \"   \\\n-          \"minimum must be satisfied)\")                                     \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier4BackEdgeThreshold, 40000,                              \\\n-          \"Back edge threshold at which tier 4 OSR compilation is invoked\") \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier40InvocationThreshold, 5000, DIAGNOSTIC,                \\\n-          \"Compile if number of method invocations crosses this \"           \\\n-          \"threshold (applicable only with \"                                \\\n-          \"CompilationMode=high-only|high-only-quick-internal)\")            \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier40MinInvocationThreshold, 600, DIAGNOSTIC,              \\\n-          \"Minimum number of invocations to compile at tier 4 \"             \\\n-          \"(applicable only with \"                                          \\\n-          \"CompilationMode=high-only|high-only-quick-internal)\")            \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier40CompileThreshold, 10000, DIAGNOSTIC,                  \\\n-          \"Threshold at which tier 4 compilation is invoked (invocation \"   \\\n-          \"minimum must be satisfied, applicable only with \"                \\\n-          \"CompilationMode=high-only|high-only-quick-internal)\")            \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier40BackEdgeThreshold, 15000, DIAGNOSTIC,                 \\\n-          \"Back edge threshold at which tier 4 OSR compilation is invoked \" \\\n-          \"(applicable only with \"                                          \\\n-          \"CompilationMode=high-only|high-only-quick-internal)\")            \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier0Delay, 5, DIAGNOSTIC,                                  \\\n-          \"If C2 queue size grows over this amount per compiler thread \"    \\\n-          \"do not start profiling in the interpreter \"                      \\\n-          \"(applicable only with \"                                          \\\n-          \"CompilationMode=high-only|high-only-quick-internal)\")            \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier3DelayOn, 5,                                            \\\n-          \"If C2 queue size grows over this amount per compiler thread \"    \\\n-          \"stop compiling at tier 3 and start compiling at tier 2\")         \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier3DelayOff, 2,                                           \\\n-          \"If C2 queue size is less than this amount per compiler thread \"  \\\n-          \"allow methods compiled at tier 2 transition to tier 3\")          \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier3LoadFeedback, 5,                                       \\\n-          \"Tier 3 thresholds will increase twofold when C1 queue size \"     \\\n-          \"reaches this amount per compiler thread\")                        \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier4LoadFeedback, 3,                                       \\\n-          \"Tier 4 thresholds will increase twofold when C2 queue size \"     \\\n-          \"reaches this amount per compiler thread\")                        \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, TieredCompileTaskTimeout, 50,                               \\\n-          \"Kill compile task if method was not used within \"                \\\n-          \"given timeout in milliseconds\")                                  \\\n-          range(0, max_intx)                                                \\\n-                                                                            \\\n-  product(intx, TieredStopAtLevel, 4,                                       \\\n-          \"Stop at given compilation level\")                                \\\n-          range(0, 4)                                                       \\\n-                                                                            \\\n-  product(intx, Tier0ProfilingStartPercentage, 200,                         \\\n-          \"Start profiling in interpreter if the counters exceed tier 3 \"   \\\n-          \"thresholds (tier 4 thresholds with \"                             \\\n-          \"CompilationMode=high-only|high-only-quick-internal)\"             \\\n-          \"by the specified percentage\")                                    \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(uintx, IncreaseFirstTierCompileThresholdAt, 50,                   \\\n-          \"Increase the compile threshold for C1 compilation if the code \"  \\\n-          \"cache is filled by the specified percentage\")                    \\\n-          range(0, 99)                                                      \\\n-                                                                            \\\n-  product(intx, TieredRateUpdateMinTime, 1,                                 \\\n-          \"Minimum rate sampling interval (in milliseconds)\")               \\\n-          range(0, max_intx)                                                \\\n-                                                                            \\\n-  product(intx, TieredRateUpdateMaxTime, 25,                                \\\n-          \"Maximum rate sampling interval (in milliseconds)\")               \\\n-          range(0, max_intx)                                                \\\n-                                                                            \\\n-  product(ccstr, CompilationMode, \"default\",                                \\\n-          \"Compilation modes: \"                                             \\\n-          \"default: normal tiered compilation; \"                            \\\n-          \"quick-only: C1-only mode; \"                                      \\\n-          \"high-only: C2\/JVMCI-only mode; \"                                 \\\n-          \"high-only-quick-internal: C2\/JVMCI-only mode, \"                  \\\n-          \"with JVMCI compiler compiled with C1.\")                          \\\n-                                                                            \\\n@@ -2170,20 +1780,0 @@\n-  product(bool, PrintTieredEvents, false,                                   \\\n-          \"Print tiered events notifications\")                              \\\n-                                                                            \\\n-  product_pd(intx, OnStackReplacePercentage,                                \\\n-          \"NON_TIERED number of method invocations\/branches (expressed as \" \\\n-          \"% of CompileThreshold) before (re-)compiling OSR code\")          \\\n-          constraint(OnStackReplacePercentageConstraintFunc, AfterErgo)     \\\n-                                                                            \\\n-  product(intx, InterpreterProfilePercentage, 33,                           \\\n-          \"NON_TIERED number of method invocations\/branches (expressed as \" \\\n-          \"% of CompileThreshold) before profiling in the interpreter\")     \\\n-          range(0, 100)                                                     \\\n-                                                                            \\\n-  develop(intx, DesiredMethodLimit,  8000,                                  \\\n-          \"The desired maximum method size (in bytecodes) after inlining\")  \\\n-                                                                            \\\n-  develop(intx, HugeMethodLimit,  8000,                                     \\\n-          \"Don't compile methods larger than this if \"                      \\\n-          \"+DontCompileHugeMethods\")                                        \\\n-                                                                            \\\n@@ -2218,0 +1808,3 @@\n+  notproduct(bool, EnableJVMTIStackDepthAsserts, true,                      \\\n+          \"Enable JVMTI asserts related to stack depth checks\")             \\\n+                                                                            \\\n@@ -2451,9 +2044,1 @@\n-  product(bool, CompilerDirectivesIgnoreCompileCommands, false, DIAGNOSTIC, \\\n-             \"Disable backwards compatibility for compile commands.\")       \\\n-                                                                            \\\n-  product(bool, CompilerDirectivesPrint, false, DIAGNOSTIC,                 \\\n-             \"Print compiler directives on installation.\")                  \\\n-  product(int,  CompilerDirectivesLimit, 50, DIAGNOSTIC,                    \\\n-             \"Limit on number of compiler directives.\")                     \\\n-                                                                            \\\n-          \"Path to the directoy where a temporary file will be created \"    \\\n+          \"Path to the directory where a temporary file will be created \"   \\\n@@ -2463,6 +2048,0 @@\n-  product(ccstr, AllocateOldGenAt, NULL, EXPERIMENTAL,                      \\\n-          \"Path to the directoy where a temporary file will be \"            \\\n-          \"created to use as the backing store for old generation.\"         \\\n-          \"File of size Xmx is pre-allocated for performance reason, so\"    \\\n-          \"we need that much space available\")                              \\\n-                                                                            \\\n@@ -2498,1 +2077,6 @@\n-                \"Make nmethod barriers deoptimise a lot.\")\n+                \"Make nmethod barriers deoptimise a lot.\")                  \\\n+                                                                            \\\n+  develop(bool, VerifyCrossModifyFence,                                     \\\n+          false AARCH64_ONLY(DEBUG_ONLY(||true)),                           \\\n+             \"Mark all threads after a safepoint, and clear on a modify \"   \\\n+             \"fence. Add cleanliness checks.\")                              \\\n@@ -2502,20 +2086,4 @@\n-\/\/ Interface macros\n-#define DECLARE_PRODUCT_FLAG(type, name, value, ...)      extern \"C\" type name;\n-#define DECLARE_PD_PRODUCT_FLAG(type, name, ...)          extern \"C\" type name;\n-#ifdef PRODUCT\n-#define DECLARE_DEVELOPER_FLAG(type, name, value, ...)    const type name = value;\n-#define DECLARE_PD_DEVELOPER_FLAG(type, name, ...)        const type name = pd_##name;\n-#define DECLARE_NOTPRODUCT_FLAG(type, name, value, ...)   const type name = value;\n-#else\n-#define DECLARE_DEVELOPER_FLAG(type, name, value, ...)    extern \"C\" type name;\n-#define DECLARE_PD_DEVELOPER_FLAG(type, name, ...)        extern \"C\" type name;\n-#define DECLARE_NOTPRODUCT_FLAG(type, name, value, ...)   extern \"C\" type name;\n-#endif \/\/ PRODUCT\n-\n-ALL_FLAGS(DECLARE_DEVELOPER_FLAG,\n-          DECLARE_PD_DEVELOPER_FLAG,\n-          DECLARE_PRODUCT_FLAG,\n-          DECLARE_PD_PRODUCT_FLAG,\n-          DECLARE_NOTPRODUCT_FLAG,\n-          IGNORE_RANGE,\n-          IGNORE_CONSTRAINT)\n+DECLARE_FLAGS(LP64_RUNTIME_FLAGS)\n+DECLARE_ARCH_FLAGS(ARCH_FLAGS)\n+DECLARE_FLAGS(RUNTIME_FLAGS)\n+DECLARE_FLAGS(RUNTIME_OS_FLAGS)\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":63,"deletions":495,"binary":false,"changes":558,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n@@ -37,1 +38,0 @@\n-#include \"utilities\/histogram.hpp\"\n@@ -194,0 +194,1 @@\n+  ResetNoHandleMark __rnhm;\n@@ -332,15 +333,0 @@\n-class RuntimeHistogramElement : public HistogramElement {\n-  public:\n-   RuntimeHistogramElement(const char* name);\n-};\n-#endif \/\/ ASSERT\n-\n-#ifdef ASSERT\n-#define TRACE_CALL(result_type, header)                            \\\n-  if (CountRuntimeCalls) {                                         \\\n-    static RuntimeHistogramElement* e = new RuntimeHistogramElement(#header); \\\n-    if (e != NULL) e->increment_count();                           \\\n-  }\n-#else\n-#define TRACE_CALL(result_type, header)                            \\\n-  \/* do nothing *\/\n@@ -349,1 +335,0 @@\n-\n@@ -353,1 +338,0 @@\n-  TRACE_CALL(result_type, header)                                    \\\n@@ -359,1 +343,0 @@\n-  TRACE_CALL(result_type, header)                                    \\\n@@ -370,1 +353,0 @@\n-  TRACE_CALL(result_type, header)                                    \\\n@@ -415,1 +397,0 @@\n-    TRACE_CALL(result_type, header)                                  \\\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.inline.hpp","additions":3,"deletions":22,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"prims\/jvmtiExport.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+#include \"oops\/oopHandle.inline.hpp\"\n+#include \"oops\/weakHandle.inline.hpp\"\n@@ -38,0 +40,1 @@\n+#include \"prims\/jvmtiExport.hpp\"\n@@ -268,0 +271,23 @@\n+ObjectMonitor::ObjectMonitor(oop object) :\n+  _header(markWord::zero()),\n+  _object(_oop_storage, object),\n+  _owner(NULL),\n+  _previous_owner_tid(0),\n+  _next_om(NULL),\n+  _recursions(0),\n+  _EntryList(NULL),\n+  _cxq(NULL),\n+  _succ(NULL),\n+  _Responsible(NULL),\n+  _Spinner(0),\n+  _SpinDuration(ObjectMonitor::Knob_SpinLimit),\n+  _contentions(0),\n+  _WaitSet(NULL),\n+  _waiters(0),\n+  _WaitSetLock(0)\n+{ }\n+\n+ObjectMonitor::~ObjectMonitor() {\n+  _object.release(_oop_storage);\n+}\n+\n@@ -283,9 +309,0 @@\n-void ObjectMonitor::set_object(oop obj) {\n-  check_object_context();\n-  if (_object.is_null()) {\n-    _object = WeakHandle(_oop_storage, obj);\n-  } else {\n-    _object.replace(obj);\n-  }\n-}\n-\n@@ -329,1 +346,1 @@\n-    assert(_owner == Self, \"must be Self: owner=\" INTPTR_FORMAT, p2i(_owner));\n+    assert(owner_raw() == Self, \"must be Self: owner=\" INTPTR_FORMAT, p2i(owner_raw()));\n@@ -339,1 +356,1 @@\n-  assert(_owner != Self, \"invariant\");\n+  assert(owner_raw() != Self, \"invariant\");\n@@ -364,1 +381,1 @@\n-  if (event.should_commit()) {\n+  if (event.is_started()) {\n@@ -366,1 +383,4 @@\n-    event.set_address((uintptr_t)object_addr());\n+    \/\/ Set an address that is 'unique enough', such that events close in\n+    \/\/ time and with the same address are likely (but not guaranteed) to\n+    \/\/ belong to the same object.\n+    event.set_address((uintptr_t)this);\n@@ -427,1 +447,1 @@\n-  assert(_owner == Self, \"invariant\");\n+  assert(owner_raw() == Self, \"invariant\");\n@@ -465,1 +485,1 @@\n-  void * own = _owner;\n+  void* own = owner_raw();\n@@ -478,0 +498,104 @@\n+\/\/ Deflate the specified ObjectMonitor if not in-use. Returns true if it\n+\/\/ was deflated and false otherwise.\n+\/\/\n+\/\/ The async deflation protocol sets owner to DEFLATER_MARKER and\n+\/\/ makes contentions negative as signals to contending threads that\n+\/\/ an async deflation is in progress. There are a number of checks\n+\/\/ as part of the protocol to make sure that the calling thread has\n+\/\/ not lost the race to a contending thread.\n+\/\/\n+\/\/ The ObjectMonitor has been successfully async deflated when:\n+\/\/   (contentions < 0)\n+\/\/ Contending threads that see that condition know to retry their operation.\n+\/\/\n+bool ObjectMonitor::deflate_monitor() {\n+  if (is_busy() != 0) {\n+    \/\/ Easy checks are first - the ObjectMonitor is busy so no deflation.\n+    return false;\n+  }\n+\n+  if (ObjectSynchronizer::is_final_audit() && owner_is_DEFLATER_MARKER()) {\n+    \/\/ The final audit can see an already deflated ObjectMonitor on the\n+    \/\/ in-use list because MonitorList::unlink_deflated() might have\n+    \/\/ blocked for the final safepoint before unlinking all the deflated\n+    \/\/ monitors.\n+    assert(contentions() < 0, \"must be negative: contentions=%d\", contentions());\n+    \/\/ Already returned 'true' when it was originally deflated.\n+    return false;\n+  }\n+\n+  const oop obj = object_peek();\n+\n+  if (obj == NULL) {\n+    \/\/ If the object died, we can recycle the monitor without racing with\n+    \/\/ Java threads. The GC already broke the association with the object.\n+    set_owner_from(NULL, DEFLATER_MARKER);\n+    assert(contentions() >= 0, \"must be non-negative: contentions=%d\", contentions());\n+    _contentions = -max_jint;\n+  } else {\n+    \/\/ Attempt async deflation protocol.\n+\n+    \/\/ Set a NULL owner to DEFLATER_MARKER to force any contending thread\n+    \/\/ through the slow path. This is just the first part of the async\n+    \/\/ deflation dance.\n+    if (try_set_owner_from(NULL, DEFLATER_MARKER) != NULL) {\n+      \/\/ The owner field is no longer NULL so we lost the race since the\n+      \/\/ ObjectMonitor is now busy.\n+      return false;\n+    }\n+\n+    if (contentions() > 0 || _waiters != 0) {\n+      \/\/ Another thread has raced to enter the ObjectMonitor after\n+      \/\/ is_busy() above or has already entered and waited on\n+      \/\/ it which makes it busy so no deflation. Restore owner to\n+      \/\/ NULL if it is still DEFLATER_MARKER.\n+      if (try_set_owner_from(DEFLATER_MARKER, NULL) != DEFLATER_MARKER) {\n+        \/\/ Deferred decrement for the JT EnterI() that cancelled the async deflation.\n+        add_to_contentions(-1);\n+      }\n+      return false;\n+    }\n+\n+    \/\/ Make a zero contentions field negative to force any contending threads\n+    \/\/ to retry. This is the second part of the async deflation dance.\n+    if (Atomic::cmpxchg(&_contentions, (jint)0, -max_jint) != 0) {\n+      \/\/ Contentions was no longer 0 so we lost the race since the\n+      \/\/ ObjectMonitor is now busy. Restore owner to NULL if it is\n+      \/\/ still DEFLATER_MARKER:\n+      if (try_set_owner_from(DEFLATER_MARKER, NULL) != DEFLATER_MARKER) {\n+        \/\/ Deferred decrement for the JT EnterI() that cancelled the async deflation.\n+        add_to_contentions(-1);\n+      }\n+      return false;\n+    }\n+  }\n+\n+  \/\/ Sanity checks for the races:\n+  guarantee(owner_is_DEFLATER_MARKER(), \"must be deflater marker\");\n+  guarantee(contentions() < 0, \"must be negative: contentions=%d\",\n+            contentions());\n+  guarantee(_waiters == 0, \"must be 0: waiters=%d\", _waiters);\n+  guarantee(_cxq == NULL, \"must be no contending threads: cxq=\"\n+            INTPTR_FORMAT, p2i(_cxq));\n+  guarantee(_EntryList == NULL,\n+            \"must be no entering threads: EntryList=\" INTPTR_FORMAT,\n+            p2i(_EntryList));\n+\n+  if (obj != NULL) {\n+    if (log_is_enabled(Trace, monitorinflation)) {\n+      ResourceMark rm;\n+      log_trace(monitorinflation)(\"deflate_monitor: object=\" INTPTR_FORMAT\n+                                  \", mark=\" INTPTR_FORMAT \", type='%s'\",\n+                                  p2i(obj), obj->mark().value(),\n+                                  obj->klass()->external_name());\n+    }\n+\n+    \/\/ Install the old mark word if nobody else has already done it.\n+    install_displaced_markword_in_object(obj);\n+  }\n+\n+  \/\/ We leave owner == DEFLATER_MARKER and contentions < 0\n+  \/\/ to force any racing threads to retry.\n+  return true;  \/\/ Success, ObjectMonitor has been deflated.\n+}\n+\n@@ -541,2 +665,2 @@\n-  if (_owner != DEFLATER_MARKER) {\n-    ss->print(\"owner=\" INTPTR_FORMAT, p2i(_owner));\n+  if (!owner_is_DEFLATER_MARKER()) {\n+    ss->print(\"owner=\" INTPTR_FORMAT, p2i(owner_raw()));\n@@ -562,1 +686,1 @@\n-    assert(_owner == Self, \"invariant\");\n+    assert(owner_raw() == Self, \"invariant\");\n@@ -595,1 +719,1 @@\n-    assert(_owner == Self, \"invariant\");\n+    assert(owner_raw() == Self, \"invariant\");\n@@ -603,1 +727,1 @@\n-  assert(_owner != Self, \"invariant\");\n+  assert(owner_raw() != Self, \"invariant\");\n@@ -633,1 +757,1 @@\n-      assert(_owner == Self, \"invariant\");\n+      assert(owner_raw() == Self, \"invariant\");\n@@ -685,1 +809,1 @@\n-    assert(_owner != Self, \"invariant\");\n+    assert(owner_raw() != Self, \"invariant\");\n@@ -754,1 +878,1 @@\n-  assert(_owner == Self, \"invariant\");\n+  assert(owner_raw() == Self, \"invariant\");\n@@ -830,1 +954,1 @@\n-    assert(_owner != Self, \"invariant\");\n+    assert(owner_raw() != Self, \"invariant\");\n@@ -889,1 +1013,1 @@\n-  assert(_owner == Self, \"invariant\");\n+  assert(owner_raw() == Self, \"invariant\");\n@@ -903,1 +1027,1 @@\n-  assert(_owner == Self, \"invariant\");\n+  assert(owner_raw() == Self, \"invariant\");\n@@ -1023,1 +1147,1 @@\n-  void* cur = Atomic::load(&_owner);\n+  void* cur = owner_raw();\n@@ -1069,1 +1193,1 @@\n-    assert(THREAD == _owner, \"invariant\");\n+    assert(THREAD == owner_raw(), \"invariant\");\n@@ -1125,1 +1249,1 @@\n-    guarantee(_owner == THREAD, \"invariant\");\n+    guarantee(owner_raw() == THREAD, \"invariant\");\n@@ -1237,1 +1361,1 @@\n-  assert(_owner == Self, \"invariant\");\n+  assert(owner_raw() == Self, \"invariant\");\n@@ -1281,1 +1405,1 @@\n-  void* cur = Atomic::load(&_owner);\n+  void* cur = owner_raw();\n@@ -1290,1 +1414,1 @@\n-  guarantee(Self == _owner, \"complete_exit not owner\");\n+  guarantee(Self == owner_raw(), \"complete_exit not owner\");\n@@ -1294,1 +1418,1 @@\n-  guarantee(_owner != Self, \"invariant\");\n+  guarantee(owner_raw() != Self, \"invariant\");\n@@ -1304,1 +1428,1 @@\n-  guarantee(_owner != Self, \"reenter already owner\");\n+  guarantee(owner_raw() != Self, \"reenter already owner\");\n@@ -1332,1 +1456,1 @@\n-  void* cur = Atomic::load(&_owner);\n+  void* cur = owner_raw();\n@@ -1354,1 +1478,4 @@\n-  event->set_address((uintptr_t)monitor->object_addr());\n+  \/\/ Set an address that is 'unique enough', such that events close in\n+  \/\/ time and with the same address are likely (but not guaranteed) to\n+  \/\/ belong to the same object.\n+  event->set_address((uintptr_t)monitor);\n@@ -1427,1 +1554,1 @@\n-  guarantee(_owner != Self, \"invariant\");\n+  guarantee(owner_raw() != Self, \"invariant\");\n@@ -1542,1 +1669,1 @@\n-    assert(_owner != Self, \"invariant\");\n+    assert(owner_raw() != Self, \"invariant\");\n@@ -1557,1 +1684,1 @@\n-    assert(_owner == Self, \"invariant\");\n+    assert(owner_raw() == Self, \"invariant\");\n@@ -1569,1 +1696,1 @@\n-  assert(_owner == Self, \"invariant\");\n+  assert(owner_raw() == Self, \"invariant\");\n@@ -1798,1 +1925,1 @@\n-  if (NotRunnable(Self, (Thread *) _owner)) {\n+  if (NotRunnable(Self, (Thread *) owner_raw())) {\n@@ -1844,1 +1971,1 @@\n-    Thread * ox = (Thread *) _owner;\n+    Thread * ox = (Thread *) owner_raw();\n@@ -1970,1 +2097,1 @@\n-    return BlockedOn != intptr_t(this) && _owner == ox;\n+    return BlockedOn != intptr_t(this) && owner_raw() == ox;\n@@ -2127,1 +2254,0 @@\n-\/\/   _allocation_state = Old\n@@ -2158,11 +2284,0 @@\n-  st->print(\"  _allocation_state = \");\n-  if (is_free()) {\n-    st->print(\"Free\");\n-  } else if (is_old()) {\n-    st->print(\"Old\");\n-  } else if (is_new()) {\n-    st->print(\"New\");\n-  } else {\n-    st->print(\"unknown=%d\", _allocation_state);\n-  }\n-  st->cr();\n@@ -2174,1 +2289,1 @@\n-  st->print_cr(\"  _owner = \" INTPTR_FORMAT, p2i(_owner));\n+  st->print_cr(\"  _owner = \" INTPTR_FORMAT, p2i(owner_raw()));\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":171,"deletions":56,"binary":false,"changes":227,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+#include \"utilities\/count_trailing_zeros.hpp\"\n@@ -69,0 +70,1 @@\n+#include \"utilities\/powerOfTwo.hpp\"\n@@ -75,1 +77,1 @@\n-volatile unsigned int os::_rand_seed      = 1;\n+volatile unsigned int os::_rand_seed      = 1234567;\n@@ -78,1 +80,1 @@\n-size_t            os::_page_sizes[os::page_sizes_max];\n+os::PageSizes     os::_page_sizes;\n@@ -883,0 +885,54 @@\n+bool os::print_function_and_library_name(outputStream* st,\n+                                         address addr,\n+                                         char* buf, int buflen,\n+                                         bool shorten_paths,\n+                                         bool demangle,\n+                                         bool strip_arguments) {\n+  \/\/ If no scratch buffer given, allocate one here on stack.\n+  \/\/ (used during error handling; its a coin toss, really, if on-stack allocation\n+  \/\/  is worse than (raw) C-heap allocation in that case).\n+  char* p = buf;\n+  if (p == NULL) {\n+    p = (char*)::alloca(O_BUFLEN);\n+    buflen = O_BUFLEN;\n+  }\n+  int offset = 0;\n+  const bool have_function_name = dll_address_to_function_name(addr, p, buflen,\n+                                                               &offset, demangle);\n+  if (have_function_name) {\n+    \/\/ Print function name, optionally demangled\n+    if (demangle && strip_arguments) {\n+      char* args_start = strchr(p, '(');\n+      if (args_start != NULL) {\n+        *args_start = '\\0';\n+      }\n+    }\n+    \/\/ Print offset. Omit printing if offset is zero, which makes the output\n+    \/\/ more readable if we print function pointers.\n+    if (offset == 0) {\n+      st->print(\"%s\", p);\n+    } else {\n+      st->print(\"%s+%d\", p, offset);\n+    }\n+  } else {\n+    st->print(PTR_FORMAT, p2i(addr));\n+  }\n+  offset = 0;\n+\n+  const bool have_library_name = dll_address_to_library_name(addr, p, buflen, &offset);\n+  if (have_library_name) {\n+    \/\/ Cut path parts\n+    if (shorten_paths) {\n+      char* p2 = strrchr(p, os::file_separator()[0]);\n+      if (p2 != NULL) {\n+        p = p2 + 1;\n+      }\n+    }\n+    st->print(\" in %s\", p);\n+    if (!have_function_name) { \/\/ Omit offset if we already printed the function offset\n+      st->print(\"+%d\", offset);\n+    }\n+  }\n+  return have_function_name || have_library_name;\n+}\n+\n@@ -1173,2 +1229,1 @@\n-\/\/ stack is walkable beyond current frame. The check for fp() is not\n-\/\/ necessary on Sparc, but it's harmless.\n+\/\/ stack is walkable beyond current frame.\n@@ -1176,0 +1231,5 @@\n+\n+#ifdef _WINDOWS\n+  return true; \/\/ native stack isn't walkable on windows this way.\n+#endif\n+\n@@ -1389,2 +1449,2 @@\n-    for (size_t i = 0; _page_sizes[i] != 0; ++i) {\n-      const size_t page_size = _page_sizes[i];\n+    for (size_t page_size = page_sizes().largest(); page_size != 0;\n+         page_size = page_sizes().next_smaller(page_size)) {\n@@ -1535,13 +1595,0 @@\n-void os::trace_page_sizes(const char* str, const size_t* page_sizes, int count) {\n-  LogTarget(Info, pagesize) log;\n-  if (log.is_enabled()) {\n-    LogStream out(log);\n-\n-    out.print(\"%s: \", str);\n-    for (int i = 0; i < count; ++i) {\n-      out.print(\" \" SIZE_FORMAT, page_sizes[i]);\n-    }\n-    out.cr();\n-  }\n-}\n-\n@@ -1667,2 +1714,2 @@\n-char* os::attempt_reserve_memory_at(char* addr, size_t bytes) {\n-  char* result = pd_attempt_reserve_memory_at(addr, bytes);\n+char* os::attempt_reserve_memory_at(char* addr, size_t bytes, bool executable) {\n+  char* result = pd_attempt_reserve_memory_at(addr, bytes, executable);\n@@ -1671,0 +1718,3 @@\n+  } else {\n+    log_debug(os)(\"Attempt to reserve memory at \" INTPTR_FORMAT \" for \"\n+                 SIZE_FORMAT \" bytes failed, errno %d\", p2i(addr), bytes, get_last_error());\n@@ -1704,1 +1754,1 @@\n-bool os::uncommit_memory(char* addr, size_t bytes, bool exec) {\n+bool os::uncommit_memory(char* addr, size_t bytes, bool executable) {\n@@ -1708,1 +1758,1 @@\n-    res = pd_uncommit_memory(addr, bytes, exec);\n+    res = pd_uncommit_memory(addr, bytes, executable);\n@@ -1713,1 +1763,1 @@\n-    res = pd_uncommit_memory(addr, bytes, exec);\n+    res = pd_uncommit_memory(addr, bytes, executable);\n@@ -1730,0 +1780,3 @@\n+  if (!res) {\n+    log_info(os)(\"os::release_memory failed (\" PTR_FORMAT \", \" SIZE_FORMAT \")\", p2i(addr), bytes);\n+  }\n@@ -1733,0 +1786,5 @@\n+\/\/ Prints all mappings\n+void os::print_memory_mappings(outputStream* st) {\n+  os::print_memory_mappings(nullptr, (size_t)-1, st);\n+}\n+\n@@ -1853,0 +1911,70 @@\n+\n+\n+\/\/\/\/\/\/ Implementation of PageSizes\n+\n+void os::PageSizes::add(size_t page_size) {\n+  assert(is_power_of_2(page_size), \"page_size must be a power of 2: \" SIZE_FORMAT_HEX, page_size);\n+  _v |= page_size;\n+}\n+\n+bool os::PageSizes::contains(size_t page_size) const {\n+  assert(is_power_of_2(page_size), \"page_size must be a power of 2: \" SIZE_FORMAT_HEX, page_size);\n+  return (_v & page_size) != 0;\n+}\n+\n+size_t os::PageSizes::next_smaller(size_t page_size) const {\n+  assert(is_power_of_2(page_size), \"page_size must be a power of 2: \" SIZE_FORMAT_HEX, page_size);\n+  size_t v2 = _v & (page_size - 1);\n+  if (v2 == 0) {\n+    return 0;\n+  }\n+  return round_down_power_of_2(v2);\n+}\n+\n+size_t os::PageSizes::next_larger(size_t page_size) const {\n+  assert(is_power_of_2(page_size), \"page_size must be a power of 2: \" SIZE_FORMAT_HEX, page_size);\n+  if (page_size == max_power_of_2<size_t>()) { \/\/ Shift by 32\/64 would be UB\n+    return 0;\n+  }\n+  \/\/ Remove current and smaller page sizes\n+  size_t v2 = _v & ~(page_size + (page_size - 1));\n+  if (v2 == 0) {\n+    return 0;\n+  }\n+  return (size_t)1 << count_trailing_zeros(v2);\n+}\n+\n+size_t os::PageSizes::largest() const {\n+  const size_t max = max_power_of_2<size_t>();\n+  if (contains(max)) {\n+    return max;\n+  }\n+  return next_smaller(max);\n+}\n+\n+size_t os::PageSizes::smallest() const {\n+  \/\/ Strictly speaking the set should not contain sizes < os::vm_page_size().\n+  \/\/ But this is not enforced.\n+  return next_larger(1);\n+}\n+\n+void os::PageSizes::print_on(outputStream* st) const {\n+  bool first = true;\n+  for (size_t sz = smallest(); sz != 0; sz = next_larger(sz)) {\n+    if (first) {\n+      first = false;\n+    } else {\n+      st->print_raw(\", \");\n+    }\n+    if (sz < M) {\n+      st->print(SIZE_FORMAT \"k\", sz \/ K);\n+    } else if (sz < G) {\n+      st->print(SIZE_FORMAT \"M\", sz \/ M);\n+    } else {\n+      st->print(SIZE_FORMAT \"G\", sz \/ G);\n+    }\n+  }\n+  if (first) {\n+    st->print(\"empty\");\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":152,"deletions":24,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"jvmtifiles\/jvmti.h\"\n@@ -55,0 +54,2 @@\n+struct jvmtiTimerInfo;\n+\n@@ -107,1 +108,19 @@\n-  enum { page_sizes_max = 9 }; \/\/ Size of _page_sizes array (8 plus a sentinel)\n+\n+  \/\/ A simple value class holding a set of page sizes (similar to sigset_t)\n+  class PageSizes {\n+    size_t _v; \/\/ actually a bitmap.\n+  public:\n+    PageSizes() : _v(0) {}\n+    void add(size_t pagesize);\n+    bool contains(size_t pagesize) const;\n+    \/\/ Given a page size, return the next smaller page size in this set, or 0.\n+    size_t next_smaller(size_t pagesize) const;\n+    \/\/ Given a page size, return the next larger page size in this set, or 0.\n+    size_t next_larger(size_t pagesize) const;\n+    \/\/ Returns the largest page size in this set, or 0 if set is empty.\n+    size_t largest() const;\n+    \/\/ Returns the smallest page size in this set, or 0 if set is empty.\n+    size_t smallest() const;\n+    \/\/ Prints one line of comma separated, human readable page sizes, \"empty\" if empty.\n+    void print_on(outputStream* st) const;\n+  };\n@@ -112,8 +131,1 @@\n- public:\n-  static size_t             _page_sizes[page_sizes_max];\n-\n- private:\n-  static void init_page_sizes(size_t default_page_size) {\n-    _page_sizes[0] = default_page_size;\n-    _page_sizes[1] = 0; \/\/ sentinel\n-  }\n+  static PageSizes          _page_sizes;\n@@ -123,1 +135,1 @@\n-  static char*  pd_attempt_reserve_memory_at(char* addr, size_t bytes);\n+  static char*  pd_attempt_reserve_memory_at(char* addr, size_t bytes, bool executable);\n@@ -135,1 +147,1 @@\n-  static bool   pd_uncommit_memory(char* addr, size_t bytes, bool exec);\n+  static bool   pd_uncommit_memory(char* addr, size_t bytes, bool executable);\n@@ -233,1 +245,1 @@\n-  static bool has_allocatable_memory_limit(julong* limit);\n+  static bool has_allocatable_memory_limit(size_t* limit);\n@@ -281,0 +293,4 @@\n+  \/\/ The set of page sizes which the VM is allowed to use (may be a subset of\n+  \/\/  the page sizes actually available on the platform).\n+  static const PageSizes& page_sizes() { return _page_sizes; }\n+\n@@ -292,4 +308,1 @@\n-  static size_t max_page_size() {\n-    \/\/ The _page_sizes array is sorted in descending order.\n-    return _page_sizes[0];\n-  }\n+  static size_t max_page_size() { return page_sizes().largest(); }\n@@ -325,1 +338,1 @@\n-  static char*  reserve_memory_aligned(size_t size, size_t alignment);\n+  static char*  reserve_memory_aligned(size_t size, size_t alignment, bool executable = false);\n@@ -329,11 +342,1 @@\n-  static char*  attempt_reserve_memory_at(char* addr, size_t bytes);\n-\n-  \/\/ Split a reserved memory region [base, base+size) into two regions [base, base+split) and\n-  \/\/  [base+split, base+size).\n-  \/\/  This may remove the original mapping, so its content may be lost.\n-  \/\/ Both base and split point must be aligned to allocation granularity; split point shall\n-  \/\/  be >0 and <size.\n-  \/\/ Splitting guarantees that the resulting two memory regions can be released independently\n-  \/\/  from each other using os::release_memory(). It also means NMT will track these regions\n-  \/\/  individually, allowing different tags to be set.\n-  static void   split_reserved_memory(char *base, size_t size, size_t split);\n+  static char*  attempt_reserve_memory_at(char* addr, size_t bytes, bool executable = false);\n@@ -351,1 +354,1 @@\n-  static bool   uncommit_memory(char* addr, size_t bytes, bool exec);\n+  static bool   uncommit_memory(char* addr, size_t bytes, bool executable = false);\n@@ -354,0 +357,5 @@\n+  \/\/ A diagnostic function to print memory mappings in the given range.\n+  static void print_memory_mappings(char* addr, size_t bytes, outputStream* st);\n+  \/\/ Prints all mappings\n+  static void print_memory_mappings(outputStream* st);\n+\n@@ -589,0 +597,18 @@\n+  \/\/ Given an address, attempt to locate both the symbol and the library it\n+  \/\/ resides in. If at least one of these steps was successful, prints information\n+  \/\/ and returns true.\n+  \/\/ - if no scratch buffer is given, stack is used\n+  \/\/ - shorten_paths: path is omitted from library name\n+  \/\/ - demangle: function name is demangled\n+  \/\/ - strip_arguments: arguments are stripped (requires demangle=true)\n+  \/\/ On success prints either one of:\n+  \/\/ \"<function name>+<offset> in <library>\"\n+  \/\/ \"<function name>+<offset>\"\n+  \/\/ \"<address> in <library>+<offset>\"\n+  static bool print_function_and_library_name(outputStream* st,\n+                                              address addr,\n+                                              char* buf = NULL, int buflen = 0,\n+                                              bool shorten_paths = true,\n+                                              bool demangle = true,\n+                                              bool strip_arguments = false);\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":56,"deletions":30,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -384,0 +384,8 @@\n+  \/\/ Mark all threads\n+  if (VerifyCrossModifyFence) {\n+    JavaThreadIteratorWithHandle jtiwh;\n+    for (; JavaThread *cur = jtiwh.next(); ) {\n+      cur->set_requires_cross_modify_fence(true);\n+    }\n+  }\n+\n@@ -541,9 +549,6 @@\n-    if (_do_lazy_roots && _subtasks.try_claim_task(SafepointSynchronize::SAFEPOINT_CLEANUP_LAZY_ROOT_PROCESSING)) {\n-      Tracer t(\"lazy partial thread root processing\");\n-      ParallelSPCleanupThreadClosure cl;\n-      Threads::threads_do(&cl);\n-    }\n-\n-    if (_subtasks.try_claim_task(SafepointSynchronize::SAFEPOINT_CLEANUP_DEFLATE_MONITORS)) {\n-      Tracer t(\"deflating idle monitors\");\n-      ObjectSynchronizer::do_safepoint_work();\n+    if (_subtasks.try_claim_task(SafepointSynchronize::SAFEPOINT_CLEANUP_LAZY_ROOT_PROCESSING)) {\n+      if (_do_lazy_roots) {\n+        Tracer t(\"lazy partial thread root processing\");\n+        ParallelSPCleanupThreadClosure cl;\n+        Threads::threads_do(&cl);\n+      }\n@@ -613,0 +618,6 @@\n+\n+  if (log_is_enabled(Debug, monitorinflation)) {\n+    \/\/ The VMThread calls do_final_audit_and_print_stats() which calls\n+    \/\/ audit_and_print_stats() at the Info level at VM exit time.\n+    ObjectSynchronizer::audit_and_print_stats(false \/* on_exit *\/);\n+  }\n@@ -739,23 +750,0 @@\n-  \/\/ Check for pending. async. exceptions or suspends - except if the\n-  \/\/ thread was blocked inside the VM. has_special_runtime_exit_condition()\n-  \/\/ is called last since it grabs a lock and we only want to do that when\n-  \/\/ we must.\n-  \/\/\n-  \/\/ Note: we never deliver an async exception at a polling point as the\n-  \/\/ compiler may not have an exception handler for it. The polling\n-  \/\/ code will notice the async and deoptimize and the exception will\n-  \/\/ be delivered. (Polling at a return point is ok though). Sure is\n-  \/\/ a lot of bother for a deprecated feature...\n-  \/\/\n-  \/\/ We don't deliver an async exception if the thread state is\n-  \/\/ _thread_in_native_trans so JNI functions won't be called with\n-  \/\/ a surprising pending exception. If the thread state is going back to java,\n-  \/\/ async exception is checked in check_special_condition_for_native_trans().\n-\n-  if (state != _thread_blocked_trans &&\n-      state != _thread_in_vm_trans &&\n-      thread->has_special_runtime_exit_condition()) {\n-    thread->handle_special_runtime_exit_condition(\n-      !thread->is_at_poll_safepoint() && (state != _thread_in_native_trans));\n-  }\n-\n@@ -959,6 +947,1 @@\n-    SafepointMechanism::process_if_requested(self);\n-    \/\/ We have to wait if we are here because of a handshake for object deoptimization.\n-    if (self->is_obj_deopt_suspend()) {\n-      self->wait_for_object_deoptimization();\n-    }\n-    self->check_and_handle_async_exceptions();\n+    SafepointMechanism::process_if_requested_with_exit_check(self, true \/* check asyncs *\/);\n@@ -974,1 +957,0 @@\n-    set_at_poll_safepoint(true);\n@@ -979,0 +961,1 @@\n+    set_at_poll_safepoint(true);\n@@ -980,5 +963,6 @@\n-    SafepointMechanism::process_if_requested(self);\n-    \/\/ We have to wait if we are here because of a handshake for object deoptimization.\n-    if (self->is_obj_deopt_suspend()) {\n-      self->wait_for_object_deoptimization();\n-    }\n+    \/\/ We never deliver an async exception at a polling point as the\n+    \/\/ compiler may not have an exception handler for it. The polling\n+    \/\/ code will notice the pending async exception, deoptimize and\n+    \/\/ the exception will be delivered. (Polling at a return point\n+    \/\/ is ok though). Sure is a lot of bother for a deprecated feature...\n+    SafepointMechanism::process_if_requested_with_exit_check(self, false \/* check asyncs *\/);\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":28,"deletions":44,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include \"classfile\/javaClasses.hpp\"\n@@ -72,0 +73,1 @@\n+#include \"runtime\/vm_version.hpp\"\n@@ -153,1 +155,0 @@\n-int SharedRuntime::_nof_removable_exceptions = 0;\n@@ -602,0 +603,22 @@\n+\n+#if INCLUDE_JVMCI\n+  if (EnableJVMCI && UseJVMCICompiler) {\n+    vframeStream vfst(thread, true);\n+    methodHandle method = methodHandle(thread, vfst.method());\n+    int bci = vfst.bci();\n+    MethodData* trap_mdo = method->method_data();\n+    if (trap_mdo != NULL) {\n+      \/\/ Set exception_seen if the exceptional bytecode is an invoke\n+      Bytecode_invoke call = Bytecode_invoke_check(method, bci);\n+      if (call.is_valid()) {\n+        ResourceMark rm(thread);\n+        ProfileData* pdata = trap_mdo->allocate_bci_to_data(bci, NULL);\n+        if (pdata != NULL && pdata->is_BitData()) {\n+          BitData* bit_data = (BitData*) pdata;\n+          bit_data->set_exception_seen();\n+        }\n+      }\n+    }\n+  }\n+#endif\n+\n@@ -1875,2 +1898,1 @@\n-  const bool is_outgoing = method->is_method_handle_intrinsic();\n-  int comp_args_on_stack = java_calling_convention(sig_bt, regs_without_member_name, total_args_passed - 1, is_outgoing);\n+  int comp_args_on_stack = java_calling_convention(sig_bt, regs_without_member_name, total_args_passed - 1);\n@@ -2145,7 +2167,0 @@\n-  if (CountRemovableExceptions) {\n-    if (_nof_removable_exceptions > 0) {\n-      Unimplemented(); \/\/ this counter is not yet incremented\n-      tty->print_cr(\"Removable exceptions: %d\", _nof_removable_exceptions);\n-    }\n-  }\n-\n@@ -2694,1 +2709,1 @@\n-    int comp_args_on_stack = SharedRuntime::java_calling_convention(sig_bt, regs, total_args_passed, false);\n+    int comp_args_on_stack = SharedRuntime::java_calling_convention(sig_bt, regs, total_args_passed);\n@@ -2902,5 +2917,2 @@\n-      \/\/ Now get the compiled-Java layout as input (or output) arguments.\n-      \/\/ NOTE: Stubs for compiled entry points of method handle intrinsics\n-      \/\/ are just trampolines so the argument registers must be outgoing ones.\n-      const bool is_outgoing = method->is_method_handle_intrinsic();\n-      int comp_args_on_stack = SharedRuntime::java_calling_convention(sig_bt, regs, total_args_passed, is_outgoing);\n+      \/\/ Now get the compiled-Java arguments layout.\n+      int comp_args_on_stack = SharedRuntime::java_calling_convention(sig_bt, regs, total_args_passed);\n@@ -2950,1 +2962,1 @@\n-  (void) java_calling_convention(&sig_bt, &regs, 1, true);\n+  (void) java_calling_convention(&sig_bt, &regs, 1);\n@@ -2981,1 +2993,1 @@\n-  comp_args_on_stack = java_calling_convention(sig_bt, regs, cnt, true);\n+  comp_args_on_stack = java_calling_convention(sig_bt, regs, cnt);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":31,"deletions":19,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-#include \"utilities\/vmError.hpp\"\n@@ -138,0 +137,1 @@\n+address StubRoutines::_base64_decodeBlock                  = NULL;\n@@ -270,34 +270,1 @@\n-\n-\/\/ simple test for SafeFetch32\n-static void test_safefetch32() {\n-  if (CanUseSafeFetch32()) {\n-    int dummy = 17;\n-    int* const p_invalid = (int*) VMError::get_segfault_address();\n-    int* const p_valid = &dummy;\n-    int result_invalid = SafeFetch32(p_invalid, 0xABC);\n-    assert(result_invalid == 0xABC, \"SafeFetch32 error\");\n-    int result_valid = SafeFetch32(p_valid, 0xABC);\n-    assert(result_valid == 17, \"SafeFetch32 error\");\n-  }\n-}\n-\n-\/\/ simple test for SafeFetchN\n-static void test_safefetchN() {\n-  if (CanUseSafeFetchN()) {\n-#ifdef _LP64\n-    const intptr_t v1 = UCONST64(0xABCD00000000ABCD);\n-    const intptr_t v2 = UCONST64(0xDEFD00000000DEFD);\n-#else\n-    const intptr_t v1 = 0xABCDABCD;\n-    const intptr_t v2 = 0xDEFDDEFD;\n-#endif\n-    intptr_t dummy = v1;\n-    intptr_t* const p_invalid = (intptr_t*) VMError::get_segfault_address();\n-    intptr_t* const p_valid = &dummy;\n-    intptr_t result_invalid = SafeFetchN(p_invalid, v2);\n-    assert(result_invalid == v2, \"SafeFetchN error\");\n-    intptr_t result_valid = SafeFetchN(p_valid, v2);\n-    assert(result_valid == v1, \"SafeFetchN error\");\n-  }\n-}\n-#endif\n+#endif \/\/ ASSERT\n@@ -397,7 +364,0 @@\n-  \/\/ test safefetch routines\n-  \/\/ Not on Windows 32bit until 8074860 is fixed\n-#if ! (defined(_WIN32) && defined(_M_IX86))\n-  test_safefetch32();\n-  test_safefetchN();\n-#endif\n-\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":2,"deletions":42,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -219,0 +219,1 @@\n+  static address _base64_decodeBlock;\n@@ -401,0 +402,1 @@\n+  static address base64_decodeBlock()    { return _base64_decodeBlock; }\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"classfile\/javaThreadStatus.hpp\"\n@@ -40,0 +41,1 @@\n+#include \"gc\/shared\/gcVMOperations.hpp\"\n@@ -42,0 +44,1 @@\n+#include \"gc\/shared\/tlab_globals.hpp\"\n@@ -59,0 +62,1 @@\n+#include \"oops\/klass.inline.hpp\"\n@@ -61,0 +65,1 @@\n+#include \"oops\/oopHandle.inline.hpp\"\n@@ -84,0 +89,1 @@\n+#include \"runtime\/monitorDeflationThread.hpp\"\n@@ -265,5 +271,0 @@\n-  om_free_list = NULL;\n-  om_free_count = 0;\n-  om_free_provision = 32;\n-  om_in_use_list = NULL;\n-  om_in_use_count = 0;\n@@ -297,1 +298,0 @@\n-  _MuxEvent    = ParkEvent::Allocate(this);\n@@ -331,0 +331,6 @@\n+void Thread::initialize_tlab() {\n+  if (UseTLAB) {\n+    tlab().initialize();\n+  }\n+}\n+\n@@ -449,1 +455,0 @@\n-  ParkEvent::Release(_MuxEvent); _MuxEvent    = NULL;\n@@ -503,10 +508,7 @@\n-  if (!DisableStartThread) {\n-    if (thread->is_Java_thread()) {\n-      \/\/ Initialize the thread state to RUNNABLE before starting this thread.\n-      \/\/ Can not set it after the thread started because we do not know the\n-      \/\/ exact thread state at that time. It could be in MONITOR_WAIT or\n-      \/\/ in SLEEPING or some other state.\n-      java_lang_Thread::set_thread_status(thread->as_Java_thread()->threadObj(),\n-                                          java_lang_Thread::RUNNABLE);\n-    }\n-    os::start_thread(thread);\n+  if (thread->is_Java_thread()) {\n+    \/\/ Initialize the thread state to RUNNABLE before starting this thread.\n+    \/\/ Can not set it after the thread started because we do not know the\n+    \/\/ exact thread state at that time. It could be in MONITOR_WAIT or\n+    \/\/ in SLEEPING or some other state.\n+    java_lang_Thread::set_thread_status(thread->as_Java_thread()->threadObj(),\n+                                        JavaThreadStatus::RUNNABLE);\n@@ -514,0 +516,1 @@\n+  os::start_thread(thread);\n@@ -898,1 +901,1 @@\n-                                      java_lang_Thread::RUNNABLE);\n+                                      JavaThreadStatus::RUNNABLE);\n@@ -1238,3 +1241,1 @@\n-    if (!DisableStartThread) {\n-      os::start_thread(this);\n-    }\n+    os::start_thread(this);\n@@ -1592,0 +1593,3 @@\n+\n+  set_requires_cross_modify_fence(false);\n+\n@@ -1829,1 +1833,1 @@\n-  java_lang_Thread::set_thread_status(threadObj(), java_lang_Thread::TERMINATED);\n+  java_lang_Thread::set_thread_status(threadObj(), JavaThreadStatus::TERMINATED);\n@@ -1862,6 +1866,0 @@\n-  \/\/ FIXIT: This code should be moved into else part, when reliable 1.2\/1.3 check is in place\n-  {\n-    EXCEPTION_MARK;\n-\n-    CLEAR_PENDING_EXCEPTION;\n-  }\n@@ -2419,4 +2417,4 @@\n-  } while (is_external_suspend());\n-  if (state != _thread_in_native) {\n-    SafepointMechanism::process_if_requested(this);\n-  }\n+    if (state != _thread_in_native) {\n+      SafepointMechanism::process_if_requested(this);\n+    }\n+  } while (is_external_suspend());\n@@ -2503,1 +2501,0 @@\n-\n@@ -2506,11 +2503,1 @@\n-  if (thread->is_external_suspend()) {\n-    thread->java_suspend_self_with_safepoint_check();\n-  } else {\n-    SafepointMechanism::process_if_requested(thread);\n-  }\n-\n-  if (thread->is_obj_deopt_suspend()) {\n-    thread->wait_for_object_deoptimization();\n-  }\n-\n-  JFR_ONLY(SUSPEND_THREAD_CONDITIONAL(thread);)\n+  SafepointMechanism::process_if_requested_with_exit_check(thread, false \/* check asyncs *\/);\n@@ -3039,1 +3026,1 @@\n-  PRESERVE_EXCEPTION_MARK;\n+  PreserveExceptionMark pm(this);\n@@ -3586,0 +3573,1 @@\n+  ObjectSynchronizer::initialize();\n@@ -3694,3 +3682,1 @@\n-  if (CleanChunkPoolAsync) {\n-    Chunk::start_chunk_pool_cleaner_task();\n-  }\n+  Chunk::start_chunk_pool_cleaner_task();\n@@ -3703,0 +3689,3 @@\n+  \/\/ Start the monitor deflation thread:\n+  MonitorDeflationThread::initialize();\n+\n@@ -4247,0 +4236,3 @@\n+  \/\/ Increase the ObjectMonitor ceiling for the new thread.\n+  ObjectSynchronizer::inc_in_use_list_ceiling();\n+\n@@ -4255,4 +4247,0 @@\n-\n-  \/\/ Reclaim the ObjectMonitors from the om_in_use_list and om_free_list of the moribund thread.\n-  ObjectSynchronizer::om_flush(p);\n-\n@@ -4263,5 +4251,4 @@\n-    \/\/ We must flush any deferred card marks and other various GC barrier\n-    \/\/ related buffers (e.g. G1 SATB buffer and G1 dirty card queue buffer)\n-    \/\/ before removing a thread from the list of active threads.\n-    \/\/ This must be done after ObjectSynchronizer::om_flush(), as GC barriers\n-    \/\/ are used in om_flush().\n+    \/\/ BarrierSet state must be destroyed after the last thread transition\n+    \/\/ before the thread terminates. Thread transitions result in calls to\n+    \/\/ StackWatermarkSet::on_safepoint(), which performs GC processing,\n+    \/\/ requiring the GC state to be alive.\n@@ -4297,0 +4284,3 @@\n+  \/\/ Reduce the ObjectMonitor ceiling for the exiting thread.\n+  ObjectSynchronizer::dec_in_use_list_ceiling();\n+\n@@ -4606,4 +4596,1 @@\n-\/\/ Internal SpinLock and Mutex\n-\/\/ Based on ParkEvent\n-\n-\/\/ Ad-hoc mutual exclusion primitives: SpinLock and Mux\n+\/\/ Ad-hoc mutual exclusion primitives: SpinLock\n@@ -4614,8 +4601,0 @@\n-\/\/ The mux construct provides a spin-then-block mutual exclusion\n-\/\/ mechanism.\n-\/\/\n-\/\/ Testing has shown that contention on the ListLock guarding gFreeList\n-\/\/ is common.  If we implement ListLock as a simple SpinLock it's common\n-\/\/ for the JVM to devolve to yielding with little progress.  This is true\n-\/\/ despite the fact that the critical sections protected by ListLock are\n-\/\/ extremely short.\n@@ -4674,144 +4653,0 @@\n-\/\/ muxAcquire and muxRelease:\n-\/\/\n-\/\/ *  muxAcquire and muxRelease support a single-word lock-word construct.\n-\/\/    The LSB of the word is set IFF the lock is held.\n-\/\/    The remainder of the word points to the head of a singly-linked list\n-\/\/    of threads blocked on the lock.\n-\/\/\n-\/\/ *  The current implementation of muxAcquire-muxRelease uses its own\n-\/\/    dedicated Thread._MuxEvent instance.  If we're interested in\n-\/\/    minimizing the peak number of extant ParkEvent instances then\n-\/\/    we could eliminate _MuxEvent and \"borrow\" _ParkEvent as long\n-\/\/    as certain invariants were satisfied.  Specifically, care would need\n-\/\/    to be taken with regards to consuming unpark() \"permits\".\n-\/\/    A safe rule of thumb is that a thread would never call muxAcquire()\n-\/\/    if it's enqueued (cxq, EntryList, WaitList, etc) and will subsequently\n-\/\/    park().  Otherwise the _ParkEvent park() operation in muxAcquire() could\n-\/\/    consume an unpark() permit intended for monitorenter, for instance.\n-\/\/    One way around this would be to widen the restricted-range semaphore\n-\/\/    implemented in park().  Another alternative would be to provide\n-\/\/    multiple instances of the PlatformEvent() for each thread.  One\n-\/\/    instance would be dedicated to muxAcquire-muxRelease, for instance.\n-\/\/\n-\/\/ *  Usage:\n-\/\/    -- Only as leaf locks\n-\/\/    -- for short-term locking only as muxAcquire does not perform\n-\/\/       thread state transitions.\n-\/\/\n-\/\/ Alternatives:\n-\/\/ *  We could implement muxAcquire and muxRelease with MCS or CLH locks\n-\/\/    but with parking or spin-then-park instead of pure spinning.\n-\/\/ *  Use Taura-Oyama-Yonenzawa locks.\n-\/\/ *  It's possible to construct a 1-0 lock if we encode the lockword as\n-\/\/    (List,LockByte).  Acquire will CAS the full lockword while Release\n-\/\/    will STB 0 into the LockByte.  The 1-0 scheme admits stranding, so\n-\/\/    acquiring threads use timers (ParkTimed) to detect and recover from\n-\/\/    the stranding window.  Thread\/Node structures must be aligned on 256-byte\n-\/\/    boundaries by using placement-new.\n-\/\/ *  Augment MCS with advisory back-link fields maintained with CAS().\n-\/\/    Pictorially:  LockWord -> T1 <-> T2 <-> T3 <-> ... <-> Tn <-> Owner.\n-\/\/    The validity of the backlinks must be ratified before we trust the value.\n-\/\/    If the backlinks are invalid the exiting thread must back-track through the\n-\/\/    the forward links, which are always trustworthy.\n-\/\/ *  Add a successor indication.  The LockWord is currently encoded as\n-\/\/    (List, LOCKBIT:1).  We could also add a SUCCBIT or an explicit _succ variable\n-\/\/    to provide the usual futile-wakeup optimization.\n-\/\/    See RTStt for details.\n-\/\/\n-\n-\n-const intptr_t LOCKBIT = 1;\n-\n-void Thread::muxAcquire(volatile intptr_t * Lock, const char * LockName) {\n-  intptr_t w = Atomic::cmpxchg(Lock, (intptr_t)0, LOCKBIT);\n-  if (w == 0) return;\n-  if ((w & LOCKBIT) == 0 && Atomic::cmpxchg(Lock, w, w|LOCKBIT) == w) {\n-    return;\n-  }\n-\n-  ParkEvent * const Self = Thread::current()->_MuxEvent;\n-  assert((intptr_t(Self) & LOCKBIT) == 0, \"invariant\");\n-  for (;;) {\n-    int its = (os::is_MP() ? 100 : 0) + 1;\n-\n-    \/\/ Optional spin phase: spin-then-park strategy\n-    while (--its >= 0) {\n-      w = *Lock;\n-      if ((w & LOCKBIT) == 0 && Atomic::cmpxchg(Lock, w, w|LOCKBIT) == w) {\n-        return;\n-      }\n-    }\n-\n-    Self->reset();\n-    Self->OnList = intptr_t(Lock);\n-    \/\/ The following fence() isn't _strictly necessary as the subsequent\n-    \/\/ CAS() both serializes execution and ratifies the fetched *Lock value.\n-    OrderAccess::fence();\n-    for (;;) {\n-      w = *Lock;\n-      if ((w & LOCKBIT) == 0) {\n-        if (Atomic::cmpxchg(Lock, w, w|LOCKBIT) == w) {\n-          Self->OnList = 0;   \/\/ hygiene - allows stronger asserts\n-          return;\n-        }\n-        continue;      \/\/ Interference -- *Lock changed -- Just retry\n-      }\n-      assert(w & LOCKBIT, \"invariant\");\n-      Self->ListNext = (ParkEvent *) (w & ~LOCKBIT);\n-      if (Atomic::cmpxchg(Lock, w, intptr_t(Self)|LOCKBIT) == w) break;\n-    }\n-\n-    while (Self->OnList != 0) {\n-      Self->park();\n-    }\n-  }\n-}\n-\n-\/\/ Release() must extract a successor from the list and then wake that thread.\n-\/\/ It can \"pop\" the front of the list or use a detach-modify-reattach (DMR) scheme\n-\/\/ similar to that used by ParkEvent::Allocate() and ::Release().  DMR-based\n-\/\/ Release() would :\n-\/\/ (A) CAS() or swap() null to *Lock, releasing the lock and detaching the list.\n-\/\/ (B) Extract a successor from the private list \"in-hand\"\n-\/\/ (C) attempt to CAS() the residual back into *Lock over null.\n-\/\/     If there were any newly arrived threads and the CAS() would fail.\n-\/\/     In that case Release() would detach the RATs, re-merge the list in-hand\n-\/\/     with the RATs and repeat as needed.  Alternately, Release() might\n-\/\/     detach and extract a successor, but then pass the residual list to the wakee.\n-\/\/     The wakee would be responsible for reattaching and remerging before it\n-\/\/     competed for the lock.\n-\/\/\n-\/\/ Both \"pop\" and DMR are immune from ABA corruption -- there can be\n-\/\/ multiple concurrent pushers, but only one popper or detacher.\n-\/\/ This implementation pops from the head of the list.  This is unfair,\n-\/\/ but tends to provide excellent throughput as hot threads remain hot.\n-\/\/ (We wake recently run threads first).\n-\/\/\n-\/\/ All paths through muxRelease() will execute a CAS.\n-\/\/ Release consistency -- We depend on the CAS in muxRelease() to provide full\n-\/\/ bidirectional fence\/MEMBAR semantics, ensuring that all prior memory operations\n-\/\/ executed within the critical section are complete and globally visible before the\n-\/\/ store (CAS) to the lock-word that releases the lock becomes globally visible.\n-void Thread::muxRelease(volatile intptr_t * Lock)  {\n-  for (;;) {\n-    const intptr_t w = Atomic::cmpxchg(Lock, LOCKBIT, (intptr_t)0);\n-    assert(w & LOCKBIT, \"invariant\");\n-    if (w == LOCKBIT) return;\n-    ParkEvent * const List = (ParkEvent *) (w & ~LOCKBIT);\n-    assert(List != NULL, \"invariant\");\n-    assert(List->OnList == intptr_t(Lock), \"invariant\");\n-    ParkEvent * const nxt = List->ListNext;\n-    guarantee((intptr_t(nxt) & LOCKBIT) == 0, \"invariant\");\n-\n-    \/\/ The following CAS() releases the lock and pops the head element.\n-    \/\/ The CAS() also ratifies the previously fetched lock-word value.\n-    if (Atomic::cmpxchg(Lock, w, intptr_t(nxt)) != w) {\n-      continue;\n-    }\n-    List->OnList = 0;\n-    OrderAccess::fence();\n-    List->unpark();\n-    return;\n-  }\n-}\n-\n@@ -4826,0 +4661,6 @@\n+\n+#ifndef PRODUCT\n+void JavaThread::verify_cross_modify_fence_failure(JavaThread *thread) {\n+   report_vm_error(__FILE__, __LINE__, \"Cross modify fence failure\", \"%p\", thread);\n+}\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":55,"deletions":214,"binary":false,"changes":269,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-#include \"prims\/jvmtiExport.hpp\"\n@@ -45,1 +44,0 @@\n-#include \"runtime\/stubRoutines.hpp\"\n@@ -66,0 +64,1 @@\n+class JvmtiSampledObjectAllocEventCollector;\n@@ -67,0 +66,1 @@\n+class JvmtiVMObjectAllocEventCollector;\n@@ -73,0 +73,1 @@\n+class BufferBlob;\n@@ -187,0 +188,1 @@\n+  friend class ThreadsListHandleTest;  \/\/ for _nested_threads_hazard_ptr_cnt, _threads_hazard_ptr, _threads_list_ptr access\n@@ -419,8 +421,0 @@\n-  \/\/ Per-thread ObjectMonitor lists:\n- public:\n-  ObjectMonitor* om_free_list;                  \/\/ SLL of free ObjectMonitors\n-  int om_free_count;                            \/\/ # on om_free_list\n-  int om_free_provision;                        \/\/ # to try to allocate next\n-  ObjectMonitor* om_in_use_list;                \/\/ SLL of in-use ObjectMonitors\n-  int om_in_use_count;                          \/\/ # on om_in_use_list\n-\n@@ -488,0 +482,1 @@\n+  virtual bool is_monitor_deflation_thread() const   { return false; }\n@@ -606,5 +601,1 @@\n-  void initialize_tlab() {\n-    if (UseTLAB) {\n-      tlab().initialize();\n-    }\n-  }\n+  void initialize_tlab();\n@@ -836,2 +827,2 @@\n-  ParkEvent * _ParkEvent;                     \/\/ for Object monitors and JVMTI raw monitors\n-  ParkEvent * _MuxEvent;                      \/\/ for low-level muxAcquire-muxRelease\n+  ParkEvent * _ParkEvent;                     \/\/ for Object monitors, JVMTI raw monitors,\n+                                              \/\/ and ObjectSynchronizer::read_stable_mark\n@@ -846,2 +837,1 @@\n-  \/\/ Low-level leaf-lock primitives used to implement synchronization\n-  \/\/ and native monitor-mutex infrastructure.\n+  \/\/ Low-level leaf-lock primitives used to implement synchronization.\n@@ -851,2 +841,0 @@\n-  static void muxAcquire(volatile intptr_t * Lock, const char * Name);\n-  static void muxRelease(volatile intptr_t * Lock);\n@@ -1180,0 +1168,1 @@\n+  NOT_PRODUCT(bool      _requires_cross_modify_fence;) \/\/ State used by VerifyCrossModifyFence\n@@ -1411,0 +1400,2 @@\n+  void set_requires_cross_modify_fence(bool val) PRODUCT_RETURN NOT_PRODUCT({ _requires_cross_modify_fence = val; })\n+\n@@ -1686,0 +1677,1 @@\n+  NOT_PRODUCT(static ByteSize requires_cross_modify_fence_offset()  { return byte_offset_of(JavaThread, _requires_cross_modify_fence); })\n@@ -1975,0 +1967,2 @@\n+\n+  static void verify_cross_modify_fence_failure(JavaThread *thread) PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":16,"deletions":22,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"classfile\/javaClasses.hpp\"\n@@ -45,0 +46,1 @@\n+#include \"runtime\/vm_version.hpp\"\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,3 +37,3 @@\n-    \/\/ (which means this is not a slowdebug build), and we are on 64-bit (except Windows\n-    \/\/ and MacOS-aarch64). This is not necessarily a rule, but what has been obvserved to date.\n-#if (defined(_NMT_NOINLINE_) || defined(_WINDOWS) || !defined(_LP64) || (defined(BSD) && defined (__aarch64__)))\n+    \/\/ (which means this is not a slowdebug build), and we are on 64-bit (except Windows).\n+    \/\/ This is not necessarily a rule, but what has been obvserved to date.\n+#if (defined(_NMT_NOINLINE_) || defined(_WINDOWS) || !defined(_LP64) || defined(PPC64) || (defined(BSD) && defined (__aarch64__)))\n","filename":"src\/hotspot\/share\/utilities\/nativeCallStack.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2017, 2020 SAP SE. All rights reserved.\n@@ -67,15 +68,19 @@\n-bool VMError::_error_reported = false;\n-\n-\/\/ call this when the VM is dying--it might loosen some asserts\n-bool VMError::is_error_reported() { return _error_reported; }\n-\n-\/\/ returns an address which is guaranteed to generate a SIGSEGV on read,\n-\/\/ for test purposes, which is not NULL and contains bits in every word\n-void* VMError::get_segfault_address() {\n-  return (void*)\n-#ifdef _LP64\n-    0xABC0000000000ABCULL;\n-#else\n-    0x00000ABC;\n-#endif\n-}\n+bool              VMError::coredump_status;\n+char              VMError::coredump_message[O_BUFLEN];\n+int               VMError::_current_step;\n+const char*       VMError::_current_step_info;\n+volatile jlong    VMError::_reporting_start_time = -1;\n+volatile bool     VMError::_reporting_did_timeout = false;\n+volatile jlong    VMError::_step_start_time = -1;\n+volatile bool     VMError::_step_did_timeout = false;\n+volatile intptr_t VMError::_first_error_tid = -1;\n+int               VMError::_id;\n+const char*       VMError::_message;\n+char              VMError::_detail_msg[1024];\n+Thread*           VMError::_thread;\n+address           VMError::_pc;\n+void*             VMError::_siginfo;\n+void*             VMError::_context;\n+const char*       VMError::_filename;\n+int               VMError::_lineno;\n+size_t            VMError::_size;\n@@ -84,1 +89,1 @@\n-const char *env_list[] = {\n+static const char* env_list[] = {\n@@ -155,3 +160,0 @@\n-bool VMError::coredump_status;\n-char VMError::coredump_message[O_BUFLEN];\n-\n@@ -343,1 +345,1 @@\n-   st->print_cr(\"# Java VM: %s%s%s (%s%s, %s%s%s%s%s, %s, %s)\",\n+   st->print_cr(\"# Java VM: %s%s%s (%s%s, %s%s%s%s%s%s, %s, %s)\",\n@@ -357,0 +359,1 @@\n+                 UseCompressedClassPointers ? \", compressed class ptrs\" : \"\",\n@@ -362,29 +365,4 @@\n-\/\/ This is the main function to report a fatal error. Only one thread can\n-\/\/ call this function, so we don't need to worry about MT-safety. But it's\n-\/\/ possible that the error handler itself may crash or die on an internal\n-\/\/ error, for example, when the stack\/heap is badly damaged. We must be\n-\/\/ able to handle recursive errors that happen inside error handler.\n-\/\/\n-\/\/ Error reporting is done in several steps. If a crash or internal error\n-\/\/ occurred when reporting an error, the nested signal\/exception handler\n-\/\/ can skip steps that are already (or partially) done. Error reporting will\n-\/\/ continue from the next step. This allows us to retrieve and print\n-\/\/ information that may be unsafe to get after a fatal error. If it happens,\n-\/\/ you may find nested report_and_die() frames when you look at the stack\n-\/\/ in a debugger.\n-\/\/\n-\/\/ In general, a hang in error handler is much worse than a crash or internal\n-\/\/ error, as it's harder to recover from a hang. Deadlock can happen if we\n-\/\/ try to grab a lock that is already owned by current thread, or if the\n-\/\/ owner is blocked forever (e.g. in os::infinite_sleep()). If possible, the\n-\/\/ error handler and all the functions it called should avoid grabbing any\n-\/\/ lock. An important thing to notice is that memory allocation needs a lock.\n-\/\/\n-\/\/ We should avoid using large stack allocated buffers. Many errors happen\n-\/\/ when stack space is already low. Making things even worse is that there\n-\/\/ could be nested report_and_die() calls on stack (see above). Only one\n-\/\/ thread can report error, so large buffers are statically allocated in data\n-\/\/ segment.\n-\n-int          VMError::_current_step;\n-const char*  VMError::_current_step_info;\n+\/\/ Returns true if at least one thread reported a fatal error and fatal error handling is in process.\n+bool VMError::is_error_reported() {\n+  return _first_error_tid != -1;\n+}\n@@ -392,4 +370,4 @@\n-volatile jlong VMError::_reporting_start_time = -1;\n-volatile bool VMError::_reporting_did_timeout = false;\n-volatile jlong VMError::_step_start_time = -1;\n-volatile bool VMError::_step_did_timeout = false;\n+\/\/ Returns true if the current thread reported a fatal error.\n+bool VMError::is_error_reported_in_current_thread() {\n+  return _first_error_tid == os::current_thread_id();\n+}\n@@ -426,0 +404,26 @@\n+\/\/ This is the main function to report a fatal error. Only one thread can\n+\/\/ call this function, so we don't need to worry about MT-safety. But it's\n+\/\/ possible that the error handler itself may crash or die on an internal\n+\/\/ error, for example, when the stack\/heap is badly damaged. We must be\n+\/\/ able to handle recursive errors that happen inside error handler.\n+\/\/\n+\/\/ Error reporting is done in several steps. If a crash or internal error\n+\/\/ occurred when reporting an error, the nested signal\/exception handler\n+\/\/ can skip steps that are already (or partially) done. Error reporting will\n+\/\/ continue from the next step. This allows us to retrieve and print\n+\/\/ information that may be unsafe to get after a fatal error. If it happens,\n+\/\/ you may find nested report_and_die() frames when you look at the stack\n+\/\/ in a debugger.\n+\/\/\n+\/\/ In general, a hang in error handler is much worse than a crash or internal\n+\/\/ error, as it's harder to recover from a hang. Deadlock can happen if we\n+\/\/ try to grab a lock that is already owned by current thread, or if the\n+\/\/ owner is blocked forever (e.g. in os::infinite_sleep()). If possible, the\n+\/\/ error handler and all the functions it called should avoid grabbing any\n+\/\/ lock. An important thing to notice is that memory allocation needs a lock.\n+\/\/\n+\/\/ We should avoid using large stack allocated buffers. Many errors happen\n+\/\/ when stack space is already low. Making things even worse is that there\n+\/\/ could be nested report_and_die() calls on stack (see above). Only one\n+\/\/ thread can report error, so large buffers are statically allocated in data\n+\/\/ segment.\n@@ -448,1 +452,1 @@\n-#ifndef PRODUCT\n+#ifdef ASSERT\n@@ -494,1 +498,1 @@\n-        int* const invalid_pointer = (int*) get_segfault_address();\n+        int* const invalid_pointer = (int*)segfault_address;\n@@ -507,1 +511,1 @@\n-#endif \/\/ PRODUCT\n+#endif \/\/ ASSERT\n@@ -514,0 +518,1 @@\n+       case OOM_MPROTECT_ERROR:\n@@ -517,1 +522,2 @@\n-                                                 \"(mmap) failed to map \");\n+                     (_id == (int)OOM_MMAP_ERROR)   ? \"(mmap) failed to map \" :\n+                                                      \"(mprotect) failed to protect \");\n@@ -656,1 +662,0 @@\n-\n@@ -697,1 +702,0 @@\n-\n@@ -921,5 +925,9 @@\n-       if (UseCompressedClassPointers) {\n-         CDS_ONLY(MetaspaceShared::print_on(st);)\n-         Metaspace::print_compressed_class_space(st);\n-         CompressedKlassPointers::print_mode(st);\n-       }\n+       st->cr();\n+     }\n+\n+  STEP(\"printing compressed klass pointers mode\")\n+\n+     if (_verbose && UseCompressedClassPointers) {\n+       CDS_ONLY(MetaspaceShared::print_on(st);)\n+       Metaspace::print_compressed_class_space(st);\n+       CompressedKlassPointers::print_mode(st);\n@@ -1132,5 +1140,8 @@\n-    if (UseCompressedClassPointers) {\n-      CDS_ONLY(MetaspaceShared::print_on(st);)\n-      Metaspace::print_compressed_class_space(st);\n-      CompressedKlassPointers::print_mode(st);\n-    }\n+    st->cr();\n+  }\n+\n+  \/\/ STEP(\"printing compressed class ptrs mode\")\n+  if (UseCompressedClassPointers) {\n+    CDS_ONLY(MetaspaceShared::print_on(st);)\n+    Metaspace::print_compressed_class_space(st);\n+    CompressedKlassPointers::print_mode(st);\n@@ -1242,2 +1253,0 @@\n-volatile intptr_t VMError::_first_error_tid = -1;\n-\n@@ -1300,11 +1309,0 @@\n-int         VMError::_id;\n-const char* VMError::_message;\n-char        VMError::_detail_msg[1024];\n-Thread*     VMError::_thread;\n-address     VMError::_pc;\n-void*       VMError::_siginfo;\n-void*       VMError::_context;\n-const char* VMError::_filename;\n-int         VMError::_lineno;\n-size_t      VMError::_size;\n-\n@@ -1397,3 +1395,0 @@\n-    \/\/ first time\n-    _error_reported = true;\n-\n@@ -1422,1 +1417,1 @@\n-    reset_signal_handlers();\n+    install_secondary_signal_handler();\n@@ -1739,1 +1734,1 @@\n-#ifndef PRODUCT\n+#ifdef ASSERT\n@@ -1762,1 +1757,1 @@\n-  char* const crash_addr = (char*) VMError::get_segfault_address();\n+  char* const crash_addr = (char*)VMError::segfault_address;\n@@ -1767,13 +1762,2 @@\n-void VMError::test_error_handler() {\n-  controlled_crash(ErrorHandlerTest);\n-}\n-\n-\/\/ how can be one of:\n-\/\/ 1,2 - asserts\n-\/\/ 3,4 - guarantee\n-\/\/ 5-7 - fatal\n-\/\/ 8 - vm_exit_out_of_memory\n-\/\/ 9 - ShouldNotCallThis\n-\/\/ 10 - ShouldNotReachHere\n-\/\/ 11 - Unimplemented\n-\/\/ 12,13 - (not guaranteed) crashes\n+\/\/ 1  - assert\n+\/\/ 2  - guarantee\n@@ -1784,23 +1768,0 @@\n-  if (how == 0) return;\n-\n-  \/\/ If asserts are disabled, use the corresponding guarantee instead.\n-  NOT_DEBUG(if (how <= 2) how += 2);\n-\n-  const char* const str = \"hello\";\n-  const size_t      num = (size_t)os::vm_page_size();\n-  const char* const eol = os::line_separator();\n-  const char* const msg = \"this message should be truncated during formatting\";\n-  char * const dataPtr = NULL;  \/\/ bad data pointer\n-  const void (*funcPtr)(void);  \/\/ bad function pointer\n-\n-#if defined(PPC64) && !defined(ABI_ELFv2)\n-  struct FunctionDescriptor functionDescriptor;\n-\n-  functionDescriptor.set_entry((address) 0xF);\n-  funcPtr = (const void(*)()) &functionDescriptor;\n-#else\n-  funcPtr = (const void(*)()) 0xF;\n-#endif\n-\n-  \/\/ Keep this in sync with test\/hotspot\/jtreg\/runtime\/ErrorHandling\/ErrorHandler.java\n-  \/\/ which tests cases 1 thru 13.\n@@ -1823,24 +1784,4 @@\n-    case  1: vmassert(str == NULL, \"expected null\"); break;\n-    case  2: vmassert(num == 1023 && *str == 'X',\n-                      \"num=\" SIZE_FORMAT \" str=\\\"%s\\\"\", num, str); break;\n-    case  3: guarantee(str == NULL, \"expected null\"); break;\n-    case  4: guarantee(num == 1023 && *str == 'X',\n-                       \"num=\" SIZE_FORMAT \" str=\\\"%s\\\"\", num, str); break;\n-    case  5: fatal(\"expected null\"); break;\n-    case  6: fatal(\"num=\" SIZE_FORMAT \" str=\\\"%s\\\"\", num, str); break;\n-    case  7: fatal(\"%s%s#    %s%s#    %s%s#    %s%s#    %s%s#    \"\n-                   \"%s%s#    %s%s#    %s%s#    %s%s#    %s%s#    \"\n-                   \"%s%s#    %s%s#    %s%s#    %s%s#    %s\",\n-                   msg, eol, msg, eol, msg, eol, msg, eol, msg, eol,\n-                   msg, eol, msg, eol, msg, eol, msg, eol, msg, eol,\n-                   msg, eol, msg, eol, msg, eol, msg, eol, msg); break;\n-    case  8: vm_exit_out_of_memory(num, OOM_MALLOC_ERROR, \"ChunkPool::allocate\"); break;\n-    case  9: ShouldNotCallThis(); break;\n-    case 10: ShouldNotReachHere(); break;\n-    case 11: Unimplemented(); break;\n-    \/\/ There's no guarantee the bad data pointer will crash us\n-    \/\/ so \"break\" out to the ShouldNotReachHere().\n-    case 12: *dataPtr = '\\0'; break;\n-    \/\/ There's no guarantee the bad function pointer will crash us\n-    \/\/ so \"break\" out to the ShouldNotReachHere().\n-    case 13: (*funcPtr)(); break;\n+    case 1: assert(how == 0, \"test assert\"); break;\n+    case 2: guarantee(how == 0, \"test guarantee\"); break;\n+\n+    \/\/ The other cases are unused.\n@@ -1860,11 +1801,3 @@\n-    case 18: {\n-      \/\/ Check for assert when allocating from resource area without a\n-      \/\/ ResourceMark.  There must not be a ResourceMark on the\n-      \/\/ current stack when invoking this test case.\n-      ResourceArea* area = Thread::current()->resource_area();\n-      assert(area->nesting() == 0, \"unexpected ResourceMark\");\n-      area->allocate_bytes(100);\n-      break;\n-    }\n-\n-    default: tty->print_cr(\"ERROR: %d: unexpected test_num value.\", how);\n+    default:\n+      \/\/ If another number is given, give a generic crash.\n+      fatal(\"Crashing with number %d\", how);\n@@ -1872,1 +1805,1 @@\n-  tty->print_cr(\"VMError::controlled_crash: survived intentional crash. Did you suppress the assert?\");\n+  tty->print_cr(\"controlled_crash: survived intentional crash. Did you suppress the assert?\");\n@@ -1875,1 +1808,1 @@\n-#endif \/\/ !PRODUCT\n+#endif \/\/ !ASSERT\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":94,"deletions":161,"binary":false,"changes":255,"status":"modified"},{"patch":"@@ -155,0 +155,1 @@\n+        virtualConstructor.addMapping(\"MonitorDeflationThread\", MonitorDeflationThread.class);\n@@ -163,1 +164,1 @@\n-      JvmtiAgentThread, NotificationThread, and ServiceThread.\n+      JvmtiAgentThread, NotificationThread, MonitorDeflationThread and ServiceThread.\n@@ -194,1 +195,1 @@\n-            \" (expected type JavaThread, CompilerThread, ServiceThread, JvmtiAgentThread or CodeCacheSweeperThread)\", e);\n+            \" (expected type JavaThread, CompilerThread, MonitorDeflationThread, ServiceThread, JvmtiAgentThread or CodeCacheSweeperThread)\", e);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/Threads.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,0 +34,6 @@\n+  const char* current_line_buffer(LogStream& ls) {\n+    return ls._current_line.buffer();\n+  }\n+  void current_line_reset(LogStream& ls) {\n+    ls._current_line.reset();\n+  }\n@@ -83,1 +89,1 @@\n-      const char* const line_buffer = ls._current_line.buffer();\n+      const char* const line_buffer = current_line_buffer(ls);\n@@ -99,1 +105,1 @@\n-  const char* const line_buffer = ls._current_line.buffer();\n+  const char* const line_buffer = current_line_buffer(ls);\n@@ -102,1 +108,1 @@\n-  ls._current_line.reset();\n+  current_line_reset(ls);\n","filename":"test\/hotspot\/gtest\/logging\/test_logStream.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/stubRoutines.inline.hpp\"\n+#include \"runtime\/vmOperations.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/vmError.hpp\"\n+#include \"unittest.hpp\"\n+\n+static const intptr_t pattern = LP64_ONLY(0xABCDABCDABCDABCDULL) NOT_LP64(0xABCDABCD);\n+static intptr_t* invalid_address = (intptr_t*)VMError::segfault_address;\n+\n+TEST_VM(os, safefetch_can_use) {\n+  \/\/ Once VM initialization is through,\n+  \/\/ safefetch should work on every platform.\n+  ASSERT_TRUE(CanUseSafeFetch32());\n+}\n+\n+TEST_VM(os, safefetch_positive) {\n+  intptr_t v = pattern;\n+  intptr_t a = SafeFetchN(&v, 1);\n+  ASSERT_EQ(v, a);\n+}\n+\n+TEST_VM(os, safefetch_negative) {\n+  intptr_t a = SafeFetchN(invalid_address, pattern);\n+  ASSERT_EQ(pattern, a);\n+  a = SafeFetchN(invalid_address, ~pattern);\n+  ASSERT_EQ(~pattern, a);\n+}\n+\n+class VM_TestSafeFetchAtSafePoint : public VM_GTestExecuteAtSafepoint {\n+public:\n+  void doit() {\n+    \/\/ Regression test for JDK-8257828\n+    \/\/ Should not crash.\n+    intptr_t a = SafeFetchN(invalid_address, pattern);\n+    ASSERT_EQ(pattern, a);\n+    a = SafeFetchN(invalid_address, ~pattern);\n+    ASSERT_EQ(~pattern, a);\n+  }\n+};\n+\n+TEST_VM(os, safefetch_negative_at_safepoint) {\n+  VM_TestSafeFetchAtSafePoint op;\n+  ThreadInVMfromNative invm(JavaThread::current());\n+  VMThread::execute(&op);\n+}\n","filename":"test\/hotspot\/gtest\/runtime\/test_safefetch.cpp","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,4 @@\n+\/\/ A work around for GCC math header bug leaving isfinite() undefined,\n+\/\/ see: https:\/\/gcc.gnu.org\/bugzilla\/show_bug.cgi?id=14608\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n@@ -75,1 +79,12 @@\n-#define TEST_VM(category, name) GTEST_TEST(category, CONCAT(name, _vm))\n+#define TEST_VM(category, name)                                     \\\n+  class category ## _  ## name ## _vm : public ::testing::Test {    \\\n+  public:                                                           \\\n+    static void do_test();                                          \\\n+  };                                                                \\\n+                                                                    \\\n+  GTEST_TEST(category, CONCAT(name, _vm)) {                         \\\n+    Thread::WXWriteFromExecSetter wx_write;                         \\\n+    category ## _ ## name ## _vm::do_test();                        \\\n+  }                                                                 \\\n+                                                                    \\\n+  void category ## _ ## name ## _vm::do_test()\n@@ -78,2 +93,20 @@\n-  GTEST_TEST_(test_fixture, name ## _vm, test_fixture,              \\\n-              ::testing::internal::GetTypeId<test_fixture>())\n+  class test_fixture ## _  ## name ## _vm_f : public test_fixture { \\\n+  public:                                                           \\\n+    void SetUp() {                                                  \\\n+      Thread::WXWriteFromExecSetter wx_write;                       \\\n+      test_fixture::SetUp();                                        \\\n+    }                                                               \\\n+  protected:                                                        \\\n+    void do_test();                                                 \\\n+  };                                                                \\\n+                                                                    \\\n+  GTEST_TEST_(test_fixture ## _ ## name,                            \\\n+      name ## _vm,                                                  \\\n+      test_fixture ## _ ## name ## _vm_f,                           \\\n+      ::testing::internal::GetTypeId<                               \\\n+        test_fixture ## _ ## name ## _vm_f>()) {                    \\\n+    Thread::WXWriteFromExecSetter wx_write;                         \\\n+    do_test();                                                      \\\n+  }                                                                 \\\n+                                                                    \\\n+  void test_fixture ## _ ## name ## _vm_f::do_test()\n@@ -85,0 +118,1 @@\n+    Thread::WXWriteFromExecSetter wx_write;                         \\\n@@ -104,0 +138,1 @@\n+    Thread::WXWriteFromExecSetter wx_write;                         \\\n@@ -126,0 +161,1 @@\n+    Thread::WXWriteFromExecSetter wx_write;                         \\\n@@ -134,1 +170,1 @@\n-                \"^assert failed: \" msg);                            \\\n+                \"assert failed: \" msg);                             \\\n","filename":"test\/hotspot\/gtest\/unittest.hpp","additions":41,"deletions":5,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+\n@@ -28,1 +29,0 @@\n-#include <pthread.h>\n@@ -31,2 +31,0 @@\n-#include <sys\/mman.h>\n-\n@@ -35,1 +33,4 @@\n-JavaVM* jvm;\n+#if defined(__APPLE__) && defined(__aarch64__)\n+\n+#include <pthread.h>\n+#include <sys\/mman.h>\n@@ -37,5 +38,1 @@\n-#ifdef __APPLE__\n-#define MACOS_ONLY(x) x\n-#else \/\/ __APPLE__\n-#define MACOS_ONLY(x)\n-#endif\n+JavaVM* jvm;\n@@ -87,1 +84,1 @@\n-      MAP_PRIVATE | MAP_ANONYMOUS MACOS_ONLY(| MAP_JIT), -1, 0);\n+      MAP_PRIVATE | MAP_ANONYMOUS | MAP_JIT, -1, 0);\n@@ -93,1 +90,1 @@\n-  MACOS_ONLY(pthread_jit_write_protect_np(false));\n+  pthread_jit_write_protect_np(false);\n@@ -97,1 +94,1 @@\n-  MACOS_ONLY(pthread_jit_write_protect_np(true));\n+  pthread_jit_write_protect_np(true);\n@@ -116,0 +113,11 @@\n+\n+#else\n+\n+JNIEXPORT void JNICALL\n+Java_TestCodegenAttach_testCodegenAttach\n+(JNIEnv *env, jclass cls) {\n+  printf(\"should not reach here\\n\");\n+  exit(1);\n+}\n+\n+#endif \/\/ __APPLE__ && __aarch64__\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/codegenAttachThread\/libcodegenAttach.c","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"}]}