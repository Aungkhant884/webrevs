{"files":[{"patch":"@@ -168,1 +168,1 @@\n-      DISABLED_WARNINGS=\"unknown-warning-option unused-parameter unused\"\n+      DISABLED_WARNINGS=\"unknown-warning-option unused-parameter unused format-nonliteral\"\n","filename":"make\/autoconf\/flags-cflags.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -91,0 +91,3 @@\n+    ifeq ($(HOTSPOT_TARGET_CPU_ARCH), aarch64)\n+      ADLCFLAGS += -DR18_RESERVED\n+    endif\n","filename":"make\/hotspot\/gensrc\/GensrcAdlc.gmk","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -568,0 +568,1 @@\n+    DISABLED_WARNINGS_clang := deprecated-declarations, \\\n@@ -792,1 +793,2 @@\n-      DISABLED_WARNINGS_clang := incompatible-pointer-types sign-compare, \\\n+      DISABLED_WARNINGS_clang := incompatible-pointer-types sign-compare \\\n+          deprecated-declarations, \\\n","filename":"make\/modules\/java.desktop\/lib\/Awt2dLibraries.gmk","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -117,2 +117,2 @@\n-reg_def R18     ( SOC, SOC, Op_RegI, 18, r18_tls->as_VMReg()        );\n-reg_def R18_H   ( SOC, SOC, Op_RegI, 18, r18_tls->as_VMReg()->next());\n+reg_def R18     ( SOC, SOC, Op_RegI, 18, r18_reserved->as_VMReg()        );\n+reg_def R18_H   ( SOC, SOC, Op_RegI, 18, r18_reserved->as_VMReg()->next());\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2636,1 +2636,1 @@\n-  regs += r18_tls;\n+  regs += r18_reserved;\n@@ -5264,1 +5264,1 @@\n-  RegSet saved_regs = RegSet::range(r0, r1) + lr - dst;\n+  RegSet saved_regs = RegSet::range(r0, r1) + BSD_ONLY(RegSet::range(r2, r17)) + lr - dst;\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -805,0 +805,5 @@\n+#ifdef __APPLE__\n+          \/\/ Less-than word types are stored one after another.\n+          \/\/ The code unable to handle this, bailout.\n+          return -1;\n+#endif\n@@ -827,0 +832,5 @@\n+#ifdef __APPLE__\n+          \/\/ Less-than word types are stored one after another.\n+          \/\/ The code unable to handle this, bailout.\n+          return -1;\n+#endif\n@@ -1361,0 +1371,4 @@\n+  if (out_arg_slots < 0) {\n+    return NULL;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -5533,1 +5533,1 @@\n-      RegSetIterator regs = (RegSet::range(r0, r26) - r18_tls).begin();\n+      RegSetIterator regs = (RegSet::range(r0, r26) - r18_reserved).begin();\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,0 +93,1 @@\n+    CPU_APPLE     = 'a',\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+#include \"runtime\/stubRoutines.inline.hpp\"\n@@ -1979,1 +1980,1 @@\n-bool os::pd_uncommit_memory(char* addr, size_t size) {\n+bool os::pd_uncommit_memory(char* addr, size_t size, bool exec) {\n@@ -2056,1 +2057,1 @@\n-char* os::pd_reserve_memory(size_t bytes) {\n+char* os::pd_reserve_memory(size_t bytes, bool executable) {\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -212,0 +212,2 @@\n+#elif defined(AARCH64)\n+static char cpu_arch[] = \"aarch64\";\n@@ -1695,1 +1697,1 @@\n-#ifdef __OpenBSD__\n+#if defined(__OpenBSD__)\n@@ -1701,0 +1703,4 @@\n+#elif defined(__APPLE__)\n+  if (::mprotect(addr, size, prot) == 0) {\n+    return true;\n+  }\n@@ -1783,2 +1789,2 @@\n-bool os::pd_uncommit_memory(char* addr, size_t size) {\n-#ifdef __OpenBSD__\n+bool os::pd_uncommit_memory(char* addr, size_t size, bool exec) {\n+#if defined(__OpenBSD__)\n@@ -1788,0 +1794,11 @@\n+#elif defined(__APPLE__)\n+  if (exec) {\n+    if (::madvise(addr, size, MADV_FREE) != 0) {\n+      return false;\n+    }\n+    return ::mprotect(addr, size, PROT_NONE) == 0;\n+  } else {\n+    uintptr_t res = (uintptr_t) ::mmap(addr, size, PROT_NONE,\n+        MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0);\n+    return res  != (uintptr_t) MAP_FAILED;\n+  }\n@@ -1802,1 +1819,1 @@\n-  return os::uncommit_memory(addr, size);\n+  return os::uncommit_memory(addr, size, !ExecMem);\n@@ -1808,1 +1825,1 @@\n-static char* anon_mmap(char* requested_addr, size_t bytes) {\n+static char* anon_mmap(char* requested_addr, size_t bytes, bool executable) {\n@@ -1810,1 +1827,6 @@\n-  const int flags = MAP_PRIVATE | MAP_NORESERVE | MAP_ANONYMOUS;\n+  int flags = MAP_PRIVATE | MAP_NORESERVE | MAP_ANONYMOUS;\n+#ifdef __APPLE__\n+  if (executable) {\n+    flags |= MAP_JIT;\n+  }\n+#endif\n@@ -1824,2 +1846,2 @@\n-char* os::pd_reserve_memory(size_t bytes) {\n-  return anon_mmap(NULL \/* addr *\/, bytes);\n+char* os::pd_reserve_memory(size_t bytes, bool executable) {\n+  return anon_mmap(NULL \/* addr *\/, bytes, executable);\n@@ -1935,1 +1957,1 @@\n-  char * addr = anon_mmap(requested_addr, bytes);\n+  char * addr = anon_mmap(requested_addr, bytes, false\/*executable*\/);\n@@ -2232,1 +2254,1 @@\n-#ifdef __APPLE__\n+#if defined(__APPLE__) && defined(__x86_64__)\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":32,"deletions":10,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/stubRoutines.inline.hpp\"\n","filename":"src\/hotspot\/os\/linux\/gc\/z\/zPhysicalMemoryBacking_linux.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3292,1 +3292,1 @@\n-bool os::pd_uncommit_memory(char* addr, size_t size) {\n+bool os::pd_uncommit_memory(char* addr, size_t size, bool exec) {\n@@ -3477,1 +3477,1 @@\n-  return os::uncommit_memory(addr, size);\n+  return os::uncommit_memory(addr, size, !ExecMem);\n@@ -3536,1 +3536,1 @@\n-char* os::pd_reserve_memory(size_t bytes) {\n+char* os::pd_reserve_memory(size_t bytes, bool executable) {\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1263,1 +1263,1 @@\n-                                EXC_MASK_BAD_ACCESS | EXC_MASK_ARITHMETIC,\n+                                EXC_MASK_BAD_ACCESS | EXC_MASK_BAD_INSTRUCTION | EXC_MASK_ARITHMETIC,\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3185,1 +3185,1 @@\n-char* os::pd_reserve_memory(size_t bytes) {\n+char* os::pd_reserve_memory(size_t bytes, bool executable) {\n@@ -3386,1 +3386,1 @@\n-bool os::pd_uncommit_memory(char* addr, size_t bytes) {\n+bool os::pd_uncommit_memory(char* addr, size_t bytes, bool exec) {\n@@ -3405,1 +3405,1 @@\n-  return os::uncommit_memory(addr, size);\n+  return os::uncommit_memory(addr, size, !ExecMem);\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,736 @@\n+\/*\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ no precompiled headers\n+#include \"jvm.h\"\n+#include \"asm\/macroAssembler.hpp\"\n+#include \"classfile\/classLoader.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n+#include \"code\/codeCache.hpp\"\n+#include \"code\/icBuffer.hpp\"\n+#include \"code\/vtableStubs.hpp\"\n+#include \"interpreter\/interpreter.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"os_share_bsd.hpp\"\n+#include \"prims\/jniFastGetField.hpp\"\n+#include \"prims\/jvm_misc.hpp\"\n+#include \"runtime\/arguments.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/java.hpp\"\n+#include \"runtime\/javaCalls.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/osThread.hpp\"\n+#include \"runtime\/safepointMechanism.hpp\"\n+#include \"runtime\/sharedRuntime.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/timer.hpp\"\n+#include \"signals_posix.hpp\"\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/events.hpp\"\n+#include \"utilities\/vmError.hpp\"\n+\n+\/\/ put OS-includes here\n+# include <sys\/types.h>\n+# include <sys\/mman.h>\n+# include <pthread.h>\n+# include <signal.h>\n+# include <errno.h>\n+# include <dlfcn.h>\n+# include <stdlib.h>\n+# include <stdio.h>\n+# include <unistd.h>\n+# include <sys\/resource.h>\n+# include <pthread.h>\n+# include <sys\/stat.h>\n+# include <sys\/time.h>\n+# include <sys\/utsname.h>\n+# include <sys\/socket.h>\n+# include <sys\/wait.h>\n+# include <pwd.h>\n+# include <poll.h>\n+#ifndef __OpenBSD__\n+# include <ucontext.h>\n+#endif\n+\n+#if !defined(__APPLE__) && !defined(__NetBSD__)\n+# include <pthread_np.h>\n+#endif\n+\n+\/\/ needed by current_stack_region() workaround for Mavericks\n+#if defined(__APPLE__)\n+# include <errno.h>\n+# include <sys\/types.h>\n+# include <sys\/sysctl.h>\n+# define DEFAULT_MAIN_THREAD_STACK_PAGES 2048\n+# define OS_X_10_9_0_KERNEL_MAJOR_VERSION 13\n+#endif\n+\n+#define SPELL_REG_SP \"sp\"\n+#define SPELL_REG_FP \"fp\"\n+\n+#ifdef __APPLE__\n+\/\/ see darwin-xnu\/osfmk\/mach\/arm\/_structs.h\n+\n+# if __DARWIN_UNIX03 && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)\n+  \/\/ 10.5 UNIX03 member name prefixes\n+  #define DU3_PREFIX(s, m) __ ## s.__ ## m\n+# else\n+  #define DU3_PREFIX(s, m) s ## . ## m\n+# endif\n+#endif\n+\n+#define context_x    uc_mcontext->DU3_PREFIX(ss,x)\n+#define context_fp   uc_mcontext->DU3_PREFIX(ss,fp)\n+#define context_lr   uc_mcontext->DU3_PREFIX(ss,lr)\n+#define context_sp   uc_mcontext->DU3_PREFIX(ss,sp)\n+#define context_pc   uc_mcontext->DU3_PREFIX(ss,pc)\n+#define context_cpsr uc_mcontext->DU3_PREFIX(ss,cpsr)\n+#define context_esr  uc_mcontext->DU3_PREFIX(es,esr)\n+\n+address os::current_stack_pointer() {\n+#if defined(__clang__) || defined(__llvm__)\n+  void *sp;\n+  __asm__(\"mov %0, \" SPELL_REG_SP : \"=r\"(sp));\n+  return (address) sp;\n+#else\n+  register void *sp __asm__ (SPELL_REG_SP);\n+  return (address) sp;\n+#endif\n+}\n+\n+char* os::non_memory_address_word() {\n+  \/\/ Must never look like an address returned by reserve_memory,\n+  \/\/ even in its subfields (as defined by the CPU immediate fields,\n+  \/\/ if the CPU splits constants across multiple instructions).\n+\n+  \/\/ the return value used in computation of Universe::non_oop_word(), which\n+  \/\/ is loaded by cpu\/aarch64 by MacroAssembler::movptr(Register, uintptr_t)\n+  return (char*) 0xffffffffffff;\n+}\n+\n+address os::Bsd::ucontext_get_pc(const ucontext_t * uc) {\n+  return (address)uc->context_pc;\n+}\n+\n+void os::Bsd::ucontext_set_pc(ucontext_t * uc, address pc) {\n+  uc->context_pc = (intptr_t)pc ;\n+}\n+\n+intptr_t* os::Bsd::ucontext_get_sp(const ucontext_t * uc) {\n+  return (intptr_t*)uc->context_sp;\n+}\n+\n+intptr_t* os::Bsd::ucontext_get_fp(const ucontext_t * uc) {\n+  return (intptr_t*)uc->context_fp;\n+}\n+\n+address os::fetch_frame_from_context(const void* ucVoid,\n+                    intptr_t** ret_sp, intptr_t** ret_fp) {\n+\n+  address epc;\n+  const ucontext_t* uc = (const ucontext_t*)ucVoid;\n+\n+  if (uc != NULL) {\n+    epc = os::Bsd::ucontext_get_pc(uc);\n+    if (ret_sp) *ret_sp = os::Bsd::ucontext_get_sp(uc);\n+    if (ret_fp) *ret_fp = os::Bsd::ucontext_get_fp(uc);\n+  } else {\n+    epc = NULL;\n+    if (ret_sp) *ret_sp = (intptr_t *)NULL;\n+    if (ret_fp) *ret_fp = (intptr_t *)NULL;\n+  }\n+\n+  return epc;\n+}\n+\n+frame os::fetch_frame_from_context(const void* ucVoid) {\n+  intptr_t* sp;\n+  intptr_t* fp;\n+  address epc = fetch_frame_from_context(ucVoid, &sp, &fp);\n+  return frame(sp, fp, epc);\n+}\n+\n+frame os::fetch_compiled_frame_from_context(const void* ucVoid) {\n+  const ucontext_t* uc = (const ucontext_t*)ucVoid;\n+  \/\/ In compiled code, the stack banging is performed before LR\n+  \/\/ has been saved in the frame.  LR is live, and SP and FP\n+  \/\/ belong to the caller.\n+  intptr_t* fp = os::Bsd::ucontext_get_fp(uc);\n+  intptr_t* sp = os::Bsd::ucontext_get_sp(uc);\n+  address pc = (address)(uc->context_lr\n+                         - NativeInstruction::instruction_size);\n+  return frame(sp, fp, pc);\n+}\n+\n+\/\/ By default, gcc always saves frame pointer rfp on this stack. This\n+\/\/ may get turned off by -fomit-frame-pointer.\n+frame os::get_sender_for_C_frame(frame* fr) {\n+  return frame(fr->link(), fr->link(), fr->sender_pc());\n+}\n+\n+NOINLINE frame os::current_frame() {\n+  intptr_t *fp = *(intptr_t **)__builtin_frame_address(0);\n+  frame myframe((intptr_t*)os::current_stack_pointer(),\n+                (intptr_t*)fp,\n+                CAST_FROM_FN_PTR(address, os::current_frame));\n+  if (os::is_first_C_frame(&myframe)) {\n+    \/\/ stack is not walkable\n+    return frame();\n+  } else {\n+    return os::get_sender_for_C_frame(&myframe);\n+  }\n+}\n+\n+bool PosixSignals::pd_hotspot_signal_handler(int sig, siginfo_t* info,\n+                                             ucontext_t* uc, JavaThread* thread) {\n+\n+\/*\n+  NOTE: does not seem to work on bsd.\n+  if (info == NULL || info->si_code <= 0 || info->si_code == SI_NOINFO) {\n+    \/\/ can't decode this kind of signal\n+    info = NULL;\n+  } else {\n+    assert(sig == info->si_signo, \"bad siginfo\");\n+  }\n+*\/\n+  \/\/ decide if this trap can be handled by a stub\n+  address stub = NULL;\n+\n+  address pc          = NULL;\n+\n+  \/\/%note os_trap_1\n+  if (info != NULL && uc != NULL && thread != NULL) {\n+    pc = (address) os::Bsd::ucontext_get_pc(uc);\n+\n+    if (StubRoutines::is_safefetch_fault(pc)) {\n+      os::Bsd::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));\n+      return true;\n+    }\n+\n+    \/\/ Handle ALL stack overflow variations here\n+    if (sig == SIGSEGV || sig == SIGBUS) {\n+      address addr = (address) info->si_addr;\n+\n+      \/\/ Make sure the high order byte is sign extended, as it may be masked away by the hardware.\n+      if ((uintptr_t(addr) & (uintptr_t(1) << 55)) != 0) {\n+        addr = address(uintptr_t(addr) | (uintptr_t(0xFF) << 56));\n+      }\n+\n+      \/\/ check if fault address is within thread stack\n+      if (thread->is_in_full_stack(addr)) {\n+        Thread::WXWriteFromExecSetter wx_write;\n+        \/\/ stack overflow\n+        if (os::Posix::handle_stack_overflow(thread, addr, pc, uc, &stub)) {\n+          return true; \/\/ continue\n+        }\n+      }\n+    }\n+\n+    \/\/ We test if stub is already set (by the stack overflow code\n+    \/\/ above) so it is not overwritten by the code that follows. This\n+    \/\/ check is not required on other platforms, because on other\n+    \/\/ platforms we check for SIGSEGV only or SIGBUS only, where here\n+    \/\/ we have to check for both SIGSEGV and SIGBUS.\n+    if (thread->thread_state() == _thread_in_Java && stub == NULL) {\n+      \/\/ Java thread running in Java code => find exception handler if any\n+      \/\/ a fault inside compiled code, the interpreter, or a stub\n+      Thread::WXWriteFromExecSetter wx_write;\n+\n+      \/\/ Handle signal from NativeJump::patch_verified_entry().\n+      if ((sig == SIGILL)\n+          && nativeInstruction_at(pc)->is_sigill_zombie_not_entrant()) {\n+        if (TraceTraps) {\n+          tty->print_cr(\"trap: zombie_not_entrant\");\n+        }\n+        stub = SharedRuntime::get_handle_wrong_method_stub();\n+      } else if ((sig == SIGSEGV || sig == SIGBUS) && SafepointMechanism::is_poll_address((address)info->si_addr)) {\n+        stub = SharedRuntime::get_poll_stub(pc);\n+#if defined(__APPLE__)\n+      \/\/ 32-bit Darwin reports a SIGBUS for nearly all memory access exceptions.\n+      \/\/ 64-bit Darwin may also use a SIGBUS (seen with compressed oops).\n+      \/\/ Catching SIGBUS here prevents the implicit SIGBUS NULL check below from\n+      \/\/ being called, so only do so if the implicit NULL check is not necessary.\n+      } else if (sig == SIGBUS && !MacroAssembler::uses_implicit_null_check(info->si_addr)) {\n+#else\n+      } else if (sig == SIGBUS \/* && info->si_code == BUS_OBJERR *\/) {\n+#endif\n+        \/\/ BugId 4454115: A read from a MappedByteBuffer can fault\n+        \/\/ here if the underlying file has been truncated.\n+        \/\/ Do not crash the VM in such a case.\n+        CodeBlob* cb = CodeCache::find_blob_unsafe(pc);\n+        CompiledMethod* nm = (cb != NULL) ? cb->as_compiled_method_or_null() : NULL;\n+        bool is_unsafe_arraycopy = (thread->doing_unsafe_access() && UnsafeCopyMemory::contains_pc(pc));\n+        if ((nm != NULL && nm->has_unsafe_access()) || is_unsafe_arraycopy) {\n+          address next_pc = pc + NativeCall::instruction_size;\n+          if (is_unsafe_arraycopy) {\n+            next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);\n+          }\n+          stub = SharedRuntime::handle_unsafe_access(thread, next_pc);\n+        }\n+      } else if (sig == SIGILL && nativeInstruction_at(pc)->is_stop()) {\n+        \/\/ Pull a pointer to the error message out of the instruction\n+        \/\/ stream.\n+        const uint64_t *detail_msg_ptr\n+          = (uint64_t*)(pc + NativeInstruction::instruction_size);\n+        const char *detail_msg = (const char *)*detail_msg_ptr;\n+        const char *msg = \"stop\";\n+        if (TraceTraps) {\n+          tty->print_cr(\"trap: %s: (SIGILL)\", msg);\n+        }\n+\n+        return false;\n+      }\n+      else\n+\n+      if (sig == SIGFPE  &&\n+          (info->si_code == FPE_INTDIV || info->si_code == FPE_FLTDIV)) {\n+        stub =\n+          SharedRuntime::\n+          continuation_for_implicit_exception(thread,\n+                                              pc,\n+                                              SharedRuntime::\n+                                              IMPLICIT_DIVIDE_BY_ZERO);\n+#ifdef __APPLE__\n+      } else if (sig == SIGFPE && info->si_code == FPE_NOOP) {\n+        Unimplemented();\n+#endif \/* __APPLE__ *\/\n+\n+      } else if ((sig == SIGSEGV || sig == SIGBUS) &&\n+                 MacroAssembler::uses_implicit_null_check(info->si_addr)) {\n+          \/\/ Determination of interpreter\/vtable stub\/compiled code null exception\n+          stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);\n+      }\n+    } else if ((thread->thread_state() == _thread_in_vm ||\n+                 thread->thread_state() == _thread_in_native) &&\n+               sig == SIGBUS && \/* info->si_code == BUS_OBJERR && *\/\n+               thread->doing_unsafe_access()) {\n+      address next_pc = pc + NativeCall::instruction_size;\n+      if (UnsafeCopyMemory::contains_pc(pc)) {\n+        next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);\n+      }\n+      stub = SharedRuntime::handle_unsafe_access(thread, next_pc);\n+    }\n+\n+    \/\/ jni_fast_Get<Primitive>Field can trap at certain pc's if a GC kicks in\n+    \/\/ and the heap gets shrunk before the field access.\n+    if ((sig == SIGSEGV) || (sig == SIGBUS)) {\n+      address addr = JNI_FastGetField::find_slowcase_pc(pc);\n+      if (addr != (address)-1) {\n+        stub = addr;\n+      }\n+    }\n+  }\n+\n+#if defined(ASSERT) && defined(__APPLE__)\n+  \/\/ Execution protection violation\n+  \/\/\n+  \/\/ This should be kept as the last step in the triage.  We don't\n+  \/\/ have a dedicated trap number for a no-execute fault, so be\n+  \/\/ conservative and allow other handlers the first shot.\n+  if (UnguardOnExecutionViolation > 0 &&\n+      (sig == SIGBUS)) {\n+    static __thread address last_addr = (address) -1;\n+\n+    address addr = (address) info->si_addr;\n+    address pc = os::Bsd::ucontext_get_pc(uc);\n+\n+    if (pc != addr && uc->context_esr == 0x9200004F) { \/\/TODO: figure out what this value means\n+      \/\/ We are faulting trying to write a R-X page\n+      pthread_jit_write_protect_np(false);\n+\n+      log_debug(os)(\"Writing protection violation \"\n+                    \"at \" INTPTR_FORMAT\n+                    \", unprotecting\", p2i(addr));\n+\n+      stub = pc;\n+\n+      last_addr = (address) -1;\n+    } else if (pc == addr && uc->context_esr == 0x8200000f) { \/\/TODO: figure out what this value means\n+      \/\/ We are faulting trying to execute a RW- page\n+\n+      if (addr != last_addr) {\n+        pthread_jit_write_protect_np(true);\n+\n+        log_debug(os)(\"Execution protection violation \"\n+                      \"at \" INTPTR_FORMAT\n+                      \", protecting\", p2i(addr));\n+\n+        stub = pc;\n+\n+        \/\/ Set last_addr so if we fault again at the same address, we don't end\n+        \/\/ up in an endless loop.\n+        last_addr = addr;\n+      }\n+    }\n+  }\n+#endif\n+\n+  if (stub != NULL) {\n+    \/\/ save all thread context in case we need to restore it\n+    if (thread != NULL) thread->set_saved_exception_pc(pc);\n+\n+    os::Bsd::ucontext_set_pc(uc, stub);\n+    return true;\n+  }\n+\n+  return false; \/\/ Mute compiler\n+}\n+\n+void os::Bsd::init_thread_fpu_state(void) {\n+}\n+\n+bool os::is_allocatable(size_t bytes) {\n+  return true;\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ thread stack\n+\n+\/\/ Minimum usable stack sizes required to get to user code. Space for\n+\/\/ HotSpot guard pages is added later.\n+size_t os::Posix::_compiler_thread_min_stack_allowed = 72 * K;\n+size_t os::Posix::_java_thread_min_stack_allowed = 72 * K;\n+size_t os::Posix::_vm_internal_thread_min_stack_allowed = 72 * K;\n+\n+\/\/ return default stack size for thr_type\n+size_t os::Posix::default_stack_size(os::ThreadType thr_type) {\n+  \/\/ default stack size (compiler thread needs larger stack)\n+  size_t s = (thr_type == os::compiler_thread ? 4 * M : 1 * M);\n+  return s;\n+}\n+\n+\n+\/\/ Java thread:\n+\/\/\n+\/\/   Low memory addresses\n+\/\/    +------------------------+\n+\/\/    |                        |\\  Java thread created by VM does not have glibc\n+\/\/    |    glibc guard page    | - guard, attached Java thread usually has\n+\/\/    |                        |\/  1 glibc guard page.\n+\/\/ P1 +------------------------+ Thread::stack_base() - Thread::stack_size()\n+\/\/    |                        |\\\n+\/\/    |  HotSpot Guard Pages   | - red, yellow and reserved pages\n+\/\/    |                        |\/\n+\/\/    +------------------------+ JavaThread::stack_reserved_zone_base()\n+\/\/    |                        |\\\n+\/\/    |      Normal Stack      | -\n+\/\/    |                        |\/\n+\/\/ P2 +------------------------+ Thread::stack_base()\n+\/\/\n+\/\/ Non-Java thread:\n+\/\/\n+\/\/   Low memory addresses\n+\/\/    +------------------------+\n+\/\/    |                        |\\\n+\/\/    |  glibc guard page      | - usually 1 page\n+\/\/    |                        |\/\n+\/\/ P1 +------------------------+ Thread::stack_base() - Thread::stack_size()\n+\/\/    |                        |\\\n+\/\/    |      Normal Stack      | -\n+\/\/    |                        |\/\n+\/\/ P2 +------------------------+ Thread::stack_base()\n+\/\/\n+\/\/ ** P1 (aka bottom) and size ( P2 = P1 - size) are the address and stack size returned from\n+\/\/    pthread_attr_getstack()\n+\n+static void current_stack_region(address * bottom, size_t * size) {\n+#ifdef __APPLE__\n+  pthread_t self = pthread_self();\n+  void *stacktop = pthread_get_stackaddr_np(self);\n+  *size = pthread_get_stacksize_np(self);\n+  \/\/ workaround for OS X 10.9.0 (Mavericks)\n+  \/\/ pthread_get_stacksize_np returns 128 pages even though the actual size is 2048 pages\n+  if (pthread_main_np() == 1) {\n+    \/\/ At least on Mac OS 10.12 we have observed stack sizes not aligned\n+    \/\/ to pages boundaries. This can be provoked by e.g. setrlimit() (ulimit -s xxxx in the\n+    \/\/ shell). Apparently Mac OS actually rounds upwards to next multiple of page size,\n+    \/\/ however, we round downwards here to be on the safe side.\n+    *size = align_down(*size, getpagesize());\n+\n+    if ((*size) < (DEFAULT_MAIN_THREAD_STACK_PAGES * (size_t)getpagesize())) {\n+      char kern_osrelease[256];\n+      size_t kern_osrelease_size = sizeof(kern_osrelease);\n+      int ret = sysctlbyname(\"kern.osrelease\", kern_osrelease, &kern_osrelease_size, NULL, 0);\n+      if (ret == 0) {\n+        \/\/ get the major number, atoi will ignore the minor amd micro portions of the version string\n+        if (atoi(kern_osrelease) >= OS_X_10_9_0_KERNEL_MAJOR_VERSION) {\n+          *size = (DEFAULT_MAIN_THREAD_STACK_PAGES*getpagesize());\n+        }\n+      }\n+    }\n+  }\n+  *bottom = (address) stacktop - *size;\n+#elif defined(__OpenBSD__)\n+  stack_t ss;\n+  int rslt = pthread_stackseg_np(pthread_self(), &ss);\n+\n+  if (rslt != 0)\n+    fatal(\"pthread_stackseg_np failed with error = %d\", rslt);\n+\n+  *bottom = (address)((char *)ss.ss_sp - ss.ss_size);\n+  *size   = ss.ss_size;\n+#else\n+  pthread_attr_t attr;\n+\n+  int rslt = pthread_attr_init(&attr);\n+\n+  \/\/ JVM needs to know exact stack location, abort if it fails\n+  if (rslt != 0)\n+    fatal(\"pthread_attr_init failed with error = %d\", rslt);\n+\n+  rslt = pthread_attr_get_np(pthread_self(), &attr);\n+\n+  if (rslt != 0)\n+    fatal(\"pthread_attr_get_np failed with error = %d\", rslt);\n+\n+  if (pthread_attr_getstackaddr(&attr, (void **)bottom) != 0 ||\n+    pthread_attr_getstacksize(&attr, size) != 0) {\n+    fatal(\"Can not locate current stack attributes!\");\n+  }\n+\n+  pthread_attr_destroy(&attr);\n+#endif\n+  assert(os::current_stack_pointer() >= *bottom &&\n+         os::current_stack_pointer() < *bottom + *size, \"just checking\");\n+}\n+\n+address os::current_stack_base() {\n+  address bottom;\n+  size_t size;\n+  current_stack_region(&bottom, &size);\n+  return (bottom + size);\n+}\n+\n+size_t os::current_stack_size() {\n+  \/\/ stack size includes normal stack and HotSpot guard pages\n+  address bottom;\n+  size_t size;\n+  current_stack_region(&bottom, &size);\n+  return size;\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ helper functions for fatal error handler\n+\n+void os::print_context(outputStream *st, const void *context) {\n+  if (context == NULL) return;\n+\n+  const ucontext_t *uc = (const ucontext_t*)context;\n+  st->print_cr(\"Registers:\");\n+  st->print( \" x0=\" INTPTR_FORMAT, (intptr_t)uc->context_x[ 0]);\n+  st->print(\"  x1=\" INTPTR_FORMAT, (intptr_t)uc->context_x[ 1]);\n+  st->print(\"  x2=\" INTPTR_FORMAT, (intptr_t)uc->context_x[ 2]);\n+  st->print(\"  x3=\" INTPTR_FORMAT, (intptr_t)uc->context_x[ 3]);\n+  st->cr();\n+  st->print( \" x4=\" INTPTR_FORMAT, (intptr_t)uc->context_x[ 4]);\n+  st->print(\"  x5=\" INTPTR_FORMAT, (intptr_t)uc->context_x[ 5]);\n+  st->print(\"  x6=\" INTPTR_FORMAT, (intptr_t)uc->context_x[ 6]);\n+  st->print(\"  x7=\" INTPTR_FORMAT, (intptr_t)uc->context_x[ 7]);\n+  st->cr();\n+  st->print( \" x8=\" INTPTR_FORMAT, (intptr_t)uc->context_x[ 8]);\n+  st->print(\"  x9=\" INTPTR_FORMAT, (intptr_t)uc->context_x[ 9]);\n+  st->print(\" x10=\" INTPTR_FORMAT, (intptr_t)uc->context_x[10]);\n+  st->print(\" x11=\" INTPTR_FORMAT, (intptr_t)uc->context_x[11]);\n+  st->cr();\n+  st->print( \"x12=\" INTPTR_FORMAT, (intptr_t)uc->context_x[12]);\n+  st->print(\" x13=\" INTPTR_FORMAT, (intptr_t)uc->context_x[13]);\n+  st->print(\" x14=\" INTPTR_FORMAT, (intptr_t)uc->context_x[14]);\n+  st->print(\" x15=\" INTPTR_FORMAT, (intptr_t)uc->context_x[15]);\n+  st->cr();\n+  st->print( \"x16=\" INTPTR_FORMAT, (intptr_t)uc->context_x[16]);\n+  st->print(\" x17=\" INTPTR_FORMAT, (intptr_t)uc->context_x[17]);\n+  st->print(\" x18=\" INTPTR_FORMAT, (intptr_t)uc->context_x[18]);\n+  st->print(\" x19=\" INTPTR_FORMAT, (intptr_t)uc->context_x[19]);\n+  st->cr();\n+  st->print( \"x20=\" INTPTR_FORMAT, (intptr_t)uc->context_x[20]);\n+  st->print(\" x21=\" INTPTR_FORMAT, (intptr_t)uc->context_x[21]);\n+  st->print(\" x22=\" INTPTR_FORMAT, (intptr_t)uc->context_x[22]);\n+  st->print(\" x23=\" INTPTR_FORMAT, (intptr_t)uc->context_x[23]);\n+  st->cr();\n+  st->print( \"x24=\" INTPTR_FORMAT, (intptr_t)uc->context_x[24]);\n+  st->print(\" x25=\" INTPTR_FORMAT, (intptr_t)uc->context_x[25]);\n+  st->print(\" x26=\" INTPTR_FORMAT, (intptr_t)uc->context_x[26]);\n+  st->print(\" x27=\" INTPTR_FORMAT, (intptr_t)uc->context_x[27]);\n+  st->cr();\n+  st->print( \"x28=\" INTPTR_FORMAT, (intptr_t)uc->context_x[28]);\n+  st->print(\"  fp=\" INTPTR_FORMAT, (intptr_t)uc->context_fp);\n+  st->print(\"  lr=\" INTPTR_FORMAT, (intptr_t)uc->context_lr);\n+  st->print(\"  sp=\" INTPTR_FORMAT, (intptr_t)uc->context_sp);\n+  st->cr();\n+  st->print(  \"pc=\" INTPTR_FORMAT,  (intptr_t)uc->context_pc);\n+  st->print(\" cpsr=\" INTPTR_FORMAT, (intptr_t)uc->context_cpsr);\n+  st->cr();\n+\n+  intptr_t *sp = (intptr_t *)os::Bsd::ucontext_get_sp(uc);\n+  st->print_cr(\"Top of Stack: (sp=\" INTPTR_FORMAT \")\", (intptr_t)sp);\n+  print_hex_dump(st, (address)sp, (address)(sp + 8*sizeof(intptr_t)), sizeof(intptr_t));\n+  st->cr();\n+\n+  \/\/ Note: it may be unsafe to inspect memory near pc. For example, pc may\n+  \/\/ point to garbage if entry point in an nmethod is corrupted. Leave\n+  \/\/ this at the end, and hope for the best.\n+  address pc = os::Bsd::ucontext_get_pc(uc);\n+  print_instructions(st, pc, 4\/*native instruction size*\/);\n+  st->cr();\n+}\n+\n+void os::print_register_info(outputStream *st, const void *context) {\n+  if (context == NULL) return;\n+\n+  const ucontext_t *uc = (const ucontext_t*)context;\n+\n+  st->print_cr(\"Register to memory mapping:\");\n+  st->cr();\n+\n+  \/\/ this is horrendously verbose but the layout of the registers in the\n+  \/\/ context does not match how we defined our abstract Register set, so\n+  \/\/ we can't just iterate through the gregs area\n+\n+  \/\/ this is only for the \"general purpose\" registers\n+\n+  st->print(\" x0=\"); print_location(st, uc->context_x[ 0]);\n+  st->print(\" x1=\"); print_location(st, uc->context_x[ 1]);\n+  st->print(\" x2=\"); print_location(st, uc->context_x[ 2]);\n+  st->print(\" x3=\"); print_location(st, uc->context_x[ 3]);\n+  st->print(\" x4=\"); print_location(st, uc->context_x[ 4]);\n+  st->print(\" x5=\"); print_location(st, uc->context_x[ 5]);\n+  st->print(\" x6=\"); print_location(st, uc->context_x[ 6]);\n+  st->print(\" x7=\"); print_location(st, uc->context_x[ 7]);\n+  st->print(\" x8=\"); print_location(st, uc->context_x[ 8]);\n+  st->print(\" x9=\"); print_location(st, uc->context_x[ 9]);\n+  st->print(\"x10=\"); print_location(st, uc->context_x[10]);\n+  st->print(\"x11=\"); print_location(st, uc->context_x[11]);\n+  st->print(\"x12=\"); print_location(st, uc->context_x[12]);\n+  st->print(\"x13=\"); print_location(st, uc->context_x[13]);\n+  st->print(\"x14=\"); print_location(st, uc->context_x[14]);\n+  st->print(\"x15=\"); print_location(st, uc->context_x[15]);\n+  st->print(\"x16=\"); print_location(st, uc->context_x[16]);\n+  st->print(\"x17=\"); print_location(st, uc->context_x[17]);\n+  st->print(\"x18=\"); print_location(st, uc->context_x[18]);\n+  st->print(\"x19=\"); print_location(st, uc->context_x[19]);\n+  st->print(\"x20=\"); print_location(st, uc->context_x[20]);\n+  st->print(\"x21=\"); print_location(st, uc->context_x[21]);\n+  st->print(\"x22=\"); print_location(st, uc->context_x[22]);\n+  st->print(\"x23=\"); print_location(st, uc->context_x[23]);\n+  st->print(\"x24=\"); print_location(st, uc->context_x[24]);\n+  st->print(\"x25=\"); print_location(st, uc->context_x[25]);\n+  st->print(\"x26=\"); print_location(st, uc->context_x[26]);\n+  st->print(\"x27=\"); print_location(st, uc->context_x[27]);\n+  st->print(\"x28=\"); print_location(st, uc->context_x[28]);\n+\n+  st->cr();\n+}\n+\n+void os::setup_fpu() {\n+}\n+\n+#ifndef PRODUCT\n+void os::verify_stack_alignment() {\n+  assert(((intptr_t)os::current_stack_pointer() & (StackAlignmentInBytes-1)) == 0, \"incorrect stack alignment\");\n+}\n+#endif\n+\n+int os::extra_bang_size_in_bytes() {\n+  \/\/ AArch64 does not require the additional stack bang.\n+  return 0;\n+}\n+\n+void os::current_thread_enable_wx_impl(WXMode mode) {\n+  pthread_jit_write_protect_np(mode == WXExec);\n+}\n+\n+extern \"C\" {\n+  int SpinPause() {\n+    return 0;\n+  }\n+\n+  void _Copy_conjoint_jshorts_atomic(const jshort* from, jshort* to, size_t count) {\n+    if (from > to) {\n+      const jshort *end = from + count;\n+      while (from < end)\n+        *(to++) = *(from++);\n+    }\n+    else if (from < to) {\n+      const jshort *end = from;\n+      from += count - 1;\n+      to   += count - 1;\n+      while (from >= end)\n+        *(to--) = *(from--);\n+    }\n+  }\n+  void _Copy_conjoint_jints_atomic(const jint* from, jint* to, size_t count) {\n+    if (from > to) {\n+      const jint *end = from + count;\n+      while (from < end)\n+        *(to++) = *(from++);\n+    }\n+    else if (from < to) {\n+      const jint *end = from;\n+      from += count - 1;\n+      to   += count - 1;\n+      while (from >= end)\n+        *(to--) = *(from--);\n+    }\n+  }\n+  void _Copy_conjoint_jlongs_atomic(const jlong* from, jlong* to, size_t count) {\n+    if (from > to) {\n+      const jlong *end = from + count;\n+      while (from < end)\n+        os::atomic_copy64(from++, to++);\n+    }\n+    else if (from < to) {\n+      const jlong *end = from;\n+      from += count - 1;\n+      to   += count - 1;\n+      while (from >= end)\n+        os::atomic_copy64(from--, to--);\n+    }\n+  }\n+\n+  void _Copy_arrayof_conjoint_bytes(const HeapWord* from,\n+                                    HeapWord* to,\n+                                    size_t    count) {\n+    memmove(to, from, count);\n+  }\n+  void _Copy_arrayof_conjoint_jshorts(const HeapWord* from,\n+                                      HeapWord* to,\n+                                      size_t    count) {\n+    memmove(to, from, count * 2);\n+  }\n+  void _Copy_arrayof_conjoint_jints(const HeapWord* from,\n+                                    HeapWord* to,\n+                                    size_t    count) {\n+    memmove(to, from, count * 4);\n+  }\n+  void _Copy_arrayof_conjoint_jlongs(const HeapWord* from,\n+                                     HeapWord* to,\n+                                     size_t    count) {\n+    memmove(to, from, count * 8);\n+  }\n+};\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/os_bsd_aarch64.cpp","additions":736,"deletions":0,"binary":false,"changes":736,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2006, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/vm_version.hpp\"\n+\n+int VM_Version::get_current_sve_vector_length() {\n+  ShouldNotReachHere();\n+  return -1;\n+}\n+\n+int VM_Version::set_and_get_current_sve_vector_length(int length) {\n+  ShouldNotReachHere();\n+  return -1;\n+}\n+\n+void VM_Version::get_os_cpu_info() {\n+  _icache_line_size = _dcache_line_size = 64;\n+\n+  \/\/ Disable DC ZVA\n+  _zva_length = -1;\n+}\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/vm_version_bsd_aarch64.cpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -415,0 +415,1 @@\n+    Thread::WXExecFromWriteSetter wx_exec;\n@@ -443,0 +444,1 @@\n+    Thread::WXExecFromWriteSetter wx_exec;\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1796,0 +1796,1 @@\n+    Thread::WXWriteVerifier wx_write;\n@@ -2092,0 +2093,1 @@\n+    Thread::WXWriteVerifier wx_write;\n@@ -2282,0 +2284,1 @@\n+    Thread::WXWriteVerifier wx_write;\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -220,1 +220,1 @@\n-  os::uncommit_memory(start_addr, pointer_delta(bounded_end_addr(end_page), start_addr, sizeof(char)));\n+  os::uncommit_memory(start_addr, pointer_delta(bounded_end_addr(end_page), start_addr, sizeof(char)), !ExecMem);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1PageBasedVirtualSpace.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1349,1 +1349,1 @@\n-  if (!_aux_bitmap_region_special && !os::uncommit_memory((char*)_aux_bitmap_region.start(), _aux_bitmap_region.byte_size())) {\n+  if (!_aux_bitmap_region_special && !os::uncommit_memory((char*)_aux_bitmap_region.start(), _aux_bitmap_region.byte_size(), !ExecMem)) {\n@@ -2845,1 +2845,1 @@\n-  if (!os::uncommit_memory((char*)_bitmap_region.start() + off, len)) {\n+  if (!os::uncommit_memory((char*)_bitmap_region.start() + off, len, !ExecMem)) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-  const uintptr_t addr = (uintptr_t)os::reserve_memory(size, mtGC);\n+  const uintptr_t addr = (uintptr_t)os::reserve_memory(size, !ExecMem, mtGC);\n","filename":"src\/hotspot\/share\/gc\/z\/zMarkStackAllocator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -932,0 +932,1 @@\n+      Thread::WXWriteVerifier wx_write;\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -126,0 +126,1 @@\n+  Thread::WXWriteFromExecSetter __wx_write;   \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -866,0 +866,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;                              \\\n@@ -1026,0 +1027,1 @@\n+    Thread::WXExecFromWriteSetter wx_exec;\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-  char* addr = os::reserve_memory(size, flags);\n+  char* addr = os::reserve_memory(size, !ExecMem, flags);\n@@ -76,1 +76,1 @@\n-  char* addr = os::reserve_memory(size, flags);\n+  char* addr = os::reserve_memory(size, !ExecMem, flags);\n","filename":"src\/hotspot\/share\/memory\/allocation.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -185,1 +185,1 @@\n-  if (os::uncommit_memory((char*)p, word_size * BytesPerWord) == false) {\n+  if (os::uncommit_memory((char*)p, word_size * BytesPerWord, !ExecMem) == false) {\n","filename":"src\/hotspot\/share\/memory\/metaspace\/virtualSpaceNode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -221,1 +221,5 @@\n-      base = map_or_reserve_memory(size, _fd_for_heap);\n+      if (_executable) {\n+        base = os::reserve_memory(size, ExecMem);\n+      } else {\n+        base = map_or_reserve_memory(size, _fd_for_heap);\n+      }\n@@ -1009,1 +1013,1 @@\n-    if (!os::uncommit_memory(aligned_upper_new_high, upper_needs)) {\n+    if (!os::uncommit_memory(aligned_upper_new_high, upper_needs, _executable)) {\n@@ -1020,1 +1024,1 @@\n-    if (!os::uncommit_memory(aligned_middle_new_high, middle_needs)) {\n+    if (!os::uncommit_memory(aligned_middle_new_high, middle_needs, _executable)) {\n@@ -1031,1 +1035,1 @@\n-    if (!os::uncommit_memory(aligned_lower_new_high, lower_needs)) {\n+    if (!os::uncommit_memory(aligned_lower_new_high, lower_needs, _executable)) {\n","filename":"src\/hotspot\/share\/memory\/virtualspace.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1431,0 +1431,2 @@\n+  Thread::WXWriteFromExecSetter wx_write;\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3584,0 +3584,1 @@\n+    Thread::WXWriteVerifier wx_write;\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -179,0 +179,1 @@\n+    Thread::WXExecVerifier __wx_exec;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+  Thread::WXExecFromWriteSetter _wx_exec;\n@@ -96,0 +97,1 @@\n+    _wx_exec(),\n@@ -105,0 +107,1 @@\n+  Thread::WXExecFromWriteSetter _wx_exec;\n@@ -109,1 +112,1 @@\n-  JvmtiThreadEventTransition(Thread *thread) : _rm(), _hm(thread) {\n+  JvmtiThreadEventTransition(Thread *thread) : _rm(), _hm(thread), _wx_exec() {\n@@ -399,0 +402,1 @@\n+    Thread::WXExecVerifier __wx_exec;\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -85,0 +85,1 @@\n+    Thread::WXExecFromWriteSetter wx_exec;\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1576,0 +1576,1 @@\n+    Thread::WXExecFromWriteSetter wx_exec;\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -402,0 +402,1 @@\n+  Thread::WXWriteVerifier wx_write;\n","filename":"src\/hotspot\/share\/prims\/nativeLookup.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -785,1 +785,1 @@\n-  os::uncommit_memory((char *)(uintptr_t)addr, size);\n+  os::uncommit_memory((char *)(uintptr_t)addr, size, !ExecMem);\n@@ -848,0 +848,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;\n@@ -1236,0 +1237,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;\n@@ -1250,0 +1252,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;\n@@ -1290,0 +1293,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;\n@@ -1311,0 +1315,1 @@\n+    Thread::WXExecFromWriteSetter wx_exec;\n@@ -1320,0 +1325,1 @@\n+    Thread::WXExecFromWriteSetter wx_exec;\n@@ -1329,0 +1335,1 @@\n+    Thread::WXExecFromWriteSetter wx_exec;\n@@ -1338,0 +1345,1 @@\n+    Thread::WXExecFromWriteSetter wx_exec;\n@@ -1347,0 +1355,1 @@\n+    Thread::WXExecFromWriteSetter wx_exec;\n@@ -1356,0 +1365,1 @@\n+    Thread::WXExecFromWriteSetter wx_exec;\n@@ -1365,0 +1375,1 @@\n+    Thread::WXExecFromWriteSetter wx_exec;\n@@ -1374,0 +1385,1 @@\n+    Thread::WXExecFromWriteSetter wx_exec;\n@@ -1383,0 +1395,1 @@\n+    Thread::WXExecFromWriteSetter wx_exec;\n@@ -1432,0 +1445,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;\n@@ -1443,0 +1457,1 @@\n+    Thread::WXWriteFromExecSetter wx_write;\n@@ -1508,0 +1523,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;\n@@ -1580,0 +1596,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;\n@@ -1663,0 +1680,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;\n@@ -1693,0 +1711,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;\n@@ -1913,0 +1932,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;\n@@ -1925,0 +1945,1 @@\n+    Thread::WXExecFromWriteSetter wx_exec;\n@@ -1935,0 +1956,1 @@\n+    Thread::WXExecFromWriteSetter wx_exec;\n@@ -1945,0 +1967,1 @@\n+    Thread::WXExecFromWriteSetter wx_exec;\n@@ -1955,0 +1978,1 @@\n+    Thread::WXExecFromWriteSetter wx_exec;\n@@ -1965,0 +1989,1 @@\n+    Thread::WXExecFromWriteSetter wx_exec;\n@@ -1975,0 +2000,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;\n@@ -2179,0 +2205,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;\n@@ -2210,0 +2237,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;\n@@ -2215,0 +2243,1 @@\n+    Thread::WXExecVerifier wx_exec;\n@@ -2235,0 +2264,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;\n@@ -2256,0 +2286,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":32,"deletions":1,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2456,0 +2456,1 @@\n+  Thread::WXWriteFromExecSetter wx_write;\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2256,1 +2256,1 @@\n-          \"Unguard page and retry on no-execute fault (Win32 only) \"        \\\n+          \"Unguard page and retry on no-execute fault \"                     \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -291,0 +291,1 @@\n+  Thread::WXWriteVerifier _wx_write;\n@@ -292,1 +293,1 @@\n-  ThreadInVMfromJavaNoAsyncException(JavaThread* thread) : ThreadStateTransition(thread) {\n+  ThreadInVMfromJavaNoAsyncException(JavaThread* thread) : ThreadStateTransition(thread), _wx_write() {\n@@ -378,0 +379,1 @@\n+    Thread::WXWriteFromExecSetter __wx_write;                        \\\n@@ -404,0 +406,1 @@\n+    Thread::WXWriteFromExecSetter __wx_write;                        \\\n@@ -413,0 +416,1 @@\n+    Thread::WXWriteFromExecSetter __wx_write;                        \\\n@@ -442,0 +446,1 @@\n+    Thread::WXWriteFromExecSetter __wx_write;                        \\\n@@ -452,0 +457,1 @@\n+    Thread::WXWriteFromExecSetter __wx_write;                        \\\n@@ -466,0 +472,1 @@\n+    Thread::WXWriteFromExecSetter __wx_write;                        \\\n@@ -475,0 +482,1 @@\n+    Thread::WXWriteFromExecSetter __wx_write;                        \\\n@@ -484,0 +492,1 @@\n+    Thread::WXWriteFromExecSetter __wx_write;                        \\\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.inline.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-#include \"runtime\/stubRoutines.hpp\"\n+#include \"runtime\/stubRoutines.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-#include \"runtime\/stubRoutines.hpp\"\n+#include \"runtime\/stubRoutines.inline.hpp\"\n@@ -1655,2 +1655,2 @@\n-char* os::reserve_memory(size_t bytes, MEMFLAGS flags) {\n-  char* result = pd_reserve_memory(bytes);\n+char* os::reserve_memory(size_t bytes, bool executable, MEMFLAGS flags) {\n+  char* result = pd_reserve_memory(bytes, executable);\n@@ -1704,1 +1704,1 @@\n-bool os::uncommit_memory(char* addr, size_t bytes) {\n+bool os::uncommit_memory(char* addr, size_t bytes, bool exec) {\n@@ -1708,1 +1708,1 @@\n-    res = pd_uncommit_memory(addr, bytes);\n+    res = pd_uncommit_memory(addr, bytes, exec);\n@@ -1713,1 +1713,1 @@\n-    res = pd_uncommit_memory(addr, bytes);\n+    res = pd_uncommit_memory(addr, bytes, exec);\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -79,0 +79,5 @@\n+enum WXMode {\n+  WXWrite,\n+  WXExec\n+};\n+\n@@ -116,1 +121,1 @@\n-  static char*  pd_reserve_memory(size_t bytes);\n+  static char*  pd_reserve_memory(size_t bytes, bool executable);\n@@ -130,1 +135,1 @@\n-  static bool   pd_uncommit_memory(char* addr, size_t bytes);\n+  static bool   pd_uncommit_memory(char* addr, size_t bytes, bool exec);\n@@ -317,1 +322,1 @@\n-  static char*  reserve_memory(size_t bytes, MEMFLAGS flags = mtOther);\n+  static char*  reserve_memory(size_t bytes, bool executable = false, MEMFLAGS flags = mtOther);\n@@ -346,1 +351,1 @@\n-  static bool   uncommit_memory(char* addr, size_t bytes);\n+  static bool   uncommit_memory(char* addr, size_t bytes, bool exec);\n@@ -904,0 +909,6 @@\n+  \/\/ If the JVM is running in W^X mode, enable write or execute access to\n+  \/\/ writeable and executable pages. No-op otherwise.\n+  static inline void current_thread_enable_wx(WXMode mode) {\n+    current_thread_enable_wx_impl(mode);\n+  }\n+\n@@ -973,1 +984,0 @@\n-\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -773,0 +773,2 @@\n+  Thread::WXWriteFromExecSetter wx_write;\n+\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -537,0 +537,1 @@\n+  Thread::WXWriteFromExecSetter wx_write;\n@@ -1926,0 +1927,2 @@\n+  Thread::WXWriteFromExecSetter wx_write;\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"runtime\/stubRoutines.hpp\"\n+#include \"runtime\/stubRoutines.inline.hpp\"\n@@ -322,0 +322,2 @@\n+  os::current_thread_enable_wx(WXExec);\n+\n@@ -402,0 +404,2 @@\n+  os::current_thread_enable_wx(WXWrite);\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -489,20 +489,0 @@\n-\/\/ Safefetch allows to load a value from a location that's not known\n-\/\/ to be valid. If the load causes a fault, the error value is returned.\n-inline int SafeFetch32(int* adr, int errValue) {\n-  assert(StubRoutines::SafeFetch32_stub(), \"stub not yet generated\");\n-  return StubRoutines::SafeFetch32_stub()(adr, errValue);\n-}\n-inline intptr_t SafeFetchN(intptr_t* adr, intptr_t errValue) {\n-  assert(StubRoutines::SafeFetchN_stub(), \"stub not yet generated\");\n-  return StubRoutines::SafeFetchN_stub()(adr, errValue);\n-}\n-\n-\n-\/\/ returns true if SafeFetch32 and SafeFetchN can be used safely (stubroutines are already generated)\n-inline bool CanUseSafeFetch32() {\n-  return StubRoutines::SafeFetch32_stub() ? true : false;\n-}\n-\n-inline bool CanUseSafeFetchN() {\n-  return StubRoutines::SafeFetchN_stub() ? true : false;\n-}\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -327,0 +327,2 @@\n+\n+  DEBUG_ONLY(_wx_init = false);\n@@ -384,0 +386,2 @@\n+  this->init_wx();\n+\n@@ -2523,0 +2527,2 @@\n+  Thread::WXWriteFromExecSetter wx_write;\n+\n@@ -3459,0 +3465,2 @@\n+  os::current_thread_enable_wx(WXWrite);\n+\n@@ -3562,0 +3570,1 @@\n+  main_thread->init_wx();\n@@ -3994,0 +4003,1 @@\n+      Thread::WXExecFromWriteSetter wx_exec;\n@@ -4013,0 +4023,1 @@\n+      Thread::WXExecFromWriteSetter wx_exec;\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -853,0 +853,75 @@\n+\n+private:\n+#ifdef ASSERT\n+  bool _wx_init;\n+  WXMode _wx_state;\n+  static inline void verify_wx_init(WXMode state) {\n+    Thread* current = Thread::current();\n+    assert(!current->_wx_init, \"second init\");\n+    current->_wx_init = true;\n+    current->_wx_state = state;\n+  }\n+  static inline void verify_wx_transition(WXMode from, WXMode to) {\n+    Thread* current = Thread::current();\n+    assert(current->_wx_init, \"no init\");\n+    assert(current->_wx_state == from, \"wrong state\");\n+    current->_wx_init = true;\n+    current->_wx_state = to;\n+  }\n+  static inline void verify_wx_state(WXMode now) {\n+    Thread* current = Thread::current();\n+    assert(current->_wx_init, \"no init\");\n+    assert(current->_wx_state == now, \"wrong state\");\n+  }\n+#else\n+  static inline void verify_wx_init(WXMode state) { }\n+  static inline void verify_wx_transition(WXMode from, WXMode to) { }\n+  static inline void verify_wx_state(WXMode now) { }\n+#endif \/\/ ASSERT\n+public:\n+  void init_wx() {\n+    WXMode init_mode = WXWrite;\n+    verify_wx_init(init_mode);\n+    os::current_thread_enable_wx(init_mode);\n+  }\n+  static inline void enable_wx_from_write(WXMode to) {\n+    verify_wx_transition(WXWrite, to);\n+    os::current_thread_enable_wx(to);\n+  }\n+  static inline void enable_wx_from_exec(WXMode to) {\n+    verify_wx_transition(WXExec, to);\n+    os::current_thread_enable_wx(to);\n+  }\n+\n+  class WXWriteFromExecSetter {\n+  public:\n+    WXWriteFromExecSetter() {\n+      enable_wx_from_exec(WXWrite);\n+    }\n+    ~WXWriteFromExecSetter() {\n+      enable_wx_from_write(WXExec);\n+    }\n+  };\n+\n+  class WXExecFromWriteSetter {\n+  public:\n+    WXExecFromWriteSetter() {\n+      enable_wx_from_write(WXExec);\n+    }\n+    ~WXExecFromWriteSetter() {\n+      enable_wx_from_exec(WXWrite);\n+    }\n+  };\n+\n+  class WXWriteVerifier {\n+  public:\n+    WXWriteVerifier() {\n+      verify_wx_state(WXWrite);\n+    }\n+  };\n+  class WXExecVerifier {\n+  public:\n+    WXExecVerifier() {\n+      verify_wx_state(WXExec);\n+    }\n+  };\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":75,"deletions":0,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -1090,0 +1090,1 @@\n+  Thread::WXExecFromWriteSetter wx_exec;\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"runtime\/stubRoutines.inline.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-#define HB_UNTAG(tag)   (uint8_t)(((tag)>>24)&0xFF), (uint8_t)(((tag)>>16)&0xFF), (uint8_t)(((tag)>>8)&0xFF), (uint8_t)((tag)&0xFF)\n+#define HB_UNTAG(tag)   (char)(((tag)>>24)&0xFF), (char)(((tag)>>16)&0xFF), (char)(((tag)>>8)&0xFF), (char)((tag)&0xFF)\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-common.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -193,0 +193,1 @@\n+#if TARGET_OS_OSX && MAC_OS_X_VERSION_MIN_REQUIRED < __MAC_10_10\n@@ -200,0 +201,1 @@\n+#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-coretext.cc","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-    char* base = os::reserve_memory(size, mtThreadStack);\n+    char* base = os::reserve_memory(size, false, mtThreadStack);\n@@ -172,1 +172,1 @@\n-    char* base = os::reserve_memory(size, mtTest);\n+    char* base = os::reserve_memory(size, false, mtTest);\n","filename":"test\/hotspot\/gtest\/runtime\/test_committed_virtualmemory.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}