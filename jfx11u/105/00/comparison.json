{"files":[{"patch":"@@ -85,0 +85,1 @@\n+    bindings\/java\/EventListenerManager.h\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/PlatformJava.cmake","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -112,0 +112,1 @@\n+bindings\/java\/EventListenerManager.cpp\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/SourcesJava.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"EventListenerManager.h\"\n+#include \"JavaEventListener.h\"\n+#include \"DOMWindow.h\"\n+\n+namespace WebCore {\n+\n+EventListenerManager& EventListenerManager::get_instance()\n+{\n+    static NeverDestroyed<EventListenerManager> sharedManager;\n+    return sharedManager;\n+}\n+\n+void EventListenerManager::registerListener(JavaEventListener *listener, const JLObject &listenerObj)\n+{\n+    ListenerJObjectWrapper *temp_ref = new ListenerJObjectWrapper(listenerObj);\n+    std::pair<JavaEventListener*, ListenerJObjectWrapper*> entry{ listener, temp_ref };\n+    listenerJObjectMap.insert(entry);\n+}\n+\n+void EventListenerManager::unregisterListener(JavaEventListener *listener)\n+{\n+     std::map<JavaEventListener*, ListenerJObjectWrapper*>::iterator it;\n+     it = listenerJObjectMap.find(listener);\n+\n+     if (it != listenerJObjectMap.end()) {\n+         if (it->second && it->second->use_count() == 1) {\n+             delete it->second;\n+             it->second = nullptr;\n+             listenerJObjectMap.erase(it); \/\/ remove from list\n+         }\n+         else if (it->second && it->second->use_count() > 1)\n+             it->second->dref();\n+     }\n+}\n+\n+JGObject EventListenerManager::getListenerJObject(JavaEventListener *listener)\n+{\n+    std::map<JavaEventListener*, ListenerJObjectWrapper*>::iterator it;\n+    it = listenerJObjectMap.find(listener);\n+    if (it != listenerJObjectMap.end())\n+        return it->second->getListenerJObject();\n+\n+    return nullptr;\n+}\n+\n+void EventListenerManager::registerDOMWindow(DOMWindow* window, JavaEventListener *listener)\n+{\n+    std::map<JavaEventListener*, ListenerJObjectWrapper*>::iterator it;\n+    it = listenerJObjectMap.find(listener);\n+    if (it != listenerJObjectMap.end())\n+        it->second->ref();\n+\n+    std::pair<JavaEventListener*, DOMWindow*> entry{ listener, window};\n+    listenerDOMWindowMultiMap.insert(entry);\n+}\n+\n+void EventListenerManager::unregisterDOMWindow(DOMWindow* window)\n+{\n+    std::multimap<JavaEventListener*, DOMWindow*>::iterator win_it;\n+    for (win_it = listenerDOMWindowMultiMap.begin(); win_it != listenerDOMWindowMultiMap.end();) {\n+        \/\/ de register associated event listeners with window\n+        \/\/ and remove the entry from the map\n+        if (window == win_it->second) {\n+            unregisterListener(win_it->first);\n+\n+            std::multimap<JavaEventListener*, DOMWindow*>::iterator tmp_it;\n+            tmp_it = win_it;\n+            ++win_it;\n+            listenerDOMWindowMultiMap.erase(tmp_it);\n+        } else {\n+            ++win_it;\n+        }\n+    }\n+}\n+\n+} \/\/ namespace WebCore\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/bindings\/java\/EventListenerManager.cpp","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#pragma once\n+\n+#ifndef EVENT_LISTENER_MANAGER_H\n+#define EVENT_LISTENER_MANAGER_H\n+\n+\n+#include \"config.h\"\n+\n+#include <map>\n+#include <wtf\/NeverDestroyed.h>\n+#include <iterator>\n+#include <wtf\/java\/JavaRef.h>\n+#include <jni.h>\n+\n+namespace WebCore {\n+\n+class DOMWindow;\n+class JavaEventListener;\n+\n+\n+class ListenerJObjectWrapper {\n+    JGObject listenerObj;\n+    unsigned int ref_count = 0;\n+public:\n+    ListenerJObjectWrapper(const JLObject& listenerObj) {\n+        this->listenerObj = listenerObj;\n+    }\n+\n+    ~ListenerJObjectWrapper() {\n+        listenerObj.clear();\n+    }\n+    JGObject getListenerJObject() { return listenerObj; }\n+    void ref() { ++ref_count; }\n+    void dref() { --ref_count; }\n+    unsigned int use_count() { return ref_count;}\n+};\n+\n+class EventListenerManager {\n+    EventListenerManager() = default;\n+    WTF_MAKE_NONCOPYABLE(EventListenerManager);\n+\n+    std::map<JavaEventListener*, ListenerJObjectWrapper*> listenerJObjectMap;\n+    std::multimap<JavaEventListener*, DOMWindow*> listenerDOMWindowMultiMap;\n+\n+    friend class NeverDestroyed<EventListenerManager>;\n+\n+public:\n+    static EventListenerManager& get_instance();\n+\n+    void registerListener(JavaEventListener *listener, const JLObject &listenerJObj);\n+    void unregisterListener(JavaEventListener *listener) ;\n+    JGObject getListenerJObject(JavaEventListener *listener);\n+\n+    void registerDOMWindow(DOMWindow*, JavaEventListener *listener);\n+    void unregisterDOMWindow(DOMWindow*);\n+};\n+\n+} \/\/ namespace WebCore\n+\n+#endif \/\/ EVENT_LISTENER_MANAGER_H\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/bindings\/java\/EventListenerManager.h","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -50,1 +50,1 @@\n-    return jother && isJavaEquals(m_joListener, jother->m_joListener);\n+    return this == jother;\n@@ -68,1 +68,1 @@\n-        m_joListener,\n+        EventListenerManager::get_instance().getListenerJObject(this),\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/bindings\/java\/JavaEventListener.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"EventListenerManager.h\"\n@@ -41,1 +42,0 @@\n-        , m_joListener(listener)\n@@ -44,0 +44,1 @@\n+        EventListenerManager::get_instance().registerListener(this, listener);\n@@ -46,1 +47,1 @@\n-    ~JavaEventListener() override;\n+    virtual ~JavaEventListener() override;\n@@ -50,2 +51,0 @@\n-\n-    JGObject m_joListener;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/bindings\/java\/JavaEventListener.h","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -59,0 +59,5 @@\n+#if PLATFORM(JAVA)\n+#include \"EventListenerManager.h\"\n+#include \"JavaEventListener.h\"\n+#endif\n+\n@@ -152,0 +157,3 @@\n+#if PLATFORM(JAVA)\n+        EventListenerManager::get_instance().unregisterListener(static_cast<JavaEventListener *> (&listener));\n+#endif\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/dom\/EventTarget.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -93,0 +93,5 @@\n+#if PLATFORM(JAVA)\n+#include \"JavaEventListener.h\"\n+#include \"EventListenerManager.h\"\n+#endif\n+\n@@ -2144,0 +2149,4 @@\n+#if PLATFORM(JAVA)\n+        EventListenerManager::get_instance().registerDOMWindow(targetNode->document().domWindow(),\n+           static_cast<JavaEventListener *> (&listener.copyRef().get()));\n+#endif\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/dom\/Node.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -152,0 +152,4 @@\n+#if PLATFORM(JAVA)\n+#include \"EventListenerManager.h\"\n+#endif\n+\n@@ -446,0 +450,4 @@\n+\n+#if PLATFORM(JAVA)\n+    EventListenerManager::get_instance().unregisterDOMWindow(this);\n+#endif\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/page\/DOMWindow.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,983 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.scene.web;\n+\n+import com.sun.javafx.application.PlatformImpl;\n+import java.lang.ref.WeakReference;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javafx.application.Platform;\n+import javafx.beans.value.ChangeListener;\n+import javafx.concurrent.Worker;\n+import javafx.scene.web.WebEngine;\n+import javafx.scene.web.WebView;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.w3c.dom.events.Event;\n+import org.w3c.dom.events.EventListener;\n+import org.w3c.dom.events.EventTarget;\n+import static org.junit.Assert.*;\n+import org.junit.Before;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.NodeList;\n+\n+\/\/ NOTE: We cannot use TestBase since we need multiple WebView instances, and\n+\/\/ greater control over the lifecycle.\n+public class EventListenerLeakTest {\n+\n+    \/\/ List of WeakReferences to EventListener objects to count which are active\n+    \/\/ NOTE: this must be reset for each test\n+    static List<WeakReference<?>> listenerRefs;\n+\n+    \/\/ Save WeakReferences to WebView objects to later check that it is released\n+    \/\/ NOTE: this must be reset for each test\n+    static List<WeakReference<?>> webViewRefs;\n+\n+    \/\/ WebView instances for testing\n+    WebView webView1;\n+    WebView webView2;\n+\n+    \/\/ List of DOM nodes for testing\n+    List<EventTarget> domNodes1;\n+    List<EventTarget> domNodes2;\n+\n+    static class MyListener implements EventListener {\n+\n+        private final AtomicInteger clickCount = new AtomicInteger(0);\n+\n+        private MyListener() {\n+        }\n+\n+        int getClickCount() {\n+            return clickCount.get();\n+        }\n+\n+        static MyListener create() {\n+            MyListener listener = new MyListener();\n+            listenerRefs.add(new WeakReference<>(listener));\n+            return listener;\n+        }\n+\n+        @Override\n+        public void handleEvent(Event evt) {\n+            clickCount.incrementAndGet();\n+        }\n+    }\n+\n+    @BeforeClass\n+    public static void setupOnce() throws Exception {\n+        final CountDownLatch startupLatch = new CountDownLatch(1);\n+\n+        PlatformImpl.startup(() -> {\n+            startupLatch.countDown();\n+        });\n+\n+        assertTrue(\"Timeout waiting for FX runtime to start\",\n+                startupLatch.await(15, TimeUnit.SECONDS));\n+    }\n+\n+    \/**\n+     * Executes a job on FX app thread, and waits until it is complete.\n+     *\n+     * Must be called on the test thread.\n+     *\/\n+    void submit(Runnable job) {\n+        final FutureTask<Void> future = new FutureTask<>(job, null);\n+        Platform.runLater(future);\n+        try {\n+            \/\/ block until job is complete\n+            future.get();\n+        } catch (ExecutionException e) {\n+            Throwable cause = e.getCause();\n+            \/\/ rethrow any assertion errors as is\n+            if (cause instanceof AssertionError) {\n+                throw (AssertionError) e.getCause();\n+            } else if (cause instanceof RuntimeException) {\n+                throw (RuntimeException) cause;\n+            }\n+            \/\/ any other exception should be considered a test error\n+            throw new AssertionError(cause);\n+        } catch (InterruptedException e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n+\n+    \/**\n+     * Loads HTML content from a String. This method does not return until\n+     * loading is finished.\n+     *\n+     * Must be called on the test thread.\n+     *\/\n+    protected void loadContent(final WebView webView, final String content) {\n+        final CountDownLatch loadLatch = new CountDownLatch(1);\n+        Platform.runLater(() -> {\n+            final AtomicReference<ChangeListener<Worker.State>> stateListener\n+                    = new AtomicReference<>();\n+            stateListener.set((obs, oldState, newState) -> {\n+                WebEngine engine = webView.getEngine();\n+                if (newState == Worker.State.SUCCEEDED) {\n+                    \/\/ Remove ChangeListener so we don't hold reference to the EventListener\n+                    engine.getLoadWorker().stateProperty()\n+                            .removeListener(stateListener.get());\n+                    stateListener.set(null);\n+                    loadLatch.countDown();\n+                }\n+            });\n+\n+            webView.getEngine().getLoadWorker().stateProperty()\n+                    .addListener(stateListener.get());\n+            webView.getEngine().loadContent(content, \"text\/html\");\n+        });\n+\n+        try {\n+            assertTrue(\"Timeout waiting for content to load\",\n+                    loadLatch.await(5, TimeUnit.SECONDS));\n+        } catch (InterruptedException ex) {\n+            throw new RuntimeException(\"Unexpected exception\", ex);\n+        }\n+    }\n+\n+    \/**\n+     * Gets the list of DOM anchor nodes.\n+     *\n+     * Must be called on the FX app thread\n+     *\/\n+    private List<EventTarget> getDomNodes(WebView webView) {\n+        final List<EventTarget> nodes = new ArrayList<>();\n+        Document doc = webView.getEngine().getDocument();\n+        assertNotNull(\"Document\", doc);\n+\n+        NodeList nodeList = doc.getElementsByTagName(\"a\");\n+        assertNotNull(\"DOM nodes\", nodeList);\n+        for (int i = 0; i < nodeList.getLength(); i++) {\n+            EventTarget node = (EventTarget) nodeList.item(i);\n+            nodes.add(node);\n+        }\n+        return nodes;\n+    }\n+\n+    \/\/ Must be called on the event thread\n+    void click(WebView webView, int link) {\n+        webView.getEngine().executeScript(\"document.getElementById(\\\"link\"\n+                + link + \"\\\").click()\");\n+    }\n+\n+    void assertNumActive(String msg, List<WeakReference<?>> refs, int exCount)\n+            throws InterruptedException {\n+\n+        int count = -1;\n+\n+        for (int i = 0; i < 10; i++) {\n+            System.gc();\n+\n+            count = (int) refs.stream()\n+                    .filter(e -> e.get() != null)\n+                    .count();\n+\n+            if (exCount == 0 && count == 0) {\n+                break;\n+            }\n+\n+            Thread.sleep(250);\n+        }\n+\n+        assertEquals(\"Active references (\" + msg + \")\", exCount, count);\n+    }\n+\n+    @Before\n+    public void initEach() {\n+        listenerRefs = new ArrayList<>();\n+        webViewRefs = new ArrayList<>();\n+\n+        submit(() -> {\n+            webView1 = new WebView();\n+            webViewRefs.add(new WeakReference<>(webView1));\n+            webView2 = new WebView();\n+            webViewRefs.add(new WeakReference<>(webView2));\n+        });\n+    }\n+\n+\/\/ ---------------------------------------------------------------\n+    private static final String HTML =\n+            \"<body><html>\" +\n+            \"Link: <a id=\\\"link0\\\" href=click>click me 0<\/a><br>\" +\n+            \"Link: <a id=\\\"link1\\\" href=click>click me 1<\/a><br>\" +\n+            \"Link: <a id=\\\"link2\\\" href=click>click me 2<\/a><br>\" +\n+            \"Link: <a id=\\\"link3\\\" href=click>click me 3<\/a><br>\" +\n+            \"<\/html><\/body>\";\n+\n+    private static final String HTML2 =\n+            \"<body><html>\" +\n+            \"Link: <a id=\\\"link0\\\" href=click>click me 0<\/a><br>\" +\n+             \"<\/html><\/body>\";\n+\n+    private static final int NUM_DOM_NODES = 4;\n+\n+    \/**\n+     * Test that the listener remains active without a strong reference to\n+     * either the listener or the DOM node when the WebView is active.\n+     *\/\n+    @Test\n+    public void oneWebViewSingleListenerNoRelease() throws Exception {\n+        webView2 = null; \/\/ unused\n+\n+        \/\/ Load HTML content and get list of DOM nodes\n+        loadContent(webView1, HTML);\n+\n+        final List<MyListener> listeners = new ArrayList<>();\n+        submit(() -> {\n+            domNodes1 = getDomNodes(webView1);\n+            assertEquals(NUM_DOM_NODES, domNodes1.size());\n+\n+            \/\/ Create listener and attach to DOM node 0\n+            listeners.add(MyListener.create());\n+            domNodes1.get(0).addEventListener(\"click\", listeners.get(0), false);\n+\n+            \/\/ Send click event\n+            click(webView1, 0);\n+        });\n+\n+        Thread.sleep(100);\n+\n+        \/\/ Verify that the event is delivered to the listener\n+        assertEquals(\"Click count\", 1, listeners.get(0).getClickCount());\n+\n+        \/\/ Clear strong reference to listener and the DOM nodes\n+        listeners.clear();\n+        domNodes1.clear();\n+\n+        \/\/ Verify that listener is still strongly held since we didn't release it\n+        assertNumActive(\"MyListener\", listenerRefs, 1);\n+    }\n+\n+    \/**\n+     * Test that there is no leak when a listener is explicitly released.\n+     *\/\n+    @Test\n+    public void oneWebViewSingleListenerExplicitRelease() throws Exception {\n+        webView2 = null; \/\/ unused\n+\n+        \/\/ Load HTML content and get list of DOM nodes\n+        loadContent(webView1, HTML);\n+\n+        final List<WeakReference<MyListener>> listeners = new ArrayList<>();\n+        submit(() -> {\n+            domNodes1 = getDomNodes(webView1);\n+            assertEquals(NUM_DOM_NODES, domNodes1.size());\n+\n+            \/\/ Create listener and attach to DOM node 0\n+            MyListener myListener = MyListener.create();\n+            listeners.add(new WeakReference<>(myListener));\n+            domNodes1.get(0).addEventListener(\"click\", listeners.get(0).get(), false);\n+\n+            \/\/ Send clilck event\n+            click(webView1, 0);\n+        });\n+\n+        \/\/ Verify that listener has not been released\n+        assertNumActive(\"MyListener\", listenerRefs, 1);\n+\n+        Thread.sleep(100);\n+\n+        \/\/ Verify that the event is delivered to the listener\n+        assertNotNull(listeners.get(0).get());\n+        assertEquals(\"Click count\", 1, listeners.get(0).get().getClickCount());\n+\n+        submit(() -> {\n+            \/\/ Remove event listener\n+            assertNotNull(listeners.get(0).get());\n+            domNodes1.get(0).removeEventListener(\"click\", listeners.get(0).get(), false);\n+        });\n+\n+        \/\/ Release strong reference to DOM nodes\n+\/\/        listeners.clear();\n+        domNodes1.clear();\n+\n+        \/\/ Verify that listener has been released\n+        assertNumActive(\"MyListener\", listenerRefs, 0);\n+    }\n+\n+    \/**\n+     * Test that there is no leak when a listener is explicitly released.\n+     *\/\n+    @Test\n+    public void oneWebViewMultipleListenersExplicitRelease() throws Exception {\n+        webView2 = null; \/\/ unused\n+\n+        \/\/ Load HTML content and get list of DOM nodes\n+        loadContent(webView1, HTML);\n+\n+        final List<WeakReference<MyListener>> listeners = new ArrayList<>();\n+        submit(() -> {\n+            domNodes1 = getDomNodes(webView1);\n+            assertEquals(NUM_DOM_NODES, domNodes1.size());\n+\n+            \/\/ Create listeners and attach to DOM node 0\n+            MyListener listenerA = MyListener.create();\n+            MyListener listenerB = MyListener.create();\n+\n+            listeners.add(new WeakReference<>(listenerA));\n+            listeners.add(new WeakReference<>(listenerB));\n+            listeners.add(new WeakReference<>(listenerA));\n+\n+            for (int i = 0; i < 3; i++) {\n+                domNodes1.get(i).addEventListener(\"click\", listeners.get(i).get(), false);\n+            }\n+        });\n+\n+        \/\/ Confirm that listeners(0) == listeners(2)\n+        assertSame(listeners.get(0).get(), listeners.get(2).get());\n+\n+        \/\/ Verify that neither listener has been released\n+        assertNumActive(\"MyListener\", listenerRefs, 2);\n+        assertNotNull(listeners.get(0).get());\n+        assertNotNull(listeners.get(1).get());\n+        assertNotNull(listeners.get(2).get());\n+\n+        submit(() -> {\n+            \/\/ Send clilck events\n+            click(webView1, 0);\n+            click(webView1, 1);\n+            click(webView1, 2);\n+        });\n+\n+        \/\/ Verify that the events are delivered to the listeners (0 and 2 are same)\n+        Thread.sleep(100);\n+        assertEquals(\"Click count\", 2, listeners.get(0).get().getClickCount());\n+        assertEquals(\"Click count\", 1, listeners.get(1).get().getClickCount());\n+        assertEquals(\"Click count\", 2, listeners.get(2).get().getClickCount());\n+\n+        submit(() -> {\n+            \/\/ Remove shared event listener from dom node 0\n+            assertNotNull(listeners.get(0).get());\n+            domNodes1.get(0).removeEventListener(\"click\", listeners.get(0).get(), false);\n+            domNodes1.set(0, null);\n+        });\n+\n+        \/\/ Verify that neither listener has been released\n+        assertNumActive(\"MyListener\", listenerRefs, 2);\n+        assertNotNull(listeners.get(0).get());\n+        assertNotNull(listeners.get(1).get());\n+        assertNotNull(listeners.get(2).get());\n+\n+        submit(() -> {\n+            \/\/ Send clilck events again\n+            click(webView1, 0);\n+            click(webView1, 1);\n+            click(webView1, 2);\n+        });\n+\n+        \/\/ Verify that one more event is delivered to each listener (0 and 2 are same)\n+        Thread.sleep(100);\n+        assertEquals(\"Click count\", 3, listeners.get(0).get().getClickCount());\n+        assertEquals(\"Click count\", 2, listeners.get(1).get().getClickCount());\n+        assertEquals(\"Click count\", 3, listeners.get(2).get().getClickCount());\n+\n+        submit(() -> {\n+            \/\/ Remove event listener from dom node 1\n+            assertNotNull(listeners.get(1).get());\n+            domNodes1.get(1).removeEventListener(\"click\", listeners.get(1).get(), false);\n+            domNodes1.set(1, null);\n+        });\n+\n+        \/\/ Verify that only listener 1 has been released\n+        assertNumActive(\"MyListener\", listenerRefs, 1);\n+        assertNotNull(listeners.get(0).get());\n+        assertNull(listeners.get(1).get());\n+        assertNotNull(listeners.get(2).get());\n+\n+        submit(() -> {\n+            \/\/ Send clilck events again\n+            click(webView1, 0);\n+            click(webView1, 1);\n+            click(webView1, 2);\n+        });\n+\n+        \/\/ Verify that one more event is delivered to active listener (0 and 2 are same)\n+        Thread.sleep(100);\n+        assertEquals(\"Click count\", 4, listeners.get(0).get().getClickCount());\n+        assertEquals(\"Click count\", 4, listeners.get(2).get().getClickCount());\n+\n+\n+        submit(() -> {\n+            \/\/ Remove event listener from dom node 2\n+            assertNotNull(listeners.get(2).get());\n+            domNodes1.get(2).removeEventListener(\"click\", listeners.get(2).get(), false);\n+            domNodes1.set(2, null);\n+        });\n+\n+        \/\/ Verify that all listners have been released\n+        assertNumActive(\"MyListener\", listenerRefs, 0);\n+        assertNull(listeners.get(0).get());\n+        assertNull(listeners.get(1).get());\n+        assertNull(listeners.get(2).get());\n+\n+        submit(() -> {\n+            \/\/ Send clilck events again\n+            click(webView1, 0);\n+            click(webView1, 1);\n+            click(webView1, 2);\n+        });\n+\n+        \/\/ One last test of ref count after sending the clicks\n+        assertNumActive(\"MyListener\", listenerRefs, 0);\n+    }\n+\n+    \/**\n+     * Test that a listener is implicitly released when the WebView is.\n+     *\/\n+    @Test\n+    public void oneWebViewSingleListenerImplicitRelease() throws Exception {\n+        webView2 = null; \/\/ unused\n+\n+        \/\/ Load HTML content and get list of DOM nodes\n+        loadContent(webView1, HTML);\n+\n+        final List<MyListener> listeners = new ArrayList<>();\n+        submit(() -> {\n+            domNodes1 = getDomNodes(webView1);\n+            assertEquals(NUM_DOM_NODES, domNodes1.size());\n+\n+            \/\/ Create listener and attach to DOM node 0\n+            listeners.add(MyListener.create());\n+            domNodes1.get(0).addEventListener(\"click\", listeners.get(0), false);\n+        });\n+\n+        \/\/ Save for later\n+        WeakReference<MyListener> ref = new WeakReference<>(listeners.get(0));\n+\n+        \/\/ Clear strong reference to listener and the DOM nodes\n+        listeners.clear();\n+        domNodes1.clear();\n+\n+        \/\/ Verify that listener is still strongly held\n+        assertNumActive(\"listeners\", listenerRefs, 1);\n+\n+        submit(() -> {\n+            \/\/ Send click event\n+            click(webView1, 0);\n+        });\n+\n+        Thread.sleep(100);\n+\n+        \/\/ Retrieve the listener from the weak ref and check that the event\n+        \/\/ was delivered even though we held no reference to the event or\n+        \/\/ the DOM node.\n+        listeners.add(ref.get());\n+        assertNotNull(listeners.get(0));\n+\n+        \/\/ Verify that the event is delivered to the listener\n+        assertEquals(\"Click count\", 1, listeners.get(0).getClickCount());\n+\n+        \/\/ Clear strong reference to listener and WebView\n+        listeners.clear();\n+        webView1 = null;\n+\n+        \/\/ Verify that there is no strong reference to the WebView\n+        assertNumActive(\"WebView\", webViewRefs, 0);\n+\n+        \/\/ Verify that no listeners are strongly held\n+        assertNumActive(\"MyListener\", listenerRefs, 0);\n+    }\n+\n+    \/**\n+     * Test that there is no leak when a listener is explicitly released in\n+     * one WebView, and that the listener attached to the other WebView is\n+     * still active.\n+     *\/\n+    @Test\n+    public void twoWebViewSingleListenerExplicitRelease() throws Exception {\n+        \/\/ Load HTML content and get list of DOM nodes\n+        loadContent(webView1, HTML);\n+        loadContent(webView2, HTML);\n+\n+        final List<MyListener> listeners1 = new ArrayList<>();\n+        final List<MyListener> listeners2 = new ArrayList<>();\n+        submit(() -> {\n+            domNodes1 = getDomNodes(webView1);\n+            assertEquals(NUM_DOM_NODES, domNodes1.size());\n+            domNodes2 = getDomNodes(webView2);\n+            assertEquals(NUM_DOM_NODES, domNodes2.size());\n+\n+            \/\/ Create listener for each WebView and attach to DOM node 0\n+            listeners1.add(MyListener.create());\n+            domNodes1.get(0).addEventListener(\"click\", listeners1.get(0), false);\n+\n+            listeners2.add(MyListener.create());\n+            domNodes2.get(0).addEventListener(\"click\", listeners2.get(0), false);\n+\n+            \/\/ Send clilck event to node 0 in webview1\n+            click(webView1, 0);\n+        });\n+\n+        \/\/ Verify that the event is delivered to the right listener\n+        Thread.sleep(100);\n+        assertEquals(\"Click count\", 1, listeners1.get(0).getClickCount());\n+        assertEquals(\"Click count\", 0, listeners2.get(0).getClickCount());\n+\n+        submit(() -> {\n+            \/\/ Now click the other WebView's node\n+            click(webView2, 0);\n+        });\n+\n+        \/\/ Verify that the event is delivered to the right listener\n+        Thread.sleep(100);\n+        assertEquals(\"Click count\", 1, listeners1.get(0).getClickCount());\n+        assertEquals(\"Click count\", 1, listeners2.get(0).getClickCount());\n+\n+        submit(() -> {\n+            \/\/ Remove event listener from first WebView\n+            domNodes1.get(0).removeEventListener(\"click\", listeners1.get(0), false);\n+        });\n+\n+        submit(() -> {\n+            \/\/ Now click both WebView's node\n+            click(webView1, 0);\n+            click(webView2, 0);\n+        });\n+\n+        \/\/ Verify that the event is delivered to the right listener\n+        assertEquals(\"Click count\", 1, listeners1.get(0).getClickCount());\n+        assertEquals(\"Click count\", 2, listeners2.get(0).getClickCount());\n+\n+        \/\/ Release strong reference to listener and the DOM nodes\n+        listeners1.clear();\n+        domNodes1.clear();\n+\n+        \/\/ Verify that only one listener has been released\n+        assertNumActive(\"MyListener\", listenerRefs, 1);\n+\n+        submit(() -> {\n+            \/\/ Remove event listener from second WebView\n+            domNodes2.get(0).removeEventListener(\"click\", listeners2.get(0), false);\n+        });\n+\n+        submit(() -> {\n+            \/\/ Now click the second WebView's node again\n+            click(webView2, 0);\n+        });\n+\n+        \/\/ Verify that no more events are delivered\n+        Thread.sleep(100);\n+        assertEquals(\"Click count\", 2, listeners2.get(0).getClickCount());\n+\n+        \/\/ Release strong reference to listener and the DOM nodes\n+        listeners2.clear();\n+        domNodes2.clear();\n+\n+        \/\/ Verify that no listeners are strongly held\n+        assertNumActive(\"MyListener\", listenerRefs, 0);\n+    }\n+\n+    \/**\n+     * Test checks that this check is testing that the immediately previous click\n+     * does not get delivered since the associated DOM node is not part of the page any more.\n+     * This is why the count remains at 1 (from the first click on the original page).\n+     *\/\n+    @Test\n+    public void testStrongRefNewContentLoad() throws Exception {\n+        webView2 = null;\n+        \/\/ Load HTML content and get list of DOM nodes\n+        loadContent(webView1, HTML);\n+\n+        final List<MyListener> listeners= new ArrayList<>();\n+        submit(() -> {\n+            domNodes1 = getDomNodes(webView1);\n+\n+            listeners.add(MyListener.create());\n+            domNodes1.get(0).addEventListener(\"click\", listeners.get(0), false);\n+\n+            \/\/ Send clilck event to node 0 in webview1\n+            click(webView1, 0);\n+        });\n+\n+        \/\/ Verify that the event is delivered to the right listener\n+        Thread.sleep(100);\n+        assertEquals(\"Click count\", 1, listeners.get(0).getClickCount());\n+\n+        \/\/ load new content\n+        loadContent(webView1, HTML2);\n+\n+        submit(() -> {\n+            \/\/ Send click event\n+            click(webView1, 0);\n+        });\n+\n+        \/\/ Verify that the click event is not delivered to the event handler.\n+        Thread.sleep(100);\n+        assertEquals(\"Click count\", 1, listeners.get(0).getClickCount());\n+        \/\/ Verify that even a new content has been loaded , previously register listener is active\n+        assertNumActive(\"MyListener\", listenerRefs, 1);\n+\n+        \/\/ Release strong reference to listener and the DOM nodes\n+        listeners.clear();\n+        domNodes1.clear();\n+\n+        \/\/ Verify that no listeners are strongly held\n+        assertNumActive(\"MyListener\", listenerRefs, 0);\n+    }\n+\n+    \/**\n+     * Test that the listener ref count increase on addevent and decrease on remove event\n+     *\/\n+    @Test\n+    public void oneWebViewRefCountTest() throws Exception {\n+        webView2 = null; \/\/ unused\n+\n+        \/\/ Load HTML content and get list of DOM nodes\n+        loadContent(webView1, HTML);\n+\n+        final List<WeakReference<MyListener>> listeners = new ArrayList<>();\n+        submit(() -> {\n+            domNodes1 = getDomNodes(webView1);\n+            assertEquals(NUM_DOM_NODES, domNodes1.size());\n+\n+            \/\/ Create listeners\n+            MyListener listener = MyListener.create();\n+            listeners.add(new WeakReference<>(listener));\n+\n+            for (int i = 0; i < 3; i++) {\n+                domNodes1.get(i).addEventListener(\"click\", listeners.get(0).get(), false);\n+            }\n+        });\n+\n+        submit(() -> {\n+            \/\/ Send clilck events\n+            click(webView1, 0);\n+            click(webView1, 1);\n+            click(webView1, 2);\n+        });\n+\n+        \/\/ Verify that all three refer to same listener\n+        Thread.sleep(100);\n+        assertEquals(\"Click count\", 3, listeners.get(0).get().getClickCount());\n+\n+        \/\/save for later\n+        MyListener tmpListener = listeners.get(0).get();\n+\n+        \/\/ remove previously registered listeners from dom nodes\n+        submit(() -> {\n+            for (int i = 0; i < 3; i++) {\n+                domNodes1.get(i).removeEventListener(\"click\", listeners.get(0).get(), false);\n+            }\n+        });\n+\n+        submit(() -> {\n+            \/\/ Send clilck events\n+            click(webView1, 0);\n+            click(webView1, 1);\n+            click(webView1, 2);\n+        });\n+\n+        \/\/ verify that the events are not delivered, which is why the count should be remains at 3.\n+        Thread.sleep(100);\n+        assertEquals(\"Click count\", 3, listeners.get(0).get().getClickCount());\n+\n+        \/\/ add events listeners again\n+        submit(() -> {\n+            domNodes1 = getDomNodes(webView1);\n+            assertEquals(NUM_DOM_NODES, domNodes1.size());\n+\n+            \/\/ Create another listeners\n+            MyListener listener = MyListener.create();\n+            listeners.add(new WeakReference<>(listener));\n+\n+            for (int i = 0; i < 3; i++) {\n+                domNodes1.get(i).addEventListener(\"click\", listeners.get(1).get(), false);\n+            }\n+        });\n+\n+        tmpListener = null;\n+        \/\/save for later\n+        MyListener tmpListener1 = listeners.get(0).get();\n+\n+        submit(() -> {\n+            \/\/ Send clilck events\n+            click(webView1, 0);\n+            click(webView1, 1);\n+            click(webView1, 2);\n+        });\n+\n+        \/\/ Verify that the events are delivered to the listeners (0, 1 and 2 are same)\n+        Thread.sleep(100);\n+        assertEquals(\"Click count\", 6, listeners.get(1).get().getClickCount() + listeners.get(0).get().getClickCount());\n+\n+        \/\/ remove events listeners again\n+        submit(() -> {\n+            domNodes1 = getDomNodes(webView1);\n+            \/\/ Create another listeners\n+            MyListener listener = MyListener.create();\n+            listeners.add(new WeakReference<>(listener));\n+\n+            for (int i = 0; i < 3; i++) {\n+                domNodes1.get(i).removeEventListener(\"click\", listeners.get(1).get(), false);\n+            }\n+        });\n+\n+        submit(() -> {\n+            \/\/ Send clilck events\n+            click(webView1, 0);\n+            click(webView1, 1);\n+            click(webView1, 2);\n+        });\n+\n+        \/\/ Verify that the events count should not be increased\n+        Thread.sleep(100);\n+        assertEquals(\"Click count\", 6, listeners.get(1).get().getClickCount() + listeners.get(0).get().getClickCount());\n+\n+        \/\/ Release strong reference to listener and the DOM nodes\n+        listeners.clear();\n+        domNodes1.clear();\n+        tmpListener1 = null;\n+\n+        \/\/ Verify that no listeners are strongly held\n+        assertNumActive(\"MyListener\", listenerRefs, 0);\n+    }\n+\n+    \/**\n+     * Test that there is no leak when a listener is implicitly released when webview goes out of scope.\n+     *\/\n+    @Test\n+    public void oneWebViewMultipleListenersImplicitRelease() throws Exception {\n+        webView2 = null; \/\/ unused\n+\n+        \/\/ Load HTML content and get list of DOM nodes\n+        loadContent(webView1, HTML);\n+\n+        final List<WeakReference<MyListener>> listeners = new ArrayList<>();\n+        submit(() -> {\n+            domNodes1 = getDomNodes(webView1);\n+            assertEquals(NUM_DOM_NODES, domNodes1.size());\n+\n+            \/\/ Create listeners and attach to DOM node 0\n+            MyListener listenerA = MyListener.create();\n+            MyListener listenerB = MyListener.create();\n+\n+            listeners.add(new WeakReference<>(listenerA));\n+            listeners.add(new WeakReference<>(listenerB));\n+            listeners.add(new WeakReference<>(listenerA));\n+\n+            for (int i = 0; i < 3; i++) {\n+                domNodes1.get(i).addEventListener(\"click\", listeners.get(i).get(), false);\n+            }\n+        });\n+\n+        \/\/ Confirm that listeners(0) == listeners(2)\n+        assertSame(listeners.get(0).get(), listeners.get(2).get());\n+\n+        \/\/ Verify that neither listener has been released\n+        assertNumActive(\"MyListener\", listenerRefs, 2);\n+        assertNotNull(listeners.get(0).get());\n+        assertNotNull(listeners.get(1).get());\n+        assertNotNull(listeners.get(2).get());\n+\n+        submit(() -> {\n+            \/\/ Send clilck events\n+            click(webView1, 0);\n+            click(webView1, 1);\n+            click(webView1, 2);\n+        });\n+\n+        \/\/ Verify that the events are delivered\n+        Thread.sleep(100);\n+        assertEquals(\"Click count\", 2, listeners.get(0).get().getClickCount());\n+\n+        \/\/ make web view , goes out of scope\n+        domNodes1.clear();\n+        webView1 = null;\n+\n+        Thread.sleep(100);\n+        \/\/ Verify that active listener\n+        assertNumActive(\"MyListener\", listenerRefs, 0);\n+    }\n+\n+    \/**\n+     * Test that there is no leak when a listener is implicitly released when webview goes out of scope.\n+     *\/\n+    @Test\n+    public void multipleWebViewMultipleListenersImplicitRelease() throws Exception {\n+\n+        \/\/ Load HTML content and get list of DOM nodes\n+        loadContent(webView1, HTML);\n+        loadContent(webView2, HTML);\n+\n+        final List<WeakReference<MyListener>> listeners = new ArrayList<>();\n+\n+        submit(() -> {\n+            domNodes1 = getDomNodes(webView1);\n+            assertEquals(NUM_DOM_NODES, domNodes1.size());\n+\n+            \/\/ Create listeners and attach to DOM node\n+            MyListener listenerA = MyListener.create();\n+            MyListener listenerB = MyListener.create();\n+\n+            listeners.add(new WeakReference<>(listenerA));\n+            listeners.add(new WeakReference<>(listenerB));\n+            listeners.add(new WeakReference<>(listenerA));\n+\n+            for (int i = 0; i < 3; i++) {\n+                domNodes1.get(i).addEventListener(\"click\", listeners.get(i).get(), false);\n+            }\n+        });\n+\n+        submit(() -> {\n+            domNodes2 = getDomNodes(webView2);\n+            assertEquals(NUM_DOM_NODES, domNodes1.size());\n+\n+            \/\/ Create listeners and attach to DOM node\n+            MyListener listenerA = MyListener.create();\n+            MyListener listenerB = MyListener.create();\n+\n+            listeners.add(new WeakReference<>(listenerA));\n+            listeners.add(new WeakReference<>(listenerB));\n+\n+            domNodes2.get(0).addEventListener(\"click\", listeners.get(3).get(), false);\n+            domNodes2.get(1).addEventListener(\"click\", listeners.get(4).get(), false);\n+            \/\/ add existing first listener shared\n+            listeners.add(listeners.get(0));\n+            domNodes2.get(2).addEventListener(\"click\", listeners.get(0).get(), false);\n+        });\n+\n+        Thread.sleep(100);\n+        \/\/ verify active listener count\n+        assertNumActive(\"MyListener\", listenerRefs, 4);\n+\n+        submit(() -> {\n+            \/\/ Send clilck events\n+            click(webView1, 0);\n+            click(webView1, 1);\n+            click(webView1, 2);\n+            click(webView2, 0);\n+            click(webView2, 1);\n+            click(webView2, 2);\n+        });\n+\n+        \/\/ Verify that the events are delivered to both webviews\n+        Thread.sleep(100);\n+        assertEquals(\"Click count\", 3, listeners.get(0).get().getClickCount());\n+\n+        domNodes1.clear();\n+        webView1 = null;\n+\n+        submit(() -> {\n+            \/\/ Send clilck events to webview2\n+            click(webView2, 0);\n+            click(webView2, 1);\n+            click(webView2, 2);\n+        });\n+\n+        \/\/ Verify that the events are delivered to webview2\n+        Thread.sleep(100);\n+        assertEquals(\"Click count\", 4, listeners.get(0).get().getClickCount());\n+        assertEquals(\"Click count\", 4, listeners.get(2).get().getClickCount());\n+        \/\/ Verify that listener is still strongly held\n+        assertNumActive(\"listeners\", listenerRefs, 3);\n+\n+        \/\/removed shared listener\n+        submit(() -> {\n+            domNodes2 = getDomNodes(webView2);\n+            domNodes2.get(2).removeEventListener(\"click\", listeners.get(4).get(), false);\n+        });\n+\n+        submit(() -> {\n+            \/\/ Send clilck events to webview2\n+            click(webView2, 2);\n+        });\n+\n+        \/\/ Verify that the event is not delivered to webview2 for shared listener\n+        Thread.sleep(100);\n+        assertEquals(\"Click count\", 2, listeners.get(4).get().getClickCount());\n+\n+        \/\/ check active listeners\n+        listeners.clear();\n+        domNodes2.clear();\n+        webView2 = null;\n+        \/\/Thread.sleep(100);\n+        \/\/ Verify that active listener\n+        assertNumActive(\"MyListener\", listenerRefs, 0);\n+    }\n+\n+    \/**\n+     * Test that multiple listeners on same node\n+     *\/\n+    @Test\n+    public void oneWebViewMultipleListenerSameNode() throws Exception {\n+        webView2 = null; \/\/ unused\n+\n+        \/\/ Load HTML content and get list of DOM nodes\n+        loadContent(webView1, HTML);\n+\n+        final List<MyListener> listeners = new ArrayList<>();\n+        submit(() -> {\n+            domNodes1 = getDomNodes(webView1);\n+            assertEquals(NUM_DOM_NODES, domNodes1.size());\n+\n+            \/\/ Create listener and attach to DOM node 0\n+            MyListener myListener1 = MyListener.create();\n+            MyListener myListener2 = MyListener.create();\n+            listeners.add(myListener1);\n+            listeners.add(myListener2);\n+            domNodes1.get(0).addEventListener(\"click\", listeners.get(0), false);\n+            domNodes1.get(0).addEventListener(\"click\", listeners.get(1), false);\n+\n+            \/\/ Send clilck event\n+            click(webView1, 0);\n+        });\n+\n+        Thread.sleep(100);\n+        \/\/ Verify that the event is delivered to the listener\n+        assertEquals(\"Click count\", 1, listeners.get(0).getClickCount());\n+        assertEquals(\"Click count\", 1, listeners.get(1).getClickCount());\n+\n+        submit(() -> {\n+            \/\/ Remove event listener\n+            domNodes1.get(0).removeEventListener(\"click\", listeners.get(0), false);\n+            \/\/ Send clilck event\n+            click(webView1, 0);\n+        });\n+\n+        Thread.sleep(100);\n+        \/\/ Verify that listener has been released\n+        assertEquals(\"Click count\", 1, listeners.get(0).getClickCount());\n+        assertEquals(\"Click count\", 2, listeners.get(1).getClickCount());\n+        \/\/ Verify that active listener\n+        assertNumActive(\"MyListener\", listenerRefs, 2);\n+\n+        \/\/ make WebView go out of scope\n+        domNodes1.clear();\n+        webView1 = null;\n+        listeners.clear();\n+\n+        \/\/ Verify that active listener\n+        assertNumActive(\"MyListener\", listenerRefs, 0);\n+    }\n+}\n","filename":"modules\/javafx.web\/src\/test\/java\/test\/javafx\/scene\/web\/EventListenerLeakTest.java","additions":983,"deletions":0,"binary":false,"changes":983,"status":"added"},{"patch":"@@ -0,0 +1,305 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javafx.application.Application;\n+import javafx.application.Platform;\n+import javafx.beans.property.IntegerProperty;\n+import javafx.beans.property.SimpleIntegerProperty;\n+import javafx.beans.value.ChangeListener;\n+import javafx.beans.value.ObservableValue;\n+import javafx.concurrent.Worker;\n+import javafx.geometry.Insets;\n+import javafx.scene.Scene;\n+import javafx.scene.control.Button;\n+import javafx.scene.layout.BorderPane;\n+import javafx.scene.layout.HBox;\n+import javafx.scene.layout.VBox;\n+import javafx.scene.control.Label;\n+import javafx.scene.web.WebEngine;\n+import javafx.scene.web.WebView;\n+import javafx.stage.Stage;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.NodeList;\n+import org.w3c.dom.events.Event;\n+import org.w3c.dom.events.EventListener;\n+import org.w3c.dom.events.EventTarget;\n+\n+public class EventListenerLeak extends Application {\n+\n+    \/**\n+     * List of WeakReferences to EventListener objects so we can count which\n+     * ones are active.\n+     *\/\n+    static List<WeakReference<EventListener>> weakRefs = new ArrayList<>();\n+\n+    \/**\n+     * Listener shared by all WebView instances.\n+     *\/\n+    static WeakReference<EventListener> sharedListener = null;\n+\n+    \/**\n+     * Count of number of active listeners.\n+     * Must be updated in the FX app thread\n+     *\/\n+    static IntegerProperty activeListenerCount = new SimpleIntegerProperty(0);\n+\n+    \/**\n+     * EventListener class use to test for leaks and correct\n+     * delivery of events.\n+     *\/\n+    static class MyEventListener implements EventListener {\n+        private final String id;\n+\n+        MyEventListener(String id) {\n+            this.id = id;\n+        }\n+\n+        @Override\n+        public void handleEvent(Event event) {\n+            System.out.println(\"[\" + id + \"] click\");\n+        }\n+    }\n+\n+    \/**\n+     * Encapsulates a WebView instance and controls\n+     * to remove a listner or the entire webview\n+     *\/\n+    static class LeakTestPanel extends VBox {\n+        private static int count = 0;\n+\n+        private String name;\n+        private WebView webView = null;\n+        private List<WeakReference<EventListener>> myListeners = new ArrayList<>();\n+        private List<EventTarget> domNodes = new ArrayList<>();\n+\n+        LeakTestPanel() {\n+            ++count;\n+            name = \"WebView #\" + count;\n+\n+            createContent();\n+            setupListeners();\n+        }\n+\n+        private static final String HTML =\n+                \"<body><html>\" +\n+                        \"Link: <a href=click>click me A<\/a><br>\" +\n+                        \"Link: <a href=click>click me B<\/a><br>\" +\n+                        \"Link: <a href=click>click me C<\/a><br>\" +\n+                        \"Link: <a href=click>click me SHARED<\/a><br>\" +\n+                        \"<\/html><\/body>\";\n+        private static final int NUM_DOM_NODES = 4;\n+\n+        private void createContent() {\n+            this.setSpacing(5);\n+            this.setPadding(new Insets(5));\n+            this.setPrefSize(350, 300);\n+\n+            webView = new WebView();\n+\n+            VBox controlBox = new VBox();\n+            controlBox.setSpacing(5);\n+            controlBox.setPadding(new Insets(5));\n+\n+            Button removeWebViewButton = new Button(\"Remove \" + name);\n+            removeWebViewButton.setOnAction(e -> {\n+                if (webView != null) {\n+                    System.out.println(\"Removing \" + name);\n+                    this.getChildren().remove(1);\n+                    domNodes.clear();\n+                    webView = null;\n+                }\n+                updateActiveListenerCount();\n+            });\n+\n+            Label listenerStatusLabel = new Label(\"DOM Event Listeners: \" + NUM_DOM_NODES + \" active\");\n+\n+            Button removeListenerButton = new Button(\"Remove listener\");\n+            removeListenerButton.setOnAction(e -> {\n+                if (domNodes.isEmpty()) {\n+                    System.out.println(\"No more listeners to remove\");\n+                } else {\n+                    EventTarget node = domNodes.remove(0);\n+                    EventListener listener = myListeners.remove(0).get();\n+                    if (node != null && listener != null) {\n+                        System.out.println(\"Removing listener\");\n+                        node.removeEventListener(\"click\", listener, false);\n+                    } else {\n+                        System.err.println(\"*** Unable to remove listener\");\n+                    }\n+                    listenerStatusLabel.setText(\"DOM Event Listeners: \" + domNodes.size() + \" active, \" + (NUM_DOM_NODES - domNodes.size()) + \" inactive\");\n+                }\n+                updateActiveListenerCount();\n+            });\n+            controlBox.getChildren().addAll(removeWebViewButton, removeListenerButton, listenerStatusLabel);\n+\n+            this.getChildren().addAll(controlBox, webView);\n+        }\n+\n+        void setupListeners() {\n+            final List<ChangeListener<Worker.State>> stateListeners =\n+                    new ArrayList<>();\n+            stateListeners.add((obs, oldState, newState) -> {\n+                WebEngine engine = webView.getEngine();\n+                if (newState == Worker.State.SUCCEEDED) {\n+                    Document doc = engine.getDocument();\n+                    if (doc != null) {\n+                        NodeList nodeList = doc.getElementsByTagName(\"a\");\n+                        if (nodeList != null) {\n+                            \/\/ Adding an EventListener creates a JNI\n+                            \/\/ global reference, which needs to be released\n+                            \/\/ either when the listener is removed or when\n+                            \/\/ the WebView does out of scope\n+                            for (int i = 0; i < nodeList.getLength(); i++) {\n+                                EventListener listener;\n+                                if (i < 2) {\n+                                    \/\/ Create a new listener\n+                                    listener = new MyEventListener(\"\" + name + \" listener \" + i);\n+                                    weakRefs.add(new WeakReference<>(listener));\n+                                } else if (i == 2) {\n+                                    \/\/ Reuse exising listener\n+                                    listener = myListeners.get(0).get();\n+                                } else {\n+                                    \/\/ Create or use a listener shared by\n+                                    \/\/ all WebView instances\n+                                    if (sharedListener == null) {\n+                                        \/\/ Create a new listener\n+                                        listener = new MyEventListener(\"Shared Listener\");\n+                                        weakRefs.add(new WeakReference<>(listener));\n+                                        sharedListener = (new WeakReference<>(listener));\n+                                    } else {\n+                                        listener = sharedListener.get();\n+                                    }\n+                                }\n+                                myListeners.add(new WeakReference<>(listener));\n+\n+                                EventTarget node = (EventTarget) nodeList.item(i);\n+                                domNodes.add(node);\n+                                System.err.println(\"\" + node.getClass() + \"::addEventListener\");\n+                                node.addEventListener(\"click\", listener, false);\n+                            }\n+                        }\n+                    }\n+\n+                    \/\/ Remove ChangeListener so we don't hold reference to the EventListener\n+                    engine.getLoadWorker().stateProperty()\n+                            .removeListener(stateListeners.get(0));\n+                    stateListeners.clear();\n+                    updateActiveListenerCount();\n+                }\n+            });\n+            webView.getEngine().getLoadWorker().stateProperty().addListener(stateListeners.get(0));\n+            webView.getEngine().loadContent(HTML);\n+            webView.setPrefSize(300, 200);\n+        }\n+\n+    }\n+\n+    static void updateActiveListenerCount() {\n+        System.gc();\n+        System.gc();\n+\n+        int count = 0;\n+        for (WeakReference<EventListener> ref : weakRefs) {\n+            if (ref.get() != null) {\n+                count++;\n+            }\n+        }\n+\n+        final int newCount = count;\n+        Platform.runLater(() -> {\n+            if (newCount != activeListenerCount.get()) {\n+                activeListenerCount.set(newCount);\n+                System.err.println(\"Active MyEventListeners: \" + newCount);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void start(Stage stage) {\n+        stage.setTitle(\"JavaFXEventListenerLeak\");\n+\n+        BorderPane root = new BorderPane();\n+        root.setPadding(new Insets(5));\n+        Scene scene = new Scene(root);\n+\n+        VBox instructions = new VBox(\n+                new Label(\" This test is for EventListener memory leak manual testing \"),\n+                new Label(\"Issue: calling eventtarget.removeEventListener doesn't remove the Eventlistener\"),\n+                new Label(\" \"),\n+                new Label(\" STEPS:\"),\n+                new Label(\"  1. In one panel, remove the WebView.\"),\n+                new Label(\"  2.  In the other panel, remove the listeners one at a time, making \\n\" +\n+                        \"\\t sure that the removed link is not active, and the other links are. \\n\" +\n+                        \"\\t The count should not change when the first of the three listeners \\n\" +\n+                        \"\\tis removed (because that listener is still in use),\\n\" +\n+                        \"\\t but then should decrease when the second and third are removed.\\n\"),\n+                new Label(\"  3. The count of number of listeners should go to 0 after doing both of the above.\"));\n+\n+\n+        root.setTop(instructions);\n+\n+        \/\/ Create content panel with 2 WebView leak test panels\n+        HBox contentPanel = new HBox();\n+        contentPanel.setSpacing(5);\n+        contentPanel.setPadding(new Insets(5));\n+\n+        LeakTestPanel leakTest1 = new LeakTestPanel();\n+        LeakTestPanel leakTest2 = new LeakTestPanel();\n+        contentPanel.getChildren().addAll(leakTest1, leakTest2);\n+\n+        root.setCenter(contentPanel);\n+\n+        \/\/ Add status line\n+        Label activeListenerLabel = new Label();\n+        activeListenerLabel.textProperty().bind(activeListenerCount.asString(\"Active Listener Count: %d\"));\n+        root.setBottom(activeListenerLabel);\n+\n+        stage.setScene(scene);\n+        stage.show();\n+    }\n+\n+    public static void main(String[] args) {\n+\n+        Thread thr = new Thread(() -> {\n+            while (true) {\n+                try {\n+                    Thread.sleep(1000);\n+                } catch (InterruptedException ex) {\n+                }\n+\n+                updateActiveListenerCount();\n+            }\n+        });\n+        thr.setDaemon(true);\n+        thr.start();\n+\n+        Application.launch(args);\n+    }\n+}\n","filename":"tests\/manual\/web\/EventListenerLeak.java","additions":305,"deletions":0,"binary":false,"changes":305,"status":"added"}]}