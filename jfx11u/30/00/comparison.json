{"files":[{"patch":"@@ -115,0 +115,1 @@\n+            byteBuffer.clear();\n","filename":"modules\/javafx.web\/src\/main\/java\/com\/sun\/webkit\/network\/ByteBufferPool.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,648 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.webkit.network;\n+\n+import com.sun.javafx.logging.PlatformLogger.Level;\n+import com.sun.javafx.logging.PlatformLogger;\n+import com.sun.javafx.tk.Toolkit;\n+import com.sun.webkit.Invoker;\n+import com.sun.webkit.LoadListenerClient;\n+import com.sun.webkit.WebPage;\n+import java.io.EOFException;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.SequenceInputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.lang.annotation.Native;\n+import java.net.ConnectException;\n+import java.net.CookieHandler;\n+import java.net.HttpRetryException;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.NoRouteToHostException;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.net.URLDecoder;\n+import java.net.UnknownHostException;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse.BodyHandler;\n+import java.net.http.HttpResponse.BodySubscriber;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpTimeoutException;\n+import java.nio.ByteBuffer;\n+import java.security.AccessControlException;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Vector;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Flow;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.zip.GZIPInputStream;\n+import java.util.zip.InflaterInputStream;\n+import javax.net.ssl.SSLHandshakeException;\n+import static com.sun.webkit.network.URLs.newURL;\n+import static java.net.http.HttpClient.Redirect;\n+import static java.net.http.HttpClient.Version;\n+import static java.net.http.HttpResponse.BodyHandlers;\n+import static java.net.http.HttpResponse.BodySubscribers;\n+\n+final class HTTP2Loader extends URLLoaderBase {\n+\n+    private static final PlatformLogger logger =\n+            PlatformLogger.getLogger(URLLoader.class.getName());\n+\n+    private final WebPage webPage;\n+    private final boolean asynchronous;\n+    private String url;\n+    private String method;\n+    private final String headers;\n+    private FormDataElement[] formDataElements;\n+    private final long data;\n+    private volatile boolean canceled = false;\n+\n+    private final CompletableFuture<Void> response;\n+    \/\/ Use singleton instance of HttpClient to get the maximum benefits\n+    private final static HttpClient HTTP_CLIENT =\n+        AccessController.doPrivileged((PrivilegedAction<HttpClient>) () -> HttpClient.newBuilder()\n+                .version(Version.HTTP_2)  \/\/ this is the default\n+                .followRedirects(Redirect.NEVER) \/\/ WebCore handles redirection\n+                .connectTimeout(Duration.ofSeconds(30)) \/\/ FIXME: Add a property to control the timeout\n+                .cookieHandler(CookieHandler.getDefault())\n+                .build());\n+    \/\/ Singleton instance of direct ByteBuffer to transfer downloaded bytes from\n+    \/\/ Java to native\n+    private static final int DEFAULT_BUFSIZE = 40 * 1024;\n+    private final static ByteBuffer BUFFER;\n+    static {\n+       int bufSize  = AccessController.doPrivileged(\n+                        (PrivilegedAction<Integer>) () ->\n+                            Integer.valueOf(System.getProperty(\"jdk.httpclient.bufsize\", Integer.toString(DEFAULT_BUFSIZE))));\n+       BUFFER = ByteBuffer.allocateDirect(bufSize);\n+    }\n+\n+    \/**\n+     * Creates a new {@code HTTP2Loader}.\n+     *\/\n+    static HTTP2Loader create(WebPage webPage,\n+              ByteBufferPool byteBufferPool,\n+              boolean asynchronous,\n+              String url,\n+              String method,\n+              String headers,\n+              FormDataElement[] formDataElements,\n+              long data) {\n+        if (url.startsWith(\"http:\/\/\") || url.startsWith(\"https:\/\/\")) {\n+            return new HTTP2Loader(\n+                webPage,\n+                byteBufferPool,\n+                asynchronous,\n+                url,\n+                method,\n+                headers,\n+                formDataElements,\n+                data);\n+        }\n+        return null;\n+    }\n+\n+    \/\/ following 2 methods can be generalized and keep a common\n+    \/\/ implementation with URLLoader.java\n+    private String[] getCustomHeaders() {\n+        final var loc = Locale.getDefault();\n+        String lang = \"\";\n+        if (!loc.equals(Locale.US) && !loc.equals(Locale.ENGLISH)) {\n+            lang = loc.getCountry().isEmpty() ?\n+                loc.getLanguage() + \",\":\n+                loc.getLanguage() + \"-\" + loc.getCountry() + \",\";\n+        }\n+\n+        return new String[] { \"Accept-Language\", lang.toLowerCase() + \"en-us;q=0.8,en;q=0.7\",\n+                              \"Accept-Encoding\", \"gzip, inflate\",\n+                              \"Accept-Charset\", \"ISO-8859-1,utf-8;q=0.7,*;q=0.7\",\n+        };\n+    }\n+\n+    private String[] getRequestHeaders() {\n+        return Arrays.stream(headers.split(\"\\n\"))\n+                     .flatMap(s -> Stream.of(s.split(\":\", 2))) \/\/ split from first occurance of :\n+                     .toArray(String[]::new);\n+    }\n+\n+    private URI toURI() throws MalformedURLException {\n+        URI uriObj;\n+        try {\n+            uriObj = new URI(this.url);\n+        } catch(URISyntaxException | IllegalArgumentException e) {\n+            \/\/ slow path\n+            try {\n+                var urlObj = newURL(this.url);\n+                uriObj = new URI(\n+                        urlObj.getProtocol(),\n+                        urlObj.getUserInfo(),\n+                        urlObj.getHost(),\n+                        urlObj.getPort(),\n+                        urlObj.getPath(),\n+                        urlObj.getQuery(),\n+                        urlObj.getRef());\n+            } catch(URISyntaxException | MalformedURLException | IllegalArgumentException ex) {\n+                throw new MalformedURLException(this.url);\n+            }\n+        }\n+        return uriObj;\n+    }\n+\n+    private HttpRequest.BodyPublisher getFormDataPublisher() {\n+        if (this.formDataElements == null) {\n+            return HttpRequest.BodyPublishers.noBody();\n+        }\n+\n+        final var formDataElementsStream = new Vector<InputStream>();\n+        final AtomicLong length = new AtomicLong();\n+        for (final var formData : formDataElements) {\n+            try {\n+                formData.open();\n+                length.addAndGet(formData.getSize());\n+                formDataElementsStream.add(formData.getInputStream());\n+            } catch(IOException ex) {\n+                return null;\n+            }\n+        }\n+\n+        final var stream = new SequenceInputStream(formDataElementsStream.elements());\n+        final var streamBodyPublisher = HttpRequest.BodyPublishers.ofInputStream(() -> stream);\n+        \/\/ Forwarding implementation to send didSendData notification\n+        \/\/ to WebCore. Otherwise `formDataPublisher = streamBodyPublisher`\n+        \/\/ can do the job.\n+        final var formDataPublisher = new HttpRequest.BodyPublisher() {\n+            @Override\n+            public long contentLength() {\n+                \/\/ streaming or fixed length\n+                return length.longValue() <= Integer.MAX_VALUE ? length.longValue() : -1;\n+            }\n+\n+            @Override\n+            public void subscribe(Flow.Subscriber<? super ByteBuffer> subscriber) {\n+                streamBodyPublisher.subscribe(new Flow.Subscriber<ByteBuffer>() {\n+                    @Override\n+                    public void onComplete() {\n+                        subscriber.onComplete();\n+                    }\n+\n+                    @Override\n+                    public void onError(Throwable th) {\n+                        subscriber.onError(th);\n+                    }\n+\n+                    @Override\n+                    public void onNext(ByteBuffer bytes) {\n+                        subscriber.onNext(bytes);\n+                        didSendData(bytes.limit(), length.longValue());\n+                    }\n+\n+                    @Override\n+                    public void onSubscribe(Flow.Subscription subscription) {\n+                        subscriber.onSubscribe(subscription);\n+                    }\n+                });\n+            }\n+        };\n+        return formDataPublisher;\n+    }\n+\n+    \/\/ InputStream based subscriber is used to handle gzip|inflate encoded body. Since InputStream based subscriber is costly interms\n+    \/\/ of memory usage and thread usage, use only when response content-encoding is set to gzip|inflate.\n+    \/\/ There will be 2 threads involved while reading data from InputStream provided by BodySubscriber.\n+    \/\/      1. The main worker which downloads HTTP data and writes to stream\n+    \/\/      2. Other worker which reads data from the InputStream(getBody.thenAcceptAsync)\n+    \/\/ For the better efficiency, we should consider using java.util.zip.Inflater directly\n+    \/\/ to deal with gzip and inflate encoded data.\n+    private InputStream createZIPStream(final String type, InputStream in) throws IOException {\n+        if (\"gzip\".equalsIgnoreCase(type))\n+            return new GZIPInputStream(in);\n+        else if (\"deflate\".equalsIgnoreCase(type))\n+            return new InflaterInputStream(in);\n+        return in;\n+    }\n+\n+    private BodySubscriber<Void> createZIPEncodedBodySubscriber(final String contentEncoding) {\n+        \/\/ Discard body if content type is unknown\n+        if (!(\"gzip\".equalsIgnoreCase(contentEncoding)\n+                    || \"inflate\".equalsIgnoreCase(contentEncoding))) {\n+            logger.severe(String.format(\"Unknown encoding type '%s' found, discarding\", contentEncoding));\n+            return BodySubscribers.discarding();\n+        }\n+\n+        final BodySubscriber<InputStream> streamSubscriber = BodySubscribers.ofInputStream();\n+        final CompletionStage<Void> unzipTask = streamSubscriber.getBody().thenAcceptAsync(is -> {\n+            try (\n+                \/\/ To AutoClose the InputStreams\n+                final InputStream stream = is;\n+                final InputStream in = createZIPStream(contentEncoding, stream);\n+            ) {\n+                while (!canceled) {\n+                    \/\/ same as URLLoader.java\n+                    final byte[] buf = new byte[8 * 1024];\n+                    final int read = in.read(buf);\n+                    if (read < 0) {\n+                        didFinishLoading();\n+                        break;\n+                    }\n+                    didReceiveData(buf, read);\n+                }\n+            } catch (IOException ex) {\n+                didFail(ex);\n+            }\n+        });\n+        return new BodySubscriber<Void>() {\n+                @Override\n+                public void onComplete() {\n+                    streamSubscriber.onComplete();\n+                }\n+\n+                @Override\n+                public void onError(Throwable th) {\n+                    streamSubscriber.onError(th);\n+                }\n+\n+                @Override\n+                public void onNext(List<ByteBuffer> bytes) {\n+                    streamSubscriber.onNext(bytes);\n+                }\n+\n+                @Override\n+                public void onSubscribe(Flow.Subscription subscription) {\n+                    streamSubscriber.onSubscribe(subscription);\n+                }\n+\n+                @Override\n+                public CompletionStage<Void> getBody() {\n+                    return streamSubscriber.getBody().thenCombine(unzipTask, (t, u) -> null);\n+                }\n+        };\n+    }\n+\n+    \/\/ Normal plain body handler, simple, easy to use and pass data to downstream.\n+    private BodySubscriber<Void> createNormalBodySubscriber() {\n+        final BodySubscriber<Void> normalBodySubscriber = BodySubscribers.fromSubscriber(new Flow.Subscriber<List<ByteBuffer>>() {\n+            private Flow.Subscription subscription;\n+            private final AtomicBoolean subscribed = new AtomicBoolean();\n+\n+            @Override\n+            public void onComplete() {\n+                didFinishLoading();\n+            }\n+\n+            @Override\n+            public void onError(Throwable th) {}\n+\n+            @Override\n+            public void onNext(final List<ByteBuffer> bytes) {\n+                didReceiveData(bytes);\n+                requestIfNotCancelled();\n+            }\n+\n+            @Override\n+            public void onSubscribe(Flow.Subscription subscription) {\n+                if (!subscribed.compareAndSet(false, true)) {\n+                    subscription.cancel();\n+                } else {\n+                    this.subscription = subscription;\n+                    requestIfNotCancelled();\n+                }\n+            }\n+\n+            private void requestIfNotCancelled() {\n+                if (canceled) {\n+                    subscription.cancel();\n+                } else {\n+                    subscription.request(1);\n+                }\n+            }\n+        });\n+        return normalBodySubscriber;\n+    }\n+\n+    private BodySubscriber<Void> getBodySubscriber(final String contentEncoding) {\n+        return contentEncoding.isEmpty() ?\n+                  createNormalBodySubscriber() : createZIPEncodedBodySubscriber(contentEncoding);\n+    }\n+\n+    private HTTP2Loader(WebPage webPage,\n+              ByteBufferPool byteBufferPool,\n+              boolean asynchronous,\n+              String url,\n+              String method,\n+              String headers,\n+              FormDataElement[] formDataElements,\n+              long data)\n+    {\n+        this.webPage = webPage;\n+        this.asynchronous = asynchronous;\n+        this.url = url;\n+        this.method = method;\n+        this.headers = headers;\n+        this.formDataElements = formDataElements;\n+        this.data = data;\n+\n+        URI uri;\n+        try {\n+            uri = toURI();\n+        } catch(MalformedURLException e) {\n+            this.response = null;\n+            didFail(e);\n+            return;\n+        }\n+\n+        final var request = HttpRequest.newBuilder()\n+                               .uri(uri)\n+                               .headers(getRequestHeaders()) \/\/ headers from WebCore\n+                               .headers(getCustomHeaders()) \/\/ headers set by us\n+                               .version(Version.HTTP_2)  \/\/ this is the default\n+                               .method(method, getFormDataPublisher())\n+                               .build();\n+\n+        final BodyHandler<Void> bodyHandler = rsp -> {\n+            if(!handleRedirectionIfNeeded(rsp)) {\n+                didReceiveResponse(rsp);\n+            }\n+            return getBodySubscriber(getContentEncoding(rsp));\n+        };\n+\n+        \/\/ Run the HttpClient in the page's access control context\n+        this.response = AccessController.doPrivileged((PrivilegedAction<CompletableFuture<Void>>) () -> {\n+            return HTTP_CLIENT.sendAsync(request, bodyHandler)\n+                              .thenAccept($ -> {})\n+                              .exceptionally(ex -> didFail(ex.getCause()));\n+        }, webPage.getAccessControlContext());\n+\n+        if (!asynchronous) {\n+            waitForRequestToComplete();\n+        }\n+    }\n+\n+    \/**\n+     * Cancels this loader.\n+     *\/\n+    @Override\n+    public void fwkCancel() {\n+        if (logger.isLoggable(Level.FINEST)) {\n+            logger.finest(String.format(\"data: [0x%016X]\", data));\n+        }\n+        canceled = true;\n+    }\n+\n+    private void callBackIfNotCanceled(final Runnable r) {\n+        Invoker.getInvoker().invokeOnEventThread(() -> {\n+            if (!canceled) {\n+                r.run();\n+            }\n+        });\n+    }\n+\n+    private void waitForRequestToComplete() {\n+        \/\/ Wait for the response using nested event loop. Once the response\n+        \/\/ arrives, nested event loop will be terminated.\n+        final Object key = new Object();\n+        this.response.handle((r, th) -> {\n+            Invoker.getInvoker().invokeOnEventThread(() ->\n+                Toolkit.getToolkit().exitNestedEventLoop(key, null));\n+            return null;\n+        });\n+        Toolkit.getToolkit().enterNestedEventLoop(key);\n+        \/\/ No need to join, nested event loop takes care of\n+        \/\/ blocking the caller until response arrives.\n+        \/\/ this.response.join();\n+    }\n+\n+    private boolean handleRedirectionIfNeeded(final HttpResponse.ResponseInfo rsp) {\n+        switch(rsp.statusCode()) {\n+                case 301: \/\/ Moved Permanently\n+                case 302: \/\/ Found\n+                case 303: \/\/ See Other\n+                case 307: \/\/ Temporary Redirect\n+                    willSendRequest(rsp);\n+                    return true;\n+\n+                case 304: \/\/ Not Modified\n+                    didReceiveResponse(rsp);\n+                    didFinishLoading();\n+                    return true;\n+        }\n+        return false;\n+    }\n+\n+    private static long getContentLength(final HttpResponse.ResponseInfo rsp) {\n+        return rsp.headers().firstValueAsLong(\"content-length\").orElse(-1);\n+    }\n+\n+    private static String getContentType(final HttpResponse.ResponseInfo rsp) {\n+        return rsp.headers().firstValue(\"content-type\").orElse(\"application\/octet-stream\");\n+    }\n+\n+    private static String getContentEncoding(final HttpResponse.ResponseInfo rsp) {\n+        return rsp.headers().firstValue(\"content-encoding\").orElse(\"\");\n+    }\n+\n+    private static String getHeadersAsString(final HttpResponse.ResponseInfo rsp) {\n+        return rsp.headers()\n+                  .map()\n+                  .entrySet()\n+                  .stream()\n+                  .map(e -> String.format(\"%s:%s\", e.getKey(), e.getValue().stream().collect(Collectors.joining(\",\"))))\n+                  .collect(Collectors.joining(\"\\n\")) + \"\\n\";\n+    }\n+\n+    private void willSendRequest(final HttpResponse.ResponseInfo rsp) {\n+        callBackIfNotCanceled(() -> {\n+            twkWillSendRequest(\n+                    rsp.statusCode(),\n+                    getContentType(rsp),\n+                    \"\",\n+                    getContentLength(rsp),\n+                    getHeadersAsString(rsp),\n+                    this.url,\n+                    data);\n+        });\n+    }\n+\n+    private void didReceiveResponse(final HttpResponse.ResponseInfo rsp) {\n+        callBackIfNotCanceled(() -> {\n+            twkDidReceiveResponse(\n+                    rsp.statusCode(),\n+                    getContentType(rsp),\n+                    \"\",\n+                    getContentLength(rsp),\n+                    getHeadersAsString(rsp),\n+                    this.url,\n+                    data);\n+        });\n+    }\n+\n+    private ByteBuffer getDirectBuffer(int size) {\n+        ByteBuffer dbb = BUFFER;\n+        \/\/ Though the chance of reaching here is rare, handle the\n+        \/\/ case by allocating a tmp direct buffer.\n+        if (size > dbb.capacity()) {\n+            dbb = ByteBuffer.allocateDirect(size);\n+        }\n+        return dbb.clear();\n+    }\n+\n+    private ByteBuffer copyToDirectBuffer(final ByteBuffer bb) {\n+        return getDirectBuffer(bb.limit()).put(bb).flip();\n+    }\n+\n+    \/\/ another variant to use from createZIPEncodedBodySubscriber\n+    private void didReceiveData(final byte[] bytes, int size) {\n+        callBackIfNotCanceled(() -> {\n+            notifyDidReceiveData(getDirectBuffer(size).put(bytes, 0, size).flip());\n+        });\n+    }\n+\n+    private void didReceiveData(final List<ByteBuffer> bytes) {\n+        callBackIfNotCanceled(() -> bytes.stream()\n+                                          .map(this::copyToDirectBuffer)\n+                                          .forEach(this::notifyDidReceiveData)\n+        );\n+    }\n+\n+    private void notifyDidReceiveData(ByteBuffer byteBuffer) {\n+        Invoker.getInvoker().checkEventThread();\n+        if (logger.isLoggable(Level.FINEST)) {\n+            logger.finest(String.format(\n+                    \"byteBuffer: [%s], \"\n+                    + \"position: [%s], \"\n+                    + \"remaining: [%s], \"\n+                    + \"data: [0x%016X]\",\n+                    byteBuffer,\n+                    byteBuffer.position(),\n+                    byteBuffer.remaining(),\n+                    data));\n+        }\n+        twkDidReceiveData(byteBuffer, byteBuffer.position(), byteBuffer.remaining(), data);\n+    }\n+\n+    private void didFinishLoading() {\n+        callBackIfNotCanceled(this::notifyDidFinishLoading);\n+    }\n+\n+    private void notifyDidFinishLoading() {\n+        Invoker.getInvoker().checkEventThread();\n+        if (logger.isLoggable(Level.FINEST)) {\n+            logger.finest(String.format(\"data: [0x%016X]\", data));\n+        }\n+        twkDidFinishLoading(data);\n+    }\n+\n+\n+    private Void didFail(final Throwable th) {\n+        callBackIfNotCanceled(() ->  {\n+            \/\/ FIXME: simply copied from URLLoader.java, it should be\n+            \/\/ retwritten using if..else rather than throw.\n+            int errorCode;\n+            try {\n+                throw th;\n+            } catch (MalformedURLException ex) {\n+                errorCode = LoadListenerClient.MALFORMED_URL;\n+            } catch (AccessControlException ex) {\n+                errorCode = LoadListenerClient.PERMISSION_DENIED;\n+            } catch (UnknownHostException ex) {\n+                errorCode = LoadListenerClient.UNKNOWN_HOST;\n+            } catch (NoRouteToHostException ex) {\n+                errorCode = LoadListenerClient.NO_ROUTE_TO_HOST;\n+            } catch (ConnectException ex) {\n+                errorCode = LoadListenerClient.CONNECTION_REFUSED;\n+            } catch (SocketException ex) {\n+                errorCode = LoadListenerClient.CONNECTION_RESET;\n+            } catch (SSLHandshakeException ex) {\n+                errorCode = LoadListenerClient.SSL_HANDSHAKE;\n+            } catch (SocketTimeoutException | HttpTimeoutException ex) {\n+                errorCode = LoadListenerClient.CONNECTION_TIMED_OUT;\n+            } catch (FileNotFoundException ex) {\n+                errorCode = LoadListenerClient.FILE_NOT_FOUND;\n+            } catch (Throwable ex) {\n+                errorCode = LoadListenerClient.UNKNOWN_ERROR;\n+            }\n+            notifyDidFail(errorCode, url, th.getMessage());\n+        });\n+        return null;\n+    }\n+\n+    private void notifyDidFail(int errorCode, String url, String message) {\n+        Invoker.getInvoker().checkEventThread();\n+        if (logger.isLoggable(Level.FINEST)) {\n+            logger.finest(String.format(\n+                    \"errorCode: [%d], \"\n+                    + \"url: [%s], \"\n+                    + \"message: [%s], \"\n+                    + \"data: [0x%016X]\",\n+                    errorCode,\n+                    url,\n+                    message,\n+                    data));\n+        }\n+        twkDidFail(errorCode, url, message, data);\n+    }\n+\n+    private void didSendData(final long totalBytesSent,\n+                             final long totalBytesToBeSent)\n+    {\n+        callBackIfNotCanceled(() -> notifyDidSendData(totalBytesSent, totalBytesToBeSent));\n+    }\n+\n+    private void notifyDidSendData(long totalBytesSent,\n+                                   long totalBytesToBeSent)\n+    {\n+        Invoker.getInvoker().checkEventThread();\n+        if (logger.isLoggable(Level.FINEST)) {\n+            logger.finest(String.format(\n+                    \"totalBytesSent: [%d], \"\n+                    + \"totalBytesToBeSent: [%d], \"\n+                    + \"data: [0x%016X]\",\n+                    totalBytesSent,\n+                    totalBytesToBeSent,\n+                    data));\n+        }\n+        twkDidSendData(totalBytesSent, totalBytesToBeSent, data);\n+    }\n+}\n","filename":"modules\/javafx.web\/src\/main\/java\/com\/sun\/webkit\/network\/HTTP2Loader.java","additions":648,"deletions":0,"binary":false,"changes":648,"status":"added"},{"patch":"@@ -65,0 +65,6 @@\n+    \/**\n+     * The default value of the maximum concurrent connections for\n+     * new gen HTTP2 client\n+     *\/\n+    private static final int DEFAULT_HTTP2_MAX_CONNECTIONS = 20;\n+\n@@ -74,0 +80,5 @@\n+\n+    \/**\n+     * Can use HTTP2Loader\n+     *\/\n+    private static final boolean useHTTP2Loader;\n@@ -83,0 +94,7 @@\n+\n+        useHTTP2Loader = AccessController.doPrivileged((PrivilegedAction<Boolean>) () -> {\n+            \/\/ Use HTTP2 by default on JDK 12 or later\n+            final var version = Runtime.Version.parse(System.getProperty(\"java.version\"));\n+            final String defaultUseHTTP2 = version.feature() >= 12 ? \"true\" : \"false\";\n+            return Boolean.valueOf(System.getProperty(\"com.sun.webkit.useHTTP2Loader\", defaultUseHTTP2));\n+        });\n@@ -120,1 +138,1 @@\n-    private static URLLoader fwkLoad(WebPage webPage,\n+    private static URLLoaderBase fwkLoad(WebPage webPage,\n@@ -146,0 +164,16 @@\n+\n+        if (useHTTP2Loader) {\n+            final URLLoaderBase loader = HTTP2Loader.create(\n+                webPage,\n+                byteBufferPool,\n+                asynchronous,\n+                url,\n+                method,\n+                headers,\n+                formDataElements,\n+                data);\n+            if (loader != null) {\n+                return loader;\n+            }\n+        }\n+\n@@ -187,0 +221,4 @@\n+\n+        if (useHTTP2Loader) {\n+            return propValue >= 0 ? propValue : DEFAULT_HTTP2_MAX_CONNECTIONS;\n+        }\n","filename":"modules\/javafx.web\/src\/main\/java\/com\/sun\/webkit\/network\/NetworkContext.java","additions":39,"deletions":1,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import java.lang.annotation.Native;\n@@ -68,3 +67,1 @@\n-final class URLLoader implements Runnable {\n-\n-    @Native public static final int ALLOW_UNASSIGNED = java.net.IDN.ALLOW_UNASSIGNED;\n+final class URLLoader extends URLLoaderBase implements Runnable {\n@@ -74,1 +71,0 @@\n-    private static final int MAX_REDIRECTS = 10;\n@@ -118,1 +114,2 @@\n-    private void fwkCancel() {\n+    @Override\n+    public void fwkCancel() {\n@@ -144,1 +141,0 @@\n-            int redirectCount = 0;\n@@ -165,1 +161,0 @@\n-                Redirect redirect = null;\n@@ -168,1 +163,1 @@\n-                    redirect = receiveResponse(c);\n+                    receiveResponse(c);\n@@ -188,19 +183,1 @@\n-\n-                if (redirect != null) {\n-                    if (redirectCount++ >= MAX_REDIRECTS) {\n-                        throw new TooManyRedirectsException();\n-                    }\n-                    boolean resetRequest = !redirect.preserveRequest\n-                            && !method.equals(GET) && !method.equals(HEAD);\n-                    String newMethod = resetRequest ? GET : method;\n-                    willSendRequest(redirect.url, newMethod, c);\n-                    \/\/ willSendRequest() may cancel this loader\n-                    if (canceled) {\n-                        break;\n-                    }\n-                    url = redirect.url;\n-                    method = newMethod;\n-                    formDataElements = resetRequest ? null : formDataElements;\n-                } else {\n-                    break;\n-                }\n+                break;\n@@ -235,3 +212,0 @@\n-        } catch (TooManyRedirectsException ex) {\n-            error = ex;\n-            errorCode = LoadListenerClient.TOO_MANY_REDIRECTS;\n@@ -420,1 +394,1 @@\n-    private Redirect receiveResponse(URLConnection c)\n+    private void receiveResponse(URLConnection c)\n@@ -424,1 +398,1 @@\n-            return null;\n+            return;\n@@ -438,1 +412,1 @@\n-                return null;\n+                return;\n@@ -447,13 +421,1 @@\n-                    String newLoc = http.getHeaderField(\"Location\");\n-                    if (newLoc != null) {\n-                        URL newUrl;\n-                        try {\n-                            newUrl = newURL(newLoc);\n-                        } catch (MalformedURLException mue) {\n-                            \/\/ Try to treat newLoc as a relative URI to conform\n-                            \/\/ to popular browsers\n-                            newUrl = newURL(c.getURL(), newLoc);\n-                        }\n-                        return new Redirect(newUrl.toExternalForm(),\n-                                            code == 307);\n-                    }\n+                    willSendRequest(c);\n@@ -465,1 +427,1 @@\n-                    return null;\n+                    return;\n@@ -513,1 +475,1 @@\n-            return null;\n+            return;\n@@ -604,1 +566,0 @@\n-                byteBuffer.clear();\n@@ -608,1 +569,0 @@\n-        return null;\n@@ -628,14 +588,0 @@\n-\n-    \/**\n-     * A holder for redirect information.\n-     *\/\n-    private static final class Redirect {\n-        private final String url;\n-        private final boolean preserveRequest;\n-\n-        private Redirect(String url, boolean preserveRequest) {\n-            this.url = url;\n-            this.preserveRequest = preserveRequest;\n-        }\n-    }\n-\n@@ -651,10 +597,0 @@\n-    \/**\n-     * Signals that too many redirects have been encountered\n-     * while processing the request.\n-     *\/\n-    private static final class TooManyRedirectsException extends IOException {\n-        private TooManyRedirectsException() {\n-            super(\"Too many redirects\");\n-        }\n-    }\n-\n@@ -686,3 +622,1 @@\n-    private void willSendRequest(String newUrl,\n-                                 final String newMethod,\n-                                 URLConnection c) throws InterruptedException\n+    private void willSendRequest(URLConnection c) throws InterruptedException\n@@ -690,1 +624,0 @@\n-        final String adjustedNewUrl = adjustUrlForWebKit(newUrl);\n@@ -697,2 +630,0 @@\n-        final CountDownLatch latch =\n-                asynchronous ? new CountDownLatch(1) : null;\n@@ -700,19 +631,8 @@\n-            try {\n-                if (!canceled) {\n-                    boolean keepGoing = notifyWillSendRequest(\n-                            adjustedNewUrl,\n-                            newMethod,\n-                            status,\n-                            contentType,\n-                            contentEncoding,\n-                            contentLength,\n-                            responseHeaders,\n-                            adjustedUrl);\n-                    if (!keepGoing) {\n-                        fwkCancel();\n-                    }\n-                }\n-            } finally {\n-                if (latch != null) {\n-                    latch.countDown();\n-                }\n+            if (!canceled) {\n+                notifyWillSendRequest(\n+                        status,\n+                        contentType,\n+                        contentEncoding,\n+                        contentLength,\n+                        responseHeaders,\n+                        adjustedUrl);\n@@ -721,3 +641,0 @@\n-        if (latch != null) {\n-            latch.await();\n-        }\n@@ -726,3 +643,1 @@\n-    private boolean notifyWillSendRequest(String newUrl,\n-                                          String newMethod,\n-                                          int status,\n+    private void notifyWillSendRequest(int status,\n@@ -737,3 +652,1 @@\n-                    \"newUrl: [%s], \"\n-                    + \"newMethod: [%s], \"\n-                    + \"status: [%d], \"\n+                    \"status: [%d], \"\n@@ -746,2 +659,0 @@\n-                    newUrl,\n-                    newMethod,\n@@ -756,3 +667,1 @@\n-        boolean result = twkWillSendRequest(\n-                newUrl,\n-                newMethod,\n+        twkWillSendRequest(\n@@ -766,4 +675,0 @@\n-        if (logger.isLoggable(Level.FINEST)) {\n-            logger.finest(String.format(\"result: [%s]\", result));\n-        }\n-        return result;\n@@ -836,1 +741,0 @@\n-            byteBuffer.clear();\n@@ -906,34 +810,0 @@\n-    private static native void twkDidSendData(long totalBytesSent,\n-                                              long totalBytesToBeSent,\n-                                              long data);\n-\n-    private static native boolean twkWillSendRequest(String newUrl,\n-                                                     String newMethod,\n-                                                     int status,\n-                                                     String contentType,\n-                                                     String contentEncoding,\n-                                                     long contentLength,\n-                                                     String headers,\n-                                                     String url,\n-                                                     long data);\n-\n-    private static native void twkDidReceiveResponse(int status,\n-                                                     String contentType,\n-                                                     String contentEncoding,\n-                                                     long contentLength,\n-                                                     String headers,\n-                                                     String url,\n-                                                     long data);\n-\n-    private static native void twkDidReceiveData(ByteBuffer byteBuffer,\n-                                                 int position,\n-                                                 int remaining,\n-                                                 long data);\n-\n-    private static native void twkDidFinishLoading(long data);\n-\n-    private static native void twkDidFail(int errorCode,\n-                                          String url,\n-                                          String message,\n-                                          long data);\n-\n","filename":"modules\/javafx.web\/src\/main\/java\/com\/sun\/webkit\/network\/URLLoader.java","additions":23,"deletions":153,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.webkit.network;\n+\n+import java.lang.annotation.Native;\n+import java.nio.ByteBuffer;\n+\n+abstract class URLLoaderBase {\n+    @Native public static final int ALLOW_UNASSIGNED = java.net.IDN.ALLOW_UNASSIGNED;\n+\n+    \/**\n+     * Cancels the loader.\n+     *\/\n+    protected abstract void fwkCancel();\n+\n+    protected static native void twkDidSendData(long totalBytesSent,\n+                                              long totalBytesToBeSent,\n+                                              long data);\n+\n+    protected static native void twkWillSendRequest(int status,\n+                                                     String contentType,\n+                                                     String contentEncoding,\n+                                                     long contentLength,\n+                                                     String headers,\n+                                                     String url,\n+                                                     long data);\n+\n+    protected static native void twkDidReceiveResponse(int status,\n+                                                     String contentType,\n+                                                     String contentEncoding,\n+                                                     long contentLength,\n+                                                     String headers,\n+                                                     String url,\n+                                                     long data);\n+\n+    protected static native void twkDidReceiveData(ByteBuffer byteBuffer,\n+                                                 int position,\n+                                                 int remaining,\n+                                                 long data);\n+\n+    protected static native void twkDidFinishLoading(long data);\n+\n+    protected static native void twkDidFail(int errorCode,\n+                                          String url,\n+                                          String message,\n+                                          long data);\n+\n+}\n","filename":"modules\/javafx.web\/src\/main\/java\/com\/sun\/webkit\/network\/URLLoaderBase.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -35,0 +35,1 @@\n+    requires java.net.http;\n@@ -36,1 +37,0 @@\n-    requires jdk.xml.dom;\n@@ -38,0 +38,1 @@\n+    requires jdk.xml.dom;\n","filename":"modules\/javafx.web\/src\/main\/java\/module-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1794,6 +1794,6 @@\n-               _Java_com_sun_webkit_network_URLLoader_twkDidFail\n-               _Java_com_sun_webkit_network_URLLoader_twkDidFinishLoading\n-               _Java_com_sun_webkit_network_URLLoader_twkDidReceiveData\n-               _Java_com_sun_webkit_network_URLLoader_twkDidReceiveResponse\n-               _Java_com_sun_webkit_network_URLLoader_twkDidSendData\n-               _Java_com_sun_webkit_network_URLLoader_twkWillSendRequest\n+               _Java_com_sun_webkit_network_URLLoaderBase_twkDidFail\n+               _Java_com_sun_webkit_network_URLLoaderBase_twkDidFinishLoading\n+               _Java_com_sun_webkit_network_URLLoaderBase_twkDidReceiveData\n+               _Java_com_sun_webkit_network_URLLoaderBase_twkDidReceiveResponse\n+               _Java_com_sun_webkit_network_URLLoaderBase_twkDidSendData\n+               _Java_com_sun_webkit_network_URLLoaderBase_twkWillSendRequest\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/mapfile-macosx","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1986,6 +1986,6 @@\n-               Java_com_sun_webkit_network_URLLoader_twkDidFail;\n-               Java_com_sun_webkit_network_URLLoader_twkDidFinishLoading;\n-               Java_com_sun_webkit_network_URLLoader_twkDidReceiveData;\n-               Java_com_sun_webkit_network_URLLoader_twkDidReceiveResponse;\n-               Java_com_sun_webkit_network_URLLoader_twkDidSendData;\n-               Java_com_sun_webkit_network_URLLoader_twkWillSendRequest;\n+               Java_com_sun_webkit_network_URLLoaderBase_twkDidFail;\n+               Java_com_sun_webkit_network_URLLoaderBase_twkDidFinishLoading;\n+               Java_com_sun_webkit_network_URLLoaderBase_twkDidReceiveData;\n+               Java_com_sun_webkit_network_URLLoaderBase_twkDidReceiveResponse;\n+               Java_com_sun_webkit_network_URLLoaderBase_twkDidSendData;\n+               Java_com_sun_webkit_network_URLLoaderBase_twkWillSendRequest;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/mapfile-vers","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,2 +28,2 @@\n-#include \"PlatformJavaClasses.h\"\n-#include \"com_sun_webkit_network_URLLoader.h\"\n+#include <wtf\/java\/JavaEnv.h>\n+#include \"com_sun_webkit_network_URLLoaderBase.h\"\n@@ -65,1 +65,1 @@\n-            com_sun_webkit_network_URLLoader_ALLOW_UNASSIGNED));\n+            com_sun_webkit_network_URLLoaderBase_ALLOW_UNASSIGNED));\n@@ -67,1 +67,0 @@\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/java\/IDNJava.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -105,0 +105,5 @@\n+#if PLATFORM(JAVA)\n+    void continueAfterWillSendRequest(ResourceRequest&& request);\n+    void willSendRequest(const ResourceResponse& response);\n+#endif\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/network\/ResourceHandle.h","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -141,0 +141,1 @@\n+    int m_redirectCount { 0 };\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/network\/ResourceHandleInternal.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -6,2 +6,0 @@\n-#include \"ResourceHandle.h\"\n-#include \"ResourceHandleInternal.h\"\n@@ -9,0 +7,1 @@\n+#include <wtf\/CompletionHandler.h>\n@@ -10,0 +9,3 @@\n+#include \"ResourceHandle.h\"\n+#include \"ResourceHandleInternal.h\"\n+#include \"com_sun_webkit_LoadListenerClient.h\"\n@@ -24,1 +26,1 @@\n-    d->m_loader = URLLoader::loadAsynchronously(context(), this);\n+    d->m_loader = URLLoader::loadAsynchronously(context(), this, this->firstRequest());\n@@ -32,0 +34,95 @@\n+        d->m_loader.reset();\n+    }\n+}\n+\n+static bool shouldRedirectAsGET(const ResourceRequest& request, const ResourceResponse& response, bool crossOrigin)\n+{\n+    if (request.httpMethod() == \"GET\" || request.httpMethod() == \"HEAD\")\n+        return false;\n+\n+    if (!request.url().protocolIsInHTTPFamily())\n+        return true;\n+\n+    if (response.isSeeOther())\n+        return true;\n+\n+    if ((response.isMovedPermanently() || response.isFound()) && (request.httpMethod() == \"POST\"))\n+        return true;\n+\n+    if (crossOrigin && (request.httpMethod() == \"DELETE\"))\n+        return true;\n+\n+    return false;\n+}\n+\n+void ResourceHandle::willSendRequest(const ResourceResponse& response)\n+{\n+    ASSERT(isMainThread());\n+\n+    ResourceRequest request = firstRequest();\n+\n+    static const int maxRedirects = 20;\n+    if (d->m_redirectCount++ > maxRedirects) {\n+        client()->didFail(this, ResourceError(\n+            String(),\n+            com_sun_webkit_LoadListenerClient_TOO_MANY_REDIRECTS,\n+            request.url(),\n+            \"Illegal redirect\"));\n+        return;\n+    }\n+\n+    if (response.httpStatusCode() == 307) {\n+        String lastHTTPMethod = d->m_lastHTTPMethod;\n+        if (!equalIgnoringASCIICase(lastHTTPMethod, request.httpMethod())) {\n+            request.setHTTPMethod(lastHTTPMethod);\n+\n+            FormData* body = d->m_firstRequest.httpBody();\n+            if (!equalLettersIgnoringASCIICase(lastHTTPMethod, \"get\") && body && !body->isEmpty())\n+                request.setHTTPBody(body);\n+\n+            String originalContentType = d->m_firstRequest.httpContentType();\n+            if (!originalContentType.isEmpty())\n+                request.setHTTPHeaderField(HTTPHeaderName::ContentType, originalContentType);\n+        }\n+    }\n+\n+    String location = response.httpHeaderField(HTTPHeaderName::Location);\n+    URL newURL = URL(response.url(), location);\n+    bool crossOrigin = !protocolHostAndPortAreEqual(request.url(), newURL);\n+\n+    ResourceRequest newRequest = request;\n+    newRequest.setURL(newURL);\n+\n+    if (shouldRedirectAsGET(newRequest, response, crossOrigin)) {\n+        newRequest.setHTTPMethod(\"GET\");\n+        newRequest.setHTTPBody(nullptr);\n+        newRequest.clearHTTPContentType();\n+    }\n+\n+    if (crossOrigin) {\n+        \/\/ If the network layer carries over authentication headers from the original request\n+        \/\/ in a cross-origin redirect, we want to clear those headers here.\n+        newRequest.clearHTTPAuthorization();\n+        newRequest.clearHTTPOrigin();\n+    }\n+\n+    \/\/ Should not set Referer after a redirect from a secure resource to non-secure one.\n+    if (!newURL.protocolIs(\"https\") && protocolIs(newRequest.httpReferrer(), \"https\") && context()->shouldClearReferrerOnHTTPSToHTTPRedirect())\n+        newRequest.clearHTTPReferrer();\n+\n+    client()->willSendRequestAsync(this, WTFMove(newRequest), ResourceResponse(response), [this, protectedThis = makeRef(*this)] (ResourceRequest&& request) {\n+        continueAfterWillSendRequest(WTFMove(request));\n+    });\n+}\n+\n+void ResourceHandle::continueAfterWillSendRequest(ResourceRequest&& request)\n+{\n+    ASSERT(isMainThread());\n+\n+    \/\/ willSendRequest might cancel the load.\n+    if (!d->m_loader || !client())\n+        return;\n+\n+    cancel();\n+    if (request.isNull()) {\n+        return;\n@@ -33,0 +130,1 @@\n+    d->m_loader = URLLoader::loadAsynchronously(context(), this, request);\n@@ -46,1 +144,0 @@\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/network\/java\/ResourceHandleJava.cpp","additions":101,"deletions":4,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-#include \"com_sun_webkit_network_URLLoader.h\"\n+#include \"com_sun_webkit_network_URLLoaderBase.h\"\n@@ -80,1 +80,1 @@\n-                \"Lcom\/sun\/webkit\/network\/URLLoader;\");\n+                \"Lcom\/sun\/webkit\/network\/URLLoaderBase;\");\n@@ -85,1 +85,1 @@\n-                \"com\/sun\/webkit\/network\/URLLoader\"));\n+                \"com\/sun\/webkit\/network\/URLLoaderBase\"));\n@@ -111,19 +111,0 @@\n-static bool shouldRedirectAsGET(const ResourceRequest& request, const ResourceResponse& response, bool crossOrigin)\n-{\n-    if (request.httpMethod() == \"GET\" || request.httpMethod() == \"HEAD\")\n-        return false;\n-\n-    if (!request.url().protocolIsInHTTPFamily())\n-        return true;\n-\n-    if (response.isSeeOther())\n-        return true;\n-\n-    if ((response.isMovedPermanently() || response.isFound()) && (request.httpMethod() == \"POST\"))\n-        return true;\n-\n-    if (crossOrigin && (request.httpMethod() == \"DELETE\"))\n-        return true;\n-\n-    return false;\n-}\n@@ -142,1 +123,2 @@\n-                                                    ResourceHandle* handle)\n+                                                    ResourceHandle* handle,\n+                                                    const ResourceRequest& request)\n@@ -149,1 +131,1 @@\n-            handle->firstRequest(),\n+            request,\n@@ -201,7 +183,2 @@\n-    const HTTPHeaderMap& headerMap = request.httpHeaderFields();\n-    for (\n-        HTTPHeaderMap::const_iterator it = headerMap.begin();\n-        headerMap.end() != it;\n-        ++it)\n-    {\n-        headerString.append(it->key);\n+    for (const auto& header : request.httpHeaderFields()) {\n+        headerString.append(header.key);\n@@ -209,1 +186,1 @@\n-        headerString.append(it->value);\n+        headerString.append(header.value);\n@@ -307,4 +284,1 @@\n-bool URLLoader::AsynchronousTarget::willSendRequest(\n-        const String& newUrl,\n-        const String& newMethod,\n-        const ResourceResponse& response)\n+bool URLLoader::AsynchronousTarget::willSendRequest(const ResourceResponse& response)\n@@ -312,28 +286,2 @@\n-    using namespace URLLoaderJavaInternal;\n-    ASSERT(isMainThread());\n-    ResourceHandleClient* client = m_handle->client();\n-    if (client) {\n-        ResourceRequest request = m_handle->firstRequest();\n-        String location = response.httpHeaderField(HTTPHeaderName::Location);\n-        URL newURL = URL(URL(), newUrl);\n-        bool crossOrigin = !protocolHostAndPortAreEqual(request.url(), newURL);\n-\n-        ResourceRequest newRequest = request;\n-        newRequest.setURL(newURL);\n-\n-        if (shouldRedirectAsGET(newRequest, response, crossOrigin)) {\n-            newRequest.setHTTPMethod(\"GET\");\n-            newRequest.setHTTPBody(nullptr);\n-            newRequest.clearHTTPContentType();\n-        } else {\n-            newRequest.setHTTPMethod(newMethod);\n-        }\n-\n-        \/\/ Should not set Referer after a redirect from a secure resource to non-secure one.\n-        if (!newURL.protocolIs(\"https\") && protocolIs(newRequest.httpReferrer(), \"https\") && m_handle->context()->shouldClearReferrerOnHTTPSToHTTPRedirect())\n-            newRequest.clearHTTPReferrer();\n-\n-        client->willSendRequestAsync(m_handle, WTFMove(newRequest), ResourceResponse(response), [] (ResourceRequest&&) {\n-        });\n-    }\n-    return true;\n+    m_handle->willSendRequest(response);\n+    return false;\n@@ -347,2 +295,1 @@\n-        client->didReceiveResponseAsync(m_handle, ResourceResponse(response), [] () {\n-        });\n+        client->didReceiveResponseAsync(m_handle, ResourceResponse(response), [] () {});\n@@ -392,4 +339,1 @@\n-bool URLLoader::SynchronousTarget::willSendRequest(\n-        const String& newUrl,\n-        const String&,\n-        const ResourceResponse&)\n+bool URLLoader::SynchronousTarget::willSendRequest(const ResourceResponse& response)\n@@ -400,1 +344,3 @@\n-    if (!protocolHostAndPortAreEqual(m_request.url(), URL(URL(), newUrl))) {\n+    String location = response.httpHeaderField(HTTPHeaderName::Location);\n+    URL newURL = URL(response.url(), location);\n+    if (!protocolHostAndPortAreEqual(m_request.url(), newURL)) {\n@@ -434,8 +380,1 @@\n-using namespace WebCore;\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-static void setupResponse(ResourceResponse& response,\n-                          JNIEnv* env,\n+static WebCore::ResourceResponse setupResponse(JNIEnv* env,\n@@ -449,0 +388,3 @@\n+    using namespace WebCore;\n+    ResourceResponse response { };\n+\n@@ -499,0 +441,1 @@\n+    return response;\n@@ -501,1 +444,1 @@\n-JNIEXPORT void JNICALL Java_com_sun_webkit_network_URLLoader_twkDidSendData\n+JNIEXPORT void JNICALL Java_com_sun_webkit_network_URLLoaderBase_twkDidSendData\n@@ -504,0 +447,1 @@\n+    using namespace WebCore;\n@@ -510,2 +454,2 @@\n-JNIEXPORT jboolean JNICALL Java_com_sun_webkit_network_URLLoader_twkWillSendRequest\n-  (JNIEnv* env, jclass, jstring newUrl, jstring newMethod, jint status,\n+JNIEXPORT void JNICALL Java_com_sun_webkit_network_URLLoaderBase_twkWillSendRequest\n+  (JNIEnv* env, jclass, jint status,\n@@ -515,0 +459,1 @@\n+    using namespace WebCore;\n@@ -519,3 +464,1 @@\n-    ResourceResponse response;\n-    setupResponse(\n-            response,\n+    ResourceResponse response = setupResponse(\n@@ -530,4 +473,1 @@\n-    return bool_to_jbool(target->willSendRequest(\n-            String(env, newUrl),\n-            String(env, newMethod),\n-            response));\n+    target->willSendRequest(response);\n@@ -536,1 +476,1 @@\n-JNIEXPORT void JNICALL Java_com_sun_webkit_network_URLLoader_twkDidReceiveResponse\n+JNIEXPORT void JNICALL Java_com_sun_webkit_network_URLLoaderBase_twkDidReceiveResponse\n@@ -541,0 +481,1 @@\n+    using namespace WebCore;\n@@ -545,3 +486,1 @@\n-    ResourceResponse response;\n-    setupResponse(\n-            response,\n+    ResourceResponse response = setupResponse(\n@@ -559,1 +498,1 @@\n-JNIEXPORT void JNICALL Java_com_sun_webkit_network_URLLoader_twkDidReceiveData\n+JNIEXPORT void JNICALL Java_com_sun_webkit_network_URLLoaderBase_twkDidReceiveData\n@@ -563,0 +502,1 @@\n+    using namespace WebCore;\n@@ -571,1 +511,1 @@\n-JNIEXPORT void JNICALL Java_com_sun_webkit_network_URLLoader_twkDidFinishLoading\n+JNIEXPORT void JNICALL Java_com_sun_webkit_network_URLLoaderBase_twkDidFinishLoading\n@@ -574,0 +514,1 @@\n+    using namespace WebCore;\n@@ -580,1 +521,1 @@\n-JNIEXPORT void JNICALL Java_com_sun_webkit_network_URLLoader_twkDidFail\n+JNIEXPORT void JNICALL Java_com_sun_webkit_network_URLLoaderBase_twkDidFail\n@@ -584,0 +525,1 @@\n+    using namespace WebCore;\n@@ -593,4 +535,0 @@\n-\n-#ifdef __cplusplus\n-}\n-#endif\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/network\/java\/URLLoader.cpp","additions":38,"deletions":100,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -23,1 +23,2 @@\n-                                                    ResourceHandle* handle);\n+                                                    ResourceHandle* handle,\n+                                                    const ResourceRequest& request);\n@@ -36,3 +37,1 @@\n-        virtual bool willSendRequest(const String& newUrl,\n-                                     const String& newMethod,\n-                                     const ResourceResponse& response) = 0;\n+        virtual bool willSendRequest(const ResourceResponse& response) = 0;\n@@ -60,3 +59,1 @@\n-        bool willSendRequest(const String& newUrl,\n-                             const String& newMethod,\n-                             const ResourceResponse& response) final;\n+        bool willSendRequest(const ResourceResponse& response) final;\n@@ -79,3 +76,1 @@\n-        bool willSendRequest(const String& newUrl,\n-                             const String& newMethod,\n-                             const ResourceResponse& response) final;\n+        bool willSendRequest(const ResourceResponse& response) final;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/network\/java\/URLLoader.h","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"}]}