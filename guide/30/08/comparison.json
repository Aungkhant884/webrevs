{"files":[{"patch":"@@ -37,0 +37,2 @@\n+* List JTReg `@key` conventions for different areas\n+* Document best practices around TEST.properties usage. See [PR#30](https:\/\/github.com\/openjdk\/guide\/pull\/30#issuecomment-714589551)\n","filename":"README.md","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -336,0 +336,135 @@\n+# Testing Changes\n+\n+In addition to your own Java applications, OpenJDK have support for two test frameworks, JTReg and GTest. JTReg is a Java regression test framework that is used for most of the tests that are included in the OpenJDK source repository. The Google Test (GTest) framework is intended for unit testing of the C++ native code. Currently only JVM testing is supported by the GTest framework. Other areas use JTReg for unit testing of C++ code.\n+\n+This section provides a brief summary of how to get started with testing in OpenJDK. For more information on configuration and how to use the OpenJDK test framework, a.k.a. \"run-test framework\", see [`doc\/testing.md`](https:\/\/github.com\/openjdk\/jdk\/blob\/master\/doc\/testing.md).\n+\n+In general all changes should come with a regression test so if you're writing product code you should also be writing test code. There are a few examples where it doesn't make sence to write an explicit regression test. These should be tagged in JBS with one of the [noreg-labels](#noreg).\n+\n+A few key items to think about when writing a regression test:\n+\n+* A regression test should execute fast - a few seconds at most\n+* The test should only test the desired functionality - if you have several features to test, write more tests\n+* The test should pass reliably on all supported platforms - watch out for platform-specific differences such as path separators\n+* Binary files should not be checked in, if your test needs to use one, the test should create it in some fashion\n+* Avoid shell scripts and relying on external commands as much as possible\n+\n+The JTReg documentation has a section on [how to write good JTReg tests](https:\/\/openjdk.java.net\/jtreg\/writetests.html).\n+\n+## JTReg\n+\n+In-depth documentation about the JTReg framework is found here: [JTReg harness](https:\/\/openjdk.java.net\/jtreg\/). JTReg itself is available in the [Code Tools Project](https:\/\/openjdk.java.net\/projects\/code-tools\/).\n+\n+Below is a small example of a JTReg test. It’s a clean Java class with a main method that is called from the test harness. If the test fails we throw a RuntimeException. This is picked up by the harness and is reported as a test failure. Try to always write a meaningful message in the exception. One that actually helps with understanding what went wrong once the test fails.\n+\n+    \/*\n+     * @test\n+     * @summary Make sure feature X handles Y correctly\n+     * @run main TestXY\n+     *\/\n+    public class TestXY {\n+        public static void main(String[] args) throws Exception {\n+            var result = X.y();\n+            if (result != expected_result) {\n+                throw new RuntimeException(\"X.y() gave \" + result + \", expexted \" + expected_result);\n+            }\n+        }\n+    }\n+\n+This example only utilizes three JTReg specific tags, `@test`, `@summary`, and `@run`. `@test` simply tells JTReg that this class is a test, and `@summary` provides a description of the test. `@run` tells JTReg how to execute the test. In this case we simply tell JTReg to execute the main method of the class `TestXY`. `@run` is not strictly necessary for JTReg to execute the test, an implicit `@run` tag will be added if none exists. However, for clarity and in order to avoid bugs it's recommended to always explicitly use the `@run` tag.\n+\n+There are several other tags that can be used in JTReg tests. You can for instance associate the test with a specific bug that this test is a regression test for.\n+\n+    @bug 7000001\n+\n+Or you can specify a number of requirements that must be fulfilled for JTReg to execute the test.\n+\n+    @requires docker.support\n+    @requires os.family != ”windows”\n+    @requires os.maxMemory > 3G\n+    @requires os.arch==\"x86_64\" | os.arch==\"amd64\"\n+\n+You can also specify if the test requires specific modules, and you can specify command line flags and run the test in several different ways.\n+\n+    @modules java.base\/jdk.internal.misc\n+    @run main\/othervm -Xmx128m TestXY\n+\n+Note that you can have several `@run` tags in the same test with different command line options.\n+\n+JTReg also have support for labeling tests with keys using the `@key` tag. These keywords can then be used to filter the test selection. For instance if you have a UI test which needs to display a window you'll want to make sure the test harness doesn't try to run this test on a system which doesn't support headful tests. You do this by specifying\n+\n+    @key headful\n+\n+Another example is `@key randomness` that should be used to indicate that a test is using randomness - i.e. is intentionally non-deterministic.\n+\n+There are many other keywords in use and their usage may differ between areas in the JDK. Make sure you understand the conventions for the particular area you are testing since these are just examples.\n+\n+The [JTReg documentation](https:\/\/openjdk.java.net\/jtreg\/) provides information on many more tags like these.\n+\n+The [compiler group](https:\/\/openjdk.java.net\/groups\/compiler\/) has a section in their wiki with [Guidelines for \"langtools\" tests](https:\/\/openjdk.java.net\/groups\/compiler\/tests.html).\n+\n+### Running OpenJDK JTReg Tests\n+\n+When configuring the OpenJDK build you can tell it where your JTReg installation is located. When providing this information you can later run `make run-test` to execute JTReg tests.\n+\n+    sh .\/configure --with-jtreg=\/path\/to\/jtreg\n+    make run-test TEST=tier1\n+\n+In the OpenJDK source tree you can find a directory called `test`. There are a large number of tests in this directory that are written to be used with JTReg.\n+\n+    make run-test TEST=test\/jdk\/java\/lang\/String\/\n+\n+You can also run JTReg without invoking make. In this case you’ll need to tell JTReg which JDK to test.\n+\n+    jtreg -jdk:\/path\/to\/jdk \/path\/to\/test\n+\n+## GTest\n+\n+As mentioned the Google test framework is mainly used for C++ unit tests. There are several of these in the `test\/hotspot` directory. Currently, only the C++ code in the JVM area is supported by the OpenJDK GTest framework. The tests can be run without starting the JVM, which enables testing of JVM data structures that would be fragile to play with in a running JVM.\n+\n+    static int demo_comparator(int a, int b) {\n+      if (a == b) {\n+        return 0;\n+      }\n+      if (a < b) {\n+        return -1;\n+      }\n+      return 1;\n+    }\n+\n+    TEST(Demo, quicksort) {\n+      int test_array[] = {7,1,5,3,6,9,8,2,4,0};\n+      int expected_array[] = {0,1,2,3,4,5,6,7,8,9};\n+\n+      QuickSort::sort(test_array, 10, demo_comparator, false);\n+      for (int i = 0; i < 10; i++) {\n+        ASSERT_EQ(expected_array[i], test_array[i]);\n+      }\n+    }\n+\n+`ASSERT_EQ` is one example of an assertion that can be used in the test. Below are a few other examples. A full list is found in the [Google Test Documentation](https:\/\/github.com\/google\/googletest\/blob\/master\/googletest\/docs\/primer.md).\n+\n+    ASSERT_TRUE(condition);\n+    ASSERT_FALSE(condition);\n+    EXPECT_EQ(expected, actual);\n+    EXPECT_LT(val1, val2);\n+    EXPECT_STREQ(expected_str, actual_str);\n+\n+`ASSERT` is a fatal assertion and will interrupt execution of the current sub-routine. `EXPECT` is a nonfatal assertion and will report the error but continues to run the test. All assertions have both an `ASSERT` and an `EXPECT` variant.\n+\n+For more information on how to write good GTests in HotSpot, see [`doc\/hotspot-unit-tests.md`](https:\/\/github.com\/openjdk\/jdk\/blob\/master\/doc\/hotspot-unit-tests.md).\n+\n+### Running OpenJDK GTests\n+\n+When configuring the OpenJDK build you can tell it where your GTest installation is located. Once configured, use make to run GTests.\n+\n+    sh .\/configure --with-gtest=\/path\/to\/gtest\n+    make test TEST=gtest\n+\n+You can also use a regular expression to filter which tests to run:\n+\n+    make test TEST=gtest:code.*:os.*\n+    make test TEST=gtest:$X\/$variant\n+\n+The second example above runs tests which match the regexp `$X.*` on a specific variant of the JVM. The variant is one of client, server, etc.\n+\n","filename":"src\/index.md","additions":135,"deletions":0,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-% Testing Changes\n+% Page moved\n@@ -3,17 +3,1 @@\n-::: {.NavBit}\n-[« Previous](reviewBodies.html) • [TOC](index.html) • [Next »](jckAcquisition.html)\n-:::\n-\n-This section will describe the need for tests and will provide an engineering\n-perspective to the different kinds of test suites, including regression tests\n-as run by the [jtreg harness](..\/jtreg\/) and JCK\n-tests. Characteristics of a good regression test will be provided.\n-\n-<!--\n- See also the <a href=\"https:\/\/openjdk.java.net\/groups\/quality\/\">OpenJDK\n-Quality Group<\/a>. \n--->\n-\n-::: {.NavBit}\n-[« Previous](reviewBodies.html) • [TOC](index.html) • [Next »](jckAcquisition.html)\n-:::\n+The OpenJDK Developers' Guide has been merged into a single document. Please update your links to point to the new location: [OpenJDK Developers' Guide](index.html)\n","filename":"src\/testingChanges.md","additions":2,"deletions":18,"binary":false,"changes":20,"status":"modified"}]}