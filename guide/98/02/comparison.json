{"files":[{"patch":"@@ -12,6 +12,0 @@\n-[**forest**]{#forest}\n-:   A collection of Mercurial repositories which can be managed as a set of nested repositories. The name \"Forest\" originally came from the Mercurial \"Forest Extension\" which can be used with some versions of Mercurial, but in general is no longer recommended. The script `common\/bin\/hgforest.sh` can be used to apply a Mercurial `hg` command to all the repositories in a forest.\n-\n-[**repository**]{#repository}\n-:   A directory tree in the filesystem that Mercurial treats specially. This tree contains the source files and their revision history.\n-\n@@ -21,3 +15,0 @@\n-[**webrev**]{#webrev}\n-:   A tool and its output. In JDK release forests, the script, [`webrev.ksh`](https:\/\/hg.openjdk.java.net\/code-tools\/webrev\/raw-file\/tip\/webrev.ksh), examines a forest or repository to generate a set of web-based views of differences.\n-\n","filename":"src\/guide\/glossary.md","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3,0 +3,5 @@\n+See [Working With Pull Requests](#working-with-pull-requests) for generic guidance and requirements around pushing changes. For the HotSpot codebase there are a few additional requirements:\n+\n+* Your change must have been approved by two reviewers out of which at least one is also a Reviewer\n+* Your change must have passed through HotSpot tier 1 testing with zero failures (See tier1 definition in `test\/hotspot\/jtreg\/TEST.groups`.)\n+\n","filename":"src\/guide\/hotspot-development.md","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -15,1 +15,1 @@\n-In general all changes should come with a regression test so if you're writing product code you should also be writing test code. There are a few examples where it doesn't make sense to write an explicit regression test. These should be tagged in JBS with one of the [noreg-labels](#noreg).\n+Please note that what's mentioned later in this section, like [GHA](#github-actions) and tier 1 testing, will only run a set of smoke-tests to ensure your change compiles and runs on a variety of platforms. They won't do any targeted testing on the particular code you have changed. You must always make sure your change works as expected before pushing, using targeted testing. In general all changes should come with a regression test, so if you're writing product code you should also be writing test code. Including the new tests (in the right places) in your change will ensure your tests will be run as part of your testing on all platforms and in the future.\n@@ -27,0 +27,2 @@\n+There are a few examples where it doesn't make sense to write an explicit regression test. These should be tagged in JBS with one of the [noreg-labels](#noreg).\n+\n@@ -170,0 +172,10 @@\n+## GitHub actions\n+\n+GitHub has a feature called **GitHub actions** (GHA) that can be used to automate testing. The GHA is executed whenever a push is made to a branch in your repository. The bots will show the results of the GHA in your PR when you create or update it. The GHA in the JDK project is configured to run a set of tests that is commonly known as **tier 1**. This is a relatively fast, small set of tests that tries to verify that your change didn't break the JDK completely. In tier 1 the JDK is built on a small set of platforms including (but not necessarily limited to) Linux, Windows, and MacOS, and a few tests are executed using these builds. There's also a set of other platforms for which GHA does cross-complilation builds.\n+\n+In addition to the testing you run manually before publishing your changes, it's recommended that you take advantage of this automated testing that the GHA offers. This will for instance allow you to run tests on platforms that you may not otherwise have access to. To enable this on your personal fork of the JDK on GitHub go to the \"Actions\" tab and click the big green button saying \"I understand my workflows, go ahead and enable them\". If you don't understand these workflows there's a link to the actual file that describes them right below the green button.\n+\n+In case of failures in the GHA it's always a good start to try to reproduce the failure locally on a machine where you have better control and easier access to a debug environment. There have been cases where the GHA has failed due to issues unrelated to the change being tested, e.g. because the GHA environment was updated and changes were needed to the JDK GHA configuration. The configuration is in general updated fairly quickly, so in cases were you can't reproduce the failure locally, consider re-running the GHA later.\n+\n+Please keep in mind that the tier 1 tests run by the GHA should only be seen as a smoke test that finds the most critical breakages, like build errors or if the JDK is DOA. These tests can never replace the targeted testing that you always must do on your changes. There are several areas of the JDK that aren't part of tier 1 at all. To see exactly what tier 1 includes, please see the various TEST.groups files that you will find in the subdirectories of [`jdk\/test\/`](https:\/\/github.com\/openjdk\/jdk\/tree\/master\/test).\n+\n@@ -174,1 +186,1 @@\n-I'll say it right away so that it's not forgotten at the end: Remember to remove the JBS id from the ProblemList or the test when the bug is closed. This is especially easy to forget if a bug is closed as a duplicate or 'Will Not Fix'. jcheck will report an error and prohibit a push if a PR is created for an issue that is found in a ProblemList if the fix doesn't remove the bug ID from the ProblemList.\n+Remember to remove the JBS id from the ProblemList or the test when the bug is closed. This is especially easy to forget if a bug is closed as a duplicate or 'Will Not Fix'. jcheck will report an error and prohibit a push if a PR is created for an issue that is found in a ProblemList if the fix doesn't remove the bug ID from the ProblemList.\n@@ -283,10 +295,0 @@\n-## GitHub actions\n-\n-GitHub has a feature called **GitHub actions** (GHA) that can be used to automate testing. The GHA is executed whenever a push is made to a branch in your repository. The bots will show the results of the GHA in your PR when you create or update it. The GHA in the JDK project is configured to run a set of tests that is commonly known as **tier 1**. This is a relatively fast, small set of tests that tries to verify that your change didn't break the JDK completely. In tier 1 the JDK is built on a small set of platforms including (but not necessarily limited to) Linux, Windows, and MacOS, and a few tests are executed using these builds.\n-\n-In addition to the testing you run manually before publishing your changes, it's recommended that you take advantage of this automated testing that the GHA offers. This will for instance allow you to run tests on platforms that you may not otherwise have access to. To enable this on your personal fork of the JDK on GitHub go to the \"Actions\" tab and click the big green button saying \"I understand my workflows, go ahead and enable them\". If you don't understand these workflows there's a link to the actual file that describes them right below the green button.\n-\n-In case of failures in the GHA it's always a good start to try to reproduce the failure locally on a machine where you have better control and easier access to a debug environment. There have been cases where the GHA has failed due to issues unrelated to the change being tested, e.g. because the GHA environment was updated and changes were needed to the JDK GHA configuration. The configuration is in general updated fairly quickly, so in cases were you can't reproduce the failure locally, consider re-running the GHA later.\n-\n-Please keep in mind that the tier 1 tests run by the GHA should only be seen as a smoke test that finds the most critical breakages, like build errors or if the JDK is DOA. These tests can never replace the targeted testing that you always must do on your changes. There are several areas of the JDK that aren't part of tier 1 at all. To see exactly what tier 1 includes, please see the various TEST.groups files that you will find in the subdirectories of [`jdk\/test\/`](https:\/\/github.com\/openjdk\/jdk\/tree\/master\/test).\n-\n","filename":"src\/guide\/testing-the-jdk.md","additions":14,"deletions":12,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-* Did you run all relevant tests on the final version of the change? (Yes, I mean final! If you only knew how many times people _only changed a comment_ and caused a build failure.)\n+* Did you run a full build and all relevant tests on the **final** version of the change? It's important to do this on the truly final version, as even an apparently trivial change in a comment can break the build.\n@@ -37,1 +37,1 @@\n-If you have an actual reason to create a PR before the change is all done, make sure to create it in `DRAFT` mode. The bot won't add the `rfr` label or send emails as long as the PR is in `DRAFT` mode.\n+If you have an actual reason to create a PR before the change is all done, make sure to create it in `DRAFT` mode. The bot won't add the `rfr` label or send emails to labeled groups as long as the PR is in `DRAFT` mode.\n@@ -87,0 +87,4 @@\n+#. **After integration**\n+\n+   After you have integrated your change you are expected to stay around in case there are any issues with it. As mentioned above, you are expected to have run all relevant testing on your change before creating your PR, but regardless of how thorough you test it, things might slip through. After your change has been integrated an automatic pipeline of tests is triggered and your change will be tested on a variety of platforms and in a variety of different modes that the JDK can be executed in. A change that causes failures in later testing may be backed out if a fix can not be provided fast enough, or if the developer is not responsive when noticed about the failure. Note that this directive should be interpreted as \"it is a really bad idea to push a change the last thing you do before bedtime, or the day before going on vacation\".\n+\n","filename":"src\/guide\/working-with-pull-requests.md","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"}]}