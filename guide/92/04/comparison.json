{"files":[{"patch":"@@ -26,1 +26,1 @@\n-> :    General discussions around the project. The special case `discuss@openjdk.org` is used for general discussions around OpenJDK. Discussions around new project proposals usually happens here.\n+> :    General discussions around the project. The special case `discuss@openjdk.org` is used for general discussions around OpenJDK. Discussions around new project proposals usually happen here.\n","filename":"src\/guide\/mailing-lists.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,137 @@\n+# Project Maintenance\n+\n+Many OpenJDK projects build on top of the JDK source code for instance to produce new language features, like projects [Amber](https:\/\/openjdk.org\/projects\/amber\/) and [Valhalla](https:\/\/openjdk.org\/projects\/valhalla\/). When doing this there are a number of common workflows that are dealt with by most project maintainers. For instance, updating the codebase (merging) to bring in the latest changes from the upstream JDK project.\n+\n+## Merging JDK mainline into a project repository\n+\n+Merging changes from one git repository to another is basically the same thing as getting your own changes merged into the project repository, with the slight twist that you don't write all the changes yourself, you just pull them from somewhere else.\n+\n+In this example we'll use a separate clone of the project repository to perform the merge in. This can be done using branches as well, but let's keep it simple for now.\n+\n+### Init - done once\n+\n+First set up your personal fork of the project repository, in this example called `my-project`. If you already are a contributor to the project you most likely have this set up. If not, see [Cloning the JDK](#cloning-the-jdk) for details on how to do that.\n+\n+~~~shell\n+git clone git@github.com:OpenDuke\/my-project.git project-merge\n+cd project-merge\n+git remote add upstream git@github.com:openjdk\/my-project.git\n+git remote add mainline git@github.com:openjdk\/jdk.git\n+~~~\n+\n+We clone the personal fork (in this case we clone OpenDuke's personal fork) into a local directory, here called `project-merge`. We then set up two remotes, `upstream` and `mainline`.\n+\n+### Performing the merge\n+\n+The clone we set up above is used each time you want to bring changes from mainline in to your project. This is done by first pulling the changes from mainline and then pushing to your personal fork. A regular PR will then be created which you can integrate into your main project repository. It sounds easy, and it is, but there are a few details below to keep in mind.\n+\n+~~~shell\n+cd project-merge\n+git pull upstream master\n+git push\n+git switch -c Merge_mainline\n+git fetch mainline\n+~~~\n+\n+We start by updating the local fork with the latest changes from the main project repository. Note that we then create a new branch \"`Merge_mainline`\" in which the merge will happen. Finally we fetch all new changes from mainline.\n+\n+Merging from what ever is latest isn't usually a good idea, mainline code is not \"clean\" for any given commit. Merging JDK tags ensures you have a known quality, those tagged commits are known to compile and pass tests. Therefore, next we check which tags have not been merged yet.\n+\n+~~~shell\n+git tag -l \"jdk-*\" --no-merged\n+~~~\n+\n+Or if you just want to see the latest tag you haven't merged,\n+\n+~~~shell\n+git tag -l \"jdk-*\" --no-merged | tail --lines 1\n+~~~\n+\n+Before merging, you may want to check what's incoming, to get an idea of the size of the merge and look for any incoming changes that you suspect may cause issues.\n+\n+~~~shell\n+git log --topo-order --pretty=oneline --reverse ..$TAG\n+~~~\n+\n+And finally we initiate the actual merge.\n+\n+~~~shell\n+git merge $TAG\n+~~~\n+\n+The commands above will likely run without a hitch up until the final `git merge`. This is where you need to combine the changes that were made in mainline with the changes that have been made in your project repository. If there are no conflicts you're in luck, then the merge will be completely automated and you will end up with a committed merge. If there are conflicts however you'll need to manually go through the files where the conflicts are and make sure you select the correct version for each change. Using `git status` you can see what files that need to be merged. Depending on how much code your project has touched, this can be quite a bit of work.\n+\n+For complicated merges, see [Sharing the work](#sharing-the-work) below.\n+\n+### Test before push\n+\n+Regardless of if you encountered conflicts or not, you should always build and test your merge before pushing it to your project repository. Testing needs to be done even when there are no textual conflicts as changes like for instance a rename can result in a compile or test error without any conflict. One could argue that `git merge --no-commit` could be used and have logical errors fixed in the merge commit. However, a subsequent \"Fix logical merge errors\" commit, is in fact more useful, as it clearly shows the project specific adjustments needed for incoming changes.\n+\n+It's always okay to have further commits to clean up after a merge. Hiding a large amount of reworking project code to fit with upstream changes in a single merge commit will make it hard for further errors post integration to be identified.\n+\n+### The commit, push, and PR\n+\n+Once you have a working version of your merged code you're ready to create the merge commit and push. Please note that `git commit` is only needed if there were conflicts. If the changes were successfully merged by `git merge`, you already have a committed merge.\n+\n+~~~\n+git commit -m \"Merge\"\n+git push --set-upstream origin Merge_mainline\n+~~~\n+\n+Now it's time to create the PR on GitHub. Just opening the PR page in your browser will most often be enough to see a message about new code that was pushed to your personal fork. Click the button to create the PR.\n+\n+Make sure the PR title starts with \"Merge\". You may have noticed that when you integrate a \"normal\" PR into an OpenJDK repository, all commits that have been done in that PR will be squashed into a single commit. For normal changes this is a good thing as each PR normally corresponds to a single JBS issue, but for a merge it would be highly undesirable to squash all the different commits that you pull in from mainline. A PR with a title that starts with \"Merge\" won't be squashed. That means that all the changes that you brought over will remain separate changes.\n+\n+It's always a good idea to also include what was merged in the title of the PR. If you for instance is pulling in JDK mainline into your project repository it's likely (because it's in general a good idea) that you choose some stable EA tag in mainline to merge. Your PR title could then be something like \"Merge jdk-21+2\".\n+\n+Whether a merge requires a review or not is up to your project lead to decide. Many projects don't require this so the GitHub bots will allow you to push the merge as soon as the [GHA](#github-actions)s are done. (They actually allow you to push even before the GHAs are done, but that's in general not a good idea.)\n+\n+Once the PR has been integrated, you can clean up your fork and its clone in preparation for the next merge.\n+\n+~~~\n+git switch master\n+git branch -d Merge_mainline\n+git push -d origin Merge_mainline\n+~~~\n+\n+These commands will remove the temporary branch that we created to perform the merge. There's a button in the GitHub GUI to delete the branch after you have integrated the PR. This can be used instead of the last of the three commands above (`git push -d...`).\n+\n+### Sharing the work\n+\n+When conflicts take place in areas requiring specialized knowledge you may need help from other contributors. Backing up the original conflicts will help if you find yourself \"in too deep\", and need assistance from other contributors. You can add and later remove these backups, along with a readme describing the merge status, to the actual merge branch to aid communication (i.e. you may not be able to compile certain components).\n+\n+Something like the following shell one-liner can be used to perform the backup.\n+\n+~~~shell\n+git status | grep \"both modified:\" | while read B M FILE; do cp -v $FILE $DEST ; done\n+~~~\n+\n+Below are two different methods of collaborating on a merge described. Please note that extra commits are fine. The merge PR itself will describe any special actions that were taken in case further failures turn up after merge integration. Ultimately these commits will be squashed when integrating the project back into mainline.\n+\n+#### 1. Parking a merge with conflicts in place\n+\n+\"Park\" the conflicts, unresolved, in a personal fork, and let others do the further work (by sending you a patch, or opening your personal fork up to push from other contributors). Do this by keeping a list of unresolved conflicts (perhaps checking in said list to describe the merge state), and then marking them as resolved in git, committing, and pushing them to your personal fork. E.g. `git add $UNRESOLVED_FILES; git commit; git push`\n+\n+**Pros:** All unresolved conflicts are stated and can be worked on by multiple parties, all at once.\n+\n+**Cons:** Broken branch in terms of compile and test, may require temporary workaround patches to be passed around to complete work on specific unresolved components.\n+\n+#### 2. Incremental merging\n+\n+An alternative to parking a merge with conflicts in place, is to incrementally merge up to the troublesome point. For example:\n+\n+* Perform the initial merge: `git merge $TAG`\n+* Find yourself in trouble, identify which change is causing the issue.\n+* Abort: `git merge --abort`\n+* Find the troublesome change: `git log --topo-order --pretty=oneline --reverse $(current_branch)..$TAG`\n+* Merge up to the previous change, commit and push.\n+* Ask others to continue the merge from the troubled change forward, how far forward is up you of course, either just that troublesome change, or the rest of the merge up to the $TAG.\n+* Rinse and repeat: There may appear further conflicts requiring other contributors help.\n+\n+**Pros:** All commits in the merge branch compile and test, you always have a working branch.\n+\n+**Cons:** There is an unknown extra amount of merge work, multiple iterations create more work. For instance you may find yourself resolving the same files multiple times (e.g. back-out commits).\n+\n+::: {.box}\n+[To the top](#){.boxheader}\n+:::\n","filename":"src\/guide\/project-maintenance.md","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -61,1 +61,1 @@\n-@requires os.family != ”windows”\n+@requires os.family != \"windows\"\n","filename":"src\/guide\/testing-the-jdk.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-:    The ramp down of a release starts with a fork of the mainline repository. A clone of the entire code base is made and hosted in a separate ramp down repository (e.g. [openjdk\/jdk17](https:\/\/github.com\/openjdk\/jdk17)). During the ramp down of a release we focus on bug fixing and stabilization in order to get the JDK ready for release. In RDP1 you may continue to fix P1-P3 product bugs (and some other issues) in the stabilization repo. For detailed information on what can be fixed when, see [JEP 3](https:\/\/openjdk.org\/jeps\/3). The start of RDP1 is essentially the deadline for integrating JEPs and enhancements into this particular release.\n+:    The ramp down of a release starts with a fork of the mainline repository. A clone of the entire code base is made and hosted in a separate ramp down repository (e.g. [openjdk\/jdk17](https:\/\/github.com\/openjdk\/jdk17)). During the ramp down of a release we focus on bug fixing and stabilization in order to get the JDK ready for release. In RDP1 you may continue to fix P1-P3 product bugs (and some other issues) in the stabilization repo. For detailed information on what can be fixed when, see [Push or defer](#push-or-defer-during-rampdown) below. The start of RDP1 is essentially the deadline for integrating JEPs and enhancements into this particular release.\n@@ -33,1 +33,1 @@\n-:    In RDP2 the bar is higher to get changes into the release. For product bugs, only P1:s and P2:s are supposed to be fixed here, and to do so an approval is needed. See the [Fix-Request Process](https:\/\/openjdk.org\/jeps\/3#Fix-Request-Process) for details on how to obtain one. All other product bugs should be deferred. Again, see [JEP 3](https:\/\/openjdk.org\/jeps\/3) for more details.\n+:    In RDP2 the bar is higher to get changes into the release. For product bugs, only P1:s and P2:s are supposed to be fixed here, and to do so an approval is needed. See the [Fix-Request Process](https:\/\/openjdk.org\/jeps\/3#Fix-Request-Process) for details on how to obtain one. All other product bugs should be deferred. See [Push or defer](#push-or-defer-during-rampdown) below for more details.\n@@ -41,0 +41,6 @@\n+### Push or defer during rampdown\n+\n+[JEP 3](https:\/\/openjdk.org\/jeps\/3) contains the exact definitions for what can be done when. This is a visualization of those definitions that may or may not clarify things.\n+\n+![Push and defer guidelines during rampdown](push-defer.png)\n+\n","filename":"src\/guide\/the-jdk-release-process.md","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -75,0 +75,2 @@\n+   If you want to update the title of the PR, remember that the one and only truth is the JBS issue, so the title must first be changed there.\n+\n","filename":"src\/guide\/working-with-pull-requests.md","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"filename":"src\/push-defer.png","binary":true,"status":"added"},{"patch":"@@ -14,0 +14,2 @@\n+the-jdk-release-process.md\n+project-maintenance.md\n@@ -16,1 +18,0 @@\n-the-jdk-release-process.md\n","filename":"src\/toc.conf","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}