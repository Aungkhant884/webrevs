{"files":[{"patch":"@@ -3,1 +3,1 @@\n-Many OpenJDK projects build on top of the JDK source code. When doing this there are a number of common workflows that are dealt with by most project maintainers. For instance updating the code (merging) to bring in the latest changes from the upstream JDK project.\n+Many OpenJDK projects build on top of the JDK source code for instance to produce new language features, like projects [Amber](https:\/\/openjdk.org\/projects\/amber\/) and [Valhalla](https:\/\/openjdk.org\/projects\/valhalla\/). When doing this there are a number of common workflows that are dealt with by most project maintainers. For instance, updating the codebase (merging) to bring in the latest changes from the upstream JDK project.\n@@ -15,1 +15,1 @@\n-~~~\n+~~~shell\n@@ -28,1 +28,1 @@\n-~~~\n+~~~shell\n@@ -39,1 +39,9 @@\n-The commands above will likely run without a hitch up until the `git merge`. This is where you need to combine the changes that were made in mainline with the changes that have been made in your project repository. If there are no conflicts you're in luck, then the merge will be completely automated and you will end up with a commit ready to push. If there are conflicts however you'll need to manually go through the files where the conflicts are and make sure you select the correct version for each change. Using `git status` you can see what files that need to be merged. Depending on how much code your project has touched this can be quite a bit of work.\n+The commands above will likely run without a hitch up until the `git merge`. This is where you need to combine the changes that were made in mainline with the changes that have been made in your project repository. If there are no conflicts you're in luck, then the merge will be completely automated and you will end up with a committed merge. If there are conflicts however you'll need to manually go through the files where the conflicts are and make sure you select the correct version for each change. Using `git status` you can see what files that need to be merged. Depending on how much code your project has touched, this can be quite a bit of work.\n+\n+For complicated merges, see [Sharing the work](#sharing-the-work) below.\n+\n+### Test before push\n+\n+Regardless of if you encountered conflicts or not, you should always build and test your merge before pushing it to your project repository. Testing needs to be done even when there are no textual conflicts as changes like for instance a rename can result in a compile or test error without any conflict. One could argue that `git merge --no-commit` could be used and have logical errors fixed in the merge commit. However, a subsequent \"Fix logical merge errors\" commit, is in fact more useful, as it clearly shows the project specific adjustments needed for incoming changes.\n+\n+It's always okay to have further commits to clean up after a merge. Hiding a large amount of reworking project code to fit with upstream changes in a single merge commit will make it hard for further errors post integration to be identified.\n@@ -41,1 +49,3 @@\n-Once you have a working version of your merged code (make sure you test it properly) you're ready to create the commit and push. Please note that `git commit` is only needed if there were conflicts. If the changes were successfully merged by `git merge`, you're already ready to push.\n+### The commit\n+\n+Once you have a working version of your merged code you're ready to create the merge commit and push. Please note that `git commit` is only needed if there were conflicts. If the changes were successfully merged by `git merge`, you already have a committed merge.\n@@ -64,0 +74,37 @@\n+\n+### Sharing the work\n+\n+When conflicts take place in areas requiring specialized knowledge you may need help from other contributors. Backing up the original conflicts will help if you find yourself \"in too deep\", and need assistance from other contributors. You can add and later remove these backups, along with a readme describing the merge status, to the actual merge branch to aid communication (i.e. you may not be able to compile certain components).\n+\n+Something like the following shell one-liner can be used to perform the backup.\n+\n+~~~shell\n+git status | grep \"both modified:\" | while read B M FILE; do cp -v $FILE $DEST ; done\n+~~~\n+\n+Below are two different methods of collaborating on a merge described. Please note that extra commits are fine. The merge PR itself will describe any special actions that were taken in case further failures turn up after merge integration. Ultimately these commits will be squashed when integrating the project back into mainline.\n+\n+#### Parking a merge with conflicts in place\n+\n+\"Park\" the conflicts, unresolved, in a personal fork, and let others do the further work (by sending you a patch, or opening your personal fork up to push from other contributors). Do this by keeping a list of unresolved conflicts (perhaps checking in said list to describe the merge state), and then marking them as resolved in git, committing, and pushing them to your personal fork. E.g. `git add $UNRESOLVED_FILES; git commit; git push`\n+\n+**Pros:** all unresolved conflicts are stated and can be worked on by multiple parties, all at once.\n+\n+**Cons:** broken branch in terms of compile and test, may require temporary workaround patches to be passed around to complete work on specific unresolved components.\n+\n+#### Incremental merging\n+\n+An alternative to parking a merge with conflicts in place, is to incrementally merge up to the troublesome point. For example:\n+\n+* Perform the initial merge: `git merge $TAG`\n+* Find yourself in trouble, identify which change is causing the issue.\n+* Abort: `git merge --abort`\n+* Find the troublesome change: `git log --topo-order --pretty=oneline --reverse $(current_branch)..$TAG`\n+* Merge up to the previous change, commit and push.\n+* Ask others to continue the merge from the troubled change forward, how far forward is up you of course, either just that troublesome change, or the rest of the merge up to the $TAG.\n+* Rinse and repeat: There may appear further conflicts requiring other contributors help.\n+\n+**Pros:** all commits in the merge branch compile and test, you always have a working branch.\n+\n+**Cons:** there is an unknown extra amount of merge work, multiple iterations create more work. For instance you may find yourself resolving the same files multiple times (e.g. back-out commits).\n+\n","filename":"src\/guide\/project-maintenance.md","additions":52,"deletions":5,"binary":false,"changes":57,"status":"modified"}]}