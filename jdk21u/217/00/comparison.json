{"files":[{"patch":"@@ -1012,1 +1012,1 @@\n-  if (!JvmtiExport::can_support_virtual_threads()) {\n+  if (get_capabilities()->can_support_virtual_threads == 0) {\n@@ -1130,1 +1130,1 @@\n-  if (!JvmtiExport::can_support_virtual_threads()) {\n+  if (get_capabilities()->can_support_virtual_threads == 0) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"runtime\/mutexLocker.hpp\"\n@@ -58,0 +59,4 @@\n+int JvmtiManageCapabilities::_can_support_virtual_threads_count = 0;\n+\n+Mutex* JvmtiManageCapabilities::_capabilities_lock = nullptr;\n+\n@@ -59,0 +64,1 @@\n+  _capabilities_lock = new Mutex(Mutex::nosafepoint, \"Capabilities_lock\");\n@@ -214,0 +220,6 @@\n+Mutex* JvmtiManageCapabilities::lock() {\n+  if (Thread::current_or_null() == nullptr) {\n+    return nullptr;  \/\/ Detached thread, can be a call from Agent_OnLoad.\n+  }\n+  return _capabilities_lock;\n+}\n@@ -215,1 +227,1 @@\n-void JvmtiManageCapabilities::get_potential_capabilities(const jvmtiCapabilities *current,\n+void JvmtiManageCapabilities::get_potential_capabilities_nolock(const jvmtiCapabilities *current,\n@@ -234,0 +246,7 @@\n+void JvmtiManageCapabilities::get_potential_capabilities(const jvmtiCapabilities* current,\n+                                                         const jvmtiCapabilities* prohibited,\n+                                                         jvmtiCapabilities* result) {\n+  MutexLocker ml(lock(), Mutex::_no_safepoint_check_flag);\n+  get_potential_capabilities_nolock(current, prohibited, result);\n+}\n+\n@@ -238,0 +257,2 @@\n+  MutexLocker ml(lock(), Mutex::_no_safepoint_check_flag);\n+\n@@ -240,1 +261,1 @@\n-  get_potential_capabilities(current, prohibited, &temp);\n+  get_potential_capabilities_nolock(current, prohibited, &temp);\n@@ -262,0 +283,4 @@\n+  if (desired->can_support_virtual_threads != 0 && current->can_support_virtual_threads == 0) {\n+    _can_support_virtual_threads_count++;\n+  }\n+\n@@ -274,0 +299,2 @@\n+  MutexLocker ml(lock(), Mutex::_no_safepoint_check_flag);\n+\n@@ -286,0 +313,6 @@\n+  if (to_trash.can_support_virtual_threads != 0) {\n+    assert(current->can_support_virtual_threads != 0, \"sanity check\");\n+    assert(_can_support_virtual_threads_count > 0, \"sanity check\");\n+    _can_support_virtual_threads_count--;\n+  }\n+\n@@ -369,1 +402,1 @@\n-  JvmtiExport::set_can_support_virtual_threads(avail.can_support_virtual_threads);\n+  JvmtiExport::set_can_support_virtual_threads(_can_support_virtual_threads_count != 0);\n","filename":"src\/hotspot\/share\/prims\/jvmtiManageCapabilities.cpp","additions":36,"deletions":3,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,6 @@\n+  \/\/ counter for the agents possess can_support_virtual_threads capability\n+  static int _can_support_virtual_threads_count;\n+\n+  \/\/ lock to access the class data\n+  static Mutex* _capabilities_lock;\n+\n@@ -64,0 +70,8 @@\n+  \/\/ returns nullptr in onload phase\n+  static Mutex* lock();\n+\n+  \/\/ get_potential_capabilities without lock\n+  static void get_potential_capabilities_nolock(const jvmtiCapabilities* current,\n+                                                const jvmtiCapabilities* prohibited,\n+                                                jvmtiCapabilities* result);\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiManageCapabilities.hpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"}]}