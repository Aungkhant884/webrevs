{"files":[{"patch":"@@ -646,1 +646,2 @@\n-          set_live_gen_kill(value, op, live_gen, live_kill)\n+          set_live_gen_kill(value, op, live_gen, live_kill);\n+          local_has_fpu_registers = local_has_fpu_registers || value->type()->is_float_kind();\n@@ -1659,2 +1660,2 @@\n-  Interval* precolored_cpu_intervals, *not_precolored_cpu_intervals;\n-  Interval* precolored_fpu_intervals, *not_precolored_fpu_intervals;\n+  Interval* precolored_cpu_intervals = Interval::end(), *not_precolored_cpu_intervals = Interval::end();\n+  Interval* precolored_fpu_intervals = Interval::end(), *not_precolored_fpu_intervals = Interval::end();\n@@ -1662,1 +1663,1 @@\n-  \/\/ allocate cpu registers\n+  \/\/ collect cpu intervals\n@@ -1666,1 +1667,1 @@\n-  \/\/ allocate fpu registers\n+  \/\/ collect fpu intervals\n@@ -1669,2 +1670,1 @@\n-\n-  \/\/ the fpu interval allocation cannot be moved down below with the fpu section as\n+  \/\/ this fpu interval collection cannot be moved down below with the allocation section as\n@@ -1673,0 +1673,1 @@\n+  \/\/ allocate cpu registers\n@@ -1678,0 +1679,1 @@\n+    \/\/ allocate fpu registers\n@@ -1681,0 +1683,8 @@\n+  } else {\n+#ifdef ASSERT\n+    assert(not_precolored_fpu_intervals == Interval::end(), \"missed an uncolored fpu interval\");\n+#else\n+    if (not_precolored_fpu_intervals != Interval::end()) {\n+      BAILOUT(\"missed an uncolored fpu interval\");\n+    }\n+#endif\n","filename":"src\/hotspot\/share\/c1\/c1_LinearScan.cpp","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8268366\n+ * @run main\/othervm -Xbatch -XX:+TieredCompilation -XX:TieredStopAtLevel=1\n+ *                   compiler.c1.TestLinearScanHasFPURegisters\n+ *\/\n+\n+package compiler.c1;\n+\n+public class TestLinearScanHasFPURegisters {\n+    void test(String[] args) {\n+        String arr[] = new String[4];\n+        float f = -1;\n+        try {\n+            arr[0] = \"-1\"; \/\/ exception edge 1 with value -1\n+            if (args.length > 1) {\n+                f = 42;\n+                arr[1] = \"42\"; \/\/ exception edge 2 with value 42\n+            }\n+        } catch (Exception e) {\n+            \/\/ exception handler block with incoming phi for \"f\"\n+            for (int i = 0; i < 1; ++i) {\n+                f = f; \/\/ generates bytecodes, but no JIT IR\n+            }\n+        }\n+    }\n+    public static void main(String[] args) {\n+        TestLinearScanHasFPURegisters t = new TestLinearScanHasFPURegisters();\n+        for (int i = 0; i < 1000; ++i) {\n+            t.test(args);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/TestLinearScanHasFPURegisters.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"}]}