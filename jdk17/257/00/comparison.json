{"files":[{"patch":"@@ -2079,1 +2079,26 @@\n-\/\/Some convenience methods to deal with objects from java\n+static volatile int _emulated_lock = 0;\n+\n+WB_ENTRY(void, WB_LockAndBlock(JNIEnv* env, jobject wb, jboolean suspender))\n+  JavaThread* self = JavaThread::current();\n+\n+  {\n+    \/\/ Before trying to acquire the lock transition into a safepoint safe state.\n+    \/\/ Otherwise if either suspender or suspendee blocks for a safepoint\n+    \/\/ in ~ThreadBlockInVM the other one could loop forever trying to acquire\n+    \/\/ the lock without allowing the safepoint to progress.\n+    ThreadBlockInVM tbivm(self);\n+\n+    \/\/ We will deadlock here if we are 'suspender' and 'suspendee'\n+    \/\/ suspended in ~ThreadBlockInVM. This verifies we only suspend\n+    \/\/ at the right place.\n+    while (Atomic::cmpxchg(&_emulated_lock, 0, 1) != 0) {}\n+    assert(_emulated_lock == 1, \"Must be locked\");\n+\n+    \/\/ Sleep much longer in suspendee to force situation where\n+    \/\/ 'suspender' is waiting above to acquire lock.\n+    os::naked_short_sleep(suspender ? 1 : 10);\n+  }\n+  Atomic::store(&_emulated_lock, 0);\n+WB_END\n+\n+\/\/ Some convenience methods to deal with objects from java\n@@ -2569,0 +2594,1 @@\n+  {CC\"lockAndBlock\", CC\"(Z)V\",                        (void*)&WB_LockAndBlock},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+  bool is_suspend()                { return _handshake_cl->is_suspend(); }\n@@ -379,0 +380,1 @@\n+      \/\/ Will not suspend here.\n@@ -428,1 +430,5 @@\n-HandshakeOperation* HandshakeState::get_op_for_self() {\n+static bool no_suspend_filter(HandshakeOperation* op) {\n+  return !op->is_suspend();\n+}\n+\n+HandshakeOperation* HandshakeState::get_op_for_self(bool allow_suspend) {\n@@ -431,2 +437,6 @@\n-  return _queue.peek();\n-};\n+  if (allow_suspend) {\n+    return _queue.peek();\n+  } else {\n+    return _queue.peek(no_suspend_filter);\n+  }\n+}\n@@ -444,0 +454,5 @@\n+bool HandshakeState::has_a_non_suspend_operation() {\n+  MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n+  return _queue.contains(no_suspend_filter);\n+}\n+\n@@ -457,1 +472,1 @@\n-bool HandshakeState::process_by_self() {\n+bool HandshakeState::process_by_self(bool allow_suspend) {\n@@ -462,0 +477,1 @@\n+\n@@ -463,8 +479,4 @@\n-  {\n-    \/\/ Handshakes cannot safely safepoint.\n-    \/\/ The exception to this rule is the asynchronous suspension handshake.\n-    \/\/ It by-passes the NSV by manually doing the transition.\n-    NoSafepointVerifier nsv;\n-    return process_self_inner();\n-  }\n-}\n+  \/\/ Handshakes cannot safely safepoint.\n+  \/\/ The exception to this rule is the asynchronous suspension handshake.\n+  \/\/ It by-passes the NSV by manually doing the transition.\n+  NoSafepointVerifier nsv;\n@@ -472,1 +484,0 @@\n-bool HandshakeState::process_self_inner() {\n@@ -475,1 +486,2 @@\n-    HandshakeOperation* op = get_op_for_self();\n+\n+    HandshakeOperation* op = get_op_for_self(allow_suspend);\n@@ -624,0 +636,1 @@\n+  virtual bool is_suspend() { return true; }\n@@ -670,0 +683,1 @@\n+  JavaThread* self = JavaThread::current();\n@@ -672,0 +686,6 @@\n+  if (_handshakee == self) {\n+    \/\/ If target is the current thread we need to call this to do the\n+    \/\/ actual suspend since Handshake::execute() above only installed\n+    \/\/ the asynchronous handshake.\n+    SafepointMechanism::process_if_requested(self);\n+  }\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":34,"deletions":14,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+  virtual bool is_suspend()                        { return false; }\n@@ -95,7 +96,0 @@\n-  \/\/ Returns false if the JavaThread finished all its handshake operations.\n-  \/\/ If the method returns true there is still potential work to be done,\n-  \/\/ but we need to check for a safepoint before.\n-  \/\/ (This is due to a suspension handshake which put the JavaThread in blocked\n-  \/\/ state so a safepoint may be in-progress.)\n-  bool process_self_inner();\n-\n@@ -103,1 +97,1 @@\n-  HandshakeOperation* get_op_for_self();\n+  HandshakeOperation* get_op_for_self(bool allow_suspend);\n@@ -126,0 +120,1 @@\n+  bool has_a_non_suspend_operation();\n@@ -129,1 +124,4 @@\n-  bool process_by_self();\n+  \/\/ If the method returns true we need to check for a possible safepoint.\n+  \/\/ This is due to a suspension handshake which put the JavaThread in blocked\n+  \/\/ state so a safepoint may be in-progress.\n+  bool process_by_self(bool allow_suspend);\n","filename":"src\/hotspot\/share\/runtime\/handshake.hpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -246,0 +246,1 @@\n+  bool _allow_suspend;\n@@ -247,1 +248,2 @@\n-  ThreadBlockInVMPreprocess(JavaThread* thread, PRE_PROC& pr) : ThreadStateTransition(thread), _pr(pr) {\n+  ThreadBlockInVMPreprocess(JavaThread* thread, PRE_PROC& pr, bool allow_suspend = true)\n+    : ThreadStateTransition(thread), _pr(pr), _allow_suspend(allow_suspend) {\n@@ -260,1 +262,1 @@\n-    if (SafepointMechanism::should_process(_thread)) {\n+    if (SafepointMechanism::should_process(_thread, _allow_suspend)) {\n@@ -262,1 +264,1 @@\n-      SafepointMechanism::process_if_requested(_thread);\n+      SafepointMechanism::process_if_requested(_thread, _allow_suspend);\n@@ -292,1 +294,1 @@\n-    : _ifmr(in_flight_mutex_addr), _tbivmpp(thread, _ifmr) {}\n+    : _ifmr(in_flight_mutex_addr), _tbivmpp(thread, _ifmr, \/* allow_suspend= *\/ false) {}\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.inline.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -79,23 +79,0 @@\n-void SafepointMechanism::process(JavaThread *thread) {\n-  bool need_rechecking;\n-  do {\n-    if (global_poll()) {\n-      \/\/ Any load in ::block() must not pass the global poll load.\n-      \/\/ Otherwise we might load an old safepoint counter (for example).\n-      OrderAccess::loadload();\n-      SafepointSynchronize::block(thread);\n-    }\n-\n-    \/\/ The call to on_safepoint fixes the thread's oops and the first few frames.\n-    \/\/\n-    \/\/ The call has been carefully placed here to cater to a few situations:\n-    \/\/ 1) After we exit from block after a global poll\n-    \/\/ 2) After a thread races with the disarming of the global poll and transitions from native\/blocked\n-    \/\/ 3) Before the handshake code is run\n-    StackWatermarkSet::on_safepoint(thread);\n-\n-    need_rechecking = thread->handshake_state()->has_operation() && thread->handshake_state()->process_by_self();\n-\n-  } while (need_rechecking);\n-}\n-\n@@ -137,1 +114,1 @@\n-void SafepointMechanism::process_if_requested_slow(JavaThread *thread) {\n+void SafepointMechanism::process(JavaThread *thread, bool allow_suspend) {\n@@ -142,1 +119,20 @@\n-  process(thread);\n+  bool need_rechecking;\n+  do {\n+    if (global_poll()) {\n+      \/\/ Any load in ::block() must not pass the global poll load.\n+      \/\/ Otherwise we might load an old safepoint counter (for example).\n+      OrderAccess::loadload();\n+      SafepointSynchronize::block(thread);\n+    }\n+\n+    \/\/ The call to on_safepoint fixes the thread's oops and the first few frames.\n+    \/\/\n+    \/\/ The call has been carefully placed here to cater to a few situations:\n+    \/\/ 1) After we exit from block after a global poll\n+    \/\/ 2) After a thread races with the disarming of the global poll and transitions from native\/blocked\n+    \/\/ 3) Before the handshake code is run\n+    StackWatermarkSet::on_safepoint(thread);\n+\n+    need_rechecking = thread->handshake_state()->has_operation() && thread->handshake_state()->process_by_self(allow_suspend);\n+  } while (need_rechecking);\n+\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.cpp","additions":21,"deletions":25,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -53,2 +53,3 @@\n-  static void process(JavaThread *thread);\n-  static void process_if_requested_slow(JavaThread *thread);\n+  static void process(JavaThread *thread, bool allow_suspend);\n+\n+  static inline bool should_process_no_suspend(JavaThread* thread);\n@@ -63,1 +64,1 @@\n-public:\n+ public:\n@@ -82,1 +83,1 @@\n-  static inline bool should_process(JavaThread* thread);\n+  static inline bool should_process(JavaThread* thread, bool allow_suspend = true);\n@@ -85,1 +86,1 @@\n-  static inline void process_if_requested(JavaThread* thread);\n+  static inline void process_if_requested(JavaThread* thread, bool allow_suspend = true);\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.hpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/handshake.hpp\"\n@@ -64,2 +65,21 @@\n-bool SafepointMechanism::should_process(JavaThread* thread) {\n-  return local_poll_armed(thread);\n+bool SafepointMechanism::should_process_no_suspend(JavaThread* thread) {\n+  if (global_poll() || thread->handshake_state()->has_a_non_suspend_operation()) {\n+    return true;\n+  } else {\n+    \/\/ The poll is armed for a suspend request but we don't want to process it now. Since\n+    \/\/ a safepoint operation could have executed while the thread was safepoint safe we\n+    \/\/ need to possibly fix the thread's oops and first few frames before returning.\n+    StackWatermarkSet::on_safepoint(thread);\n+    update_poll_values(thread);\n+    OrderAccess::cross_modify_fence();\n+    return false;\n+  }\n+}\n+\n+bool SafepointMechanism::should_process(JavaThread* thread, bool allow_suspend) {\n+  if (!local_poll_armed(thread)) {\n+    return false;\n+  } else if (allow_suspend) {\n+    return true;\n+  }\n+  return should_process_no_suspend(thread);\n@@ -68,1 +88,1 @@\n-void SafepointMechanism::process_if_requested(JavaThread* thread) {\n+void SafepointMechanism::process_if_requested(JavaThread* thread, bool allow_suspend) {\n@@ -80,1 +100,1 @@\n-    process_if_requested_slow(thread);\n+    process(thread, allow_suspend);\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.inline.hpp","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test SuspendBlocked\n+ * @bug 8270085\n+ * @library \/testlibrary \/test\/lib\n+ * @build SuspendBlocked\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI SuspendBlocked\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import sun.hotspot.WhiteBox;\n+\n+public class SuspendBlocked {\n+\n+    public static void main(String... args) throws Exception {\n+        Thread suspend_thread = new Thread(() -> run_loop());\n+        suspend_thread.start();\n+        WhiteBox wb = WhiteBox.getWhiteBox();\n+        for (int i = 0; i < 100; i++) {\n+            suspend_thread.suspend();\n+            wb.lockAndBlock(\/* suspender= *\/ true);\n+            suspend_thread.resume();\n+            Thread.sleep(1);\n+        }\n+        suspend_thread.join();\n+    }\n+\n+    public static void run_loop() {\n+        WhiteBox wb = WhiteBox.getWhiteBox();\n+        for (int i = 0; i < 100; i++) {\n+            wb.lockAndBlock(\/* suspender= *\/ false);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/handshake\/SuspendBlocked.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -610,0 +610,2 @@\n+  public native void lockAndBlock(boolean suspender);\n+\n","filename":"test\/lib\/sun\/hotspot\/WhiteBox.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}