{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,0 +63,1 @@\n+import java.time.LocalTime;\n@@ -101,0 +102,31 @@\n+        private String addMessageContext(String message) {\n+            return \"T:\" + Thread.currentThread().getId() +\n+                \" I:\" + iteration +\n+                \" \" + LocalTime.now().toString() +\n+                \": \" + message;\n+        }\n+\n+        private void info(String message) {\n+            log.info(addMessageContext(message));\n+        }\n+\n+        private void progress(String message) {\n+            \/\/ Uncomment this to get more verbose logging.\n+            \/\/ log.debug(addMessageContext(message));\n+        }\n+\n+        private void fail(String message) {\n+            log.error(addMessageContext(\"[FAILED] \" + message));\n+            setFailed(true);\n+        }\n+\n+        private boolean shouldTerminate() {\n+            return !getExecutionController().continueExecution();\n+        }\n+\n+        private void eatMemory(int initialFactor) {\n+            GarbageUtils.eatMemory(getExecutionController(),\n+                                   garbageProducer,\n+                                   initialFactor , 10, 0);\n+        }\n+\n@@ -103,1 +135,2 @@\n-                log.info(\"iteration \" + iteration);\n+                int code = iteration % TYPES_COUNT;\n+                info(\"start code \" + code);\n@@ -106,1 +139,0 @@\n-                int code = iteration % TYPES_COUNT;\n@@ -161,1 +193,2 @@\n-                GarbageUtils.eatMemory(getExecutionController(), garbageProducer, initialFactor , 10, 0);\n+\n+                \/\/ If referent is finalizable, provoke GCs and wait for finalization.\n@@ -163,6 +196,7 @@\n-                        while (!finalized && getExecutionController().continueExecution()) {\n-                                System.runFinalization(); \/\/does not guarantee finalization, but increases the chance\n-                                try {\n-                                        Thread.sleep(100);\n-                                } catch (InterruptedException e) {}\n-                                GarbageUtils.eatMemory(getExecutionController(), garbageProducer, initialFactor , 10, 0);\n+                    progress(\"Waiting for finalization: \" + type);\n+                    for (int checks = 0; !finalized && !shouldTerminate(); ++checks) {\n+                        \/\/ There are scenarios where one eatMemory() isn't enough,\n+                        \/\/ but 10 iterations really ought to be sufficient.\n+                        if (checks > 10) {\n+                            fail(\"Waiting for finalization: \" + type);\n+                            return;\n@@ -170,0 +204,7 @@\n+                        eatMemory(initialFactor);\n+                        \/\/ Give some time for finalizer to run.\n+                        try {\n+                            Thread.sleep(100);\n+                        } catch (InterruptedException e) {}\n+                    }\n+                }\n@@ -171,2 +212,15 @@\n-                        \/\/provoke gc once more to make finalized object phantom reachable\n-                        GarbageUtils.eatMemory(getExecutionController(), garbageProducer, initialFactor , 10, 0);\n+                \/\/ Provoke GCs and wait for reference to be enqueued.\n+                progress(\"Waiting for enqueue: \" + type);\n+                Reference polled = queue.poll();\n+                for (int checks = 0; polled == null && !shouldTerminate(); ++checks) {\n+                    \/\/ There are scenarios where one eatMemory() isn't enough,\n+                    \/\/ but 10 iterations really ought to be sufficient.\n+                    if (checks > 10) {\n+                        fail(\"Waiting for enqueue: \" + type);\n+                        return;\n+                    }\n+                    eatMemory(initialFactor);\n+                    \/\/ Give some time for reference to be enqueued.\n+                    try {\n+                        polled = queue.remove(100);\n+                    } catch (InterruptedException e) {}\n@@ -174,2 +228,3 @@\n-                if (!getExecutionController().continueExecution()) {\n-                    \/\/ we were interrrupted by stresser. just exit...\n+\n+                if (polled == null && shouldTerminate()) {\n+                    info(\"Terminated: \" + type);\n@@ -178,8 +233,1 @@\n-                Reference polledReference = null;\n-                try {\n-                    polledReference = queue.remove();\n-                } catch (InterruptedException e) {\n-                    log.error(\"Unexpected InterruptedException during queue.remove().\");\n-                    setFailed(true);\n-                }\n-                \/\/ Check the reference and the queue\n+\n@@ -188,4 +236,3 @@\n-\n-                if (polledReference != reference) {\n-                    log.error(\"The original reference is not equal to polled reference.\");\n-                    setFailed(true);\n+                if (polled != reference) {\n+                    fail(\"The original reference is not equal to polled reference.\");\n+                    return;\n@@ -196,4 +243,3 @@\n-                polledReference = queue.poll();\n-                if (polledReference != null) {\n-                    log.error(\"There are more  than one references in the queue.\");\n-                    setFailed(true);\n+                if (queue.poll() != null) {\n+                    fail(\"There are more than one reference in the queue.\");\n+                    return;\n@@ -201,1 +247,1 @@\n-                reference.clear();\n+                progress(\"Finished: \" + type);\n@@ -203,0 +249,2 @@\n+            } finally {\n+                iteration++;\n@@ -204,1 +252,0 @@\n-            iteration++;\n@@ -209,4 +256,4 @@\n-                \/\/We need discard this flag to make second and following checks with type.equals(\"class\") useful\n-                public Referent() {\n-                                finalized = false;\n-                        }\n+            \/\/We need discard this flag to make second and following checks with type.equals(\"class\") useful\n+            public Referent() {\n+                finalized = false;\n+            }\n@@ -214,1 +261,1 @@\n-                        protected void finalize() {\n+            protected void finalize() {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/PhantomReference\/phantom001\/phantom001.java","additions":84,"deletions":37,"binary":false,"changes":121,"status":"modified"}]}