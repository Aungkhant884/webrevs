{"files":[{"patch":"@@ -2949,1 +2949,0 @@\n-  const TypePtr* adr_type = TypeKlassPtr::make(TypePtr::NotNull, C->env()->Object_klass(), Type::OffsetBot);\n@@ -2961,0 +2960,2 @@\n+  assert(!klass->is_interface(), \"no exact type check on interfaces\");\n+\n@@ -2964,2 +2965,2 @@\n-  Node* cmp = _gvn.transform( new CmpPNode(recv_klass, want_klass) );\n-  Node* bol = _gvn.transform( new BoolNode(cmp, BoolTest::eq) );\n+  Node* cmp = _gvn.transform(new CmpPNode(recv_klass, want_klass));\n+  Node* bol = _gvn.transform(new BoolNode(cmp, BoolTest::eq));\n@@ -2967,11 +2968,16 @@\n-  set_control( _gvn.transform( new IfTrueNode (iff) ));\n-  Node* fail = _gvn.transform( new IfFalseNode(iff) );\n-\n-  const TypeOopPtr* recv_xtype = tklass->as_instance_type();\n-  assert(recv_xtype->klass_is_exact(), \"\");\n-\n-  \/\/ Subsume downstream occurrences of receiver with a cast to\n-  \/\/ recv_xtype, since now we know what the type will be.\n-  Node* cast = new CheckCastPPNode(control(), receiver, recv_xtype);\n-  (*casted_receiver) = _gvn.transform(cast);\n-  \/\/ (User must make the replace_in_map call.)\n+  set_control( _gvn.transform(new IfTrueNode (iff)));\n+  Node* fail = _gvn.transform(new IfFalseNode(iff));\n+\n+  if (!stopped()) {\n+    const TypeOopPtr* receiver_type = _gvn.type(receiver)->isa_oopptr();\n+    const TypeOopPtr* recvx_type = tklass->as_instance_type();\n+    assert(recvx_type->klass_is_exact(), \"\");\n+\n+    if (!receiver_type->higher_equal(recvx_type)) { \/\/ ignore redundant casts\n+      \/\/ Subsume downstream occurrences of receiver with a cast to\n+      \/\/ recv_xtype, since now we know what the type will be.\n+      Node* cast = new CheckCastPPNode(control(), receiver, recvx_type);\n+      (*casted_receiver) = _gvn.transform(cast);\n+      \/\/ (User must make the replace_in_map call.)\n+    }\n+  }\n@@ -2990,4 +2996,9 @@\n-  \/\/ Cast receiver after successful check\n-  const TypeOopPtr* recv_type = tklass->cast_to_exactness(false)->is_klassptr()->as_instance_type();\n-  Node* cast = new CheckCastPPNode(control(), receiver, recv_type);\n-  (*casted_receiver) = _gvn.transform(cast);\n+  \/\/ Ignore interface type information until interface types are properly tracked.\n+  if (!stopped() && !klass->is_interface()) {\n+    const TypeOopPtr* receiver_type = _gvn.type(receiver)->isa_oopptr();\n+    const TypeOopPtr* recv_type = tklass->cast_to_exactness(false)->is_klassptr()->as_instance_type();\n+    if (!receiver_type->higher_equal(recv_type)) { \/\/ ignore redundant casts\n+      Node* cast = new CheckCastPPNode(control(), receiver, recv_type);\n+      (*casted_receiver) = _gvn.transform(cast);\n+    }\n+  }\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":29,"deletions":18,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -0,0 +1,175 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @requires vm.flavor == \"server\"\n+ *\n+ * @run main\/othervm -Xbatch -XX:-TieredCompilation -XX:+PrintCompilation -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining\n+ *                   -XX:CompileCommand=quiet -XX:CompileCommand=compileonly,*::test\n+ *                     compiler.c2.UpcastTest\n+ *\/\n+\n+package compiler.c2;\n+\n+public class UpcastTest {\n+    static class Test1 {\n+        interface I { void m(); }\n+\n+        static abstract class AC implements I {\n+            public void m() {}\n+        }\n+\n+        static class T extends AC {\n+            int i = 0;\n+\n+            static {\n+                \/\/ Run the test while T is not fully initialized yet.\n+                for (int i = 0; i < 20_000; i++) {\n+                    test(new T(){});\n+                    test(new T(){});\n+                    test(new T(){});\n+                }\n+            }\n+        }\n+\n+        static void test(T t) {\n+            \/\/ Interface I has unique implementor AC.\n+            \/\/ CHA reports AC::m and the callee is guarded by a type check against its holder (AC).\n+\n+            ((I)t).m(); \/\/ invokeinterface I.m w\/ polluted profile\n+\n+            \/\/ No upcasts (to class AC) on t after the call.\n+            \/\/ Otherwise, field access fires an assert.\n+            t.i = 1;\n+        }\n+    }\n+\n+    static class Test2 {\n+        interface I { void m(); }\n+        interface J extends I {\n+            default void m() {}\n+        }\n+\n+        static abstract class AC implements I {\n+        }\n+\n+        static abstract class T extends AC {\n+            int i = 0;\n+\n+            static {\n+                \/\/ Run the test while T is not fully initialized yet.\n+                for (int i = 0; i < 20_000; i++) {\n+                    test(new T1(){});\n+                    test(new T2(){});\n+                    test(new T3(){});\n+                }\n+            }\n+        }\n+\n+        static class T1 extends T implements J {}\n+        static class T2 extends T implements J {}\n+        static class T3 extends T implements J {}\n+\n+        static void test(T t) {\n+            \/\/ Interface I has unique implementor AC.\n+            \/\/ CHA reports J::m and the callee is guarded by a type check against its holder (J).\n+\n+            ((I)t).m(); \/\/ invokeinterface I.m w\/ polluted profile\n+\n+            \/\/ No upcasts (to interface J) on t after the call.\n+            \/\/ Otherwise, field access fires an assert.\n+            t.i = 1;\n+        }\n+    }\n+\n+    static class Test3 {\n+        interface I {\n+            default void m1() { m2(); }\n+            void m2();\n+        }\n+        interface J extends I {\n+            default void m2() {}\n+        }\n+\n+        static abstract class AC implements I {}\n+\n+        static class T extends AC implements J {\n+            int i = 0;\n+        }\n+\n+        static void test(T t) {\n+            t.m1(); \/\/ invokeinterface I.m w\/ polluted profile\n+\n+            \/\/ No upcasts (to interface J) on t after the call.\n+            \/\/ Otherwise, field access fires an assert.\n+            t.i = 1;\n+        }\n+\n+        static void run() {\n+            for (int i = 0; i < 20_000; i++) {\n+                test(new T() {});\n+                test(new T() {});\n+                test(new T() {});\n+            }\n+        }\n+    }\n+\n+    static class Test4 {\n+        interface I { default void m() {}}\n+\n+        static class T {\n+            int i = 0;\n+        }\n+\n+        static class D extends T implements I {}\n+\n+        static void test(T t) {\n+            if (t instanceof I) {\n+                ((I)t).m();\n+\n+                \/\/ No upcasts (to interface J) on t after the call.\n+                \/\/ Otherwise, field access fires an assert.\n+\n+                t.i = 1;\n+            } else {\n+                throw new InternalError();\n+            }\n+        }\n+\n+        static void run() {\n+            for (int i = 0; i < 20_000; i++) {\n+                test(new D() {});\n+                test(new D() {});\n+                test(new D() {});\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        new Test1.T();  \/\/ trigger initialization of class T\n+        new Test2.T1(); \/\/ trigger initialization of class T\n+        Test3.run();\n+        Test4.run();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/UpcastTest.java","additions":175,"deletions":0,"binary":false,"changes":175,"status":"added"}]}