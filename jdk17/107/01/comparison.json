{"files":[{"patch":"@@ -1599,2 +1599,12 @@\n-  if (is_not_entrant() && can_convert_to_zombie()) {\n-    return;\n+  {\n+    MutexLocker ml(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n+    \/\/ When the nmethod is acquired from the CodeCache iterator, it can racingly become zombie\n+    \/\/ before this code is called. Filter them out here under the CompiledMethod_lock.\n+    if (!is_alive()) {\n+      return;\n+    }\n+    \/\/ As for is_alive() nmethods, we also don't want them to racingly become zombie once we\n+    \/\/ release this lock, so we check that this is not going to be the case.\n+    if (is_not_entrant() && can_convert_to_zombie()) {\n+      return;\n+    }\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -230,2 +230,4 @@\n-      \/\/ Walk the CodeCache notifying for live nmethods, don't release the CodeCache_lock\n-      \/\/ because the sweeper may be running concurrently.\n+      \/\/ Walk the CodeCache notifying for live nmethods. We hold the CodeCache_lock\n+      \/\/ to ensure the iteration is safe and nmethods are not concurrently freed.\n+      \/\/ However, they may still change states and become !is_alive(). Filtering\n+      \/\/ those out is done inside of nmethod::post_compiled_method_load_event().\n","filename":"src\/hotspot\/share\/prims\/jvmtiCodeBlobEvents.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}