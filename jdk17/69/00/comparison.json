{"files":[{"patch":"@@ -182,1 +182,1 @@\n-    \/\/ init method. Check opmode and key, then call init(byte[]).\n+    \/\/ init method. Check key, then call init(byte[]).\n@@ -184,0 +184,4 @@\n+\n+        \/\/ Cipher.init() already checks opmode to be:\n+        \/\/ ENCRYPT_MODE\/DECRYPT_MODE\/WRAP_MODE\/UNWRAP_MODE\n+\n@@ -187,3 +191,1 @@\n-        if ((opmode < Cipher.ENCRYPT_MODE) || (opmode > Cipher.UNWRAP_MODE)) {\n-            throw new InvalidKeyException(\"Unknown opmode: \" + opmode);\n-        }\n+\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ARCFOURCipher.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -538,0 +538,2 @@\n+        \/\/ Cipher.init() already checks opmode to be:\n+        \/\/ ENCRYPT_MODE\/DECRYPT_MODE\/WRAP_MODE\/UNWRAP_MODE\n@@ -541,3 +543,0 @@\n-        } else if ((opmode != Cipher.ENCRYPT_MODE) &&\n-                (opmode != Cipher.DECRYPT_MODE)) {\n-            throw new InvalidKeyException(\"Unknown opmode: \" + opmode);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ChaCha20Cipher.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -264,1 +264,2 @@\n-            throw new InvalidKeyException(\"Unknown mode: \" + opmode);\n+            \/\/ should never happen; checked by Cipher.init()\n+            throw new AssertionError(\"Unknown mode: \" + opmode);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/RSACipher.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -359,2 +359,3 @@\n-            default:\n-                throw new InvalidAlgorithmParameterException\n+            case Cipher.WRAP_MODE:\n+            case Cipher.UNWRAP_MODE:\n+                throw new UnsupportedOperationException\n@@ -362,0 +363,3 @@\n+            default:\n+                \/\/ should never happen; checked by Cipher.init()\n+                throw new AssertionError(\"Unknown mode: \" + opmode);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11AEADCipher.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -373,2 +373,3 @@\n-            default:\n-                throw new InvalidAlgorithmParameterException\n+            case Cipher.WRAP_MODE:\n+            case Cipher.UNWRAP_MODE:\n+                throw new UnsupportedOperationException\n@@ -376,0 +377,3 @@\n+            default:\n+                \/\/ should never happen; checked by Cipher.init()\n+                throw new AssertionError(\"Unknown mode: \" + opmode);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Cipher.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -207,1 +207,2 @@\n-            throw new InvalidKeyException(\"Unknown mode: \" + opmode);\n+            \/\/ should never happen; checked by Cipher.init()\n+            throw new AssertionError(\"Unknown mode: \" + opmode);\n","filename":"src\/jdk.crypto.mscapi\/windows\/classes\/sun\/security\/mscapi\/CRSACipher.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.Arrays;\n@@ -43,4 +44,8 @@\n-        \"DES\/ECB\/PKCS5Padding\",\n-        \"AES\/KW\/NoPadding\",\n-        \"AES\/KW\/PKCS5Padding\",\n-        \"AES\/KWP\/NoPadding\",\n+        \"DES\/ECB\/PKCS5Padding\", \/\/ CipherCore\n+        \"AES\/GCM\/NoPadding\", \/\/ GaloisCounterMode\n+        \"AES\/KW\/NoPadding\", \/\/ KeyWrapCipher\n+        \"AES\/KW\/PKCS5Padding\", \/\/ KeyWrapCipher\n+        \"AES\/KWP\/NoPadding\", \/\/ KeyWrapCipher\n+        \"RSA\/ECB\/NoPadding\", \/\/ RSACipher\n+        \"DESedeWrap\/CBC\/NoPadding\", \/\/ DESedeWrapCipher\n+        \"ChaCha20-Poly1305\", \/\/ ChaCha20Cipher\n@@ -49,0 +54,2 @@\n+    private static final byte[] BYTES32 =\n+            Arrays.copyOf(TRANSFORMATIONS[0].getBytes(), 32);\n@@ -50,1 +57,1 @@\n-            new SecretKeySpec(new byte[8], \"DES\");\n+            new SecretKeySpec(BYTES32, 0, 8, \"DES\");\n@@ -52,1 +59,1 @@\n-            new SecretKeySpec(new byte[16], \"AES\");\n+            new SecretKeySpec(BYTES32, 0, 16, \"AES\");\n@@ -54,13 +61,39 @@\n-    public static void main(String[] argv) throws Exception {\n-        for (String t : TRANSFORMATIONS) {\n-            System.out.println(\"Testing SunJCE provider, Cipher \" + t );\n-\n-            TestCipherMode test = new TestCipherMode(t);\n-            System.out.println(\"Testing ENCRYPT_MODE...\");\n-            test.checkMode(Cipher.ENCRYPT_MODE, \"encryption\");\n-            System.out.println(\"Testing DECRYPT_MODE...\");\n-            test.checkMode(Cipher.DECRYPT_MODE, \"decryption\");\n-            System.out.println(\"Testing WRAP_MODE...\");\n-            test.checkMode(Cipher.WRAP_MODE, \"key wrapping\");\n-            System.out.println(\"Testing UNWRAP_MODE...\");\n-            test.checkMode(Cipher.UNWRAP_MODE, \"key unwrapping\");\n+    private  static enum CipherMode {\n+        ENCRYPT(Cipher.ENCRYPT_MODE),\n+        DECRYPT(Cipher.DECRYPT_MODE),\n+        WRAP(Cipher.WRAP_MODE),\n+        UNWRAP(Cipher.UNWRAP_MODE),\n+        NONEXISTENT(100);\n+\n+        int value;\n+\n+        CipherMode(int value) {\n+            this.value = value;\n+        }\n+    }\n+\n+    private static Key getKey(String t, CipherMode m)\n+            throws NoSuchAlgorithmException, NoSuchProviderException {\n+        Key key;\n+        String algo = t.split(\"\/\")[0];\n+        switch (algo) {\n+        case \"AES\":\n+            key = AES_KEY;\n+        break;\n+        case \"RSA\":\n+            KeyPairGenerator kpg = KeyPairGenerator.getInstance(algo);\n+            KeyPair kp = kpg.generateKeyPair();\n+            key = ((m == CipherMode.ENCRYPT || m == CipherMode.UNWRAP)?\n+                    kp.getPrivate() : kp.getPublic());\n+        break;\n+        case \"ChaCha20-Poly1305\":\n+            key = new SecretKeySpec(BYTES32, 0, 32, \"ChaCha20\");\n+        break;\n+        case \"DES\":\n+            key = new SecretKeySpec(BYTES32, 0, 8, algo);\n+        break;\n+        case \"DESedeWrap\":\n+            key = new SecretKeySpec(BYTES32, 0, 24, \"DESede\");\n+        break;\n+        default:\n+            throw new RuntimeException(\"Unknown transformation: \" + t);\n@@ -68,0 +101,6 @@\n+        return key;\n+    }\n+\n+    public static void main(String[] argv) throws Exception {\n+\n+        TestCipherMode test = new TestCipherMode(\"SunJCE\", TRANSFORMATIONS);\n@@ -74,10 +113,10 @@\n-    private TestCipherMode(String transformation)\n-            throws NoSuchAlgorithmException, NoSuchProviderException,\n-            NoSuchPaddingException {\n-        c = Cipher.getInstance(transformation, \"SunJCE\");\n-        this.key = switch (transformation.split(\"\/\")[0]) {\n-            case \"DES\" -> DES_KEY;\n-            case \"AES\" -> AES_KEY;\n-            default -> throw new RuntimeException\n-                    (\"Error: Unsupported key algorithm\");\n-        };\n+    private TestCipherMode(String provName, String... transformations)\n+            throws Exception {\n+\n+        System.out.println(\"Testing \" + provName);\n+\n+        for (String t : transformations) {\n+            for (CipherMode m : CipherMode.values()) {\n+                checkMode(t, m, provName);\n+            }\n+        }\n@@ -86,2 +125,25 @@\n-    private void checkMode(int mode, String opString) throws Exception {\n-        c.init(mode, key);\n+    private void checkMode(String t, CipherMode mode, String provName)\n+            throws Exception {\n+        Cipher c = Cipher.getInstance(t, provName);\n+        Key key = getKey(t, mode);\n+\n+        System.out.println(c.getAlgorithm() + \" with \" + mode.name());\n+        try {\n+            c.init(mode.value, key, c.getParameters());\n+            if (mode == CipherMode.NONEXISTENT) {\n+                throw new Exception(\"ERROR: should throw IPE for init()\");\n+            }\n+        } catch (UnsupportedOperationException uoe)  {\n+            \/\/ some may not support wrap\/unwrap or enc\/dec\n+            if (mode != CipherMode.NONEXISTENT) {\n+                System.out.println(\"Expected UOE thrown with init()\");\n+                return;\n+            }\n+            throw uoe;\n+        } catch (InvalidParameterException ipe) {\n+            if (mode == CipherMode.NONEXISTENT) {\n+                System.out.println(\"=> expected IPE thrown for init()\");\n+                return;\n+            }\n+            throw ipe;\n+        }\n@@ -90,2 +152,2 @@\n-        case Cipher.ENCRYPT_MODE:\n-        case Cipher.DECRYPT_MODE:\n+        case ENCRYPT:\n+        case DECRYPT:\n@@ -97,1 +159,1 @@\n-                System.out.println(\"expected ISE is thrown for wrap()\");\n+                System.out.println(\"=> expected ISE thrown for wrap()\");\n@@ -103,1 +165,1 @@\n-                System.out.println(\"expected ISE is thrown for unwrap()\");\n+                System.out.println(\"=> expected ISE thrown for unwrap()\");\n@@ -106,2 +168,2 @@\n-        case Cipher.WRAP_MODE:\n-        case Cipher.UNWRAP_MODE:\n+        case WRAP:\n+        case UNWRAP:\n@@ -112,1 +174,1 @@\n-                System.out.println(\"expected ISE is thrown for update()\");\n+                System.out.println(\"=> expected ISE thrown for update()\");\n@@ -118,1 +180,1 @@\n-                System.out.println(\"expected ISE is thrown for doFinal()\");\n+                System.out.println(\"=> expected ISE thrown for doFinal()\");\n","filename":"test\/jdk\/javax\/crypto\/Cipher\/TestCipherMode.java","additions":101,"deletions":39,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -0,0 +1,176 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8265500\n+ * @summary\n+ * @library \/test\/lib ..\n+ * @modules jdk.crypto.cryptoki\n+ * @run main\/othervm TestCipherMode\n+ *\/\n+\n+import java.security.Provider;\n+import java.security.Key;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.PrivateKey;\n+import java.security.PublicKey;\n+import java.security.InvalidParameterException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Arrays;\n+import javax.crypto.Cipher;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+public class TestCipherMode extends PKCS11Test {\n+\n+    private static String[] TRANSFORMATIONS = {\n+        \"AES\/ECB\/PKCS5Padding\", \"AES\/GCM\/NoPadding\",\n+        \"RSA\/ECB\/PKCS1Padding\"\n+    };\n+\n+    private static byte[] BYTES16 =\n+            Arrays.copyOf(TRANSFORMATIONS[0].getBytes(), 16);\n+    private static SecretKey AES_KEY = new SecretKeySpec(BYTES16, \"AES\");\n+    private static PublicKey RSA_PUBKEY = null;\n+    private static PrivateKey RSA_PRIVKEY = null;\n+\n+    enum CipherMode {\n+        ENCRYPT(Cipher.ENCRYPT_MODE),\n+        DECRYPT(Cipher.DECRYPT_MODE),\n+        WRAP(Cipher.WRAP_MODE),\n+        UNWRAP(Cipher.UNWRAP_MODE),\n+        NONEXISTENT(100);\n+\n+        int value;\n+\n+        CipherMode(int value) {\n+            this.value = value;\n+        }\n+    }\n+\n+    private static Key getKey(String t, CipherMode m, Provider p)\n+            throws NoSuchAlgorithmException {\n+        if (t.startsWith(\"AES\")) {\n+            return AES_KEY;\n+        } else if (t.startsWith(\"RSA\")) {\n+            if (RSA_PUBKEY == null) {\n+                KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\", p);\n+                KeyPair kp = kpg.generateKeyPair();\n+                RSA_PUBKEY = kp.getPublic();\n+                RSA_PRIVKEY = kp.getPrivate();\n+            }\n+            return ((m == CipherMode.ENCRYPT || m == CipherMode.UNWRAP)?\n+                    RSA_PRIVKEY : RSA_PUBKEY);\n+        } else {\n+            throw new RuntimeException(\"Unknown transformation: \" + t);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new TestCipherMode(), args);\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+\n+        \/\/ test all cipher impls, e.g. P11Cipher, P11AEADCipher, and\n+        \/\/ P11RSACipher\n+        for (String t : TRANSFORMATIONS) {\n+            checkModes(t, p);\n+        }\n+        System.out.println(\"All tests passed\");\n+    }\n+\n+    private static void checkModes(String t, Provider p) throws Exception {\n+        try {\n+            Cipher.getInstance(t, p);\n+        } catch (Exception e) {\n+            System.out.println(\"Skip \" + t + \" due to \" + e.getMessage());\n+            return;\n+        }\n+\n+        for (CipherMode m : CipherMode.values()) {\n+            System.out.println(\"Testing \" + t + \" with \" + m.name());\n+            Cipher c;\n+            try {\n+                c = Cipher.getInstance(t, p);\n+                \/\/ try init and see if the expected Exception is thrown\n+                c.init(m.value, getKey(t, m, p), c.getParameters());\n+                if (m == CipherMode.NONEXISTENT) {\n+                    throw new Exception(\"ERROR: should throw IPE with init()\");\n+                }\n+            } catch (UnsupportedOperationException uoe)  {\n+                \/\/ some may not support wrap\/unwrap\n+                if (m == CipherMode.WRAP || m == CipherMode.UNWRAP) {\n+                    System.out.println(\"Expected UOE thrown with init()\");\n+                    continue;\n+                }\n+                throw uoe;\n+            } catch (InvalidParameterException ipe) {\n+                if (m == CipherMode.NONEXISTENT) {\n+                    System.out.println(\"Expected IPE thrown for init()\");\n+                    continue;\n+                }\n+                throw ipe;\n+            }\n+            switch (m) {\n+            case ENCRYPT:\n+            case DECRYPT:\n+                \/\/ call wrap()\/unwrap() and see if ISE is thrown.\n+                try {\n+                    c.wrap(AES_KEY);\n+                    throw new Exception(\"ERROR: should throw ISE for wrap()\");\n+                } catch (IllegalStateException ise) {\n+                    System.out.println(\"Expected ISE thrown for wrap()\");\n+                }\n+                try {\n+                    c.unwrap(BYTES16, \"AES\", Cipher.SECRET_KEY);\n+                    throw new Exception(\"ERROR: should throw ISE for unwrap()\");\n+                } catch (IllegalStateException ise) {\n+                    System.out.println(\"Expected ISE thrown for unwrap()\");\n+                }\n+                break;\n+            case WRAP:\n+            case UNWRAP:\n+                try {\n+                    c.update(BYTES16);\n+                    throw new Exception(\"ERROR: should throw ISE for update()\");\n+                } catch (IllegalStateException ise) {\n+                    System.out.println(\"Expected ISE thrown for update()\");\n+                }\n+                try {\n+                    c.doFinal();\n+                    throw new Exception(\"ERROR: should throw ISE for\" +\n+                            \" doFinal()\");\n+                } catch (IllegalStateException ise) {\n+                    System.out.println(\"Expected ISE thrown for doFinal()\");\n+                }\n+                break;\n+            default:\n+                throw new AssertionError();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestCipherMode.java","additions":176,"deletions":0,"binary":false,"changes":176,"status":"added"}]}