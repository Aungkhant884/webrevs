{"files":[{"patch":"@@ -141,2 +141,2 @@\n-      \/\/ encounter a flush token. take a record for the time being\n-      \/\/ and notify flush() after the loop.\n+      \/\/ This is a flush token. Record that we found it and then\n+      \/\/ signal the flushing thread after the loop.\n@@ -187,1 +187,4 @@\n-\/\/ NOT MT-safe! see the comments in the header file.\n+\/\/ Inserts a flush token into the async output buffer and waits until the AsyncLog thread\n+\/\/ signals that it has seen it and completed all dequeued message processing.\n+\/\/ This is method is not MT-safe in itself, but is guarded by another lock in the usual\n+\/\/ usecase - see the comments in the header file for more details.\n@@ -196,1 +199,1 @@\n-      \/\/ not disposable\n+      \/\/ Push directly in-case we are at logical max capacity, as this must not get dropped.\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -124,2 +124,2 @@\n-\/\/ instance() is MT-safe and returns the pointer of the singleton instance if and only if async logging is enabled and has well\n-\/\/ initialized. Clients can use its return value to determine async logging is established or not.\n+\/\/ instance() is MT-safe and returns the pointer of the singleton instance if and only if async logging is enabled and has\n+\/\/ successfully initialized. Clients can use its return value to determine async logging is established or not.\n@@ -127,1 +127,1 @@\n-\/\/ enqueue() is the basic operation of AsyncLogWriter. 2 overloading versions of it are provided to match LogOutput::write().\n+\/\/ enqueue() is the basic operation of AsyncLogWriter. Two overloading versions of it are provided to match LogOutput::write().\n@@ -131,3 +131,3 @@\n-\/\/ flush() is designated to flush out all pending messages. MT-safety is not provided. It is no-op if async logging is not in use.\n-\/\/ In normal JVM termination, flush() is invoked in LogConfiguration::finalize(). When the users change logging configurations\n-\/\/ via jcmd, LogConfiguration::configure_output() invokes it with the protection of ConfigurationLock.\n+\/\/ flush() is designated to flush out all pending messages before returning. MT-safety is not provided. It is no-op if async\n+\/\/ logging is not in use. In normal JVM termination, flush() is invoked in LogConfiguration::finalize(). When the users change\n+\/\/ logging configurations via jcmd, LogConfiguration::configure_output() invokes it with the protection of ConfigurationLock.\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -216,1 +216,1 @@\n-\/\/ ConfigurationLock can guarantee that only one thread is performing reconfiguration. This function still needs\n+\/\/ The ConfigurationLock guarantees that only one thread is performing reconfiguration. This function still needs\n@@ -220,3 +220,3 @@\n-\/\/ A RCU-style synchronization 'wait_until_no_readers()' is imposed inside of 'ts->set_output_level(output, level)'\n-\/\/ if setting has changed. It guarantees that all logs either synchronous writing or enqueuing to the async buffer\n-\/\/ see the new tags and decorators. It's worth noting that the synchronization happens even level does not change.\n+\/\/ A RCU-style synchronization 'wait_until_no_readers()' is used inside of 'ts->set_output_level(output, level)'\n+\/\/ if a setting has changed. It guarantees that all logs, either synchronous writes or enqueuing to the async buffer\n+\/\/ see the new tags and decorators. It's worth noting that the synchronization occurs even if the level does not change.\n@@ -271,7 +271,2 @@\n-  \/\/ for async logging, enqueuing instead of writing is still under protection of the synchronization\n-  \/\/ `wait_until_no_readers()`. There are 2 hazards in async logging as follows.\n-  \/\/  1. asynclog buffer may be holding some log messages with previous decorators.\n-  \/\/  2. asynclog buffer may be holding some log messages targeting to the output 'idx'.\n-  \/\/\n-  \/\/ A flush operation guarantees to all pending messages in buffer are written before returning. Therefore,\n-  \/\/ the two hazards won't appear after it. It's a nop if async logging is not set.\n+  \/\/ For async logging we have to ensure that all enqueued messages, which may refer to previous decorators,\n+  \/\/ or a soon-to-be-deleted outputs, are written out first. The flush() call ensures this.\n@@ -306,4 +301,4 @@\n-  \/\/ Handle jcmd VM.log disable\n-  \/\/ ts->disable_outputs() above has deleted output_list with RCU synchronization.\n-  \/\/ Therefore, no new logging entry can enter AsyncLog buffer for the time being.\n-  \/\/ flush pending entries before LogOutput instances die.\n+  \/\/ Handle 'jcmd VM.log disable' and JVM termination.\n+  \/\/ ts->disable_outputs() above has disabled all output_lists with RCU synchronization.\n+  \/\/ Therefore, no new logging message can enter the async buffer for the time being.\n+  \/\/ flush out all pending messages before LogOutput instances die.\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.cpp","additions":10,"deletions":15,"binary":false,"changes":25,"status":"modified"}]}