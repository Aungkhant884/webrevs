{"files":[{"patch":"@@ -44,1 +44,1 @@\n-  if (_buffer.size() >= _buffer_max_size)  {\n+  if (_buffer.size() >= _buffer_max_size) {\n@@ -53,1 +53,0 @@\n-  assert(_buffer.size() < _buffer_max_size, \"_buffer is over-sized.\");\n@@ -59,1 +58,1 @@\n-  AsyncLogMessage m(output, decorations, os::strdup(msg));\n+  AsyncLogMessage m(&output, decorations, os::strdup(msg));\n@@ -73,1 +72,1 @@\n-    AsyncLogMessage m(output, msg_iterator.decorations(), os::strdup(msg_iterator.message()));\n+    AsyncLogMessage m(&output, msg_iterator.decorations(), os::strdup(msg_iterator.message()));\n@@ -79,1 +78,1 @@\n-  : _lock(1), _sem(0), _io_sem(1),\n+  : _lock(1), _sem(0), _flush_sem(0),\n@@ -101,1 +100,1 @@\n-      LogDecorations decorations(LogLevel::Warning, none::tagset(), output->decorators());\n+      LogDecorations decorations(LogLevel::Warning, none::tagset(), LogDecorators::All);\n@@ -104,1 +103,1 @@\n-      AsyncLogMessage msg(*output, decorations, ss.as_string(true \/*c_heap*\/));\n+      AsyncLogMessage msg(output, decorations, ss.as_string(true \/*c_heap*\/));\n@@ -121,1 +120,0 @@\n-  bool own_io = false;\n@@ -130,1 +128,0 @@\n-    own_io = _io_sem.trywait();\n@@ -134,3 +131,0 @@\n-  if (!own_io) {\n-    _io_sem.wait();\n-  }\n@@ -138,0 +132,1 @@\n+  int req = 0;\n@@ -145,0 +140,4 @@\n+    } else if (e->output() == nullptr) {\n+      \/\/ This is a flush token. Record that we found it and then\n+      \/\/ signal the flushing thread after the loop.\n+      req++;\n@@ -147,1 +146,5 @@\n-  _io_sem.signal();\n+\n+  if (req > 0) {\n+    assert(req == 1, \"AsyncLogWriter::flush() is NOT MT-safe!\");\n+    _flush_sem.signal(req);\n+  }\n@@ -184,2 +187,4 @@\n-\/\/ write() acquires and releases _io_sem even _buffer is empty.\n-\/\/ This guarantees all logging I\/O of dequeued messages are done when it returns.\n+\/\/ Inserts a flush token into the async output buffer and waits until the AsyncLog thread\n+\/\/ signals that it has seen it and completed all dequeued message processing.\n+\/\/ This is method is not MT-safe in itself, but is guarded by another lock in the usual\n+\/\/ usecase - see the comments in the header file for more details.\n@@ -188,1 +193,12 @@\n-    _instance->write();\n+    {\n+      using none = LogTagSetMapping<LogTag::__NO_TAG>;\n+      AsyncLogLocker locker;\n+      LogDecorations d(LogLevel::Off, none::tagset(), LogDecorators::None);\n+      AsyncLogMessage token(nullptr, d, nullptr);\n+\n+      \/\/ Push directly in-case we are at logical max capacity, as this must not get dropped.\n+      _instance->_buffer.push_back(token);\n+      _instance->_sem.signal();\n+    }\n+\n+    _instance->_flush_sem.wait();\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":32,"deletions":16,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-  LogFileOutput& _output;\n+  LogFileOutput* _output;\n@@ -99,1 +99,1 @@\n-  AsyncLogMessage(LogFileOutput& output, const LogDecorations& decorations, char* msg)\n+  AsyncLogMessage(LogFileOutput* output, const LogDecorations& decorations, char* msg)\n@@ -105,1 +105,1 @@\n-  LogFileOutput* output() const { return &_output; }\n+  LogFileOutput* output() const { return _output; }\n@@ -124,2 +124,2 @@\n-\/\/ instance() is MT-safe and returns the pointer of the singleton instance if and only if async logging is enabled and has well\n-\/\/ initialized. Clients can use its return value to determine async logging is established or not.\n+\/\/ instance() is MT-safe and returns the pointer of the singleton instance if and only if async logging is enabled and has\n+\/\/ successfully initialized. Clients can use its return value to determine async logging is established or not.\n@@ -127,1 +127,1 @@\n-\/\/ The basic operation of AsyncLogWriter is enqueue(). 2 overloading versions of it are provided to match LogOutput::write().\n+\/\/ enqueue() is the basic operation of AsyncLogWriter. Two overloading versions of it are provided to match LogOutput::write().\n@@ -131,4 +131,3 @@\n-\/\/ The static member function flush() is designated to flush out all pending messages when JVM is terminating.\n-\/\/ In normal JVM termination, flush() is invoked in LogConfiguration::finalize(). flush() is MT-safe and can be invoked arbitrary\n-\/\/ times. It is no-op if async logging is not established.\n-\/\/\n+\/\/ flush() is designated to flush out all pending messages before returning. MT-safety is not provided. It is no-op if async\n+\/\/ logging is not in use. In normal JVM termination, flush() is invoked in LogConfiguration::finalize(). When the users change\n+\/\/ logging configurations via jcmd, LogConfiguration::configure_output() invokes it with the protection of ConfigurationLock.\n@@ -144,2 +143,1 @@\n-  \/\/ A lock of IO\n-  Semaphore _io_sem;\n+  Semaphore _flush_sem;\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -214,0 +214,15 @@\n+\/\/ MT-SAFETY\n+\/\/\n+\/\/ The ConfigurationLock guarantees that only one thread is performing reconfiguration. This function still needs\n+\/\/ to be MT-safe because logsites in other threads may be executing in parallel. Reconfiguration means unified\n+\/\/ logging allows users to dynamically change tags and decorators of a log output via DCMD(logDiagnosticCommand.hpp).\n+\/\/\n+\/\/ A RCU-style synchronization 'wait_until_no_readers()' is used inside of 'ts->set_output_level(output, level)'\n+\/\/ if a setting has changed. It guarantees that all logs, either synchronous writes or enqueuing to the async buffer\n+\/\/ see the new tags and decorators. It's worth noting that the synchronization occurs even if the level does not change.\n+\/\/\n+\/\/ LogDecorator is a set of decorators represented in a uint. ts->update_decorators(decorators) is a union of the\n+\/\/ current decorators and new_decorators. It's safe to do output->set_decorators(decorators) because new_decorators\n+\/\/ is a subset of relevant tagsets decorators. After updating output's decorators, it is still safe to shrink all\n+\/\/ decorators of tagsets.\n+\/\/\n@@ -256,0 +271,4 @@\n+  \/\/ For async logging we have to ensure that all enqueued messages, which may refer to previous decorators,\n+  \/\/ or a soon-to-be-deleted outputs, are written out first. The flush() call ensures this.\n+  AsyncLogWriter::flush();\n+\n@@ -265,4 +284,0 @@\n-    \/\/ User may disable a logOuput like this:\n-    \/\/ LogConfiguration::parse_log_arguments(filename, \"all=off\", \"\", \"\", &stream);\n-    \/\/ Just be conservative. Flush them all before deleting idx.\n-    AsyncLogWriter::flush();\n@@ -286,4 +301,4 @@\n-  \/\/ Handle jcmd VM.log disable\n-  \/\/ ts->disable_outputs() above has deleted output_list with RCU synchronization.\n-  \/\/ Therefore, no new logging entry can enter AsyncLog buffer for the time being.\n-  \/\/ flush pending entries before LogOutput instances die.\n+  \/\/ Handle 'jcmd VM.log disable' and JVM termination.\n+  \/\/ ts->disable_outputs() above has disabled all output_lists with RCU synchronization.\n+  \/\/ Therefore, no new logging message can enter the async buffer for the time being.\n+  \/\/ flush out all pending messages before LogOutput instances die.\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.cpp","additions":23,"deletions":8,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -28,0 +28,11 @@\n+template <LogDecorators::Decorator d>\n+struct AllBitmask {\n+  \/\/ Use recursive template deduction to calculate the bitmask of all decorations.\n+  static const uint _value = (1 << d) | AllBitmask<static_cast<LogDecorators::Decorator>(d + 1)>::_value;\n+};\n+\n+template<>\n+struct AllBitmask<LogDecorators::Count> {\n+  static const uint _value = 0;\n+};\n+\n@@ -29,0 +40,1 @@\n+const LogDecorators LogDecorators::All  = LogDecorators(AllBitmask<time_decorator>::_value);\n","filename":"src\/hotspot\/share\/logging\/logDecorators.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -85,0 +85,1 @@\n+  static const LogDecorators All;\n","filename":"src\/hotspot\/share\/logging\/logDecorators.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,0 +76,6 @@\n+  \/\/ Increasing the atomic reader counter in iterator(level) must\n+  \/\/ happen before the creation of LogDecorations instance so\n+  \/\/ wait_until_no_readers() in LogConfiguration::configure_output()\n+  \/\/ synchronizes _decorations as well. The order is guaranteed by\n+  \/\/ the implied memory order of Atomic::add().\n+  LogOutputList::Iterator it = _output_list.iterator(level);\n@@ -77,1 +83,2 @@\n-  for (LogOutputList::Iterator it = _output_list.iterator(level); it != _output_list.end(); it++) {\n+\n+  for (; it != _output_list.end(); it++) {\n@@ -83,0 +90,1 @@\n+  LogOutputList::Iterator it = _output_list.iterator(msg.least_detailed_level());\n@@ -84,1 +92,2 @@\n-  for (LogOutputList::Iterator it = _output_list.iterator(msg.least_detailed_level()); it != _output_list.end(); it++) {\n+\n+  for (; it != _output_list.end(); it++) {\n","filename":"src\/hotspot\/share\/logging\/logTagSet.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-  AsyncLogWriter::flush();\n","filename":"test\/hotspot\/gtest\/logging\/logTestFixture.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include \"concurrentTestRunner.inline.hpp\"\n@@ -231,0 +232,85 @@\n+class ConcurrentLogsite : public TestRunnable {\n+  int _id;\n+\n+ public:\n+  ConcurrentLogsite(int id) : _id(id) {}\n+  void runUnitTest() const override {\n+    log_debug(logging)(\"ConcurrentLogsite %d emits a log\", _id);\n+  }\n+};\n+\n+\/\/ Dynamically change decorators while loggings are emitting.\n+TEST_VM_F(LogConfigurationTest, reconfigure_decorators_MT) {\n+  const int nrOfThreads = 2;\n+  ConcurrentLogsite logsites[nrOfThreads] = {0, 1};\n+  Semaphore done(0);\n+  const long testDurationMillis = 1000;\n+  UnitTestThread* t[nrOfThreads];\n+\n+  set_log_config(TestLogFileName, \"logging=debug\", \"none\", \"filecount=0\");\n+  set_log_config(\"stdout\", \"all=off\", \"none\");\n+  set_log_config(\"stderr\", \"all=off\", \"none\");\n+  for (int i = 0; i < nrOfThreads; ++i) {\n+    t[i] = new UnitTestThread(&logsites[i], &done, testDurationMillis);\n+  }\n+\n+  for (int i = 0; i < nrOfThreads; i++) {\n+    t[i]->doit();\n+  }\n+\n+  jlong time_start = os::elapsed_counter();\n+  while (true) {\n+    jlong elapsed = (jlong)TimeHelper::counter_to_millis(os::elapsed_counter() - time_start);\n+    if (elapsed > testDurationMillis) {\n+      break;\n+    }\n+\n+    \/\/ Take turn logging with different decorators, either None or All.\n+    set_log_config(TestLogFileName, \"logging=debug\", \"none\");\n+    set_log_config(TestLogFileName, \"logging=debug\", _all_decorators);\n+  }\n+\n+  for (int i = 0; i < nrOfThreads; ++i) {\n+    done.wait();\n+  }\n+}\n+\n+\/\/ Dynamically change tags while loggings are emitting.\n+TEST_VM_F(LogConfigurationTest, reconfigure_tags_MT) {\n+  const int nrOfThreads = 2;\n+  ConcurrentLogsite logsites[nrOfThreads] = {0, 1};\n+  Semaphore done(0);\n+  const long testDurationMillis = 1000;\n+  UnitTestThread* t[nrOfThreads];\n+\n+  set_log_config(TestLogFileName, \"logging=debug\", \"\", \"filecount=0\");\n+  set_log_config(\"stdout\", \"all=off\", \"none\");\n+  set_log_config(\"stderr\", \"all=off\", \"none\");\n+\n+  for (int i = 0; i < nrOfThreads; ++i) {\n+    t[i] = new UnitTestThread(&logsites[i], &done, testDurationMillis);\n+  }\n+\n+  for (int i = 0; i < nrOfThreads; i++) {\n+    t[i]->doit();\n+  }\n+\n+  jlong time_start = os::elapsed_counter();\n+  while (true) {\n+    jlong elapsed = (jlong)TimeHelper::counter_to_millis(os::elapsed_counter() - time_start);\n+    if (elapsed > testDurationMillis) {\n+      break;\n+    }\n+\n+    \/\/ turn on\/off the tagset 'logging'.\n+    set_log_config(TestLogFileName, \"logging=off\");\n+    set_log_config(TestLogFileName, \"logging=debug\", \"\", \"filecount=0\");\n+    \/\/ sleep a prime number milliseconds to allow concurrent logsites to write logs\n+    os::naked_short_nanosleep(37);\n+  }\n+\n+  for (int i = 0; i < nrOfThreads; ++i) {\n+    done.wait();\n+  }\n+}\n+\n","filename":"test\/hotspot\/gtest\/logging\/test_logConfiguration.cpp","additions":87,"deletions":1,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -213,0 +213,7 @@\n+TEST(LogDecorators, all) {\n+  LogDecorators dec = LogDecorators::All;\n+  for (size_t i = 0; i < LogDecorators::Count; i++) {\n+    EXPECT_TRUE(dec.is_decorator(decorator_array[i]));\n+  }\n+}\n+\n","filename":"test\/hotspot\/gtest\/logging\/test_logDecorators.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"}]}