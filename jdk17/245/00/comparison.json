{"files":[{"patch":"@@ -190,1 +190,1 @@\n-                               !VerifyAccess.isSamePackage(implClass, implInfo.getDeclaringClass())) ||\n+                               !VerifyAccess.isSamePackage(targetClass, implInfo.getDeclaringClass())) ||\n@@ -567,1 +567,4 @@\n-                MethodType mtype = implInfo.getMethodType().insertParameterTypes(0, implClass);\n+                MethodType mtype = implInfo.getMethodType();\n+                if (implKind != MethodHandleInfo.REF_invokeStatic) {\n+                    mtype = mtype.insertParameterTypes(0, implClass);\n+                }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8227415 8254975 8270056\n+ * @run testng\/othervm p.ProtectedMethodInOtherPackage\n+ * @summary method reference to a protected method inherited from its\n+ *          superclass in a different runtime package where\n+ *          lambda proxy class has no access to it.\n+ *\/\n+\n+package p;\n+\n+import q.I;\n+import q.J;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.function.Function;\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+public class ProtectedMethodInOtherPackage  {\n+    @Test\n+    public static void remotePackageSameLoader() {\n+        Sub_I sub = new Sub_I();\n+        sub.test(Paths.get(\"test\"));\n+    }\n+\n+    public static class Sub_J extends J {\n+        Sub_J(Function<Path,String> function) {\n+            super(function);\n+        }\n+    }\n+\n+    public static class Sub_I extends I {\n+        public void test(Path path) {\n+            \/*\n+             * The method reference to an inherited protected method\n+             * in another package is desugared with REF_invokeVirtual on\n+             * a bridge method to invoke protected q.I::filename method\n+             *\/\n+            Sub_J c = new Sub_J(this::filename);\n+            c.check(path);\n+        }\n+    }\n+\n+    @Test\n+    public static void splitPackage() throws Throwable {\n+        ClassLoader parent = new Loader(\"loader-A\", null, A.class);\n+        ClassLoader loader = new Loader(\"loader-B\", parent, B.class);\n+        Class<?> aClass = Class.forName(A.class.getName(), false, loader);\n+        Class<?> bClass = Class.forName(B.class.getName(), false, loader);\n+        assertTrue(aClass.getClassLoader() == parent);\n+        assertTrue(bClass.getClassLoader() == loader);\n+        assertEquals(aClass.getPackageName(), bClass.getPackageName());\n+\n+        Object b = bClass.getDeclaredConstructor().newInstance();\n+\n+        \/\/ verify subclass can access a protected member inherited from\n+        \/\/ its superclass in a split package\n+        MethodHandle test = MethodHandles.lookup()\n+                .findVirtual(bClass, \"test\", MethodType.methodType(void.class));\n+        test.invoke(b);\n+\n+        \/\/ verify lambda can access a protected member inherited from\n+        \/\/ a superclass of the host class where the superclass is in\n+        \/\/ a split package (not the same runtime package as the host class)\n+        MethodHandle get = MethodHandles.lookup()\n+                .findVirtual(bClass, \"get\", MethodType.methodType(Runnable.class));\n+        ((Runnable) get.invoke(b)).run();\n+    }\n+\n+    @Test\n+    public static void protectedStaticMethodInSplitPackage() throws Throwable {\n+        ClassLoader parent = new Loader(\"loader-A1\", null, A1.class);\n+        ClassLoader loader = new Loader(\"loader-B1\", parent, B1.class);\n+        Class<?> aClass1 = Class.forName(A1.class.getName(), false, loader);\n+        Class<?> bClass1 = Class.forName(B1.class.getName(), false, loader);\n+        assertTrue(aClass1.getClassLoader() == parent);\n+        assertTrue(bClass1.getClassLoader() == loader);\n+        assertEquals(aClass1.getPackageName(), bClass1.getPackageName());\n+\n+        \/\/ verify subclass can access a static protected method inherited from\n+        \/\/ its superclass in a split package\n+        MethodHandle test = MethodHandles.lookup()\n+                .findStatic(bClass1, \"test\", MethodType.methodType(void.class));\n+        test.invoke();\n+\n+        \/\/ verify lambda can access a static protected method inherited from\n+        \/\/ a superclass of the host class where the superclass is in\n+        \/\/ a split package (not the same runtime package as the host class)\n+        MethodHandle get = MethodHandles.lookup()\n+                .findStatic(bClass1, \"get\", MethodType.methodType(Runnable.class));\n+        ((Runnable) get.invoke()).run();\n+    }\n+\n+    static class Loader extends URLClassLoader {\n+        static final Path CLASSES_DIR = Paths.get(System.getProperty(\"test.class.path\"));\n+        private final Class<?> c;\n+        Loader(String name, ClassLoader parent, Class<?> c) {\n+            super(name, new URL[]{}, parent);\n+            this.c = c;\n+        }\n+\n+        @Override\n+        protected Class<?> findClass(String name) throws ClassNotFoundException {\n+            if (name.equals(c.getName())) {\n+                try {\n+                    String path = name.replace('.', '\/') + \".class\";\n+                    byte[] bytes = Files.readAllBytes(CLASSES_DIR.resolve(path));\n+                    return defineClass(name, bytes, 0, bytes.length);\n+                } catch (IOException e) {\n+                    throw new UncheckedIOException(e);\n+                }\n+            }\n+\n+            return super.findClass(name);\n+        }\n+\n+    }\n+\n+    public static class A {\n+        protected void func() { }\n+    }\n+\n+    public static class B extends A {\n+        public Runnable get() {\n+            return this::func;\n+        }\n+        public void test() {\n+            func();\n+        }\n+    }\n+\n+    public static class A1 {\n+        protected static void func() { }\n+    }\n+\n+    public static class B1 extends A1 {\n+        public static Runnable get() {\n+            return A1::func;\n+        }\n+        public static void test() {\n+            func();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/superProtectedMethod\/ProtectedMethodInOtherPackage.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -1,141 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8227415 8254975\n- * @run testng\/othervm p.SuperMethodTest\n- * @summary method reference to a protected method inherited from its\n- *          superclass in a different runtime package where\n- *          lambda proxy class has no access to it.\n- *\/\n-\n-package p;\n-\n-import q.I;\n-import q.J;\n-\n-import java.io.IOException;\n-import java.io.UncheckedIOException;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.net.URL;\n-import java.net.URLClassLoader;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.function.Function;\n-\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n-public class SuperMethodTest  {\n-    @Test\n-    public static void remotePackageSameLoader() {\n-        Sub_I sub = new Sub_I();\n-        sub.test(Paths.get(\"test\"));\n-    }\n-\n-    public static class Sub_J extends J {\n-        Sub_J(Function<Path,String> function) {\n-            super(function);\n-        }\n-    }\n-\n-    public static class Sub_I extends I {\n-        public void test(Path path) {\n-            \/*\n-             * The method reference to an inherited protected method\n-             * in another package is desugared with REF_invokeVirtual on\n-             * a bridge method to invoke protected q.I::filename method\n-             *\/\n-            Sub_J c = new Sub_J(this::filename);\n-            c.check(path);\n-        }\n-    }\n-\n-    @Test\n-    public static void splitPackage() throws Throwable {\n-        ClassLoader parent = new Loader(\"loader-A\", null, A.class);\n-        ClassLoader loader = new Loader(\"loader-B\", parent, B.class);\n-        Class<?> aClass = Class.forName(A.class.getName(), false, loader);\n-        Class<?> bClass = Class.forName(B.class.getName(), false, loader);\n-        assertTrue(aClass.getClassLoader() == parent);\n-        assertTrue(bClass.getClassLoader() == loader);\n-        assertEquals(aClass.getPackageName(), bClass.getPackageName());\n-\n-        Object b = bClass.getDeclaredConstructor().newInstance();\n-\n-        \/\/ verify subclass can access a protected member inherited from\n-        \/\/ its superclass in a split package\n-        MethodHandle test = MethodHandles.lookup()\n-                .findVirtual(bClass, \"test\", MethodType.methodType(void.class));\n-        test.invoke(b);\n-\n-        \/\/ verify lambda can access a protected member inherited from\n-        \/\/ a superclass of the host class where the superclass is in\n-        \/\/ a split package (not the same runtime package as the host class)\n-        MethodHandle get = MethodHandles.lookup()\n-                .findVirtual(bClass, \"get\", MethodType.methodType(Runnable.class));\n-        ((Runnable) get.invoke(b)).run();\n-    }\n-\n-    static class Loader extends URLClassLoader {\n-        static final Path CLASSES_DIR = Paths.get(System.getProperty(\"test.class.path\"));\n-        private final Class<?> c;\n-        Loader(String name, ClassLoader parent, Class<?> c) {\n-            super(name, new URL[]{}, parent);\n-            this.c = c;\n-        }\n-\n-        @Override\n-        protected Class<?> findClass(String name) throws ClassNotFoundException {\n-            if (name.equals(c.getName())) {\n-                try {\n-                    String path = name.replace('.', '\/') + \".class\";\n-                    byte[] bytes = Files.readAllBytes(CLASSES_DIR.resolve(path));\n-                    return defineClass(name, bytes, 0, bytes.length);\n-                } catch (IOException e) {\n-                    throw new UncheckedIOException(e);\n-                }\n-            }\n-\n-            return super.findClass(name);\n-        }\n-\n-    }\n-\n-    public static class A {\n-        protected void func() { }\n-    }\n-\n-    public static class B extends A {\n-        public Runnable get() {\n-            return this::func;\n-        }\n-        public void test() {\n-            func();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/superProtectedMethod\/SuperMethodTest.java","additions":0,"deletions":141,"binary":false,"changes":141,"status":"deleted"}]}