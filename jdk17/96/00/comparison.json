{"files":[{"patch":"@@ -42,0 +42,1 @@\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -188,1 +189,2 @@\n-        synchronized (loadedLibraryNames) {\n+        acquireNativeLibraryLock(name);\n+        try {\n@@ -205,3 +207,2 @@\n-             * We use a static stack to hold the list of libraries we are\n-             * loading because this can happen only when called by the\n-             * same thread because this block is synchronous.\n+             * Each thread maintains its own stack to hold the list of\n+             * libraries it is loading.\n@@ -210,2 +211,2 @@\n-             * immediately return success; otherwise, we raise\n-             * UnsatisfiedLinkError.\n+             * immediately return success; if the pending load is from\n+             * a different class loader, we raise UnsatisfiedLinkError.\n@@ -213,1 +214,1 @@\n-            for (NativeLibraryImpl lib : nativeLibraryContext) {\n+            for (NativeLibraryImpl lib : NativeLibraryContext.current()) {\n@@ -226,1 +227,1 @@\n-            nativeLibraryContext.push(lib);\n+            NativeLibraryContext.push(lib);\n@@ -245,1 +246,1 @@\n-                nativeLibraryContext.pop();\n+                NativeLibraryContext.pop();\n@@ -251,0 +252,2 @@\n+        } finally {\n+            releaseNativeLibraryLock(name);\n@@ -298,1 +301,2 @@\n-        synchronized (loadedLibraryNames) {\n+        acquireNativeLibraryLock(lib.name());\n+        try {\n@@ -305,0 +309,2 @@\n+        } finally {\n+            releaseNativeLibraryLock(lib.name());\n@@ -418,1 +424,2 @@\n-            synchronized (loadedLibraryNames) {\n+            acquireNativeLibraryLock(name);\n+            try {\n@@ -423,1 +430,1 @@\n-                nativeLibraryContext.push(UNLOADER);\n+                NativeLibraryContext.push(UNLOADER);\n@@ -427,1 +434,1 @@\n-                    nativeLibraryContext.pop();\n+                    NativeLibraryContext.pop();\n@@ -429,0 +436,2 @@\n+            } finally {\n+                releaseNativeLibraryLock(name);\n@@ -446,3 +455,57 @@\n-    \/\/ This also serves as the lock to obtain nativeLibraries\n-    \/\/ and write to nativeLibraryContext.\n-    private static final Set<String> loadedLibraryNames = new HashSet<>();\n+    private static final Set<String> loadedLibraryNames =\n+            ConcurrentHashMap.newKeySet();\n+\n+    \/\/ reentrant lock class that allows exact counting (with external synchronization)\n+    @SuppressWarnings(\"serial\")\n+    private static final class CountedLock extends ReentrantLock {\n+\n+        private int counter = 0;\n+\n+        public void increment() {\n+            if (counter == Integer.MAX_VALUE) {\n+                \/\/ prevent overflow\n+                throw new Error(\"Maximum lock count exceeded\");\n+            }\n+            ++counter;\n+        }\n+\n+        public void decrement() {\n+            --counter;\n+        }\n+\n+        public int getCounter() {\n+            return counter;\n+        }\n+    }\n+\n+    \/\/ Maps native library name to the corresponding lock object\n+    private static final Map<String, CountedLock> nativeLibraryLockMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static void acquireNativeLibraryLock(String libraryName) {\n+        nativeLibraryLockMap.compute(libraryName, (name, currentLock) -> {\n+            if (currentLock == null) {\n+                currentLock = new CountedLock();\n+            }\n+            \/\/ safe as compute lambda is executed atomically\n+            currentLock.increment();\n+            return currentLock;\n+        }).lock();\n+    }\n+\n+    private static void releaseNativeLibraryLock(String libraryName) {\n+        CountedLock lock = nativeLibraryLockMap.computeIfPresent(libraryName, (name, currentLock) -> {\n+            if (currentLock.getCounter() == 1) {\n+                \/\/ unlock and release the object if no other threads are queued\n+                currentLock.unlock();\n+                \/\/ remove the element\n+                return null;\n+            } else {\n+                currentLock.decrement();\n+                return currentLock;\n+            }\n+        });\n+        if (lock != null) {\n+            lock.unlock();\n+        }\n+    }\n@@ -451,1 +514,38 @@\n-    private static Deque<NativeLibraryImpl> nativeLibraryContext = new ArrayDeque<>(8);\n+    private static final class NativeLibraryContext {\n+\n+        \/\/ Maps thread object to the native library context stack, maintained by each thread\n+        private static Map<Thread, Deque<NativeLibraryImpl>> nativeLibraryThreadContext =\n+                new ConcurrentHashMap<>();\n+\n+        \/\/ returns a context associated with the current thread\n+        private static Deque<NativeLibraryImpl> current() {\n+            return nativeLibraryThreadContext.computeIfAbsent(\n+                    Thread.currentThread(),\n+                    t -> new ArrayDeque<>(8));\n+        }\n+\n+        private static NativeLibraryImpl peek() {\n+            return current().peek();\n+        }\n+\n+        private static void push(NativeLibraryImpl lib) {\n+            current().push(lib);\n+        }\n+\n+        private static void pop() {\n+            \/\/ this does not require synchronization since each\n+            \/\/ thread has its own context\n+            Deque<NativeLibraryImpl> libs = current();\n+            libs.pop();\n+            if (libs.isEmpty()) {\n+                \/\/ context can be safely removed once empty\n+                nativeLibraryThreadContext.remove(Thread.currentThread());\n+            }\n+        }\n+\n+        private static boolean isEmpty() {\n+            Deque<NativeLibraryImpl> context =\n+                    nativeLibraryThreadContext.get(Thread.currentThread());\n+            return (context == null || context.isEmpty());\n+        }\n+    }\n@@ -456,1 +556,1 @@\n-        if (nativeLibraryContext.isEmpty()) { \/\/ only default library\n+        if (NativeLibraryContext.isEmpty()) { \/\/ only default library\n@@ -459,1 +559,1 @@\n-        return nativeLibraryContext.peek().fromClass;\n+        return NativeLibraryContext.peek().fromClass;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/NativeLibraries.java","additions":119,"deletions":19,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * Class1 loads a native library that calls ClassLoader.findClass in JNI_OnLoad.\n+ * Class1 runs concurrently with another thread that opens a signed jar file.\n+ *\/\n+class Class1 {\n+    static {\n+        System.loadLibrary(\"loadLibraryDeadlock\");\n+        System.out.println(\"Signed jar loaded from native library.\");\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/loadLibraryDeadlock\/Class1.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * LoadLibraryDeadlock class triggers the deadlock between the two\n+ * lock objects - ZipFile object and ClassLoader.loadedLibraryNames hashmap.\n+ * Thread #2 loads a signed jar which leads to acquiring the lock objects in\n+ * natural order (ZipFile then HashMap) - loading a signed jar may involve\n+ * Providers initialization. Providers may load native libraries.\n+ * Thread #1 acquires the locks in reverse order, first entering loadLibrary\n+ * called from Class1, then acquiring ZipFile during the search for a class\n+ * triggered from JNI.\n+ *\/\n+import java.lang.*;\n+\n+public class LoadLibraryDeadlock {\n+\n+    public static void main(String[] args) {\n+        Thread t1 = new Thread() {\n+            public void run() {\n+                try {\n+                    \/\/ an instance of unsigned class that loads a native library\n+                    Class<?> c1 = Class.forName(\"Class1\");\n+                    Object o = c1.newInstance();\n+                } catch (ClassNotFoundException |\n+                         InstantiationException |\n+                         IllegalAccessException e) {\n+                    System.out.println(\"Class Class1 not found.\");\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+        };\n+        Thread t2 = new Thread() {\n+            public void run() {\n+                try {\n+                    \/\/ load a class from a signed jar, which locks the JarFile\n+                    Class<?> c2 = Class.forName(\"p.Class2\");\n+                    System.out.println(\"Signed jar loaded.\");\n+                } catch (ClassNotFoundException e) {\n+                    System.out.println(\"Class Class2 not found.\");\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+        };\n+        t2.start();\n+        t1.start();\n+        try {\n+            t1.join();\n+            t2.join();\n+        } catch (InterruptedException ignore) {\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/loadLibraryDeadlock\/LoadLibraryDeadlock.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,249 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8266310\n+ * @summary Checks if there's no deadlock between the two lock objects -\n+ *          class loading lock and ClassLoader.loadedLibraryNames hashmap.\n+ * @library \/test\/lib\n+ * @build LoadLibraryDeadlock Class1 p.Class2\n+ * @run main\/othervm\/native -Xcheck:jni TestLoadLibraryDeadlock\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.JDKToolFinder;\n+import jdk.test.lib.process.*;\n+import jdk.test.lib.util.FileUtils;\n+\n+import java.lang.ProcessBuilder;\n+import java.lang.Process;\n+import java.nio.file.Paths;\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.*;\n+import java.util.spi.ToolProvider;\n+\n+public class TestLoadLibraryDeadlock {\n+\n+    private static final ToolProvider JAR = ToolProvider.findFirst(\"jar\")\n+            .orElseThrow(() -> new RuntimeException(\"ToolProvider for jar not found\"));\n+\n+    private static final String KEYSTORE = \"keystore.jks\";\n+    private static final String STOREPASS = \"changeit\";\n+    private static final String KEYPASS = \"changeit\";\n+    private static final String ALIAS = \"test\";\n+    private static final String DNAME = \"CN=test\";\n+    private static final String VALIDITY = \"366\";\n+\n+    private static String testClassPath = System.getProperty(\"test.classes\");\n+    private static String testLibraryPath = System.getProperty(\"test.nativepath\");\n+    private static String classPathSeparator = System.getProperty(\"path.separator\");\n+\n+    private static OutputAnalyzer runCommand(File workingDirectory, String... commands) throws Throwable {\n+        ProcessBuilder pb = new ProcessBuilder(commands);\n+        pb.directory(workingDirectory);\n+        System.out.println(\"COMMAND: \" + String.join(\" \", commands));\n+        return ProcessTools.executeProcess(pb);\n+    }\n+\n+    private static OutputAnalyzer runCommandInTestClassPath(String... commands) throws Throwable {\n+        return runCommand(new File(testClassPath), commands);\n+    }\n+\n+    private static OutputAnalyzer genKey() throws Throwable {\n+        FileUtils.deleteFileIfExistsWithRetry(\n+                Paths.get(testClassPath, KEYSTORE));\n+        String keytool = JDKToolFinder.getJDKTool(\"keytool\");\n+        return runCommandInTestClassPath(keytool,\n+                \"-storepass\", STOREPASS,\n+                \"-keypass\", KEYPASS,\n+                \"-keystore\", KEYSTORE,\n+                \"-keyalg\", \"rsa\", \"-keysize\", \"2048\",\n+                \"-genkeypair\",\n+                \"-alias\", ALIAS,\n+                \"-dname\", DNAME,\n+                \"-validity\", VALIDITY\n+        );\n+    }\n+\n+    private static void createJar(String outputJar, String... classes) throws Throwable {\n+        List<String> args = new ArrayList<>();\n+        Collections.addAll(args, \"cvf\", Paths.get(testClassPath, outputJar).toString());\n+        for (String c : classes) {\n+            Collections.addAll(args, \"-C\", testClassPath, c);\n+        }\n+        if (JAR.run(System.out, System.err, args.toArray(new String[0])) != 0) {\n+            throw new RuntimeException(\"jar operation failed\");\n+        }\n+    }\n+\n+    private static OutputAnalyzer signJar(String jarToSign) throws Throwable {\n+        String jarsigner = JDKToolFinder.getJDKTool(\"jarsigner\");\n+        return runCommandInTestClassPath(jarsigner,\n+                \"-keystore\", KEYSTORE,\n+                \"-storepass\", STOREPASS,\n+                jarToSign, ALIAS\n+        );\n+    }\n+\n+    private static Process runJavaCommand(String... command) throws Throwable {\n+        String java = JDKToolFinder.getJDKTool(\"java\");\n+        List<String> commands = new ArrayList<>();\n+        Collections.addAll(commands, java);\n+        Collections.addAll(commands, command);\n+        System.out.println(\"COMMAND: \" + String.join(\" \", commands));\n+        return new ProcessBuilder(commands.toArray(new String[0]))\n+                .redirectErrorStream(true)\n+                .directory(new File(testClassPath))\n+                .start();\n+    }\n+\n+    private static OutputAnalyzer jcmd(long pid, String command) throws Throwable {\n+        String jcmd = JDKToolFinder.getJDKTool(\"jcmd\");\n+        return runCommandInTestClassPath(jcmd,\n+                String.valueOf(pid),\n+                command\n+        );\n+    }\n+\n+    private static String readAvailable(final InputStream is) throws Throwable {\n+        final List<String> list = Collections.synchronizedList(new ArrayList<String>());\n+        ExecutorService executor = Executors.newFixedThreadPool(2);\n+        Future<String> future = executor.submit(new Callable<String>() {\n+            public String call() {\n+                String result = new String();\n+                BufferedReader reader = new BufferedReader(new InputStreamReader(is));\n+                try {\n+                    while(true) {\n+                        String s = reader.readLine();\n+                        if (s.length() > 0) {\n+                            list.add(s);\n+                            result += s + \"\\n\";\n+                        }\n+                    }\n+                } catch (IOException ignore) {}\n+                return result;\n+            }\n+        });\n+        try {\n+            return future.get(1000, TimeUnit.MILLISECONDS);\n+        } catch (Exception ignoreAll) {\n+            future.cancel(true);\n+            return String.join(\"\\n\", list);\n+        }\n+    }\n+\n+    private final static long countLines(OutputAnalyzer output, String string) {\n+        return output.asLines()\n+                     .stream()\n+                     .filter(s -> s.contains(string))\n+                     .count();\n+    }\n+\n+    private final static void dump(OutputAnalyzer output) {\n+        output.asLines()\n+              .stream()\n+              .forEach(s -> System.out.println(s));\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        genKey()\n+                .shouldHaveExitValue(0);\n+\n+        FileUtils.deleteFileIfExistsWithRetry(\n+                Paths.get(testClassPath, \"a.jar\"));\n+        FileUtils.deleteFileIfExistsWithRetry(\n+                Paths.get(testClassPath, \"b.jar\"));\n+        FileUtils.deleteFileIfExistsWithRetry(\n+                Paths.get(testClassPath, \"c.jar\"));\n+\n+        createJar(\"a.jar\",\n+                \"LoadLibraryDeadlock.class\",\n+                \"LoadLibraryDeadlock$1.class\",\n+                \"LoadLibraryDeadlock$2.class\");\n+\n+        createJar(\"b.jar\",\n+                \"Class1.class\");\n+\n+        createJar(\"c.jar\",\n+                \"p\/Class2.class\");\n+\n+        signJar(\"c.jar\")\n+                .shouldHaveExitValue(0);\n+\n+        \/\/ load trigger class\n+        Process process = runJavaCommand(\"-cp\",\n+                \"a.jar\" + classPathSeparator +\n+                \"b.jar\" + classPathSeparator +\n+                \"c.jar\",\n+                \"-Djava.library.path=\" + testLibraryPath,\n+                \"LoadLibraryDeadlock\");\n+\n+        \/\/ wait for a while to grab some output\n+        process.waitFor(5, TimeUnit.SECONDS);\n+\n+        \/\/ dump available output\n+        String output = readAvailable(process.getInputStream());\n+        OutputAnalyzer outputAnalyzer = new OutputAnalyzer(output);\n+        dump(outputAnalyzer);\n+\n+        \/\/ if the process is still running, get the thread dump\n+        OutputAnalyzer outputAnalyzerJcmd = jcmd(process.pid(), \"Thread.print\");\n+        dump(outputAnalyzerJcmd);\n+\n+        Asserts.assertTrue(\n+                countLines(outputAnalyzer, \"Java-level deadlock\") == 0,\n+                \"Found a deadlock.\");\n+\n+        \/\/ if no deadlock, make sure all components have been loaded\n+        Asserts.assertTrue(\n+                countLines(outputAnalyzer, \"Class Class1 not found.\") == 0,\n+                \"Unable to load class. Class1 not found.\");\n+\n+        Asserts.assertTrue(\n+                countLines(outputAnalyzer, \"Class Class2 not found.\") == 0,\n+                \"Unable to load class. Class2 not found.\");\n+\n+        Asserts.assertTrue(\n+                countLines(outputAnalyzer, \"Native library loaded.\") > 0,\n+                \"Unable to load native library.\");\n+\n+        Asserts.assertTrue(\n+                countLines(outputAnalyzer, \"Signed jar loaded.\") > 0,\n+                \"Unable to load signed jar.\");\n+\n+        Asserts.assertTrue(\n+                countLines(outputAnalyzer, \"Signed jar loaded from native library.\") > 0,\n+                \"Unable to load signed jar from native library.\");\n+\n+        if (!process.waitFor(5, TimeUnit.SECONDS)) {\n+            \/\/ if the process is still frozen, fail the test even though\n+            \/\/ the \"deadlock\" text hasn't been found\n+            process.destroyForcibly();\n+            Asserts.assertTrue(process.waitFor() == 0,\n+                    \"Process frozen.\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/loadLibraryDeadlock\/TestLoadLibraryDeadlock.java","additions":249,"deletions":0,"binary":false,"changes":249,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include \"jni.h\"\n+\n+\/*\n+ * Native library that loads an arbitrary class from a (signed) jar.\n+ * This triggers the search in jars, and the lock in ZipFile is acquired\n+ * as a result.\n+ *\/\n+JNIEXPORT jint JNICALL\n+JNI_OnLoad(JavaVM *vm, void *reserved)\n+{\n+    JNIEnv *env;\n+    jclass cl;\n+\n+    printf(\"Native library loaded.\\n\");\n+    fflush(stdout);\n+\n+    if ((*vm)->GetEnv(vm, (void**) &env, JNI_VERSION_1_2) != JNI_OK) {\n+        return JNI_EVERSION; \/* JNI version not supported *\/\n+    }\n+\n+    \/\/ find any class which triggers the search in jars\n+    cl = (*env)->FindClass(env, \"p\/Class2\");\n+\n+    return JNI_VERSION_1_2;\n+}\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/loadLibraryDeadlock\/libloadLibraryDeadlock.c","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * Class2 is loaded from Thread #2 that checks jar signature and from\n+ * Thread #1 that loads a native library.\n+ *\/\n+package p;\n+\n+class Class2 {}\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/loadLibraryDeadlock\/p\/Class2.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * LoadLibraryUnload class calls ClassLoader.loadedLibrary from multiple threads\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8266310\n+ * @summary Loads a native library from multiple class loaders and multiple\n+ *          threads. This creates a race for loading the library. The winner\n+ *          loads the library in two threads. All threads except two would fail\n+ *          with UnsatisfiedLinkError when the class being loaded is already\n+ *          loaded in a different class loader that won the race. The test\n+ *          checks that the loaded class is GC'ed, that means the class loader\n+ *          is GC'ed and the native library is unloaded.\n+ * @library \/test\/lib\n+ * @build LoadLibraryUnload p.Class1\n+ * @run main\/othervm\/native -Xcheck:jni LoadLibraryUnload\n+ *\/\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.util.ForceGC;\n+import java.lang.*;\n+import java.lang.reflect.*;\n+import java.lang.ref.WeakReference;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import p.Class1;\n+\n+public class LoadLibraryUnload {\n+\n+    private static class TestLoader extends URLClassLoader {\n+        public TestLoader() throws Exception {\n+            super(new URL[] { Path.of(System.getProperty(\"test.classes\")).toUri().toURL() });\n+        }\n+\n+        @Override\n+        public Class<?> loadClass(String name) throws ClassNotFoundException {\n+            synchronized (getClassLoadingLock(name)) {\n+                Class<?> clazz = findLoadedClass(name);\n+                if (clazz == null) {\n+                    try {\n+                        clazz = findClass(name);\n+                    } catch (ClassNotFoundException ignore) {\n+                    }\n+                    if (clazz == null) {\n+                        clazz = super.loadClass(name);\n+                    }\n+                }\n+                return clazz;\n+            }\n+        }\n+    }\n+\n+    private static class LoadLibraryFromClass implements Runnable {\n+        Object object;\n+        Method method;\n+\n+        public LoadLibraryFromClass(Class<?> fromClass) {\n+            try {\n+                this.object = fromClass.newInstance();\n+                this.method = fromClass.getDeclaredMethod(\"loadLibrary\");\n+            } catch (ReflectiveOperationException roe) {\n+                throw new RuntimeException(roe);\n+            }\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                method.invoke(object);\n+            } catch (ReflectiveOperationException roe) {\n+                throw new RuntimeException(roe);\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        Class<?> clazz = null;\n+        List<Thread> threads = new ArrayList<>();\n+\n+        for (int i = 0 ; i < 5 ; i++) {\n+            \/\/ 5 loaders and 10 threads in total.\n+            \/\/ winner loads the library in 2 threads\n+            clazz = new TestLoader().loadClass(\"p.Class1\");\n+            threads.add(new Thread(new LoadLibraryFromClass(clazz)));\n+            threads.add(new Thread(new LoadLibraryFromClass(clazz)));\n+        }\n+\n+        final Set<Throwable> exceptions = ConcurrentHashMap.newKeySet();\n+        threads.forEach( t -> {\n+            t.setUncaughtExceptionHandler((th, ex) -> {\n+                \/\/ collect the root cause of each failure\n+                Throwable rootCause = ex;\n+                while((ex = ex.getCause()) != null) {\n+                    rootCause = ex;\n+                }\n+                exceptions.add(rootCause);\n+            });\n+            t.start();\n+        });\n+\n+        \/\/ wait for all threads to finish\n+        for (Thread t : threads) {\n+            t.join();\n+        }\n+\n+        \/\/ expect all errors to be UnsatisfiedLinkError\n+        boolean allAreUnsatisfiedLinkError = exceptions\n+                .stream()\n+                .map(e -> e instanceof UnsatisfiedLinkError)\n+                .reduce(true, (i, a) -> i && a);\n+\n+        \/\/ expect exactly 8 errors\n+        Asserts.assertTrue(exceptions.size() == 8,\n+                \"Expected to see 8 failing threads\");\n+\n+        Asserts.assertTrue(allAreUnsatisfiedLinkError,\n+                \"All errors have to be UnsatisfiedLinkError\");\n+\n+        WeakReference<Class<?>> wClass = new WeakReference<>(clazz);\n+\n+        \/\/ release strong refs\n+        clazz = null;\n+        threads = null;\n+        exceptions.clear();\n+        ForceGC gc = new ForceGC();\n+        if (!gc.await(() -> wClass.refersTo(null))) {\n+            throw new RuntimeException(\"Class1 hasn't been GC'ed\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/loadLibraryUnload\/LoadLibraryUnload.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * LoadLibraryUnloadTest ensures all objects (NativeLibrary) are deallocated\n+ * when loaded in concurrent mode.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8266310\n+ * @summary Checks that JNI_OnLoad is invoked only once when multiple threads\n+ *          call System.loadLibrary concurrently, and JNI_OnUnload is invoked\n+ *          when the native library is loaded from a custom class loader.\n+ * @library \/test\/lib\n+ * @build LoadLibraryUnload p.Class1\n+ * @run main\/othervm\/native -Xcheck:jni LoadLibraryUnloadTest\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.JDKToolFinder;\n+import jdk.test.lib.process.*;\n+\n+import java.lang.ProcessBuilder;\n+import java.lang.Process;\n+import java.io.File;\n+import java.util.*;\n+\n+public class LoadLibraryUnloadTest {\n+\n+    private static String testClassPath = System.getProperty(\"test.classes\");\n+    private static String testLibraryPath = System.getProperty(\"test.nativepath\");\n+    private static String classPathSeparator = System.getProperty(\"path.separator\");\n+\n+    private static Process runJavaCommand(String... command) throws Throwable {\n+        String java = JDKToolFinder.getJDKTool(\"java\");\n+        List<String> commands = new ArrayList<>();\n+        Collections.addAll(commands, java);\n+        Collections.addAll(commands, command);\n+        System.out.println(\"COMMAND: \" + String.join(\" \", commands));\n+        return new ProcessBuilder(commands.toArray(new String[0]))\n+                .redirectErrorStream(true)\n+                .directory(new File(testClassPath))\n+                .start();\n+    }\n+\n+    private final static long countLines(OutputAnalyzer output, String string) {\n+        return output.asLines()\n+                     .stream()\n+                     .filter(s -> s.contains(string))\n+                     .count();\n+    }\n+\n+    private final static void dump(OutputAnalyzer output) {\n+        output.asLines()\n+              .stream()\n+              .forEach(s -> System.out.println(s));\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+\n+        Process process = runJavaCommand(\n+                \"-Dtest.classes=\" + testClassPath,\n+                \"-Djava.library.path=\" + testLibraryPath,\n+                \"LoadLibraryUnload\");\n+\n+        OutputAnalyzer outputAnalyzer = new OutputAnalyzer(process);\n+        dump(outputAnalyzer);\n+\n+        Asserts.assertTrue(\n+                countLines(outputAnalyzer, \"Native library loaded from Class1.\") == 2,\n+                \"Native library expected to be loaded in 2 threads.\");\n+\n+        long refCount = countLines(outputAnalyzer, \"Native library loaded.\");\n+\n+        Asserts.assertTrue(refCount > 0, \"Failed to load native library.\");\n+\n+        System.out.println(\"Native library loaded in \" + refCount + \" threads\");\n+\n+        Asserts.assertTrue(refCount == 1, \"Native library is loaded more than once.\");\n+\n+        Asserts.assertTrue(\n+                countLines(outputAnalyzer, \"Native library unloaded.\") == refCount,\n+                \"Failed to unload native library\");\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/loadLibraryUnload\/LoadLibraryUnloadTest.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include \"jni.h\"\n+\n+JNIEXPORT jint JNICALL\n+JNI_OnLoad(JavaVM *vm, void *reserved)\n+{\n+    JNIEnv *env;\n+\n+    printf(\"Native library loaded.\\n\");\n+    fflush(stdout);\n+\n+    if ((*vm)->GetEnv(vm, (void**) &env, JNI_VERSION_1_2) != JNI_OK) {\n+        return JNI_EVERSION; \/* JNI version not supported *\/\n+    }\n+\n+    return JNI_VERSION_1_2;\n+}\n+\n+JNIEXPORT void JNICALL\n+JNI_OnUnload(JavaVM *vm, void *reserved) {\n+\n+    printf(\"Native library unloaded.\\n\");\n+    fflush(stdout);\n+}\n+\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/loadLibraryUnload\/libloadLibraryUnload.c","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * Class1 loads a native library.\n+ *\/\n+package p;\n+\n+public class Class1 {\n+\n+    public Class1() {\n+    }\n+\n+    \/\/ method called from java threads\n+    public void loadLibrary() throws Exception {\n+        System.loadLibrary(\"loadLibraryUnload\");\n+        System.out.println(\"Native library loaded from Class1.\");\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/loadLibraryUnload\/p\/Class1.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"}]}