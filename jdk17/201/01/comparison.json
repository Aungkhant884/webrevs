{"files":[{"patch":"@@ -2037,1 +2037,5 @@\n-  if( true_path != 0 ) {\n+  if (true_path != 0 &&\n+      \/\/ If one of the diamond's branch is in the process of dying then, the Phi's input for that branch might transform\n+      \/\/ to top. If that happens replacing the Phi with an operation that consumes the Phi's inputs will cause the Phi\n+      \/\/ to be replaced by top. To prevent that, delay the transformation until the branch has a chance to be removed.\n+      !(can_reshape && wait_for_region_igvn(phase))) {\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8268883\n+ * @summary C2: assert(false) failed: unscheduable graph\n+ *\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileOnly=TestCondAddDeadBranch TestCondAddDeadBranch\n+ *\n+ *\/\n+\n+public class TestCondAddDeadBranch {\n+\n+    public static final int N = 400;\n+\n+    public static long instanceCount=47540L;\n+    public int iFld=-41658;\n+    public static float fFld=95.926F;\n+    public static double dFld=0.15667;\n+    public static int iFld1=4;\n+    public static short sFld=5587;\n+    public static short sArrFld[]=new short[N];\n+\n+    static {\n+        init(TestCondAddDeadBranch.sArrFld, (short)-26197);\n+    }\n+\n+    public static long vSmallMeth_check_sum = 0;\n+\n+    public static void vSmallMeth(long l, long l1, int i) {\n+        vSmallMeth_check_sum += l + l1 + i;\n+    }\n+\n+    public static void vMeth(int i1, int i2) {\n+        int i3=-27774, i4=9, i5=2, i6=12, i7=0, i8=-4, i29=53186;\n+        long lArr[][]=new long[N][N];\n+    }\n+\n+    public void mainTest(String[] strArr1) {\n+\n+        short s=838;\n+        int i31=238, i32=-19630, i33=-1, i34=181, i35=155, i36=-8401, i37=-50, i38=-153, iArr[][]=new int[N][N];\n+        float f1=46.763F, fArr[]=new float[N];\n+        byte byArr[]=new byte[N];\n+        boolean bArr[]=new boolean[N];\n+\n+        init(fArr, -59.7F);\n+        init(byArr, (byte)63);\n+        init(iArr, 39165);\n+\n+        for (float f : fArr) {\n+            for (int smallinvoc=0; smallinvoc<62; smallinvoc++) vSmallMeth(TestCondAddDeadBranch.instanceCount = ((TestCondAddDeadBranch.instanceCount++)\n+                * 65430), ((iFld + iFld) * (iFld++)) + (iFld + (iFld + iFld)), -s);\n+        }\n+        TestCondAddDeadBranch.instanceCount |= -2906416119L;\n+        for (byte by : byArr) {\n+            vMeth(iFld, -8);\n+            iFld |= (int)TestCondAddDeadBranch.instanceCount;\n+            i31 = 1;\n+            do {\n+                TestCondAddDeadBranch.sFld -= (short)TestCondAddDeadBranch.iFld1;\n+            } while (++i31 < 63);\n+        }\n+        for (i32 = 7; i32 < 160; i32++) {\n+            for (i34 = 1; i34 < 164; i34 += 3) {\n+                try {\n+                    iFld = (105 \/ i33);\n+                    TestCondAddDeadBranch.iFld1 = (iArr[i34 + 1][i34 + 1] % iArr[i32 + 1][i34 - 1]);\n+                    TestCondAddDeadBranch.iFld1 = (254 \/ i32);\n+                } catch (ArithmeticException a_e) {}\n+            }\n+            i33 <<= i31;\n+        }\n+        switch ((((TestCondAddDeadBranch.iFld1 >>> 1) % 5) * 5) + 60) {\n+        case 84:\n+        case 82:\n+            TestCondAddDeadBranch.fFld += TestCondAddDeadBranch.instanceCount;\n+            i36 = 1;\n+            break;\n+        case 83:\n+            TestCondAddDeadBranch.dFld += i32;\n+            break;\n+        }\n+\n+        System.out.println(\"s i31 i32 = \" + s + \",\" + i31 + \",\" + i32);\n+        System.out.println(\"i33 i34 i35 = \" + i33 + \",\" + i34 + \",\" + i35);\n+    }\n+\n+    public static void main(String[] strArr) {\n+        TestCondAddDeadBranch _instance = new TestCondAddDeadBranch();\n+        for (int i = 0; i < 10; i++ ) {\n+            _instance.mainTest(strArr);\n+        }\n+    }\n+\n+    public static void init(short[] a, short seed) {\n+        for (int j = 0; j < a.length; j++) {\n+            a[j] = (short) ((j % 2 == 0) ? seed + j : seed - j);\n+        }\n+    }\n+\n+    public static void init(float[] a, float seed) {\n+        for (int j = 0; j < a.length; j++) {\n+            a[j] = (j % 2 == 0) ? seed + j : seed - j;\n+        }\n+    }\n+\n+    public static void init(byte[] a, byte seed) {\n+        for (int j = 0; j < a.length; j++) {\n+            a[j] = (byte) ((j % 2 == 0) ? seed + j : seed - j);\n+        }\n+    }\n+\n+    public static void init(int[][] a, int seed) {\n+        for (int j = 0; j < a.length; j++) {\n+            init(a[j], seed);\n+        }\n+    }\n+\n+    public static void init(int[] a, int seed) {\n+        for (int j = 0; j < a.length; j++) {\n+            a[j] = (j % 2 == 0) ? seed + j : seed - j;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestCondAddDeadBranch.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"}]}