{"files":[{"patch":"@@ -519,3 +519,4 @@\n-     * @implSpec The default implementation simply calls\n-     * {@link RandomSupport#checkBound checkBound}(bound) and then\n-     * {@link RandomSupport#boundedNextFloat boundedNextFloat}(this, bound).\n+     * @implSpec The default implementation checks that {@code bound} is a\n+     * positive finite float. Then invokes {@code nextFloat()}, scaling\n+     * the result so that the final result lies between {@code 0.0f} (inclusive)\n+     * and {@code bound} (exclusive).\n@@ -543,3 +544,5 @@\n-     * @implSpec The default implementation simply calls\n-     * {@link RandomSupport#checkBound checkBound}(bound) and then\n-     * {@link RandomSupport#boundedNextFloat boundedNextFloat}(this, bound).\n+     * @implSpec The default implementation checks that {@code origin} and\n+     * {@code bound} are positive finite floats. Then invokes\n+     * {@code nextFloat()}, scaling and translating the result so that the final\n+     * result lies between {@code origin} (inclusive) and {@code bound}\n+     * (exclusive).\n@@ -580,3 +583,4 @@\n-     * @implSpec The default implementation simply calls\n-     * {@link RandomSupport#checkBound checkBound}(bound) and then\n-     * {@link RandomSupport#boundedNextDouble boundedNextDouble}(this, bound).\n+     * @implSpec The default implementation checks that {@code bound} is a\n+     * positive finite double. Then invokes {@code nextDouble()}, scaling\n+     * the result so that the final result lies between {@code 0.0} (inclusive)\n+     * and {@code bound} (exclusive).\n@@ -604,3 +608,5 @@\n-     * @implSpec The default implementation simply calls\n-     * {@link RandomSupport#checkBound checkBound}(bound) and then\n-     * {@link RandomSupport#boundedNextDouble boundedNextDouble}(this, bound).\n+     * @implSpec The default implementation checks that {@code origin} and\n+     * {@code bound} are positive finite doubles. Then calls\n+     * {@code nextDouble()}, scaling and translating the result so that the final\n+     * result lies between {@code origin} (inclusive) and {@code bound}\n+     * (exclusive).\n@@ -637,3 +643,7 @@\n-     * @implSpec The default implementation simply calls\n-     * {@link RandomSupport#checkBound checkBound}(bound) and then\n-     * {@link RandomSupport#boundedNextInt boundedNextInt}(this, bound).\n+     * @implSpec The default implementation checks that {@code bound} is a\n+     * positive int. Then invokes {@code nextInt()}, limiting the result to\n+     * be greater equal zero and less than {@code bound}. If {@code bound} is a\n+     * power of two then limiting is a simple masking operation. Otherwise, a\n+     * new result is re-calculated by averaging the previous result and\n+     * {@code nextInt()} until the final result is greater equal zero and less\n+     * than {@code bound}.\n@@ -660,3 +670,7 @@\n-     * @implSpec The default implementation simply calls\n-     * {@link RandomSupport#checkBound(long) checkBound}(bound) and then\n-     * {@link RandomSupport#boundedNextInt(RandomGenerator, int) boundedNextInt}(this, bound).\n+     * @implSpec The default implementation checks that {@code origin} and\n+     * {@code bound} are positive ints. Then invokes {@code nextInt()}, limiting\n+     * the result to be greater equal {@code origin} and less than {@code bound}.\n+     * If {@code bound} is a power of two then limiting is a simple masking\n+     * operation. Otherwise, a new result is re-calculated by averaging the\n+     * previous result and {@code nextInt()} until the final result is greater\n+     * equal {@code origin} and less than {@code bound}.\n@@ -688,3 +702,7 @@\n-     * @implSpec The default implementation simply calls\n-     * {@link RandomSupport#checkBound checkBound}(bound) and then\n-     * {@link RandomSupport#boundedNextLong boundedNextLong}(this, bound).\n+     * @implSpec The default implementation checks that {@code bound} is a\n+     * positive long. Then invokes {@code nextLong()}, limiting the result to\n+     * be greater equal zero and less than {@code bound}. If {@code bound} is a\n+     * power of two then limiting is a simple masking operation. Otherwise, a\n+     * new result is re-calculated by averaging the previous result and\n+     * {@code nextLong()} until the final result is greater equal zero and less\n+     * than {@code bound}.\n@@ -711,3 +729,7 @@\n-     * @implSpec The default implementation simply calls\n-     * {@link RandomSupport#checkBound checkBound}(bound) and then\n-     * {@link RandomSupport#boundedNextLong boundedNextLong}(this, bound).\n+     * @implSpec The default implementation checks that {@code origin} and\n+     * {@code bound} are positive longs. Then invokes {@code nextLong()},\n+     * limiting the result to be greater equal {@code origin} and less than\n+     * {@code bound}. If {@code bound} is a power of two then limiting is a\n+     * simple masking operation. Otherwise, a new result is re-calculated by\n+     * averaging the previous result and {@code nextLong()} until the final\n+     * result is greater equal {@code origin} and less than {@code bound}.\n@@ -895,4 +917,0 @@\n-         * @implNote Availability is determined by RandomGeneratorFactory using the\n-         * service provider API to locate implementations of the RandomGenerator\n-         * interface and filtering on the SplittableGenerator interface.\n-         *\n","filename":"src\/java.base\/share\/classes\/java\/util\/random\/RandomGenerator.java","additions":46,"deletions":28,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -377,1 +377,1 @@\n-     * RandomGenerators that are marked as deprecated or are not properly configured are not included in the result.\n+     * RandomGenerators that are marked as deprecated are not included in the result.\n","filename":"src\/java.base\/share\/classes\/java\/util\/random\/RandomGeneratorFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}