{"files":[{"patch":"@@ -1687,1 +1687,0 @@\n-            boolean prevCompletedNormally = false;\n@@ -1705,1 +1704,1 @@\n-                                log.error(c.pos(), Errors.DuplicateCaseLabel);\n+                                log.error(pat.pos(), Errors.DuplicateCaseLabel);\n@@ -1707,1 +1706,1 @@\n-                                log.error(c.pos(), Errors.PatternDominated);\n+                                log.error(pat.pos(), Errors.PatternDominated);\n@@ -1717,1 +1716,1 @@\n-                                log.error(c.pos(), Errors.DuplicateCaseLabel);\n+                                log.error(pat.pos(), Errors.DuplicateCaseLabel);\n@@ -1761,3 +1760,0 @@\n-                        } else if (matchBindings.bindingsWhenTrue.nonEmpty()) {\n-                            \/\/there was a pattern, and the execution flows into a default:\n-                            log.error(pat.pos(), Errors.FlowsThroughFromPattern);\n@@ -1768,3 +1764,0 @@\n-                        if (prevCompletedNormally) {\n-                            log.error(pat.pos(), Errors.FlowsThroughToPattern);\n-                        }\n@@ -1797,1 +1790,0 @@\n-                    prevCompletedNormally = !TreeInfo.isNull(pat);\n@@ -1808,6 +1800,7 @@\n-                boolean completesNormally = c.caseKind == CaseTree.CaseKind.STATEMENT ? flow.aliveAfter(caseEnv, c, make) : false;\n-                prevBindings = completesNormally ? currentBindings : null;\n-                prevCompletedNormally =\n-                        completesNormally &&\n-                        !(c.labels.size() == 1 &&\n-                          TreeInfo.isNull(c.labels.head) && c.stats.isEmpty());\n+                c.completesNormally = flow.aliveAfter(caseEnv, c, make);\n+\n+                prevBindings = c.caseKind == CaseTree.CaseKind.STATEMENT && c.completesNormally ? currentBindings\n+                                                                                                : null;\n+            }\n+            if (patternSwitch) {\n+                chk.checkSwitchCaseStructure(cases);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":10,"deletions":17,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import com.sun.source.tree.CaseTree;\n@@ -4273,0 +4274,62 @@\n+    \/**\n+     * Verify the case labels conform to the constraints. Checks constraints related\n+     * combinations of patterns and other labels.\n+     *\n+     * @param cases the cases that should be checked.\n+     *\/\n+    void checkSwitchCaseStructure(List<JCCase> cases) {\n+        boolean wasConstant = false;          \/\/ Seen a constant in the same case label\n+        boolean wasDefault = false;           \/\/ Seen a default in the same case label\n+        boolean wasNullPattern = false;       \/\/ Seen a null pattern in the same case label,\n+                                              \/\/or fall through from a null pattern\n+        boolean wasPattern = false;           \/\/ Seen a pattern in the same case label\n+                                              \/\/or fall through from a pattern\n+        boolean wasTypePattern = false;       \/\/ Seen a pattern in the same case label\n+                                              \/\/or fall through from a type pattern\n+        boolean wasNonEmptyFallThrough = false;\n+        for (List<JCCase> l = cases; l.nonEmpty(); l = l.tail) {\n+            JCCase c = l.head;\n+            for (JCCaseLabel pat : c.labels) {\n+                if (pat.isExpression()) {\n+                    JCExpression expr = (JCExpression) pat;\n+                    if (TreeInfo.isNull(expr)) {\n+                        if (wasPattern && !wasTypePattern && !wasNonEmptyFallThrough) {\n+                            log.error(pat.pos(), Errors.FlowsThroughFromPattern);\n+                        }\n+                        wasNullPattern = true;\n+                    } else {\n+                        if (wasPattern && !wasNonEmptyFallThrough) {\n+                            log.error(pat.pos(), Errors.FlowsThroughFromPattern);\n+                        }\n+                        wasConstant = true;\n+                    }\n+                } else if (pat.hasTag(DEFAULTCASELABEL)) {\n+                    if (wasPattern && !wasNonEmptyFallThrough) {\n+                        log.error(pat.pos(), Errors.FlowsThroughFromPattern);\n+                    }\n+                    wasDefault = true;\n+                } else {\n+                    boolean isTypePattern = pat.hasTag(BINDINGPATTERN);\n+                    if (wasPattern || wasConstant || wasDefault ||\n+                        (wasNullPattern && (!isTypePattern || wasNonEmptyFallThrough))) {\n+                        log.error(pat.pos(), Errors.FlowsThroughToPattern);\n+                    }\n+                    wasPattern = true;\n+                    wasTypePattern = isTypePattern;\n+                }\n+            }\n+\n+            boolean completesNormally = c.caseKind == CaseTree.CaseKind.STATEMENT ? c.completesNormally\n+                                                                                  : false;\n+\n+            if (c.stats.nonEmpty()) {\n+                wasConstant = false;\n+                wasDefault = false;\n+                wasNullPattern &= completesNormally;\n+                wasPattern &= completesNormally;\n+                wasTypePattern &= completesNormally;\n+            }\n+\n+            wasNonEmptyFallThrough = c.stats.nonEmpty() && completesNormally;\n+        }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -680,1 +680,0 @@\n-                c.completesNormally = alive != Liveness.DEAD;\n@@ -728,1 +727,0 @@\n-                c.completesNormally = alive != Liveness.DEAD;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -132,3 +132,0 @@\n-        if (!prevBindings.bindingsWhenTrue.isEmpty() && !currentBindings.bindingsWhenTrue.isEmpty()) {\n-            log.error(tree.pos(), Errors.FlowsThroughToPattern);\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/MatchBindingsComputer.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8269146\n+ * @summary Check compilation outcomes for various combinations of case label element.\n+ * @library \/tools\/lib \/tools\/javac\/lib\n+ * @modules\n+ *      jdk.compiler\/com.sun.tools.javac.api\n+ *      jdk.compiler\/com.sun.tools.javac.file\n+ *      jdk.compiler\/com.sun.tools.javac.main\n+ *      jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @build combo.ComboTestHelper\n+ * @compile CaseStructureTest.java\n+ * @run main CaseStructureTest\n+ *\/\n+\n+import combo.ComboInstance;\n+import combo.ComboParameter;\n+import combo.ComboTask;\n+import combo.ComboTestHelper;\n+import java.util.Arrays;\n+import java.util.stream.Collectors;\n+import toolbox.ToolBox;\n+\n+public class CaseStructureTest extends ComboInstance<CaseStructureTest> {\n+    private static final String JAVA_VERSION = System.getProperty(\"java.specification.version\");\n+\n+    protected ToolBox tb;\n+\n+    CaseStructureTest() {\n+        super();\n+        tb = new ToolBox();\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        new ComboTestHelper<CaseStructureTest>()\n+                .withDimension(\"AS_CASE_LABEL_ELEMENTS\", (x, asCaseLabelElements) -> x.asCaseLabelElements = asCaseLabelElements, true, false)\n+                .withArrayDimension(\"CASE_LABELS\", (x, caseLabels, idx) -> x.caseLabels[idx] = caseLabels, DIMENSIONS, CaseLabel.values())\n+                .withFilter(t -> Arrays.stream(t.caseLabels).anyMatch(l -> l != CaseLabel.NONE))\n+                .withFailMode(ComboTestHelper.FailMode.FAIL_FAST)\n+                .run(CaseStructureTest::new);\n+    }\n+\n+    private static final int DIMENSIONS = 4;\n+    private boolean asCaseLabelElements;\n+    private CaseLabel[] caseLabels = new CaseLabel[DIMENSIONS];\n+\n+    private static final String MAIN_TEMPLATE =\n+            \"\"\"\n+            public class Test {\n+                public static void doTest(Integer in) {\n+                    switch (in) {\n+                        case -1: break;\n+                        #{CASES}\n+                        #{DEFAULT}\n+                    }\n+                }\n+            }\n+            \"\"\";\n+\n+    @Override\n+    protected void doWork() throws Throwable {\n+        String labelSeparator = asCaseLabelElements ? \", \" : \": case \";\n+        String labels = Arrays.stream(caseLabels).filter(l -> l != CaseLabel.NONE).map(l -> l.code).collect(Collectors.joining(labelSeparator, \"case \", \": break;\"));\n+        boolean hasDefault = Arrays.stream(caseLabels).anyMatch(l -> l == CaseLabel.DEFAULT || l == CaseLabel.TYPE_PATTERN || l == CaseLabel.PARENTHESIZED_PATTERN);\n+\n+        ComboTask task = newCompilationTask()\n+                .withSourceFromTemplate(MAIN_TEMPLATE.replace(\"#{CASES}\", labels).replace(\"#{DEFAULT}\", hasDefault ? \"\" : \"default: break;\"))\n+                .withOption(\"--enable-preview\")\n+                .withOption(\"-source\").withOption(JAVA_VERSION);\n+\n+        task.generate(result -> {\n+            boolean shouldPass = true;\n+            long patternCases = Arrays.stream(caseLabels).filter(l -> l == CaseLabel.TYPE_PATTERN || l == CaseLabel.GUARDED_PATTERN || l == CaseLabel.PARENTHESIZED_PATTERN).count();\n+            long typePatternCases = Arrays.stream(caseLabels).filter(l -> l == CaseLabel.TYPE_PATTERN).count();\n+            long constantCases = Arrays.stream(caseLabels).filter(l -> l == CaseLabel.CONSTANT).count();\n+            long nullCases = Arrays.stream(caseLabels).filter(l -> l == CaseLabel.NULL).count();\n+            long defaultCases = Arrays.stream(caseLabels).filter(l -> l == CaseLabel.DEFAULT).count();\n+            if (constantCases > 1) {\n+                shouldPass &= false;\n+            }\n+            if (constantCases > 0) {\n+                shouldPass &= patternCases == 0;\n+            }\n+            if (defaultCases > 1) {\n+                shouldPass &= false;\n+            }\n+            if (nullCases > 1) {\n+                shouldPass &= false;\n+            }\n+            if (nullCases > 0 && patternCases > 0) {\n+                shouldPass &= patternCases == typePatternCases;\n+            }\n+            if (patternCases > 1) {\n+                shouldPass &= false;\n+            }\n+            if (patternCases > 0 && defaultCases > 0) {\n+                shouldPass &= false;\n+            }\n+            if (!asCaseLabelElements) {\n+                \/\/as an edge case, `case <total-pattern>: case null:` is prohibited:\n+                boolean seenPattern = false;\n+                for (CaseLabel label : caseLabels) {\n+                    switch (label) {\n+                        case NULL: if (seenPattern) shouldPass = false; break;\n+                        case GUARDED_PATTERN, PARENTHESIZED_PATTERN, TYPE_PATTERN: seenPattern = true; break;\n+                    }\n+                }\n+            }\n+            if (!(shouldPass ^ result.hasErrors())) {\n+                throw new AssertionError(\"Unexpected result: shouldPass=\" + shouldPass + \", actual: \" + !result.hasErrors() + \", info: \" + result.compilationInfo());\n+            }\n+        });\n+    }\n+\n+    public enum CaseLabel implements ComboParameter {\n+        NONE(\"\"),\n+        TYPE_PATTERN(\"Integer i\"),\n+        PARENTHESIZED_PATTERN(\"(Integer i)\"),\n+        GUARDED_PATTERN(\"Integer i && i > 0\"),\n+        CONSTANT(\"1\"),\n+        NULL(\"null\"),\n+        DEFAULT(\"default\");\n+\n+        private final String code;\n+\n+        private CaseLabel(String code) {\n+            this.code = code;\n+        }\n+\n+        @Override\n+        public String expand(String optParameter) {\n+            throw new UnsupportedOperationException(\"Not supported.\");\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/CaseStructureTest.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -3,1 +3,1 @@\n- * @bug 8262891\n+ * @bug 8262891 8269146\n@@ -188,0 +188,32 @@\n+    void test8269146a(Integer i) {\n+        switch (i) {\n+            \/\/error - illegal combination of pattern and constant:\n+            case Integer o && o != null, 1:\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+    void test8269146b(Integer i) {\n+        switch (i) {\n+            \/\/error - illegal combination of null and pattern other than type pattern:\n+            case null, Integer o && o != null:\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+    void test8269146c(Integer i) {\n+        switch (i) {\n+            \/\/error - illegal combination of pattern and default:\n+            case Integer o, default:\n+                break;\n+        }\n+    }\n+    void test8269301(Integer i) {\n+        switch (i) {\n+            \/\/error - illegal combination of pattern, constant and default\n+            case Integer o && o != null, 1, default:\n+                break;\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.java","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n-SwitchErrors.java:42:13: compiler.err.pattern.dominated\n+SwitchErrors.java:42:18: compiler.err.pattern.dominated\n@@ -16,2 +16,2 @@\n-SwitchErrors.java:77:13: compiler.err.duplicate.case.label\n-SwitchErrors.java:82:13: compiler.err.duplicate.case.label\n+SwitchErrors.java:77:18: compiler.err.duplicate.case.label\n+SwitchErrors.java:82:24: compiler.err.duplicate.case.label\n@@ -30,1 +30,1 @@\n-SwitchErrors.java:160:13: compiler.err.pattern.dominated\n+SwitchErrors.java:160:18: compiler.err.pattern.dominated\n@@ -34,0 +34,5 @@\n+SwitchErrors.java:191:42: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:200:24: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:209:29: compiler.err.total.pattern.and.default\n+SwitchErrors.java:216:42: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:216:45: compiler.err.flows.through.from.pattern\n@@ -45,1 +50,1 @@\n-SwitchErrors.java:189:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:221:9: compiler.err.not.exhaustive.statement\n@@ -48,1 +53,1 @@\n-45 errors\n+50 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.out","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -70,0 +70,2 @@\n+        runFallThrough(this::testFallThrough2Statement);\n+        runFallThrough(this::testFallThrough2Expression);\n@@ -400,0 +402,27 @@\n+    Integer testFallThrough2Statement(Integer i) {\n+        int r = 0;\n+\n+        switch (i) {\n+            case Integer o && o != null:\n+                r = 1;\n+            case -1: r = 1;\n+            case null, default:\n+                r = 2;\n+        }\n+\n+        return r;\n+    }\n+\n+    Integer testFallThrough2Expression(Integer i) {\n+        int r = switch (i) {\n+            case Integer o && o != null:\n+                r = 1;\n+            case -1: r = 1;\n+            case null, default:\n+                r = 2;\n+                yield r;\n+        };\n+\n+        return r;\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/Switches.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"}]}