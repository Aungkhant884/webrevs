{"files":[{"patch":"@@ -1684,0 +1684,9 @@\n+            boolean wasConstant = false;          \/\/ Seen a constant in the same case label\n+            boolean wasDefault = false;           \/\/ Seen a default in the same case label\n+            boolean wasNullPattern = false;       \/\/ Seen a null pattern in the same case label,\n+                                                  \/\/or fall through from a null pattern\n+            boolean wasPattern = false;           \/\/ Seen a pattern in the same case label\n+                                                  \/\/or fall through from a pattern\n+            boolean wasTypePattern = false;       \/\/ Seen a pattern in the same case label\n+                                                  \/\/or fall through from a type pattern\n+            boolean wasNonEmptyFallThrough = false;\n@@ -1687,1 +1696,0 @@\n-            boolean prevCompletedNormally = false;\n@@ -1705,1 +1713,1 @@\n-                                log.error(c.pos(), Errors.DuplicateCaseLabel);\n+                                log.error(pat.pos(), Errors.DuplicateCaseLabel);\n@@ -1707,1 +1715,3 @@\n-                                log.error(c.pos(), Errors.PatternDominated);\n+                                log.error(pat.pos(), Errors.PatternDominated);\n+                            } else if (wasPattern && !wasTypePattern && !wasNonEmptyFallThrough) {\n+                                log.error(pat.pos(), Errors.FlowsThroughFromPattern);\n@@ -1709,1 +1719,1 @@\n-                            hasNullPattern = true;\n+                            wasNullPattern = hasNullPattern = true;\n@@ -1712,20 +1722,0 @@\n-                        } else if (enumSwitch) {\n-                            Symbol sym = enumConstant(expr, seltype);\n-                            if (sym == null) {\n-                                log.error(expr.pos(), Errors.EnumLabelMustBeUnqualifiedEnum);\n-                            } else if (!labels.add(sym)) {\n-                                log.error(c.pos(), Errors.DuplicateCaseLabel);\n-                            } else {\n-                                checkCaseLabelDominated(pat.pos(), coveredTypes, sym.type);\n-                            }\n-                        } else if (errorEnumSwitch) {\n-                            \/\/error recovery: the selector is erroneous, and all the case labels\n-                            \/\/are identifiers. This could be an enum switch - don't report resolve\n-                            \/\/error for the case label:\n-                            var prevResolveHelper = rs.basicLogResolveHelper;\n-                            try {\n-                                rs.basicLogResolveHelper = rs.silentLogResolveHelper;\n-                                attribExpr(pat, switchEnv, seltype);\n-                            } finally {\n-                                rs.basicLogResolveHelper = prevResolveHelper;\n-                            }\n@@ -1733,10 +1723,39 @@\n-                            ResultInfo valTypInfo = new ResultInfo(KindSelector.VAL_TYP,\n-                                                                   !seltype.hasTag(ERROR) ? seltype\n-                                                                                          : Type.noType);\n-                            Type pattype = attribTree(expr, switchEnv, valTypInfo);\n-                            if (!pattype.hasTag(ERROR)) {\n-                                if (pattype.constValue() == null) {\n-                                    Symbol s = TreeInfo.symbol(expr);\n-                                    if (s != null && s.kind == TYP && allowPatternSwitch) {\n-                                        log.error(expr.pos(),\n-                                                  Errors.PatternExpected);\n+                            if (enumSwitch) {\n+                                Symbol sym = enumConstant(expr, seltype);\n+                                if (sym == null) {\n+                                    log.error(expr.pos(), Errors.EnumLabelMustBeUnqualifiedEnum);\n+                                } else if (!labels.add(sym)) {\n+                                    log.error(pat.pos(), Errors.DuplicateCaseLabel);\n+                                } else {\n+                                    checkCaseLabelDominated(pat.pos(), coveredTypes, sym.type);\n+                                }\n+                            } else if (errorEnumSwitch) {\n+                                \/\/error recovery: the selector is erroneous, and all the case labels\n+                                \/\/are identifiers. This could be an enum switch - don't report resolve\n+                                \/\/error for the case label:\n+                                var prevResolveHelper = rs.basicLogResolveHelper;\n+                                try {\n+                                    rs.basicLogResolveHelper = rs.silentLogResolveHelper;\n+                                    attribExpr(pat, switchEnv, seltype);\n+                                } finally {\n+                                    rs.basicLogResolveHelper = prevResolveHelper;\n+                                }\n+                            } else {\n+                                ResultInfo valTypInfo = new ResultInfo(KindSelector.VAL_TYP,\n+                                                                       !seltype.hasTag(ERROR) ? seltype\n+                                                                                              : Type.noType);\n+                                Type pattype = attribTree(expr, switchEnv, valTypInfo);\n+                                if (!pattype.hasTag(ERROR)) {\n+                                    if (pattype.constValue() == null) {\n+                                        Symbol s = TreeInfo.symbol(expr);\n+                                        if (s != null && s.kind == TYP && allowPatternSwitch) {\n+                                            log.error(expr.pos(),\n+                                                      Errors.PatternExpected);\n+                                        } else {\n+                                            log.error(expr.pos(),\n+                                                      (stringSwitch ? Errors.StringConstReq : Errors.ConstExprReq));\n+                                        }\n+                                    } else if (!stringSwitch && !types.isAssignable(seltype, syms.intType)) {\n+                                        log.error(pat.pos(), Errors.ConstantLabelNotCompatible(pattype, seltype));\n+                                    } else if (!labels.add(pattype.constValue())) {\n+                                        log.error(c.pos(), Errors.DuplicateCaseLabel);\n@@ -1744,2 +1763,1 @@\n-                                        log.error(expr.pos(),\n-                                                  (stringSwitch ? Errors.StringConstReq : Errors.ConstExprReq));\n+                                        checkCaseLabelDominated(pat.pos(), coveredTypes, types.boxedTypeOrType(pattype));\n@@ -1747,6 +1765,0 @@\n-                                } else if (!stringSwitch && !types.isAssignable(seltype, syms.intType)) {\n-                                    log.error(pat.pos(), Errors.ConstantLabelNotCompatible(pattype, seltype));\n-                                } else if (!labels.add(pattype.constValue())) {\n-                                    log.error(c.pos(), Errors.DuplicateCaseLabel);\n-                                } else {\n-                                    checkCaseLabelDominated(pat.pos(), coveredTypes, types.boxedTypeOrType(pattype));\n@@ -1755,0 +1767,4 @@\n+                            if (wasPattern && !wasNonEmptyFallThrough) {\n+                                log.error(pat.pos(), Errors.FlowsThroughFromPattern);\n+                            }\n+                            wasConstant = true;\n@@ -1761,2 +1777,1 @@\n-                        } else if (matchBindings.bindingsWhenTrue.nonEmpty()) {\n-                            \/\/there was a pattern, and the execution flows into a default:\n+                        } else if (wasPattern && !wasNonEmptyFallThrough) {\n@@ -1766,0 +1781,1 @@\n+                        wasDefault = true;\n@@ -1768,1 +1784,3 @@\n-                        if (prevCompletedNormally) {\n+                        boolean isTypePattern = pat.hasTag(BINDINGPATTERN);\n+                        if (wasPattern || wasConstant || wasDefault ||\n+                            (wasNullPattern && (!isTypePattern || wasNonEmptyFallThrough))) {\n@@ -1771,0 +1789,2 @@\n+                        wasPattern = true;\n+                        wasTypePattern = isTypePattern;\n@@ -1797,1 +1817,0 @@\n-                    prevCompletedNormally = !TreeInfo.isNull(pat);\n@@ -1809,0 +1828,10 @@\n+\n+                if (c.stats.nonEmpty()) {\n+                    wasConstant = false;\n+                    wasDefault = false;\n+                    wasNullPattern &= completesNormally;\n+                    wasPattern &= completesNormally;\n+                    wasTypePattern &= completesNormally;\n+                }\n+\n+                wasNonEmptyFallThrough = c.stats.nonEmpty() && completesNormally;\n@@ -1810,4 +1839,0 @@\n-                prevCompletedNormally =\n-                        completesNormally &&\n-                        !(c.labels.size() == 1 &&\n-                          TreeInfo.isNull(c.labels.head) && c.stats.isEmpty());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":75,"deletions":50,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -132,3 +132,0 @@\n-        if (!prevBindings.bindingsWhenTrue.isEmpty() && !currentBindings.bindingsWhenTrue.isEmpty()) {\n-            log.error(tree.pos(), Errors.FlowsThroughToPattern);\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/MatchBindingsComputer.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8269146\n+ * @summary Check compilation outcomes for various combinations of case label element.\n+ * @library \/tools\/lib \/tools\/javac\/lib\n+ * @modules\n+ *      jdk.compiler\/com.sun.tools.javac.api\n+ *      jdk.compiler\/com.sun.tools.javac.file\n+ *      jdk.compiler\/com.sun.tools.javac.main\n+ *      jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @build combo.ComboTestHelper\n+ * @compile CaseStructureTest.java\n+ * @run main CaseStructureTest\n+ *\/\n+\n+import combo.ComboInstance;\n+import combo.ComboParameter;\n+import combo.ComboTask;\n+import combo.ComboTestHelper;\n+import java.util.Arrays;\n+import java.util.stream.Collectors;\n+import toolbox.ToolBox;\n+\n+public class CaseStructureTest extends ComboInstance<CaseStructureTest> {\n+    private static final String JAVA_VERSION = System.getProperty(\"java.specification.version\");\n+\n+    protected ToolBox tb;\n+\n+    CaseStructureTest() {\n+        super();\n+        tb = new ToolBox();\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        new ComboTestHelper<CaseStructureTest>()\n+                .withDimension(\"AS_CASE_LABEL_ELEMENTS\", (x, asCaseLabelElements) -> x.asCaseLabelElements = asCaseLabelElements, true, false)\n+                .withArrayDimension(\"CASE_LABELS\", (x, caseLabels, idx) -> x.caseLabels[idx] = caseLabels, DIMENSIONS, CaseLabel.values())\n+                .withFilter(t -> Arrays.stream(t.caseLabels).anyMatch(l -> l != CaseLabel.NONE))\n+                .withFailMode(ComboTestHelper.FailMode.FAIL_FAST)\n+                .run(CaseStructureTest::new);\n+    }\n+\n+    private static final int DIMENSIONS = 4;\n+    private boolean asCaseLabelElements;\n+    private CaseLabel[] caseLabels = new CaseLabel[DIMENSIONS];\n+\n+    private static final String MAIN_TEMPLATE =\n+            \"\"\"\n+            public class Test {\n+                public static void doTest(Integer in) {\n+                    switch (in) {\n+                        case -1: break;\n+                        #{CASES}\n+                        #{DEFAULT}\n+                    }\n+                }\n+            }\n+            \"\"\";\n+\n+    @Override\n+    protected void doWork() throws Throwable {\n+        String labelSeparator = asCaseLabelElements ? \", \" : \": case \";\n+        String labels = Arrays.stream(caseLabels).filter(l -> l != CaseLabel.NONE).map(l -> l.code).collect(Collectors.joining(labelSeparator, \"case \", \": break;\"));\n+        boolean hasDefault = Arrays.stream(caseLabels).anyMatch(l -> l == CaseLabel.DEFAULT || l == CaseLabel.TYPE_PATTERN || l == CaseLabel.PARENTHESIZED_PATTERN);\n+\n+        ComboTask task = newCompilationTask()\n+                .withSourceFromTemplate(MAIN_TEMPLATE.replace(\"#{CASES}\", labels).replace(\"#{DEFAULT}\", hasDefault ? \"\" : \"default: break;\"))\n+                .withOption(\"--enable-preview\")\n+                .withOption(\"-source\").withOption(JAVA_VERSION);\n+\n+        task.generate(result -> {\n+            boolean shouldPass = true;\n+            long patternCases = Arrays.stream(caseLabels).filter(l -> l == CaseLabel.TYPE_PATTERN || l == CaseLabel.GUARDED_PATTERN || l == CaseLabel.PARENTHESIZED_PATTERN).count();\n+            long typePatternCases = Arrays.stream(caseLabels).filter(l -> l == CaseLabel.TYPE_PATTERN).count();\n+            long constantCases = Arrays.stream(caseLabels).filter(l -> l == CaseLabel.CONSTANT).count();\n+            long nullCases = Arrays.stream(caseLabels).filter(l -> l == CaseLabel.NULL).count();\n+            long defaultCases = Arrays.stream(caseLabels).filter(l -> l == CaseLabel.DEFAULT).count();\n+            if (constantCases > 1) {\n+                shouldPass &= false;\n+            }\n+            if (constantCases > 0) {\n+                shouldPass &= patternCases == 0;\n+            }\n+            if (defaultCases > 1) {\n+                shouldPass &= false;\n+            }\n+            if (nullCases > 1) {\n+                shouldPass &= false;\n+            }\n+            if (nullCases > 0 && patternCases > 0) {\n+                shouldPass &= patternCases == typePatternCases;\n+            }\n+            if (patternCases > 1) {\n+                shouldPass &= false;\n+            }\n+            if (patternCases > 0 && defaultCases > 0) {\n+                shouldPass &= false;\n+            }\n+            if (!asCaseLabelElements) {\n+                \/\/as an edge case, `case <total-pattern>: case null:` is prohibited:\n+                boolean seenPattern = false;\n+                for (CaseLabel label : caseLabels) {\n+                    switch (label) {\n+                        case NULL: if (seenPattern) shouldPass = false; break;\n+                        case GUARDED_PATTERN, PARENTHESIZED_PATTERN, TYPE_PATTERN: seenPattern = true; break;\n+                    }\n+                }\n+            }\n+            if (!(shouldPass ^ result.hasErrors())) {\n+                throw new AssertionError(\"Unexpected result: shouldPass=\" + shouldPass + \", actual: \" + !result.hasErrors() + \", info: \" + result.compilationInfo());\n+            }\n+        });\n+    }\n+\n+    public enum CaseLabel implements ComboParameter {\n+        NONE(\"\"),\n+        TYPE_PATTERN(\"Integer i\"),\n+        PARENTHESIZED_PATTERN(\"(Integer i)\"),\n+        GUARDED_PATTERN(\"Integer i && i > 0\"),\n+        CONSTANT(\"1\"),\n+        NULL(\"null\"),\n+        DEFAULT(\"default\");\n+\n+        private final String code;\n+\n+        private CaseLabel(String code) {\n+            this.code = code;\n+        }\n+\n+        @Override\n+        public String expand(String optParameter) {\n+            throw new UnsupportedOperationException(\"Not supported.\");\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/CaseStructureTest.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -10,1 +10,0 @@\n-SwitchErrors.java:66:13: compiler.err.pattern.dominated\n@@ -15,2 +14,0 @@\n-SwitchErrors.java:101:13: compiler.err.duplicate.case.label\n-SwitchErrors.java:106:13: compiler.err.duplicate.case.label\n@@ -27,1 +24,0 @@\n-SwitchErrors.java:184:13: compiler.err.pattern.dominated\n@@ -31,0 +27,3 @@\n+SwitchErrors.java:215:42: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:224:24: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:240:42: compiler.err.flows.through.from.pattern\n@@ -42,1 +41,1 @@\n-41 errors\n+40 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors-no-preview.out","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8262891\n+ * @bug 8262891 8269146\n@@ -212,0 +212,32 @@\n+    void test8269146a(Integer i) {\n+        switch (i) {\n+            \/\/error - illegal combination of pattern and constant:\n+            case Integer o && o != null, 1:\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+    void test8269146b(Integer i) {\n+        switch (i) {\n+            \/\/error - illegal combination of null and pattern other than type pattern:\n+            case null, Integer o && o != null:\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+    void test8269146c(Integer i) {\n+        switch (i) {\n+            \/\/error - illegal combination of pattern and default:\n+            case Integer o, default:\n+                break;\n+        }\n+    }\n+    void test8269301(Integer i) {\n+        switch (i) {\n+            \/\/error - illegal combination of pattern, constant and default\n+            case Integer o && o != null, 1, default:\n+                break;\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.java","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n-SwitchErrors.java:66:13: compiler.err.pattern.dominated\n+SwitchErrors.java:66:18: compiler.err.pattern.dominated\n@@ -16,2 +16,2 @@\n-SwitchErrors.java:101:13: compiler.err.duplicate.case.label\n-SwitchErrors.java:106:13: compiler.err.duplicate.case.label\n+SwitchErrors.java:101:18: compiler.err.duplicate.case.label\n+SwitchErrors.java:106:24: compiler.err.duplicate.case.label\n@@ -30,1 +30,1 @@\n-SwitchErrors.java:184:13: compiler.err.pattern.dominated\n+SwitchErrors.java:184:18: compiler.err.pattern.dominated\n@@ -34,0 +34,5 @@\n+SwitchErrors.java:215:42: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:224:24: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:233:29: compiler.err.total.pattern.and.default\n+SwitchErrors.java:240:42: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:240:45: compiler.err.flows.through.from.pattern\n@@ -47,1 +52,1 @@\n-44 errors\n+49 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.out","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -65,0 +65,2 @@\n+        runFallThrough(this::testFallThrough2Statement);\n+        runFallThrough(this::testFallThrough2Expression);\n@@ -343,0 +345,27 @@\n+    Integer testFallThrough2Statement(Integer i) {\n+        int r = 0;\n+\n+        switch (i) {\n+            case Integer o && o != null:\n+                r = 1;\n+            case -1: r = 1;\n+            case null, default:\n+                r = 2;\n+        }\n+\n+        return r;\n+    }\n+\n+    Integer testFallThrough2Expression(Integer i) {\n+        int r = switch (i) {\n+            case Integer o && o != null:\n+                r = 1;\n+            case -1: r = 1;\n+            case null, default:\n+                r = 2;\n+                yield r;\n+        };\n+\n+        return r;\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/Switches.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"}]}