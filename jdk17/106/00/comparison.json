{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,0 +63,1 @@\n+import java.time.LocalTime;\n@@ -101,0 +102,31 @@\n+        private String addMessageContext(String message) {\n+            return \"T:\" + Thread.currentThread().getId() +\n+                \" I:\" + iteration +\n+                \" \" + LocalTime.now().toString() +\n+                \": \" + message;\n+        }\n+\n+        private void info(String message) {\n+            log.info(addMessageContext(message));\n+        }\n+\n+        private void progress(String message) {\n+            \/\/ Uncomment this to get (much) more verbose logging.\n+            \/\/ log.debug(addMessageContext(message));\n+        }\n+\n+        private void fail(String message) {\n+            log.error(addMessageContext(\"[FAILED] \" + message));\n+            setFailed(true);\n+        }\n+\n+        private boolean shouldTerminate() {\n+            return !getExecutionController().continueExecution();\n+        }\n+\n+        private void provokeGC(int initialFactor) {\n+            GarbageUtils.eatMemory(getExecutionController(),\n+                                   garbageProducer,\n+                                   initialFactor , 10, 0);\n+        }\n+\n@@ -103,1 +135,2 @@\n-                log.info(\"iteration \" + iteration);\n+                int code = iteration % TYPES_COUNT;\n+                info(\"start code \" + code);\n@@ -106,1 +139,0 @@\n-                int code = iteration % TYPES_COUNT;\n@@ -161,1 +193,2 @@\n-                GarbageUtils.eatMemory(getExecutionController(), garbageProducer, initialFactor , 10, 0);\n+\n+                \/\/ If referent is finalizable, provoke and wait for finalization.\n@@ -163,6 +196,8 @@\n-                        while (!finalized && getExecutionController().continueExecution()) {\n-                                System.runFinalization(); \/\/does not guarantee finalization, but increases the chance\n-                                try {\n-                                        Thread.sleep(100);\n-                                } catch (InterruptedException e) {}\n-                                GarbageUtils.eatMemory(getExecutionController(), garbageProducer, initialFactor , 10, 0);\n+                    \/\/ Don't check shouldTerminate() in the loop.  We want to\n+                    \/\/ treat failure to finalize as a test failure by eventually\n+                    \/\/ timing out.\n+                    progress(\"start waiting for finalization\");\n+                    for (int checks = 0; true; ++checks) {\n+                        if (finalized) {\n+                            progress(\"finished waiting for finalization: \" + checks);\n+                            break;\n@@ -170,0 +205,12 @@\n+                        provokeGC(initialFactor);\n+                        \/\/ Does not guarantee finalization, but increases the chance.\n+                        System.runFinalization();\n+                        try {\n+                            Thread.sleep(100);\n+                        } catch (InterruptedException e) {}\n+                    }\n+                    if (shouldTerminate()) {\n+                        info(\"terminated after finalization\");\n+                        return;\n+                    }\n+                }\n@@ -171,2 +218,16 @@\n-                        \/\/provoke gc once more to make finalized object phantom reachable\n-                        GarbageUtils.eatMemory(getExecutionController(), garbageProducer, initialFactor , 10, 0);\n+                \/\/ Provoke and wait for reference to be cleared.\n+                \/\/ One GC might not be sufficient if the referent is finalizable.\n+                \/\/ The referent might remain reachable from the finalization\n+                \/\/ thread for a little while.  But don't check shouldTerminate()\n+                \/\/ in the loop.  We want to treat failure to be cleared as a test\n+                \/\/ failure by eventually timing out.\n+                progress(\"start waiting for clearing\");\n+                for (int checks = 0; true; ++checks) {\n+                    if (reference.refersTo(null)) {\n+                        progress(\"finished waiting for clearing: \" + checks);\n+                        break;\n+                    }\n+                    provokeGC(initialFactor);\n+                    try {\n+                        Thread.sleep(100);\n+                    } catch (InterruptedException e) {}\n@@ -174,2 +235,2 @@\n-                if (!getExecutionController().continueExecution()) {\n-                    \/\/ we were interrrupted by stresser. just exit...\n+                if (shouldTerminate()) {\n+                    info(\"terminated after clearing\");\n@@ -178,0 +239,3 @@\n+\n+                \/\/ Wait for notification.\n+                progress(\"start waiting for enqueue\");\n@@ -182,2 +246,2 @@\n-                    log.error(\"Unexpected InterruptedException during queue.remove().\");\n-                    setFailed(true);\n+                    fail(\"Unexpected InterruptedException during queue.remove().\");\n+                    return;\n@@ -185,0 +249,1 @@\n+                progress(\"finished waiting for enqueue\");\n@@ -190,2 +255,2 @@\n-                    log.error(\"The original reference is not equal to polled reference.\");\n-                    setFailed(true);\n+                    fail(\"The original reference is not equal to polled reference.\");\n+                    return;\n@@ -198,2 +263,2 @@\n-                    log.error(\"There are more  than one references in the queue.\");\n-                    setFailed(true);\n+                    fail(\"There are more  than one references in the queue.\");\n+                    return;\n@@ -201,1 +266,1 @@\n-                reference.clear();\n+                progress(\"finished code \" + code);\n@@ -203,0 +268,2 @@\n+            } finally {\n+                iteration++;\n@@ -204,1 +271,0 @@\n-            iteration++;\n@@ -209,4 +275,4 @@\n-                \/\/We need discard this flag to make second and following checks with type.equals(\"class\") useful\n-                public Referent() {\n-                                finalized = false;\n-                        }\n+            \/\/We need discard this flag to make second and following checks with type.equals(\"class\") useful\n+            public Referent() {\n+                finalized = false;\n+            }\n@@ -214,1 +280,1 @@\n-                        protected void finalize() {\n+            protected void finalize() {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/PhantomReference\/phantom001\/phantom001.java","additions":93,"deletions":27,"binary":false,"changes":120,"status":"modified"}]}