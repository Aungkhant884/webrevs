{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,3 +53,1 @@\n-bool OSXSemaphore::signal(uint count, bool ignore_overflow) {\n-  \/\/ Semaphore of Darwin-XNU just wraps around its value and returns KERN_SUCCESS.\n-  \/\/ https:\/\/github.com\/apple\/darwin-xnu\/blob\/main\/osfmk\/kern\/sync_sema.c#L400\n+void OSXSemaphore::signal(uint count) {\n@@ -61,1 +59,0 @@\n-  return true;\n","filename":"src\/hotspot\/os\/bsd\/semaphore_bsd.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-  bool signal(uint count = 1, bool ignore_overflow = false);\n+  void signal(uint count = 1);\n","filename":"src\/hotspot\/os\/bsd\/semaphore_bsd.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,3 +53,1 @@\n-bool PosixSemaphore::signal(uint count, bool ignore_overflow) {\n-  bool succeed = true;\n-\n+void PosixSemaphore::signal(uint count) {\n@@ -59,7 +57,1 @@\n-    if (ignore_overflow && ret != 0) {\n-      assert_with_errno(errno == EOVERFLOW || errno == ERANGE,\n-                        \"semaphore overflow detected\");\n-      ret = false;\n-    } else {\n-      assert_with_errno(ret == 0, \"sem_post failed\");\n-    }\n+    assert_with_errno(ret == 0, \"sem_post failed\");\n@@ -67,1 +59,0 @@\n-  return succeed;\n","filename":"src\/hotspot\/os\/posix\/semaphore_posix.cpp","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-  bool signal(uint count = 1, bool ignore_overflow = false);\n+  void signal(uint count = 1);\n","filename":"src\/hotspot\/os\/posix\/semaphore_posix.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,3 +42,1 @@\n-bool WindowsSemaphore::signal(uint count, bool ignore_overflow) {\n-  bool succeed = true;\n-\n+void WindowsSemaphore::signal(uint count) {\n@@ -47,1 +45,0 @@\n-    DWORD err = GetLastError();\n@@ -49,6 +46,1 @@\n-    if (ignore_overflow && ret == 0) {\n-      assert(err == ERROR_TOO_MANY_POSTS, \"ReleaseSemaphore failed due to overflow\");\n-      succeed = false;\n-    } else {\n-      assert(ret != 0, \"ReleaseSemaphore failed with error code: %lu\", err);\n-    }\n+    assert(ret != 0, \"ReleaseSemaphore failed with error code: %lu\", GetLastError());\n@@ -56,1 +48,0 @@\n-  return succeed;\n","filename":"src\/hotspot\/os\/windows\/semaphore_windows.cpp","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-  bool signal(uint count = 1, bool ignore_overflow = false);\n+  void signal(uint count = 1);\n","filename":"src\/hotspot\/os\/windows\/semaphore_windows.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/os.inline.hpp\"\n@@ -54,1 +55,2 @@\n-  _sem.signal(1, true);\n+  _data_available = true;\n+  _cv.notify();\n@@ -78,1 +80,1 @@\n-  : _lock(1), _sem(0), _flush_sem(0),\n+  : _lock(1), _flush_sem(0), _cv(), _data_available(false),\n@@ -128,0 +130,1 @@\n+    _data_available = false;\n@@ -155,3 +158,10 @@\n-    \/\/ The value of a semphore cannot be negative. Therefore, the current thread falls asleep\n-    \/\/ when its value is zero. It will be waken up when new messages are enqueued.\n-    _sem.wait();\n+    {\n+      AsyncLogLocker locker;\n+\n+      while (!_data_available) {\n+        _lock.signal();\n+        _cv.wait(0\/* no timeout *\/);\n+        _lock.wait();\n+      }\n+    }\n+\n@@ -201,1 +211,2 @@\n-      _instance->_sem.signal(1, true);\n+      _instance->_data_available = true;\n+      _instance->_cv.notify();\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -140,4 +140,0 @@\n-  \/\/ _sem is a semaphore whose value denotes how many messages have been enqueued.\n-  \/\/ It decreases in AsyncLogWriter::run().\n-  \/\/ It will ignore the error of overflow\n-  Semaphore _sem;\n@@ -145,1 +141,2 @@\n-\n+  os::PlatformMonitor _cv;\n+  bool _data_available;\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,3 +53,1 @@\n-  bool signal(uint count = 1, bool ignore_overflow = false) {\n-    return _impl.signal(count, ignore_overflow);\n-  }\n+  void signal(uint count = 1) { _impl.signal(count); }\n","filename":"src\/hotspot\/share\/runtime\/semaphore.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"}]}