{"files":[{"patch":"@@ -615,1 +615,2 @@\n-  JavaThreadState jts = _handshakee->thread_state();\n+  assert(_handshakee->thread_state() == _thread_blocked, \"Caller should have transitioned to _thread_blocked\");\n+\n@@ -617,1 +618,0 @@\n-    _handshakee->set_thread_state(_thread_blocked);\n@@ -621,2 +621,0 @@\n-  _handshakee->set_thread_state(jts);\n-  set_async_suspend_handshake(false);\n@@ -634,0 +632,3 @@\n+    JavaThreadState jts = current->thread_state();\n+\n+    current->set_thread_state(_thread_blocked);\n@@ -635,0 +636,2 @@\n+    current->set_thread_state(jts);\n+    current->handshake_state()->set_async_suspend_handshake(false);\n@@ -684,2 +687,0 @@\n-  SuspendThreadHandshake st;\n-  Handshake::execute(&st, _handshakee);\n@@ -687,4 +688,11 @@\n-    \/\/ If target is the current thread we need to call this to do the\n-    \/\/ actual suspend since Handshake::execute() above only installed\n-    \/\/ the asynchronous handshake.\n-    SafepointMechanism::process_if_requested(self);\n+    \/\/ If target is the current thread we can bypass the handshake machinery\n+    \/\/ and just suspend directly\n+    ThreadBlockInVM tbivm(self);\n+    MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n+    set_suspended(true);\n+    do_self_suspend();\n+    return true;\n+  } else {\n+    SuspendThreadHandshake st;\n+    Handshake::execute(&st, _handshakee);\n+    return st.did_suspend();\n@@ -692,1 +700,0 @@\n-  return st.did_suspend();\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":18,"deletions":11,"binary":false,"changes":29,"status":"modified"}]}