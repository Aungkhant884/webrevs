{"files":[{"patch":"@@ -615,1 +615,2 @@\n-  JavaThreadState jts = _handshakee->thread_state();\n+\n+  log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" suspended\", p2i(_handshakee));\n@@ -617,2 +618,0 @@\n-    _handshakee->set_thread_state(_thread_blocked);\n-    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" suspended\", p2i(_handshakee));\n@@ -621,2 +620,0 @@\n-  _handshakee->set_thread_state(jts);\n-  set_async_suspend_handshake(false);\n@@ -634,0 +631,3 @@\n+    JavaThreadState jts = current->thread_state();\n+\n+    current->set_thread_state(_thread_blocked);\n@@ -635,0 +635,2 @@\n+    current->set_thread_state(jts);\n+    current->handshake_state()->set_async_suspend_handshake(false);\n@@ -684,2 +686,0 @@\n-  SuspendThreadHandshake st;\n-  Handshake::execute(&st, _handshakee);\n@@ -687,4 +687,11 @@\n-    \/\/ If target is the current thread we need to call this to do the\n-    \/\/ actual suspend since Handshake::execute() above only installed\n-    \/\/ the asynchronous handshake.\n-    SafepointMechanism::process_if_requested(self);\n+    \/\/ If target is the current thread we can bypass the handshake machinery\n+    \/\/ and just suspend directly\n+    ThreadBlockInVM tbivm(self);\n+    MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n+    set_suspended(true);\n+    do_self_suspend();\n+    return true;\n+  } else {\n+    SuspendThreadHandshake st;\n+    Handshake::execute(&st, _handshakee);\n+    return st.did_suspend();\n@@ -692,1 +699,0 @@\n-  return st.did_suspend();\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":18,"deletions":12,"binary":false,"changes":30,"status":"modified"}]}