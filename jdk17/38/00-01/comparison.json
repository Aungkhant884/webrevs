{"files":[{"patch":"@@ -49,0 +49,1 @@\n+    \/\/ Don't inline\n@@ -50,1 +51,0 @@\n-        \/\/ Don't inline\n@@ -70,0 +70,1 @@\n+    \/\/ Don't inline\n@@ -91,0 +92,3 @@\n+                    \/\/ This is outer Lock region for object 's'.\n+                    \/\/ Locks from following inlined methods are \"nested\"\n+                    \/\/ because they reference the same object.\n@@ -93,0 +97,8 @@\n+\n+                        \/\/ The next is bi-morphic call with both calls inlined.\n+                        \/\/ But one is synchronized and the other is not.\n+                        \/\/ Class check for bi-morphic call is loop invariant\n+                        \/\/ and will trigger loop unswitching.\n+                        \/\/ Loop unswitching will create two versions of loop\n+                        \/\/ with gollowing calls inlinined in both versions.\n+\n@@ -94,0 +106,10 @@\n+\n+                        \/\/ The next synchronized method availableSegment() is\n+                        \/\/ inlined and its Lock will be \"coarsened\" with Unlock\n+                        \/\/ in version of loop with inlined synchronized method\n+                        \/\/ isComplete().\n+                        \/\/ Nested Lock Optimization will mark only this Unlock\n+                        \/\/ as nested (as part of \"nested\" pair lock\/unlock).\n+                        \/\/ Locks elimination will remove \"coarsened\" Lock from\n+                        \/\/ availableSegment() method leaving unmatched unlock.\n+\n@@ -113,1 +135,0 @@\n-        \/\/ warmup\n","filename":"test\/hotspot\/jtreg\/compiler\/locks\/TestNestedLocksElimination.java","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"}]}