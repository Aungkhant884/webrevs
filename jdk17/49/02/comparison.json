{"files":[{"patch":"@@ -1761,1 +1761,1 @@\n-      length->set_req(0, init->proj_out_or_null(0));\n+      length->set_req(TypeFunc::Control, init->proj_out_or_null(TypeFunc::Control));\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1187,5 +1187,1 @@\n-    alen = alloc->Ideal_length();\n-    Node* ccast = alloc->make_ideal_length(_gvn.type(array)->is_oopptr(), &_gvn);\n-    if (ccast != alen) {\n-      alen = _gvn.transform(ccast);\n-    }\n+    alen = array_ideal_length(alloc, _gvn.type(array)->is_oopptr(), false);\n@@ -1196,0 +1192,20 @@\n+Node* GraphKit::array_ideal_length(AllocateArrayNode* alloc,\n+                                   const TypeOopPtr* oop_type,\n+                                   bool replace_length_in_map) {\n+  Node* length = alloc->Ideal_length();\n+  if (replace_length_in_map == false || map()->find_edge(length) >= 0) {\n+    Node* ccast = alloc->make_ideal_length(oop_type, &_gvn);\n+    if (ccast != length) {\n+      \/\/ do not transfrom ccast here, it might convert to top node for\n+      \/\/ negative array length and break assumptions in parsing stage.\n+      _gvn.set_type_bottom(ccast);\n+      record_for_igvn(ccast);\n+      if (replace_length_in_map) {\n+        replace_in_map(length, ccast);\n+      }\n+      return ccast;\n+    }\n+  }\n+  return length;\n+}\n+\n@@ -3970,10 +3986,1 @@\n-  \/\/ Cast length on remaining path to be as narrow as possible\n-  if (map()->find_edge(length) >= 0) {\n-    Node* ccast = alloc->make_ideal_length(ary_type, &_gvn);\n-    if (ccast != length) {\n-      _gvn.set_type_bottom(ccast);\n-      record_for_igvn(ccast);\n-      replace_in_map(length, ccast);\n-    }\n-  }\n-\n+  array_ideal_length(alloc, ary_type, true);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":22,"deletions":15,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -346,0 +346,6 @@\n+  \/\/ Cast array allocation's length as narrow as possible.\n+  \/\/ If replace_length_in_map is true, replace length with CastIINode in map.\n+  \/\/ This method is invoked after creating\/moving ArrayAllocationNode or in load_array_length\n+  Node* array_ideal_length(AllocateArrayNode* alloc,\n+                           const TypeOopPtr* oop_type,\n+                           bool replace_length_in_map);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4446,0 +4446,30 @@\n+\n+    \/\/ The CastIINode created in GraphKit::new_array (in AllocateArrayNode::make_ideal_length) must stay below\n+    \/\/ the allocation (i.e. is only valid if the allocation succeeds):\n+    \/\/ 1) replace CastIINode with AllocateArrayNode's length here\n+    \/\/ 2) Create CastIINode again once allocation has moved (see below) at the end of this method\n+    \/\/\n+    \/\/ Multiple identical CastIINodes might exist here. Each GraphKit::load_array_length() call will generate\n+    \/\/ new separate CastIINode (arraycopy guard checks or any array length use between array allocation and ararycopy)\n+    Node* init_control = init->proj_out(TypeFunc::Control);\n+    Node* alloc_length = alloc->Ideal_length();\n+#ifdef ASSERT\n+    Node* prev_cast = NULL;\n+#endif\n+    for (uint i = 0; i < init_control->outcnt(); i++) {\n+      Node* init_out = init_control->raw_out(i);\n+      if (init_out->is_CastII() && init_out->in(TypeFunc::Control) == init_control && init_out->in(1) == alloc_length) {\n+#ifdef ASSERT\n+        if (prev_cast == NULL) {\n+          prev_cast = init_out;\n+        } else {\n+          if (prev_cast->cmp(*init_out) == false) {\n+            prev_cast->dump();\n+            init_out->dump();\n+            assert(false, \"not equal CastIINode\");\n+          }\n+        }\n+#endif\n+        C->gvn_replace_by(init_out, alloc_length);\n+      }\n+    }\n@@ -4477,0 +4507,2 @@\n+\n+    array_ideal_length(alloc, ary_type, true);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8268362\n+ * @requires vm.compiler2.enabled & vm.debug\n+ * @summary C2 using negative array length as index, using a.length.\n+ *          AllocateArrayNode::make_ideal_length create CastIINode to not negative range.\n+ *          Apply transform in GraphKit::load_array_length will covert array load index type to top.\n+ *          This cause assert in Parse::array_addressing, it expect index type is int.\n+ * @run main\/othervm -XX:-PrintCompilation compiler.arraycopy.TestNegArrayLengthAsIndex1\n+ *\/\n+\n+package compiler.arraycopy;\n+public class TestNegArrayLengthAsIndex1 {\n+\n+    public static void main(String[] args) throws Exception {\n+        for (int i = 0; i < 10000; i++) {\n+            foo();\n+        }\n+    }\n+\n+    static int foo() {\n+        int minusOne = -1;\n+        int[] a = null;\n+        try {\n+            a = new int[minusOne];\n+        } catch (NegativeArraySizeException e) {\n+           return 0;\n+        }\n+        return a[a.length - 1];\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestNegArrayLengthAsIndex1.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8268362\n+ * @requires vm.compiler2.enabled & vm.debug\n+ * @summary C2 using negative array length as index, using array allocation length.\n+ *          This assertion is triggered by 8267904.\n+ * @run main\/othervm compiler.arraycopy.TestNegArrayLengthAsIndex2\n+ *\/\n+\n+package compiler.arraycopy;\n+public class TestNegArrayLengthAsIndex2 {\n+\n+    public static void main(String[] args) throws Exception {\n+        for (int i = 0; i < 10000; i++) {\n+            foo();\n+        }\n+    }\n+\n+    static int foo() {\n+        int minusOne = -1;\n+        int[] a = null;\n+        try {\n+            a = new int[minusOne];\n+        } catch (NegativeArraySizeException e) {\n+           return 0;\n+        }\n+        return a[minusOne - 1];\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestNegArrayLengthAsIndex2.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8267904\n+ * @requires vm.compiler2.enabled\n+ * @summary C2 inline array_copy move CastIINode(Array Length) before allocation cause crash.\n+ * @run main\/othervm compiler.arraycopy.TestNegativeArrayCopyAfterLoop\n+ *\/\n+\n+package compiler.arraycopy;\n+import java.util.Arrays;\n+\n+class test {\n+    public static int exp_count = 0;\n+    public int in1 = -4096;\n+    test (){\n+        try {\n+            short sha4[] = new short[1012];\n+            for (int i = 0; i < sha4.length; i++) {\n+              sha4[i] = 9;\n+            }\n+            Arrays.copyOf(sha4, in1);\n+        } catch (Exception ex) {\n+            exp_count++;\n+        }\n+    }\n+}\n+\n+public class TestNegativeArrayCopyAfterLoop {\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20000; i++) {\n+            new test();\n+        }\n+        if (test.exp_count == 20000) {\n+            System.out.println(\"TEST PASSED\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestNegativeArrayCopyAfterLoop.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"}]}