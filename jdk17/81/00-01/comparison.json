{"files":[{"patch":"@@ -55,1 +55,2 @@\n-    private static final MethodHandle DO_SWITCH;\n+    private static final MethodHandle DO_TYPE_SWITCH;\n+    private static final MethodHandle DO_ENUM_SWITCH;\n@@ -59,1 +60,1 @@\n-            DO_SWITCH = LOOKUP.findStatic(SwitchBootstraps.class, \"doSwitch\",\n+            DO_TYPE_SWITCH = LOOKUP.findStatic(SwitchBootstraps.class, \"doTypeSwitch\",\n@@ -61,0 +62,2 @@\n+            DO_ENUM_SWITCH = LOOKUP.findStatic(SwitchBootstraps.class, \"doEnumSwitch\",\n+                                           MethodType.methodType(int.class, Enum.class, int.class, Object[].class));\n@@ -71,1 +74,1 @@\n-     * {@code String} or {@code Integer}, an enum constant or {@code Class}.\n+     * {@code String} or {@code Integer} or {@code Class}.\n@@ -87,1 +90,1 @@\n-     *   <li>the element is of type {@code String} or {@code Integer} or an enum constant and\n+     *   <li>the element is of type {@code String} or {@code Integer} and\n@@ -105,1 +108,1 @@\n-     * @throws IllegalArgumentException if the\n+     * @throws IllegalArgumentException if any element in the labels array is null, if the\n@@ -109,1 +112,1 @@\n-     * {@code Integer} or and enum constant or {@code Class}.\n+     * {@code Integer} or {@code Class}.\n@@ -128,1 +131,1 @@\n-        MethodHandle target = MethodHandles.insertArguments(DO_SWITCH, 2, (Object) labels);\n+        MethodHandle target = MethodHandles.insertArguments(DO_TYPE_SWITCH, 2, (Object) labels);\n@@ -134,1 +137,1 @@\n-            return ;\n+            throw new IllegalArgumentException(\"null label found\");\n@@ -136,1 +139,0 @@\n-\n@@ -140,2 +142,1 @@\n-            labelClass != Integer.class &&\n-            !labelClass.isEnum()) {\n+            labelClass != Integer.class) {\n@@ -146,1 +147,1 @@\n-    private static int doSwitch(Object target, int startIndex, Object[] labels) {\n+    private static int doTypeSwitch(Object target, int startIndex, Object[] labels) {\n@@ -154,3 +155,1 @@\n-            if (label == null) {\n-                \/\/ignore\n-            } else if (label instanceof Class<?> c) {\n+            if (label instanceof Class<?> c) {\n@@ -165,4 +164,0 @@\n-            } else if (label instanceof Enum<?>) {\n-                if (label == target) {\n-                    return i;\n-                }\n@@ -178,2 +173,25 @@\n-     * Returns an {@code enum} constant of the type specified by {@code type}\n-     * with the name specified by {@code name}.\n+     * Bootstrap method for linking an {@code invokedynamic} call site that\n+     * implements a {@code switch} on a target of an enum type.  The static\n+     * arguments are an array of case labels which must be non-null and of type\n+     * {@code String} (representing enum constants) or {@code Class}.\n+     * <p>\n+     * The type of the returned {@code CallSite}'s method handle will have\n+     * a return type of {@code int}.   It has two parameters: the first argument\n+     * will be an {@code Enum} instance ({@code target}) and the second\n+     * will be {@code int} ({@code restart}).\n+     * <p>\n+     * If the {@code target} is {@code null}, then the method of the call site\n+     * returns {@literal -1}.\n+     * <p>\n+     * If the {@code target} is not {@code null}, then the method of the call site\n+     * returns the index of the first element in the {@code labels} array starting from\n+     * the {@code restart} index matching one of the following conditions:\n+     * <ul>\n+     *   <li>the element is of type {@code Class} that is assignable\n+     *       from the target's class; or<\/li>\n+     *   <li>the element is of type {@code String} and equals to the target\n+     *       enum constant's {@link Enum#name()}.<\/li>\n+     * <\/ul>\n+     * <p>\n+     * If no element in the {@code labels} array matches the target, then\n+     * the method of the call site return the length of the {@code labels} array.\n@@ -185,11 +203,15 @@\n-     * @param invocationClass unused\n-     * @param name the name of the constant to return, which must exactly match\n-     * an enum constant in the specified type.\n-     * @param type the {@code Class} object describing the enum type for which\n-     * a constant is to be returned\n-     * @param <E> The enum type for which a constant value is to be returned\n-     * @return the enum constant of the specified enum type with the\n-     * specified name, or null if not found\n-     * @throws IllegalAccessError if the declaring class or the field is not\n-     * accessible to the class performing the operation\n-     * @see Enum#valueOf(Class, String)\n+     * @param invocationType The invocation type of the {@code CallSite} with two parameters,\n+     *                       an enum type, an {@code int}, and {@code int} as a return type.\n+     * @param labels case labels - {@code String} constants and {@code Class} instances,\n+     *               in any combination\n+     * @return a {@code CallSite} returning the first matching element as described above\n+     *\n+     * @throws NullPointerException if any argument is {@code null}\n+     * @throws IllegalArgumentException if any element in the labels array is null, if the\n+     * invocation type is not a method type of first parameter of an enum type,\n+     * second parameter of type {@code int} and with {@code int} as its return type,\n+     * or if {@code labels} contains an element that is not of type {@code String} or\n+     * {@code Class}.\n+     * @throws Throwable if there is any error linking the call site\n+     * @jvms 4.4.6 The CONSTANT_NameAndType_info Structure\n+     * @jvms 4.4.10 The CONSTANT_Dynamic_info and CONSTANT_InvokeDynamic_info Structures\n@@ -197,9 +219,41 @@\n-    public static <E extends Enum<E>> E enumConstant(MethodHandles.Lookup lookup,\n-                                                     String invocationName,\n-                                                     Class<?> invocationClass,\n-                                                     String name,\n-                                                     Class<E> type) {\n-        try {\n-            return ConstantBootstraps.enumConstant(lookup, name, type);\n-        } catch (IllegalArgumentException ex) {\n-            return null;\n+    public static CallSite enumSwitch(MethodHandles.Lookup lookup,\n+                                      String invocationName,\n+                                      MethodType invocationType,\n+                                      Object... labels) throws Throwable {\n+        if (invocationType.parameterCount() != 2\n+            || (!invocationType.returnType().equals(int.class))\n+            || invocationType.parameterType(0).isPrimitive()\n+            || !invocationType.parameterType(0).isEnum()\n+            || !invocationType.parameterType(1).equals(int.class))\n+            throw new IllegalArgumentException(\"Illegal invocation type \" + invocationType);\n+        requireNonNull(labels);\n+\n+        labels = labels.clone();\n+\n+        Class<?> enumClass = invocationType.parameterType(0);\n+        labels = Stream.of(labels).map(l -> convertEnumConstants(lookup, enumClass, l)).toArray();\n+\n+        MethodHandle target =\n+                MethodHandles.insertArguments(DO_ENUM_SWITCH, 2, (Object) labels);\n+        target = MethodHandles.explicitCastArguments(target, invocationType);\n+\n+        return new ConstantCallSite(target);\n+    }\n+\n+    private static <E extends Enum<E>> Object convertEnumConstants(MethodHandles.Lookup lookup, Class<?> enumClassTemplate, Object label) {\n+        if (label == null) {\n+            throw new IllegalArgumentException(\"null label found\");\n+        }\n+        Class<?> labelClass = label.getClass();\n+        if (labelClass == Class.class) {\n+            return label;\n+        } else if (labelClass == String.class) {\n+            @SuppressWarnings(\"unchecked\")\n+            Class<E> enumClass = (Class<E>) enumClassTemplate;\n+            try {\n+                return ConstantBootstraps.enumConstant(lookup, (String) label, enumClass);\n+            } catch (IllegalArgumentException ex) {\n+                return null;\n+            }\n+        } else {\n+            throw new IllegalArgumentException(\"label with illegal type found: \" + labelClass);\n@@ -208,0 +262,20 @@\n+\n+    private static int doEnumSwitch(Enum<?> target, int startIndex, Object[] labels) {\n+        if (target == null)\n+            return -1;\n+\n+        \/\/ Dumbest possible strategy\n+        Class<?> targetClass = target.getClass();\n+        for (int i = startIndex; i < labels.length; i++) {\n+            Object label = labels[i];\n+            if (label instanceof Class<?> c) {\n+                if (c.isAssignableFrom(targetClass))\n+                    return i;\n+            } else if (label == target) {\n+                return i;\n+            }\n+        }\n+\n+        return labels.length;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":115,"deletions":41,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -365,0 +365,2 @@\n+            boolean enumSelector = seltype.tsym.isEnum();\n+            Name bootstrapName = enumSelector ? names.enumSwitch : names.typeSwitch;\n@@ -366,1 +368,1 @@\n-                    names.fromString(\"typeSwitch\"), staticArgTypes, List.nil());\n+                    bootstrapName, staticArgTypes, List.nil());\n@@ -369,1 +371,1 @@\n-                    List.of(syms.objectType, syms.intType),\n+                    List.of(enumSelector ? seltype : syms.objectType, syms.intType),\n@@ -374,1 +376,1 @@\n-            DynamicMethodSymbol dynSym = new DynamicMethodSymbol(names.fromString(\"typeSwitch\"),\n+            DynamicMethodSymbol dynSym = new DynamicMethodSymbol(bootstrapName,\n@@ -486,24 +488,1 @@\n-                Assert.check(l.hasTag(Tag.IDENT));\n-\n-                List<Type> staticArgTypes = List.of(syms.methodHandleLookupType,\n-                                                    syms.stringType,\n-                                                    syms.classType,\n-                                                    syms.stringType,\n-                                                    new ClassType(syms.classType.getEnclosingType(),\n-                                                                  List.of(l.type),\n-                                                                  syms.classType.tsym));\n-                LoadableConstant[] staticArgValues = new LoadableConstant[] {\n-                    LoadableConstant.String(((JCIdent) l).name.toString()),\n-                    (ClassType) l.type\n-                };\n-\n-                Symbol bsm = rs.resolveInternalMethod(l.pos(), env, syms.switchBootstrapsType,\n-                        names.fromString(\"enumConstant\"), staticArgTypes, List.nil());\n-\n-                DynamicVarSymbol dynSym = new DynamicVarSymbol(names.fromString(\"enumConstant\"),\n-                        syms.noSymbol,\n-                        ((MethodSymbol)bsm).asHandle(),\n-                        l.type,\n-                        staticArgValues);\n-\n-                return dynSym;\n+                return LoadableConstant.String(((JCIdent) l).name.toString());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":6,"deletions":27,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.util.HashSet;\n@@ -933,13 +932,1 @@\n-        \/\/ensure all bootstrap methods are entered into the map:\n-        int size;\n-        do {\n-            size = poolWriter.bootstrapMethods.size();\n-            for (BsmKey bsmKey : new HashSet<>(poolWriter.bootstrapMethods.keySet())) {\n-                \/\/ensure all static args are in pool:\n-                LoadableConstant[] uniqueArgs = bsmKey.staticArgs;\n-                for (LoadableConstant arg : uniqueArgs) {\n-                    poolWriter.putConstant(arg);\n-                }\n-            }\n-        } while (size != poolWriter.bootstrapMethods.size());\n-        databuf.appendChar(size);\n+        databuf.appendChar(poolWriter.bootstrapMethods.size());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -218,0 +218,4 @@\n+    \/\/ pattern switches\n+    public final Name typeSwitch;\n+    public final Name enumSwitch;\n+\n@@ -387,0 +391,4 @@\n+\n+        \/\/ pattern switches\n+        typeSwitch = fromString(\"typeSwitch\");\n+        enumSwitch = fromString(\"enumSwitch\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+    public static final MethodHandle BSM_ENUM_SWITCH;\n@@ -52,0 +53,2 @@\n+            BSM_ENUM_SWITCH = MethodHandles.lookup().findStatic(SwitchBootstraps.class, \"enumSwitch\",\n+                                                                MethodType.methodType(CallSite.class, MethodHandles.Lookup.class, String.class, MethodType.class, Object[].class));\n@@ -65,0 +68,7 @@\n+    private void testEnum(Enum<?> target, int start, int result, Object... labels) throws Throwable {\n+        MethodType switchType = MethodType.methodType(int.class, target.getClass(), int.class);\n+        MethodHandle indy = ((CallSite) BSM_ENUM_SWITCH.invoke(MethodHandles.lookup(), \"\", switchType, labels)).dynamicInvoker();\n+        assertEquals((int) indy.invoke(target, start), result);\n+        assertEquals(-1, (int) indy.invoke(null, start));\n+    }\n+\n@@ -100,1 +110,6 @@\n-        testType(E1.A, 0, 2, E1.B, null, E1.A, Object.class);\n+    }\n+\n+    public void testEnums() throws Throwable {\n+        testEnum(E1.A, 0, 2, \"B\", \"C\", \"A\", E1.class);\n+        testEnum(E1.B, 0, 0, \"B\", \"C\", \"A\", E1.class);\n+        testEnum(E1.B, 1, 3, \"B\", \"C\", \"A\", E1.class);\n@@ -117,0 +132,14 @@\n+        MethodType[] enumSwitchTypes = new MethodType[] {\n+            MethodType.methodType(int.class, Enum.class),\n+            MethodType.methodType(int.class, Object.class, int.class),\n+            MethodType.methodType(int.class, double.class, int.class),\n+            MethodType.methodType(int.class, Enum.class, Integer.class)\n+        };\n+        for (MethodType enumSwitchType : enumSwitchTypes) {\n+            try {\n+                BSM_ENUM_SWITCH.invoke(MethodHandles.lookup(), \"\", enumSwitchType);\n+                fail(\"Didn't get the expected exception.\");\n+            } catch (IllegalArgumentException ex) {\n+                \/\/OK, expected\n+            }\n+        }\n@@ -127,0 +156,21 @@\n+        try {\n+            BSM_TYPE_SWITCH.invoke(MethodHandles.lookup(), \"\", switchType,\n+                                   new Object[] {1, null, String.class});\n+            fail(\"Didn't get the expected exception.\");\n+        } catch (IllegalArgumentException ex) {\n+            \/\/OK\n+        }\n+        MethodType enumSwitchType = MethodType.methodType(int.class, E1.class, int.class);\n+        try {\n+            BSM_TYPE_SWITCH.invoke(MethodHandles.lookup(), \"\", enumSwitchType, (Object[]) null);\n+            fail(\"Didn't get the expected exception.\");\n+        } catch (NullPointerException ex) {\n+            \/\/OK\n+        }\n+        try {\n+            BSM_TYPE_SWITCH.invoke(MethodHandles.lookup(), \"\", enumSwitchType,\n+                                   new Object[] {1, null, String.class});\n+            fail(\"Didn't get the expected exception.\");\n+        } catch (IllegalArgumentException ex) {\n+            \/\/OK\n+        }\n","filename":"test\/jdk\/java\/lang\/runtime\/SwitchBootstrapsTest.java","additions":51,"deletions":1,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+            case EnumTypeChangesEnum e1 && false -> throw new AssertionError();\n@@ -63,0 +64,1 @@\n+            case EnumTypeChangesEnum e1 && false -> throw new AssertionError();\n","filename":"test\/langtools\/tools\/javac\/patterns\/EnumTypeChanges.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}