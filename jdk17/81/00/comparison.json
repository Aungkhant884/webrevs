{"files":[{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.invoke.ConstantBootstraps;\n@@ -33,2 +34,0 @@\n-import java.util.Arrays;\n-import java.util.Objects;\n@@ -72,1 +71,1 @@\n-     * {@code String} or {@code Integer} or {@code Class}.\n+     * {@code String} or {@code Integer}, an enum constant or {@code Class}.\n@@ -88,1 +87,1 @@\n-     *   <li>the element is of type {@code String} or {@code Integer} and\n+     *   <li>the element is of type {@code String} or {@code Integer} or an enum constant and\n@@ -106,1 +105,1 @@\n-     * @throws IllegalArgumentException if any element in the labels array is null, if the\n+     * @throws IllegalArgumentException if the\n@@ -110,1 +109,1 @@\n-     * {@code Integer} or {@code Class}.\n+     * {@code Integer} or and enum constant or {@code Class}.\n@@ -135,1 +134,1 @@\n-            throw new IllegalArgumentException(\"null label found\");\n+            return ;\n@@ -137,0 +136,1 @@\n+\n@@ -140,1 +140,2 @@\n-            labelClass != Integer.class) {\n+            labelClass != Integer.class &&\n+            !labelClass.isEnum()) {\n@@ -153,1 +154,3 @@\n-            if (label instanceof Class<?> c) {\n+            if (label == null) {\n+                \/\/ignore\n+            } else if (label instanceof Class<?> c) {\n@@ -162,0 +165,4 @@\n+            } else if (label instanceof Enum<?>) {\n+                if (label == target) {\n+                    return i;\n+                }\n@@ -170,0 +177,31 @@\n+    \/**\n+     * Returns an {@code enum} constant of the type specified by {@code type}\n+     * with the name specified by {@code name}.\n+     *\n+     * @param lookup Represents a lookup context with the accessibility\n+     *               privileges of the caller.  When used with {@code invokedynamic},\n+     *               this is stacked automatically by the VM.\n+     * @param invocationName unused\n+     * @param invocationClass unused\n+     * @param name the name of the constant to return, which must exactly match\n+     * an enum constant in the specified type.\n+     * @param type the {@code Class} object describing the enum type for which\n+     * a constant is to be returned\n+     * @param <E> The enum type for which a constant value is to be returned\n+     * @return the enum constant of the specified enum type with the\n+     * specified name, or null if not found\n+     * @throws IllegalAccessError if the declaring class or the field is not\n+     * accessible to the class performing the operation\n+     * @see Enum#valueOf(Class, String)\n+     *\/\n+    public static <E extends Enum<E>> E enumConstant(MethodHandles.Lookup lookup,\n+                                                     String invocationName,\n+                                                     Class<?> invocationClass,\n+                                                     String name,\n+                                                     Class<E> type) {\n+        try {\n+            return ConstantBootstraps.enumConstant(lookup, name, type);\n+        } catch (IllegalArgumentException ex) {\n+            return null;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":47,"deletions":9,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import com.sun.tools.javac.code.Symbol.DynamicVarSymbol;\n@@ -61,0 +62,1 @@\n+import com.sun.tools.javac.util.Name;\n@@ -96,0 +98,1 @@\n+import java.util.Iterator;\n@@ -272,1 +275,0 @@\n-        boolean enumSwitch = (seltype.tsym.flags() & Flags.ENUM) != 0;\n@@ -312,21 +314,0 @@\n-            \/\/a special case for switches over enums with pattern case\n-            \/\/with only a single unguarded (type) pattern case, which is equivalent\n-            \/\/to a default with additional binding variable assignment:\n-            \/\/switch ($enum) {\n-            \/\/    case $constant1: $stats$\n-            \/\/    case $constant2: $stats$\n-            \/\/    case typeof($enum) e: $stats$\n-            \/\/}\n-            \/\/=>\n-            \/\/switch ($enum) {\n-            \/\/    case $constant1: $stats$\n-            \/\/    case $constant2: $stats$\n-            \/\/    default: typeof($enum) e = $enum; $stats$\n-            \/\/}\n-            \/\/constant labels in switches over enums with one or more pattern cases\n-            \/\/with guards are desugared into guards:\n-            \/\/case $constant1: $stats$\n-            \/\/=>\n-            \/\/case typeof($enum) e && e == $constant1: $stats$\n-            \/\/and handled as a normal pattern matching switch\n-            \/\/\n@@ -342,21 +323,0 @@\n-            if (enumSwitch && hasGuards(newCases)) {\n-                for (JCCase c : newCases) {\n-                    for (List<JCCaseLabel> l = c.labels; l.nonEmpty(); l = l.tail) {\n-                        if (l.head.isExpression() && !TreeInfo.isNull(l.head)) {\n-                            BindingSymbol temp = new BindingSymbol(Flags.SYNTHETIC,\n-                                    names.fromString(\"enumGuard\" + c.pos +\n-                                                     target.syntheticNameChar() + \"temp\"),\n-                                    seltype,\n-                                    currentMethodSym);\n-                            JCBindingPattern binding =\n-                                    make.at(l.head.pos()).BindingPattern(make.VarDef(temp, null));\n-                            binding.setType(seltype);\n-                            l.head = make.GuardPattern(binding,\n-                                                       makeBinary(Tag.EQ,\n-                                                                  make.Ident(temp),\n-                                                                  (JCExpression) l.head));\n-                        }\n-                    }\n-                }\n-                enumSwitch = false;\n-            }\n@@ -391,40 +351,36 @@\n-            if (enumSwitch) {\n-                selector = make.Ident(temp);\n-            } else {\n-                List<Type> staticArgTypes = List.of(syms.methodHandleLookupType,\n-                                                    syms.stringType,\n-                                                    syms.methodTypeType,\n-                                                    types.makeArrayType(new ClassType(syms.classType.getEnclosingType(),\n-                                                                        List.of(new WildcardType(syms.objectType, BoundKind.UNBOUND,\n-                                                                                                 syms.boundClass)),\n-                                                                        syms.classType.tsym)));\n-                LoadableConstant[] staticArgValues =\n-                        cases.stream()\n-                             .flatMap(c -> c.labels.stream())\n-                             .map(l -> toLoadableConstant(l))\n-                             .filter(c -> c != null)\n-                             .toArray(s -> new LoadableConstant[s]);\n-\n-                Symbol bsm = rs.resolveInternalMethod(tree.pos(), env, syms.switchBootstrapsType,\n-                        names.fromString(\"typeSwitch\"), staticArgTypes, List.nil());\n-\n-                MethodType indyType = new MethodType(\n-                        List.of(syms.objectType, syms.intType),\n-                        syms.intType,\n-                        List.nil(),\n-                        syms.methodClass\n-                );\n-                DynamicMethodSymbol dynSym = new DynamicMethodSymbol(names.fromString(\"typeSwitch\"),\n-                        syms.noSymbol,\n-                        ((MethodSymbol)bsm).asHandle(),\n-                        indyType,\n-                        staticArgValues);\n-\n-                JCFieldAccess qualifier = make.Select(make.QualIdent(bsm.owner), dynSym.name);\n-                qualifier.sym = dynSym;\n-                qualifier.type = syms.intType;\n-                selector = make.Apply(List.nil(),\n-                                      qualifier,\n-                                      List.of(make.Ident(temp), make.Ident(index)))\n-                               .setType(syms.intType);\n-            }\n+            List<Type> staticArgTypes = List.of(syms.methodHandleLookupType,\n+                                                syms.stringType,\n+                                                syms.methodTypeType,\n+                                                types.makeArrayType(new ClassType(syms.classType.getEnclosingType(),\n+                                                                    List.of(new WildcardType(syms.objectType, BoundKind.UNBOUND,\n+                                                                                             syms.boundClass)),\n+                                                                    syms.classType.tsym)));\n+            LoadableConstant[] staticArgValues =\n+                    cases.stream()\n+                         .flatMap(c -> c.labels.stream())\n+                         .map(l -> toLoadableConstant(l))\n+                         .filter(c -> c != null)\n+                         .toArray(s -> new LoadableConstant[s]);\n+\n+            Symbol bsm = rs.resolveInternalMethod(tree.pos(), env, syms.switchBootstrapsType,\n+                    names.fromString(\"typeSwitch\"), staticArgTypes, List.nil());\n+\n+            MethodType indyType = new MethodType(\n+                    List.of(syms.objectType, syms.intType),\n+                    syms.intType,\n+                    List.nil(),\n+                    syms.methodClass\n+            );\n+            DynamicMethodSymbol dynSym = new DynamicMethodSymbol(names.fromString(\"typeSwitch\"),\n+                    syms.noSymbol,\n+                    ((MethodSymbol)bsm).asHandle(),\n+                    indyType,\n+                    staticArgValues);\n+\n+            JCFieldAccess qualifier = make.Select(make.QualIdent(bsm.owner), dynSym.name);\n+            qualifier.sym = dynSym;\n+            qualifier.type = syms.intType;\n+            selector = make.Apply(List.nil(),\n+                                  qualifier,\n+                                  List.of(make.Ident(temp), make.Ident(index)))\n+                           .setType(syms.intType);\n@@ -467,20 +423,14 @@\n-                if (enumSwitch) {\n-                    var labels = c.labels;\n-\n-                    while (labels.nonEmpty()) {\n-                        if (labels.head.isPattern()) {\n-                            labels.head = make.DefaultCaseLabel();\n-                        }\n-                        labels = labels.tail;\n-                    }\n-                } else {\n-                    ListBuffer<JCCaseLabel> translatedLabels = new ListBuffer<>();\n-                    for (var p : c.labels) {\n-                        if (p.hasTag(Tag.DEFAULTCASELABEL)) {\n-                            translatedLabels.add(p);\n-                            hasDefault = true;\n-                        } else if (hasTotalPattern && !hasDefault &&\n-                                   c == lastCase && p.isPattern()) {\n-                            \/\/If the switch has total pattern, the last case will contain it.\n-                            \/\/Convert the total pattern to default:\n-                            translatedLabels.add(make.DefaultCaseLabel());\n+                ListBuffer<JCCaseLabel> translatedLabels = new ListBuffer<>();\n+                for (var p : c.labels) {\n+                    if (p.hasTag(Tag.DEFAULTCASELABEL)) {\n+                        translatedLabels.add(p);\n+                        hasDefault = true;\n+                    } else if (hasTotalPattern && !hasDefault &&\n+                               c == lastCase && p.isPattern()) {\n+                        \/\/If the switch has total pattern, the last case will contain it.\n+                        \/\/Convert the total pattern to default:\n+                        translatedLabels.add(make.DefaultCaseLabel());\n+                    } else {\n+                        int value;\n+                        if (p.isNullPattern()) {\n+                            value = -1;\n@@ -488,7 +438,1 @@\n-                            int value;\n-                            if (p.isNullPattern()) {\n-                                value = -1;\n-                            } else {\n-                                value = i++;\n-                            }\n-                            translatedLabels.add(make.Literal(value));\n+                            value = i++;\n@@ -496,0 +440,1 @@\n+                        translatedLabels.add(make.Literal(value));\n@@ -497,1 +442,0 @@\n-                    c.labels = translatedLabels.toList();\n@@ -499,0 +443,1 @@\n+                c.labels = translatedLabels.toList();\n@@ -532,7 +477,0 @@\n-    private boolean hasGuards(Collection<JCCase> cases) {\n-        return cases.stream()\n-                    .flatMap(c -> c.labels.stream())\n-                    .filter(JCCaseLabel::isPattern)\n-                    .anyMatch(l -> !TreeInfo.primaryPatternType((JCPattern) l).unconditional());\n-    }\n-\n@@ -547,8 +485,35 @@\n-            Assert.checkNonNull(l.type.constValue());\n-\n-            return switch (l.type.getTag()) {\n-                case BYTE, CHAR,\n-                     SHORT, INT -> LoadableConstant.Int((Integer) l.type.constValue());\n-                case CLASS -> LoadableConstant.String((String) l.type.constValue());\n-                default -> throw new AssertionError();\n-            };\n+            if ((l.type.tsym.flags_field & Flags.ENUM) != 0) {\n+                Assert.check(l.hasTag(Tag.IDENT));\n+\n+                List<Type> staticArgTypes = List.of(syms.methodHandleLookupType,\n+                                                    syms.stringType,\n+                                                    syms.classType,\n+                                                    syms.stringType,\n+                                                    new ClassType(syms.classType.getEnclosingType(),\n+                                                                  List.of(l.type),\n+                                                                  syms.classType.tsym));\n+                LoadableConstant[] staticArgValues = new LoadableConstant[] {\n+                    LoadableConstant.String(((JCIdent) l).name.toString()),\n+                    (ClassType) l.type\n+                };\n+\n+                Symbol bsm = rs.resolveInternalMethod(l.pos(), env, syms.switchBootstrapsType,\n+                        names.fromString(\"enumConstant\"), staticArgTypes, List.nil());\n+\n+                DynamicVarSymbol dynSym = new DynamicVarSymbol(names.fromString(\"enumConstant\"),\n+                        syms.noSymbol,\n+                        ((MethodSymbol)bsm).asHandle(),\n+                        l.type,\n+                        staticArgValues);\n+\n+                return dynSym;\n+            } else {\n+                Assert.checkNonNull(l.type.constValue());\n+\n+                return switch (l.type.getTag()) {\n+                    case BYTE, CHAR,\n+                         SHORT, INT -> LoadableConstant.Int((Integer) l.type.constValue());\n+                    case CLASS -> LoadableConstant.String((String) l.type.constValue());\n+                    default -> throw new AssertionError();\n+                };\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":91,"deletions":126,"binary":false,"changes":217,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.HashSet;\n@@ -932,1 +933,13 @@\n-        databuf.appendChar(poolWriter.bootstrapMethods.size());\n+        \/\/ensure all bootstrap methods are entered into the map:\n+        int size;\n+        do {\n+            size = poolWriter.bootstrapMethods.size();\n+            for (BsmKey bsmKey : new HashSet<>(poolWriter.bootstrapMethods.keySet())) {\n+                \/\/ensure all static args are in pool:\n+                LoadableConstant[] uniqueArgs = bsmKey.staticArgs;\n+                for (LoadableConstant arg : uniqueArgs) {\n+                    poolWriter.putConstant(arg);\n+                }\n+            }\n+        } while (size != poolWriter.bootstrapMethods.size());\n+        databuf.appendChar(size);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -66,1 +66,2 @@\n-        A;\n+        A,\n+        B;\n@@ -99,0 +100,1 @@\n+        testType(E1.A, 0, 2, E1.B, null, E1.A, Object.class);\n@@ -125,7 +127,0 @@\n-        try {\n-            BSM_TYPE_SWITCH.invoke(MethodHandles.lookup(), \"\", switchType,\n-                                   new Object[] {1, null, String.class});\n-            fail(\"Didn't get the expected exception.\");\n-        } catch (IllegalArgumentException ex) {\n-            \/\/OK\n-        }\n","filename":"test\/jdk\/java\/lang\/runtime\/SwitchBootstrapsTest.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8262891\n+ * @summary Verify pattern switches work properly when the set of enum constant changes.\n+ * @compile --enable-preview -source ${jdk.version} EnumTypeChanges.java\n+ * @compile --enable-preview -source ${jdk.version} EnumTypeChanges2.java\n+ * @run main\/othervm --enable-preview EnumTypeChanges\n+ *\/\n+\n+import java.util.function.Function;\n+import java.util.Objects;\n+\n+public class EnumTypeChanges {\n+\n+    public static void main(String... args) throws Exception {\n+        new EnumTypeChanges().run();\n+    }\n+\n+    void run() throws Exception {\n+        doRun(this::statementEnum);\n+        doRun(this::expressionEnum);\n+    }\n+\n+    void doRun(Function<EnumTypeChangesEnum, String> c) throws Exception {\n+        assertEquals(\"A\", c.apply(EnumTypeChangesEnum.A));\n+        assertEquals(\"D\", c.apply(EnumTypeChangesEnum.valueOf(\"C\")));\n+    }\n+\n+    String statementEnum(EnumTypeChangesEnum e) {\n+        switch (e) {\n+            case A -> { return \"A\"; }\n+            case B -> { return \"B\"; }\n+            default -> { return \"D\"; }\n+        }\n+    }\n+\n+    String expressionEnum(EnumTypeChangesEnum e) {\n+        return switch (e) {\n+            case A -> \"A\";\n+            case B -> \"B\";\n+            default -> \"D\";\n+        };\n+    }\n+\n+    private static void assertEquals(Object o1, Object o2) {\n+        if (!Objects.equals(o1, o2)) {\n+            throw new AssertionError();\n+        }\n+    }\n+}\n+\n+enum EnumTypeChangesEnum {\n+    A,\n+    B;\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/EnumTypeChanges.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -24,4 +24,4 @@\n-package pkg1;\n-\n-public enum Enum0 {\n-}\n+enum EnumTypeChangesEnum {\n+    A,\n+    C;\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/EnumTypeChanges2.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"test\/langtools\/jdk\/javadoc\/doclet\/testPackageSummary\/pkg1\/Enum0.java","status":"copied"}]}