{"files":[{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.invoke.ConstantBootstraps;\n@@ -33,2 +34,0 @@\n-import java.util.Arrays;\n-import java.util.Objects;\n@@ -56,1 +55,2 @@\n-    private static final MethodHandle DO_SWITCH;\n+    private static final MethodHandle DO_TYPE_SWITCH;\n+    private static final MethodHandle DO_ENUM_SWITCH;\n@@ -60,1 +60,1 @@\n-            DO_SWITCH = LOOKUP.findStatic(SwitchBootstraps.class, \"doSwitch\",\n+            DO_TYPE_SWITCH = LOOKUP.findStatic(SwitchBootstraps.class, \"doTypeSwitch\",\n@@ -62,0 +62,2 @@\n+            DO_ENUM_SWITCH = LOOKUP.findStatic(SwitchBootstraps.class, \"doEnumSwitch\",\n+                                           MethodType.methodType(int.class, Enum.class, int.class, Object[].class));\n@@ -129,1 +131,1 @@\n-        MethodHandle target = MethodHandles.insertArguments(DO_SWITCH, 2, (Object) labels);\n+        MethodHandle target = MethodHandles.insertArguments(DO_TYPE_SWITCH, 2, (Object) labels);\n@@ -145,1 +147,1 @@\n-    private static int doSwitch(Object target, int startIndex, Object[] labels) {\n+    private static int doTypeSwitch(Object target, int startIndex, Object[] labels) {\n@@ -170,0 +172,110 @@\n+    \/**\n+     * Bootstrap method for linking an {@code invokedynamic} call site that\n+     * implements a {@code switch} on a target of an enum type.  The static\n+     * arguments are an array of case labels which must be non-null and of type\n+     * {@code String} (representing enum constants) or {@code Class}.\n+     * <p>\n+     * The returned {@code CallSite}'s method handle will have\n+     * a return type of {@code int} and accepts two parameters: the first argument\n+     * will be an {@code Enum} instance ({@code target}) and the second\n+     * will be {@code int} ({@code restart}).\n+     * <p>\n+     * If the {@code target} is {@code null}, then the method of the call site\n+     * returns {@literal -1}.\n+     * <p>\n+     * If the {@code target} is not {@code null}, then the method of the call site\n+     * returns the index of the first element in the {@code labels} array starting from\n+     * the {@code restart} index matching one of the following conditions:\n+     * <ul>\n+     *   <li>the element is of type {@code Class} that is assignable\n+     *       from the target's class; or<\/li>\n+     *   <li>the element is of type {@code String} and equals to the target\n+     *       enum constant's {@link Enum#name()}.<\/li>\n+     * <\/ul>\n+     * <p>\n+     * If no element in the {@code labels} array matches the target, then\n+     * the method of the call site return the length of the {@code labels} array.\n+     *\n+     * @param lookup Represents a lookup context with the accessibility\n+     *               privileges of the caller.  When used with {@code invokedynamic},\n+     *               this is stacked automatically by the VM.\n+     * @param invocationName unused\n+     * @param invocationType The invocation type of the {@code CallSite} with two parameters,\n+     *                       an enum type, an {@code int}, and {@code int} as a return type.\n+     * @param labels case labels - {@code String} constants and {@code Class} instances,\n+     *               in any combination\n+     * @return a {@code CallSite} returning the first matching element as described above\n+     *\n+     * @throws NullPointerException if any argument is {@code null}\n+     * @throws IllegalArgumentException if any element in the labels array is null, if the\n+     * invocation type is not a method type of first parameter of an enum type,\n+     * second parameter of type {@code int} and with {@code int} as its return type,\n+     * or if {@code labels} contains an element that is not of type {@code String} or\n+     * {@code Class}.\n+     * @throws Throwable if there is any error linking the call site\n+     * @jvms 4.4.6 The CONSTANT_NameAndType_info Structure\n+     * @jvms 4.4.10 The CONSTANT_Dynamic_info and CONSTANT_InvokeDynamic_info Structures\n+     *\/\n+    public static CallSite enumSwitch(MethodHandles.Lookup lookup,\n+                                      String invocationName,\n+                                      MethodType invocationType,\n+                                      Object... labels) throws Throwable {\n+        if (invocationType.parameterCount() != 2\n+            || (!invocationType.returnType().equals(int.class))\n+            || invocationType.parameterType(0).isPrimitive()\n+            || !invocationType.parameterType(0).isEnum()\n+            || !invocationType.parameterType(1).equals(int.class))\n+            throw new IllegalArgumentException(\"Illegal invocation type \" + invocationType);\n+        requireNonNull(labels);\n+\n+        labels = labels.clone();\n+\n+        Class<?> enumClass = invocationType.parameterType(0);\n+        labels = Stream.of(labels).map(l -> convertEnumConstants(lookup, enumClass, l)).toArray();\n+\n+        MethodHandle target =\n+                MethodHandles.insertArguments(DO_ENUM_SWITCH, 2, (Object) labels);\n+        target = target.asType(invocationType);\n+\n+        return new ConstantCallSite(target);\n+    }\n+\n+    private static <E extends Enum<E>> Object convertEnumConstants(MethodHandles.Lookup lookup, Class<?> enumClassTemplate, Object label) {\n+        if (label == null) {\n+            throw new IllegalArgumentException(\"null label found\");\n+        }\n+        Class<?> labelClass = label.getClass();\n+        if (labelClass == Class.class) {\n+            return label;\n+        } else if (labelClass == String.class) {\n+            @SuppressWarnings(\"unchecked\")\n+            Class<E> enumClass = (Class<E>) enumClassTemplate;\n+            try {\n+                return ConstantBootstraps.enumConstant(lookup, (String) label, enumClass);\n+            } catch (IllegalArgumentException ex) {\n+                return null;\n+            }\n+        } else {\n+            throw new IllegalArgumentException(\"label with illegal type found: \" + labelClass);\n+        }\n+    }\n+\n+    private static int doEnumSwitch(Enum<?> target, int startIndex, Object[] labels) {\n+        if (target == null)\n+            return -1;\n+\n+        \/\/ Dumbest possible strategy\n+        Class<?> targetClass = target.getClass();\n+        for (int i = startIndex; i < labels.length; i++) {\n+            Object label = labels[i];\n+            if (label instanceof Class<?> c) {\n+                if (c.isAssignableFrom(targetClass))\n+                    return i;\n+            } else if (label == target) {\n+                return i;\n+            }\n+        }\n+\n+        return labels.length;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":118,"deletions":6,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import com.sun.tools.javac.code.Symbol.DynamicVarSymbol;\n@@ -61,0 +62,1 @@\n+import com.sun.tools.javac.util.Name;\n@@ -96,0 +98,1 @@\n+import java.util.Iterator;\n@@ -272,1 +275,0 @@\n-        boolean enumSwitch = (seltype.tsym.flags() & Flags.ENUM) != 0;\n@@ -312,21 +314,0 @@\n-            \/\/a special case for switches over enums with pattern case\n-            \/\/with only a single unguarded (type) pattern case, which is equivalent\n-            \/\/to a default with additional binding variable assignment:\n-            \/\/switch ($enum) {\n-            \/\/    case $constant1: $stats$\n-            \/\/    case $constant2: $stats$\n-            \/\/    case typeof($enum) e: $stats$\n-            \/\/}\n-            \/\/=>\n-            \/\/switch ($enum) {\n-            \/\/    case $constant1: $stats$\n-            \/\/    case $constant2: $stats$\n-            \/\/    default: typeof($enum) e = $enum; $stats$\n-            \/\/}\n-            \/\/constant labels in switches over enums with one or more pattern cases\n-            \/\/with guards are desugared into guards:\n-            \/\/case $constant1: $stats$\n-            \/\/=>\n-            \/\/case typeof($enum) e && e == $constant1: $stats$\n-            \/\/and handled as a normal pattern matching switch\n-            \/\/\n@@ -342,21 +323,0 @@\n-            if (enumSwitch && hasGuards(newCases)) {\n-                for (JCCase c : newCases) {\n-                    for (List<JCCaseLabel> l = c.labels; l.nonEmpty(); l = l.tail) {\n-                        if (l.head.isExpression() && !TreeInfo.isNull(l.head)) {\n-                            BindingSymbol temp = new BindingSymbol(Flags.SYNTHETIC,\n-                                    names.fromString(\"enumGuard\" + c.pos +\n-                                                     target.syntheticNameChar() + \"temp\"),\n-                                    seltype,\n-                                    currentMethodSym);\n-                            JCBindingPattern binding =\n-                                    make.at(l.head.pos()).BindingPattern(make.VarDef(temp, null));\n-                            binding.setType(seltype);\n-                            l.head = make.GuardPattern(binding,\n-                                                       makeBinary(Tag.EQ,\n-                                                                  make.Ident(temp),\n-                                                                  (JCExpression) l.head));\n-                        }\n-                    }\n-                }\n-                enumSwitch = false;\n-            }\n@@ -391,40 +351,38 @@\n-            if (enumSwitch) {\n-                selector = make.Ident(temp);\n-            } else {\n-                List<Type> staticArgTypes = List.of(syms.methodHandleLookupType,\n-                                                    syms.stringType,\n-                                                    syms.methodTypeType,\n-                                                    types.makeArrayType(new ClassType(syms.classType.getEnclosingType(),\n-                                                                        List.of(new WildcardType(syms.objectType, BoundKind.UNBOUND,\n-                                                                                                 syms.boundClass)),\n-                                                                        syms.classType.tsym)));\n-                LoadableConstant[] staticArgValues =\n-                        cases.stream()\n-                             .flatMap(c -> c.labels.stream())\n-                             .map(l -> toLoadableConstant(l))\n-                             .filter(c -> c != null)\n-                             .toArray(s -> new LoadableConstant[s]);\n-\n-                Symbol bsm = rs.resolveInternalMethod(tree.pos(), env, syms.switchBootstrapsType,\n-                        names.fromString(\"typeSwitch\"), staticArgTypes, List.nil());\n-\n-                MethodType indyType = new MethodType(\n-                        List.of(syms.objectType, syms.intType),\n-                        syms.intType,\n-                        List.nil(),\n-                        syms.methodClass\n-                );\n-                DynamicMethodSymbol dynSym = new DynamicMethodSymbol(names.fromString(\"typeSwitch\"),\n-                        syms.noSymbol,\n-                        ((MethodSymbol)bsm).asHandle(),\n-                        indyType,\n-                        staticArgValues);\n-\n-                JCFieldAccess qualifier = make.Select(make.QualIdent(bsm.owner), dynSym.name);\n-                qualifier.sym = dynSym;\n-                qualifier.type = syms.intType;\n-                selector = make.Apply(List.nil(),\n-                                      qualifier,\n-                                      List.of(make.Ident(temp), make.Ident(index)))\n-                               .setType(syms.intType);\n-            }\n+            List<Type> staticArgTypes = List.of(syms.methodHandleLookupType,\n+                                                syms.stringType,\n+                                                syms.methodTypeType,\n+                                                types.makeArrayType(new ClassType(syms.classType.getEnclosingType(),\n+                                                                    List.of(new WildcardType(syms.objectType, BoundKind.UNBOUND,\n+                                                                                             syms.boundClass)),\n+                                                                    syms.classType.tsym)));\n+            LoadableConstant[] staticArgValues =\n+                    cases.stream()\n+                         .flatMap(c -> c.labels.stream())\n+                         .map(l -> toLoadableConstant(l))\n+                         .filter(c -> c != null)\n+                         .toArray(s -> new LoadableConstant[s]);\n+\n+            boolean enumSelector = seltype.tsym.isEnum();\n+            Name bootstrapName = enumSelector ? names.enumSwitch : names.typeSwitch;\n+            Symbol bsm = rs.resolveInternalMethod(tree.pos(), env, syms.switchBootstrapsType,\n+                    bootstrapName, staticArgTypes, List.nil());\n+\n+            MethodType indyType = new MethodType(\n+                    List.of(enumSelector ? seltype : syms.objectType, syms.intType),\n+                    syms.intType,\n+                    List.nil(),\n+                    syms.methodClass\n+            );\n+            DynamicMethodSymbol dynSym = new DynamicMethodSymbol(bootstrapName,\n+                    syms.noSymbol,\n+                    ((MethodSymbol)bsm).asHandle(),\n+                    indyType,\n+                    staticArgValues);\n+\n+            JCFieldAccess qualifier = make.Select(make.QualIdent(bsm.owner), dynSym.name);\n+            qualifier.sym = dynSym;\n+            qualifier.type = syms.intType;\n+            selector = make.Apply(List.nil(),\n+                                  qualifier,\n+                                  List.of(make.Ident(temp), make.Ident(index)))\n+                           .setType(syms.intType);\n@@ -467,20 +425,14 @@\n-                if (enumSwitch) {\n-                    var labels = c.labels;\n-\n-                    while (labels.nonEmpty()) {\n-                        if (labels.head.isPattern()) {\n-                            labels.head = make.DefaultCaseLabel();\n-                        }\n-                        labels = labels.tail;\n-                    }\n-                } else {\n-                    ListBuffer<JCCaseLabel> translatedLabels = new ListBuffer<>();\n-                    for (var p : c.labels) {\n-                        if (p.hasTag(Tag.DEFAULTCASELABEL)) {\n-                            translatedLabels.add(p);\n-                            hasDefault = true;\n-                        } else if (hasTotalPattern && !hasDefault &&\n-                                   c == lastCase && p.isPattern()) {\n-                            \/\/If the switch has total pattern, the last case will contain it.\n-                            \/\/Convert the total pattern to default:\n-                            translatedLabels.add(make.DefaultCaseLabel());\n+                ListBuffer<JCCaseLabel> translatedLabels = new ListBuffer<>();\n+                for (var p : c.labels) {\n+                    if (p.hasTag(Tag.DEFAULTCASELABEL)) {\n+                        translatedLabels.add(p);\n+                        hasDefault = true;\n+                    } else if (hasTotalPattern && !hasDefault &&\n+                               c == lastCase && p.isPattern()) {\n+                        \/\/If the switch has total pattern, the last case will contain it.\n+                        \/\/Convert the total pattern to default:\n+                        translatedLabels.add(make.DefaultCaseLabel());\n+                    } else {\n+                        int value;\n+                        if (p.isNullPattern()) {\n+                            value = -1;\n@@ -488,7 +440,1 @@\n-                            int value;\n-                            if (p.isNullPattern()) {\n-                                value = -1;\n-                            } else {\n-                                value = i++;\n-                            }\n-                            translatedLabels.add(make.Literal(value));\n+                            value = i++;\n@@ -496,0 +442,1 @@\n+                        translatedLabels.add(make.Literal(value));\n@@ -497,1 +444,0 @@\n-                    c.labels = translatedLabels.toList();\n@@ -499,0 +445,1 @@\n+                c.labels = translatedLabels.toList();\n@@ -532,7 +479,0 @@\n-    private boolean hasGuards(Collection<JCCase> cases) {\n-        return cases.stream()\n-                    .flatMap(c -> c.labels.stream())\n-                    .filter(JCCaseLabel::isPattern)\n-                    .anyMatch(l -> !TreeInfo.primaryPatternType((JCPattern) l).unconditional());\n-    }\n-\n@@ -547,8 +487,12 @@\n-            Assert.checkNonNull(l.type.constValue());\n-\n-            return switch (l.type.getTag()) {\n-                case BYTE, CHAR,\n-                     SHORT, INT -> LoadableConstant.Int((Integer) l.type.constValue());\n-                case CLASS -> LoadableConstant.String((String) l.type.constValue());\n-                default -> throw new AssertionError();\n-            };\n+            if ((l.type.tsym.flags_field & Flags.ENUM) != 0) {\n+                return LoadableConstant.String(((JCIdent) l).name.toString());\n+            } else {\n+                Assert.checkNonNull(l.type.constValue());\n+\n+                return switch (l.type.getTag()) {\n+                    case BYTE, CHAR,\n+                         SHORT, INT -> LoadableConstant.Int((Integer) l.type.constValue());\n+                    case CLASS -> LoadableConstant.String((String) l.type.constValue());\n+                    default -> throw new AssertionError();\n+                };\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":70,"deletions":126,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -218,0 +218,4 @@\n+    \/\/ pattern switches\n+    public final Name typeSwitch;\n+    public final Name enumSwitch;\n+\n@@ -387,0 +391,4 @@\n+\n+        \/\/ pattern switches\n+        typeSwitch = fromString(\"typeSwitch\");\n+        enumSwitch = fromString(\"enumSwitch\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+    public static final MethodHandle BSM_ENUM_SWITCH;\n@@ -52,0 +53,2 @@\n+            BSM_ENUM_SWITCH = MethodHandles.lookup().findStatic(SwitchBootstraps.class, \"enumSwitch\",\n+                                                                MethodType.methodType(CallSite.class, MethodHandles.Lookup.class, String.class, MethodType.class, Object[].class));\n@@ -65,0 +68,7 @@\n+    private void testEnum(Enum<?> target, int start, int result, Object... labels) throws Throwable {\n+        MethodType switchType = MethodType.methodType(int.class, target.getClass(), int.class);\n+        MethodHandle indy = ((CallSite) BSM_ENUM_SWITCH.invoke(MethodHandles.lookup(), \"\", switchType, labels)).dynamicInvoker();\n+        assertEquals((int) indy.invoke(target, start), result);\n+        assertEquals(-1, (int) indy.invoke(null, start));\n+    }\n+\n@@ -66,1 +76,2 @@\n-        A;\n+        A,\n+        B;\n@@ -101,0 +112,6 @@\n+    public void testEnums() throws Throwable {\n+        testEnum(E1.A, 0, 2, \"B\", \"C\", \"A\", E1.class);\n+        testEnum(E1.B, 0, 0, \"B\", \"C\", \"A\", E1.class);\n+        testEnum(E1.B, 1, 3, \"B\", \"C\", \"A\", E1.class);\n+    }\n+\n@@ -115,0 +132,14 @@\n+        MethodType[] enumSwitchTypes = new MethodType[] {\n+            MethodType.methodType(int.class, Enum.class),\n+            MethodType.methodType(int.class, Object.class, int.class),\n+            MethodType.methodType(int.class, double.class, int.class),\n+            MethodType.methodType(int.class, Enum.class, Integer.class)\n+        };\n+        for (MethodType enumSwitchType : enumSwitchTypes) {\n+            try {\n+                BSM_ENUM_SWITCH.invoke(MethodHandles.lookup(), \"\", enumSwitchType);\n+                fail(\"Didn't get the expected exception.\");\n+            } catch (IllegalArgumentException ex) {\n+                \/\/OK, expected\n+            }\n+        }\n@@ -132,0 +163,14 @@\n+        MethodType enumSwitchType = MethodType.methodType(int.class, E1.class, int.class);\n+        try {\n+            BSM_TYPE_SWITCH.invoke(MethodHandles.lookup(), \"\", enumSwitchType, (Object[]) null);\n+            fail(\"Didn't get the expected exception.\");\n+        } catch (NullPointerException ex) {\n+            \/\/OK\n+        }\n+        try {\n+            BSM_TYPE_SWITCH.invoke(MethodHandles.lookup(), \"\", enumSwitchType,\n+                                   new Object[] {1, null, String.class});\n+            fail(\"Didn't get the expected exception.\");\n+        } catch (IllegalArgumentException ex) {\n+            \/\/OK\n+        }\n","filename":"test\/jdk\/java\/lang\/runtime\/SwitchBootstrapsTest.java","additions":46,"deletions":1,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8262891\n+ * @summary Verify pattern switches work properly when the set of enum constant changes.\n+ * @compile --enable-preview -source ${jdk.version} EnumTypeChanges.java\n+ * @compile --enable-preview -source ${jdk.version} EnumTypeChanges2.java\n+ * @run main\/othervm --enable-preview EnumTypeChanges\n+ *\/\n+\n+import java.util.function.Function;\n+import java.util.Objects;\n+\n+public class EnumTypeChanges {\n+\n+    public static void main(String... args) throws Exception {\n+        new EnumTypeChanges().run();\n+    }\n+\n+    void run() throws Exception {\n+        doRun(this::statementEnum);\n+        doRun(this::expressionEnum);\n+    }\n+\n+    void doRun(Function<EnumTypeChangesEnum, String> c) throws Exception {\n+        assertEquals(\"A\", c.apply(EnumTypeChangesEnum.A));\n+        assertEquals(\"D\", c.apply(EnumTypeChangesEnum.valueOf(\"C\")));\n+    }\n+\n+    String statementEnum(EnumTypeChangesEnum e) {\n+        switch (e) {\n+            case A -> { return \"A\"; }\n+            case EnumTypeChangesEnum e1 && false -> throw new AssertionError();\n+            case B -> { return \"B\"; }\n+            default -> { return \"D\"; }\n+        }\n+    }\n+\n+    String expressionEnum(EnumTypeChangesEnum e) {\n+        return switch (e) {\n+            case A -> \"A\";\n+            case EnumTypeChangesEnum e1 && false -> throw new AssertionError();\n+            case B -> \"B\";\n+            default -> \"D\";\n+        };\n+    }\n+\n+    private static void assertEquals(Object o1, Object o2) {\n+        if (!Objects.equals(o1, o2)) {\n+            throw new AssertionError();\n+        }\n+    }\n+}\n+\n+enum EnumTypeChangesEnum {\n+    A,\n+    B;\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/EnumTypeChanges.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -24,3 +24,3 @@\n-package pkg1;\n-\n-public record Record0() {\n+enum EnumTypeChangesEnum {\n+    A,\n+    C;\n","filename":"test\/langtools\/tools\/javac\/patterns\/EnumTypeChanges2.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"test\/langtools\/jdk\/javadoc\/doclet\/testPackageSummary\/pkg1\/Record0.java","status":"copied"}]}