{"files":[{"patch":"@@ -111,14 +111,0 @@\n-    static final List<IntFunction<int[]>> INDEX_GENERATORS = List.of(\n-            withToString(\"index[i -> i]\", (int s) -> {\n-                return fillInts(s,\n-                                i -> i);\n-            }),\n-            withToString(\"index[i -> size - i - 1]\", (int s) -> {\n-                return fillInts(s,\n-                                i -> s - i - 1);\n-            }),\n-            withToString(\"index[i -> (i % 2) == 0 ? i : s - i - 1]\", (int s) -> {\n-                return fillInts(s,\n-                                i -> (i % 2) == 0 ? i : s - i - 1);\n-            })\n-    );\n@@ -164,3 +150,2 @@\n-            withToStringBi(\"shuffle[random]\", (Integer l, Integer m) -> {\n-                return RAND.ints(l, 0, m).toArray();\n-            })\n+            withToStringBi(\"shuffle[random]\",\n+                    (Integer l, Integer m) -> RAND.ints(l, 0, m).toArray())\n@@ -205,3 +190,2 @@\n-            withToStringBi(\"index[random]\", (Integer l, Integer m) -> {\n-                return RAND.ints(l, 0, m).toArray();\n-            })\n+            withToStringBi(\"index[random]\",\n+                    (Integer l, Integer m) -> RAND.ints(l, 0, m).toArray())\n@@ -210,6 +194,0 @@\n-    static int countTrailingFalse(boolean[] m) {\n-        int i;\n-        for (i = m.length - 1; i >= 0 && !m[i]; i--);\n-        return m.length - 1 - i;\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/AbstractVectorTest.java","additions":4,"deletions":26,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import java.util.Arrays;\n@@ -53,1 +54,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -58,2 +59,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (128 \/ 8));\n-\n@@ -181,19 +180,0 @@\n-    @DataProvider\n-    public Object[][] byteIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> BYTE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] byteIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> BYTE_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -1041,0 +1021,277 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(byte[] r, byte[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(byte[] r, byte[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (byte) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (byte) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(byte[] r, byte[] a, int[] indexMap, boolean[] mask) {\n+        byte[] expected = new byte[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(byte[] r, byte[] a, int[] indexMap) {\n+        byte[] expected = new byte[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> BYTE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            BYTE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+    static void assertGatherArraysEquals(boolean[] r, boolean[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(boolean[] r, boolean[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: false);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: false, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(boolean[] r, boolean[] a, int[] indexMap, boolean[] mask) {\n+        boolean[] expected = new boolean[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(boolean[] r, boolean[] a, int[] indexMap) {\n+        boolean[] expected = new boolean[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void booleanGather(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, b, i);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void booleanGatherMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, b, i, vmask);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void booleanScatter(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void booleanScatterMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorLoadStoreTests.java","additions":279,"deletions":22,"binary":false,"changes":301,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (128 \/ 8));\n-\n@@ -1011,30 +1009,0 @@\n-    @DataProvider\n-    public Object[][] byteUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> BYTE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] byteUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            BYTE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            BYTE_GENERATORS.stream().flatMap(fn ->\n-              BYTE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4925,116 +4893,0 @@\n-    static byte[] gather(byte a[], int ix, int[] b, int iy) {\n-        byte[] res = new byte[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"byteUnaryOpIndexProvider\")\n-    static void gatherByte128VectorTests(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Byte128VectorTests::gather);\n-    }\n-    static byte[] gatherMasked(byte a[], int ix, boolean[] mask, int[] b, int iy) {\n-        byte[] res = new byte[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"byteUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedByte128VectorTests(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Byte128VectorTests::gatherMasked);\n-    }\n-\n-    static byte[] scatter(byte a[], int ix, int[] b, int iy) {\n-      byte[] res = new byte[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"byteUnaryOpIndexProvider\")\n-    static void scatterByte128VectorTests(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Byte128VectorTests::scatter);\n-    }\n-\n-    static byte[] scatterMasked(byte r[], byte a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      byte[] oldVal = gather(r, ix, b, iy);\n-      byte[] newVal = new byte[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      byte[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        byte[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Byte128VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import java.util.Arrays;\n@@ -53,1 +54,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -58,2 +59,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (256 \/ 8));\n-\n@@ -181,19 +180,0 @@\n-    @DataProvider\n-    public Object[][] byteIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> BYTE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] byteIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> BYTE_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -1041,0 +1021,277 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(byte[] r, byte[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(byte[] r, byte[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (byte) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (byte) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(byte[] r, byte[] a, int[] indexMap, boolean[] mask) {\n+        byte[] expected = new byte[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(byte[] r, byte[] a, int[] indexMap) {\n+        byte[] expected = new byte[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> BYTE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            BYTE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+    static void assertGatherArraysEquals(boolean[] r, boolean[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(boolean[] r, boolean[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: false);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: false, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(boolean[] r, boolean[] a, int[] indexMap, boolean[] mask) {\n+        boolean[] expected = new boolean[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(boolean[] r, boolean[] a, int[] indexMap) {\n+        boolean[] expected = new boolean[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void booleanGather(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, b, i);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void booleanGatherMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, b, i, vmask);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void booleanScatter(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void booleanScatterMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorLoadStoreTests.java","additions":279,"deletions":22,"binary":false,"changes":301,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (256 \/ 8));\n-\n@@ -1011,30 +1009,0 @@\n-    @DataProvider\n-    public Object[][] byteUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> BYTE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] byteUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            BYTE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            BYTE_GENERATORS.stream().flatMap(fn ->\n-              BYTE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4925,116 +4893,0 @@\n-    static byte[] gather(byte a[], int ix, int[] b, int iy) {\n-        byte[] res = new byte[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"byteUnaryOpIndexProvider\")\n-    static void gatherByte256VectorTests(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Byte256VectorTests::gather);\n-    }\n-    static byte[] gatherMasked(byte a[], int ix, boolean[] mask, int[] b, int iy) {\n-        byte[] res = new byte[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"byteUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedByte256VectorTests(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Byte256VectorTests::gatherMasked);\n-    }\n-\n-    static byte[] scatter(byte a[], int ix, int[] b, int iy) {\n-      byte[] res = new byte[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"byteUnaryOpIndexProvider\")\n-    static void scatterByte256VectorTests(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Byte256VectorTests::scatter);\n-    }\n-\n-    static byte[] scatterMasked(byte r[], byte a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      byte[] oldVal = gather(r, ix, b, iy);\n-      byte[] newVal = new byte[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      byte[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        byte[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Byte256VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import java.util.Arrays;\n@@ -53,1 +54,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -58,2 +59,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (512 \/ 8));\n-\n@@ -181,19 +180,0 @@\n-    @DataProvider\n-    public Object[][] byteIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> BYTE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] byteIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> BYTE_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -1041,0 +1021,277 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(byte[] r, byte[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(byte[] r, byte[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (byte) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (byte) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(byte[] r, byte[] a, int[] indexMap, boolean[] mask) {\n+        byte[] expected = new byte[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(byte[] r, byte[] a, int[] indexMap) {\n+        byte[] expected = new byte[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> BYTE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            BYTE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+    static void assertGatherArraysEquals(boolean[] r, boolean[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(boolean[] r, boolean[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: false);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: false, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(boolean[] r, boolean[] a, int[] indexMap, boolean[] mask) {\n+        boolean[] expected = new boolean[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(boolean[] r, boolean[] a, int[] indexMap) {\n+        boolean[] expected = new boolean[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void booleanGather(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, b, i);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void booleanGatherMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, b, i, vmask);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void booleanScatter(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void booleanScatterMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorLoadStoreTests.java","additions":279,"deletions":22,"binary":false,"changes":301,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (512 \/ 8));\n-\n@@ -1011,30 +1009,0 @@\n-    @DataProvider\n-    public Object[][] byteUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> BYTE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] byteUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            BYTE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            BYTE_GENERATORS.stream().flatMap(fn ->\n-              BYTE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4925,116 +4893,0 @@\n-    static byte[] gather(byte a[], int ix, int[] b, int iy) {\n-        byte[] res = new byte[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"byteUnaryOpIndexProvider\")\n-    static void gatherByte512VectorTests(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Byte512VectorTests::gather);\n-    }\n-    static byte[] gatherMasked(byte a[], int ix, boolean[] mask, int[] b, int iy) {\n-        byte[] res = new byte[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"byteUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedByte512VectorTests(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Byte512VectorTests::gatherMasked);\n-    }\n-\n-    static byte[] scatter(byte a[], int ix, int[] b, int iy) {\n-      byte[] res = new byte[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"byteUnaryOpIndexProvider\")\n-    static void scatterByte512VectorTests(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Byte512VectorTests::scatter);\n-    }\n-\n-    static byte[] scatterMasked(byte r[], byte a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      byte[] oldVal = gather(r, ix, b, iy);\n-      byte[] newVal = new byte[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      byte[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        byte[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Byte512VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import java.util.Arrays;\n@@ -53,1 +54,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -58,2 +59,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (64 \/ 8));\n-\n@@ -181,19 +180,0 @@\n-    @DataProvider\n-    public Object[][] byteIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> BYTE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] byteIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> BYTE_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -1041,0 +1021,277 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(byte[] r, byte[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(byte[] r, byte[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (byte) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (byte) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(byte[] r, byte[] a, int[] indexMap, boolean[] mask) {\n+        byte[] expected = new byte[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(byte[] r, byte[] a, int[] indexMap) {\n+        byte[] expected = new byte[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> BYTE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            BYTE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+    static void assertGatherArraysEquals(boolean[] r, boolean[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(boolean[] r, boolean[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: false);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: false, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(boolean[] r, boolean[] a, int[] indexMap, boolean[] mask) {\n+        boolean[] expected = new boolean[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(boolean[] r, boolean[] a, int[] indexMap) {\n+        boolean[] expected = new boolean[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void booleanGather(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, b, i);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void booleanGatherMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, b, i, vmask);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void booleanScatter(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void booleanScatterMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorLoadStoreTests.java","additions":279,"deletions":22,"binary":false,"changes":301,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (64 \/ 8));\n-\n@@ -1011,30 +1009,0 @@\n-    @DataProvider\n-    public Object[][] byteUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> BYTE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] byteUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            BYTE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            BYTE_GENERATORS.stream().flatMap(fn ->\n-              BYTE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4925,116 +4893,0 @@\n-    static byte[] gather(byte a[], int ix, int[] b, int iy) {\n-        byte[] res = new byte[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"byteUnaryOpIndexProvider\")\n-    static void gatherByte64VectorTests(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Byte64VectorTests::gather);\n-    }\n-    static byte[] gatherMasked(byte a[], int ix, boolean[] mask, int[] b, int iy) {\n-        byte[] res = new byte[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"byteUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedByte64VectorTests(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Byte64VectorTests::gatherMasked);\n-    }\n-\n-    static byte[] scatter(byte a[], int ix, int[] b, int iy) {\n-      byte[] res = new byte[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"byteUnaryOpIndexProvider\")\n-    static void scatterByte64VectorTests(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Byte64VectorTests::scatter);\n-    }\n-\n-    static byte[] scatterMasked(byte r[], byte a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      byte[] oldVal = gather(r, ix, b, iy);\n-      byte[] newVal = new byte[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      byte[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        byte[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Byte64VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import java.util.Arrays;\n@@ -57,1 +58,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -67,2 +68,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (Max \/ 8));\n-\n@@ -190,19 +189,0 @@\n-    @DataProvider\n-    public Object[][] byteIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> BYTE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] byteIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> BYTE_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -1050,0 +1030,277 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(byte[] r, byte[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(byte[] r, byte[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (byte) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (byte) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(byte[] r, byte[] a, int[] indexMap, boolean[] mask) {\n+        byte[] expected = new byte[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(byte[] r, byte[] a, int[] indexMap) {\n+        byte[] expected = new byte[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> BYTE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            BYTE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+    static void assertGatherArraysEquals(boolean[] r, boolean[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(boolean[] r, boolean[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: false);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: false, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(boolean[] r, boolean[] a, int[] indexMap, boolean[] mask) {\n+        boolean[] expected = new boolean[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(boolean[] r, boolean[] a, int[] indexMap) {\n+        boolean[] expected = new boolean[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void booleanGather(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, b, i);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void booleanGatherMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, b, i, vmask);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void booleanScatter(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void booleanScatterMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorLoadStoreTests.java","additions":279,"deletions":22,"binary":false,"changes":301,"status":"modified"},{"patch":"@@ -70,2 +70,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (Max \/ 8));\n-\n@@ -1016,30 +1014,0 @@\n-    @DataProvider\n-    public Object[][] byteUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> BYTE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] byteUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            BYTE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            BYTE_GENERATORS.stream().flatMap(fn ->\n-              BYTE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4930,116 +4898,0 @@\n-    static byte[] gather(byte a[], int ix, int[] b, int iy) {\n-        byte[] res = new byte[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"byteUnaryOpIndexProvider\")\n-    static void gatherByteMaxVectorTests(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, ByteMaxVectorTests::gather);\n-    }\n-    static byte[] gatherMasked(byte a[], int ix, boolean[] mask, int[] b, int iy) {\n-        byte[] res = new byte[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"byteUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedByteMaxVectorTests(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, ByteMaxVectorTests::gatherMasked);\n-    }\n-\n-    static byte[] scatter(byte a[], int ix, int[] b, int iy) {\n-      byte[] res = new byte[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"byteUnaryOpIndexProvider\")\n-    static void scatterByteMaxVectorTests(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, ByteMaxVectorTests::scatter);\n-    }\n-\n-    static byte[] scatterMasked(byte r[], byte a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      byte[] oldVal = gather(r, ix, b, iy);\n-      byte[] newVal = new byte[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      byte[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        byte[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, ByteMaxVectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Arrays;\n@@ -54,1 +55,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -59,2 +60,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (128 \/ 8));\n-\n@@ -192,19 +191,0 @@\n-    @DataProvider\n-    public Object[][] doubleIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> DOUBLE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] doubleIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> DOUBLE_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -965,0 +945,152 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(double[] r, double[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(double[] r, double[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (double) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (double) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(double[] r, double[] a, int[] indexMap, boolean[] mask) {\n+        double[] expected = new double[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(double[] r, double[] a, int[] indexMap) {\n+        double[] expected = new double[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> DOUBLE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            DOUBLE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorLoadStoreTests.java","additions":154,"deletions":22,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (128 \/ 8));\n-\n@@ -1143,30 +1141,0 @@\n-    @DataProvider\n-    public Object[][] doubleUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> DOUBLE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] doubleUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            DOUBLE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            DOUBLE_GENERATORS.stream().flatMap(fn ->\n-              DOUBLE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4497,116 +4465,0 @@\n-    static double[] gather(double a[], int ix, int[] b, int iy) {\n-        double[] res = new double[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"doubleUnaryOpIndexProvider\")\n-    static void gatherDouble128VectorTests(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Double128VectorTests::gather);\n-    }\n-    static double[] gatherMasked(double a[], int ix, boolean[] mask, int[] b, int iy) {\n-        double[] res = new double[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"doubleUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedDouble128VectorTests(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Double128VectorTests::gatherMasked);\n-    }\n-\n-    static double[] scatter(double a[], int ix, int[] b, int iy) {\n-      double[] res = new double[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"doubleUnaryOpIndexProvider\")\n-    static void scatterDouble128VectorTests(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Double128VectorTests::scatter);\n-    }\n-\n-    static double[] scatterMasked(double r[], double a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      double[] oldVal = gather(r, ix, b, iy);\n-      double[] newVal = new double[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      double[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedDouble128VectorTests(IntFunction<double[]> fa, IntFunction<double[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        double[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Double128VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Arrays;\n@@ -54,1 +55,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -59,2 +60,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (256 \/ 8));\n-\n@@ -192,19 +191,0 @@\n-    @DataProvider\n-    public Object[][] doubleIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> DOUBLE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] doubleIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> DOUBLE_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -965,0 +945,152 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(double[] r, double[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(double[] r, double[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (double) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (double) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(double[] r, double[] a, int[] indexMap, boolean[] mask) {\n+        double[] expected = new double[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(double[] r, double[] a, int[] indexMap) {\n+        double[] expected = new double[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> DOUBLE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            DOUBLE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorLoadStoreTests.java","additions":154,"deletions":22,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (256 \/ 8));\n-\n@@ -1143,30 +1141,0 @@\n-    @DataProvider\n-    public Object[][] doubleUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> DOUBLE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] doubleUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            DOUBLE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            DOUBLE_GENERATORS.stream().flatMap(fn ->\n-              DOUBLE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4497,116 +4465,0 @@\n-    static double[] gather(double a[], int ix, int[] b, int iy) {\n-        double[] res = new double[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"doubleUnaryOpIndexProvider\")\n-    static void gatherDouble256VectorTests(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Double256VectorTests::gather);\n-    }\n-    static double[] gatherMasked(double a[], int ix, boolean[] mask, int[] b, int iy) {\n-        double[] res = new double[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"doubleUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedDouble256VectorTests(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Double256VectorTests::gatherMasked);\n-    }\n-\n-    static double[] scatter(double a[], int ix, int[] b, int iy) {\n-      double[] res = new double[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"doubleUnaryOpIndexProvider\")\n-    static void scatterDouble256VectorTests(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Double256VectorTests::scatter);\n-    }\n-\n-    static double[] scatterMasked(double r[], double a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      double[] oldVal = gather(r, ix, b, iy);\n-      double[] newVal = new double[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      double[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedDouble256VectorTests(IntFunction<double[]> fa, IntFunction<double[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        double[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Double256VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Arrays;\n@@ -54,1 +55,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -59,2 +60,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (512 \/ 8));\n-\n@@ -192,19 +191,0 @@\n-    @DataProvider\n-    public Object[][] doubleIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> DOUBLE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] doubleIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> DOUBLE_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -965,0 +945,152 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(double[] r, double[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(double[] r, double[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (double) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (double) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(double[] r, double[] a, int[] indexMap, boolean[] mask) {\n+        double[] expected = new double[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(double[] r, double[] a, int[] indexMap) {\n+        double[] expected = new double[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> DOUBLE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            DOUBLE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorLoadStoreTests.java","additions":154,"deletions":22,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (512 \/ 8));\n-\n@@ -1143,30 +1141,0 @@\n-    @DataProvider\n-    public Object[][] doubleUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> DOUBLE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] doubleUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            DOUBLE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            DOUBLE_GENERATORS.stream().flatMap(fn ->\n-              DOUBLE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4497,116 +4465,0 @@\n-    static double[] gather(double a[], int ix, int[] b, int iy) {\n-        double[] res = new double[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"doubleUnaryOpIndexProvider\")\n-    static void gatherDouble512VectorTests(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Double512VectorTests::gather);\n-    }\n-    static double[] gatherMasked(double a[], int ix, boolean[] mask, int[] b, int iy) {\n-        double[] res = new double[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"doubleUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedDouble512VectorTests(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Double512VectorTests::gatherMasked);\n-    }\n-\n-    static double[] scatter(double a[], int ix, int[] b, int iy) {\n-      double[] res = new double[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"doubleUnaryOpIndexProvider\")\n-    static void scatterDouble512VectorTests(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Double512VectorTests::scatter);\n-    }\n-\n-    static double[] scatterMasked(double r[], double a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      double[] oldVal = gather(r, ix, b, iy);\n-      double[] newVal = new double[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      double[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedDouble512VectorTests(IntFunction<double[]> fa, IntFunction<double[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        double[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Double512VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Arrays;\n@@ -54,1 +55,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -59,2 +60,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (64 \/ 8));\n-\n@@ -192,19 +191,0 @@\n-    @DataProvider\n-    public Object[][] doubleIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> DOUBLE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] doubleIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> DOUBLE_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -965,0 +945,152 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(double[] r, double[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(double[] r, double[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (double) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (double) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(double[] r, double[] a, int[] indexMap, boolean[] mask) {\n+        double[] expected = new double[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(double[] r, double[] a, int[] indexMap) {\n+        double[] expected = new double[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> DOUBLE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            DOUBLE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorLoadStoreTests.java","additions":154,"deletions":22,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (64 \/ 8));\n-\n@@ -1143,30 +1141,0 @@\n-    @DataProvider\n-    public Object[][] doubleUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> DOUBLE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] doubleUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            DOUBLE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            DOUBLE_GENERATORS.stream().flatMap(fn ->\n-              DOUBLE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4497,116 +4465,0 @@\n-    static double[] gather(double a[], int ix, int[] b, int iy) {\n-        double[] res = new double[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"doubleUnaryOpIndexProvider\")\n-    static void gatherDouble64VectorTests(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Double64VectorTests::gather);\n-    }\n-    static double[] gatherMasked(double a[], int ix, boolean[] mask, int[] b, int iy) {\n-        double[] res = new double[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"doubleUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedDouble64VectorTests(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Double64VectorTests::gatherMasked);\n-    }\n-\n-    static double[] scatter(double a[], int ix, int[] b, int iy) {\n-      double[] res = new double[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"doubleUnaryOpIndexProvider\")\n-    static void scatterDouble64VectorTests(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Double64VectorTests::scatter);\n-    }\n-\n-    static double[] scatterMasked(double r[], double a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      double[] oldVal = gather(r, ix, b, iy);\n-      double[] newVal = new double[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      double[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedDouble64VectorTests(IntFunction<double[]> fa, IntFunction<double[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        double[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Double64VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Arrays;\n@@ -58,1 +59,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -68,2 +69,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (Max \/ 8));\n-\n@@ -201,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] doubleIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> DOUBLE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] doubleIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> DOUBLE_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -974,0 +954,152 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(double[] r, double[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(double[] r, double[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (double) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (double) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(double[] r, double[] a, int[] indexMap, boolean[] mask) {\n+        double[] expected = new double[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(double[] r, double[] a, int[] indexMap) {\n+        double[] expected = new double[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> DOUBLE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            DOUBLE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        double[] r = new double[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorLoadStoreTests.java","additions":154,"deletions":22,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -70,2 +70,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (Max \/ 8));\n-\n@@ -1148,30 +1146,0 @@\n-    @DataProvider\n-    public Object[][] doubleUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> DOUBLE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] doubleUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            DOUBLE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            DOUBLE_GENERATORS.stream().flatMap(fn ->\n-              DOUBLE_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4502,116 +4470,0 @@\n-    static double[] gather(double a[], int ix, int[] b, int iy) {\n-        double[] res = new double[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"doubleUnaryOpIndexProvider\")\n-    static void gatherDoubleMaxVectorTests(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, DoubleMaxVectorTests::gather);\n-    }\n-    static double[] gatherMasked(double a[], int ix, boolean[] mask, int[] b, int iy) {\n-        double[] res = new double[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"doubleUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedDoubleMaxVectorTests(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, DoubleMaxVectorTests::gatherMasked);\n-    }\n-\n-    static double[] scatter(double a[], int ix, int[] b, int iy) {\n-      double[] res = new double[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"doubleUnaryOpIndexProvider\")\n-    static void scatterDoubleMaxVectorTests(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, DoubleMaxVectorTests::scatter);\n-    }\n-\n-    static double[] scatterMasked(double r[], double a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      double[] oldVal = gather(r, ix, b, iy);\n-      double[] newVal = new double[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      double[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedDoubleMaxVectorTests(IntFunction<double[]> fa, IntFunction<double[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        double[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, DoubleMaxVectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Arrays;\n@@ -54,1 +55,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -59,2 +60,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (128 \/ 8));\n-\n@@ -192,19 +191,0 @@\n-    @DataProvider\n-    public Object[][] floatIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> FLOAT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] floatIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> FLOAT_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -965,0 +945,152 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(float[] r, float[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(float[] r, float[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (float) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (float) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(float[] r, float[] a, int[] indexMap, boolean[] mask) {\n+        float[] expected = new float[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(float[] r, float[] a, int[] indexMap) {\n+        float[] expected = new float[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> FLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            FLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorLoadStoreTests.java","additions":154,"deletions":22,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (128 \/ 8));\n-\n@@ -1153,30 +1151,0 @@\n-    @DataProvider\n-    public Object[][] floatUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> FLOAT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] floatUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            FLOAT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            FLOAT_GENERATORS.stream().flatMap(fn ->\n-              FLOAT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4465,116 +4433,0 @@\n-    static float[] gather(float a[], int ix, int[] b, int iy) {\n-        float[] res = new float[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"floatUnaryOpIndexProvider\")\n-    static void gatherFloat128VectorTests(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Float128VectorTests::gather);\n-    }\n-    static float[] gatherMasked(float a[], int ix, boolean[] mask, int[] b, int iy) {\n-        float[] res = new float[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"floatUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedFloat128VectorTests(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Float128VectorTests::gatherMasked);\n-    }\n-\n-    static float[] scatter(float a[], int ix, int[] b, int iy) {\n-      float[] res = new float[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"floatUnaryOpIndexProvider\")\n-    static void scatterFloat128VectorTests(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Float128VectorTests::scatter);\n-    }\n-\n-    static float[] scatterMasked(float r[], float a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      float[] oldVal = gather(r, ix, b, iy);\n-      float[] newVal = new float[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      float[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedFloat128VectorTests(IntFunction<float[]> fa, IntFunction<float[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        float[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Float128VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Arrays;\n@@ -54,1 +55,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -59,2 +60,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (256 \/ 8));\n-\n@@ -192,19 +191,0 @@\n-    @DataProvider\n-    public Object[][] floatIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> FLOAT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] floatIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> FLOAT_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -965,0 +945,152 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(float[] r, float[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(float[] r, float[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (float) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (float) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(float[] r, float[] a, int[] indexMap, boolean[] mask) {\n+        float[] expected = new float[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(float[] r, float[] a, int[] indexMap) {\n+        float[] expected = new float[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> FLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            FLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorLoadStoreTests.java","additions":154,"deletions":22,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (256 \/ 8));\n-\n@@ -1153,30 +1151,0 @@\n-    @DataProvider\n-    public Object[][] floatUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> FLOAT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] floatUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            FLOAT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            FLOAT_GENERATORS.stream().flatMap(fn ->\n-              FLOAT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4465,116 +4433,0 @@\n-    static float[] gather(float a[], int ix, int[] b, int iy) {\n-        float[] res = new float[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"floatUnaryOpIndexProvider\")\n-    static void gatherFloat256VectorTests(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Float256VectorTests::gather);\n-    }\n-    static float[] gatherMasked(float a[], int ix, boolean[] mask, int[] b, int iy) {\n-        float[] res = new float[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"floatUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedFloat256VectorTests(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Float256VectorTests::gatherMasked);\n-    }\n-\n-    static float[] scatter(float a[], int ix, int[] b, int iy) {\n-      float[] res = new float[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"floatUnaryOpIndexProvider\")\n-    static void scatterFloat256VectorTests(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Float256VectorTests::scatter);\n-    }\n-\n-    static float[] scatterMasked(float r[], float a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      float[] oldVal = gather(r, ix, b, iy);\n-      float[] newVal = new float[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      float[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedFloat256VectorTests(IntFunction<float[]> fa, IntFunction<float[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        float[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Float256VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Arrays;\n@@ -54,1 +55,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -59,2 +60,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (512 \/ 8));\n-\n@@ -192,19 +191,0 @@\n-    @DataProvider\n-    public Object[][] floatIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> FLOAT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] floatIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> FLOAT_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -965,0 +945,152 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(float[] r, float[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(float[] r, float[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (float) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (float) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(float[] r, float[] a, int[] indexMap, boolean[] mask) {\n+        float[] expected = new float[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(float[] r, float[] a, int[] indexMap) {\n+        float[] expected = new float[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> FLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            FLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorLoadStoreTests.java","additions":154,"deletions":22,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (512 \/ 8));\n-\n@@ -1153,30 +1151,0 @@\n-    @DataProvider\n-    public Object[][] floatUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> FLOAT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] floatUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            FLOAT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            FLOAT_GENERATORS.stream().flatMap(fn ->\n-              FLOAT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4465,116 +4433,0 @@\n-    static float[] gather(float a[], int ix, int[] b, int iy) {\n-        float[] res = new float[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"floatUnaryOpIndexProvider\")\n-    static void gatherFloat512VectorTests(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Float512VectorTests::gather);\n-    }\n-    static float[] gatherMasked(float a[], int ix, boolean[] mask, int[] b, int iy) {\n-        float[] res = new float[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"floatUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedFloat512VectorTests(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Float512VectorTests::gatherMasked);\n-    }\n-\n-    static float[] scatter(float a[], int ix, int[] b, int iy) {\n-      float[] res = new float[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"floatUnaryOpIndexProvider\")\n-    static void scatterFloat512VectorTests(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Float512VectorTests::scatter);\n-    }\n-\n-    static float[] scatterMasked(float r[], float a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      float[] oldVal = gather(r, ix, b, iy);\n-      float[] newVal = new float[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      float[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedFloat512VectorTests(IntFunction<float[]> fa, IntFunction<float[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        float[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Float512VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Arrays;\n@@ -54,1 +55,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -59,2 +60,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (64 \/ 8));\n-\n@@ -192,19 +191,0 @@\n-    @DataProvider\n-    public Object[][] floatIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> FLOAT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] floatIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> FLOAT_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -965,0 +945,152 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(float[] r, float[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(float[] r, float[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (float) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (float) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(float[] r, float[] a, int[] indexMap, boolean[] mask) {\n+        float[] expected = new float[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(float[] r, float[] a, int[] indexMap) {\n+        float[] expected = new float[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> FLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            FLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorLoadStoreTests.java","additions":154,"deletions":22,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (64 \/ 8));\n-\n@@ -1153,30 +1151,0 @@\n-    @DataProvider\n-    public Object[][] floatUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> FLOAT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] floatUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            FLOAT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            FLOAT_GENERATORS.stream().flatMap(fn ->\n-              FLOAT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4465,116 +4433,0 @@\n-    static float[] gather(float a[], int ix, int[] b, int iy) {\n-        float[] res = new float[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"floatUnaryOpIndexProvider\")\n-    static void gatherFloat64VectorTests(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Float64VectorTests::gather);\n-    }\n-    static float[] gatherMasked(float a[], int ix, boolean[] mask, int[] b, int iy) {\n-        float[] res = new float[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"floatUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedFloat64VectorTests(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Float64VectorTests::gatherMasked);\n-    }\n-\n-    static float[] scatter(float a[], int ix, int[] b, int iy) {\n-      float[] res = new float[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"floatUnaryOpIndexProvider\")\n-    static void scatterFloat64VectorTests(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Float64VectorTests::scatter);\n-    }\n-\n-    static float[] scatterMasked(float r[], float a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      float[] oldVal = gather(r, ix, b, iy);\n-      float[] newVal = new float[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      float[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedFloat64VectorTests(IntFunction<float[]> fa, IntFunction<float[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        float[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Float64VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Arrays;\n@@ -58,1 +59,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -68,2 +69,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (Max \/ 8));\n-\n@@ -201,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] floatIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> FLOAT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] floatIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> FLOAT_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -974,0 +954,152 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(float[] r, float[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(float[] r, float[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (float) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (float) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(float[] r, float[] a, int[] indexMap, boolean[] mask) {\n+        float[] expected = new float[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(float[] r, float[] a, int[] indexMap) {\n+        float[] expected = new float[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> FLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            FLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        float[] r = new float[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorLoadStoreTests.java","additions":154,"deletions":22,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -70,2 +70,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (Max \/ 8));\n-\n@@ -1158,30 +1156,0 @@\n-    @DataProvider\n-    public Object[][] floatUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> FLOAT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] floatUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            FLOAT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            FLOAT_GENERATORS.stream().flatMap(fn ->\n-              FLOAT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4470,116 +4438,0 @@\n-    static float[] gather(float a[], int ix, int[] b, int iy) {\n-        float[] res = new float[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"floatUnaryOpIndexProvider\")\n-    static void gatherFloatMaxVectorTests(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, FloatMaxVectorTests::gather);\n-    }\n-    static float[] gatherMasked(float a[], int ix, boolean[] mask, int[] b, int iy) {\n-        float[] res = new float[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"floatUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedFloatMaxVectorTests(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, FloatMaxVectorTests::gatherMasked);\n-    }\n-\n-    static float[] scatter(float a[], int ix, int[] b, int iy) {\n-      float[] res = new float[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"floatUnaryOpIndexProvider\")\n-    static void scatterFloatMaxVectorTests(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, FloatMaxVectorTests::scatter);\n-    }\n-\n-    static float[] scatterMasked(float r[], float a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      float[] oldVal = gather(r, ix, b, iy);\n-      float[] newVal = new float[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      float[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedFloatMaxVectorTests(IntFunction<float[]> fa, IntFunction<float[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        float[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, FloatMaxVectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Arrays;\n@@ -54,1 +55,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -59,2 +60,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (128 \/ 8));\n-\n@@ -192,19 +191,0 @@\n-    @DataProvider\n-    public Object[][] intIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> INT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] intIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> INT_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -965,0 +945,152 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(int[] r, int[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(int[] r, int[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (int) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (int) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(int[] r, int[] a, int[] indexMap, boolean[] mask) {\n+        int[] expected = new int[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(int[] r, int[] a, int[] indexMap) {\n+        int[] expected = new int[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> INT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            INT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorLoadStoreTests.java","additions":154,"deletions":22,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (128 \/ 8));\n-\n@@ -971,30 +969,0 @@\n-    @DataProvider\n-    public Object[][] intUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> INT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] intUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            INT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            INT_GENERATORS.stream().flatMap(fn ->\n-              INT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4890,116 +4858,0 @@\n-    static int[] gather(int a[], int ix, int[] b, int iy) {\n-        int[] res = new int[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"intUnaryOpIndexProvider\")\n-    static void gatherInt128VectorTests(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Int128VectorTests::gather);\n-    }\n-    static int[] gatherMasked(int a[], int ix, boolean[] mask, int[] b, int iy) {\n-        int[] res = new int[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"intUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedInt128VectorTests(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Int128VectorTests::gatherMasked);\n-    }\n-\n-    static int[] scatter(int a[], int ix, int[] b, int iy) {\n-      int[] res = new int[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"intUnaryOpIndexProvider\")\n-    static void scatterInt128VectorTests(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Int128VectorTests::scatter);\n-    }\n-\n-    static int[] scatterMasked(int r[], int a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      int[] oldVal = gather(r, ix, b, iy);\n-      int[] newVal = new int[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      int[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        int[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Int128VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Arrays;\n@@ -54,1 +55,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -59,2 +60,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (256 \/ 8));\n-\n@@ -192,19 +191,0 @@\n-    @DataProvider\n-    public Object[][] intIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> INT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] intIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> INT_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -965,0 +945,152 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(int[] r, int[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(int[] r, int[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (int) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (int) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(int[] r, int[] a, int[] indexMap, boolean[] mask) {\n+        int[] expected = new int[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(int[] r, int[] a, int[] indexMap) {\n+        int[] expected = new int[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> INT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            INT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorLoadStoreTests.java","additions":154,"deletions":22,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (256 \/ 8));\n-\n@@ -971,30 +969,0 @@\n-    @DataProvider\n-    public Object[][] intUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> INT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] intUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            INT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            INT_GENERATORS.stream().flatMap(fn ->\n-              INT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4890,116 +4858,0 @@\n-    static int[] gather(int a[], int ix, int[] b, int iy) {\n-        int[] res = new int[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"intUnaryOpIndexProvider\")\n-    static void gatherInt256VectorTests(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Int256VectorTests::gather);\n-    }\n-    static int[] gatherMasked(int a[], int ix, boolean[] mask, int[] b, int iy) {\n-        int[] res = new int[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"intUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedInt256VectorTests(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Int256VectorTests::gatherMasked);\n-    }\n-\n-    static int[] scatter(int a[], int ix, int[] b, int iy) {\n-      int[] res = new int[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"intUnaryOpIndexProvider\")\n-    static void scatterInt256VectorTests(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Int256VectorTests::scatter);\n-    }\n-\n-    static int[] scatterMasked(int r[], int a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      int[] oldVal = gather(r, ix, b, iy);\n-      int[] newVal = new int[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      int[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        int[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Int256VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Arrays;\n@@ -54,1 +55,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -59,2 +60,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (512 \/ 8));\n-\n@@ -192,19 +191,0 @@\n-    @DataProvider\n-    public Object[][] intIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> INT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] intIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> INT_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -965,0 +945,152 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(int[] r, int[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(int[] r, int[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (int) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (int) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(int[] r, int[] a, int[] indexMap, boolean[] mask) {\n+        int[] expected = new int[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(int[] r, int[] a, int[] indexMap) {\n+        int[] expected = new int[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> INT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            INT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorLoadStoreTests.java","additions":154,"deletions":22,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (512 \/ 8));\n-\n@@ -971,30 +969,0 @@\n-    @DataProvider\n-    public Object[][] intUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> INT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] intUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            INT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            INT_GENERATORS.stream().flatMap(fn ->\n-              INT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4890,116 +4858,0 @@\n-    static int[] gather(int a[], int ix, int[] b, int iy) {\n-        int[] res = new int[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"intUnaryOpIndexProvider\")\n-    static void gatherInt512VectorTests(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Int512VectorTests::gather);\n-    }\n-    static int[] gatherMasked(int a[], int ix, boolean[] mask, int[] b, int iy) {\n-        int[] res = new int[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"intUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedInt512VectorTests(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Int512VectorTests::gatherMasked);\n-    }\n-\n-    static int[] scatter(int a[], int ix, int[] b, int iy) {\n-      int[] res = new int[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"intUnaryOpIndexProvider\")\n-    static void scatterInt512VectorTests(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Int512VectorTests::scatter);\n-    }\n-\n-    static int[] scatterMasked(int r[], int a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      int[] oldVal = gather(r, ix, b, iy);\n-      int[] newVal = new int[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      int[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        int[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Int512VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Arrays;\n@@ -54,1 +55,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -59,2 +60,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (64 \/ 8));\n-\n@@ -192,19 +191,0 @@\n-    @DataProvider\n-    public Object[][] intIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> INT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] intIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> INT_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -965,0 +945,152 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(int[] r, int[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(int[] r, int[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (int) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (int) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(int[] r, int[] a, int[] indexMap, boolean[] mask) {\n+        int[] expected = new int[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(int[] r, int[] a, int[] indexMap) {\n+        int[] expected = new int[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> INT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            INT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorLoadStoreTests.java","additions":154,"deletions":22,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (64 \/ 8));\n-\n@@ -971,30 +969,0 @@\n-    @DataProvider\n-    public Object[][] intUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> INT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] intUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            INT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            INT_GENERATORS.stream().flatMap(fn ->\n-              INT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4890,116 +4858,0 @@\n-    static int[] gather(int a[], int ix, int[] b, int iy) {\n-        int[] res = new int[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"intUnaryOpIndexProvider\")\n-    static void gatherInt64VectorTests(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Int64VectorTests::gather);\n-    }\n-    static int[] gatherMasked(int a[], int ix, boolean[] mask, int[] b, int iy) {\n-        int[] res = new int[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"intUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedInt64VectorTests(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Int64VectorTests::gatherMasked);\n-    }\n-\n-    static int[] scatter(int a[], int ix, int[] b, int iy) {\n-      int[] res = new int[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"intUnaryOpIndexProvider\")\n-    static void scatterInt64VectorTests(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Int64VectorTests::scatter);\n-    }\n-\n-    static int[] scatterMasked(int r[], int a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      int[] oldVal = gather(r, ix, b, iy);\n-      int[] newVal = new int[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      int[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        int[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Int64VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Arrays;\n@@ -58,1 +59,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -68,2 +69,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (Max \/ 8));\n-\n@@ -201,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] intIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> INT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] intIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> INT_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -974,0 +954,152 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(int[] r, int[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(int[] r, int[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (int) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (int) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(int[] r, int[] a, int[] indexMap, boolean[] mask) {\n+        int[] expected = new int[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(int[] r, int[] a, int[] indexMap) {\n+        int[] expected = new int[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> INT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            INT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        int[] r = new int[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorLoadStoreTests.java","additions":154,"deletions":22,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -70,2 +70,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (Max \/ 8));\n-\n@@ -976,30 +974,0 @@\n-    @DataProvider\n-    public Object[][] intUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> INT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] intUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            INT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            INT_GENERATORS.stream().flatMap(fn ->\n-              INT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4895,116 +4863,0 @@\n-    static int[] gather(int a[], int ix, int[] b, int iy) {\n-        int[] res = new int[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"intUnaryOpIndexProvider\")\n-    static void gatherIntMaxVectorTests(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, IntMaxVectorTests::gather);\n-    }\n-    static int[] gatherMasked(int a[], int ix, boolean[] mask, int[] b, int iy) {\n-        int[] res = new int[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"intUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedIntMaxVectorTests(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, IntMaxVectorTests::gatherMasked);\n-    }\n-\n-    static int[] scatter(int a[], int ix, int[] b, int iy) {\n-      int[] res = new int[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"intUnaryOpIndexProvider\")\n-    static void scatterIntMaxVectorTests(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, IntMaxVectorTests::scatter);\n-    }\n-\n-    static int[] scatterMasked(int r[], int a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      int[] oldVal = gather(r, ix, b, iy);\n-      int[] newVal = new int[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      int[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        int[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, IntMaxVectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Arrays;\n@@ -54,1 +55,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -59,2 +60,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (128 \/ 8));\n-\n@@ -192,19 +191,0 @@\n-    @DataProvider\n-    public Object[][] longIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> LONG_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] longIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> LONG_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -965,0 +945,152 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(long[] r, long[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(long[] r, long[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (long) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (long) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(long[] r, long[] a, int[] indexMap, boolean[] mask) {\n+        long[] expected = new long[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(long[] r, long[] a, int[] indexMap) {\n+        long[] expected = new long[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> LONG_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            LONG_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorLoadStoreTests.java","additions":154,"deletions":22,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (128 \/ 8));\n-\n@@ -997,30 +995,0 @@\n-    @DataProvider\n-    public Object[][] longUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> LONG_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] longUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            LONG_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            LONG_GENERATORS.stream().flatMap(fn ->\n-              LONG_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4840,116 +4808,0 @@\n-    static long[] gather(long a[], int ix, int[] b, int iy) {\n-        long[] res = new long[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"longUnaryOpIndexProvider\")\n-    static void gatherLong128VectorTests(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Long128VectorTests::gather);\n-    }\n-    static long[] gatherMasked(long a[], int ix, boolean[] mask, int[] b, int iy) {\n-        long[] res = new long[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"longUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedLong128VectorTests(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Long128VectorTests::gatherMasked);\n-    }\n-\n-    static long[] scatter(long a[], int ix, int[] b, int iy) {\n-      long[] res = new long[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"longUnaryOpIndexProvider\")\n-    static void scatterLong128VectorTests(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Long128VectorTests::scatter);\n-    }\n-\n-    static long[] scatterMasked(long r[], long a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      long[] oldVal = gather(r, ix, b, iy);\n-      long[] newVal = new long[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      long[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        long[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Long128VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Arrays;\n@@ -54,1 +55,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -59,2 +60,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (256 \/ 8));\n-\n@@ -192,19 +191,0 @@\n-    @DataProvider\n-    public Object[][] longIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> LONG_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] longIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> LONG_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -965,0 +945,152 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(long[] r, long[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(long[] r, long[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (long) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (long) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(long[] r, long[] a, int[] indexMap, boolean[] mask) {\n+        long[] expected = new long[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(long[] r, long[] a, int[] indexMap) {\n+        long[] expected = new long[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> LONG_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            LONG_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorLoadStoreTests.java","additions":154,"deletions":22,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (256 \/ 8));\n-\n@@ -997,30 +995,0 @@\n-    @DataProvider\n-    public Object[][] longUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> LONG_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] longUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            LONG_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            LONG_GENERATORS.stream().flatMap(fn ->\n-              LONG_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4840,116 +4808,0 @@\n-    static long[] gather(long a[], int ix, int[] b, int iy) {\n-        long[] res = new long[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"longUnaryOpIndexProvider\")\n-    static void gatherLong256VectorTests(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Long256VectorTests::gather);\n-    }\n-    static long[] gatherMasked(long a[], int ix, boolean[] mask, int[] b, int iy) {\n-        long[] res = new long[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"longUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedLong256VectorTests(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Long256VectorTests::gatherMasked);\n-    }\n-\n-    static long[] scatter(long a[], int ix, int[] b, int iy) {\n-      long[] res = new long[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"longUnaryOpIndexProvider\")\n-    static void scatterLong256VectorTests(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Long256VectorTests::scatter);\n-    }\n-\n-    static long[] scatterMasked(long r[], long a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      long[] oldVal = gather(r, ix, b, iy);\n-      long[] newVal = new long[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      long[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        long[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Long256VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Arrays;\n@@ -54,1 +55,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -59,2 +60,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (512 \/ 8));\n-\n@@ -192,19 +191,0 @@\n-    @DataProvider\n-    public Object[][] longIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> LONG_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] longIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> LONG_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -965,0 +945,152 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(long[] r, long[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(long[] r, long[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (long) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (long) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(long[] r, long[] a, int[] indexMap, boolean[] mask) {\n+        long[] expected = new long[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(long[] r, long[] a, int[] indexMap) {\n+        long[] expected = new long[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> LONG_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            LONG_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorLoadStoreTests.java","additions":154,"deletions":22,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (512 \/ 8));\n-\n@@ -997,30 +995,0 @@\n-    @DataProvider\n-    public Object[][] longUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> LONG_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] longUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            LONG_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            LONG_GENERATORS.stream().flatMap(fn ->\n-              LONG_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4840,116 +4808,0 @@\n-    static long[] gather(long a[], int ix, int[] b, int iy) {\n-        long[] res = new long[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"longUnaryOpIndexProvider\")\n-    static void gatherLong512VectorTests(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Long512VectorTests::gather);\n-    }\n-    static long[] gatherMasked(long a[], int ix, boolean[] mask, int[] b, int iy) {\n-        long[] res = new long[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"longUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedLong512VectorTests(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Long512VectorTests::gatherMasked);\n-    }\n-\n-    static long[] scatter(long a[], int ix, int[] b, int iy) {\n-      long[] res = new long[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"longUnaryOpIndexProvider\")\n-    static void scatterLong512VectorTests(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Long512VectorTests::scatter);\n-    }\n-\n-    static long[] scatterMasked(long r[], long a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      long[] oldVal = gather(r, ix, b, iy);\n-      long[] newVal = new long[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      long[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        long[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Long512VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Arrays;\n@@ -54,1 +55,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -59,2 +60,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (64 \/ 8));\n-\n@@ -192,19 +191,0 @@\n-    @DataProvider\n-    public Object[][] longIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> LONG_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] longIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> LONG_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -965,0 +945,152 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(long[] r, long[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(long[] r, long[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (long) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (long) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(long[] r, long[] a, int[] indexMap, boolean[] mask) {\n+        long[] expected = new long[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(long[] r, long[] a, int[] indexMap) {\n+        long[] expected = new long[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> LONG_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            LONG_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorLoadStoreTests.java","additions":154,"deletions":22,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (64 \/ 8));\n-\n@@ -997,30 +995,0 @@\n-    @DataProvider\n-    public Object[][] longUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> LONG_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] longUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            LONG_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            LONG_GENERATORS.stream().flatMap(fn ->\n-              LONG_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4840,116 +4808,0 @@\n-    static long[] gather(long a[], int ix, int[] b, int iy) {\n-        long[] res = new long[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"longUnaryOpIndexProvider\")\n-    static void gatherLong64VectorTests(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Long64VectorTests::gather);\n-    }\n-    static long[] gatherMasked(long a[], int ix, boolean[] mask, int[] b, int iy) {\n-        long[] res = new long[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"longUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedLong64VectorTests(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Long64VectorTests::gatherMasked);\n-    }\n-\n-    static long[] scatter(long a[], int ix, int[] b, int iy) {\n-      long[] res = new long[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"longUnaryOpIndexProvider\")\n-    static void scatterLong64VectorTests(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Long64VectorTests::scatter);\n-    }\n-\n-    static long[] scatterMasked(long r[], long a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      long[] oldVal = gather(r, ix, b, iy);\n-      long[] newVal = new long[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      long[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        long[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Long64VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Arrays;\n@@ -58,1 +59,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -68,2 +69,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (Max \/ 8));\n-\n@@ -201,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] longIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> LONG_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] longIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> LONG_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -974,0 +954,152 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(long[] r, long[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(long[] r, long[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (long) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (long) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(long[] r, long[] a, int[] indexMap, boolean[] mask) {\n+        long[] expected = new long[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(long[] r, long[] a, int[] indexMap) {\n+        long[] expected = new long[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> LONG_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            LONG_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        long[] r = new long[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorLoadStoreTests.java","additions":154,"deletions":22,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -70,2 +70,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (Max \/ 8));\n-\n@@ -1002,30 +1000,0 @@\n-    @DataProvider\n-    public Object[][] longUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> LONG_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] longUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            LONG_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            LONG_GENERATORS.stream().flatMap(fn ->\n-              LONG_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4845,116 +4813,0 @@\n-    static long[] gather(long a[], int ix, int[] b, int iy) {\n-        long[] res = new long[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"longUnaryOpIndexProvider\")\n-    static void gatherLongMaxVectorTests(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, LongMaxVectorTests::gather);\n-    }\n-    static long[] gatherMasked(long a[], int ix, boolean[] mask, int[] b, int iy) {\n-        long[] res = new long[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"longUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedLongMaxVectorTests(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, LongMaxVectorTests::gatherMasked);\n-    }\n-\n-    static long[] scatter(long a[], int ix, int[] b, int iy) {\n-      long[] res = new long[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"longUnaryOpIndexProvider\")\n-    static void scatterLongMaxVectorTests(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, LongMaxVectorTests::scatter);\n-    }\n-\n-    static long[] scatterMasked(long r[], long a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      long[] oldVal = gather(r, ix, b, iy);\n-      long[] newVal = new long[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      long[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        long[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, LongMaxVectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Arrays;\n@@ -54,1 +55,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -59,2 +60,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (128 \/ 8));\n-\n@@ -192,19 +191,0 @@\n-    @DataProvider\n-    public Object[][] shortIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> SHORT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] shortIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> SHORT_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -1209,0 +1189,297 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+    static void assertGatherArraysEquals(char[] r, char[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(char[] r, char[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (char) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (char) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(char[] r, char[] a, int[] indexMap, boolean[] mask) {\n+        char[] expected = new char[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(char[] r, char[] a, int[] indexMap) {\n+        char[] expected = new char[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charGatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charGatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"charGatherScatterProvider\")\n+    static void charGather(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, b, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterMaskProvider\")\n+    static void charGatherMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, b, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterProvider\")\n+    static void charScatter(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterMaskProvider\")\n+    static void charScatterMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorLoadStoreTests.java","additions":299,"deletions":22,"binary":false,"changes":321,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (128 \/ 8));\n-\n@@ -1001,30 +999,0 @@\n-    @DataProvider\n-    public Object[][] shortUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] shortUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            SHORT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            SHORT_GENERATORS.stream().flatMap(fn ->\n-              SHORT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4915,116 +4883,0 @@\n-    static short[] gather(short a[], int ix, int[] b, int iy) {\n-        short[] res = new short[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"shortUnaryOpIndexProvider\")\n-    static void gatherShort128VectorTests(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Short128VectorTests::gather);\n-    }\n-    static short[] gatherMasked(short a[], int ix, boolean[] mask, int[] b, int iy) {\n-        short[] res = new short[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"shortUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedShort128VectorTests(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Short128VectorTests::gatherMasked);\n-    }\n-\n-    static short[] scatter(short a[], int ix, int[] b, int iy) {\n-      short[] res = new short[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"shortUnaryOpIndexProvider\")\n-    static void scatterShort128VectorTests(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Short128VectorTests::scatter);\n-    }\n-\n-    static short[] scatterMasked(short r[], short a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      short[] oldVal = gather(r, ix, b, iy);\n-      short[] newVal = new short[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      short[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        short[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Short128VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Arrays;\n@@ -54,1 +55,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -59,2 +60,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (256 \/ 8));\n-\n@@ -192,19 +191,0 @@\n-    @DataProvider\n-    public Object[][] shortIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> SHORT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] shortIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> SHORT_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -1209,0 +1189,297 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+    static void assertGatherArraysEquals(char[] r, char[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(char[] r, char[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (char) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (char) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(char[] r, char[] a, int[] indexMap, boolean[] mask) {\n+        char[] expected = new char[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(char[] r, char[] a, int[] indexMap) {\n+        char[] expected = new char[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charGatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charGatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"charGatherScatterProvider\")\n+    static void charGather(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, b, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterMaskProvider\")\n+    static void charGatherMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, b, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterProvider\")\n+    static void charScatter(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterMaskProvider\")\n+    static void charScatterMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorLoadStoreTests.java","additions":299,"deletions":22,"binary":false,"changes":321,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (256 \/ 8));\n-\n@@ -1001,30 +999,0 @@\n-    @DataProvider\n-    public Object[][] shortUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] shortUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            SHORT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            SHORT_GENERATORS.stream().flatMap(fn ->\n-              SHORT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4915,116 +4883,0 @@\n-    static short[] gather(short a[], int ix, int[] b, int iy) {\n-        short[] res = new short[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"shortUnaryOpIndexProvider\")\n-    static void gatherShort256VectorTests(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Short256VectorTests::gather);\n-    }\n-    static short[] gatherMasked(short a[], int ix, boolean[] mask, int[] b, int iy) {\n-        short[] res = new short[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"shortUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedShort256VectorTests(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Short256VectorTests::gatherMasked);\n-    }\n-\n-    static short[] scatter(short a[], int ix, int[] b, int iy) {\n-      short[] res = new short[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"shortUnaryOpIndexProvider\")\n-    static void scatterShort256VectorTests(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Short256VectorTests::scatter);\n-    }\n-\n-    static short[] scatterMasked(short r[], short a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      short[] oldVal = gather(r, ix, b, iy);\n-      short[] newVal = new short[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      short[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        short[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Short256VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Arrays;\n@@ -54,1 +55,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -59,2 +60,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (512 \/ 8));\n-\n@@ -192,19 +191,0 @@\n-    @DataProvider\n-    public Object[][] shortIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> SHORT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] shortIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> SHORT_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -1209,0 +1189,297 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+    static void assertGatherArraysEquals(char[] r, char[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(char[] r, char[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (char) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (char) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(char[] r, char[] a, int[] indexMap, boolean[] mask) {\n+        char[] expected = new char[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(char[] r, char[] a, int[] indexMap) {\n+        char[] expected = new char[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charGatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charGatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"charGatherScatterProvider\")\n+    static void charGather(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, b, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterMaskProvider\")\n+    static void charGatherMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, b, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterProvider\")\n+    static void charScatter(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterMaskProvider\")\n+    static void charScatterMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorLoadStoreTests.java","additions":299,"deletions":22,"binary":false,"changes":321,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (512 \/ 8));\n-\n@@ -1001,30 +999,0 @@\n-    @DataProvider\n-    public Object[][] shortUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] shortUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            SHORT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            SHORT_GENERATORS.stream().flatMap(fn ->\n-              SHORT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4915,116 +4883,0 @@\n-    static short[] gather(short a[], int ix, int[] b, int iy) {\n-        short[] res = new short[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"shortUnaryOpIndexProvider\")\n-    static void gatherShort512VectorTests(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Short512VectorTests::gather);\n-    }\n-    static short[] gatherMasked(short a[], int ix, boolean[] mask, int[] b, int iy) {\n-        short[] res = new short[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"shortUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedShort512VectorTests(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Short512VectorTests::gatherMasked);\n-    }\n-\n-    static short[] scatter(short a[], int ix, int[] b, int iy) {\n-      short[] res = new short[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"shortUnaryOpIndexProvider\")\n-    static void scatterShort512VectorTests(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Short512VectorTests::scatter);\n-    }\n-\n-    static short[] scatterMasked(short r[], short a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      short[] oldVal = gather(r, ix, b, iy);\n-      short[] newVal = new short[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      short[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        short[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Short512VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Arrays;\n@@ -54,1 +55,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -59,2 +60,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (64 \/ 8));\n-\n@@ -192,19 +191,0 @@\n-    @DataProvider\n-    public Object[][] shortIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> SHORT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] shortIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> SHORT_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -1209,0 +1189,297 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+    static void assertGatherArraysEquals(char[] r, char[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(char[] r, char[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (char) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (char) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(char[] r, char[] a, int[] indexMap, boolean[] mask) {\n+        char[] expected = new char[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(char[] r, char[] a, int[] indexMap) {\n+        char[] expected = new char[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charGatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charGatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"charGatherScatterProvider\")\n+    static void charGather(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, b, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterMaskProvider\")\n+    static void charGatherMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, b, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterProvider\")\n+    static void charScatter(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterMaskProvider\")\n+    static void charScatterMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorLoadStoreTests.java","additions":299,"deletions":22,"binary":false,"changes":321,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (64 \/ 8));\n-\n@@ -1001,30 +999,0 @@\n-    @DataProvider\n-    public Object[][] shortUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] shortUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            SHORT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            SHORT_GENERATORS.stream().flatMap(fn ->\n-              SHORT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4915,116 +4883,0 @@\n-    static short[] gather(short a[], int ix, int[] b, int iy) {\n-        short[] res = new short[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"shortUnaryOpIndexProvider\")\n-    static void gatherShort64VectorTests(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Short64VectorTests::gather);\n-    }\n-    static short[] gatherMasked(short a[], int ix, boolean[] mask, int[] b, int iy) {\n-        short[] res = new short[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"shortUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedShort64VectorTests(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Short64VectorTests::gatherMasked);\n-    }\n-\n-    static short[] scatter(short a[], int ix, int[] b, int iy) {\n-      short[] res = new short[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"shortUnaryOpIndexProvider\")\n-    static void scatterShort64VectorTests(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, Short64VectorTests::scatter);\n-    }\n-\n-    static short[] scatterMasked(short r[], short a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      short[] oldVal = gather(r, ix, b, iy);\n-      short[] newVal = new short[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      short[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        short[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, Short64VectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Arrays;\n@@ -58,1 +59,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -68,2 +69,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (Max \/ 8));\n-\n@@ -201,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] shortIndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> SHORT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] shortIndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> SHORT_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -1218,0 +1198,297 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+    static void assertGatherArraysEquals(char[] r, char[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(char[] r, char[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (char) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (char) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(char[] r, char[] a, int[] indexMap, boolean[] mask) {\n+        char[] expected = new char[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(char[] r, char[] a, int[] indexMap) {\n+        char[] expected = new char[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charGatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charGatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"charGatherScatterProvider\")\n+    static void charGather(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, b, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterMaskProvider\")\n+    static void charGatherMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, b, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterProvider\")\n+    static void charScatter(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterMaskProvider\")\n+    static void charScatterMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorLoadStoreTests.java","additions":299,"deletions":22,"binary":false,"changes":321,"status":"modified"},{"patch":"@@ -70,2 +70,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * (Max \/ 8));\n-\n@@ -1006,30 +1004,0 @@\n-    @DataProvider\n-    public Object[][] shortUnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] shortUnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            SHORT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            SHORT_GENERATORS.stream().flatMap(fn ->\n-              SHORT_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n@@ -4920,116 +4888,0 @@\n-    static short[] gather(short a[], int ix, int[] b, int iy) {\n-        short[] res = new short[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"shortUnaryOpIndexProvider\")\n-    static void gatherShortMaxVectorTests(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, ShortMaxVectorTests::gather);\n-    }\n-    static short[] gatherMasked(short a[], int ix, boolean[] mask, int[] b, int iy) {\n-        short[] res = new short[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"shortUnaryMaskedOpIndexProvider\")\n-    static void gatherMaskedShortMaxVectorTests(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, ShortMaxVectorTests::gatherMasked);\n-    }\n-\n-    static short[] scatter(short a[], int ix, int[] b, int iy) {\n-      short[] res = new short[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"shortUnaryOpIndexProvider\")\n-    static void scatterShortMaxVectorTests(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, ShortMaxVectorTests::scatter);\n-    }\n-\n-    static short[] scatterMasked(short r[], short a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      short[] oldVal = gather(r, ix, b, iy);\n-      short[] newVal = new short[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      short[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void scatterMaskedShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        short[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n-\n-        assertArraysEquals(r, a, b, mask, ShortMaxVectorTests::scatterMasked);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -77,4 +77,0 @@\n-gather_template=\"Gather-op\"\n-gather_masked_template=\"Gather-Masked-op\"\n-scatter_template=\"Scatter-op\"\n-scatter_masked_template=\"Scatter-Masked-op\"\n@@ -561,6 +557,0 @@\n-# Gather Scatter operations.\n-gen_op_tmpl $gather_template \"gather\" \"\"\n-gen_op_tmpl $gather_masked_template \"gather\" \"\"\n-gen_op_tmpl $scatter_template \"scatter\" \"\"\n-gen_op_tmpl $scatter_masked_template \"scatter\" \"\"\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,12 +0,0 @@\n-        $type$[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        $type$[] r = new $type$[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n-            }\n-        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Gather-Masked-op.template","additions":0,"deletions":12,"binary":false,"changes":12,"status":"deleted"},{"patch":"@@ -1,10 +0,0 @@\n-        $type$[] a = fa.apply(SPECIES.length());\n-        int[] b    = fs.apply(a.length, SPECIES.length());\n-        $type$[] r = new $type$[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n-            }\n-        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Gather-op.template","additions":0,"deletions":10,"binary":false,"changes":10,"status":"deleted"},{"patch":"@@ -1,12 +0,0 @@\n-        $type$[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        $type$[] r = fb.apply(SPECIES.length());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n-            }\n-        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Scatter-Masked-op.template","additions":0,"deletions":12,"binary":false,"changes":12,"status":"deleted"},{"patch":"@@ -1,10 +0,0 @@\n-        $type$[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        $type$[] r = new $type$[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n-            }\n-        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Scatter-op.template","additions":0,"deletions":10,"binary":false,"changes":10,"status":"deleted"},{"patch":"@@ -1,17 +0,0 @@\n-    static $type$[] [[TEST]][[TEST_TYPE]]($type$ a[], int ix, boolean[] mask, int[] b, int iy) {\n-        $type$[] res = new $type$[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            if (mask[i]) {\n-              res[i] = a[b[bi] + ix];\n-            }\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"$type$UnaryMaskedOpIndexProvider\")\n-    static void [[TEST]][[TEST_TYPE]]$vectorteststype$(IntFunction<$type$[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-[[KERNEL]]\n-        assertArraysEquals(r, a, b, mask, $vectorteststype$::[[TEST]][[TEST_TYPE]]);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Gather-Masked-op.template","additions":0,"deletions":17,"binary":false,"changes":17,"status":"deleted"},{"patch":"@@ -1,14 +0,0 @@\n-    static $type$[] [[TEST]]($type$ a[], int ix, int[] b, int iy) {\n-        $type$[] res = new $type$[SPECIES.length()];\n-        for (int i = 0; i < SPECIES.length(); i++) {\n-            int bi = iy + i;\n-            res[i] = a[b[bi] + ix];\n-        }\n-        return res;\n-    }\n-\n-    @Test(dataProvider = \"$type$UnaryOpIndexProvider\")\n-    static void [[TEST]]$vectorteststype$(IntFunction<$type$[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-[[KERNEL]]\n-        assertArraysEquals(r, a, b, $vectorteststype$::[[TEST]]);\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Gather-op.template","additions":0,"deletions":14,"binary":false,"changes":14,"status":"deleted"},{"patch":"@@ -1,26 +0,0 @@\n-    static $type$[] [[TEST]][[TEST_TYPE]]($type$ r[], $type$ a[], int ix, boolean[] mask, int[] b, int iy) {\n-      \/\/ First, gather r.\n-      $type$[] oldVal = gather(r, ix, b, iy);\n-      $type$[] newVal = new $type$[SPECIES.length()];\n-\n-      \/\/ Second, blending it with a.\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        newVal[i] = blend(oldVal[i], a[i+ix], mask[i]);\n-      }\n-\n-      \/\/ Third, scatter: copy old value of r, and scatter it manually.\n-      $type$[] res = Arrays.copyOfRange(r, ix, ix+SPECIES.length());\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = newVal[i];\n-      }\n-\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"scatterMaskedOpIndexProvider\")\n-    static void [[TEST]][[TEST_TYPE]]$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-[[KERNEL]]\n-        assertArraysEquals(r, a, b, mask, $vectorteststype$::[[TEST]][[TEST_TYPE]]);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Scatter-Masked-op.template","additions":0,"deletions":26,"binary":false,"changes":26,"status":"deleted"},{"patch":"@@ -1,15 +0,0 @@\n-    static $type$[] [[TEST]]($type$ a[], int ix, int[] b, int iy) {\n-      $type$[] res = new $type$[SPECIES.length()];\n-      for (int i = 0; i < SPECIES.length(); i++) {\n-        int bi = iy + i;\n-        res[b[bi]] = a[i + ix];\n-      }\n-      return res;\n-    }\n-\n-    @Test(dataProvider = \"$type$UnaryOpIndexProvider\")\n-    static void [[TEST]]$vectorteststype$(IntFunction<$type$[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-[[KERNEL]]\n-        assertArraysEquals(r, a, b, $vectorteststype$::[[TEST]]);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Scatter-op.template","additions":0,"deletions":15,"binary":false,"changes":15,"status":"deleted"},{"patch":"@@ -94,2 +94,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * ($bits$ \/ 8));\n-\n@@ -1220,30 +1218,0 @@\n-    @DataProvider\n-    public Object[][] $type$UnaryOpIndexProvider() {\n-        return INT_INDEX_GENERATORS.stream().\n-                flatMap(fs -> $TYPE$_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fs};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] $type$UnaryMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            $TYPE$_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fm, fs};\n-            }))).\n-            toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] scatterMaskedOpIndexProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n-            $TYPE$_GENERATORS.stream().flatMap(fn ->\n-              $TYPE$_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fn, fm, fs};\n-            })))).\n-            toArray(Object[][]::new);\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+import java.util.Arrays;\n@@ -73,1 +74,1 @@\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 10);\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n@@ -85,2 +86,0 @@\n-    static final int BUFFER_SIZE = Integer.getInteger(\"jdk.incubator.vector.test.buffer-size\", BUFFER_REPS * ($bits$ \/ 8));\n-\n@@ -220,19 +219,0 @@\n-    @DataProvider\n-    public Object[][] $type$IndexMapProvider() {\n-        return INDEX_GENERATORS.stream().\n-                flatMap(fim -> $TYPE$_GENERATORS.stream().map(fa -> {\n-                    return new Object[] {fa, fim};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] $type$IndexMapMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INDEX_GENERATORS.stream().\n-                    flatMap(fim -> $TYPE$_GENERATORS.stream().map(fa -> {\n-                        return new Object[] {fa, fim, fm};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -1332,0 +1312,426 @@\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals($type$[] r, $type$[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals($type$[] r, $type$[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: ($type$) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: ($type$) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals($type$[] r, $type$[] a, int[] indexMap, boolean[] mask) {\n+        $type$[] expected = new $type$[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals($type$[] r, $type$[] a, int[] indexMap) {\n+        $type$[] expected = new $type$[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> $TYPE$_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            $TYPE$_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<$type$[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        $type$[] r = new $type$[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<$type$[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        $type$[] r = new $type$[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<$type$[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        $type$[] r = new $type$[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<$type$[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        $type$[] r = new $type$[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+#if[short]\n+    static void assertGatherArraysEquals(char[] r, char[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(char[] r, char[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (char) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (char) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(char[] r, char[] a, int[] indexMap, boolean[] mask) {\n+        char[] expected = new char[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(char[] r, char[] a, int[] indexMap) {\n+        char[] expected = new char[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charGatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charGatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"charGatherScatterProvider\")\n+    static void charGather(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, i, b, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterMaskProvider\")\n+    static void charGatherMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, i, b, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterProvider\")\n+    static void charScatter(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterMaskProvider\")\n+    static void charScatterMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+#end[short]\n+\n+#if[byte]\n+    static void assertGatherArraysEquals(boolean[] r, boolean[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(boolean[] r, boolean[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: false);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: false, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(boolean[] r, boolean[] a, int[] indexMap, boolean[] mask) {\n+        boolean[] expected = new boolean[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(boolean[] r, boolean[] a, int[] indexMap) {\n+        boolean[] expected = new boolean[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void booleanGather(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromBooleanArray(SPECIES, a, i, b, i);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void booleanGatherMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromBooleanArray(SPECIES, a, i, b, i, vmask);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void booleanScatter(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void booleanScatterMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+#end[byte]\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/X-LoadStoreTest.java.template","additions":428,"deletions":22,"binary":false,"changes":450,"status":"modified"}]}