{"files":[{"patch":"@@ -107,0 +107,7 @@\n+  \/\/ Variant for cases where access strength needs to be resolved at run-time.\n+  template <class T>\n+  inline oop load_reference_barrier(DecoratorSet decorators, oop obj, T* load_addr);\n+\n+  template <typename T>\n+  inline oop cmpxchg_barrier(T* addr, oop compare_value, oop new_value) const;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -139,0 +139,31 @@\n+template <class T>\n+inline oop ShenandoahBarrierSet::load_reference_barrier(DecoratorSet decorators, oop obj, T* load_addr) {\n+  assert((decorators & ON_UNKNOWN_OOP_REF) != 0, \"no unknown accesses\");\n+\n+  if (obj == NULL) {\n+    return NULL;\n+  }\n+\n+  \/\/ Prevent resurrection of unreachable phantom (i.e. weak-native) references.\n+  if ((decorators & ON_PHANTOM_OOP_REF) != 0 &&\n+      _heap->is_concurrent_weak_root_in_progress() &&\n+      !_heap->marking_context()->is_marked(obj)) {\n+    return NULL;\n+  }\n+\n+  \/\/ Prevent resurrection of unreachable weak references.\n+  if ((decorators & ON_WEAK_OOP_REF) != 0 &&\n+      _heap->is_concurrent_weak_root_in_progress() &&\n+      !_heap->marking_context()->is_marked_strong(obj)) {\n+    return NULL;\n+  }\n+\n+  oop fwd = load_reference_barrier(obj);\n+  if (ShenandoahSelfFixing && load_addr != NULL && fwd != obj) {\n+    \/\/ Since we are here and we know the load address, update the reference.\n+    ShenandoahHeap::cas_oop(fwd, load_addr, obj);\n+  }\n+\n+  return fwd;\n+}\n+\n@@ -223,1 +254,1 @@\n-  value = bs->load_reference_barrier<decorators>(value, AccessInternal::oop_field_addr<decorators>(base, offset));\n+  value = bs->load_reference_barrier(resolved_decorators, value, AccessInternal::oop_field_addr<decorators>(base, offset));\n@@ -254,1 +285,0 @@\n-template <DecoratorSet decorators, typename BarrierSetT>\n@@ -256,4 +286,1 @@\n-inline oop ShenandoahBarrierSet::AccessBarrier<decorators, BarrierSetT>::oop_atomic_cmpxchg_not_in_heap(T* addr, oop compare_value, oop new_value) {\n-  ShenandoahBarrierSet* bs = ShenandoahBarrierSet::barrier_set();\n-  bs->iu_barrier(new_value);\n-\n+inline oop ShenandoahBarrierSet::cmpxchg_barrier(T* addr, oop compare_value, oop new_value) const {\n@@ -264,1 +291,1 @@\n-    res = Raw::oop_atomic_cmpxchg(addr, compare_value, new_value);\n+    res = RawAccess<>::oop_atomic_cmpxchg(addr, compare_value, new_value);\n@@ -267,0 +294,10 @@\n+  return res;\n+}\n+\n+template <DecoratorSet decorators, typename BarrierSetT>\n+template <typename T>\n+inline oop ShenandoahBarrierSet::AccessBarrier<decorators, BarrierSetT>::oop_atomic_cmpxchg_not_in_heap(T* addr, oop compare_value, oop new_value) {\n+  ShenandoahBarrierSet* bs = ShenandoahBarrierSet::barrier_set();\n+  bs->iu_barrier(new_value);\n+\n+  oop res = bs->cmpxchg_barrier(addr, compare_value, new_value);\n@@ -270,1 +307,1 @@\n-  res = ShenandoahBarrierSet::barrier_set()->load_reference_barrier<decorators & ~ON_UNKNOWN_OOP_REF, T>(res, NULL);\n+  res = ShenandoahBarrierSet::barrier_set()->load_reference_barrier<decorators, T>(res, NULL);\n@@ -283,1 +320,11 @@\n-  return oop_atomic_cmpxchg_in_heap(AccessInternal::oop_field_addr<decorators>(base, offset), compare_value, new_value);\n+  ShenandoahBarrierSet* bs = ShenandoahBarrierSet::barrier_set();\n+  bs->iu_barrier(new_value);\n+\n+  oop res = bs->cmpxchg_barrier(AccessInternal::oop_field_addr<decorators>(base, offset), compare_value, new_value);\n+\n+  \/\/ Note: We don't need a keep-alive-barrier here. We already enqueue any loaded reference for SATB anyway,\n+  \/\/ because it must be the previous value.\n+  DecoratorSet resolved_decorators = AccessBarrierSupport::resolve_possibly_unknown_oop_ref_strength<decorators>(base, offset);\n+  res = ShenandoahBarrierSet::barrier_set()->load_reference_barrier(resolved_decorators, res, reinterpret_cast<typename HeapOopType<decorators>::type*>(NULL));\n+  bs->satb_enqueue(res);\n+  return res;\n@@ -309,1 +356,11 @@\n-  return oop_atomic_xchg_in_heap(AccessInternal::oop_field_addr<decorators>(base, offset), new_value);\n+  ShenandoahBarrierSet* bs = ShenandoahBarrierSet::barrier_set();\n+  bs->iu_barrier(new_value);\n+\n+  oop previous = Raw::oop_atomic_xchg(AccessInternal::oop_field_addr<decorators>(base, offset), new_value);\n+\n+  \/\/ Note: We don't need a keep-alive-barrier here. We already enqueue any loaded reference for SATB anyway,\n+  \/\/ because it must be the previous value.\n+  DecoratorSet resolved_decorators = AccessBarrierSupport::resolve_possibly_unknown_oop_ref_strength<decorators>(base, offset);\n+  previous = ShenandoahBarrierSet::barrier_set()->load_reference_barrier(previous, reinterpret_cast<typename HeapOopType<decorators>::type*>(NULL));\n+  bs->satb_enqueue(previous);\n+  return previous;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":67,"deletions":10,"binary":false,"changes":77,"status":"modified"}]}