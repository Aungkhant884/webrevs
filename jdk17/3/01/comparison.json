{"files":[{"patch":"@@ -438,4 +438,17 @@\n-        if (params != null) {\n-            if (params instanceof IvParameterSpec) {\n-                ivBytes = ((IvParameterSpec) params).getIV();\n-                if ((ivBytes == null) || (ivBytes.length != blockSize)) {\n+        try {\n+            if (params != null) {\n+                if (params instanceof IvParameterSpec) {\n+                    ivBytes = ((IvParameterSpec) params).getIV();\n+                    if ((ivBytes == null) || (ivBytes.length != blockSize)) {\n+                        throw new InvalidAlgorithmParameterException\n+                                (\"Wrong IV length: must be \" + blockSize +\n+                                        \" bytes long\");\n+                    }\n+                } else if (params instanceof RC2ParameterSpec) {\n+                    ivBytes = ((RC2ParameterSpec) params).getIV();\n+                    if ((ivBytes != null) && (ivBytes.length != blockSize)) {\n+                        throw new InvalidAlgorithmParameterException\n+                                (\"Wrong IV length: must be \" + blockSize +\n+                                        \" bytes long\");\n+                    }\n+                } else {\n@@ -443,2 +456,1 @@\n-                        (\"Wrong IV length: must be \" + blockSize +\n-                            \" bytes long\");\n+                            (\"Unsupported parameter: \" + params);\n@@ -446,3 +458,3 @@\n-            } else if (params instanceof RC2ParameterSpec) {\n-                ivBytes = ((RC2ParameterSpec) params).getIV();\n-                if ((ivBytes != null) && (ivBytes.length != blockSize)) {\n+            }\n+            if (cipherMode == ECB_MODE) {\n+                if (ivBytes != null) {\n@@ -450,2 +462,6 @@\n-                        (\"Wrong IV length: must be \" + blockSize +\n-                            \" bytes long\");\n+                            (\"ECB mode cannot use IV\");\n+                }\n+            } else if (ivBytes == null) {\n+                if (decrypting) {\n+                    throw new InvalidAlgorithmParameterException(\"Parameters \"\n+                            + \"missing\");\n@@ -453,15 +469,0 @@\n-            } else {\n-                throw new InvalidAlgorithmParameterException\n-                    (\"Unsupported parameter: \" + params);\n-            }\n-        }\n-        if (cipherMode == ECB_MODE) {\n-            if (ivBytes != null) {\n-                throw new InvalidAlgorithmParameterException\n-                    (\"ECB mode cannot use IV\");\n-            }\n-        } else if (ivBytes == null) {\n-            if (decrypting) {\n-                throw new InvalidAlgorithmParameterException(\"Parameters \"\n-                    + \"missing\");\n-            }\n@@ -469,3 +470,3 @@\n-            if (random == null) {\n-                random = SunJCE.getRandom();\n-            }\n+                if (random == null) {\n+                    random = SunJCE.getRandom();\n+                }\n@@ -473,3 +474,3 @@\n-            ivBytes = new byte[blockSize];\n-            random.nextBytes(ivBytes);\n-        }\n+                ivBytes = new byte[blockSize];\n+                random.nextBytes(ivBytes);\n+            }\n@@ -477,2 +478,2 @@\n-        buffered = 0;\n-        diffBlocksize = blockSize;\n+            buffered = 0;\n+            diffBlocksize = blockSize;\n@@ -480,2 +481,5 @@\n-        String algorithm = key.getAlgorithm();\n-        cipher.init(decrypting, algorithm, keyBytes, ivBytes);\n+            String algorithm = key.getAlgorithm();\n+            cipher.init(decrypting, algorithm, keyBytes, ivBytes);\n+        } finally {\n+            Arrays.fill(keyBytes, (byte)0);\n+        }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/CipherCore.java","additions":40,"deletions":36,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.access.SharedSecrets;\n+\n@@ -51,9 +53,1 @@\n-    \/**\n-     * Construct a public key from its encoding.\n-     *\n-     * @param encodedKey the encoding of a public key.\n-     *\n-     * @param encodedKeyAlgorithm the algorithm the encodedKey is for.\n-     *\n-     * @return a public key constructed from the encodedKey.\n-     *\/\n+\n@@ -61,1 +55,1 @@\n-            String encodedKeyAlgorithm)\n+            int ofs, int len, String encodedKeyAlgorithm)\n@@ -64,0 +58,3 @@\n+        byte[] keyBytes = (ofs == 0 && encodedKey.length == len)\n+                ? encodedKey : Arrays.copyOfRange(encodedKey, ofs, ofs + len);\n+        X509EncodedKeySpec keySpec = new X509EncodedKeySpec(keyBytes);\n@@ -68,1 +65,0 @@\n-            X509EncodedKeySpec keySpec = new X509EncodedKeySpec(encodedKey);\n@@ -76,2 +72,0 @@\n-                X509EncodedKeySpec keySpec =\n-                    new X509EncodedKeySpec(encodedKey);\n@@ -100,9 +94,0 @@\n-    \/**\n-     * Construct a private key from its encoding.\n-     *\n-     * @param encodedKey the encoding of a private key.\n-     *\n-     * @param encodedKeyAlgorithm the algorithm the wrapped key is for.\n-     *\n-     * @return a private key constructed from the encodedKey.\n-     *\/\n@@ -110,1 +95,1 @@\n-            String encodedKeyAlgorithm)\n+            int ofs, int len, String encodedKeyAlgorithm)\n@@ -113,1 +98,3 @@\n-\n+        byte[] keyBytes = (ofs == 0 && encodedKey.length == len)\n+                ? encodedKey : Arrays.copyOfRange(encodedKey, ofs, ofs + len);\n+        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(keyBytes);\n@@ -118,1 +105,0 @@\n-            PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(encodedKey);\n@@ -126,2 +112,0 @@\n-                PKCS8EncodedKeySpec keySpec =\n-                    new PKCS8EncodedKeySpec(encodedKey);\n@@ -145,0 +129,5 @@\n+        } finally {\n+            SharedSecrets.getJavaSecuritySpecAccess().clearEncodedKeySpec(keySpec);\n+            if (keyBytes != encodedKey) {\n+                Arrays.fill(keyBytes, (byte)0);\n+            }\n@@ -150,9 +139,0 @@\n-    \/**\n-     * Construct a secret key from its encoding.\n-     *\n-     * @param encodedKey the encoding of a secret key.\n-     *\n-     * @param encodedKeyAlgorithm the algorithm the secret key is for.\n-     *\n-     * @return a secret key constructed from the encodedKey.\n-     *\/\n@@ -173,30 +153,9 @@\n-        switch (keyType) {\n-        case Cipher.SECRET_KEY:\n-            try {\n-                return ConstructKeys.constructSecretKey(encoding, ofs, len,\n-                        keyAlgorithm);\n-            } finally {\n-                Arrays.fill(encoding, ofs, len, (byte)0);\n-            }\n-        case Cipher.PRIVATE_KEY:\n-            byte[] encoding2 = encoding;\n-            try {\n-                if (ofs != 0 || len != encoding.length) {\n-                    encoding2 = Arrays.copyOfRange(encoding, ofs, ofs + len);\n-                }\n-                return ConstructKeys.constructPrivateKey(encoding2,\n-                        keyAlgorithm);\n-            } finally {\n-                Arrays.fill(encoding, ofs, len, (byte)0);\n-                if (encoding2 != encoding) {\n-                    Arrays.fill(encoding2, (byte)0);\n-                }\n-            }\n-        case Cipher.PUBLIC_KEY:\n-            if (ofs != 0 || len != encoding.length) {\n-                encoding = Arrays.copyOfRange(encoding, ofs, ofs + len);\n-            }\n-            return ConstructKeys.constructPublicKey(encoding, keyAlgorithm);\n-        default:\n-            throw new NoSuchAlgorithmException(\"Unsupported key type\");\n-        }\n+        return switch (keyType) {\n+            case Cipher.SECRET_KEY -> ConstructKeys.constructSecretKey(\n+                    encoding, ofs, len, keyAlgorithm);\n+            case Cipher.PRIVATE_KEY -> ConstructKeys.constructPrivateKey(\n+                    encoding, ofs, len, keyAlgorithm);\n+            case Cipher.PUBLIC_KEY -> ConstructKeys.constructPublicKey(\n+                    encoding, ofs, len, keyAlgorithm);\n+            default -> throw new NoSuchAlgorithmException(\"Unsupported key type\");\n+        };\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ConstructKeys.java","additions":25,"deletions":66,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -166,1 +166,7 @@\n-        blockCipher.init(false, key.getAlgorithm(), keyValue);\n+        try {\n+            blockCipher.init(false, key.getAlgorithm(), keyValue);\n+        } finally {\n+            if (!encryption) {\n+                Arrays.fill(keyValue, (byte) 0);\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GaloisCounterMode.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -127,0 +127,1 @@\n+        Arrays.fill(buffer, (byte)0);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/KWUtil.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -475,1 +475,5 @@\n-                return Arrays.copyOf(out, outLen);\n+                try {\n+                    return Arrays.copyOf(out, outLen);\n+                } finally {\n+                    Arrays.fill(out, (byte)0);\n+                }\n@@ -532,0 +536,3 @@\n+            if (dataBuf != null) {\n+                Arrays.fill(dataBuf, (byte)0);\n+            }\n@@ -562,2 +569,8 @@\n-        return (opmode == Cipher.ENCRYPT_MODE?\n-                helperEncrypt(out, len) : helperDecrypt(out, len));\n+        try {\n+            return (opmode == Cipher.ENCRYPT_MODE ?\n+                    helperEncrypt(out, len) : helperDecrypt(out, len));\n+        } finally {\n+            if (dataBuf != null && dataBuf != out) {\n+                Arrays.fill(dataBuf, (byte)0);\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/KeyWrapCipher.java","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"}]}