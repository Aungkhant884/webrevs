{"files":[{"patch":"@@ -770,0 +770,3 @@\n+                                                                            \\\n+  product(bool, VerifyReceiverTypes, trueInDebug, DIAGNOSTIC,               \\\n+          \"Verify receiver types at runtime\")                               \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -518,0 +518,4 @@\n+  if (!allow_inline && _callee->holder()->is_interface()) {\n+    \/\/ Don't convert the interface call to a direct call guarded by an interface subtype check.\n+    return false;\n+  }\n@@ -956,1 +960,1 @@\n-    \/\/ Instance exactly does not matches the desired type.\n+    \/\/ Instance does not match the predicted type.\n@@ -961,1 +965,1 @@\n-  \/\/ fall through if the instance exactly matches the desired type\n+  \/\/ Fall through if the instance matches the desired type.\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -75,0 +75,3 @@\n+  const bool is_virtual_or_interface = (bytecode == Bytecodes::_invokevirtual) ||\n+                                       (bytecode == Bytecodes::_invokeinterface);\n+\n@@ -167,0 +170,12 @@\n+        \/\/ For optimized virtual calls assert at runtime that receiver object\n+        \/\/ is a subtype of the inlined method holder. CHA can report a method\n+        \/\/ as a unique target under an abstract method, but receiver type\n+        \/\/ sometimes has a broader type. Similar scenario is possible with\n+        \/\/ default methods when type system loses information about implemented\n+        \/\/ interfaces.\n+        if (cg != NULL && is_virtual_or_interface && !callee->is_static()) {\n+          CallGenerator* trap_cg = CallGenerator::for_uncommon_trap(callee,\n+              Deoptimization::Reason_receiver_constraint, Deoptimization::Action_none);\n+\n+          cg = CallGenerator::for_guarded_call(callee->holder(), trap_cg, cg);\n+        }\n@@ -347,3 +362,10 @@\n-    \/\/ Class Hierarchy Analysis or Type Profile reveals a unique target,\n-    \/\/ or it is a static or special call.\n-    return CallGenerator::for_direct_call(callee, should_delay_inlining(callee, jvms));\n+    \/\/ Class Hierarchy Analysis or Type Profile reveals a unique target, or it is a static or special call.\n+    CallGenerator* cg = CallGenerator::for_direct_call(callee, should_delay_inlining(callee, jvms));\n+    \/\/ For optimized virtual calls assert at runtime that receiver object\n+    \/\/ is a subtype of the method holder.\n+    if (cg != NULL && is_virtual_or_interface && !callee->is_static()) {\n+      CallGenerator* trap_cg = CallGenerator::for_uncommon_trap(callee,\n+          Deoptimization::Reason_receiver_constraint, Deoptimization::Action_none);\n+      cg = CallGenerator::for_guarded_call(callee->holder(), trap_cg, cg);\n+    }\n+    return cg;\n@@ -1108,3 +1130,3 @@\n-  ciInstanceKlass *ikl = receiver_type->klass()->as_instance_klass();\n-  if (ikl->is_loaded() && ikl->is_initialized() && !ikl->is_interface() &&\n-      (ikl == actual_receiver || ikl->is_subtype_of(actual_receiver))) {\n+  ciInstanceKlass* receiver_klass = receiver_type->klass()->as_instance_klass();\n+  if (receiver_klass->is_loaded() && receiver_klass->is_initialized() && !receiver_klass->is_interface() &&\n+      (receiver_klass == actual_receiver || receiver_klass->is_subtype_of(actual_receiver))) {\n@@ -1113,1 +1135,1 @@\n-    actual_receiver = ikl;\n+    actual_receiver = receiver_klass;\n@@ -1121,11 +1143,0 @@\n-  \/\/ Validate receiver info against target method.\n-  if (cha_monomorphic_target != NULL) {\n-    bool has_receiver = !cha_monomorphic_target->is_static();\n-    bool is_interface_holder = cha_monomorphic_target->holder()->is_interface();\n-    if (has_receiver && !is_interface_holder) {\n-      if (!cha_monomorphic_target->holder()->is_subtype_of(receiver_type->klass())) {\n-        cha_monomorphic_target = NULL; \/\/ not a subtype\n-      }\n-    }\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":29,"deletions":18,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2936,1 +2936,3 @@\n-  if (ExpandSubTypeCheckAtParseTime) {\n+  bool expand_subtype_check = C->post_loop_opts_phase() ||   \/\/ macro node expansion is over\n+                              ExpandSubTypeCheckAtParseTime; \/\/ forced expansion\n+  if (expand_subtype_check) {\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1196,0 +1196,1 @@\n+#ifdef ASSERT\n@@ -1197,1 +1198,0 @@\n-  ciInstanceKlass* callee_holder = method()->holder();\n@@ -1199,0 +1199,1 @@\n+    ciInstanceKlass* callee_holder = method()->holder();\n@@ -1205,0 +1206,5 @@\n+      \/\/ Receiver should always be a subtype of callee holder.\n+      \/\/ But, since C2 type system doesn't properly track interfaces,\n+      \/\/ the invariant can't be expressed in the type system for default methods.\n+      \/\/ Example: for unrelated C <: I and D <: I, (C `meet` D) = Object <\/: I.\n+      assert(callee_holder->is_interface(), \"missing subtype check\");\n@@ -1206,1 +1212,0 @@\n-#ifdef ASSERT\n@@ -1214,15 +1219,0 @@\n-#endif \/\/ ASSERT\n-\n-      \/\/ Receiver should always be a subtype of callee holder.\n-      \/\/ But, since C2 type system doesn't properly track interfaces,\n-      \/\/ the invariant on default methods can't be expressed in the type system.\n-      \/\/ Example: for unrelated C <: I and D <: I, (C `meet` D) = Object <\/: I.\n-      \/\/ (Downcasting interface receiver type to concrete class is fine, though it doesn't happen in practice.)\n-      if (!callee_holder->is_interface()) {\n-        assert(callee_holder->is_subtype_of(receiver_type->klass()), \"sanity\");\n-        assert(!receiver_type->klass()->is_interface(), \"interface receiver type\");\n-        receiver_type = receiver_type->join_speculative(holder_type)->is_instptr(); \/\/ keep speculative part\n-        Node* casted_receiver_obj = _gvn.transform(new CheckCastPPNode(control(), receiver_obj, receiver_type));\n-        set_local(0, casted_receiver_obj);\n-      }\n-\n@@ -1231,0 +1221,1 @@\n+#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":8,"deletions":17,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -383,1 +383,1 @@\n-#endif\n+#endif \/\/ !PRODUCT\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1960,1 +1960,3 @@\n-    if (TraceDeoptimization) {\n+    bool is_receiver_constraint_failure = VerifyReceiverTypes && (reason == Deoptimization::Reason_receiver_constraint);\n+\n+    if (TraceDeoptimization || is_receiver_constraint_failure) {\n@@ -2019,1 +2021,1 @@\n-    if (TraceDeoptimization || LogCompilation) {\n+    if (TraceDeoptimization || LogCompilation || is_receiver_constraint_failure) {\n@@ -2112,0 +2114,4 @@\n+    if (is_receiver_constraint_failure) {\n+      fatal(\"missing receiver type check\");\n+    }\n+\n@@ -2601,0 +2607,1 @@\n+  \"receiver_constraint\",\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+    Reason_receiver_constraint,   \/\/ receiver subtype check failed\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2405,0 +2405,1 @@\n+  declare_constant(Deoptimization::Reason_receiver_constraint)            \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}