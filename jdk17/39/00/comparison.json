{"files":[{"patch":"@@ -603,1 +603,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -605,10 +606,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -785,18 +777,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -635,1 +635,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -637,10 +638,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -817,18 +809,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -699,1 +699,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -701,10 +702,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -881,18 +873,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -587,1 +587,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -589,10 +590,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -769,18 +761,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -573,1 +573,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -575,10 +576,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -755,18 +747,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxShuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -571,1 +571,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -573,10 +574,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -753,18 +745,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -575,1 +575,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -577,10 +578,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -757,18 +749,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -583,1 +583,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -585,10 +586,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -765,18 +757,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -569,1 +569,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -571,10 +572,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -751,18 +743,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -568,1 +568,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -570,10 +571,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -750,18 +742,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxShuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -575,1 +575,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -577,10 +578,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -757,18 +749,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -583,1 +583,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -585,10 +586,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -765,18 +757,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -599,1 +599,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -601,10 +602,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -781,18 +773,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -571,1 +571,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -573,10 +574,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -753,18 +745,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -568,1 +568,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -570,10 +571,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -750,18 +742,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxShuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -579,1 +579,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -581,10 +582,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -761,18 +753,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -587,1 +587,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -589,10 +590,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -769,18 +761,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -603,1 +603,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -605,10 +606,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -785,18 +777,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -575,1 +575,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -577,10 +578,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -757,18 +749,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -573,1 +573,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -575,10 +576,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -766,18 +758,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxShuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -565,1 +565,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -567,10 +568,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -747,18 +739,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -569,1 +569,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -571,10 +572,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -751,18 +743,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -577,1 +577,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -579,10 +580,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -759,18 +751,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -563,1 +563,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -565,10 +566,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -745,18 +737,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -563,1 +563,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -565,10 +566,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -745,18 +737,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxShuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -587,1 +587,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -589,10 +590,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -769,18 +761,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -603,1 +603,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -605,10 +606,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -785,18 +777,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -635,1 +635,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -637,10 +638,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -817,18 +809,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -579,1 +579,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -581,10 +582,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -761,18 +753,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -573,1 +573,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -575,10 +576,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -755,18 +747,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxShuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -846,1 +846,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -848,10 +849,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte$bits$Vector.Byte$bits$Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short$bits$Vector.Short$bits$Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int$bits$Vector.Int$bits$Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long$bits$Vector.Long$bits$Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float$bits$Vector.Float$bits$Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double$bits$Vector.Double$bits$Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -1043,18 +1035,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte$bits$Vector.Byte$bits$Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short$bits$Vector.Short$bits$Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int$bits$Vector.Int$bits$Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long$bits$Vector.Long$bits$Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float$bits$Vector.Float$bits$Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double$bits$Vector.Double$bits$Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.ArrayList;\n@@ -37,0 +38,2 @@\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShape;\n@@ -254,0 +257,22 @@\n+    static void assertArraysEquals(int[] r, int[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], a[i+offs]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i+offs], \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], a[i+offs]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i+offs], \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n@@ -264,0 +289,34 @@\n+\n+    static  List<VectorSpecies> castSpeciesProvider(VectorSpecies SPECIES, boolean legal) {\n+        List<VectorSpecies> res = new ArrayList<VectorSpecies>();\n+        for (int elmSz : new int[] {8,16,32,64} ) {\n+            int toSpeciesLength = SPECIES.length() * elmSz;\n+            boolean pickSpecies = legal ?\n+                                  toSpeciesLength >= 64 && toSpeciesLength <= 512 :\n+                                  toSpeciesLength < 64 || toSpeciesLength > 512;\n+            if (pickSpecies) {\n+                if (!legal) {\n+                    toSpeciesLength = toSpeciesLength < 64 ? 64 : 512;\n+                }\n+                switch(elmSz) {\n+                    case 8:\n+                        res.add(VectorSpecies.of(byte.class, VectorShape.forBitSize(toSpeciesLength)));\n+                        break;\n+                    case 16:\n+                        res.add(VectorSpecies.of(short.class, VectorShape.forBitSize(toSpeciesLength)));\n+                        break;\n+                    case 32:\n+                        res.add(VectorSpecies.of(int.class, VectorShape.forBitSize(toSpeciesLength)));\n+                        res.add(VectorSpecies.of(float.class, VectorShape.forBitSize(toSpeciesLength)));\n+                        break;\n+                    case 64:\n+                        res.add(VectorSpecies.of(long.class, VectorShape.forBitSize(toSpeciesLength)));\n+                        res.add(VectorSpecies.of(double.class, VectorShape.forBitSize(toSpeciesLength)));\n+                        break;\n+                    default:\n+                        assert false;\n+                }\n+            }\n+        }\n+        return res;\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/AbstractVectorTest.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -40,0 +40,5 @@\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -67,0 +72,4 @@\n+    static List<VectorSpecies> VALIDCASTSPECIES = castSpeciesProvider(SPECIES, true);\n+\n+    static List<VectorSpecies> INVALIDCASTSPECIES = castSpeciesProvider(SPECIES, false);\n+\n@@ -942,0 +951,28 @@\n+    @DataProvider\n+    public Object[][] castSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5414,2 +5451,2 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueByte128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    @Test(dataProvider = \"castSpeciesMaskProvider\")\n+    static void maskCastByte128VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n@@ -5417,0 +5454,11 @@\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vmask.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n+            }\n+        }\n+    }\n@@ -5418,6 +5466,11 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+    @Test(dataProvider = \"castSpeciesShuffleProvider\")\n+    static void shuffleCastByte128VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vshuffle.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n@@ -5425,1 +5478,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -5427,2 +5481,15 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"castInvalidSpeciesMaskProvider\")\n+    static void maskIllegalCastByte128VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vmask.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n@@ -5432,0 +5499,19 @@\n+    @Test(dataProvider = \"castInvalidSpeciesShuffleProvider\")\n+    static void shuffleIllegalCastByte128VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vshuffle.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":97,"deletions":11,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -40,0 +40,5 @@\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -67,0 +72,4 @@\n+    static List<VectorSpecies> VALIDCASTSPECIES = castSpeciesProvider(SPECIES, true);\n+\n+    static List<VectorSpecies> INVALIDCASTSPECIES = castSpeciesProvider(SPECIES, false);\n+\n@@ -942,0 +951,28 @@\n+    @DataProvider\n+    public Object[][] castSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5414,2 +5451,2 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueByte256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    @Test(dataProvider = \"castSpeciesMaskProvider\")\n+    static void maskCastByte256VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n@@ -5417,0 +5454,11 @@\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vmask.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n+            }\n+        }\n+    }\n@@ -5418,6 +5466,11 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+    @Test(dataProvider = \"castSpeciesShuffleProvider\")\n+    static void shuffleCastByte256VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vshuffle.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n@@ -5425,1 +5478,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -5427,2 +5481,15 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"castInvalidSpeciesMaskProvider\")\n+    static void maskIllegalCastByte256VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vmask.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n@@ -5432,0 +5499,19 @@\n+    @Test(dataProvider = \"castInvalidSpeciesShuffleProvider\")\n+    static void shuffleIllegalCastByte256VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vshuffle.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":97,"deletions":11,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -40,0 +40,5 @@\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -67,0 +72,4 @@\n+    static List<VectorSpecies> VALIDCASTSPECIES = castSpeciesProvider(SPECIES, true);\n+\n+    static List<VectorSpecies> INVALIDCASTSPECIES = castSpeciesProvider(SPECIES, false);\n+\n@@ -942,0 +951,28 @@\n+    @DataProvider\n+    public Object[][] castSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5414,2 +5451,2 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueByte512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    @Test(dataProvider = \"castSpeciesMaskProvider\")\n+    static void maskCastByte512VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n@@ -5417,0 +5454,11 @@\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vmask.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n+            }\n+        }\n+    }\n@@ -5418,6 +5466,11 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+    @Test(dataProvider = \"castSpeciesShuffleProvider\")\n+    static void shuffleCastByte512VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vshuffle.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n@@ -5425,1 +5478,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -5427,2 +5481,15 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"castInvalidSpeciesMaskProvider\")\n+    static void maskIllegalCastByte512VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vmask.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n@@ -5432,0 +5499,19 @@\n+    @Test(dataProvider = \"castInvalidSpeciesShuffleProvider\")\n+    static void shuffleIllegalCastByte512VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vshuffle.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":97,"deletions":11,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -40,0 +40,5 @@\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -67,0 +72,4 @@\n+    static List<VectorSpecies> VALIDCASTSPECIES = castSpeciesProvider(SPECIES, true);\n+\n+    static List<VectorSpecies> INVALIDCASTSPECIES = castSpeciesProvider(SPECIES, false);\n+\n@@ -942,0 +951,28 @@\n+    @DataProvider\n+    public Object[][] castSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5414,2 +5451,2 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueByte64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    @Test(dataProvider = \"castSpeciesMaskProvider\")\n+    static void maskCastByte64VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n@@ -5417,0 +5454,11 @@\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vmask.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n+            }\n+        }\n+    }\n@@ -5418,6 +5466,11 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+    @Test(dataProvider = \"castSpeciesShuffleProvider\")\n+    static void shuffleCastByte64VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vshuffle.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n@@ -5425,1 +5478,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -5427,2 +5481,15 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"castInvalidSpeciesMaskProvider\")\n+    static void maskIllegalCastByte64VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vmask.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n@@ -5432,0 +5499,19 @@\n+    @Test(dataProvider = \"castInvalidSpeciesShuffleProvider\")\n+    static void shuffleIllegalCastByte64VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vshuffle.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":97,"deletions":11,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -40,0 +40,5 @@\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -72,0 +77,4 @@\n+    static List<VectorSpecies> VALIDCASTSPECIES = castSpeciesProvider(SPECIES, true);\n+\n+    static List<VectorSpecies> INVALIDCASTSPECIES = castSpeciesProvider(SPECIES, false);\n+\n@@ -947,0 +956,28 @@\n+    @DataProvider\n+    public Object[][] castSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5419,2 +5456,2 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueByteMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    @Test(dataProvider = \"castSpeciesMaskProvider\")\n+    static void maskCastByteMaxVectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n@@ -5422,0 +5459,11 @@\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vmask.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n+            }\n+        }\n+    }\n@@ -5423,6 +5471,11 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+    @Test(dataProvider = \"castSpeciesShuffleProvider\")\n+    static void shuffleCastByteMaxVectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vshuffle.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n@@ -5430,1 +5483,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -5432,2 +5486,15 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"castInvalidSpeciesMaskProvider\")\n+    static void maskIllegalCastByteMaxVectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vmask.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n@@ -5437,0 +5504,19 @@\n+    @Test(dataProvider = \"castInvalidSpeciesShuffleProvider\")\n+    static void shuffleIllegalCastByteMaxVectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vshuffle.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":97,"deletions":11,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n@@ -40,0 +43,2 @@\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -67,0 +72,4 @@\n+    static List<VectorSpecies> VALIDCASTSPECIES = castSpeciesProvider(SPECIES, true);\n+\n+    static List<VectorSpecies> INVALIDCASTSPECIES = castSpeciesProvider(SPECIES, false);\n+\n@@ -1074,0 +1083,28 @@\n+    @DataProvider\n+    public Object[][] castSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4965,2 +5002,2 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueDouble128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    @Test(dataProvider = \"castSpeciesMaskProvider\")\n+    static void maskCastDouble128VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n@@ -4968,0 +5005,11 @@\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vmask.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n+            }\n+        }\n+    }\n@@ -4969,6 +5017,11 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+    @Test(dataProvider = \"castSpeciesShuffleProvider\")\n+    static void shuffleCastDouble128VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vshuffle.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n@@ -4976,1 +5029,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -4978,2 +5032,15 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"castInvalidSpeciesMaskProvider\")\n+    static void maskIllegalCastDouble128VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vmask.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n@@ -4983,0 +5050,19 @@\n+    @Test(dataProvider = \"castInvalidSpeciesShuffleProvider\")\n+    static void shuffleIllegalCastDouble128VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vshuffle.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":97,"deletions":11,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n@@ -40,0 +43,2 @@\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -67,0 +72,4 @@\n+    static List<VectorSpecies> VALIDCASTSPECIES = castSpeciesProvider(SPECIES, true);\n+\n+    static List<VectorSpecies> INVALIDCASTSPECIES = castSpeciesProvider(SPECIES, false);\n+\n@@ -1074,0 +1083,28 @@\n+    @DataProvider\n+    public Object[][] castSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4965,2 +5002,2 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueDouble256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    @Test(dataProvider = \"castSpeciesMaskProvider\")\n+    static void maskCastDouble256VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n@@ -4968,0 +5005,11 @@\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vmask.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n+            }\n+        }\n+    }\n@@ -4969,6 +5017,11 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+    @Test(dataProvider = \"castSpeciesShuffleProvider\")\n+    static void shuffleCastDouble256VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vshuffle.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n@@ -4976,1 +5029,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -4978,2 +5032,15 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"castInvalidSpeciesMaskProvider\")\n+    static void maskIllegalCastDouble256VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vmask.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n@@ -4983,0 +5050,19 @@\n+    @Test(dataProvider = \"castInvalidSpeciesShuffleProvider\")\n+    static void shuffleIllegalCastDouble256VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vshuffle.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":97,"deletions":11,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n@@ -40,0 +43,2 @@\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -67,0 +72,4 @@\n+    static List<VectorSpecies> VALIDCASTSPECIES = castSpeciesProvider(SPECIES, true);\n+\n+    static List<VectorSpecies> INVALIDCASTSPECIES = castSpeciesProvider(SPECIES, false);\n+\n@@ -1074,0 +1083,28 @@\n+    @DataProvider\n+    public Object[][] castSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4965,2 +5002,2 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueDouble512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    @Test(dataProvider = \"castSpeciesMaskProvider\")\n+    static void maskCastDouble512VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n@@ -4968,0 +5005,11 @@\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vmask.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n+            }\n+        }\n+    }\n@@ -4969,6 +5017,11 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+    @Test(dataProvider = \"castSpeciesShuffleProvider\")\n+    static void shuffleCastDouble512VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vshuffle.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n@@ -4976,1 +5029,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -4978,2 +5032,15 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"castInvalidSpeciesMaskProvider\")\n+    static void maskIllegalCastDouble512VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vmask.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n@@ -4983,0 +5050,19 @@\n+    @Test(dataProvider = \"castInvalidSpeciesShuffleProvider\")\n+    static void shuffleIllegalCastDouble512VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vshuffle.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":97,"deletions":11,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n@@ -40,0 +43,2 @@\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -67,0 +72,4 @@\n+    static List<VectorSpecies> VALIDCASTSPECIES = castSpeciesProvider(SPECIES, true);\n+\n+    static List<VectorSpecies> INVALIDCASTSPECIES = castSpeciesProvider(SPECIES, false);\n+\n@@ -1074,0 +1083,28 @@\n+    @DataProvider\n+    public Object[][] castSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4965,2 +5002,2 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueDouble64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    @Test(dataProvider = \"castSpeciesMaskProvider\")\n+    static void maskCastDouble64VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n@@ -4968,0 +5005,11 @@\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vmask.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n+            }\n+        }\n+    }\n@@ -4969,6 +5017,11 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+    @Test(dataProvider = \"castSpeciesShuffleProvider\")\n+    static void shuffleCastDouble64VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vshuffle.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n@@ -4976,1 +5029,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -4978,2 +5032,15 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"castInvalidSpeciesMaskProvider\")\n+    static void maskIllegalCastDouble64VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vmask.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n@@ -4983,0 +5050,19 @@\n+    @Test(dataProvider = \"castInvalidSpeciesShuffleProvider\")\n+    static void shuffleIllegalCastDouble64VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vshuffle.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":97,"deletions":11,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n@@ -40,0 +43,2 @@\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -72,0 +77,4 @@\n+    static List<VectorSpecies> VALIDCASTSPECIES = castSpeciesProvider(SPECIES, true);\n+\n+    static List<VectorSpecies> INVALIDCASTSPECIES = castSpeciesProvider(SPECIES, false);\n+\n@@ -1079,0 +1088,28 @@\n+    @DataProvider\n+    public Object[][] castSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4970,2 +5007,2 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueDoubleMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    @Test(dataProvider = \"castSpeciesMaskProvider\")\n+    static void maskCastDoubleMaxVectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n@@ -4973,0 +5010,11 @@\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vmask.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n+            }\n+        }\n+    }\n@@ -4974,6 +5022,11 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+    @Test(dataProvider = \"castSpeciesShuffleProvider\")\n+    static void shuffleCastDoubleMaxVectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vshuffle.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n@@ -4981,1 +5034,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -4983,2 +5037,15 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"castInvalidSpeciesMaskProvider\")\n+    static void maskIllegalCastDoubleMaxVectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vmask.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n@@ -4988,0 +5055,19 @@\n+    @Test(dataProvider = \"castInvalidSpeciesShuffleProvider\")\n+    static void shuffleIllegalCastDoubleMaxVectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vshuffle.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":97,"deletions":11,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.incubator.vector.ByteVector;\n@@ -40,0 +41,4 @@\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -67,0 +72,4 @@\n+    static List<VectorSpecies> VALIDCASTSPECIES = castSpeciesProvider(SPECIES, true);\n+\n+    static List<VectorSpecies> INVALIDCASTSPECIES = castSpeciesProvider(SPECIES, false);\n+\n@@ -1084,0 +1093,28 @@\n+    @DataProvider\n+    public Object[][] castSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4943,2 +4980,2 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueFloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    @Test(dataProvider = \"castSpeciesMaskProvider\")\n+    static void maskCastFloat128VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n@@ -4946,0 +4983,11 @@\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vmask.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n+            }\n+        }\n+    }\n@@ -4947,6 +4995,11 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+    @Test(dataProvider = \"castSpeciesShuffleProvider\")\n+    static void shuffleCastFloat128VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vshuffle.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n@@ -4954,1 +5007,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -4956,2 +5010,15 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"castInvalidSpeciesMaskProvider\")\n+    static void maskIllegalCastFloat128VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vmask.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n@@ -4961,0 +5028,19 @@\n+    @Test(dataProvider = \"castInvalidSpeciesShuffleProvider\")\n+    static void shuffleIllegalCastFloat128VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vshuffle.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":97,"deletions":11,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.incubator.vector.ByteVector;\n@@ -40,0 +41,4 @@\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -67,0 +72,4 @@\n+    static List<VectorSpecies> VALIDCASTSPECIES = castSpeciesProvider(SPECIES, true);\n+\n+    static List<VectorSpecies> INVALIDCASTSPECIES = castSpeciesProvider(SPECIES, false);\n+\n@@ -1084,0 +1093,28 @@\n+    @DataProvider\n+    public Object[][] castSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4943,2 +4980,2 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueFloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    @Test(dataProvider = \"castSpeciesMaskProvider\")\n+    static void maskCastFloat256VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n@@ -4946,0 +4983,11 @@\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vmask.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n+            }\n+        }\n+    }\n@@ -4947,6 +4995,11 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+    @Test(dataProvider = \"castSpeciesShuffleProvider\")\n+    static void shuffleCastFloat256VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vshuffle.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n@@ -4954,1 +5007,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -4956,2 +5010,15 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"castInvalidSpeciesMaskProvider\")\n+    static void maskIllegalCastFloat256VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vmask.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n@@ -4961,0 +5028,19 @@\n+    @Test(dataProvider = \"castInvalidSpeciesShuffleProvider\")\n+    static void shuffleIllegalCastFloat256VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vshuffle.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":97,"deletions":11,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.incubator.vector.ByteVector;\n@@ -40,0 +41,4 @@\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -67,0 +72,4 @@\n+    static List<VectorSpecies> VALIDCASTSPECIES = castSpeciesProvider(SPECIES, true);\n+\n+    static List<VectorSpecies> INVALIDCASTSPECIES = castSpeciesProvider(SPECIES, false);\n+\n@@ -1084,0 +1093,28 @@\n+    @DataProvider\n+    public Object[][] castSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4943,2 +4980,2 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueFloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    @Test(dataProvider = \"castSpeciesMaskProvider\")\n+    static void maskCastFloat512VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n@@ -4946,0 +4983,11 @@\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vmask.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n+            }\n+        }\n+    }\n@@ -4947,6 +4995,11 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+    @Test(dataProvider = \"castSpeciesShuffleProvider\")\n+    static void shuffleCastFloat512VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vshuffle.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n@@ -4954,1 +5007,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -4956,2 +5010,15 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"castInvalidSpeciesMaskProvider\")\n+    static void maskIllegalCastFloat512VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vmask.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n@@ -4961,0 +5028,19 @@\n+    @Test(dataProvider = \"castInvalidSpeciesShuffleProvider\")\n+    static void shuffleIllegalCastFloat512VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vshuffle.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":97,"deletions":11,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.incubator.vector.ByteVector;\n@@ -40,0 +41,4 @@\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -67,0 +72,4 @@\n+    static List<VectorSpecies> VALIDCASTSPECIES = castSpeciesProvider(SPECIES, true);\n+\n+    static List<VectorSpecies> INVALIDCASTSPECIES = castSpeciesProvider(SPECIES, false);\n+\n@@ -1084,0 +1093,28 @@\n+    @DataProvider\n+    public Object[][] castSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4943,2 +4980,2 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueFloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    @Test(dataProvider = \"castSpeciesMaskProvider\")\n+    static void maskCastFloat64VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n@@ -4946,0 +4983,11 @@\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vmask.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n+            }\n+        }\n+    }\n@@ -4947,6 +4995,11 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+    @Test(dataProvider = \"castSpeciesShuffleProvider\")\n+    static void shuffleCastFloat64VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vshuffle.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n@@ -4954,1 +5007,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -4956,2 +5010,15 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"castInvalidSpeciesMaskProvider\")\n+    static void maskIllegalCastFloat64VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vmask.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n@@ -4961,0 +5028,19 @@\n+    @Test(dataProvider = \"castInvalidSpeciesShuffleProvider\")\n+    static void shuffleIllegalCastFloat64VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vshuffle.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":97,"deletions":11,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.incubator.vector.ByteVector;\n@@ -40,0 +41,4 @@\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -72,0 +77,4 @@\n+    static List<VectorSpecies> VALIDCASTSPECIES = castSpeciesProvider(SPECIES, true);\n+\n+    static List<VectorSpecies> INVALIDCASTSPECIES = castSpeciesProvider(SPECIES, false);\n+\n@@ -1089,0 +1098,28 @@\n+    @DataProvider\n+    public Object[][] castSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4948,2 +4985,2 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueFloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    @Test(dataProvider = \"castSpeciesMaskProvider\")\n+    static void maskCastFloatMaxVectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n@@ -4951,0 +4988,11 @@\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vmask.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n+            }\n+        }\n+    }\n@@ -4952,6 +5000,11 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+    @Test(dataProvider = \"castSpeciesShuffleProvider\")\n+    static void shuffleCastFloatMaxVectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vshuffle.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n@@ -4959,1 +5012,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -4961,2 +5015,15 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"castInvalidSpeciesMaskProvider\")\n+    static void maskIllegalCastFloatMaxVectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vmask.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n@@ -4966,0 +5033,19 @@\n+    @Test(dataProvider = \"castInvalidSpeciesShuffleProvider\")\n+    static void shuffleIllegalCastFloatMaxVectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vshuffle.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":97,"deletions":11,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n@@ -40,0 +42,3 @@\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -67,0 +72,4 @@\n+    static List<VectorSpecies> VALIDCASTSPECIES = castSpeciesProvider(SPECIES, true);\n+\n+    static List<VectorSpecies> INVALIDCASTSPECIES = castSpeciesProvider(SPECIES, false);\n+\n@@ -932,0 +941,28 @@\n+    @DataProvider\n+    public Object[][] castSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5368,2 +5405,2 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueInt128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    @Test(dataProvider = \"castSpeciesMaskProvider\")\n+    static void maskCastInt128VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n@@ -5371,0 +5408,11 @@\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vmask.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n+            }\n+        }\n+    }\n@@ -5372,6 +5420,11 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+    @Test(dataProvider = \"castSpeciesShuffleProvider\")\n+    static void shuffleCastInt128VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vshuffle.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n@@ -5379,1 +5432,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -5381,2 +5435,15 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"castInvalidSpeciesMaskProvider\")\n+    static void maskIllegalCastInt128VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vmask.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n@@ -5386,0 +5453,19 @@\n+    @Test(dataProvider = \"castInvalidSpeciesShuffleProvider\")\n+    static void shuffleIllegalCastInt128VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vshuffle.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":97,"deletions":11,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n@@ -40,0 +42,3 @@\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -67,0 +72,4 @@\n+    static List<VectorSpecies> VALIDCASTSPECIES = castSpeciesProvider(SPECIES, true);\n+\n+    static List<VectorSpecies> INVALIDCASTSPECIES = castSpeciesProvider(SPECIES, false);\n+\n@@ -932,0 +941,28 @@\n+    @DataProvider\n+    public Object[][] castSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5368,2 +5405,2 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueInt256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    @Test(dataProvider = \"castSpeciesMaskProvider\")\n+    static void maskCastInt256VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n@@ -5371,0 +5408,11 @@\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vmask.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n+            }\n+        }\n+    }\n@@ -5372,6 +5420,11 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+    @Test(dataProvider = \"castSpeciesShuffleProvider\")\n+    static void shuffleCastInt256VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vshuffle.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n@@ -5379,1 +5432,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -5381,2 +5435,15 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"castInvalidSpeciesMaskProvider\")\n+    static void maskIllegalCastInt256VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vmask.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n@@ -5386,0 +5453,19 @@\n+    @Test(dataProvider = \"castInvalidSpeciesShuffleProvider\")\n+    static void shuffleIllegalCastInt256VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vshuffle.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":97,"deletions":11,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n@@ -40,0 +42,3 @@\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -67,0 +72,4 @@\n+    static List<VectorSpecies> VALIDCASTSPECIES = castSpeciesProvider(SPECIES, true);\n+\n+    static List<VectorSpecies> INVALIDCASTSPECIES = castSpeciesProvider(SPECIES, false);\n+\n@@ -932,0 +941,28 @@\n+    @DataProvider\n+    public Object[][] castSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5368,2 +5405,2 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueInt512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    @Test(dataProvider = \"castSpeciesMaskProvider\")\n+    static void maskCastInt512VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n@@ -5371,0 +5408,11 @@\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vmask.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n+            }\n+        }\n+    }\n@@ -5372,6 +5420,11 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+    @Test(dataProvider = \"castSpeciesShuffleProvider\")\n+    static void shuffleCastInt512VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vshuffle.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n@@ -5379,1 +5432,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -5381,2 +5435,15 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"castInvalidSpeciesMaskProvider\")\n+    static void maskIllegalCastInt512VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vmask.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n@@ -5386,0 +5453,19 @@\n+    @Test(dataProvider = \"castInvalidSpeciesShuffleProvider\")\n+    static void shuffleIllegalCastInt512VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vshuffle.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":97,"deletions":11,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n@@ -40,0 +42,3 @@\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -67,0 +72,4 @@\n+    static List<VectorSpecies> VALIDCASTSPECIES = castSpeciesProvider(SPECIES, true);\n+\n+    static List<VectorSpecies> INVALIDCASTSPECIES = castSpeciesProvider(SPECIES, false);\n+\n@@ -932,0 +941,28 @@\n+    @DataProvider\n+    public Object[][] castSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5368,2 +5405,2 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueInt64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    @Test(dataProvider = \"castSpeciesMaskProvider\")\n+    static void maskCastInt64VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n@@ -5371,0 +5408,11 @@\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vmask.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n+            }\n+        }\n+    }\n@@ -5372,6 +5420,11 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+    @Test(dataProvider = \"castSpeciesShuffleProvider\")\n+    static void shuffleCastInt64VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vshuffle.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n@@ -5379,1 +5432,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -5381,2 +5435,15 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"castInvalidSpeciesMaskProvider\")\n+    static void maskIllegalCastInt64VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vmask.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n@@ -5386,0 +5453,19 @@\n+    @Test(dataProvider = \"castInvalidSpeciesShuffleProvider\")\n+    static void shuffleIllegalCastInt64VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vshuffle.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":97,"deletions":11,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n@@ -40,0 +42,3 @@\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.LongVector;\n@@ -72,0 +77,4 @@\n+    static List<VectorSpecies> VALIDCASTSPECIES = castSpeciesProvider(SPECIES, true);\n+\n+    static List<VectorSpecies> INVALIDCASTSPECIES = castSpeciesProvider(SPECIES, false);\n+\n@@ -937,0 +946,28 @@\n+    @DataProvider\n+    public Object[][] castSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5373,2 +5410,2 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueIntMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    @Test(dataProvider = \"castSpeciesMaskProvider\")\n+    static void maskCastIntMaxVectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n@@ -5376,0 +5413,11 @@\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vmask.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n+            }\n+        }\n+    }\n@@ -5377,6 +5425,11 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+    @Test(dataProvider = \"castSpeciesShuffleProvider\")\n+    static void shuffleCastIntMaxVectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vshuffle.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n@@ -5384,1 +5437,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -5386,2 +5440,15 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"castInvalidSpeciesMaskProvider\")\n+    static void maskIllegalCastIntMaxVectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vmask.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n@@ -5391,0 +5458,19 @@\n+    @Test(dataProvider = \"castInvalidSpeciesShuffleProvider\")\n+    static void shuffleIllegalCastIntMaxVectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vshuffle.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":97,"deletions":11,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -39,0 +39,5 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n@@ -67,0 +72,4 @@\n+    static List<VectorSpecies> VALIDCASTSPECIES = castSpeciesProvider(SPECIES, true);\n+\n+    static List<VectorSpecies> INVALIDCASTSPECIES = castSpeciesProvider(SPECIES, false);\n+\n@@ -928,0 +937,28 @@\n+    @DataProvider\n+    public Object[][] castSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5252,2 +5289,2 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueLong128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    @Test(dataProvider = \"castSpeciesMaskProvider\")\n+    static void maskCastLong128VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n@@ -5255,0 +5292,11 @@\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vmask.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n+            }\n+        }\n+    }\n@@ -5256,6 +5304,11 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+    @Test(dataProvider = \"castSpeciesShuffleProvider\")\n+    static void shuffleCastLong128VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vshuffle.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n@@ -5263,1 +5316,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -5265,2 +5319,15 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"castInvalidSpeciesMaskProvider\")\n+    static void maskIllegalCastLong128VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vmask.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n@@ -5270,0 +5337,19 @@\n+    @Test(dataProvider = \"castInvalidSpeciesShuffleProvider\")\n+    static void shuffleIllegalCastLong128VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vshuffle.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":97,"deletions":11,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -39,0 +39,5 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n@@ -67,0 +72,4 @@\n+    static List<VectorSpecies> VALIDCASTSPECIES = castSpeciesProvider(SPECIES, true);\n+\n+    static List<VectorSpecies> INVALIDCASTSPECIES = castSpeciesProvider(SPECIES, false);\n+\n@@ -928,0 +937,28 @@\n+    @DataProvider\n+    public Object[][] castSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5252,2 +5289,2 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueLong256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    @Test(dataProvider = \"castSpeciesMaskProvider\")\n+    static void maskCastLong256VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n@@ -5255,0 +5292,11 @@\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vmask.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n+            }\n+        }\n+    }\n@@ -5256,6 +5304,11 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+    @Test(dataProvider = \"castSpeciesShuffleProvider\")\n+    static void shuffleCastLong256VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vshuffle.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n@@ -5263,1 +5316,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -5265,2 +5319,15 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"castInvalidSpeciesMaskProvider\")\n+    static void maskIllegalCastLong256VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vmask.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n@@ -5270,0 +5337,19 @@\n+    @Test(dataProvider = \"castInvalidSpeciesShuffleProvider\")\n+    static void shuffleIllegalCastLong256VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vshuffle.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":97,"deletions":11,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -39,0 +39,5 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n@@ -67,0 +72,4 @@\n+    static List<VectorSpecies> VALIDCASTSPECIES = castSpeciesProvider(SPECIES, true);\n+\n+    static List<VectorSpecies> INVALIDCASTSPECIES = castSpeciesProvider(SPECIES, false);\n+\n@@ -928,0 +937,28 @@\n+    @DataProvider\n+    public Object[][] castSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5252,2 +5289,2 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueLong512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    @Test(dataProvider = \"castSpeciesMaskProvider\")\n+    static void maskCastLong512VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n@@ -5255,0 +5292,11 @@\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vmask.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n+            }\n+        }\n+    }\n@@ -5256,6 +5304,11 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+    @Test(dataProvider = \"castSpeciesShuffleProvider\")\n+    static void shuffleCastLong512VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vshuffle.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n@@ -5263,1 +5316,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -5265,2 +5319,15 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"castInvalidSpeciesMaskProvider\")\n+    static void maskIllegalCastLong512VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vmask.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n@@ -5270,0 +5337,19 @@\n+    @Test(dataProvider = \"castInvalidSpeciesShuffleProvider\")\n+    static void shuffleIllegalCastLong512VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vshuffle.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":97,"deletions":11,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -39,0 +39,5 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n@@ -67,0 +72,4 @@\n+    static List<VectorSpecies> VALIDCASTSPECIES = castSpeciesProvider(SPECIES, true);\n+\n+    static List<VectorSpecies> INVALIDCASTSPECIES = castSpeciesProvider(SPECIES, false);\n+\n@@ -928,0 +937,28 @@\n+    @DataProvider\n+    public Object[][] castSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5252,2 +5289,2 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueLong64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    @Test(dataProvider = \"castSpeciesMaskProvider\")\n+    static void maskCastLong64VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n@@ -5255,0 +5292,11 @@\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vmask.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n+            }\n+        }\n+    }\n@@ -5256,6 +5304,11 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+    @Test(dataProvider = \"castSpeciesShuffleProvider\")\n+    static void shuffleCastLong64VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vshuffle.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n@@ -5263,1 +5316,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -5265,2 +5319,15 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"castInvalidSpeciesMaskProvider\")\n+    static void maskIllegalCastLong64VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vmask.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n@@ -5270,0 +5337,19 @@\n+    @Test(dataProvider = \"castInvalidSpeciesShuffleProvider\")\n+    static void shuffleIllegalCastLong64VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vshuffle.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":97,"deletions":11,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -39,0 +39,5 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.ShortVector;\n@@ -72,0 +77,4 @@\n+    static List<VectorSpecies> VALIDCASTSPECIES = castSpeciesProvider(SPECIES, true);\n+\n+    static List<VectorSpecies> INVALIDCASTSPECIES = castSpeciesProvider(SPECIES, false);\n+\n@@ -933,0 +942,28 @@\n+    @DataProvider\n+    public Object[][] castSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5257,2 +5294,2 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueLongMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    @Test(dataProvider = \"castSpeciesMaskProvider\")\n+    static void maskCastLongMaxVectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n@@ -5260,0 +5297,11 @@\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vmask.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n+            }\n+        }\n+    }\n@@ -5261,6 +5309,11 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+    @Test(dataProvider = \"castSpeciesShuffleProvider\")\n+    static void shuffleCastLongMaxVectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vshuffle.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n@@ -5268,1 +5321,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -5270,2 +5324,15 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"castInvalidSpeciesMaskProvider\")\n+    static void maskIllegalCastLongMaxVectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vmask.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n@@ -5275,0 +5342,19 @@\n+    @Test(dataProvider = \"castInvalidSpeciesShuffleProvider\")\n+    static void shuffleIllegalCastLongMaxVectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vshuffle.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":97,"deletions":11,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -39,0 +39,4 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n@@ -40,0 +44,1 @@\n+import jdk.incubator.vector.LongVector;\n@@ -67,0 +72,4 @@\n+    static List<VectorSpecies> VALIDCASTSPECIES = castSpeciesProvider(SPECIES, true);\n+\n+    static List<VectorSpecies> INVALIDCASTSPECIES = castSpeciesProvider(SPECIES, false);\n+\n@@ -932,0 +941,28 @@\n+    @DataProvider\n+    public Object[][] castSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5393,2 +5430,2 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueShort128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    @Test(dataProvider = \"castSpeciesMaskProvider\")\n+    static void maskCastShort128VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n@@ -5396,0 +5433,11 @@\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vmask.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n+            }\n+        }\n+    }\n@@ -5397,6 +5445,11 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+    @Test(dataProvider = \"castSpeciesShuffleProvider\")\n+    static void shuffleCastShort128VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vshuffle.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n@@ -5404,1 +5457,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -5406,2 +5460,15 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"castInvalidSpeciesMaskProvider\")\n+    static void maskIllegalCastShort128VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vmask.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n@@ -5411,0 +5478,19 @@\n+    @Test(dataProvider = \"castInvalidSpeciesShuffleProvider\")\n+    static void shuffleIllegalCastShort128VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vshuffle.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":97,"deletions":11,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -39,0 +39,4 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n@@ -40,0 +44,1 @@\n+import jdk.incubator.vector.LongVector;\n@@ -67,0 +72,4 @@\n+    static List<VectorSpecies> VALIDCASTSPECIES = castSpeciesProvider(SPECIES, true);\n+\n+    static List<VectorSpecies> INVALIDCASTSPECIES = castSpeciesProvider(SPECIES, false);\n+\n@@ -932,0 +941,28 @@\n+    @DataProvider\n+    public Object[][] castSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5393,2 +5430,2 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueShort256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    @Test(dataProvider = \"castSpeciesMaskProvider\")\n+    static void maskCastShort256VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n@@ -5396,0 +5433,11 @@\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vmask.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n+            }\n+        }\n+    }\n@@ -5397,6 +5445,11 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+    @Test(dataProvider = \"castSpeciesShuffleProvider\")\n+    static void shuffleCastShort256VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vshuffle.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n@@ -5404,1 +5457,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -5406,2 +5460,15 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"castInvalidSpeciesMaskProvider\")\n+    static void maskIllegalCastShort256VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vmask.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n@@ -5411,0 +5478,19 @@\n+    @Test(dataProvider = \"castInvalidSpeciesShuffleProvider\")\n+    static void shuffleIllegalCastShort256VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vshuffle.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":97,"deletions":11,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -39,0 +39,4 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n@@ -40,0 +44,1 @@\n+import jdk.incubator.vector.LongVector;\n@@ -67,0 +72,4 @@\n+    static List<VectorSpecies> VALIDCASTSPECIES = castSpeciesProvider(SPECIES, true);\n+\n+    static List<VectorSpecies> INVALIDCASTSPECIES = castSpeciesProvider(SPECIES, false);\n+\n@@ -932,0 +941,28 @@\n+    @DataProvider\n+    public Object[][] castSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5393,2 +5430,2 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueShort512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    @Test(dataProvider = \"castSpeciesMaskProvider\")\n+    static void maskCastShort512VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n@@ -5396,0 +5433,11 @@\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vmask.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n+            }\n+        }\n+    }\n@@ -5397,6 +5445,11 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+    @Test(dataProvider = \"castSpeciesShuffleProvider\")\n+    static void shuffleCastShort512VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vshuffle.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n@@ -5404,1 +5457,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -5406,2 +5460,15 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"castInvalidSpeciesMaskProvider\")\n+    static void maskIllegalCastShort512VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vmask.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n@@ -5411,0 +5478,19 @@\n+    @Test(dataProvider = \"castInvalidSpeciesShuffleProvider\")\n+    static void shuffleIllegalCastShort512VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vshuffle.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":97,"deletions":11,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -39,0 +39,4 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n@@ -40,0 +44,1 @@\n+import jdk.incubator.vector.LongVector;\n@@ -67,0 +72,4 @@\n+    static List<VectorSpecies> VALIDCASTSPECIES = castSpeciesProvider(SPECIES, true);\n+\n+    static List<VectorSpecies> INVALIDCASTSPECIES = castSpeciesProvider(SPECIES, false);\n+\n@@ -932,0 +941,28 @@\n+    @DataProvider\n+    public Object[][] castSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5393,2 +5430,2 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueShort64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    @Test(dataProvider = \"castSpeciesMaskProvider\")\n+    static void maskCastShort64VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n@@ -5396,0 +5433,11 @@\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vmask.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n+            }\n+        }\n+    }\n@@ -5397,6 +5445,11 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+    @Test(dataProvider = \"castSpeciesShuffleProvider\")\n+    static void shuffleCastShort64VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vshuffle.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n@@ -5404,1 +5457,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -5406,2 +5460,15 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"castInvalidSpeciesMaskProvider\")\n+    static void maskIllegalCastShort64VectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vmask.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n@@ -5411,0 +5478,19 @@\n+    @Test(dataProvider = \"castInvalidSpeciesShuffleProvider\")\n+    static void shuffleIllegalCastShort64VectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vshuffle.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":97,"deletions":11,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -39,0 +39,4 @@\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.DoubleVector;\n@@ -40,0 +44,1 @@\n+import jdk.incubator.vector.LongVector;\n@@ -72,0 +77,4 @@\n+    static List<VectorSpecies> VALIDCASTSPECIES = castSpeciesProvider(SPECIES, true);\n+\n+    static List<VectorSpecies> INVALIDCASTSPECIES = castSpeciesProvider(SPECIES, false);\n+\n@@ -937,0 +946,28 @@\n+    @DataProvider\n+    public Object[][] castSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5398,2 +5435,2 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueShortMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+    @Test(dataProvider = \"castSpeciesMaskProvider\")\n+    static void maskCastShortMaxVectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n@@ -5401,0 +5438,11 @@\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vmask.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n+            }\n+        }\n+    }\n@@ -5402,6 +5450,11 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+    @Test(dataProvider = \"castSpeciesShuffleProvider\")\n+    static void shuffleCastShortMaxVectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vshuffle.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n@@ -5409,1 +5462,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -5411,2 +5465,15 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"castInvalidSpeciesMaskProvider\")\n+    static void maskIllegalCastShortMaxVectorTestsTest(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vmask.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n@@ -5416,0 +5483,19 @@\n+    @Test(dataProvider = \"castInvalidSpeciesShuffleProvider\")\n+    static void shuffleIllegalCastShortMaxVectorTestsTest(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vshuffle.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":97,"deletions":11,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -447,2 +447,2 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrue$vectorteststype$SmokeTest(IntFunction<boolean[]> fa) {\n+    @Test(dataProvider = \"castSpeciesMaskProvider\")\n+    static void maskCast$vectorteststype$Test(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n@@ -450,0 +450,11 @@\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vmask.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n+            }\n+        }\n+    }\n@@ -451,6 +462,29 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n+    @Test(dataProvider = \"castSpeciesShuffleProvider\")\n+    static void shuffleCast$vectorteststype$Test(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] vsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < vsp.length; j++) {\n+                    var res = vshuffle.cast(vsp[j]);\n+                    assertArraysEquals(res.toArray(), a, i);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"castInvalidSpeciesMaskProvider\")\n+    static void maskIllegalCast$vectorteststype$Test(IntFunction<boolean[]> fa, List<VectorSpecies> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vmask.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n@@ -458,1 +492,2 @@\n-            int expectedFtrue = j - i;\n+        }\n+    }\n@@ -460,2 +495,15 @@\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n+    @Test(dataProvider = \"castInvalidSpeciesShuffleProvider\")\n+    static void shuffleIllegalCast$vectorteststype$Test(BiFunction<Integer,Integer,int[]> fa, List<VectorSpecies> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        VectorSpecies[] invsp = fb.toArray(VectorSpecies[]::new);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vshuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+                for (int j = 0 ; j < invsp.length; j++) {\n+                    try {\n+                        vshuffle.cast(invsp[j]);\n+                        Assert.fail();\n+                    } catch (IllegalArgumentException e) {\n+                    }\n+                }\n+            }\n@@ -465,0 +513,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Miscellaneous.template","additions":60,"deletions":11,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-#if[Byte]\n@@ -41,2 +40,0 @@\n-#end[Byte]\n-#if[Float]\n@@ -44,2 +41,0 @@\n-#end[Float]\n-#if[Int]\n@@ -47,2 +42,0 @@\n-#end[Int]\n-#if[Double]\n@@ -50,2 +43,0 @@\n-#end[Double]\n-#if[Short]\n@@ -53,2 +44,0 @@\n-#end[Short]\n-#if[Long]\n@@ -56,1 +45,0 @@\n-#end[Long]\n@@ -96,0 +84,4 @@\n+    static List<VectorSpecies> VALIDCASTSPECIES = castSpeciesProvider(SPECIES, true);\n+\n+    static List<VectorSpecies> INVALIDCASTSPECIES = castSpeciesProvider(SPECIES, false);\n+\n@@ -1145,0 +1137,28 @@\n+    @DataProvider\n+    public Object[][] castSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,VALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] castInvalidSpeciesShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f,INVALIDCASTSPECIES}).\n+                toArray(Object[][]::new);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":32,"deletions":12,"binary":false,"changes":44,"status":"modified"}]}