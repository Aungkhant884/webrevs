{"files":[{"patch":"@@ -603,1 +603,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -605,10 +606,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -785,18 +777,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -635,1 +635,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -637,10 +638,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -817,18 +809,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -699,1 +699,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -701,10 +702,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -881,18 +873,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -587,1 +587,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -589,10 +590,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -769,18 +761,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -573,1 +573,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -575,10 +576,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -755,18 +747,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxShuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -571,1 +571,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -573,10 +574,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -753,18 +745,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -575,1 +575,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -577,10 +578,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -757,18 +749,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -583,1 +583,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -585,10 +586,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -765,18 +757,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -569,1 +569,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -571,10 +572,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -751,18 +743,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -568,1 +568,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -570,10 +571,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -750,18 +742,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxShuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -575,1 +575,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -577,10 +578,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -757,18 +749,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -583,1 +583,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -585,10 +586,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -765,18 +757,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -599,1 +599,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -601,10 +602,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -781,18 +773,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -571,1 +571,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -573,10 +574,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -753,18 +745,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -568,1 +568,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -570,10 +571,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -750,18 +742,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxShuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -579,1 +579,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -581,10 +582,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -761,18 +753,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -587,1 +587,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -589,10 +590,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -769,18 +761,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -603,1 +603,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -605,10 +606,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -785,18 +777,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -575,1 +575,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -577,10 +578,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -757,18 +749,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -573,1 +573,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -575,10 +576,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -766,18 +758,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxShuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -565,1 +565,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -567,10 +568,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -747,18 +739,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -569,1 +569,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -571,10 +572,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -751,18 +743,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -577,1 +577,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -579,10 +580,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -759,18 +751,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -563,1 +563,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -565,10 +566,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -745,18 +737,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -563,1 +563,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -565,10 +566,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -745,18 +737,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxShuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -587,1 +587,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -589,10 +590,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -769,18 +761,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -603,1 +603,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -605,10 +606,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -785,18 +777,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -635,1 +635,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -637,10 +638,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -817,18 +809,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -579,1 +579,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -581,10 +582,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -761,18 +753,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -573,1 +573,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -575,10 +576,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -755,18 +747,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxShuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -846,1 +846,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -848,10 +849,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte$bits$Vector.Byte$bits$Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short$bits$Vector.Short$bits$Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int$bits$Vector.Int$bits$Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long$bits$Vector.Long$bits$Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float$bits$Vector.Float$bits$Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double$bits$Vector.Double$bits$Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -1043,18 +1035,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte$bits$Vector.Byte$bits$Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short$bits$Vector.Short$bits$Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int$bits$Vector.Int$bits$Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long$bits$Vector.Long$bits$Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float$bits$Vector.Float$bits$Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double$bits$Vector.Double$bits$Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -244,0 +244,25 @@\n+    static Object[][] fixedShapeXSegmentedCastSpeciesArgs(VectorShape srcShape) {\n+        List<Object[]> args = new ArrayList<>();\n+\n+        for (Class<?> srcE : List.of(byte.class, short.class, int.class, long.class, float.class, double.class)) {\n+            VectorSpecies<?> src = VectorSpecies.of(srcE, srcShape);\n+\n+            for (VectorShape dstShape : VectorShape.values()) {\n+                for (Class<?> dstE : List.of(byte.class, short.class, int.class, long.class, float.class, double.class)) {\n+                    VectorSpecies<?> dst = VectorSpecies.of(dstE, dstShape);\n+\n+                    List<VectorSpecies> legal = new ArrayList<VectorSpecies>();\n+                    List<VectorSpecies> illegal = new ArrayList<VectorSpecies>();\n+\n+                    if (dst.length() == src.length()) {\n+                        legal.add(dst);\n+                    } else {\n+                        illegal.add(dst);\n+                    }\n+\n+                    args.add(new Object[]{src, legal, illegal});\n+                }\n+            }\n+        }\n+        return args.toArray(Object[][]::new);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/AbstractVectorConversionTest.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.ArrayList;\n@@ -37,0 +38,2 @@\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShape;\n@@ -254,0 +257,22 @@\n+    static void assertArraysEquals(int[] r, int[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], a[i+offs]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i+offs], \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], a[i+offs]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i+offs], \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/AbstractVectorTest.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -5414,17 +5414,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueByte128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -5414,17 +5414,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueByte256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -5414,17 +5414,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueByte512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -5414,17 +5414,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueByte64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -5419,17 +5419,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueByteMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -4965,17 +4965,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueDouble128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -4965,17 +4965,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueDouble256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -4965,17 +4965,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueDouble512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -4965,17 +4965,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueDouble64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -4970,17 +4970,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueDoubleMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -4943,17 +4943,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueFloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -4943,17 +4943,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueFloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -4943,17 +4943,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueFloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -4943,17 +4943,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueFloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -4948,17 +4948,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueFloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -5368,17 +5368,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueInt128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -5368,17 +5368,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueInt256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -5368,17 +5368,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueInt512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -5368,17 +5368,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueInt64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -5373,17 +5373,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueIntMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -5252,17 +5252,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueLong128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -5252,17 +5252,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueLong256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -5252,17 +5252,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueLong512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -5252,17 +5252,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueLong64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -5257,17 +5257,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueLongMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -5393,17 +5393,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueShort128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -5393,17 +5393,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueShort256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -5393,17 +5393,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueShort512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -5393,17 +5393,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueShort64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -5398,17 +5398,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrueShortMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorShuffle;\n@@ -28,0 +30,1 @@\n+import org.testng.Assert;\n@@ -30,0 +33,1 @@\n+import java.util.List;\n@@ -55,0 +59,5 @@\n+    @DataProvider\n+    public Object[][] fixedShapeXSegmentedCastSpecies() {\n+        return fixedShapeXSegmentedCastSpeciesArgs(SHAPE);\n+    }\n+\n@@ -78,0 +87,41 @@\n+\n+    @Test(dataProvider = \"fixedShapeXSegmentedCastSpecies\")\n+    static void shuffleCast(VectorSpecies src, List<VectorSpecies> legal, List<VectorSpecies> illegal) {\n+        int [] arr = new int[src.length()];\n+        for(int i = 0; i < arr.length; i++) {\n+            arr[i] = i;\n+        }\n+        VectorShuffle shuffle = VectorShuffle.fromArray(src, arr, 0);\n+\n+        for(var sps : legal) {\n+            VectorShuffle res = shuffle.cast(sps);\n+            Assert.assertEquals(res.toArray(), arr);\n+        }\n+\n+        for(var sps : illegal) {\n+            try {\n+                shuffle.cast(sps);\n+                Assert.fail();\n+            } catch (IllegalArgumentException e) {\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"fixedShapeXSegmentedCastSpecies\")\n+    static void maskCast(VectorSpecies src, List<VectorSpecies> legal, List<VectorSpecies> illegal) {\n+        long val = (1L << (src.length() & 63)) - 1L;\n+        VectorMask mask = VectorMask.fromLong(src, val);\n+\n+        for(var sps : legal) {\n+            VectorMask res = mask.cast(sps);\n+            Assert.assertEquals(res.toLong(), val);\n+        }\n+\n+        for(var sps : illegal) {\n+            try {\n+                mask.cast(sps);\n+                Assert.fail();\n+            } catch (IllegalArgumentException e) {\n+            }\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Vector128ConversionTests.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorShuffle;\n@@ -28,0 +30,1 @@\n+import org.testng.Assert;\n@@ -30,0 +33,1 @@\n+import java.util.List;\n@@ -55,0 +59,5 @@\n+    @DataProvider\n+    public Object[][] fixedShapeXSegmentedCastSpecies() {\n+        return fixedShapeXSegmentedCastSpeciesArgs(SHAPE);\n+    }\n+\n@@ -78,0 +87,41 @@\n+\n+    @Test(dataProvider = \"fixedShapeXSegmentedCastSpecies\")\n+    static void shuffleCast(VectorSpecies src, List<VectorSpecies> legal, List<VectorSpecies> illegal) {\n+        int [] arr = new int[src.length()];\n+        for(int i = 0; i < arr.length; i++) {\n+            arr[i] = i;\n+        }\n+        VectorShuffle shuffle = VectorShuffle.fromArray(src, arr, 0);\n+\n+        for(var sps : legal) {\n+            VectorShuffle res = shuffle.cast(sps);\n+            Assert.assertEquals(res.toArray(), arr);\n+        }\n+\n+        for(var sps : illegal) {\n+            try {\n+                shuffle.cast(sps);\n+                Assert.fail();\n+            } catch (IllegalArgumentException e) {\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"fixedShapeXSegmentedCastSpecies\")\n+    static void maskCast(VectorSpecies src, List<VectorSpecies> legal, List<VectorSpecies> illegal) {\n+        long val = (1L << (src.length() & 63)) - 1L;\n+        VectorMask mask = VectorMask.fromLong(src, val);\n+\n+        for(var sps : legal) {\n+            VectorMask res = mask.cast(sps);\n+            Assert.assertEquals(res.toLong(), val);\n+        }\n+\n+        for(var sps : illegal) {\n+            try {\n+                mask.cast(sps);\n+                Assert.fail();\n+            } catch (IllegalArgumentException e) {\n+            }\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Vector256ConversionTests.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorShuffle;\n@@ -28,0 +30,1 @@\n+import org.testng.Assert;\n@@ -30,0 +33,1 @@\n+import java.util.List;\n@@ -55,0 +59,5 @@\n+    @DataProvider\n+    public Object[][] fixedShapeXSegmentedCastSpecies() {\n+        return fixedShapeXSegmentedCastSpeciesArgs(SHAPE);\n+    }\n+\n@@ -78,0 +87,41 @@\n+\n+    @Test(dataProvider = \"fixedShapeXSegmentedCastSpecies\")\n+    static void shuffleCast(VectorSpecies src, List<VectorSpecies> legal, List<VectorSpecies> illegal) {\n+        int [] arr = new int[src.length()];\n+        for(int i = 0; i < arr.length; i++) {\n+            arr[i] = i;\n+        }\n+        VectorShuffle shuffle = VectorShuffle.fromArray(src, arr, 0);\n+\n+        for(var sps : legal) {\n+            VectorShuffle res = shuffle.cast(sps);\n+            Assert.assertEquals(res.toArray(), arr);\n+        }\n+\n+        for(var sps : illegal) {\n+            try {\n+                shuffle.cast(sps);\n+                Assert.fail();\n+            } catch (IllegalArgumentException e) {\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"fixedShapeXSegmentedCastSpecies\")\n+    static void maskCast(VectorSpecies src, List<VectorSpecies> legal, List<VectorSpecies> illegal) {\n+        long val = (1L << (src.length() & 63)) - 1L;\n+        VectorMask mask = VectorMask.fromLong(src, val);\n+\n+        for(var sps : legal) {\n+            VectorMask res = mask.cast(sps);\n+            Assert.assertEquals(res.toLong(), val);\n+        }\n+\n+        for(var sps : illegal) {\n+            try {\n+                mask.cast(sps);\n+                Assert.fail();\n+            } catch (IllegalArgumentException e) {\n+            }\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Vector512ConversionTests.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorShuffle;\n@@ -28,0 +30,1 @@\n+import org.testng.Assert;\n@@ -30,1 +33,1 @@\n-\n+import java.util.List;\n@@ -77,0 +80,5 @@\n+    @DataProvider\n+    public Object[][] fixedShapeXSegmentedCastSpecies() {\n+        return fixedShapeXSegmentedCastSpeciesArgs(SHAPE);\n+    }\n+\n@@ -100,0 +108,41 @@\n+\n+    @Test(dataProvider = \"fixedShapeXSegmentedCastSpecies\")\n+    static void shuffleCast(VectorSpecies src, List<VectorSpecies> legal, List<VectorSpecies> illegal) {\n+        int [] arr = new int[src.length()];\n+        for(int i = 0; i < arr.length; i++) {\n+            arr[i] = i;\n+        }\n+        VectorShuffle shuffle = VectorShuffle.fromArray(src, arr, 0);\n+\n+        for(var sps : legal) {\n+            VectorShuffle res = shuffle.cast(sps);\n+            Assert.assertEquals(res.toArray(), arr);\n+        }\n+\n+        for(var sps : illegal) {\n+            try {\n+                shuffle.cast(sps);\n+                Assert.fail();\n+            } catch (IllegalArgumentException e) {\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"fixedShapeXSegmentedCastSpecies\")\n+    static void maskCast(VectorSpecies src, List<VectorSpecies> legal, List<VectorSpecies> illegal) {\n+        long val = (1L << (src.length() & 63)) - 1L;\n+        VectorMask mask = VectorMask.fromLong(src, val);\n+\n+        for(var sps : legal) {\n+            VectorMask res = mask.cast(sps);\n+            Assert.assertEquals(res.toLong(), val);\n+        }\n+\n+        for(var sps : illegal) {\n+            try {\n+                mask.cast(sps);\n+                Assert.fail();\n+            } catch (IllegalArgumentException e) {\n+            }\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Vector64ConversionTests.java","additions":50,"deletions":1,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorShuffle;\n@@ -28,0 +30,1 @@\n+import org.testng.Assert;\n@@ -30,0 +33,1 @@\n+import java.util.List;\n@@ -54,0 +58,5 @@\n+    @DataProvider\n+    public Object[][] fixedShapeXSegmentedCastSpecies() {\n+        return fixedShapeXSegmentedCastSpeciesArgs(SHAPE);\n+    }\n+\n@@ -77,0 +86,41 @@\n+\n+    @Test(dataProvider = \"fixedShapeXSegmentedCastSpecies\")\n+    static void shuffleCast(VectorSpecies src, List<VectorSpecies> legal, List<VectorSpecies> illegal) {\n+        int [] arr = new int[src.length()];\n+        for(int i = 0; i < arr.length; i++) {\n+            arr[i] = i;\n+        }\n+        VectorShuffle shuffle = VectorShuffle.fromArray(src, arr, 0);\n+\n+        for(var sps : legal) {\n+            VectorShuffle res = shuffle.cast(sps);\n+            Assert.assertEquals(res.toArray(), arr);\n+        }\n+\n+        for(var sps : illegal) {\n+            try {\n+                shuffle.cast(sps);\n+                Assert.fail();\n+            } catch (IllegalArgumentException e) {\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"fixedShapeXSegmentedCastSpecies\")\n+    static void maskCast(VectorSpecies src, List<VectorSpecies> legal, List<VectorSpecies> illegal) {\n+        long val = (1L << (src.length() & 63)) - 1L;\n+        VectorMask mask = VectorMask.fromLong(src, val);\n+\n+        for(var sps : legal) {\n+            VectorMask res = mask.cast(sps);\n+            Assert.assertEquals(res.toLong(), val);\n+        }\n+\n+        for(var sps : illegal) {\n+            try {\n+                mask.cast(sps);\n+                Assert.fail();\n+            } catch (IllegalArgumentException e) {\n+            }\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/VectorMaxConversionTests.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -447,17 +447,0 @@\n-    @Test(dataProvider = \"maskProvider\")\n-    static void maskFirstTrue$vectorteststype$SmokeTest(IntFunction<boolean[]> fa) {\n-        boolean[] a = fa.apply(SPECIES.length());\n-\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            var vmask = SPECIES.loadMask(a, i);\n-            int ftrue = vmask.firstTrue();\n-            int j = i;\n-            for (; j < i + SPECIES.length() ; j++) {\n-                if (a[j]) break;\n-            }\n-            int expectedFtrue = j - i;\n-\n-            Assert.assertTrue(ftrue == expectedFtrue, \"at index \" + i +\n-                \", firstTrue should be = \" + expectedFtrue + \", but is = \" + ftrue);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Miscellaneous.template","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"}]}