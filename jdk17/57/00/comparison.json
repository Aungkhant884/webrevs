{"files":[{"patch":"@@ -26,1 +26,1 @@\n-#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/javaClasses.inline.hpp\"\n@@ -36,0 +36,1 @@\n+#include \"memory\/arena.hpp\"\n@@ -222,1 +223,0 @@\n-  ResourceMark rm(THREAD);\n@@ -244,2 +244,0 @@\n-  static const char signature[] = \"(Ljava\/lang\/String;Ljava\/lang\/String;C)[Ljava\/lang\/String;\";\n-\n@@ -249,1 +247,1 @@\n-\n+  static const char signature[] = \"(Ljava\/lang\/String;Ljava\/lang\/String;C)[Ljava\/lang\/String;\";\n@@ -274,2 +272,2 @@\n-  JfrJavaArguments print_help(&result, javaClass(), \"printHelp\", signature, thread);\n-  invoke(print_help, thread);\n+  JfrJavaArguments printHelp(&result, javaClass(), \"printHelp\", signature, thread);\n+  invoke(printHelp, thread);\n@@ -279,0 +277,63 @@\n+\/\/ Since the DcmdFramework does not support dynamically allocated strings,\n+\/\/ we keep them in a thread local arena. The arena is reset between invocations.\n+static THREAD_LOCAL Arena* dcmd_arena = NULL;\n+\n+static void prepare_dcmd_string_arena() {\n+  if (dcmd_arena == NULL) {\n+    dcmd_arena = new (mtTracing) Arena(mtTracing);\n+  } else {\n+    dcmd_arena->destruct_contents(); \/\/ will grow on next allocation\n+  }\n+}\n+\n+static char* dcmd_arena_allocate(size_t size) {\n+  assert(dcmd_arena != NULL, \"invariant\");\n+  return (char*)dcmd_arena->Amalloc(size);\n+}\n+\n+static const char* get_as_dcmd_arena_string(oop string, JavaThread* t) {\n+  char* str = NULL;\n+  const typeArrayOop value = java_lang_String::value(string);\n+  if (value != NULL) {\n+    const size_t length = static_cast<size_t>(java_lang_String::utf8_length(string, value)) + 1;\n+    str = dcmd_arena_allocate(length);\n+    assert(str != NULL, \"invariant\");\n+    java_lang_String::as_utf8_string(string, value, str, static_cast<int>(length));\n+  }\n+  return str;\n+}\n+\n+static const char* read_string_field(oop argument, const char* field_name, TRAPS) {\n+  JavaValue result(T_OBJECT);\n+  JfrJavaArguments args(&result);\n+  args.set_klass(argument->klass());\n+  args.set_name(field_name);\n+  args.set_signature(\"Ljava\/lang\/String;\");\n+  args.set_receiver(argument);\n+  JfrJavaSupport::get_field(&args, THREAD);\n+  const oop string_oop = result.get_oop();\n+  return string_oop != NULL ? get_as_dcmd_arena_string(string_oop, (JavaThread*)THREAD) : NULL;\n+}\n+\n+static bool read_boolean_field(oop argument, const char* field_name, TRAPS) {\n+  JavaValue result(T_BOOLEAN);\n+  JfrJavaArguments args(&result);\n+  args.set_klass(argument->klass());\n+  args.set_name(field_name);\n+  args.set_signature(\"Z\");\n+  args.set_receiver(argument);\n+  JfrJavaSupport::get_field(&args, THREAD);\n+  return (result.get_jint() & 1) == 1;\n+}\n+\n+static DCmdArgumentInfo* create_info(oop argument, TRAPS) {\n+  return new DCmdArgumentInfo(\n+    read_string_field(argument, \"name\", THREAD),\n+    read_string_field(argument, \"description\", THREAD),\n+    read_string_field(argument, \"type\", THREAD),\n+    read_string_field(argument, \"defaultValue\", THREAD),\n+    read_boolean_field(argument, \"mandatory\", THREAD),\n+    true, \/\/ a DcmdFramework \"option\"\n+    read_boolean_field(argument, \"allowMultiple\", THREAD));\n+}\n+\n@@ -280,1 +341,17 @@\n-  return new GrowableArray<DCmdArgumentInfo*>();\n+  static const char signature[] = \"()[Ljdk\/jfr\/internal\/dcmd\/Argument;\";\n+  JavaThread* thread = JavaThread::current();\n+  JavaValue result(T_OBJECT);\n+  JfrJavaArguments getArgumentInfos(&result, javaClass(), \"getArgumentInfos\", signature, thread);\n+  invoke(getArgumentInfos, thread);\n+  objArrayOop arguments = objArrayOop(result.get_oop());\n+  assert(arguments != NULL, \"invariant\");\n+  assert(arguments->is_array(), \"must be array\");\n+  GrowableArray<DCmdArgumentInfo*>* const array = new GrowableArray<DCmdArgumentInfo*>();\n+  const int length = arguments->length();\n+  prepare_dcmd_string_arena();\n+  for (int i = 0; i < length; ++i) {\n+    DCmdArgumentInfo* const dai = create_info(arguments->obj_at(i), thread);\n+    assert(dai != NULL, \"invariant\");\n+    array->append(dai);\n+  }\n+  return array;\n@@ -390,1 +467,0 @@\n-  ResourceMark rm(THREAD);\n","filename":"src\/hotspot\/share\/jfr\/dcmd\/jfrDcmds.cpp","additions":85,"deletions":9,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -68,0 +68,3 @@\n+  static int num_arguments() {\n+    return 11;\n+  }\n@@ -90,0 +93,3 @@\n+  static int num_arguments() {\n+    return 7;\n+  }\n@@ -112,0 +118,3 @@\n+  static int num_arguments() {\n+    return 2;\n+  }\n@@ -134,0 +143,3 @@\n+  static int num_arguments() {\n+    return 2;\n+  }\n","filename":"src\/hotspot\/share\/jfr\/dcmd\/jfrDcmds.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -61,1 +61,4 @@\n-    \/\/ Called by native\n+    \/\/ Called by native. The number of arguments for each command is\n+    \/\/ reported to the DCmdFramework as a hardcoded number in native.\n+    \/\/ This is to avoid an upcall as part of DcmdFramework enumerating existing commands.\n+    \/\/ Remember to keep the two sides in synch.\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/AbstractDCmd.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}