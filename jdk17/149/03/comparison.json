{"files":[{"patch":"@@ -365,1 +365,1 @@\n-JavaFrameAnchor* OptimizedEntryBlob::jfa_for_frame(const frame& frame) const {\n+OptimizedEntryBlob::FrameData* OptimizedEntryBlob::frame_data_for_frame(const frame& frame) const {\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -316,0 +316,5 @@\n+OptimizedEntryBlob::FrameData* OptimizedEntryBlob::frame_data_for_frame(const frame& frame) const {\n+  ShouldNotCallThis();\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -200,0 +200,5 @@\n+OptimizedEntryBlob::FrameData* OptimizedEntryBlob::frame_data_for_frame(const frame& frame) const {\n+  ShouldNotCallThis();\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -211,0 +211,5 @@\n+OptimizedEntryBlob::FrameData* OptimizedEntryBlob::frame_data_for_frame(const frame& frame) const {\n+  ShouldNotCallThis();\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/frame_s390.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -356,1 +356,2 @@\n-JavaFrameAnchor* OptimizedEntryBlob::jfa_for_frame(const frame& frame) const {\n+OptimizedEntryBlob::FrameData* OptimizedEntryBlob::frame_data_for_frame(const frame& frame) const {\n+  assert(frame.is_optimized_entry_frame(), \"wrong frame\");\n@@ -358,1 +359,2 @@\n-  return reinterpret_cast<JavaFrameAnchor*>(reinterpret_cast<char*>(frame.unextended_sp()) + in_bytes(jfa_sp_offset()));\n+  return reinterpret_cast<OptimizedEntryBlob::FrameData*>(\n+    reinterpret_cast<char*>(frame.unextended_sp()) + in_bytes(_frame_data_offset));\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -319,41 +319,0 @@\n-void save_java_frame_anchor(MacroAssembler* _masm, ByteSize store_offset, Register thread) {\n-  __ block_comment(\"{ save_java_frame_anchor \");\n-  \/\/ upcall->jfa._last_Java_fp = _thread->_anchor._last_Java_fp;\n-  __ movptr(rscratch1, Address(thread, JavaThread::last_Java_fp_offset()));\n-  __ movptr(Address(rsp, store_offset + JavaFrameAnchor::last_Java_fp_offset()), rscratch1);\n-\n-  \/\/ upcall->jfa._last_Java_pc = _thread->_anchor._last_Java_pc;\n-  __ movptr(rscratch1, Address(thread, JavaThread::last_Java_pc_offset()));\n-  __ movptr(Address(rsp, store_offset + JavaFrameAnchor::last_Java_pc_offset()), rscratch1);\n-\n-  \/\/ upcall->jfa._last_Java_sp = _thread->_anchor._last_Java_sp;\n-  __ movptr(rscratch1, Address(thread, JavaThread::last_Java_sp_offset()));\n-  __ movptr(Address(rsp, store_offset + JavaFrameAnchor::last_Java_sp_offset()), rscratch1);\n-  __ block_comment(\"} save_java_frame_anchor \");\n-}\n-\n-void restore_java_frame_anchor(MacroAssembler* _masm, ByteSize load_offset, Register thread) {\n-  __ block_comment(\"{ restore_java_frame_anchor \");\n-  \/\/ thread->_last_Java_sp = NULL\n-  __ movptr(Address(thread, JavaThread::last_Java_sp_offset()), NULL_WORD);\n-\n-  \/\/ ThreadStateTransition::transition_from_java(_thread, _thread_in_vm);\n-  \/\/ __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native_trans);\n-  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native);\n-\n-  \/\/_thread->frame_anchor()->copy(&_anchor);\n-\/\/  _thread->_last_Java_fp = upcall->_last_Java_fp;\n-\/\/  _thread->_last_Java_pc = upcall->_last_Java_pc;\n-\/\/  _thread->_last_Java_sp = upcall->_last_Java_sp;\n-\n-  __ movptr(rscratch1, Address(rsp, load_offset + JavaFrameAnchor::last_Java_fp_offset()));\n-  __ movptr(Address(thread, JavaThread::last_Java_fp_offset()), rscratch1);\n-\n-  __ movptr(rscratch1, Address(rsp, load_offset + JavaFrameAnchor::last_Java_pc_offset()));\n-  __ movptr(Address(thread, JavaThread::last_Java_pc_offset()), rscratch1);\n-\n-  __ movptr(rscratch1, Address(rsp, load_offset + JavaFrameAnchor::last_Java_sp_offset()));\n-  __ movptr(Address(thread, JavaThread::last_Java_sp_offset()), rscratch1);\n-  __ block_comment(\"} restore_java_frame_anchor \");\n-}\n-\n@@ -445,0 +404,54 @@\n+static int compute_res_save_area_size(const CallRegs& conv) {\n+  int result_size = 0;\n+  for (int i = 0; i < conv._rets_length; i++) {\n+    VMReg reg = conv._ret_regs[i];\n+    if (reg->is_Register()) {\n+      result_size += 8;\n+    } else if (reg->is_XMMRegister()) {\n+      \/\/ Java API doesn't support vector args\n+      result_size += 16;\n+    } else {\n+      ShouldNotReachHere(); \/\/ unhandled type\n+    }\n+  }\n+  return result_size;\n+}\n+\n+static void save_java_result(MacroAssembler* _masm, const CallRegs& conv, int res_save_area_offset) {\n+  int offset = res_save_area_offset;\n+  __ block_comment(\"{ save java result \");\n+  for (int i = 0; i < conv._rets_length; i++) {\n+    VMReg reg = conv._ret_regs[i];\n+    if (reg->is_Register()) {\n+      __ movptr(Address(rsp, offset), reg->as_Register());\n+      offset += 8;\n+    } else if (reg->is_XMMRegister()) {\n+      \/\/ Java API doesn't support vector args\n+      __ movdqu(Address(rsp, offset), reg->as_XMMRegister());\n+      offset += 16;\n+    } else {\n+      ShouldNotReachHere(); \/\/ unhandled type\n+    }\n+  }\n+  __ block_comment(\"} save java result \");\n+}\n+\n+static void restore_java_result(MacroAssembler* _masm, const CallRegs& conv, int res_save_area_offset) {\n+  int offset = res_save_area_offset;\n+  __ block_comment(\"{ restore java result \");\n+  for (int i = 0; i < conv._rets_length; i++) {\n+    VMReg reg = conv._ret_regs[i];\n+    if (reg->is_Register()) {\n+      __ movptr(reg->as_Register(), Address(rsp, offset));\n+      offset += 8;\n+    } else if (reg->is_XMMRegister()) {\n+      \/\/ Java API doesn't support vector args\n+      __ movdqu(reg->as_XMMRegister(), Address(rsp, offset));\n+      offset += 16;\n+    } else {\n+      ShouldNotReachHere(); \/\/ unhandled type\n+    }\n+  }\n+  __ block_comment(\"} restore java result \");\n+}\n+\n@@ -577,6 +590,0 @@\n-struct AuxiliarySaves {\n-  JavaFrameAnchor jfa;\n-  uintptr_t thread;\n-  bool should_detach;\n-};\n-\n@@ -607,0 +614,1 @@\n+  int res_save_area_size = compute_res_save_area_size(conv);\n@@ -612,1 +620,2 @@\n-  int arg_save_area_offset   = deopt_spill_offset     + deopt_spill_size;\n+  int res_save_area_offset   = deopt_spill_offset     + deopt_spill_size;\n+  int arg_save_area_offset   = res_save_area_offset   + res_save_area_size;\n@@ -614,6 +623,2 @@\n-  int auxiliary_saves_offset = reg_save_area_offset   + reg_save_area_size;\n-  int frame_bottom_offset    = auxiliary_saves_offset + sizeof(AuxiliarySaves);\n-\n-  ByteSize jfa_offset           = in_ByteSize(auxiliary_saves_offset) + byte_offset_of(AuxiliarySaves, jfa);\n-  ByteSize thread_offset        = in_ByteSize(auxiliary_saves_offset) + byte_offset_of(AuxiliarySaves, thread);\n-  ByteSize should_detach_offset = in_ByteSize(auxiliary_saves_offset) + byte_offset_of(AuxiliarySaves, should_detach);\n+  int frame_data_offset      = reg_save_area_offset   + reg_save_area_size;\n+  int frame_bottom_offset    = frame_data_offset      + sizeof(OptimizedEntryBlob::FrameData);\n@@ -630,2 +635,2 @@\n-  \/\/      | AuxiliarySaves      |\n-  \/\/      |---------------------| = auxiliary_saves_offset\n+  \/\/      | FrameData           |\n+  \/\/      |---------------------| = frame_data_offset\n@@ -639,0 +644,3 @@\n+  \/\/      | res_save_area       |\n+  \/\/      |---------------------| = res_save_are_offset\n+  \/\/      |                     |\n@@ -649,1 +657,0 @@\n-  Label call_return;\n@@ -665,1 +672,1 @@\n-  __ block_comment(\"{ get_thread\");\n+  __ block_comment(\"{ on_entry\");\n@@ -667,1 +674,1 @@\n-  __ lea(c_rarg0, Address(rsp, should_detach_offset));\n+  __ lea(c_rarg0, Address(rsp, frame_data_offset));\n@@ -669,1 +676,1 @@\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ProgrammableUpcallHandler::maybe_attach_and_get_thread)));\n+  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ProgrammableUpcallHandler::on_entry)));\n@@ -672,40 +679,1 @@\n-  __ movptr(Address(rsp, thread_offset), r15_thread);\n-  __ block_comment(\"} get_thread\");\n-\n-  \/\/ TODO:\n-  \/\/ We expect not to be coming from JNI code, but we might be.\n-  \/\/ We should figure out what our stance is on supporting that and then maybe add\n-  \/\/ some more handling here for:\n-  \/\/   - handle blocks\n-  \/\/   - check for active exceptions (and emit an error)\n-\n-  __ block_comment(\"{ safepoint poll\");\n-  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native_trans);\n-\n-  if (os::is_MP()) {\n-    __ membar(Assembler::Membar_mask_bits(\n-                Assembler::LoadLoad  | Assembler::StoreLoad |\n-                Assembler::LoadStore | Assembler::StoreStore));\n-   }\n-\n-  \/\/ check for safepoint operation in progress and\/or pending suspend requests\n-  Label L_after_safepoint_poll;\n-  Label L_safepoint_poll_slow_path;\n-\n-  __ safepoint_poll(L_safepoint_poll_slow_path, r15_thread, false \/* at_return *\/, false \/* in_nmethod *\/);\n-\n-  __ cmpl(Address(r15_thread, JavaThread::suspend_flags_offset()), 0);\n-  __ jcc(Assembler::notEqual, L_safepoint_poll_slow_path);\n-\n-  __ bind(L_after_safepoint_poll);\n-  __ block_comment(\"} safepoint poll\");\n-  \/\/ change thread state\n-  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_Java);\n-\n-  __ block_comment(\"{ reguard stack check\");\n-  Label L_reguard;\n-  Label L_after_reguard;\n-  __ cmpl(Address(r15_thread, JavaThread::stack_guard_state_offset()), StackOverflow::stack_guard_yellow_reserved_disabled);\n-  __ jcc(Assembler::equal, L_reguard);\n-  __ bind(L_after_reguard);\n-  __ block_comment(\"} reguard stack check\");\n+  __ block_comment(\"} on_entry\");\n@@ -727,0 +695,10 @@\n+\n+  __ call(Address(rbx, Method::from_compiled_offset()));\n+\n+  save_java_result(_masm, conv, res_save_area_offset);\n+\n+  __ block_comment(\"{ on_exit\");\n+  __ vzeroupper();\n+  __ lea(c_rarg0, Address(rsp, frame_data_offset));\n+  \/\/ stack already aligned\n+  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ProgrammableUpcallHandler::on_exit)));\n@@ -728,0 +706,1 @@\n+  __ block_comment(\"} on_exit\");\n@@ -729,2 +708,1 @@\n-  save_java_frame_anchor(_masm, jfa_offset, r15_thread);\n-  __ reset_last_Java_frame(r15_thread, true);\n+  restore_callee_saved_registers(_masm, abi, reg_save_area_offset);\n@@ -732,1 +710,1 @@\n-  __ call(Address(rbx, Method::from_compiled_offset()));\n+  restore_java_result(_masm, conv, res_save_area_offset);\n@@ -734,0 +712,1 @@\n+  \/\/ return value shuffle\n@@ -760,21 +739,0 @@\n-  __ bind(call_return);\n-\n-  \/\/ also sets last Java frame\n-  __ movptr(r15_thread, Address(rsp, thread_offset));\n-  \/\/ TODO corrupted thread pointer causes havoc. Can we verify it here?\n-  restore_java_frame_anchor(_masm, jfa_offset, r15_thread); \/\/ also transitions to native state\n-\n-  __ block_comment(\"{ maybe_detach_thread\");\n-  Label L_after_detach;\n-  __ cmpb(Address(rsp, should_detach_offset), 0);\n-  __ jcc(Assembler::equal, L_after_detach);\n-  __ vzeroupper();\n-  __ mov(c_rarg0, r15_thread);\n-  \/\/ stack already aligned\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ProgrammableUpcallHandler::detach_thread)));\n-  __ reinit_heapbase();\n-  __ bind(L_after_detach);\n-  __ block_comment(\"} maybe_detach_thread\");\n-\n-  restore_callee_saved_registers(_masm, abi, reg_save_area_offset);\n-\n@@ -786,23 +744,0 @@\n-  __ block_comment(\"{ L_safepoint_poll_slow_path\");\n-  __ bind(L_safepoint_poll_slow_path);\n-  __ vzeroupper();\n-  __ mov(c_rarg0, r15_thread);\n-  \/\/ stack already aligned\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans)));\n-  __ reinit_heapbase();\n-  __ jmp(L_after_safepoint_poll);\n-  __ block_comment(\"} L_safepoint_poll_slow_path\");\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  __ block_comment(\"{ L_reguard\");\n-  __ bind(L_reguard);\n-  __ vzeroupper();\n-  \/\/ stack already aligned\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages)));\n-  __ reinit_heapbase();\n-  __ jmp(L_after_reguard);\n-  __ block_comment(\"} L_reguard\");\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n@@ -838,1 +773,1 @@\n-  OptimizedEntryBlob* blob = OptimizedEntryBlob::create(name, &buffer, exception_handler_offset, receiver, jfa_offset);\n+  OptimizedEntryBlob* blob = OptimizedEntryBlob::create(name, &buffer, exception_handler_offset, receiver, in_ByteSize(frame_data_offset));\n","filename":"src\/hotspot\/cpu\/x86\/universalUpcallHandler_x86_64.cpp","additions":83,"deletions":148,"binary":false,"changes":231,"status":"modified"},{"patch":"@@ -64,0 +64,5 @@\n+OptimizedEntryBlob::FrameData* OptimizedEntryBlob::frame_data_for_frame(const frame& frame) const {\n+  ShouldNotCallThis();\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/cpu\/zero\/frame_zero.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+#include \"runtime\/javaFrameAnchor.hpp\"\n+#include \"runtime\/jniHandles.hpp\"\n@@ -716,1 +718,1 @@\n-                     jobject receiver, ByteSize jfa_sp_offset) :\n+                                       jobject receiver, ByteSize frame_data_offset) :\n@@ -720,1 +722,1 @@\n-  _jfa_sp_offset(jfa_sp_offset) {\n+  _frame_data_offset(frame_data_offset) {\n@@ -725,1 +727,1 @@\n-                             jobject receiver, ByteSize jfa_sp_offset) {\n+                                               jobject receiver, ByteSize frame_data_offset) {\n@@ -732,1 +734,1 @@\n-    blob = new (size) OptimizedEntryBlob(name, size, cb, exception_handler_offset, receiver, jfa_sp_offset);\n+    blob = new (size) OptimizedEntryBlob(name, size, cb, exception_handler_offset, receiver, frame_data_offset);\n@@ -739,0 +741,8 @@\n+\n+void OptimizedEntryBlob::oops_do(OopClosure* f, const frame& frame) {\n+  frame_data_for_frame(frame)->old_handles->oops_do(f);\n+}\n+\n+JavaFrameAnchor* OptimizedEntryBlob::jfa_for_frame(const frame& frame) const {\n+  return &frame_data_for_frame(frame)->jfa;\n+}\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/javaFrameAnchor.hpp\"\n@@ -37,0 +38,1 @@\n+class JNIHandleBlock;\n@@ -80,1 +82,1 @@\n-class JavaFrameAnchor; \/\/ for EntryBlob::jfa_for_frame\n+class JavaFrameAnchor; \/\/ for OptimizedEntryBlob::jfa_for_frame\n@@ -729,1 +731,2 @@\n-\/\/ For optimized upcall stubs\n+class ProgrammableUpcallHandler;\n+\n@@ -731,0 +734,1 @@\n+  friend class ProgrammableUpcallHandler;\n@@ -734,1 +738,1 @@\n-  ByteSize _jfa_sp_offset;\n+  ByteSize _frame_data_offset;\n@@ -737,1 +741,9 @@\n-            jobject receiver, ByteSize jfa_sp_offset);\n+                     jobject receiver, ByteSize frame_data_offset);\n+\n+  struct FrameData {\n+    JavaFrameAnchor jfa;\n+    JavaThread* thread;\n+    JNIHandleBlock* old_handles;\n+    JNIHandleBlock* new_handles;\n+    bool should_detach;\n+  };\n@@ -739,0 +751,2 @@\n+  \/\/ defined in frame_ARCH.cpp\n+  FrameData* frame_data_for_frame(const frame& frame) const;\n@@ -742,2 +756,2 @@\n-                           intptr_t exception_handler_offset, jobject receiver,\n-                           ByteSize jfa_sp_offset);\n+                                    intptr_t exception_handler_offset, jobject receiver,\n+                                    ByteSize frame_data_offset);\n@@ -747,1 +761,0 @@\n-  ByteSize jfa_sp_offset() const { return _jfa_sp_offset; }\n@@ -749,1 +762,0 @@\n-  \/\/ defined in frame_ARCH.cpp\n@@ -752,0 +764,2 @@\n+  void oops_do(OopClosure* f, const frame& frame);\n+\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":22,"deletions":8,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -54,2 +54,2 @@\n-Thread* ProgrammableUpcallHandler::maybe_attach_and_get_thread(bool* should_detach) {\n-  Thread* thread = Thread::current_or_null();\n+JavaThread* ProgrammableUpcallHandler::maybe_attach_and_get_thread(bool* should_detach) {\n+  JavaThread* thread = JavaThread::current_or_null();\n@@ -62,1 +62,2 @@\n-    thread = Thread::current();\n+    thread = JavaThread::current();\n+    assert(!thread->has_last_Java_frame(), \"newly-attached thread not expected to have last Java frame\");\n@@ -69,1 +70,1 @@\n-void ProgrammableUpcallHandler::detach_thread(Thread* thread) {\n+void ProgrammableUpcallHandler::detach_current_thread() {\n@@ -74,0 +75,79 @@\n+\/\/ modelled after JavaCallWrapper::JavaCallWrapper\n+JavaThread* ProgrammableUpcallHandler::on_entry(OptimizedEntryBlob::FrameData* context) {\n+  JavaThread* thread = maybe_attach_and_get_thread(&context->should_detach);\n+  context->thread = thread;\n+\n+  assert(thread->can_call_java(), \"must be able to call Java\");\n+\n+  \/\/ Allocate handle block for Java code. This must be done before we change thread_state to _thread_in_Java,\n+  \/\/ since it can potentially block.\n+  context->new_handles = JNIHandleBlock::allocate_block(thread);\n+\n+  \/\/ After this, we are officially in Java Code. This needs to be done before we change any of the thread local\n+  \/\/ info, since we cannot find oops before the new information is set up completely.\n+  ThreadStateTransition::transition_from_native(thread, _thread_in_Java);\n+\n+  \/\/ Make sure that we handle asynchronous stops and suspends _before_ we clear all thread state\n+  \/\/ in OptimizedEntryBlob::FrameData. This way, we can decide if we need to do any pd actions\n+  \/\/ to prepare for stop\/suspend (cache sp, or other state).\n+  bool clear_pending_exception = true;\n+  if (thread->has_special_runtime_exit_condition()) {\n+    thread->handle_special_runtime_exit_condition();\n+    if (thread->has_pending_exception()) {\n+      clear_pending_exception = false;\n+    }\n+  }\n+\n+  context->old_handles = thread->active_handles();\n+\n+  \/\/ For the profiler, the last_Java_frame information in thread must always be in\n+  \/\/ legal state. We have no last Java frame if last_Java_sp == NULL so\n+  \/\/ the valid transition is to clear _last_Java_sp and then reset the rest of\n+  \/\/ the (platform specific) state.\n+\n+  context->jfa.copy(thread->frame_anchor());\n+  thread->frame_anchor()->clear();\n+\n+  debug_only(thread->inc_java_call_counter());\n+  thread->set_active_handles(context->new_handles);     \/\/ install new handle block and reset Java frame linkage\n+\n+  \/\/ clear any pending exception in thread (native calls start with no exception pending)\n+  if (clear_pending_exception) {\n+    thread->clear_pending_exception();\n+  }\n+\n+  MACOS_AARCH64_ONLY(thread->enable_wx(WXExec));\n+\n+  return thread;\n+}\n+\n+\/\/ modelled after JavaCallWrapper::~JavaCallWrapper\n+void ProgrammableUpcallHandler::on_exit(OptimizedEntryBlob::FrameData* context) {\n+  JavaThread* thread = context->thread;\n+  assert(thread == JavaThread::current(), \"must still be the same thread\");\n+\n+  MACOS_AARCH64_ONLY(thread->enable_wx(WXWrite));\n+\n+  \/\/ restore previous handle block\n+  thread->set_active_handles(context->old_handles);\n+\n+  thread->frame_anchor()->zap();\n+\n+  debug_only(thread->dec_java_call_counter());\n+\n+  \/\/ Old thread-local info. has been restored. We are now back in native code.\n+  ThreadStateTransition::transition_from_java(thread, _thread_in_native);\n+\n+  thread->frame_anchor()->copy(&context->jfa);\n+\n+  \/\/ Release handles after we are marked as being in native code again, since this\n+  \/\/ operation might block\n+  JNIHandleBlock::release_block(context->new_handles, thread);\n+\n+  assert(!thread->has_pending_exception(), \"Upcall can not throw an exception\");\n+\n+  if (context->should_detach) {\n+    detach_current_thread();\n+  }\n+}\n+\n@@ -76,1 +156,1 @@\n-  Thread* thread = maybe_attach_and_get_thread(&should_detach);\n+  JavaThread* thread = maybe_attach_and_get_thread(&should_detach);\n@@ -80,1 +160,1 @@\n-    upcall_helper(thread->as_Java_thread(), rec, buff);\n+    upcall_helper(thread, rec, buff);\n@@ -84,1 +164,1 @@\n-    detach_thread(thread);\n+    detach_current_thread();\n","filename":"src\/hotspot\/share\/prims\/universalUpcallHandler.cpp","additions":87,"deletions":7,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"code\/codeBlob.hpp\"\n@@ -50,2 +51,5 @@\n-  static Thread* maybe_attach_and_get_thread(bool* should_detach);\n-  static void detach_thread(Thread* thread);\n+  static JavaThread* maybe_attach_and_get_thread(bool* should_detach);\n+  static void detach_current_thread();\n+\n+  static JavaThread* on_entry(OptimizedEntryBlob::FrameData* context);\n+  static void on_exit(OptimizedEntryBlob::FrameData* context);\n","filename":"src\/hotspot\/share\/prims\/universalUpcallHandler.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1071,3 +1071,1 @@\n-   \/\/ Nothing to do\n-   \/\/ receiver is a global ref\n-   \/\/ handle block is for JNI\n+    _cb->as_optimized_entry_blob()->oops_do(f, *this);\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+class ProgrammableUpcallHandler;\n@@ -55,0 +56,1 @@\n+friend class ProgrammableUpcallHandler;\n","filename":"src\/hotspot\/share\/runtime\/javaFrameAnchor.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -931,0 +931,1 @@\n+    HandleMark hm(self);\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1967,0 +1967,9 @@\n+#ifdef ASSERT\n+void JavaThread::verify_frame_info() {\n+  assert((!has_last_Java_frame() && java_call_counter() == 0) ||\n+         (has_last_Java_frame() && java_call_counter() > 0),\n+         \"unexpected frame info: has_last_frame=%s, java_call_counter=%d\",\n+         has_last_Java_frame() ? \"true\" : \"false\", java_call_counter());\n+}\n+#endif\n+\n@@ -1974,2 +1983,1 @@\n-  assert((!has_last_Java_frame() && java_call_counter() == 0) ||\n-         (has_last_Java_frame() && java_call_counter() > 0), \"wrong java_sp info!\");\n+  DEBUG_ONLY(verify_frame_info();)\n@@ -2023,4 +2031,1 @@\n-  assert((!has_last_Java_frame() && java_call_counter() == 0) ||\n-         (has_last_Java_frame() && java_call_counter() > 0),\n-         \"unexpected frame info: has_last_frame=%d, java_call_counter=%d\",\n-         has_last_Java_frame(), java_call_counter());\n+  verify_frame_info();\n@@ -2031,4 +2036,1 @@\n-  assert((!has_last_Java_frame() && java_call_counter() == 0) ||\n-         (has_last_Java_frame() && java_call_counter() > 0),\n-         \"unexpected frame info: has_last_frame=%d, java_call_counter=%d\",\n-         has_last_Java_frame(), java_call_counter());\n+  DEBUG_ONLY(verify_frame_info();)\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1128,0 +1128,2 @@\n+  DEBUG_ONLY(void verify_frame_info();)\n+\n@@ -1424,0 +1426,2 @@\n+  \/\/ Returns the current thread as a JavaThread, or NULL if not attached\n+  static inline JavaThread* current_or_null();\n@@ -1594,0 +1598,5 @@\n+inline JavaThread* JavaThread::current_or_null() {\n+  Thread* current = Thread::current_or_null();\n+  return current != nullptr ? current->as_Java_thread() : nullptr;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @test\n+ * @test id=default_gc\n@@ -50,0 +50,57 @@\n+\/*\n+ * @test id=zgc\n+ * @requires (((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\")\n+ * @requires vm.gc.Z\n+ * @library \/test\/lib\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm\n+ *   -Xbootclasspath\/a:.\n+ *   -XX:+UnlockDiagnosticVMOptions\n+ *   -XX:+WhiteBoxAPI\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Xbatch\n+ *   -XX:+UseZGC\n+ *   TestAsyncStackWalk\n+ *\n+ * @run main\/othervm\n+ *   -Xbootclasspath\/a:.\n+ *   -XX:+UnlockDiagnosticVMOptions\n+ *   -XX:+WhiteBoxAPI\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Xbatch\n+ *   -XX:+UseZGC\n+ *   TestAsyncStackWalk\n+ *\/\n+\/*\n+ * @test id=shenandoah\n+ * @requires (((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\")\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm\n+ *   -Xbootclasspath\/a:.\n+ *   -XX:+UnlockDiagnosticVMOptions\n+ *   -XX:+WhiteBoxAPI\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Xbatch\n+ *   -XX:+UseShenandoahGC\n+ *   TestAsyncStackWalk\n+ *\n+ * @run main\/othervm\n+ *   -Xbootclasspath\/a:.\n+ *   -XX:+UnlockDiagnosticVMOptions\n+ *   -XX:+WhiteBoxAPI\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Xbatch\n+ *   -XX:+UseShenandoahGC\n+ *   TestAsyncStackWalk\n+ *\/\n+\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestAsyncStackWalk.java","additions":58,"deletions":1,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @test\n+ * @test id=default_gc\n@@ -50,0 +50,57 @@\n+\/*\n+ * @test id=zgc\n+ * @requires (((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\")\n+ * @requires vm.gc.Z\n+ * @library \/test\/lib\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm\n+ *   -Xbootclasspath\/a:.\n+ *   -XX:+UnlockDiagnosticVMOptions\n+ *   -XX:+WhiteBoxAPI\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Xbatch\n+ *   -XX:+UseZGC\n+ *   TestStackWalk\n+ *\n+ * @run main\/othervm\n+ *   -Xbootclasspath\/a:.\n+ *   -XX:+UnlockDiagnosticVMOptions\n+ *   -XX:+WhiteBoxAPI\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Xbatch\n+ *   -XX:+UseZGC\n+ *   TestStackWalk\n+ *\/\n+\/*\n+ * @test id=shenandoah\n+ * @requires (((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\")\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm\n+ *   -Xbootclasspath\/a:.\n+ *   -XX:+UnlockDiagnosticVMOptions\n+ *   -XX:+WhiteBoxAPI\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Xbatch\n+ *   -XX:+UseShenandoahGC\n+ *   TestStackWalk\n+ *\n+ * @run main\/othervm\n+ *   -Xbootclasspath\/a:.\n+ *   -XX:+UnlockDiagnosticVMOptions\n+ *   -XX:+WhiteBoxAPI\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Xbatch\n+ *   -XX:+UseShenandoahGC\n+ *   TestStackWalk\n+ *\/\n+\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestStackWalk.java","additions":58,"deletions":1,"binary":false,"changes":59,"status":"modified"}]}