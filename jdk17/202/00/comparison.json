{"files":[{"patch":"@@ -775,2 +775,2 @@\n-            JCExpression e = parsedType == null ? term(EXPR | TYPE | NOLAMBDA) : parsedType;\n-            mods = mods != null ? mods : F.at(token.pos).Modifiers(0);\n+            mods = mods != null ? mods : optFinal(0);\n+            JCExpression e = parsedType == null ? term(TYPE | NOLAMBDA) : parsedType;\n@@ -1697,4 +1697,0 @@\n-    ParensResult analyzeParens() {\n-        return analyzeParens(0);\n-    }\n-\n@@ -1702,1 +1698,1 @@\n-    ParensResult analyzeParens(int startLookahead) {\n+    ParensResult analyzeParens() {\n@@ -1706,1 +1702,1 @@\n-        outer: for (int lookahead = startLookahead; ; lookahead++) {\n+        outer: for (int lookahead = 0; ; lookahead++) {\n@@ -1732,1 +1728,1 @@\n-                    if (lookahead != startLookahead) {\n+                    if (lookahead != 0) {\n@@ -1783,25 +1779,1 @@\n-                    lookahead += 1; \/\/skip '@'\n-                    while (peekToken(lookahead, DOT)) {\n-                        lookahead += 2;\n-                    }\n-                    if (peekToken(lookahead, LPAREN)) {\n-                        lookahead++;\n-                        \/\/skip annotation values\n-                        int nesting = 0;\n-                        for (; ; lookahead++) {\n-                            TokenKind tk2 = S.token(lookahead).kind;\n-                            switch (tk2) {\n-                                case EOF:\n-                                    return ParensResult.PARENS;\n-                                case LPAREN:\n-                                    nesting++;\n-                                    break;\n-                                case RPAREN:\n-                                    nesting--;\n-                                    if (nesting == 0) {\n-                                        continue outer;\n-                                    }\n-                                break;\n-                            }\n-                        }\n-                    }\n+                    lookahead = skipAnnotation(lookahead);\n@@ -1864,0 +1836,29 @@\n+    private int skipAnnotation(int lookahead) {\n+        lookahead += 1; \/\/skip '@'\n+        while (peekToken(lookahead, DOT)) {\n+            lookahead += 2;\n+        }\n+        if (peekToken(lookahead, LPAREN)) {\n+            lookahead++;\n+            \/\/skip annotation values\n+            int nesting = 0;\n+            for (; ; lookahead++) {\n+                TokenKind tk2 = S.token(lookahead).kind;\n+                switch (tk2) {\n+                    case EOF:\n+                        return lookahead;\n+                    case LPAREN:\n+                        nesting++;\n+                        break;\n+                    case RPAREN:\n+                        nesting--;\n+                        if (nesting == 0) {\n+                            return lookahead;\n+                        }\n+                    break;\n+                }\n+            }\n+        }\n+        return lookahead;\n+    }\n+\n@@ -3070,12 +3071,10 @@\n-            if (token.kind == LPAREN) {\n-                int lookahead = 0;\n-                while (S.token(lookahead + 1).kind == LPAREN) {\n-                    lookahead++;\n-                }\n-                boolean pattern = analyzeParens(lookahead) == ParensResult.EXPLICIT_LAMBDA;\n-                if (pattern) {\n-                    checkSourceLevel(token.pos, Feature.PATTERN_SWITCH);\n-                    return parsePattern(token.pos, null, null, false);\n-                } else {\n-                    return term(EXPR | TYPE | NOLAMBDA);\n-                }\n+            int lookahead = 0;\n+            while (S.token(lookahead).kind == LPAREN) {\n+                lookahead++;\n+            }\n+            JCModifiers mods = optFinal(0);\n+            boolean pattern = mods.flags != 0 || mods.annotations.nonEmpty() ||\n+                              analyzePattern(lookahead) == PatternResult.PATTERN;\n+            if (pattern) {\n+                checkSourceLevel(token.pos, Feature.PATTERN_SWITCH);\n+                return parsePattern(patternPos, mods, null, false);\n@@ -3083,9 +3082,1 @@\n-                JCModifiers mods = optFinal(0);\n-                JCExpression e = term(EXPR | TYPE | NOLAMBDA);\n-\n-                if (token.kind == IDENTIFIER || mods.flags != 0 || mods.annotations.nonEmpty()) {\n-                    checkSourceLevel(token.pos, Feature.PATTERN_SWITCH);\n-                    return parsePattern(patternPos, null, e, false);\n-                } else {\n-                    return e;\n-                }\n+                return term(EXPR | NOLAMBDA);\n@@ -3098,0 +3089,45 @@\n+    @SuppressWarnings(\"fallthrough\")\n+    PatternResult analyzePattern(int lookahead) {\n+        int depth = 0;\n+        while (true) {\n+            TokenKind token = S.token(lookahead).kind;\n+            switch (token) {\n+                case BYTE: case SHORT: case INT: case LONG: case FLOAT:\n+                case DOUBLE: case BOOLEAN: case CHAR: case VOID:\n+                case ASSERT, ENUM, IDENTIFIER, UNDERSCORE:\n+                    if (depth == 0 && peekToken(lookahead, LAX_IDENTIFIER)) return PatternResult.PATTERN;\n+                    break;\n+                case DOT, QUES, EXTENDS, SUPER, COMMA: break;\n+                case LT: depth++; break;\n+                case GTGTGT: depth--;\n+                case GTGT: depth--;\n+                case GT:\n+                    depth--;\n+                    if (depth == 0) {\n+                         return peekToken(lookahead, LAX_IDENTIFIER) ? PatternResult.PATTERN\n+                                                          : PatternResult.EXPRESSION;\n+                    } else if (depth < 0) return PatternResult.EXPRESSION;\n+                    break;\n+                case MONKEYS_AT:\n+                    lookahead = skipAnnotation(lookahead);\n+                    break;\n+                case LBRACKET:\n+                    if (peekToken(lookahead, RBRACKET, LAX_IDENTIFIER)) {\n+                        return PatternResult.PATTERN;\n+                    } else if (peekToken(lookahead, RBRACKET)) {\n+                        lookahead++;\n+                        break;\n+                    } else {\n+                        return PatternResult.EXPRESSION;\n+                    }\n+                default: return PatternResult.EXPRESSION;\n+            }\n+            lookahead++;\n+        }\n+    }\n+\n+    private enum PatternResult {\n+        EXPRESSION,\n+        PATTERN;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":91,"deletions":55,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -1,102 +0,0 @@\n-\/**\n- * @test\n- * @modules jdk.compiler\/com.sun.tools.javac.file\n- *          jdk.compiler\/com.sun.tools.javac.main\n- *          jdk.compiler\/com.sun.tools.javac.parser\n- *          jdk.compiler\/com.sun.tools.javac.tree\n- *          jdk.compiler\/com.sun.tools.javac.util\n- * @compile --enable-preview -source ${jdk.version} DisambiguateParenthesizedPattern.java\n- * @run main\/othervm --enable-preview DisambiguateParenthesizedPattern\n- *\/\n-\n-import com.sun.source.tree.CaseLabelTree;\n-import com.sun.source.tree.ClassTree;\n-import com.sun.source.tree.CompilationUnitTree;\n-import com.sun.source.tree.ExpressionTree;\n-import com.sun.source.tree.MethodTree;\n-import com.sun.source.tree.PatternTree;\n-import com.sun.source.tree.SwitchTree;\n-import com.sun.tools.javac.file.JavacFileManager;\n-import com.sun.tools.javac.parser.JavacParser;\n-import com.sun.tools.javac.parser.ParserFactory;\n-import com.sun.tools.javac.util.Context;\n-import com.sun.tools.javac.main.Option;\n-import com.sun.tools.javac.util.Options;\n-import java.nio.charset.Charset;\n-\n-public class DisambiguateParenthesizedPattern {\n-\n-    public static void main(String... args) throws Throwable {\n-        DisambiguateParenthesizedPattern test = new DisambiguateParenthesizedPattern();\n-        test.disambiguationTest(\"String s\",\n-                                 ExpressionType.PATTERN);\n-        test.disambiguationTest(\"String s && s.isEmpty()\",\n-                                 ExpressionType.PATTERN);\n-        test.disambiguationTest(\"(String s)\",\n-                                 ExpressionType.PATTERN);\n-        test.disambiguationTest(\"((String s))\",\n-                                 ExpressionType.PATTERN);\n-        test.disambiguationTest(\"(String) s\",\n-                                 ExpressionType.EXPRESSION);\n-        test.disambiguationTest(\"((String) s)\",\n-                                 ExpressionType.EXPRESSION);\n-        test.disambiguationTest(\"((0x1))\",\n-                                 ExpressionType.EXPRESSION);\n-        test.disambiguationTest(\"(a > b)\",\n-                                 ExpressionType.EXPRESSION);\n-        test.disambiguationTest(\"(a >> b)\",\n-                                 ExpressionType.EXPRESSION);\n-        test.disambiguationTest(\"(a >>> b)\",\n-                                 ExpressionType.EXPRESSION);\n-        test.disambiguationTest(\"(a < b | a > b)\",\n-                                 ExpressionType.EXPRESSION);\n-        test.disambiguationTest(\"(a << b | a >> b)\",\n-                                 ExpressionType.EXPRESSION);\n-        test.disambiguationTest(\"(a << b || a < b | a >>> b)\",\n-                                 ExpressionType.EXPRESSION);\n-        test.disambiguationTest(\"(a < c.d > b)\",\n-                                 ExpressionType.PATTERN);\n-    }\n-\n-    private final ParserFactory factory;\n-\n-    public DisambiguateParenthesizedPattern() {\n-        Context context = new Context();\n-        JavacFileManager jfm = new JavacFileManager(context, true, Charset.defaultCharset());\n-        Options.instance(context).put(Option.PREVIEW, \"\");\n-        factory = ParserFactory.instance(context);\n-    }\n-\n-    void disambiguationTest(String snippet, ExpressionType expectedType) {\n-        String code = \"\"\"\n-                      public class Test {\n-                          private void test() {\n-                              switch (null) {\n-                                  case SNIPPET -> {}\n-                              }\n-                          }\n-                      }\n-                      \"\"\".replace(\"SNIPPET\", snippet);\n-        JavacParser parser = factory.newParser(code, false, false, false);\n-        CompilationUnitTree result = parser.parseCompilationUnit();\n-        ClassTree clazz = (ClassTree) result.getTypeDecls().get(0);\n-        MethodTree method = (MethodTree) clazz.getMembers().get(0);\n-        SwitchTree st = (SwitchTree) method.getBody().getStatements().get(0);\n-        CaseLabelTree label = st.getCases().get(0).getLabels().get(0);\n-        ExpressionType actualType = switch (label) {\n-            case ExpressionTree et -> ExpressionType.EXPRESSION;\n-            case PatternTree pt -> ExpressionType.PATTERN;\n-            default -> throw new AssertionError(\"Unexpected result: \" + result);\n-        };\n-        if (expectedType != actualType) {\n-            throw new AssertionError(\"Expected: \" + expectedType + \", actual: \" + actualType +\n-                                      \", for: \" + code + \", parsed: \" + result);\n-        }\n-    }\n-\n-    enum ExpressionType {\n-        PATTERN,\n-        EXPRESSION;\n-    }\n-\n-}\n","filename":"test\/langtools\/tools\/javac\/patterns\/DisambiguateParenthesizedPattern.java","additions":0,"deletions":102,"binary":false,"changes":102,"status":"deleted"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @modules jdk.compiler\/com.sun.tools.javac.file\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.parser\n+ *          jdk.compiler\/com.sun.tools.javac.tree\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @compile --enable-preview -source ${jdk.version} DisambiguatePatterns.java\n+ * @run main\/othervm --enable-preview DisambiguatePatterns\n+ *\/\n+\n+import com.sun.source.tree.CaseLabelTree;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.PatternTree;\n+import com.sun.source.tree.SwitchTree;\n+import com.sun.tools.javac.file.JavacFileManager;\n+import com.sun.tools.javac.parser.JavacParser;\n+import com.sun.tools.javac.parser.ParserFactory;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.main.Option;\n+import com.sun.tools.javac.util.Options;\n+import java.nio.charset.Charset;\n+\n+public class DisambiguatePatterns {\n+\n+    public static void main(String... args) throws Throwable {\n+        DisambiguatePatterns test = new DisambiguatePatterns();\n+        test.disambiguationTest(\"String s\",\n+                                 ExpressionType.PATTERN);\n+        test.disambiguationTest(\"String s && s.isEmpty()\",\n+                                 ExpressionType.PATTERN);\n+        test.disambiguationTest(\"(String s)\",\n+                                 ExpressionType.PATTERN);\n+        test.disambiguationTest(\"(@Ann String s)\",\n+                                 ExpressionType.PATTERN);\n+        test.disambiguationTest(\"((String s))\",\n+                                 ExpressionType.PATTERN);\n+        test.disambiguationTest(\"(String) s\",\n+                                 ExpressionType.EXPRESSION);\n+        test.disambiguationTest(\"((String) s)\",\n+                                 ExpressionType.EXPRESSION);\n+        test.disambiguationTest(\"((0x1))\",\n+                                 ExpressionType.EXPRESSION);\n+        test.disambiguationTest(\"(a > b)\",\n+                                 ExpressionType.EXPRESSION);\n+        test.disambiguationTest(\"(a >> b)\",\n+                                 ExpressionType.EXPRESSION);\n+        test.disambiguationTest(\"(a >>> b)\",\n+                                 ExpressionType.EXPRESSION);\n+        test.disambiguationTest(\"(a < b | a > b)\",\n+                                 ExpressionType.EXPRESSION);\n+        test.disambiguationTest(\"(a << b | a >> b)\",\n+                                 ExpressionType.EXPRESSION);\n+        test.disambiguationTest(\"(a << b || a < b | a >>> b)\",\n+                                 ExpressionType.EXPRESSION);\n+        test.disambiguationTest(\"(a < c.d > b)\",\n+                                 ExpressionType.PATTERN);\n+        test.disambiguationTest(\"a<? extends c.d> b\",\n+                                 ExpressionType.PATTERN);\n+        test.disambiguationTest(\"@Ann a<? extends c.d> b\",\n+                                 ExpressionType.PATTERN);\n+        test.disambiguationTest(\"a<? extends @Ann c.d> b\",\n+                                 ExpressionType.PATTERN);\n+        test.disambiguationTest(\"a<? super c.d> b\",\n+                                 ExpressionType.PATTERN);\n+        test.disambiguationTest(\"a<? super @Ann c.d> b\",\n+                                 ExpressionType.PATTERN);\n+        test.disambiguationTest(\"a<b<c.d>> b\",\n+                                 ExpressionType.PATTERN);\n+        test.disambiguationTest(\"a<b<@Ann c.d>> b\",\n+                                 ExpressionType.PATTERN);\n+        test.disambiguationTest(\"a<b<c<d>>> b\",\n+                                 ExpressionType.PATTERN);\n+        test.disambiguationTest(\"a[] b\",\n+                                 ExpressionType.PATTERN);\n+        test.disambiguationTest(\"a[][] b\",\n+                                 ExpressionType.PATTERN);\n+        test.disambiguationTest(\"int i\",\n+                                 ExpressionType.PATTERN);\n+        test.disambiguationTest(\"int[] i\",\n+                                 ExpressionType.PATTERN);\n+        test.disambiguationTest(\"a[a]\",\n+                                 ExpressionType.EXPRESSION);\n+        test.disambiguationTest(\"a[b][c]\",\n+                                 ExpressionType.EXPRESSION);\n+        test.disambiguationTest(\"a & b\",\n+                                 ExpressionType.EXPRESSION);\n+    }\n+\n+    private final ParserFactory factory;\n+\n+    public DisambiguatePatterns() {\n+        Context context = new Context();\n+        JavacFileManager jfm = new JavacFileManager(context, true, Charset.defaultCharset());\n+        Options.instance(context).put(Option.PREVIEW, \"\");\n+        factory = ParserFactory.instance(context);\n+    }\n+\n+    void disambiguationTest(String snippet, ExpressionType expectedType) {\n+        String code = \"\"\"\n+                      public class Test {\n+                          private void test() {\n+                              switch (null) {\n+                                  case SNIPPET -> {}\n+                              }\n+                          }\n+                      }\n+                      \"\"\".replace(\"SNIPPET\", snippet);\n+        JavacParser parser = factory.newParser(code, false, false, false);\n+        CompilationUnitTree result = parser.parseCompilationUnit();\n+        ClassTree clazz = (ClassTree) result.getTypeDecls().get(0);\n+        MethodTree method = (MethodTree) clazz.getMembers().get(0);\n+        SwitchTree st = (SwitchTree) method.getBody().getStatements().get(0);\n+        CaseLabelTree label = st.getCases().get(0).getLabels().get(0);\n+        ExpressionType actualType = switch (label) {\n+            case ExpressionTree et -> ExpressionType.EXPRESSION;\n+            case PatternTree pt -> ExpressionType.PATTERN;\n+            default -> throw new AssertionError(\"Unexpected result: \" + result);\n+        };\n+        if (expectedType != actualType) {\n+            throw new AssertionError(\"Expected: \" + expectedType + \", actual: \" + actualType +\n+                                      \", for: \" + code + \", parsed: \" + result);\n+        }\n+    }\n+\n+    enum ExpressionType {\n+        PATTERN,\n+        EXPRESSION;\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/DisambiguatePatterns.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -0,0 +1,19 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8268859\n+ * @summary Verify error recovery\/disambiguation of case labels that mix expressions and patterns\n+ * @compile\/fail\/ref=PatternCaseErrorRecovery.out --enable-preview -source ${jdk.version} -XDrawDiagnostics PatternCaseErrorRecovery.java\n+ *\/\n+\n+public class PatternCaseErrorRecovery {\n+    Object expressionLikeType(Object o1, Object o2) {\n+        final int a = 1;\n+        final int b = 2;\n+        return switch (o1) {\n+            case true t -> o2;\n+            case 1 + 1 e -> o2;\n+            case a < b ? a : b e -> o2;\n+            default -> null;\n+        };\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/PatternCaseErrorRecovery.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+PatternCaseErrorRecovery.java:13:22: compiler.err.expected2: :, ->\n+PatternCaseErrorRecovery.java:13:23: compiler.err.not.stmt\n+PatternCaseErrorRecovery.java:14:23: compiler.err.expected2: :, ->\n+PatternCaseErrorRecovery.java:14:24: compiler.err.not.stmt\n+PatternCaseErrorRecovery.java:15:31: compiler.err.expected2: :, ->\n+PatternCaseErrorRecovery.java:15:32: compiler.err.not.stmt\n+6 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/PatternCaseErrorRecovery.out","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+PatternErrorRecovery.java:12:18: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.pattern.switch)\n+PatternErrorRecovery.java:11:18: compiler.err.const.expr.req\n+2 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/PatternErrorRecovery-no-preview.out","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8268320\n+ * @summary Verify user-friendly errors are reported for ill-formed pattern.\n+* @compile\/fail\/ref=PatternErrorRecovery.out -XDrawDiagnostics -XDshould-stop.at=FLOW --enable-preview -source ${jdk.version} PatternErrorRecovery.java\n+ * @compile\/fail\/ref=PatternErrorRecovery-no-preview.out -XDrawDiagnostics -XDshould-stop.at=FLOW PatternErrorRecovery.java\n+ *\/\n+public class PatternErrorRecovery {\n+    void errorRecoveryNoPattern1(Object o) {\n+        switch (o) {\n+            case String: break;\n+            case Object obj: break;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/PatternErrorRecovery.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+PatternErrorRecovery.java:11:18: compiler.err.pattern.expected\n+- compiler.note.preview.filename: PatternErrorRecovery.java, DEFAULT\n+- compiler.note.preview.recompile\n+1 error\n","filename":"test\/langtools\/tools\/javac\/patterns\/PatternErrorRecovery.out","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -79,1 +79,1 @@\n-               \"Test.java:5:26: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.pattern.switch)\",\n+               \"Test.java:5:18: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.pattern.switch)\",\n","filename":"test\/langtools\/tools\/javac\/patterns\/SourceLevelChecks.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,42 +0,0 @@\n-SwitchErrors.java:35:31: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.pattern.switch)\n-SwitchErrors.java:34:18: compiler.err.constant.label.not.compatible: java.lang.String, java.lang.Object\n-SwitchErrors.java:40:18: compiler.err.constant.label.not.compatible: int, java.lang.Object\n-SwitchErrors.java:46:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, java.lang.Integer)\n-SwitchErrors.java:47:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Integer, java.lang.CharSequence)\n-SwitchErrors.java:52:18: compiler.err.preview.feature.disabled: (compiler.misc.feature.case.null)\n-SwitchErrors.java:53:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, int)\n-SwitchErrors.java:54:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int, java.lang.CharSequence)\n-SwitchErrors.java:60:20: compiler.err.total.pattern.and.default\n-SwitchErrors.java:66:13: compiler.err.pattern.dominated\n-SwitchErrors.java:72:18: compiler.err.total.pattern.and.default\n-SwitchErrors.java:78:18: compiler.err.duplicate.total.pattern\n-SwitchErrors.java:84:20: compiler.err.duplicate.default.label\n-SwitchErrors.java:90:20: compiler.err.duplicate.default.label\n-SwitchErrors.java:101:13: compiler.err.duplicate.case.label\n-SwitchErrors.java:106:13: compiler.err.duplicate.case.label\n-SwitchErrors.java:111:28: compiler.err.flows.through.to.pattern\n-SwitchErrors.java:117:18: compiler.err.flows.through.to.pattern\n-SwitchErrors.java:124:18: compiler.err.flows.through.to.pattern\n-SwitchErrors.java:131:18: compiler.err.flows.through.to.pattern\n-SwitchErrors.java:136:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, java.lang.Integer)\n-SwitchErrors.java:142:18: compiler.err.instanceof.reifiable.not.safe: java.util.List, java.util.List<java.lang.Integer>\n-SwitchErrors.java:148:18: compiler.err.cant.resolve.location: kindname.class, Undefined, , , (compiler.misc.location: kindname.class, SwitchErrors, null)\n-SwitchErrors.java:155:18: compiler.err.type.found.req: int, (compiler.misc.type.req.class.array)\n-SwitchErrors.java:172:27: compiler.err.flows.through.to.pattern\n-SwitchErrors.java:178:18: compiler.err.flows.through.to.pattern\n-SwitchErrors.java:184:13: compiler.err.pattern.dominated\n-SwitchErrors.java:196:18: compiler.err.const.expr.req\n-SwitchErrors.java:202:76: compiler.err.cant.resolve.location: kindname.variable, n, , , (compiler.misc.location: kindname.class, SwitchErrors, null)\n-SwitchErrors.java:208:71: compiler.err.cant.resolve.location: kindname.variable, n, , , (compiler.misc.location: kindname.class, SwitchErrors, null)\n-SwitchErrors.java:33:9: compiler.err.not.exhaustive.statement\n-SwitchErrors.java:39:9: compiler.err.not.exhaustive.statement\n-SwitchErrors.java:45:9: compiler.err.not.exhaustive.statement\n-SwitchErrors.java:51:9: compiler.err.not.exhaustive.statement\n-SwitchErrors.java:99:9: compiler.err.not.exhaustive.statement\n-SwitchErrors.java:105:9: compiler.err.not.exhaustive.statement\n-SwitchErrors.java:110:9: compiler.err.not.exhaustive.statement\n-SwitchErrors.java:115:9: compiler.err.not.exhaustive.statement\n-SwitchErrors.java:121:9: compiler.err.not.exhaustive.statement\n-SwitchErrors.java:128:9: compiler.err.not.exhaustive.statement\n-SwitchErrors.java:188:9: compiler.err.not.exhaustive.statement\n-41 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors-no-preview.out","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -2,24 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n+ * @test \/nodynamiccopyright\/\n@@ -29,1 +6,0 @@\n- * @compile\/fail\/ref=SwitchErrors-no-preview.out -XDrawDiagnostics -XDshould-stop.at=FLOW SwitchErrors.java\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.java","additions":1,"deletions":25,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1,44 +1,44 @@\n-SwitchErrors.java:34:18: compiler.err.constant.label.not.compatible: java.lang.String, java.lang.Object\n-SwitchErrors.java:40:18: compiler.err.constant.label.not.compatible: int, java.lang.Object\n-SwitchErrors.java:46:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, java.lang.Integer)\n-SwitchErrors.java:47:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Integer, java.lang.CharSequence)\n-SwitchErrors.java:52:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, int)\n-SwitchErrors.java:53:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, int)\n-SwitchErrors.java:54:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int, java.lang.CharSequence)\n-SwitchErrors.java:60:20: compiler.err.total.pattern.and.default\n-SwitchErrors.java:66:13: compiler.err.pattern.dominated\n-SwitchErrors.java:66:24: compiler.err.total.pattern.and.default\n-SwitchErrors.java:72:18: compiler.err.total.pattern.and.default\n-SwitchErrors.java:78:18: compiler.err.duplicate.total.pattern\n-SwitchErrors.java:84:20: compiler.err.duplicate.default.label\n-SwitchErrors.java:90:20: compiler.err.duplicate.default.label\n-SwitchErrors.java:95:27: compiler.err.duplicate.default.label\n-SwitchErrors.java:101:13: compiler.err.duplicate.case.label\n-SwitchErrors.java:106:13: compiler.err.duplicate.case.label\n-SwitchErrors.java:111:28: compiler.err.flows.through.to.pattern\n-SwitchErrors.java:117:18: compiler.err.flows.through.to.pattern\n-SwitchErrors.java:124:18: compiler.err.flows.through.to.pattern\n-SwitchErrors.java:131:18: compiler.err.flows.through.to.pattern\n-SwitchErrors.java:136:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, java.lang.Integer)\n-SwitchErrors.java:142:18: compiler.err.instanceof.reifiable.not.safe: java.util.List, java.util.List<java.lang.Integer>\n-SwitchErrors.java:148:18: compiler.err.cant.resolve.location: kindname.class, Undefined, , , (compiler.misc.location: kindname.class, SwitchErrors, null)\n-SwitchErrors.java:155:18: compiler.err.type.found.req: int, (compiler.misc.type.req.class.array)\n-SwitchErrors.java:161:28: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:167:18: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:172:27: compiler.err.flows.through.to.pattern\n-SwitchErrors.java:178:18: compiler.err.flows.through.to.pattern\n-SwitchErrors.java:184:13: compiler.err.pattern.dominated\n-SwitchErrors.java:196:18: compiler.err.pattern.expected\n-SwitchErrors.java:202:76: compiler.err.cant.resolve.location: kindname.variable, n, , , (compiler.misc.location: kindname.class, SwitchErrors, null)\n-SwitchErrors.java:208:71: compiler.err.cant.resolve.location: kindname.variable, n, , , (compiler.misc.location: kindname.class, SwitchErrors, null)\n-SwitchErrors.java:33:9: compiler.err.not.exhaustive.statement\n-SwitchErrors.java:39:9: compiler.err.not.exhaustive.statement\n-SwitchErrors.java:45:9: compiler.err.not.exhaustive.statement\n-SwitchErrors.java:51:9: compiler.err.not.exhaustive.statement\n-SwitchErrors.java:99:9: compiler.err.not.exhaustive.statement\n-SwitchErrors.java:105:9: compiler.err.not.exhaustive.statement\n-SwitchErrors.java:110:9: compiler.err.not.exhaustive.statement\n-SwitchErrors.java:115:9: compiler.err.not.exhaustive.statement\n-SwitchErrors.java:121:9: compiler.err.not.exhaustive.statement\n-SwitchErrors.java:128:9: compiler.err.not.exhaustive.statement\n-SwitchErrors.java:188:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:10:18: compiler.err.constant.label.not.compatible: java.lang.String, java.lang.Object\n+SwitchErrors.java:16:18: compiler.err.constant.label.not.compatible: int, java.lang.Object\n+SwitchErrors.java:22:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, java.lang.Integer)\n+SwitchErrors.java:23:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Integer, java.lang.CharSequence)\n+SwitchErrors.java:28:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, int)\n+SwitchErrors.java:29:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, int)\n+SwitchErrors.java:30:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int, java.lang.CharSequence)\n+SwitchErrors.java:36:20: compiler.err.total.pattern.and.default\n+SwitchErrors.java:42:13: compiler.err.pattern.dominated\n+SwitchErrors.java:42:24: compiler.err.total.pattern.and.default\n+SwitchErrors.java:48:18: compiler.err.total.pattern.and.default\n+SwitchErrors.java:54:18: compiler.err.duplicate.total.pattern\n+SwitchErrors.java:60:20: compiler.err.duplicate.default.label\n+SwitchErrors.java:66:20: compiler.err.duplicate.default.label\n+SwitchErrors.java:71:27: compiler.err.duplicate.default.label\n+SwitchErrors.java:77:13: compiler.err.duplicate.case.label\n+SwitchErrors.java:82:13: compiler.err.duplicate.case.label\n+SwitchErrors.java:87:28: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:93:18: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:100:18: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:107:18: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:112:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, java.lang.Integer)\n+SwitchErrors.java:118:18: compiler.err.instanceof.reifiable.not.safe: java.util.List, java.util.List<java.lang.Integer>\n+SwitchErrors.java:124:18: compiler.err.cant.resolve.location: kindname.class, Undefined, , , (compiler.misc.location: kindname.class, SwitchErrors, null)\n+SwitchErrors.java:131:18: compiler.err.type.found.req: int, (compiler.misc.type.req.class.array)\n+SwitchErrors.java:137:28: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:143:18: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:148:27: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:154:18: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:160:13: compiler.err.pattern.dominated\n+SwitchErrors.java:172:18: compiler.err.pattern.expected\n+SwitchErrors.java:178:76: compiler.err.cant.resolve.location: kindname.variable, n, , , (compiler.misc.location: kindname.class, SwitchErrors, null)\n+SwitchErrors.java:184:71: compiler.err.cant.resolve.location: kindname.variable, n, , , (compiler.misc.location: kindname.class, SwitchErrors, null)\n+SwitchErrors.java:9:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:15:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:21:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:27:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:75:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:81:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:86:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:91:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:97:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:104:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:164:9: compiler.err.not.exhaustive.statement\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.out","additions":44,"deletions":44,"binary":false,"changes":88,"status":"modified"}]}