{"files":[{"patch":"@@ -33,1 +33,1 @@\n-import java.util.function.Predicate;\n+import java.util.stream.StreamSupport;\n@@ -48,1 +48,0 @@\n-import com.sun.tools.javac.code.Kinds.Kind;\n@@ -55,0 +54,1 @@\n+import com.sun.tools.javac.code.Type.TypeVar;\n@@ -58,1 +58,0 @@\n-import com.sun.tools.javac.tree.JCTree.JCParenthesizedPattern;\n@@ -668,1 +667,1 @@\n-            Set<Object> constants = tree.patternSwitch ? allSwitchConstants(tree.selector) : null;\n+            Set<Symbol> constants = tree.patternSwitch ? new HashSet<>() : null;\n@@ -690,2 +689,3 @@\n-            if ((constants == null || !constants.isEmpty()) && !tree.hasTotalPattern &&\n-                tree.patternSwitch && !TreeInfo.isErrorEnumSwitch(tree.selector, tree.cases)) {\n+            if (!tree.hasTotalPattern && tree.patternSwitch &&\n+                !TreeInfo.isErrorEnumSwitch(tree.selector, tree.cases) &&\n+                (constants == null || !isExhaustive(tree.selector.type, constants))) {\n@@ -705,1 +705,1 @@\n-            Set<Object> constants = allSwitchConstants(tree.selector);\n+            Set<Symbol> constants = new HashSet<>();\n@@ -726,2 +726,2 @@\n-            if ((constants == null || !constants.isEmpty()) && !tree.hasTotalPattern &&\n-                !TreeInfo.isErrorEnumSwitch(tree.selector, tree.cases)) {\n+            if (!tree.hasTotalPattern && !TreeInfo.isErrorEnumSwitch(tree.selector, tree.cases) &&\n+                !isExhaustive(tree.selector.type, constants)) {\n@@ -734,18 +734,1 @@\n-        private Set<Object> allSwitchConstants(JCExpression selector) {\n-            Set<Object> constants = null;\n-            TypeSymbol selectorSym = selector.type.tsym;\n-            if ((selectorSym.flags() & ENUM) != 0) {\n-                constants = new HashSet<>();\n-                Predicate<Symbol> enumConstantFilter =\n-                        s -> (s.flags() & ENUM) != 0 && s.kind == Kind.VAR;\n-                for (Symbol s : selectorSym.members().getSymbols(enumConstantFilter)) {\n-                    constants.add(s.name);\n-                }\n-            } else if (selectorSym.isAbstract() && selectorSym.isSealed() && selectorSym.kind == Kind.TYP) {\n-                constants = new HashSet<>();\n-                constants.addAll(((ClassSymbol) selectorSym).permitted);\n-            }\n-            return constants;\n-        }\n-\n-        private void handleConstantCaseLabel(Set<Object> constants, JCCaseLabel pat) {\n+        private void handleConstantCaseLabel(Set<Symbol> constants, JCCaseLabel pat) {\n@@ -755,2 +738,2 @@\n-                    if (expr.hasTag(IDENT))\n-                        constants.remove(((JCIdent) expr).name);\n+                    if (expr.hasTag(IDENT) && ((JCIdent) expr).sym.isEnum())\n+                        constants.add(((JCIdent) expr).sym);\n@@ -761,1 +744,37 @@\n-                        constants.remove(patternType.type().tsym);\n+                        constants.add(patternType.type().tsym);\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void transitiveCovers(Set<Symbol> covered) {\n+            List<Symbol> todo = List.from(covered);\n+            while (todo.nonEmpty()) {\n+                Symbol sym = todo.head;\n+                todo = todo.tail;\n+                switch (sym.kind) {\n+                    case VAR -> {\n+                        Iterable<Symbol> constants = sym.owner\n+                                                        .members()\n+                                                        .getSymbols(s -> s.isEnum() &&\n+                                                                         s.kind == VAR);\n+                        boolean hasAll = StreamSupport.stream(constants.spliterator(), false)\n+                                                      .allMatch(covered::contains);\n+\n+                        if (hasAll && covered.add(sym.owner)) {\n+                            todo = todo.prepend(sym.owner);\n+                        }\n+                    }\n+\n+                    case TYP -> {\n+                        for (Type sup : types.directSupertypes(sym.type)) {\n+                            if (sup.tsym.kind == TYP && sup.tsym.isAbstract() && sup.tsym.isSealed()) {\n+                                boolean hasAll = ((ClassSymbol) sup.tsym).permitted\n+                                                                         .stream()\n+                                                                         .allMatch(covered::contains);\n+\n+                                if (hasAll && covered.add(sup.tsym)) {\n+                                    todo = todo.prepend(sup.tsym);\n+                                }\n+                            }\n+                        }\n@@ -767,0 +786,17 @@\n+        private boolean isExhaustive(Type seltype, Set<Symbol> covered) {\n+            transitiveCovers(covered);\n+            return switch (seltype.getTag()) {\n+                case CLASS -> {\n+                    if (seltype.isCompound()) {\n+                        if (seltype.isIntersection()) {\n+                            yield ((Type.IntersectionClassType) seltype).getComponents().stream().anyMatch(t -> isExhaustive(t, covered));\n+                        }\n+                        yield false;\n+                    }\n+                    yield covered.contains(seltype.tsym);\n+                }\n+                case TYPEVAR -> isExhaustive(((TypeVar) seltype).getUpperBound(), covered);\n+                default -> false;\n+            };\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":66,"deletions":30,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8262891\n+ * @bug 8262891 8268871\n@@ -372,43 +372,0 @@\n-    private void doTest(Path base, String[] libraryCode, String testCode, String... expectedErrors) throws IOException {\n-        Path current = base.resolve(\".\");\n-        Path libSrc = current.resolve(\"lib-src\");\n-        for (String code : libraryCode) {\n-            tb.writeJavaFiles(libSrc, code);\n-        }\n-\n-        Path libClasses = current.resolve(\"libClasses\");\n-\n-        Files.createDirectories(libClasses);\n-\n-        new JavacTask(tb)\n-                .options(\"--enable-preview\",\n-                         \"-source\", JAVA_VERSION)\n-                .outdir(libClasses)\n-                .files(tb.findJavaFiles(libSrc))\n-                .run();\n-\n-        Path src = current.resolve(\"src\");\n-        tb.writeJavaFiles(src, testCode);\n-\n-        Path classes = current.resolve(\"libClasses\");\n-\n-        Files.createDirectories(libClasses);\n-\n-        var log =\n-                new JavacTask(tb)\n-                    .options(\"--enable-preview\",\n-                             \"-source\", JAVA_VERSION,\n-                             \"-XDrawDiagnostics\",\n-                             \"-Xlint:-preview\",\n-                             \"--class-path\", libClasses.toString())\n-                    .outdir(classes)\n-                    .files(tb.findJavaFiles(src))\n-                    .run(expectedErrors.length > 0 ? Task.Expect.FAIL : Task.Expect.SUCCESS)\n-                    .writeAll()\n-                    .getOutputLines(Task.OutputKind.DIRECT);\n-        if (expectedErrors.length > 0 && !List.of(expectedErrors).equals(log)) {\n-            throw new AssertionError(\"Incorrect errors, expected: \" + List.of(expectedErrors) +\n-                                      \", actual: \" + log);\n-        }\n-    }\n-\n@@ -643,0 +600,221 @@\n+    @Test\n+    public void testExhaustiveTransitive(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public abstract sealed class B implements S permits C, D {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class C extends B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class D extends B {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(S obj, boolean b) {\n+                       return switch (obj) {\n+                           case A a -> 0;\n+                           case C c && b -> 0;\n+                           case C c -> 0;\n+                           case D d -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testNotExhaustiveTransitive(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public abstract sealed class B implements S permits C, D {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class C extends B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class D extends B {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(S obj, boolean b) {\n+                       return switch (obj) {\n+                           case A a -> 0;\n+                           case C c -> 0;\n+                           case D d && b -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:5:16: compiler.err.not.exhaustive\",\n+               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+               \"- compiler.note.preview.recompile\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testExhaustiveIntersection(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public abstract class Base {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public interface Marker {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A extends Base implements S, Marker {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public abstract sealed class B extends Base implements S permits C, D {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class C extends B implements Marker {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class D extends B implements Marker {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private <T extends Base & S & Marker> int test(T obj, boolean b) {\n+                       return switch (obj) {\n+                           case A a -> 0;\n+                           case C c && b -> 0;\n+                           case C c -> 0;\n+                           case D d -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testNotExhaustiveIntersection(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public abstract class Base {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public interface Marker {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A extends Base implements S, Marker {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public abstract sealed class B extends Base implements S permits C, D {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class C extends B implements Marker {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class D extends B implements Marker {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private <T extends Base & S & Marker> int test(T obj, boolean b) {\n+                       return switch (obj) {\n+                           case A a -> 0;\n+                           case C c -> 0;\n+                           case D d && b -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:5:16: compiler.err.not.exhaustive\",\n+               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+               \"- compiler.note.preview.recompile\",\n+               \"1 error\");\n+    }\n+\n+    private void doTest(Path base, String[] libraryCode, String testCode, String... expectedErrors) throws IOException {\n+        Path current = base.resolve(\".\");\n+        Path libSrc = current.resolve(\"lib-src\");\n+        for (String code : libraryCode) {\n+            tb.writeJavaFiles(libSrc, code);\n+        }\n+\n+        Path libClasses = current.resolve(\"libClasses\");\n+\n+        Files.createDirectories(libClasses);\n+\n+        new JavacTask(tb)\n+                .options(\"--enable-preview\",\n+                         \"-source\", JAVA_VERSION)\n+                .outdir(libClasses)\n+                .files(tb.findJavaFiles(libSrc))\n+                .run();\n+\n+        Path src = current.resolve(\"src\");\n+        tb.writeJavaFiles(src, testCode);\n+\n+        Path classes = current.resolve(\"libClasses\");\n+\n+        Files.createDirectories(libClasses);\n+\n+        var log =\n+                new JavacTask(tb)\n+                    .options(\"--enable-preview\",\n+                             \"-source\", JAVA_VERSION,\n+                             \"-XDrawDiagnostics\",\n+                             \"-Xlint:-preview\",\n+                             \"--class-path\", libClasses.toString())\n+                    .outdir(classes)\n+                    .files(tb.findJavaFiles(src))\n+                    .run(expectedErrors.length > 0 ? Task.Expect.FAIL : Task.Expect.SUCCESS)\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.DIRECT);\n+        if (expectedErrors.length > 0 && !List.of(expectedErrors).equals(log)) {\n+            throw new AssertionError(\"Incorrect errors, expected: \" + List.of(expectedErrors) +\n+                                      \", actual: \" + log);\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/Exhaustiveness.java","additions":222,"deletions":44,"binary":false,"changes":266,"status":"modified"}]}