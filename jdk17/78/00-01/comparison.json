{"files":[{"patch":"@@ -751,19 +751,15 @@\n-            boolean modified = true;\n-            OUTER: while (modified) {\n-                modified = false;\n-                for (Symbol sym : covered) {\n-                    switch (sym.kind) {\n-                        case VAR -> {\n-                            Iterable<Symbol> constants = sym.owner\n-                                                            .members()\n-                                                            .getSymbols(s -> s.isEnum() &&\n-                                                                             s.kind == VAR);\n-                            boolean hasAll = StreamSupport.stream(constants.spliterator(), false)\n-                                                          .allMatch(covered::contains);\n-\n-                            if (hasAll) {\n-                                if (covered.add(sym.owner)) {\n-                                    modified = true;\n-                                    continue OUTER;\n-                                }\n-                            }\n+            List<Symbol> todo = List.from(covered);\n+            while (todo.nonEmpty()) {\n+                Symbol sym = todo.head;\n+                todo = todo.tail;\n+                switch (sym.kind) {\n+                    case VAR -> {\n+                        Iterable<Symbol> constants = sym.owner\n+                                                        .members()\n+                                                        .getSymbols(s -> s.isEnum() &&\n+                                                                         s.kind == VAR);\n+                        boolean hasAll = StreamSupport.stream(constants.spliterator(), false)\n+                                                      .allMatch(covered::contains);\n+\n+                        if (hasAll && covered.add(sym.owner)) {\n+                            todo = todo.prepend(sym.owner);\n@@ -771,0 +767,1 @@\n+                    }\n@@ -772,6 +769,6 @@\n-                        case TYP -> {\n-                            for (Type sup : types.directSupertypes(sym.type)) {\n-                                if (sup.tsym.kind == TYP && sup.tsym.isAbstract() && sup.tsym.isSealed()) {\n-                                    boolean hasAll = ((ClassSymbol) sup.tsym).permitted\n-                                                                             .stream()\n-                                                                             .allMatch(covered::contains);\n+                    case TYP -> {\n+                        for (Type sup : types.directSupertypes(sym.type)) {\n+                            if (sup.tsym.kind == TYP && sup.tsym.isAbstract() && sup.tsym.isSealed()) {\n+                                boolean hasAll = ((ClassSymbol) sup.tsym).permitted\n+                                                                         .stream()\n+                                                                         .allMatch(covered::contains);\n@@ -779,3 +776,2 @@\n-                                    if (hasAll) {\n-                                        modified |= covered.add(sup.tsym);\n-                                    }\n+                                if (hasAll && covered.add(sup.tsym)) {\n+                                    todo = todo.prepend(sup.tsym);\n@@ -784,4 +780,0 @@\n-\n-                            if (modified) {\n-                                continue OUTER;\n-                            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":24,"deletions":32,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -627,1 +627,1 @@\n-                   private int test(S obj) {\n+                   private int test(S obj, boolean b) {\n@@ -630,0 +630,1 @@\n+                           case C c && b -> 0;\n@@ -638,0 +639,42 @@\n+    @Test\n+    public void testNotExhaustiveTransitive(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public abstract sealed class B implements S permits C, D {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class C extends B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class D extends B {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(S obj, boolean b) {\n+                       return switch (obj) {\n+                           case A a -> 0;\n+                           case C c -> 0;\n+                           case D d && b -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:5:16: compiler.err.not.exhaustive\",\n+               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+               \"- compiler.note.preview.recompile\",\n+               \"1 error\");\n+    }\n+\n@@ -673,1 +716,1 @@\n-                   private <T extends Base & S & Marker> int test(T obj) {\n+                   private <T extends Base & S & Marker> int test(T obj, boolean b) {\n@@ -676,0 +719,1 @@\n+                           case C c && b -> 0;\n@@ -684,0 +728,50 @@\n+    @Test\n+    public void testNotExhaustiveIntersection(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public abstract class Base {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public interface Marker {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A extends Base implements S, Marker {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public abstract sealed class B extends Base implements S permits C, D {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class C extends B implements Marker {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class D extends B implements Marker {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private <T extends Base & S & Marker> int test(T obj, boolean b) {\n+                       return switch (obj) {\n+                           case A a -> 0;\n+                           case C c -> 0;\n+                           case D d && b -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:5:16: compiler.err.not.exhaustive\",\n+               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+               \"- compiler.note.preview.recompile\",\n+               \"1 error\");\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/Exhaustiveness.java","additions":96,"deletions":2,"binary":false,"changes":98,"status":"modified"}]}