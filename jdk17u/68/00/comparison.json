{"files":[{"patch":"@@ -55,1 +55,0 @@\n-  bool safe = false;\n@@ -73,2 +72,2 @@\n-  \/\/ An interpreter fp must be within the stack and above (but not equal) sp.\n-  \/\/ Moreover, it must be at least the size of the ijava_state structure.\n+  \/\/ An interpreter fp must be fp_safe.\n+  \/\/ Moreover, it must be at a distance at least the size of the ijava_state structure.\n@@ -80,1 +79,1 @@\n-  \/\/ to construct the sender and do some validation of it. This goes a long way\n+  \/\/ construct the sender and do some validation of it. This goes a long way\n@@ -84,5 +83,0 @@\n-    \/\/ Entry frame checks\n-    if (is_entry_frame()) {\n-      \/\/ An entry frame must have a valid fp.\n-      return fp_safe && is_entry_frame_valid(thread);\n-    }\n@@ -90,5 +84,5 @@\n-    \/\/ Now check if the frame is complete and the test is\n-    \/\/ reliable. Unfortunately we can only check frame completeness for\n-    \/\/ runtime stubs and nmethods. Other generic buffer blobs are more\n-    \/\/ problematic so we just assume they are OK. Adapter blobs never have a\n-    \/\/ complete frame and are never OK\n+    \/\/ First check if the frame is complete and the test is reliable.\n+    \/\/ Unfortunately we can only check frame completeness for runtime stubs\n+    \/\/ and nmethods. Other generic buffer blobs are more problematic\n+    \/\/ so we just assume they are OK.\n+    \/\/ Adapter blobs never have a complete frame and are never OK\n@@ -106,0 +100,6 @@\n+    \/\/ Entry frame checks\n+    if (is_entry_frame()) {\n+      \/\/ An entry frame must have a valid fp.\n+      return fp_safe && is_entry_frame_valid(thread);\n+    }\n+\n@@ -108,0 +108,7 @@\n+    }\n+\n+    \/\/ At this point, there still is a chance that fp_safe is false.\n+    \/\/ In particular, (fp == NULL) might be true. So let's check and\n+    \/\/ bail out before we actually dereference from fp.\n+    if (!fp_safe) {\n+      return false;\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.cpp","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-  bool safe = false;\n@@ -76,2 +75,2 @@\n-  \/\/ An interpreter fp must be within the stack and above (but not equal) sp.\n-  \/\/ Moreover, it must be at least the size of the z_ijava_state structure.\n+  \/\/ An interpreter fp must be fp_safe.\n+  \/\/ Moreover, it must be at a distance at least the size of the z_ijava_state structure.\n@@ -83,1 +82,1 @@\n-  \/\/ to construct the sender and do some validation of it. This goes a long way\n+  \/\/ construct the sender and do some validation of it. This goes a long way\n@@ -87,5 +86,0 @@\n-    \/\/ Entry frame checks\n-    if (is_entry_frame()) {\n-      \/\/ An entry frame must have a valid fp.\n-      return fp_safe && is_entry_frame_valid(thread);\n-    }\n@@ -93,5 +87,5 @@\n-    \/\/ Now check if the frame is complete and the test is\n-    \/\/ reliable. Unfortunately we can only check frame completeness for\n-    \/\/ runtime stubs. Other generic buffer blobs are more\n-    \/\/ problematic so we just assume they are OK. Adapter blobs never have a\n-    \/\/ complete frame and are never OK. nmethods should be OK on s390.\n+    \/\/ First check if the frame is complete and the test is reliable.\n+    \/\/ Unfortunately we can only check frame completeness for runtime stubs.\n+    \/\/ Other generic buffer blobs are more problematic so we just assume they are OK.\n+    \/\/ Adapter blobs never have a complete frame and are never OK.\n+    \/\/ nmethods should be OK on s390.\n@@ -109,0 +103,6 @@\n+    \/\/ Entry frame checks\n+    if (is_entry_frame()) {\n+      \/\/ An entry frame must have a valid fp.\n+      return fp_safe && is_entry_frame_valid(thread);\n+    }\n+\n@@ -113,0 +113,7 @@\n+    \/\/ At this point, there still is a chance that fp_safe is false.\n+    \/\/ In particular, (fp == NULL) might be true. So let's check and\n+    \/\/ bail out before we actually dereference from fp.\n+    if (!fp_safe) {\n+      return false;\n+    }\n+\n@@ -115,1 +122,1 @@\n-    address   sender_pc = (address) sender_abi->return_pc;\n+    address   sender_pc = (address)   sender_abi->return_pc;\n","filename":"src\/hotspot\/cpu\/s390\/frame_s390.cpp","additions":22,"deletions":15,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+  \/\/ Assume spill slot for link register contains a suitable pc.\n+  \/\/ Should have been filled by method entry code.\n@@ -67,0 +69,11 @@\n+    if (ret_frame.fp() == NULL) {\n+      \/\/ The found frame does not have a valid frame pointer.\n+      \/\/ Bail out because this will create big trouble later on, either\n+      \/\/  - when using istate, calculated as (NULL - ijava_state_size) or\n+      \/\/  - when using fp() directly in safe_for_sender()\n+      \/\/\n+      \/\/ There is no conclusive description (yet) how this could happen, but it does.\n+      \/\/ For more details on what was observed, see thread_linux_s390.cpp\n+      return false;\n+    }\n+\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/thread_linux_ppc.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+  \/\/ Assume spill slot for Z_R14 (return register) contains a suitable pc.\n+  \/\/ Should have been filled by method entry code.\n@@ -54,0 +56,3 @@\n+  \/\/ At this point, we don't have a last_Java_frame, so\n+  \/\/ we try to glean some information out of the ucontext\n+  \/\/ if we were running Java code when SIGPROF came in.\n@@ -64,0 +69,32 @@\n+    if (ret_frame.fp() == NULL) {\n+      \/\/ The found frame does not have a valid frame pointer.\n+      \/\/ Bail out because this will create big trouble later on, either\n+      \/\/  - when using istate, calculated as (NULL - z_ijava_state_size (= 0x70 (dbg) or 0x68 (rel)) or\n+      \/\/  - when using fp() directly in safe_for_sender()\n+      \/\/\n+      \/\/ There is no conclusive description (yet) how this could happen, but it does:\n+      \/\/\n+      \/\/ We observed a SIGSEGV with the following stack trace (openjdk.jdk11u-dev, 2021-07-07, linuxs390x fastdebug)\n+      \/\/ V  [libjvm.so+0x12c8f12]  JavaThread::pd_get_top_frame_for_profiling(frame*, void*, bool)+0x142\n+      \/\/ V  [libjvm.so+0xb1020c]  JfrGetCallTrace::get_topframe(void*, frame&)+0x3c\n+      \/\/ V  [libjvm.so+0xba0b08]  OSThreadSampler::protected_task(os::SuspendedThreadTaskContext const&)+0x98\n+      \/\/ V  [libjvm.so+0xff33c4]  os::SuspendedThreadTask::internal_do_task()+0x14c\n+      \/\/ V  [libjvm.so+0xfe3c9c]  os::SuspendedThreadTask::run()+0x24\n+      \/\/ V  [libjvm.so+0xba0c66]  JfrThreadSampleClosure::sample_thread_in_java(JavaThread*, JfrStackFrame*, unsigned int)+0x66\n+      \/\/ V  [libjvm.so+0xba1718]  JfrThreadSampleClosure::do_sample_thread(JavaThread*, JfrStackFrame*, unsigned int, JfrSampleType)+0x278\n+      \/\/ V  [libjvm.so+0xba4f54]  JfrThreadSampler::task_stacktrace(JfrSampleType, JavaThread**) [clone .constprop.62]+0x284\n+      \/\/ V  [libjvm.so+0xba5e54]  JfrThreadSampler::run()+0x2ec\n+      \/\/ V  [libjvm.so+0x12adc9c]  Thread::call_run()+0x9c\n+      \/\/ V  [libjvm.so+0xff5ab0]  thread_native_entry(Thread*)+0x128\n+      \/\/ siginfo: si_signo: 11 (SIGSEGV), si_code: 1 (SEGV_MAPERR), si_addr: 0xfffffffffffff000\n+      \/\/ failing instruction: e320 6008 0004   LG   r2,8(r0,r6)\n+      \/\/ contents of r6:  0xffffffffffffff90\n+      \/\/\n+      \/\/ Here is the sequence of what happens:\n+      \/\/  - ret_frame is constructed with _fp == NULL (for whatever reason)\n+      \/\/  - ijava_state_unchecked() calculates it's result as\n+      \/\/      istate = fp() - z_ijava_state_size() = NULL - 0x68 DEBUG_ONLY(-8)\n+      \/\/  - istate->method dereferences memory at offset 8 from istate\n+      return false;\n+    }\n+\n","filename":"src\/hotspot\/os_cpu\/linux_s390\/thread_linux_s390.cpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"}]}