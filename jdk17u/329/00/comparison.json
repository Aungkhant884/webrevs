{"files":[{"patch":"@@ -205,1 +205,1 @@\n-  return sample->has_stack_trace_id() && !sample->is_dead();\n+  return sample->has_stack_trace_id() && !sample->is_dead() && !sample->stacktrace().valid();\n@@ -252,1 +252,1 @@\n-  blob = writer.copy();\n+  blob = writer.move();\n@@ -281,1 +281,1 @@\n-  assert(ClassLoaderDataGraph_lock->owned_by_self(), \"invariant\");\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n@@ -384,0 +384,6 @@\n+  {\n+    \/\/ First install stacktrace blobs for the most recently added candidates.\n+    MutexLocker lock(SafepointSynchronize::is_at_safepoint() ? nullptr : ClassLoaderDataGraph_lock);\n+    \/\/ the lock is needed to ensure the unload lists do not grow in the middle of inspection.\n+    install_stack_traces(sampler);\n+  }\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/objectSampleCheckpoint.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -246,0 +246,1 @@\n+  CLEAR_LEAKP(klass);\n@@ -851,1 +852,1 @@\n-  MethodUsedPredicate<leakp> _method_used_predicate;\n+  MethodUsedPredicate _method_used_predicate;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSet.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -149,1 +149,0 @@\n-template <bool leakp>\n@@ -155,4 +154,1 @@\n-    if (_current_epoch) {\n-      return leakp ? IS_LEAKP(klass) : METHOD_USED_THIS_EPOCH(klass);\n-    }\n-    return  leakp ? IS_LEAKP(klass) : METHOD_USED_PREVIOUS_EPOCH(klass);\n+    return _current_epoch ? METHOD_USED_THIS_EPOCH(klass) : METHOD_USED_PREVIOUS_EPOCH(klass);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSetUtils.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"}]}