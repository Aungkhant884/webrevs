{"files":[{"patch":"@@ -151,1 +151,1 @@\n-    public static native void colorConvert(LCMSTransform trans,\n+    public static native void colorConvert(long trans,\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/cmm\/lcms\/LCMS.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import java.lang.ref.Reference;\n@@ -53,5 +54,0 @@\n-    long ID;\n-    private int inFormatter = 0;\n-    private boolean isInIntPacked = false;\n-    private int outFormatter = 0;\n-    private boolean isOutIntPacked = false;\n@@ -59,0 +55,16 @@\n+    private final static class NativeTransform {\n+        private long ID;\n+        private int inFormatter;\n+        private boolean isInIntPacked;\n+        private int outFormatter;\n+        private boolean isOutIntPacked;\n+\n+        private boolean match(LCMSImageLayout in, LCMSImageLayout out) {\n+            return inFormatter == in.pixelType\n+                    && isInIntPacked == in.isIntPacked\n+                    && outFormatter == out.pixelType\n+                    && isOutIntPacked == out.isIntPacked;\n+        }\n+    }\n+\n+    private volatile NativeTransform transform;\n@@ -67,2 +79,0 @@\n-    private Object disposerReferent = new Object();\n-\n@@ -125,11 +135,22 @@\n-    private synchronized void doTransform(LCMSImageLayout in,\n-                                          LCMSImageLayout out) {\n-        \/\/ update native transfrom if needed\n-        if (ID == 0L ||\n-            inFormatter != in.pixelType || isInIntPacked != in.isIntPacked ||\n-            outFormatter != out.pixelType || isOutIntPacked != out.isIntPacked)\n-        {\n-\n-            if (ID != 0L) {\n-                \/\/ Disposer will destroy forgotten transform\n-                disposerReferent = new Object();\n+    private void doTransform(LCMSImageLayout in, LCMSImageLayout out) {\n+        NativeTransform tfm = transform;\n+        \/\/ update native transform if needed\n+        if (tfm == null || !tfm.match(in, out)) {\n+            synchronized (this) {\n+                tfm = transform;\n+                if (tfm == null || !tfm.match(in, out)) {\n+                    tfm = new NativeTransform();\n+                    tfm.inFormatter = in.pixelType;\n+                    tfm.isInIntPacked = in.isIntPacked;\n+\n+                    tfm.outFormatter = out.pixelType;\n+                    tfm.isOutIntPacked = out.isIntPacked;\n+\n+                    tfm.ID = LCMS.createTransform(lcmsProfiles, renderType,\n+                                                  tfm.inFormatter,\n+                                                  tfm.isInIntPacked,\n+                                                  tfm.outFormatter,\n+                                                  tfm.isOutIntPacked, tfm);\n+                    \/\/ Disposer will destroy forgotten transform\n+                    transform = tfm;\n+                }\n@@ -137,10 +158,0 @@\n-            inFormatter = in.pixelType;\n-            isInIntPacked = in.isIntPacked;\n-\n-            outFormatter = out.pixelType;\n-            isOutIntPacked = out.isIntPacked;\n-\n-            ID = LCMS.createTransform(lcmsProfiles, renderType,\n-                                            inFormatter, isInIntPacked,\n-                                            outFormatter, isOutIntPacked,\n-                                            disposerReferent);\n@@ -148,2 +159,2 @@\n-\n-        LCMS.colorConvert(this, in, out);\n+        LCMS.colorConvert(tfm.ID, in, out);\n+        Reference.reachabilityFence(tfm); \/\/ prevent deallocation of \"tfm.ID\"\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/cmm\/lcms\/LCMSTransform.java","additions":41,"deletions":30,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -74,1 +74,0 @@\n-static jfieldID Trans_ID_fID;\n@@ -513,1 +512,1 @@\n-  (JNIEnv *env, jclass cls, jobject trans, jobject src, jobject dst)\n+  (JNIEnv *env, jclass cls, jlong ID, jobject src, jobject dst)\n@@ -515,1 +514,1 @@\n-    cmsHTRANSFORM sTrans = NULL;\n+    cmsHTRANSFORM sTrans = jlong_to_ptr(ID);\n@@ -536,2 +535,0 @@\n-    sTrans = jlong_to_ptr((*env)->GetLongField (env, trans, Trans_ID_fID));\n-\n@@ -629,5 +626,0 @@\n-    Trans_ID_fID = (*env)->GetFieldID (env, Trans, \"ID\", \"J\");\n-    if (Trans_ID_fID == NULL) {\n-        return;\n-    }\n-\n","filename":"src\/java.desktop\/share\/native\/liblcms\/LCMS.c","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.color.ColorSpace;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorConvertOp;\n+\n+\/**\n+ * @test\n+ * @bug 8273972\n+ * @summary Verifies that ColorConvertOp works fine if shared between threads\n+ * @run main\/othervm\/timeout=600 MTTransformValidation\n+ *\/\n+public final class MTPerLineTransformValidation {\n+\n+    private volatile static BufferedImage[] lines;\n+\n+    public static final int SIZE = 255;\n+    private static volatile boolean failed = false;\n+\n+    private static final int[] spaces = {\n+            ColorSpace.CS_CIEXYZ, ColorSpace.CS_GRAY, ColorSpace.CS_LINEAR_RGB,\n+            ColorSpace.CS_PYCC, ColorSpace.CS_sRGB\n+    };\n+\n+    private static final int[] types = new int[]{\n+            BufferedImage.TYPE_INT_RGB, BufferedImage.TYPE_INT_ARGB,\n+            BufferedImage.TYPE_INT_ARGB_PRE, BufferedImage.TYPE_INT_BGR,\n+            BufferedImage.TYPE_3BYTE_BGR, BufferedImage.TYPE_4BYTE_ABGR,\n+            BufferedImage.TYPE_4BYTE_ABGR_PRE,\n+            BufferedImage.TYPE_USHORT_565_RGB,\n+            BufferedImage.TYPE_USHORT_555_RGB, BufferedImage.TYPE_BYTE_GRAY,\n+            BufferedImage.TYPE_USHORT_GRAY, BufferedImage.TYPE_BYTE_BINARY,\n+            BufferedImage.TYPE_BYTE_INDEXED\n+    };\n+\n+    \/**\n+     * For all possible combinations of color spaces and image types, convert\n+     * the source image using one shared ColorConvertOp per line on the\n+     * different threads. The result is validated against images converted on\n+     * one thread only.\n+     *\/\n+    public static void main(String[] args) throws Exception {\n+        for (int srcCS : spaces) {\n+            for (int dstCS : spaces) {\n+                if(srcCS != dstCS) {\n+                    for (int type : types) {\n+                        checkTypes(ColorSpace.getInstance(srcCS),\n+                                   ColorSpace.getInstance(dstCS), type);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void checkTypes(ColorSpace srcCS, ColorSpace dstCS, int type)\n+            throws Exception {\n+        lines = new BufferedImage[SIZE];\n+        ColorConvertOp goldOp = new ColorConvertOp(srcCS, dstCS, null);\n+        BufferedImage src = createSrc(type);\n+        BufferedImage gold = goldOp.filter(src, null);\n+\n+        \/\/ we do not share the goldOp since it is already initialized and used\n+        \/\/ for the whole image, instead we will create a separate sharedOp and\n+        \/\/ use it for each line of a different threads\n+        ColorConvertOp sharedOp = new ColorConvertOp(srcCS, dstCS, null);\n+        Thread[] threads = new Thread[SIZE];\n+        for (int y = 0; y < SIZE; ++y) {\n+            BufferedImage line = src.getSubimage(0, y, SIZE, 1);\n+            threads[y] = test(sharedOp, line, y);\n+        }\n+\n+        for (Thread t: threads) {\n+            t.start();\n+        }\n+        for (Thread t: threads) {\n+            t.join();\n+        }\n+        for (int y = 0; y < SIZE; ++y) {\n+            validate(gold, lines[y], y);\n+        }\n+        if (failed) {\n+            throw new RuntimeException(\"Unexpected exception\");\n+        }\n+    }\n+\n+    private static Thread test(ColorConvertOp sharedOp,\n+                               BufferedImage line, int y){\n+        return new Thread(() -> {\n+            try {\n+                BufferedImage image = sharedOp.filter(line, null);\n+                lines[y] = image;\n+            } catch (Throwable t) {\n+                t.printStackTrace();\n+                failed = true;\n+            }\n+        });\n+    }\n+\n+    private static BufferedImage createSrc(int type) {\n+        BufferedImage img = new BufferedImage(SIZE, SIZE, type);\n+        fill(img);\n+        return img;\n+    }\n+\n+    private static void fill(BufferedImage image) {\n+        for (int i = 0; i < SIZE; i++) {\n+            for (int j = 0; j < SIZE; j++) {\n+                image.setRGB(i, j,\n+                             (i << 24) | (i << 16) | (j << 8) | ((i + j) >> 1));\n+            }\n+        }\n+    }\n+\n+    private static void validate(BufferedImage full, BufferedImage line, int y) {\n+        for (int i = 0; i < SIZE; i++) {\n+            int rgb1 = full.getRGB(i, y);\n+            int rgb2 = line.getRGB(i, 0);\n+            if (rgb1 != rgb2) {\n+                System.err.println(\"rgb1 = \" + Integer.toHexString(rgb1));\n+                System.err.println(\"rgb2 = \" + Integer.toHexString(rgb2));\n+                throw new RuntimeException();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/cmm\/ColorConvertOp\/MTPerLineTransformValidation.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -0,0 +1,143 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.color.ColorSpace;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorConvertOp;\n+import java.util.concurrent.CountDownLatch;\n+\n+\/**\n+ * @test\n+ * @bug 8273972\n+ * @summary Verifies that ColorConvertOp works fine if shared between threads\n+ * @run main\/othervm\/timeout=600 MTTransformValidation\n+ *\/\n+public final class MTTransformValidation {\n+\n+    public static final int SIZE = 255;\n+    private static volatile boolean failed = false;\n+\n+    private static final int[] spaces = {\n+            ColorSpace.CS_CIEXYZ, ColorSpace.CS_GRAY, ColorSpace.CS_LINEAR_RGB,\n+            ColorSpace.CS_PYCC, ColorSpace.CS_sRGB\n+    };\n+\n+    private static final int[] types = new int[]{\n+            BufferedImage.TYPE_INT_RGB, BufferedImage.TYPE_INT_ARGB,\n+            BufferedImage.TYPE_INT_ARGB_PRE, BufferedImage.TYPE_INT_BGR,\n+            BufferedImage.TYPE_3BYTE_BGR, BufferedImage.TYPE_4BYTE_ABGR,\n+            BufferedImage.TYPE_4BYTE_ABGR_PRE,\n+            BufferedImage.TYPE_USHORT_565_RGB,\n+            BufferedImage.TYPE_USHORT_555_RGB, BufferedImage.TYPE_BYTE_GRAY,\n+            BufferedImage.TYPE_USHORT_GRAY, BufferedImage.TYPE_BYTE_BINARY,\n+            BufferedImage.TYPE_BYTE_INDEXED\n+    };\n+\n+    \/**\n+     * For all possible combinations of color spaces and image types, convert\n+     * the source image using one shared ColorConvertOp. The result is validated\n+     * against images converted on one thread only.\n+     *\/\n+    public static void main(String[] args) throws Exception {\n+        for (int srcCS : spaces) {\n+            for (int dstCS : spaces) {\n+                if(srcCS != dstCS) {\n+                    for (int type : types) {\n+                        checkTypes(ColorSpace.getInstance(srcCS),\n+                                   ColorSpace.getInstance(dstCS), type);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void checkTypes(ColorSpace srcCS, ColorSpace dstCS, int type)\n+            throws Exception {\n+        ColorConvertOp goldOp = new ColorConvertOp(srcCS, dstCS, null);\n+        BufferedImage gold = goldOp.filter(createSrc(type), null);\n+        \/\/ we do not share the goldOp since it is already initialized, but\n+        \/\/ instead we will trigger initialization\/usage of the new sharedOp on\n+        \/\/ different threads at once\n+        ColorConvertOp sharedOp = new ColorConvertOp(srcCS, dstCS, null);\n+        test(gold, sharedOp, type);\n+\n+        if (failed) {\n+            throw new RuntimeException(\"Unexpected exception\");\n+        }\n+    }\n+\n+    private static void test(BufferedImage gold, ColorConvertOp sharedOp,\n+                             int type) throws Exception {\n+        Thread[] ts = new Thread[7];\n+        CountDownLatch latch = new CountDownLatch(ts.length);\n+        for (int i = 0; i < ts.length; i++) {\n+            ts[i] = new Thread(() -> {\n+                BufferedImage local = createSrc(type);\n+                latch.countDown();\n+                try {\n+                    latch.await();\n+                    BufferedImage image = sharedOp.filter(local, null);\n+                    validate(image, gold);\n+                } catch (Throwable t) {\n+                    t.printStackTrace();\n+                    failed = true;\n+                }\n+            });\n+        }\n+        for (Thread t : ts) {\n+            t.start();\n+        }\n+        for (Thread t : ts) {\n+            t.join();\n+        }\n+    }\n+\n+    private static BufferedImage createSrc(int type) {\n+        BufferedImage img = new BufferedImage(SIZE, SIZE, type);\n+        fill(img);\n+        return img;\n+    }\n+\n+    private static void fill(BufferedImage image) {\n+        for (int i = 0; i < SIZE; i++) {\n+            for (int j = 0; j < SIZE; j++) {\n+                image.setRGB(i, j,\n+                             (i << 24) | (i << 16) | (j << 8) | ((i + j) >> 1));\n+            }\n+        }\n+    }\n+\n+    private static void validate(BufferedImage img1, BufferedImage img2) {\n+        for (int i = 0; i < SIZE; i++) {\n+            for (int j = 0; j < SIZE; j++) {\n+                int rgb1 = img1.getRGB(i, j);\n+                int rgb2 = img2.getRGB(i, j);\n+                if (rgb1 != rgb2) {\n+                    System.err.println(\"rgb1 = \" + Integer.toHexString(rgb1));\n+                    System.err.println(\"rgb2 = \" + Integer.toHexString(rgb2));\n+                    throw new RuntimeException();\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/cmm\/ColorConvertOp\/MTTransformValidation.java","additions":143,"deletions":0,"binary":false,"changes":143,"status":"added"}]}