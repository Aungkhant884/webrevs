{"files":[{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.reflect.Modifier;\n+\n@@ -160,1 +162,1 @@\n-                if (targetClass == implClass) {\n+                if (targetClass == implClass && Modifier.isPrivate(implInfo.getModifiers())) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/AbstractValidatingLambdaMetafactory.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8274848\n+ * @run testng InvokeSpecialMethodTest\n+ * @summary ensure REF_invokeSpecial on a non-private implementation method\n+ *          behaves as if `super::m` is invoked regardless of its access flag\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.CallSite;\n+import java.lang.invoke.LambdaMetafactory;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+\n+import static java.lang.invoke.MethodType.methodType;\n+\n+public class InvokeSpecialMethodTest {\n+    static class MethodTest {\n+        static final Lookup LOOKUP = MethodHandles.lookup();\n+\n+        public String m_public() {\n+            return \"test_public\";\n+        }\n+\n+        protected String m_protected() {\n+            return \"test_protected\";\n+        }\n+\n+        private String m_private() {\n+            return \"test_private\";\n+        }\n+\n+        public static class SubClass extends MethodTest {\n+            @Override\n+            public String m_public() {\n+                return \"subclass_public\";\n+            }\n+\n+            @Override\n+            public String m_protected() {\n+                return \"subclass_protected\";\n+            }\n+\n+            public String m_private() {\n+                return \"subclass_private\";\n+            }\n+        }\n+\n+        \/*\n+         * findSpecial with Test class as the special caller matching\n+         * the factory type `StringFactory(Test)`\n+         *\/\n+        static MethodHandle mh(String name) {\n+            try {\n+                return LOOKUP.findSpecial(MethodTest.class, name, methodType(String.class), MethodTest.class);\n+            } catch (NoSuchMethodException | IllegalAccessException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        static final MethodHandle M_PUBLIC = mh(\"m_public\");\n+        static final MethodHandle M_PROTECTED = mh(\"m_protected\");\n+        static final MethodHandle M_PRIVATE = mh(\"m_private\");\n+    }\n+\n+    @FunctionalInterface\n+    interface StringFactory {\n+        String get();\n+    }\n+\n+    @DataProvider\n+    public Object[][] methodProvider() {\n+        return new Object[][]{\n+                {MethodTest.M_PUBLIC, \"test_public\"},\n+                {MethodTest.M_PROTECTED, \"test_protected\"},\n+                {MethodTest.M_PRIVATE, \"test_private\"}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"methodProvider\")\n+    void test(MethodHandle implMethod, String expected) throws Throwable {\n+        testMetafactory(implMethod, expected);\n+        testAltMetafactory(implMethod, expected);\n+    }\n+\n+    static void testMetafactory(MethodHandle implMethod, String expected) throws Throwable {\n+        CallSite cs = LambdaMetafactory.metafactory(MethodTest.LOOKUP, \"get\",\n+                                                    methodType(StringFactory.class, MethodTest.class),\n+                                                    methodType(String.class), implMethod, methodType(String.class));\n+        MethodTest o = new MethodTest.SubClass();\n+        StringFactory factory = (StringFactory) cs.dynamicInvoker().invokeExact(o);\n+        String actual = factory.get();\n+        Assert.assertEquals(actual, expected);\n+    }\n+\n+    static void testAltMetafactory(MethodHandle implMethod, String expected) throws Throwable {\n+        CallSite cs = LambdaMetafactory.altMetafactory(MethodTest.LOOKUP, \"get\",\n+                                                       methodType(StringFactory.class, MethodTest.class),\n+                                                       methodType(String.class), implMethod, methodType(String.class),\n+                                                       LambdaMetafactory.FLAG_SERIALIZABLE);\n+        MethodTest o = new MethodTest.SubClass();\n+        StringFactory factory = (StringFactory) cs.dynamicInvoker().invokeExact(o);\n+        String actual = factory.get();\n+        Assert.assertEquals(actual, expected);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/invokeSpecial\/InvokeSpecialMethodTest.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"}]}