{"files":[{"patch":"@@ -2491,1 +2491,0 @@\n-        assert(in2->bottom_type()->isa_int(), \"Shift must always be an int value\");\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"opto\/convertnode.hpp\"\n@@ -314,0 +315,8 @@\n+  \/\/ If target does not support variable shift operations then no point\n+  \/\/ in creating a rotate vector node since it will not be disintegratable.\n+  \/\/ Adding a pessimistic check to avoid complex pattern mathing which\n+  \/\/ may not be full proof.\n+  if (!Matcher::supports_vector_variable_shifts()) {\n+     return false;\n+  }\n+\n@@ -1145,3 +1154,5 @@\n-  if (cnt->is_Con() && cnt->bottom_type()->isa_int()) {\n-    \/\/ Constant shift case.\n-    int shift = cnt->get_int() & shift_mask;\n+  const TypeInt* cnt_type = cnt->bottom_type()->isa_int();\n+  bool is_binary_vector_op = false;\n+  if (cnt_type && cnt_type->is_con()) {\n+    \/\/ Constant shift.\n+    int shift = cnt_type->get_con() & shift_mask;\n@@ -1150,3 +1161,2 @@\n-  } else {\n-    \/\/ Variable shift case.\n-    assert(VectorNode::is_invariant_vector(cnt), \"Broadcast expected\");\n+  } else if (VectorNode::is_invariant_vector(cnt)) {\n+    \/\/ Scalar variable shift, handle replicates generated by auto vectorizer.\n@@ -1156,2 +1166,7 @@\n-      assert(cnt->Opcode() == Op_ConvI2L, \"ConvI2L expected\");\n-      cnt = cnt->in(1);\n+      if (cnt->Opcode() == Op_ConvI2L) {\n+         cnt = cnt->in(1);\n+      } else {\n+         assert(cnt->bottom_type()->isa_long() &&\n+                cnt->bottom_type()->is_long()->is_con(), \"Long constant expected\");\n+         cnt = phase->transform(new ConvL2INode(cnt));\n+      }\n@@ -1161,0 +1176,22 @@\n+  } else {\n+    \/\/ Vector variable shift.\n+    assert(Matcher::supports_vector_variable_shifts(), \"\");\n+    assert(bt == T_INT, \"Variable vector case supported for integer type rotation\");\n+\n+    assert(cnt->bottom_type()->isa_vect(), \"Unexpected shift\");\n+    const Type* elem_ty = Type::get_const_basic_type(bt);\n+\n+    Node* shift_mask_node = phase->intcon(shift_mask);\n+    Node* const_one_node = phase->intcon(1);\n+\n+    int subVopc = VectorNode::opcode(Op_SubI, bt);\n+    int addVopc = VectorNode::opcode(Op_AddI, bt);\n+\n+    Node* vector_mask = phase->transform(VectorNode::scalar2vector(shift_mask_node, vlen, elem_ty));\n+    Node* vector_one = phase->transform(VectorNode::scalar2vector(const_one_node, vlen, elem_ty));\n+\n+    shiftRCnt = cnt;\n+    shiftRCnt = phase->transform(VectorNode::make(Op_AndV, shiftRCnt, vector_mask, vt));\n+    vector_mask = phase->transform(VectorNode::make(addVopc, vector_one, vector_mask, vt));\n+    shiftLCnt = phase->transform(VectorNode::make(subVopc, vector_mask, shiftRCnt, vt));\n+    is_binary_vector_op = true;\n@@ -1168,2 +1205,4 @@\n-  shiftLCnt = phase->transform(new LShiftCntVNode(shiftLCnt, vt));\n-  shiftRCnt = phase->transform(new RShiftCntVNode(shiftRCnt, vt));\n+  if (!is_binary_vector_op) {\n+    shiftLCnt = phase->transform(new LShiftCntVNode(shiftLCnt, vt));\n+    shiftRCnt = phase->transform(new RShiftCntVNode(shiftRCnt, vt));\n+  }\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":49,"deletions":10,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+  private static final int REPCOUNT = 16;\n@@ -47,0 +48,9 @@\n+  private static final int [] rolRes = {\n+    15, 32, 68, 144, 304, 640, 1344, 2816, 5888, 12288, 25600, 53248, 110592, 229376, 475136, 983040\n+  };\n+\n+  private static final int [] rorRes = {\n+    15, 8, 1073741828, 1073741826, 805306369, -1610612736, 1409286144, 738197504, 385875968, 201326592,\n+    104857600, 54525952, 28311552, 14680064, 7602176, 3932160\n+  };\n+\n@@ -61,0 +71,2 @@\n+  static int[] a2 = new int[ARRLEN];\n+  static int[] a3 = new int[ARRLEN];\n@@ -67,0 +79,2 @@\n+      a2[i] = (i & (REPCOUNT-1)) + VALUE;\n+      a3[i] = i & (REPCOUNT-1);\n@@ -96,0 +110,3 @@\n+\n+      test_rolv_vec(a0, a2, a3);\n+      test_rorv_vec(a0, a2, a3);\n@@ -191,1 +208,8 @@\n-\n+    test_rolv_vec(a0, a2, a3);\n+    for (int i=0; i<ARRLEN; i++) {\n+      errn += verify(\"test_rolv_vec: \", i, a0[i], rolRes[i & (REPCOUNT-1)]);\n+    }\n+    test_rorv_vec(a0, a2, a3);\n+    for (int i=0; i<ARRLEN; i++) {\n+      errn += verify(\"test_rorv_vec: \", i, a0[i], rorRes[i & (REPCOUNT-1)]);\n+    }\n@@ -361,0 +385,14 @@\n+\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_rorv_vec(a0, a2, a3);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_rorv_vec: \" + (end - start));\n+\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_rolv_vec(a0, a2, a3);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_rolv_vec: \" + (end - start));\n@@ -387,0 +425,13 @@\n+  static void test_rolv_vec(int[] a0, int[] a1, int [] a2) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = (int)(Integer.rotateLeft(a1[i], a2[i]));\n+    }\n+  }\n+\n+  static void test_rorv_vec(int[] a0, int[] a1, int [] a2) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = (int)(Integer.rotateRight(a1[i], a2[i]));\n+    }\n+  }\n+\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/cr6340864\/TestIntVectRotate.java","additions":52,"deletions":1,"binary":false,"changes":53,"status":"modified"}]}