{"files":[{"patch":"@@ -30,0 +30,1 @@\n+import java.util.concurrent.locks.StampedLock;\n@@ -37,0 +38,5 @@\n+    \/**\n+     * Prevent changing profiles data during transform creation.\n+     *\/\n+    private static final StampedLock lock = new StampedLock();\n+\n@@ -83,2 +89,7 @@\n-    public synchronized void setTagData(Profile p, int tagSignature, byte[] data) {\n-        getLcmsProfile(p).setTag(tagSignature, data);\n+    public void setTagData(Profile p, int tagSignature, byte[] data) {\n+        long stamp = lock.writeLock();\n+        try {\n+            getLcmsProfile(p).setTag(tagSignature, data);\n+        } finally {\n+            lock.unlockWrite(stamp);\n+        }\n@@ -97,5 +108,13 @@\n-\n-        for (int i = 0; i < profiles.length; i++) {\n-            if (profiles[i] == null) throw new CMMException(\"Unknown profile ID\");\n-\n-            ptrs[i] = profiles[i].getLcmsPtr();\n+        long stamp = lock.readLock();\n+        try {\n+            for (int i = 0; i < profiles.length; i++) {\n+                if (profiles[i] == null) {\n+                    throw new CMMException(\"Unknown profile ID\");\n+                }\n+                ptrs[i] = profiles[i].getLcmsPtr();\n+            }\n+\n+            return createNativeTransform(ptrs, renderType, inFormatter,\n+                    isInIntPacked, outFormatter, isOutIntPacked, disposerRef);\n+        } finally {\n+            lock.unlockRead(stamp);\n@@ -103,3 +122,0 @@\n-\n-        return createNativeTransform(ptrs, renderType, inFormatter,\n-                isInIntPacked, outFormatter, isOutIntPacked, disposerRef);\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/cmm\/lcms\/LCMS.java","additions":26,"deletions":10,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.color.ColorSpace;\n+import java.awt.color.ICC_ColorSpace;\n+import java.awt.color.ICC_Profile;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+\/**\n+ * @test\n+ * @bug 8271718\n+ * @summary Verifies MT safety of color transformation while profile is changed\n+ *\/\n+public final class MTTransformReplacedProfile {\n+\n+    private static volatile long endtime;\n+\n+    public static void main(String[] args) throws Exception {\n+        ICC_Profile[] profiles = {\n+                ICC_Profile.getInstance(ColorSpace.CS_sRGB),\n+                ICC_Profile.getInstance(ColorSpace.CS_LINEAR_RGB),\n+                ICC_Profile.getInstance(ColorSpace.CS_CIEXYZ),\n+                ICC_Profile.getInstance(ColorSpace.CS_PYCC),\n+                ICC_Profile.getInstance(ColorSpace.CS_GRAY)\n+        };\n+\n+        List<Integer> tags = new ArrayList<>();\n+        for (Field field : ICC_Profile.class.getDeclaredFields()) {\n+            if (Modifier.isStatic(field.getModifiers())\n+                    && Modifier.isPublic(field.getModifiers())\n+                    && Modifier.isFinal(field.getModifiers())\n+                    && field.getType() == int.class) {\n+                tags.add(field.getInt(null));\n+            }\n+        }\n+\n+        List<Thread> tasks = new ArrayList<>();\n+        for (int tag : tags) {\n+            for (ICC_Profile profile1 : profiles) {\n+                for (ICC_Profile profile2 : profiles) {\n+                    byte[] d1 = profile1.getData(tag);\n+                    byte[] d2 = profile2.getData(tag);\n+                    if (d1 == null || d2 == null) {\n+                        continue;\n+                    }\n+                    tasks.add(new Thread(() -> {\n+                        try {\n+                            test(profile1.getData(), d1, d2, tag);\n+                        } catch (Throwable ignored) {\n+                            \/\/ only the crash is the test failure\n+                        }\n+                    }));\n+                }\n+            }\n+        }\n+\n+        \/\/ Try to run the test no more than 15 seconds\n+        endtime = System.nanoTime() + TimeUnit.SECONDS.toNanos(15);\n+        for (Thread t : tasks) {\n+            t.start();\n+        }\n+        for (Thread t : tasks) {\n+            t.join();\n+        }\n+    }\n+\n+    private static void test(byte[] all, byte[] data1, byte[] data2, int tag)\n+            throws Exception {\n+        ICC_Profile icc = ICC_Profile.getInstance(all);\n+        ColorSpace cs = new ICC_ColorSpace(icc);\n+        AtomicBoolean stop = new AtomicBoolean();\n+        Thread swap = new Thread(() -> {\n+            try {\n+                while (!isComplete()) {\n+                    icc.setData(tag, data1);\n+                    icc.setData(tag, data2);\n+                }\n+            } catch (Throwable ignored) {\n+                \/\/ only the crash is the test failure\n+            }\n+            stop.set(true);\n+        });\n+\n+        float[] colorvalue = new float[3];\n+        Thread transform = new Thread(() -> {\n+            boolean rgb = true;\n+            while (!stop.get()) {\n+                try {\n+                    if (rgb) {\n+                        cs.toRGB(colorvalue);\n+                    } else {\n+                        cs.toCIEXYZ(colorvalue);\n+                    }\n+                } catch (Throwable ignored) {\n+                    \/\/ only the crash is the test failure\n+                }\n+                rgb = !rgb;\n+            }\n+        });\n+\n+        swap.start();\n+        transform.start();\n+        swap.join();\n+        transform.join();\n+    }\n+\n+    private static boolean isComplete() {\n+        return endtime - System.nanoTime() < 0;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/color\/ICC_ColorSpace\/MTTransformReplacedProfile.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"}]}