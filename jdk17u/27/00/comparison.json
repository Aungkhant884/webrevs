{"files":[{"patch":"@@ -28,0 +28,1 @@\n+ * @library \/test\/lib \/\n@@ -44,0 +45,1 @@\n+ * @library \/test\/lib \/\n@@ -55,0 +57,1 @@\n+ * @library \/test\/lib \/\n@@ -66,0 +69,1 @@\n+ * @library \/test\/lib \/\n@@ -77,0 +81,1 @@\n+ * @library \/test\/lib \/\n@@ -88,0 +93,1 @@\n+ * @library \/test\/lib \/\n@@ -107,0 +113,2 @@\n+import jdk.test.lib.Utils;\n+\n@@ -124,0 +132,2 @@\n+        final long startTime = System.currentTimeMillis();\n+\n@@ -162,9 +172,0 @@\n-        \/\/ Wait until notifications start arriving, and then wait some more\n-        \/\/ to catch the ones arriving late.\n-        while (churnBytes.get() == 0) {\n-            Thread.sleep(1000);\n-        }\n-        Thread.sleep(5000);\n-\n-        long actual = churnBytes.get();\n-\n@@ -173,0 +174,20 @@\n+        long actual = 0;\n+\n+        \/\/ Look at test timeout to figure out how long we can wait without breaking into timeout.\n+        \/\/ Default to 1\/4 of the remaining time in 1s steps.\n+        final long STEP_MS = 1000;\n+        long spentTime = System.currentTimeMillis() - startTime;\n+        long maxTries = (Utils.adjustTimeout(Utils.DEFAULT_TEST_TIMEOUT) - spentTime) \/ STEP_MS \/ 4;\n+\n+        \/\/ Wait until enough notifications are accrued to match minimum boundary.\n+        long tries = 0;\n+        while (tries++ < maxTries) {\n+            actual = churnBytes.get();\n+            if (minExpected <= actual) {\n+                \/\/ Wait some more to test if we are breaking the maximum boundary.\n+                Thread.sleep(5000);\n+                actual = churnBytes.get();\n+                break;\n+            }\n+            Thread.sleep(STEP_MS);\n+        }\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/mxbeans\/TestChurnNotifications.java","additions":30,"deletions":9,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @library \/test\/lib \/\n@@ -44,0 +45,1 @@\n+ * @library \/test\/lib \/\n@@ -54,0 +56,1 @@\n+ * @library \/test\/lib \/\n@@ -64,0 +67,1 @@\n+ * @library \/test\/lib \/\n@@ -74,0 +78,1 @@\n+ * @library \/test\/lib \/\n@@ -84,0 +89,1 @@\n+ * @library \/test\/lib \/\n@@ -101,0 +107,2 @@\n+import jdk.test.lib.Utils;\n+\n@@ -111,0 +119,2 @@\n+        final long startTime = System.currentTimeMillis();\n+\n@@ -113,0 +123,2 @@\n+        final AtomicLong pausesCount = new AtomicLong();\n+        final AtomicLong cyclesCount = new AtomicLong();\n@@ -120,3 +132,1 @@\n-                    System.out.println(info.getGcInfo().toString());\n-                    System.out.println(info.getGcName());\n-                    System.out.println();\n+                    System.out.println(\"Received: \" + info.getGcName());\n@@ -129,0 +139,1 @@\n+                            pausesCount.incrementAndGet();\n@@ -131,0 +142,1 @@\n+                            cyclesCount.incrementAndGet();\n@@ -151,4 +163,24 @@\n-        \/\/ Wait until notifications start arriving, and then wait some more\n-        \/\/ to catch the ones arriving late.\n-        while (pausesDuration.get() == 0) {\n-            Thread.sleep(1000);\n+        \/\/ Look at test timeout to figure out how long we can wait without breaking into timeout.\n+        \/\/ Default to 1\/4 of the remaining time in 1s steps.\n+        final long STEP_MS = 1000;\n+        long spentTime = System.currentTimeMillis() - startTime;\n+        long maxTries = (Utils.adjustTimeout(Utils.DEFAULT_TEST_TIMEOUT) - spentTime) \/ STEP_MS \/ 4;\n+\n+        long actualPauses = 0;\n+        long actualCycles = 0;\n+\n+        \/\/ Wait until enough notifications are accrued to match minimum boundary.\n+        long minExpected = 10;\n+\n+        long tries = 0;\n+        while (tries++ < maxTries) {\n+            actualPauses = pausesCount.get();\n+            actualCycles = cyclesCount.get();\n+            if (minExpected <= actualPauses && minExpected <= actualCycles) {\n+                \/\/ Wait a little bit to catch the lingering notifications.\n+                Thread.sleep(5000);\n+                actualPauses = pausesCount.get();\n+                actualCycles = cyclesCount.get();\n+                break;\n+            }\n+            Thread.sleep(STEP_MS);\n@@ -156,7 +188,0 @@\n-        Thread.sleep(5000);\n-\n-        long pausesActual = pausesDuration.get();\n-        long cyclesActual = cyclesDuration.get();\n-\n-        long minExpected = 1;\n-        long maxExpected = Long.MAX_VALUE;\n@@ -165,2 +190,2 @@\n-            String msg = \"Pauses expected = [\" + minExpected + \"; \" + maxExpected + \"], actual = \" + pausesActual;\n-            if (minExpected <= pausesActual && pausesActual <= maxExpected) {\n+            String msg = \"Pauses expected = [\" + minExpected + \"; +inf], actual = \" + actualPauses;\n+            if (minExpected <= actualPauses) {\n@@ -174,2 +199,2 @@\n-            String msg = \"Cycles expected = [\" + minExpected + \"; \" + maxExpected + \"], actual = \" + cyclesActual;\n-            if (minExpected <= cyclesActual && cyclesActual <= maxExpected) {\n+            String msg = \"Cycles expected = [\" + minExpected + \"; +inf], actual = \" + actualCycles;\n+            if (minExpected <= actualCycles) {\n@@ -183,2 +208,6 @@\n-            String msg = \"Cycle duration (\" + cyclesActual + \"), pause duration (\" + pausesActual + \")\";\n-            if (pausesActual <= cyclesActual) {\n+            long actualPauseDuration = pausesDuration.get();\n+            long actualCycleDuration = cyclesDuration.get();\n+\n+            String msg = \"Pauses duration (\" + actualPauseDuration + \") is expected to be not larger than cycles duration (\" + actualCycleDuration + \")\";\n+\n+            if (actualPauseDuration <= actualCycleDuration) {\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/mxbeans\/TestPauseNotifications.java","additions":49,"deletions":20,"binary":false,"changes":69,"status":"modified"}]}