{"files":[{"patch":"@@ -54,1 +54,0 @@\n-    private int maxFootprint;\n@@ -61,1 +60,0 @@\n-    private int totalCpuCount;\n@@ -63,0 +61,1 @@\n+    private int heapPerFork;\n@@ -110,1 +109,1 @@\n-        OptionSpec<Integer> maxFootprint = parser.accepts(\"mf\", \"Maximum footprint for each test, in megabytes. This \" +\n+        OptionSpec<Integer> heapPerFork = parser.accepts(\"hs\", \"Java heap size per fork, in megabytes. This \" +\n@@ -184,1 +183,1 @@\n-        totalCpuCount = VMSupport.figureOutHotCPUs();\n+        int totalCpuCount = VMSupport.figureOutHotCPUs();\n@@ -239,1 +238,1 @@\n-        this.maxFootprint = orDefault(set.valueOf(maxFootprint), 100);\n+        this.heapPerFork = orDefault(set.valueOf(heapPerFork), 256);\n@@ -348,4 +347,0 @@\n-    public int getTotalCPUCount() {\n-        return totalCpuCount;\n-    }\n-\n@@ -364,0 +359,4 @@\n+    public int getHeapPerForkMb() {\n+        return heapPerFork;\n+    }\n+\n@@ -365,1 +364,2 @@\n-        return maxFootprint;\n+        \/\/ Half of heap size.\n+        return getHeapPerForkMb() \/ 2;\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/Options.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -212,5 +212,0 @@\n-        if (data.contains(\"Option MaxRAMFraction was deprecated in version\") ||\n-            data.contains(\"Option MinRAMFraction was deprecated in version\")) {\n-            return true;\n-        }\n-\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/infra\/grading\/ReportUtils.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -75,14 +75,9 @@\n-        \/\/ Rationale: every test VM uses at least 2 threads. Which means there are at max $CPU\/2 VMs.\n-        \/\/ Reserving half of the RSS of each VM to Java heap leaves enough space for native RSS and\n-        \/\/ other processes. This means multiplying the factor by 2. These two adjustments cancel each\n-        \/\/ other.\n-        \/\/\n-        \/\/ It does not matter if user requested lower number of VMs, we still want to follow\n-        \/\/ the global per-VM fraction. This would trim down the memory requirements along with\n-        \/\/ CPU requirements.\n-        \/\/\n-        \/\/ Setting -Xms\/-Xmx explicitly is supposed to override these defaults.\n-        \/\/\n-        int part = opts.getTotalCPUCount();\n-\n-        detect(\"Trimming down the default VM heap size to 1\/\" + part + \"-th of max RAM\",\n+        \/\/ Tests are supposed to run in a very tight memory constraints:\n+        \/\/ the test objects are small and reused where possible. The footprint\n+        \/\/ testing machinery would select appropriate stride sizes to fit the heap.\n+        \/\/ Users can override this to work on smaller\/larger machines, but it should\n+        \/\/ not be necessary, as even the smallest machines usually have more than 256M\n+        \/\/ of system memory per CPU.\n+\n+        int heap = opts.getHeapPerForkMb();\n+        detect(\"Trimming down the VM heap size to \" + heap + \"M\",\n@@ -91,1 +86,1 @@\n-                \"-XX:MaxRAMFraction=\" + part, \"-XX:MinRAMFraction=\" + part);\n+                \"-Xms\" + heap + \"M\", \"-Xmx\" + heap + \"M\");\n@@ -93,5 +88,9 @@\n-        detect(\"Trimming down the number of compiler threads\",\n-                SimpleTestMain.class,\n-                GLOBAL_JVM_FLAGS,\n-                \"-XX:CICompilerCount=2\" \/\/ This is the absolute minimum for tiered configurations\n-        );\n+        \/\/ The tests are usually not GC heavy. The minimum amount of threads a jcstress\n+        \/\/ test uses is 2, so we can expect the CPU affinity machinery to allocate at\n+        \/\/ least 2 CPUs per fork. This gives us the upper bound for the number of GC threads: 2,\n+        \/\/ otherwise we risk oversubscribing the forked VM.\n+        \/\/\n+        \/\/ We could, theoretically, drop the number of GC threads to 1, but GC ergonomics\n+        \/\/ sometimes decides to switch to single-threaded mode in some GC implementations\n+        \/\/ (e.g. for reference processing), and it would make sense to let GC run in multi-threaded\n+        \/\/ modes instead.\n@@ -102,1 +101,1 @@\n-                \"-XX:ParallelGCThreads=4\"\n+                \"-XX:ParallelGCThreads=2\"\n@@ -108,1 +107,1 @@\n-                \"-XX:ConcGCThreads=4\"\n+                \"-XX:ConcGCThreads=2\"\n@@ -114,1 +113,7 @@\n-                \"-XX:G1ConcRefinementThreads=4\"\n+                \"-XX:G1ConcRefinementThreads=2\"\n+        );\n+\n+        detect(\"Trimming down the number of compiler threads\",\n+                SimpleTestMain.class,\n+                GLOBAL_JVM_FLAGS,\n+                \"-XX:CICompilerCount=2\" \/\/ This is the absolute minimum for tiered configurations\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/vm\/VMSupport.java","additions":28,"deletions":23,"binary":false,"changes":51,"status":"modified"}]}