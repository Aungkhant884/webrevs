{"files":[{"patch":"@@ -36,2 +36,1 @@\n-import org.openjdk.jcstress.util.HashMultimap;\n-import org.openjdk.jcstress.util.Multimap;\n+import org.openjdk.jcstress.util.*;\n@@ -42,1 +41,0 @@\n-import java.nio.file.Files;\n@@ -177,3 +175,1 @@\n-        private final File stdout;\n-        private final File stderr;\n-        private final File compilerDirectives;\n+        private File compilerDirectives;\n@@ -186,0 +182,2 @@\n+        private InputStreamCollector errCollector;\n+        private InputStreamCollector outCollector;\n@@ -193,6 +191,2 @@\n-            try {\n-                this.stdout = File.createTempFile(\"jcstress\", \"stdout\");\n-                this.stderr = File.createTempFile(\"jcstress\", \"stderr\");\n-                this.compilerDirectives = File.createTempFile(\"jcstress\", \"directives\");\n-\n-                if (VMSupport.compilerDirectivesAvailable()) {\n+            if (VMSupport.compilerDirectivesAvailable()) {\n+                try {\n@@ -200,0 +194,2 @@\n+                } catch (IOException e) {\n+                    throw new IllegalStateException(e);\n@@ -201,7 +197,0 @@\n-\n-                \/\/ Register these files for removal in case we terminate through the uncommon path\n-                this.stdout.deleteOnExit();\n-                this.stderr.deleteOnExit();\n-                this.compilerDirectives.deleteOnExit();\n-            } catch (IOException e) {\n-                throw new IllegalStateException(e);\n@@ -212,0 +201,5 @@\n+            compilerDirectives = File.createTempFile(\"jcstress\", \"directives\");\n+\n+            \/\/ Register these files for removal in case we terminate through the uncommon path\n+            compilerDirectives.deleteOnExit();\n+\n@@ -341,2 +335,0 @@\n-                pb.redirectOutput(stdout);\n-                pb.redirectError(stderr);\n@@ -344,0 +336,10 @@\n+\n+                \/\/ start the stream drainers and read the streams into memory;\n+                \/\/ makes little sense to write them to files, since we would be\n+                \/\/ reading them back soon anyway\n+                errCollector = new InputStreamCollector(process.getErrorStream());\n+                outCollector = new InputStreamCollector(process.getInputStream());\n+\n+                errCollector.start();\n+                outCollector.start();\n+\n@@ -379,13 +381,2 @@\n-                List<String> out = new ArrayList<>();\n-                try {\n-                    out.addAll(Files.readAllLines(stdout.toPath()));\n-                } catch (IOException e) {\n-                    out.add(\"Failed to read stdout: \" + e.getMessage());\n-                }\n-\n-                List<String> err = new ArrayList<>();\n-                try {\n-                    err.addAll(Files.readAllLines(stderr.toPath()));\n-                } catch (IOException e) {\n-                    err.add(\"Failed to read stderr: \" + e.getMessage());\n-                }\n+                outCollector.join();\n+                errCollector.join();\n@@ -397,2 +388,2 @@\n-                result.addVMOuts(out);\n-                result.addVMErrs(err);\n+                result.addVMOuts(outCollector.getOutput());\n+                result.addVMErrs(errCollector.getOutput());\n@@ -406,2 +397,3 @@\n-                stdout.delete();\n-                stderr.delete();\n+                if (compilerDirectives != null) {\n+                    compilerDirectives.delete();\n+                }\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/TestExecutor.java","additions":30,"deletions":38,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jcstress.util;\n+\n+import java.io.*;\n+import java.nio.Buffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+public class InputStreamCollector extends Thread {\n+\n+    private final InputStream in;\n+    private final List<String> list;\n+\n+    public InputStreamCollector(InputStream in) {\n+        this.in = in;\n+        this.list = new ArrayList<>();\n+    }\n+\n+    public void run() {\n+        try (InputStreamReader isr = new InputStreamReader(in);\n+             BufferedReader br = new BufferedReader(isr)) {\n+            String line;\n+            while ((line = br.readLine()) != null) {\n+                list.add(line);\n+            }\n+        } catch (IOException e) {\n+            \/\/ Do nothing.\n+        }\n+    }\n+\n+    public List<String> getOutput() {\n+        return list;\n+    }\n+\n+}\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/util\/InputStreamCollector.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"}]}