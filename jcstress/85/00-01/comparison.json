{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import org.openjdk.jcstress.infra.results.ZZ_Result;\n@@ -37,0 +38,4 @@\n+\/*\n+    How to run this test:\n+        $ java -jar jcstress-samples\/target\/jcstress.jar -t Mutex_01_NoAlgorithm\n+*\/\n@@ -38,0 +43,7 @@\n+\/**\n+ * This sample demonstrates you how you can introduce a critical section to check algorithms\n+ * which ensure only one actor at most can enter the critical section.\n+ *\/\n+@JCStressTest\n+@Outcome(id = {\"true, true\", \"true, false\", \"false, true\", \"false, false\"}, expect = ACCEPTABLE, desc = \"Both actors have entered the critical section whenever they wanted\")\n+@State\n@@ -39,0 +51,1 @@\n+    private volatile boolean taken1, taken2;\n@@ -40,23 +53,6 @@\n-    \/*\n-        How to run this test:\n-            $ java -jar jcstress-samples\/target\/jcstress.jar -t Mutex_01_NoAlgorithm\n-     *\/\n-    \/**\n-     * This sample demonstrates you how you can introduce a critical section to check algorithms\n-     * which ensure only one actor at most can enter the critical section.\n-     *\/\n-    @JCStressTest\n-    @Outcome(id = {\"1, 1\", \"1, 2\", \"2, 1\", \"2, 2\"}, expect = ACCEPTABLE, desc = \"Both actors can enter the critical section one by one but must not\")\n-    @State\n-    public static class NoAlgorithm {\n-        private final AtomicBoolean isInCriticalSection = new AtomicBoolean();\n-\n-        @Actor\n-        public void actor1(II_Result r) {\n-            if (isInCriticalSection.compareAndSet(false, true)) {\n-                r.r1 = 1;\n-                isInCriticalSection.set(false);\n-            } else {\n-                r.r1 = 2;\n-            }\n-        }\n+    @Actor\n+    public void actor1(ZZ_Result r) {\n+        taken1 = true;\n+        r.r1 = taken2;\n+        taken1 = false;\n+    }\n@@ -64,9 +60,5 @@\n-        @Actor\n-        public void actor2(II_Result r) {\n-            if (isInCriticalSection.compareAndSet(false, true)) {\n-                r.r2 = 1;\n-                isInCriticalSection.set(false);\n-            } else {\n-                r.r2 = 2;\n-            }\n-        }\n+    @Actor\n+    public void actor2(ZZ_Result r) {\n+        taken2 = true;\n+        r.r2 = taken1;\n+        taken2 = false;\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/concurreny\/mutex\/Mutex_01_NoAlgorithm.java","additions":25,"deletions":33,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import org.openjdk.jcstress.infra.results.ZZ_Result;\n@@ -39,6 +40,4 @@\n-public class Mutex_02_PetersonAlgorithm {\n-\n-    \/*\n-        How to run this test:\n-            $ java -jar jcstress-samples\/target\/jcstress.jar -t Mutex_02_PetersonAlgorithm\n-     *\/\n+\/*\n+    How to run this test:\n+        $ java -jar jcstress-samples\/target\/jcstress.jar -t Mutex_02_PetersonAlgorithm\n+ *\/\n@@ -46,13 +45,12 @@\n-    \/**\n-     * Implemented according to https:\/\/en.wikipedia.org\/wiki\/Peterson%27s_algorithm\n-     *\/\n-    @JCStressTest\n-    @Outcome(id = {\"1, 1\"}, expect = ACCEPTABLE, desc = \"Both actors could enter the critical section\")\n-    @Outcome(id = {\"1, 2\", \"2, 1\", \"2, 2\"}, expect = FORBIDDEN, desc = \"At least one actor couldn't enter the critical section\")\n-    @Outcome(id = {\"0, 0\", \"0, 1\", \"1, 0\", \"0, 2\", \"2, 0\"}, expect = FORBIDDEN, desc = \"At least one actor hang up in the loop\")\n-    @State\n-    public static class PetersonAlgorithm {\n-        private final AtomicBoolean flagForActor1 = new AtomicBoolean();\n-        private final AtomicBoolean flagForActor2 = new AtomicBoolean();\n-        private final AtomicInteger turn = new AtomicInteger();\n-        private final AtomicBoolean isInCriticalSection = new AtomicBoolean();\n+\/**\n+ * Implemented according to https:\/\/en.wikipedia.org\/wiki\/Peterson%27s_algorithm\n+ *\/\n+@JCStressTest\n+@Outcome(id = {\"false, false\"}, expect = ACCEPTABLE, desc = \"Both actors have entered the critical section one after another\")\n+@Outcome(id = {\"true, false\", \"false, true\", \"true, true\"}, expect = FORBIDDEN, desc = \"Both actors have entered the critical section at the same time\")\n+@State\n+public class Mutex_02_PetersonAlgorithm {\n+    private final AtomicBoolean flagForActor1 = new AtomicBoolean();\n+    private final AtomicBoolean flagForActor2 = new AtomicBoolean();\n+    private final AtomicInteger turn = new AtomicInteger();\n+    private volatile boolean taken1, taken2;\n@@ -60,13 +58,10 @@\n-        @Actor\n-        public void actor1(II_Result r) {\n-            flagForActor1.set(true);\n-            turn.set(2);\n-            while (flagForActor2.get() && turn.get() == 2) ;\n-            if (isInCriticalSection.compareAndSet(false, true)) {\n-                r.r1 = 1;\n-                isInCriticalSection.set(false);\n-            } else {\n-                r.r1 = 2;\n-            }\n-            flagForActor1.set(false);\n-        }\n+    @Actor\n+    public void actor1(ZZ_Result r) {\n+        flagForActor1.set(true);\n+        turn.set(2);\n+        while (flagForActor2.get() && turn.get() == 2) ;\n+        taken1 = true;\n+        r.r1 = taken2;\n+        taken1 = false;\n+        flagForActor1.set(false);\n+    }\n@@ -74,13 +69,9 @@\n-        @Actor\n-        public void actor2(II_Result r) {\n-            flagForActor2.set(true);\n-            turn.set(1);\n-            while (flagForActor1.get() && turn.get() == 1) ;\n-            if (isInCriticalSection.compareAndSet(false, true)) {\n-                r.r2 = 1;\n-                isInCriticalSection.set(false);\n-            } else {\n-                r.r2 = 2;\n-            }\n-            flagForActor2.set(false);\n-        }\n+    @Actor\n+    public void actor2(ZZ_Result r) {\n+        flagForActor2.set(true);\n+        turn.set(1);\n+        while (flagForActor1.get() && turn.get() == 1) ;\n+        taken2 = true;\n+        r.r2 = taken1;\n+        taken2 = false;\n+        flagForActor2.set(false);\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/concurreny\/mutex\/Mutex_02_PetersonAlgorithm.java","additions":37,"deletions":46,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import org.openjdk.jcstress.infra.results.ZZ_Result;\n@@ -39,6 +40,4 @@\n-public class Mutex_03_DekkerAlgorithm {\n-\n-    \/*\n-        How to run this test:\n-            $ java -jar jcstress-samples\/target\/jcstress.jar -t Mutex_03_DekkerAlgorithm\n-     *\/\n+\/*\n+    How to run this test:\n+        $ java -jar jcstress-samples\/target\/jcstress.jar -t Mutex_03_DekkerAlgorithm\n+*\/\n@@ -46,13 +45,12 @@\n-    \/**\n-     * Implemented according to https:\/\/en.wikipedia.org\/wiki\/Dekker%27s_algorithm\n-     *\/\n-    @JCStressTest\n-    @Outcome(id = {\"1, 1\"}, expect = ACCEPTABLE, desc = \"Both actors could enter the critical section\")\n-    @Outcome(id = {\"1, 2\", \"2, 1\", \"2, 2\"}, expect = FORBIDDEN, desc = \"At least one actor couldn't enter the critical section\")\n-    @Outcome(id = {\"0, 0\", \"0, 1\", \"1, 0\", \"0, 2\", \"2, 0\"}, expect = FORBIDDEN, desc = \"At least one actor hang up in one of the loops\")\n-    @State\n-    public static class DekkerAlgorithm {\n-        private final AtomicBoolean actor1wantsToEnter = new AtomicBoolean();\n-        private final AtomicBoolean actor2wantsToEnter = new AtomicBoolean();\n-        private final AtomicInteger turn = new AtomicInteger(0);\n-        private final AtomicBoolean isInCriticalSection = new AtomicBoolean();\n+\/**\n+ * Implemented according to https:\/\/en.wikipedia.org\/wiki\/Dekker%27s_algorithm\n+ *\/\n+@JCStressTest\n+@Outcome(id = {\"false, false\"}, expect = ACCEPTABLE, desc = \"Both actors have entered the critical section one after another\")\n+@Outcome(id = {\"true, false\", \"false, true\", \"true, true\"}, expect = FORBIDDEN, desc = \"Both actors have entered the critical section at the same time\")\n+@State\n+public class Mutex_03_DekkerAlgorithm {\n+    private final AtomicBoolean actor1wantsToEnter = new AtomicBoolean();\n+    private final AtomicBoolean actor2wantsToEnter = new AtomicBoolean();\n+    private final AtomicInteger turn = new AtomicInteger(0);\n+    private volatile boolean taken1, taken2;\n@@ -60,15 +58,8 @@\n-        @Actor\n-        public void actor1(II_Result r) {\n-            actor1wantsToEnter.set(true);\n-            while (actor2wantsToEnter.get()) {\n-                if (turn.get() != 0) {\n-                    actor1wantsToEnter.set(false);\n-                    while (turn.get() != 0) ;\n-                    actor1wantsToEnter.set(true);\n-                }\n-            }\n-            if (isInCriticalSection.compareAndSet(false, true)) {\n-                r.r1 = 1;\n-                isInCriticalSection.set(false);\n-            } else {\n-                r.r1 = 2;\n+    @Actor\n+    public void actor1(ZZ_Result r) {\n+        actor1wantsToEnter.set(true);\n+        while (actor2wantsToEnter.get()) {\n+            if (turn.get() != 0) {\n+                actor1wantsToEnter.set(false);\n+                while (turn.get() != 0) ;\n+                actor1wantsToEnter.set(true);\n@@ -76,2 +67,0 @@\n-            turn.set(1);\n-            actor1wantsToEnter.set(false);\n@@ -79,0 +68,6 @@\n+        taken1 = true;\n+        r.r1 = taken2;\n+        taken1 = false;\n+        turn.set(1);\n+        actor1wantsToEnter.set(false);\n+    }\n@@ -80,15 +75,8 @@\n-        @Actor\n-        public void actor2(II_Result r) {\n-            actor2wantsToEnter.set(true);\n-            while (actor1wantsToEnter.get()) {\n-                if (turn.get() != 1) {\n-                    actor2wantsToEnter.set(false);\n-                    while (turn.get() != 1) ;\n-                    actor2wantsToEnter.set(true);\n-                }\n-            }\n-            if (isInCriticalSection.compareAndSet(false, true)) {\n-                r.r2 = 1;\n-                isInCriticalSection.set(false);\n-            } else {\n-                r.r2 = 2;\n+    @Actor\n+    public void actor2(ZZ_Result r) {\n+        actor2wantsToEnter.set(true);\n+        while (actor1wantsToEnter.get()) {\n+            if (turn.get() != 1) {\n+                actor2wantsToEnter.set(false);\n+                while (turn.get() != 1) ;\n+                actor2wantsToEnter.set(true);\n@@ -96,2 +84,0 @@\n-            turn.set(0);\n-            actor2wantsToEnter.set(false);\n@@ -99,0 +85,5 @@\n+        taken2 = true;\n+        r.r2 = taken1;\n+        taken2 = false;\n+        turn.set(0);\n+        actor2wantsToEnter.set(false);\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/concurreny\/mutex\/Mutex_03_DekkerAlgorithm.java","additions":45,"deletions":54,"binary":false,"changes":99,"status":"modified"}]}