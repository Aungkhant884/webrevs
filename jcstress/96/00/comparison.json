{"files":[{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jcstress.samples.high.rmw;\n+\n+import org.openjdk.jcstress.annotations.*;\n+import org.openjdk.jcstress.infra.results.ZI_Result;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+\n+import static org.openjdk.jcstress.annotations.Expect.*;\n+\n+public class RMW_10_FailureWitness {\n+\n+    \/*\n+        How to run this test:\n+            $ java -jar jcstress-samples\/target\/jcstress.jar -t RMW_10_FailureWitness[.SubTestName]\n+     *\/\n+\n+    abstract static class Base {\n+        static final VarHandle VH;\n+\n+        static {\n+            try {\n+                VH = MethodHandles.lookup().findVarHandle(Base.class, \"v\", int.class);\n+            } catch (NoSuchFieldException | IllegalAccessException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }\n+\n+        int v;\n+    }\n+\n+    \/*\n+      ----------------------------------------------------------------------------------------------------------\n+\n+        This example shows one of the cases where having a \"failure witness\" for the failing CAS\n+        operation is useful. Failure witness is the memory value that CAS had failed on -- the one\n+        that was not expected by the CAS.\n+\n+        Re-reading the memory value \"right after\" the CAS update can show oddities: it could\n+        show the interfering updated that now matches the expected value from the CAS! This would\n+        look like a spurious failure in CAS, except that it is allowed by a simple interleaving.\n+\n+        In this example, a CAS that expected \"0\" failed, and yet there is \"0\" in memory.\n+\n+        On x86_64:\n+            RESULT         SAMPLES     FREQ       EXPECT  DESCRIPTION\n+          false, 0      65,410,888    0.13%  Interesting  Whoa\n+          false, 1  24,486,524,897   47.97%   Acceptable  Trivial\n+           true, 0      25,634,745    0.05%   Acceptable  Trivial\n+           true, 1  26,473,074,974   51.86%   Acceptable  Trivial\n+     *\/\n+\n+    @JCStressTest\n+    @Outcome(id = \"false, 0\",                         expect = ACCEPTABLE_INTERESTING, desc = \"Whoa\")\n+    @Outcome(id = {\"false, 1\", \"true, 0\", \"true, 1\"}, expect = ACCEPTABLE, desc = \"Trivial\")\n+    @State\n+    public static class BooleanCAS extends Base {\n+        @Actor\n+        public void actor1(ZI_Result r) {\n+            r.r1 = VH.compareAndSet(this, 0, 1);\n+            r.r2 = (int) VH.get(this);\n+        }\n+\n+        @Actor\n+        public void actor2() {\n+            VH.set(this, 0);\n+        }\n+\n+        @Actor\n+        public void actor3() {\n+            VH.set(this, 1);\n+        }\n+    }\n+\n+    \/*\n+      ----------------------------------------------------------------------------------------------------------\n+\n+        With witness, we clearly know what was the memory value CAS had failed on, so the\n+        interesting outcome is now forbidden.\n+\n+        On x86_64:\n+            RESULT         SAMPLES     FREQ      EXPECT  DESCRIPTION\n+          false, 0               0    0.00%   Forbidden  Cannot happen\n+          false, 1  26,892,302,582   49.43%  Acceptable  Trivial\n+           true, 0  27,516,182,282   50.57%  Acceptable  Trivial\n+           true, 1               0    0.00%  Acceptable  Trivial\n+     *\/\n+\n+    @JCStressTest\n+    @Outcome(id = \"false, 0\",                         expect = FORBIDDEN,  desc = \"Cannot happen\")\n+    @Outcome(id = {\"false, 1\", \"true, 0\", \"true, 1\"}, expect = ACCEPTABLE, desc = \"Trivial\")\n+    @State\n+    public static class WitnessCAS extends Base {\n+        @Actor\n+        public void actor1(ZI_Result r) {\n+            int witness = (int) VH.compareAndExchange(this, 0, 1);\n+            r.r1 = (witness == 0);\n+            r.r2 = witness;\n+        }\n+\n+        @Actor\n+        public void actor2() {\n+            VH.set(this, 0);\n+        }\n+\n+        @Actor\n+        public void actor3() {\n+            VH.set(this, 1);\n+        }\n+    }\n+\n+}\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/high\/rmw\/RMW_10_FailureWitness.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jcstress.samples.high.rmw;\n+\n+import org.openjdk.jcstress.annotations.*;\n+import org.openjdk.jcstress.infra.results.LLLL_Result;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+\n+import static org.openjdk.jcstress.annotations.Expect.ACCEPTABLE;\n+\n+@JCStressTest\n+@Outcome(id = {\"WRITE-BLOCKED, WRITE-BLOCKED, WRITE-BLOCKED, write-lock\",\n+               \"WRITE-BLOCKED, WRITE-BLOCKED, write-lock, WRITE-BLOCKED\"},\n+        expect = ACCEPTABLE, desc = \"One writer locked\")\n+@Outcome(id = {\"read-lock-1, read-lock-2, READ-BLOCKED, READ-BLOCKED\",\n+               \"read-lock-2, read-lock-1, READ-BLOCKED, READ-BLOCKED\"},\n+        expect = ACCEPTABLE, desc = \"Two readers locked\")\n+@State\n+public class RMW_11_FailureWitnessRWL {\n+\n+    \/*\n+        How to run this test:\n+            $ java -jar jcstress-samples\/target\/jcstress.jar -t RMW_11_FailureWitnessRWL[.SubTestName]\n+     *\/\n+\n+    \/*\n+      ----------------------------------------------------------------------------------------------------------\n+\n+        Failure witness is helpful when the updates are not monotonic, and you would like to see\n+        what exact value you have failed against. Re-reading the value would not help, because it\n+        might be racy, as RMW_10_FailureWitness shows.\n+\n+        Consider, for example, a reduced version of read-write lock. With failure witness, we can\n+        easily disambiguate whether we have conflicted with another reader or another writer.\n+\n+        On x86_64:\n+                                                           RESULT        SAMPLES     FREQ      EXPECT  DESCRIPTION\n+          WRITE-BLOCKED, WRITE-BLOCKED, WRITE-BLOCKED, write-lock  2,123,068,906   25.22%  Acceptable  One writer locked\n+          WRITE-BLOCKED, WRITE-BLOCKED, write-lock, WRITE-BLOCKED  1,992,233,099   23.67%  Acceptable  One writer locked\n+             read-lock-1, read-lock-2, READ-BLOCKED, READ-BLOCKED  2,258,993,329   26.84%  Acceptable  Two readers locked\n+             read-lock-2, read-lock-1, READ-BLOCKED, READ-BLOCKED  2,043,097,306   24.27%  Acceptable  Two readers locked\n+     *\/\n+\n+    static final VarHandle VH;\n+\n+    static {\n+        try {\n+            VH = MethodHandles.lookup().findVarHandle(RMW_11_FailureWitnessRWL.class, \"state\", int.class);\n+        } catch (NoSuchFieldException | IllegalAccessException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    \/\/ RWL state:\n+    \/\/   0..+inf: acquired for (multiple) readers\n+    \/\/         0: free\n+    \/\/        -1: acquired for single writer\n+    int state;\n+\n+    private String takeForRead() {\n+        int witness = (int)VH.compareAndExchange(this, 0, 1);\n+        if (witness == 0) {\n+            \/\/ Read lock acquired.\n+            return \"read-lock-1\";\n+        } else if (witness < 0) {\n+            \/\/ Another thread acquired for write.\n+            return \"WRITE-BLOCKED\";\n+        } else {\n+            \/\/ Another thread acquired for read.\n+            return \"read-lock-2\";\n+        }\n+    }\n+\n+    private String takeForWrite() {\n+        int witness = (int)VH.compareAndExchange(this, 0, -1);\n+        if (witness == 0) {\n+            \/\/ Write lock acquired.\n+            return \"write-lock\";\n+        } else if (witness < 0) {\n+            \/\/ Another thread acquired for write.\n+            return \"WRITE-BLOCKED\";\n+        } else {\n+            \/\/ Another thread acquired for read.\n+            return \"READ-BLOCKED\";\n+        }\n+    }\n+\n+    @Actor\n+    public void actor1(LLLL_Result r) {\n+        r.r1 = takeForRead();\n+    }\n+\n+    @Actor\n+    public void actor2(LLLL_Result r) {\n+        r.r2 = takeForRead();\n+    }\n+\n+    @Actor\n+    public void actor3(LLLL_Result r) {\n+        r.r3 = takeForWrite();\n+    }\n+\n+    @Actor\n+    public void actor4(LLLL_Result r) {\n+        r.r4 = takeForWrite();\n+    }\n+\n+}\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/high\/rmw\/RMW_11_FailureWitnessRWL.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jcstress.samples.high.rmw;\n+\n+import org.openjdk.jcstress.annotations.*;\n+import org.openjdk.jcstress.infra.results.III_Result;\n+import org.openjdk.jcstress.infra.results.ZZI_Result;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+\n+import static org.openjdk.jcstress.annotations.Expect.*;\n+\n+public class RMW_12_FailureWitnessLoops {\n+\n+    \/*\n+        How to run this test:\n+            $ java -jar jcstress-samples\/target\/jcstress.jar -t RMW_12_FailureWitnessLoops[.SubTestName]\n+     *\/\n+\n+    abstract static class Base {\n+        static final VarHandle VH;\n+\n+        static {\n+            try {\n+                VH = MethodHandles.lookup().findVarHandle(Base.class, \"v\", int.class);\n+            } catch (NoSuchFieldException | IllegalAccessException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }\n+\n+        int v = 1;\n+    }\n+\n+    \/*\n+      ----------------------------------------------------------------------------------------------------------\n+\n+        Failure witness can also be used to get the fresh value in update loops. First, consider\n+        the \"normal\" loop: read the latest value, prepare the update, CAS it, check if successful.\n+        This is the usual way to do the CAS-update-loop.\n+\n+        On x86_64:\n+           RESULT        SAMPLES     FREQ      EXPECT  DESCRIPTION\n+          2, 4, 4  2,602,060,422   50.34%  Acceptable  Trivial\n+          4, 2, 4  2,566,882,682   49.66%  Acceptable  Trivial\n+     *\/\n+\n+    @JCStressTest\n+    @Outcome(id = {\"2, 4, 4\", \"4, 2, 4\"}, expect = ACCEPTABLE, desc = \"Trivial\")\n+    @Outcome(                             expect = FORBIDDEN,  desc = \"Cannot happen\")\n+    @State\n+    public static class NormalLoop extends Base {\n+        private int update() {\n+            while (true) {\n+                int val = (int) VH.get(this);\n+                int newVal = val * 2;\n+                if (VH.compareAndSet(this, val, newVal)) {\n+                    return newVal;\n+                }\n+            }\n+        }\n+\n+        @Actor\n+        public void actor1(III_Result r) {\n+            r.r1 = update();\n+        }\n+\n+        @Actor\n+        public void actor2(III_Result r) {\n+            r.r2 = update();\n+        }\n+\n+        @Arbiter\n+        public void check(III_Result r) {\n+            r.r3 = (int) VH.get(this);\n+        }\n+    }\n+\n+    \/*\n+      ----------------------------------------------------------------------------------------------------------\n+\n+        With failure witness, we can use it as the \"latest\" value for retry, thus avoiding the\n+        reload in the hot loop.\n+\n+        Note that the actual performance really depends on the hardware implementation,\n+        the contention in the loop, scheduling lags, etc. Do not assume that sparing a read\n+        would have an universally positive impact. See for example:\n+            https:\/\/bugs.openjdk.java.net\/browse\/JDK-8141640\n+\n+        On x86_64:\n+           RESULT        SAMPLES     FREQ      EXPECT  DESCRIPTION\n+          2, 4, 4  2,484,075,481   47.92%  Acceptable  Trivial\n+          4, 2, 4  2,699,879,463   52.08%  Acceptable  Trivial\n+     *\/\n+\n+    @JCStressTest\n+    @Outcome(id = {\"2, 4, 4\", \"4, 2, 4\"}, expect = ACCEPTABLE, desc = \"Trivial\")\n+    @Outcome(                             expect = FORBIDDEN,  desc = \"Cannot happen\")\n+    @State\n+    public static class WitnessLoop extends Base {\n+        private int update() {\n+            int val = (int) VH.get(this);\n+            while (true) {\n+                int newVal = val*2;\n+                int witness = (int) VH.compareAndExchange(this, val, newVal);\n+                if (val == witness) {\n+                    return newVal;\n+                }\n+                val = witness;\n+            }\n+        }\n+\n+        @Actor\n+        public void actor1(III_Result r) {\n+            r.r1 = update();\n+        }\n+\n+        @Actor\n+        public void actor2(III_Result r) {\n+            r.r2 = update();\n+        }\n+\n+        @Arbiter\n+        public void check(III_Result r) {\n+            r.r3 = (int) VH.get(this);\n+        }\n+    }\n+\n+}\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/high\/rmw\/RMW_12_FailureWitnessLoops.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"}]}