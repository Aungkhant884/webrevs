{"files":[{"patch":"@@ -65,1 +65,1 @@\n-        <jmh.version>1.25<\/jmh.version>\n+        <jmh.version>1.36<\/jmh.version>\n@@ -94,0 +94,1 @@\n+                        <id>default<\/id>\n@@ -121,0 +122,15 @@\n+                    <execution>\n+                        <id>assembly<\/id>\n+                        <phase>package<\/phase>\n+                        <goals>\n+                            <goal>shade<\/goal>\n+                        <\/goals>\n+                        <configuration>\n+                            <finalName>benchmark-assembly<\/finalName>\n+                            <transformers>\n+                                <transformer implementation=\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\">\n+                                    <mainClass>org.openjdk.jcstress.SampleTestBench<\/mainClass>\n+                                <\/transformer>\n+                            <\/transformers>\n+                        <\/configuration>\n+                    <\/execution>\n","filename":"jcstress-benchmarks\/pom.xml","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import org.openjdk.jcstress.infra.runners.ForkedTestConfig;\n@@ -29,1 +30,0 @@\n-import org.openjdk.jcstress.os.CPUMap;\n@@ -35,2 +35,0 @@\n-import org.openjdk.jcstress.infra.collectors.TestResultCollector;\n-import org.openjdk.jcstress.infra.grading.ConsoleReportPrinter;\n@@ -40,0 +38,3 @@\n+import org.openjdk.jmh.profile.LinuxPerfAsmProfiler;\n+import org.openjdk.jmh.runner.RunnerException;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n@@ -41,0 +42,2 @@\n+import java.io.File;\n+import java.io.IOException;\n@@ -45,2 +48,1 @@\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n+import java.util.List;\n@@ -51,0 +53,36 @@\n+    \/\/ Must match the source code.\n+    private static final List<String> ACTOR_NAMES = Arrays.asList(\"actor1\", \"actor2\");;\n+\n+    private static final TestConfig[] CFGS;\n+    private static final Constructor<?> CNSTR;\n+\n+    static {\n+        try {\n+            Options opts = new Options(new String[] {\n+                    \"-v\",\n+                    \"-iters\", \"1\",\n+                    \"-time\", \"10000\"});\n+            opts.parse();\n+\n+            String testName = SampleTest.class.getCanonicalName();\n+            String runnerName = SampleTest_jcstress.class.getCanonicalName();\n+\n+            TestInfo ti = new TestInfo(testName, testName, runnerName, \"\", 2, ACTOR_NAMES, false);\n+            SchedulingClass sc = new SchedulingClass(AffinityMode.NONE, 2, NodeType.PACKAGE);\n+\n+            int[] casesFor = CompileMode.casesFor(2, true, true);\n+            casesFor = Arrays.copyOf(casesFor, casesFor.length + 1);\n+            casesFor[casesFor.length - 1] = CompileMode.UNIFIED;\n+\n+            CFGS = new TestConfig[casesFor.length];\n+            for (int i = 0; i < casesFor.length; i++) {\n+                CFGS[i] = new TestConfig(opts, ti, 1, Collections.emptyList(), casesFor[i], sc);\n+            }\n+\n+            Class<?> aClass = Class.forName(runnerName);\n+            CNSTR = aClass.getConstructor(ForkedTestConfig.class);\n+        } catch (Exception e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n@@ -52,1 +90,0 @@\n-    private ExecutorService pool;\n@@ -56,25 +93,1 @@\n-        Options opts = new Options(new String[]{\"-v\", \"-iters\", \"1\", \"-time\", \"5000\", \"-deoptMode\", \"NONE\"});\n-        opts.parse();\n-        PrintWriter pw = new PrintWriter(System.out, true);\n-        ConsoleReportPrinter sink = new ConsoleReportPrinter(opts, pw, 1);\n-\n-        String testName = SampleTest.class.getCanonicalName();\n-        String runnerName = SampleTest_jcstress.class.getCanonicalName();\n-\n-        TestInfo ti = new TestInfo(testName, testName, runnerName, \"\", 2, Arrays.asList(\"a1\", \"a2\"), false);\n-        TestConfig cfg = new TestConfig(opts, ti, 1, Collections.emptyList(), CompileMode.UNIFIED, new SchedulingClass(AffinityMode.NONE, 2, NodeType.PACKAGE));\n-        int[] map = new int[2];\n-        map[0] = -1;\n-        map[1] = -1;\n-        cfg.setCPUMap(new CPUMap(map, map, map, map, map, map, NodeType.PACKAGE));\n-\n-        pool = Executors.newCachedThreadPool();\n-\n-        Class<?> aClass = Class.forName(runnerName);\n-        Constructor<?> cnstr = aClass.getConstructor(TestConfig.class, TestResultCollector.class, ExecutorService.class);\n-        o = (Runner<?>) cnstr.newInstance(cfg, sink, pool);\n-    }\n-\n-    @TearDown\n-    public void tearDown() {\n-        pool.shutdown();\n+        o = (Runner<?>) CNSTR.newInstance(new ForkedTestConfig(CFGS[0]));\n@@ -85,1 +98,2 @@\n-    public void testMethod() throws Throwable {\n+    @Fork(1)\n+    public void testMethod() {\n@@ -89,0 +103,32 @@\n+    public static void main(String... args) throws IOException, RunnerException {\n+        for (TestConfig cfg : CFGS) {\n+            File cdFile = null;\n+            try {\n+                cdFile = File.createTempFile(\"jcstress\", \"directives\");\n+\n+                PrintWriter pw = new PrintWriter(cdFile);\n+                cfg.generateDirectives(pw, new Verbosity(1));\n+                pw.close();\n+\n+                org.openjdk.jmh.runner.options.Options opts = new OptionsBuilder()\n+                        .include(SampleTestBench.class.getName())\n+                        .jvmArgsPrepend(\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:CompilerDirectivesFile=\" + cdFile.getAbsolutePath())\n+                        .addProfiler(LinuxPerfAsmProfiler.class, \"hotThreshold=0.05\")\n+                        .build();\n+\n+                System.out.println();\n+                System.out.println(\"--------------------------------------------------------------------------------------------------\");\n+                System.out.println(CompileMode.description(cfg.getCompileMode(), ACTOR_NAMES));\n+                System.out.println();\n+                cfg.generateDirectives(new PrintWriter(System.out, true), new Verbosity(1));\n+                System.out.println();\n+\n+                new org.openjdk.jmh.runner.Runner(opts).runSingle();\n+            } finally {\n+                if (cdFile != null) {\n+                    cdFile.delete();\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"jcstress-benchmarks\/src\/main\/java\/org\/openjdk\/jcstress\/SampleTestBench.java","additions":78,"deletions":32,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -101,0 +101,4 @@\n+        public WarmupAffinityTask() {\n+            super(\"Warmup Affinity\");\n+        }\n+\n@@ -112,0 +116,4 @@\n+        public WarmupAllocProfileTask() {\n+            super(\"Warmup Alloc Profile\");\n+        }\n+\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/ForkedMain.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -246,132 +246,1 @@\n-            pw.println(\"[\");\n-\n-            \/\/ The worker threads:\n-            \/\/ Avoid any inlining for worker threads: either wait for task loop\n-            \/\/ compilation and pick up from there, or avoid inlining the actor method\n-            \/\/ that might be interpreted.\n-            pw.println(\"  {\");\n-            pw.println(\"    match: \\\"\" + VoidThread.class.getName() + \"::*\\\",\");\n-            pw.println(\"    inline: \\\"-*::*\\\",\");\n-            pw.println(\"  },\");\n-            pw.println(\"  {\");\n-            pw.println(\"    match: \\\"\" + LongThread.class.getName() + \"::*\\\",\");\n-            pw.println(\"    inline: \\\"-*::*\\\",\");\n-            pw.println(\"  },\");\n-            pw.println(\"  {\");\n-            pw.println(\"    match: \\\"\" + CounterThread.class.getName() + \"::*\\\",\");\n-            pw.println(\"    inline: \\\"-*::*\\\",\");\n-            pw.println(\"  },\");\n-\n-            \/\/ The task loop:\n-            pw.println(\"  {\");\n-            pw.println(\"    match: \\\"\" + task.generatedRunnerName + \"::\" + JCStressTestProcessor.TASK_LOOP_PREFIX + \"*\\\",\");\n-\n-            \/\/ Avoid inlining the run loop, it should be compiled as separate hot code\n-            pw.println(\"    inline: \\\"-\" + task.generatedRunnerName + \"::\" + JCStressTestProcessor.RUN_LOOP_PREFIX + \"*\\\",\");\n-\n-            \/\/ Force inline the auxiliary methods and classes in the run loop\n-            pw.println(\"    inline: \\\"+\" + task.generatedRunnerName + \"::\" + JCStressTestProcessor.CONSUME_PREFIX + \"*\\\",\");\n-            pw.println(\"    inline: \\\"+\" + WorkerSync.class.getName() + \"::*\\\",\");\n-            pw.println(\"    inline: \\\"+java.util.concurrent.atomic.*::*\\\",\");\n-\n-            \/\/ Omit inlining of non-essential methods\n-            pw.println(\"    inline: \\\"-\" + task.generatedRunnerName + \"::\" + JCStressTestProcessor.CONSUME_NI_PREFIX + \"*\\\",\");\n-\n-            \/\/ The test is running in resource-constrained JVM. Block the task loop execution until\n-            \/\/ compiled code is available. This would allow compilers to work in relative peace.\n-            pw.println(\"    BackgroundCompilation: false,\");\n-\n-            pw.println(\"  },\");\n-\n-            \/\/ Force inline everything from WorkerSync. WorkerSync does not use anything\n-            \/\/ too deeply, so inlining everything is fine.\n-            pw.println(\"  {\");\n-            pw.println(\"    match: \\\"\" + WorkerSync.class.getName() + \"::*\" + \"\\\",\");\n-            pw.println(\"    inline: \\\"+*::*\\\",\");\n-\n-            \/\/ The test is running in resource-constrained JVM. Block the WorkerSync execution until\n-            \/\/ compiled code is available. This would allow compilers to work in relative peace.\n-            pw.println(\"    BackgroundCompilation: false,\");\n-\n-            pw.println(\"  },\");\n-\n-            \/\/ The run loops:\n-            int cm = task.getCompileMode();\n-            for (int a = 0; a < task.threads; a++) {\n-                String an = task.actorNames.get(a);\n-\n-                pw.println(\"  {\");\n-                pw.println(\"    match: \\\"\" + task.generatedRunnerName + \"::\" + JCStressTestProcessor.RUN_LOOP_PREFIX + an + \"\\\",\");\n-                pw.println(\"    inline: \\\"+\" + task.generatedRunnerName + \"::\" + JCStressTestProcessor.CONSUME_PREFIX + \"*\\\",\");\n-                pw.println(\"    inline: \\\"-\" + task.generatedRunnerName + \"::\" + JCStressTestProcessor.CONSUME_NI_PREFIX + \"*\\\",\");\n-\n-                \/\/ Force inline of actor methods if run in compiled mode: this would inherit\n-                \/\/ compiler for them. Forbid inlining of actor methods in interpreted mode:\n-                \/\/ this would make sure that while actor methods are running in interpreter,\n-                \/\/ the run loop still runs in compiled mode, running faster. The call to interpreted\n-                \/\/ method would happen anyway, even though through c2i transition.\n-                if (CompileMode.isInt(cm, a)) {\n-                    pw.println(\"    inline: \\\"-\" + task.binaryName + \"::\" + an + \"\\\",\");\n-                } else {\n-                    pw.println(\"    inline: \\\"+\" + task.binaryName + \"::\" + an + \"\\\",\");\n-                }\n-\n-                \/\/ Run loop should be compiled with C2? Forbid C1 compilation then.\n-                if (CompileMode.isC2(cm, a)) {\n-                    pw.println(\"    c1: {\");\n-                    pw.println(\"      Exclude: true,\");\n-                    pw.println(\"    },\");\n-                }\n-\n-                \/\/ Run loop should be compiled with C1? Forbid C2 compilation then.\n-                if (CompileMode.isC1(cm, a)) {\n-                    pw.println(\"    c2: {\");\n-                    pw.println(\"      Exclude: true,\");\n-                    pw.println(\"    },\");\n-                }\n-\n-                if (VMSupport.printAssemblyAvailable() && verbosity.printAssembly() && !CompileMode.isInt(cm, a)) {\n-                    pw.println(\"    PrintAssembly: true,\");\n-                }\n-\n-                \/\/ The test is running in resource-constrained JVM. Block the run loop execution until\n-                \/\/ compiled code is available. This would allow compilers to work in relative peace.\n-                pw.println(\"    BackgroundCompilation: false,\");\n-\n-                pw.println(\"  },\");\n-            }\n-\n-            for (int a = 0; a < task.threads; a++) {\n-                String an = task.actorNames.get(a);\n-\n-                pw.println(\"  {\");\n-                pw.println(\"    match: \\\"\" + task.binaryName + \"::\" + an + \"\\\",\");\n-\n-                \/\/ Make sure actor is compiled with the target mode. Note that normally\n-                \/\/ we would wait for run loop to inline the actor, but we don't want\n-                \/\/ the actor thread to escape the compilation mode before that happens.\n-                \/\/ In intepreted mode, the inlining would not happen, so we definitely\n-                \/\/ need to forbid the compilation here.\n-                if (CompileMode.isInt(cm, a)) {\n-                    \/\/ Should be interpreter? Forbid compilation completely.\n-                    pw.println(\"    c1: {\");\n-                    pw.println(\"      Exclude: true,\");\n-                    pw.println(\"    },\");\n-                    pw.println(\"    c2: {\");\n-                    pw.println(\"      Exclude: true,\");\n-                    pw.println(\"    },\");\n-                } else if (CompileMode.isC2(cm, a)) {\n-                    \/\/ Should be compiled with C2? Forbid C1 compilation then.\n-                    pw.println(\"    c1: {\");\n-                    pw.println(\"      Exclude: true,\");\n-                    pw.println(\"    },\");\n-                } else if (CompileMode.isC1(cm, a)) {\n-                    \/\/ Should be compiled with C1? Forbid C2 compilation then.\n-                    pw.println(\"    c2: {\");\n-                    pw.println(\"      Exclude: true,\");\n-                    pw.println(\"    },\");\n-                }\n-                pw.println(\"  },\");\n-            }\n-            pw.println(\"]\");\n-            pw.flush();\n+            task.generateDirectives(pw, verbosity);\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/TestExecutor.java","additions":1,"deletions":132,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -55,2 +55,4 @@\n-    public static final String TASK_LOOP_PREFIX = \"jcstress_task_\";\n-    public static final String RUN_LOOP_PREFIX = \"jcstress_run_\";\n+    public static final String CHECK_LOOP_PREFIX = \"jcstress_check_\";\n+    public static final String ITERATION_LOOP_PREFIX = \"jcstress_iteration_\";\n+    public static final String STRIDE_LOOP_PREFIX = \"jcstress_stride_\";\n+    public static final String SANITY_CHECK_PREFIX = \"jcstress_sanityCheck_\";\n@@ -59,0 +61,1 @@\n+    public static final String WORKER_PREFIX = \"JcstressThread_\";\n@@ -363,2 +366,2 @@\n-        pw.println(\"        sanityCheck_API(counter);\");\n-        pw.println(\"        sanityCheck_Footprints(counter);\");\n+        pw.println(\"        \" + SANITY_CHECK_PREFIX + \"API(counter);\");\n+        pw.println(\"        \" + SANITY_CHECK_PREFIX + \"Resource(counter);\");\n@@ -367,1 +370,0 @@\n-        pw.println(\"    private void sanityCheck_API(Counter<\" + r + \"> counter) throws Throwable {\");\n@@ -369,0 +371,25 @@\n+        for (int a = 0; a < actorsCount; a++) {\n+            ExecutableElement el = info.getActors().get(a);\n+            String name = WORKER_PREFIX + \"APICheck_\" + el.getSimpleName();\n+            pw.println(\"    private static class \" + name + \" extends VoidThread {\");\n+            pw.println(\"        final \" + t + \" t;\");\n+            pw.println(\"        final \" + s + \" s;\");\n+            pw.println(\"        final \" + r + \" r;\");\n+            pw.println();\n+            pw.println(\"        public \" + name + \"(\" + t + \" t, \" + s + \" s, \" + r + \" r) {\");\n+            pw.println(\"            super(\\\"\" + name + \"\\\");\");\n+            pw.println(\"            this.t = t;\");\n+            pw.println(\"            this.s = s;\");\n+            pw.println(\"            this.r = r;\");\n+            pw.println(\"        }\");\n+            pw.println();\n+            pw.println(\"        public void internalRun() {\");\n+            pw.print(\"            \");\n+            emitMethod(pw, el, (isStateItself ? \"s.\" : \"t.\") + el.getSimpleName(), \"s\", \"r\", false);\n+            pw.println(\";\");\n+            pw.println(\"        };\");\n+            pw.println(\"    }\");\n+            pw.println();\n+        }\n+\n+        pw.println(\"    private void \" + SANITY_CHECK_PREFIX + \"API(Counter<\" + r + \"> counter) throws Throwable {\");\n@@ -377,5 +404,2 @@\n-            pw.println(\"        VoidThread a\" + a + \" = new VoidThread() { protected void internalRun() {\");\n-            pw.print(\"            \");\n-            emitMethod(pw, el, (isStateItself ? \"s.\" : \"t.\") + el.getSimpleName(), \"s\", \"r\", false);\n-            pw.println(\";\");\n-            pw.println(\"        }};\");\n+            String name = WORKER_PREFIX + \"APICheck_\" + el.getSimpleName();\n+            pw.println(\"        VoidThread a\" + a + \" = new \" + name + \"(\" + (isStateItself ? \"null\" : \"t\") + \", s, r);\");\n@@ -404,1 +428,37 @@\n-        pw.println(\"    private void sanityCheck_Footprints(Counter<\" + r + \"> counter) throws Throwable {\");\n+        for (int a = 0; a < actorsCount; a++) {\n+            ExecutableElement el = info.getActors().get(a);\n+            String name = WORKER_PREFIX + \"ResourceCheck_\" + el.getSimpleName();\n+            pw.println(\"    private class \" + name + \" extends LongThread {\");\n+            pw.println(\"        final \" + s + \"[] ss;\");\n+            pw.println(\"        final \" + r + \"[] rs;\");\n+            pw.println(\"        final int size;\");\n+            pw.println();\n+            pw.println(\"        public \" + name + \"(\" + s + \"[] ss, \" + r + \"[] rs, int size) {\");\n+            pw.println(\"            super(\\\"\" + name + \"\\\");\");\n+            pw.println(\"            this.ss = ss;\");\n+            pw.println(\"            this.rs = rs;\");\n+            pw.println(\"            this.size = size;\");\n+            pw.println(\"        }\");\n+            pw.println();\n+            pw.println(\"        public long internalRun() {\");\n+            pw.println(\"            long a1 = AllocProfileSupport.getAllocatedBytes();\");\n+            pw.println(\"            \" + CHECK_LOOP_PREFIX + el.getSimpleName() + \"(ss, rs, size);\");\n+            pw.println(\"            long a2 = AllocProfileSupport.getAllocatedBytes();\");\n+            pw.println(\"            return a2 - a1;\");\n+            pw.println(\"        }\");\n+            pw.println();\n+            pw.println(\"        private void \" + CHECK_LOOP_PREFIX + el.getSimpleName() + \"(\" + s + \"[] ls, \" + r + \"[] lr, int size) {\");\n+            if (!isStateItself) {\n+                pw.println(\"            final \" + t + \" t = new \" + t + \"();\");\n+            }\n+            pw.println(\"            for (int c = 0; c < size; c++) {\");\n+            pw.print(\"                \");\n+            emitMethod(pw, el, (isStateItself ? \"ls[c].\" : \"t.\") + el.getSimpleName(), \"ls[c]\", \"lr[c]\", false);\n+            pw.println(\";\");\n+            pw.println(\"            }\");\n+            pw.println(\"        }\");\n+            pw.println(\"    }\");\n+            pw.println();\n+        }\n+\n+        pw.println(\"    private void \" + SANITY_CHECK_PREFIX + \"Resource(Counter<\" + r + \"> counter) throws Throwable {\");\n@@ -425,10 +485,2 @@\n-            pw.println(\"            LongThread a\" + a + \" = new LongThread() { public long internalRun() {\");\n-            pw.println(\"                long a1 = AllocProfileSupport.getAllocatedBytes();\");\n-            pw.println(\"                for (int c = 0; c < size; c++) {\");\n-            pw.print(\"                    \");\n-            emitMethod(pw, el, (isStateItself ? \"ls[c].\" : \"t.\") + el.getSimpleName(), \"ls[c]\", \"lr[c]\", false);\n-            pw.println(\";\");\n-            pw.println(\"                }\");\n-            pw.println(\"                long a2 = AllocProfileSupport.getAllocatedBytes();\");\n-            pw.println(\"                return a2 - a1;\");\n-            pw.println(\"            }};\");\n+            String name = WORKER_PREFIX + \"ResourceCheck_\" + el.getSimpleName();\n+            pw.println(\"            LongThread a\" + a + \" = new \" + name + \"(ls, lr, size);\");\n@@ -498,3 +550,2 @@\n-            pw.println(\"        threads.add(new CounterThread<\" + r + \">() { public Counter<\" + r + \"> internalRun() {\");\n-            pw.println(\"            return \" + TASK_LOOP_PREFIX + a.getSimpleName() + \"();\");\n-            pw.println(\"        }});\");\n+            String name = WORKER_PREFIX + a.getSimpleName();\n+            pw.println(\"        threads.add(new \" + name + \"());\");\n@@ -522,4 +573,1 @@\n-            pw.println(\"    private void \" + name + \"(Counter<\" + r + \"> cnt, int a) {\");\n-            pw.println(\"        \" + s + \"[] ls = gs;\");\n-            pw.println(\"        \" + r + \"[] lr = gr;\");\n-            pw.println(\"        int len = config.strideSize * config.strideCount;\");\n+            pw.println(\"    public static void \" + name + \"(Counter<\" + r + \"> cnt, \" + s + \"[] ls, \" + r + \"[] lr, \" + t + \" test, int len, int a) {\");\n@@ -576,0 +624,5 @@\n+            String name = WORKER_PREFIX + a.getSimpleName();\n+            pw.println(\"    public class \" + name + \" extends CounterThread<\" + r + \"> {\");\n+            pw.println(\"        public \" + name + \"() {\");\n+            pw.println(\"            super(\\\"\" + name + \"\\\");\");\n+            pw.println(\"        }\");\n@@ -577,21 +630,29 @@\n-            pw.println(\"    private Counter<\" + r + \"> \" + TASK_LOOP_PREFIX + a.getSimpleName() + \"() {\");\n-            pw.println(\"        int len = config.strideSize * config.strideCount;\");\n-            pw.println(\"        int stride = config.strideSize;\");\n-            pw.println(\"        Counter<\" + r + \"> counter = new Counter<>();\");\n-            pw.println(\"        if (config.localAffinity) AffinitySupport.bind(config.localAffinityMap[\" + n + \"]);\");\n-            pw.println(\"        while (true) {\");\n-            pw.println(\"            WorkerSync sync = workerSync;\");\n-            pw.println(\"            int check = 0;\");\n-            pw.println(\"            for (int start = 0; start < len; start += stride) {\");\n-            pw.println(\"                \" + RUN_LOOP_PREFIX + a.getSimpleName() + \"(gs, gr, start, start + stride);\");\n-            pw.println(\"                check += \" + actorsCount + \";\");\n-            pw.println(\"                sync.awaitCheckpoint(check);\");\n-            pw.println(\"            }\");\n-            pw.println(\"            if (sync.stopping) {\");\n-            pw.println(\"                \" + CONSUME_NI_PREFIX + \"final(counter, \" + n + \");\");\n-            pw.println(\"                return counter;\");\n-            pw.println(\"            } else {\");\n-            pw.println(\"                \" + CONSUME_PREFIX + \"reinit(counter, \" + n + \");\");\n-            pw.println(\"            }\");\n-            pw.println(\"            if (sync.tryStartUpdate()) {\");\n-            pw.println(\"                workerSync = new WorkerSync(control.stopping, \" + actorsCount + \", config.spinLoopStyle);\");\n+            pw.println(\"        public Counter<\" + r + \"> internalRun() {\");\n+            pw.println(\"            return \" + ITERATION_LOOP_PREFIX + a.getSimpleName() + \"();\");\n+            pw.println(\"        }\");\n+            pw.println();\n+            pw.println(\"        private Counter<\" + r + \"> \" + ITERATION_LOOP_PREFIX + a.getSimpleName() + \"() {\");\n+            pw.println(\"            \" + s + \"[] ls = gs;\");\n+            pw.println(\"            \" + r + \"[] lr = gr;\");\n+            pw.println(\"            int len = config.strideSize * config.strideCount;\");\n+            pw.println(\"            int stride = config.strideSize;\");\n+            pw.println(\"            Counter<\" + r + \"> counter = new Counter<>();\");\n+            pw.println(\"            if (config.localAffinity) AffinitySupport.bind(config.localAffinityMap[\" + n + \"]);\");\n+            pw.println(\"            while (true) {\");\n+            pw.println(\"                WorkerSync sync = workerSync;\");\n+            pw.println(\"                int check = 0;\");\n+            pw.println(\"                for (int start = 0; start < len; start += stride) {\");\n+            pw.println(\"                    \" + STRIDE_LOOP_PREFIX + a.getSimpleName() + \"(ls, lr, start, start + stride);\");\n+            pw.println(\"                    check += \" + actorsCount + \";\");\n+            pw.println(\"                    sync.awaitCheckpoint(check);\");\n+            pw.println(\"                }\");\n+            pw.println(\"                if (sync.stopping) {\");\n+            pw.println(\"                    \" + CONSUME_NI_PREFIX + \"final(counter, ls, lr, \" + (isStateItself ? \"null\" : \"test\") + \", len, \" + n + \");\");\n+            pw.println(\"                    return counter;\");\n+            pw.println(\"                } else {\");\n+            pw.println(\"                    \" + CONSUME_PREFIX + \"reinit(counter, ls, lr, \" + (isStateItself ? \"null\" : \"test\") + \", len, \" + n + \");\");\n+            pw.println(\"                }\");\n+            pw.println(\"                if (sync.tryStartUpdate()) {\");\n+            pw.println(\"                    workerSync = new WorkerSync(control.stopping, \" + actorsCount + \", config.spinLoopStyle);\");\n+            pw.println(\"                }\");\n+            pw.println(\"                sync.postUpdate();\");\n@@ -599,1 +660,0 @@\n-            pw.println(\"            sync.postUpdate();\");\n@@ -601,1 +661,0 @@\n-            pw.println(\"    }\");\n@@ -603,1 +662,1 @@\n-            pw.println(\"    private void \" + RUN_LOOP_PREFIX + a.getSimpleName() + \"(\" + s + \"[] gs, \" + r + \"[] gr, int start, int end) {\");\n+            pw.println(\"        private void \" + STRIDE_LOOP_PREFIX + a.getSimpleName() + \"(\" + s + \"[] gs, \" + r + \"[] gr, int start, int end) {\");\n@@ -605,1 +664,1 @@\n-                pw.println(\"        \" + t + \" lt = test;\");\n+                pw.println(\"            \" + t + \" lt = test;\");\n@@ -607,3 +666,3 @@\n-            pw.println(\"        \" + s + \"[] ls = gs;\");\n-            pw.println(\"        \" + r + \"[] lr = gr;\");\n-            pw.println(\"        for (int c = start; c < end; c++) {\");\n+            pw.println(\"            \" + s + \"[] ls = gs;\");\n+            pw.println(\"            \" + r + \"[] lr = gr;\");\n+            pw.println(\"            for (int c = start; c < end; c++) {\");\n@@ -621,1 +680,1 @@\n-            pw.println(\"            \" + s + \" s = ls[c];\");\n+            pw.println(\"                \" + s + \" s = ls[c];\");\n@@ -623,2 +682,2 @@\n-                pw.println(\"            \" + r + \" r = lr[c];\");\n-                pw.println(\"            int trap_r = r.jcstress_trap;\");\n+                pw.println(\"                \" + r + \" r = lr[c];\");\n+                pw.println(\"                int trap_r = r.jcstress_trap;\");\n@@ -628,1 +687,1 @@\n-                emitMethod(pw, a, \"            s.\" + a.getSimpleName(), \"s\", \"r\", true);\n+                emitMethod(pw, a, \"                s.\" + a.getSimpleName(), \"s\", \"r\", true);\n@@ -632,1 +691,1 @@\n-                    pw.println(\"            \" + sf[0] + \" trap_s = s.\" + sf[1] + \";\");\n+                    pw.println(\"                \" + sf[0] + \" trap_s = s.\" + sf[1] + \";\");\n@@ -634,1 +693,1 @@\n-                emitMethod(pw, a, \"           lt.\" + a.getSimpleName(), \"s\", \"r\", true);\n+                emitMethod(pw, a, \"               lt.\" + a.getSimpleName(), \"s\", \"r\", true);\n@@ -637,0 +696,1 @@\n+            pw.println(\"            }\");\n@@ -639,0 +699,1 @@\n+            pw.println();\n@@ -642,1 +703,0 @@\n-        pw.println();\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/infra\/processors\/JCStressTestProcessor.java","additions":123,"deletions":63,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-    private static final AtomicInteger ID = new AtomicInteger();\n-\n@@ -34,1 +32,1 @@\n-    public AbstractThread() {\n+    public AbstractThread(String name) {\n@@ -36,1 +34,1 @@\n-        setName(\"jcstress-worker-\" + ID.incrementAndGet());\n+        setName(name);\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/infra\/runners\/AbstractThread.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,0 +34,3 @@\n+    private CounterThread() { \/\/ Cannot touch this\n+        super(\"N\/A\");\n+    }\n@@ -35,0 +38,3 @@\n+    protected CounterThread(String name) {\n+        super(name);\n+    }\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/infra\/runners\/CounterThread.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,9 @@\n+\n+    private LongThread() { \/\/ Cannot touch this\n+        super(\"N\/A\");\n+    }\n+\n+    protected LongThread(String name) {\n+        super(name);\n+    }\n+\n@@ -32,1 +41,0 @@\n-\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/infra\/runners\/LongThread.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.jcstress.Verbosity;\n+import org.openjdk.jcstress.infra.processors.JCStressTestProcessor;\n@@ -31,0 +33,2 @@\n+import org.openjdk.jcstress.vm.CompileMode;\n+import org.openjdk.jcstress.vm.VMSupport;\n@@ -32,0 +36,1 @@\n+import java.io.PrintWriter;\n@@ -108,0 +113,140 @@\n+    public void generateDirectives(PrintWriter pw, Verbosity verbosity) {\n+        pw.println(\"[\");\n+\n+        \/\/ The worker threads:\n+        \/\/ Avoid any inlining for worker threads: either wait for task loop\n+        \/\/ compilation and pick up from there, or avoid inlining the actor method\n+        \/\/ that might be interpreted.\n+        pw.println(\"  {\");\n+        pw.println(\"    match: \\\"\" + VoidThread.class.getName() + \"::*\\\",\");\n+        pw.println(\"    inline: \\\"-*::*\\\",\");\n+        pw.println(\"  },\");\n+        pw.println(\"  {\");\n+        pw.println(\"    match: \\\"\" + LongThread.class.getName() + \"::*\\\",\");\n+        pw.println(\"    inline: \\\"-*::*\\\",\");\n+        pw.println(\"  },\");\n+        pw.println(\"  {\");\n+        pw.println(\"    match: \\\"\" + CounterThread.class.getName() + \"::*\\\",\");\n+        pw.println(\"    inline: \\\"-*::*\\\",\");\n+        pw.println(\"  },\");\n+\n+        \/\/ The task loop:\n+        pw.println(\"  {\");\n+        pw.println(\"    match: [\");\n+        pw.println(\"      \\\"*::\" + JCStressTestProcessor.ITERATION_LOOP_PREFIX + \"*\\\",\");\n+        pw.println(\"      \\\"*::\" + JCStressTestProcessor.SANITY_CHECK_PREFIX + \"*\\\",\");\n+        pw.println(\"    ],\");\n+\n+        \/\/ Avoid inlining the run loop, it should be compiled as separate hot code\n+        pw.println(\"    inline: \\\"-*::\" + JCStressTestProcessor.STRIDE_LOOP_PREFIX + \"*\\\",\");\n+        pw.println(\"    inline: \\\"-*::\" + JCStressTestProcessor.CHECK_LOOP_PREFIX + \"*\\\",\");\n+\n+        \/\/ Force inline the auxiliary methods and classes in the run loop\n+        pw.println(\"    inline: \\\"+*::\" + JCStressTestProcessor.CONSUME_PREFIX + \"*\\\",\");\n+        pw.println(\"    inline: \\\"+\" + WorkerSync.class.getName() + \"::*\\\",\");\n+        pw.println(\"    inline: \\\"+java.util.concurrent.atomic.*::*\\\",\");\n+\n+        \/\/ Omit inlining of non-essential methods\n+        pw.println(\"    inline: \\\"-*::\" + JCStressTestProcessor.CONSUME_NI_PREFIX + \"*\\\",\");\n+\n+        \/\/ The test is running in resource-constrained JVM. Block the task loop execution until\n+        \/\/ compiled code is available. This would allow compilers to work in relative peace.\n+        pw.println(\"    BackgroundCompilation: false,\");\n+\n+        pw.println(\"  },\");\n+\n+        \/\/ Force inline everything from WorkerSync. WorkerSync does not use anything\n+        \/\/ too deeply, so inlining everything is fine.\n+        pw.println(\"  {\");\n+        pw.println(\"    match: \\\"\" + WorkerSync.class.getName() + \"::*\" + \"\\\",\");\n+        pw.println(\"    inline: \\\"+*::*\\\",\");\n+\n+        \/\/ The test is running in resource-constrained JVM. Block the WorkerSync execution until\n+        \/\/ compiled code is available. This would allow compilers to work in relative peace.\n+        pw.println(\"    BackgroundCompilation: false,\");\n+\n+        pw.println(\"  },\");\n+\n+        \/\/ The run loops:\n+        for (int a = 0; a < threads; a++) {\n+            String an = actorNames.get(a);\n+\n+            pw.println(\"  {\");\n+            pw.println(\"    match: [\");\n+            pw.println(\"      \\\"*::\" + JCStressTestProcessor.STRIDE_LOOP_PREFIX + an + \"\\\",\");\n+            pw.println(\"      \\\"*::\" + JCStressTestProcessor.CHECK_LOOP_PREFIX + an + \"\\\",\");\n+            pw.println(\"    ],\");\n+            pw.println(\"    inline: \\\"+*::\" + JCStressTestProcessor.CONSUME_PREFIX + \"*\\\",\");\n+            pw.println(\"    inline: \\\"-*::\" + JCStressTestProcessor.CONSUME_NI_PREFIX + \"*\\\",\");\n+\n+            \/\/ Force inline of actor methods if run in compiled mode: this would inherit\n+            \/\/ compiler for them. Forbid inlining of actor methods in interpreted mode:\n+            \/\/ this would make sure that while actor methods are running in interpreter,\n+            \/\/ the run loop still runs in compiled mode, running faster. The call to interpreted\n+            \/\/ method would happen anyway, even though through c2i transition.\n+            if (CompileMode.isInt(compileMode, a)) {\n+                pw.println(\"    inline: \\\"-\" + binaryName + \"::\" + an + \"\\\",\");\n+            } else {\n+                pw.println(\"    inline: \\\"+\" + binaryName + \"::\" + an + \"\\\",\");\n+            }\n+\n+            \/\/ Run loop should be compiled with C2? Forbid C1 compilation then.\n+            if (CompileMode.isC2(compileMode, a)) {\n+                pw.println(\"    c1: {\");\n+                pw.println(\"      Exclude: true,\");\n+                pw.println(\"    },\");\n+            }\n+\n+            \/\/ Run loop should be compiled with C1? Forbid C2 compilation then.\n+            if (CompileMode.isC1(compileMode, a)) {\n+                pw.println(\"    c2: {\");\n+                pw.println(\"      Exclude: true,\");\n+                pw.println(\"    },\");\n+            }\n+\n+            if (VMSupport.printAssemblyAvailable() && verbosity.printAssembly() && !CompileMode.isInt(compileMode, a)) {\n+                pw.println(\"    PrintAssembly: true,\");\n+            }\n+\n+            \/\/ The test is running in resource-constrained JVM. Block the run loop execution until\n+            \/\/ compiled code is available. This would allow compilers to work in relative peace.\n+            pw.println(\"    BackgroundCompilation: false,\");\n+\n+            pw.println(\"  },\");\n+        }\n+\n+        for (int a = 0; a < threads; a++) {\n+            String an = actorNames.get(a);\n+\n+            pw.println(\"  {\");\n+            pw.println(\"    match: \\\"\" + binaryName + \"::\" + an + \"\\\",\");\n+\n+            \/\/ Make sure actor is compiled with the target mode. Note that normally\n+            \/\/ we would wait for run loop to inline the actor, but we don't want\n+            \/\/ the actor thread to escape the compilation mode before that happens.\n+            \/\/ In interpreted mode, the inlining would not happen, so we definitely\n+            \/\/ need to forbid the compilation here.\n+            if (CompileMode.isInt(compileMode, a)) {\n+                \/\/ Should be interpreter? Forbid compilation completely.\n+                pw.println(\"    c1: {\");\n+                pw.println(\"      Exclude: true,\");\n+                pw.println(\"    },\");\n+                pw.println(\"    c2: {\");\n+                pw.println(\"      Exclude: true,\");\n+                pw.println(\"    },\");\n+            } else if (CompileMode.isC2(compileMode, a)) {\n+                \/\/ Should be compiled with C2? Forbid C1 compilation then.\n+                pw.println(\"    c1: {\");\n+                pw.println(\"      Exclude: true,\");\n+                pw.println(\"    },\");\n+            } else if (CompileMode.isC1(compileMode, a)) {\n+                \/\/ Should be compiled with C1? Forbid C2 compilation then.\n+                pw.println(\"    c2: {\");\n+                pw.println(\"      Exclude: true,\");\n+                pw.println(\"    },\");\n+            }\n+            pw.println(\"  },\");\n+        }\n+        pw.println(\"]\");\n+        pw.flush();\n+    }\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/infra\/runners\/TestConfig.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -28,0 +28,9 @@\n+\n+    private VoidThread() { \/\/ Cannot touch this\n+        super(\"N\/A\");\n+    }\n+\n+    protected VoidThread(String name) {\n+        super(name);\n+    }\n+\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/infra\/runners\/VoidThread.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"}]}