{"files":[{"patch":"@@ -35,4 +35,3 @@\n-import org.openjdk.jcstress.os.AffinityMode;\n-import org.openjdk.jcstress.os.CPUMap;\n-import org.openjdk.jcstress.os.OSSupport;\n-import org.openjdk.jcstress.os.Scheduler;\n+import org.openjdk.jcstress.os.*;\n+import org.openjdk.jcstress.util.HashMultimap;\n+import org.openjdk.jcstress.util.Multimap;\n@@ -112,2 +111,7 @@\n-        while (!configs.isEmpty()) {\n-            List<TestConfig> leftover = new ArrayList<>();\n+        \/\/ Build the scheduling classes maps\n+        Multimap<SchedulingClass, TestConfig> byScl = new HashMultimap<>();\n+        List<SchedulingClass> scls = new ArrayList<>();\n+\n+        {\n+            Set<SchedulingClass> uniqueScls = new HashSet<>();\n+\n@@ -115,2 +119,23 @@\n-                CPUMap cpuMap = scheduler.tryAcquire(cfg.shClass);\n-                if (cpuMap != null) {\n+                byScl.put(cfg.getSchedulingClass(), cfg);\n+                uniqueScls.add(cfg.getSchedulingClass());\n+            }\n+\n+            \/\/ Try the largest scheduling classes first\n+            scls.addAll(uniqueScls);\n+            Collections.sort(scls, Comparator.comparing(SchedulingClass::numActors).reversed());\n+        }\n+\n+        while (!byScl.isEmpty()) {\n+\n+            \/\/ Roll over the scheduling classes and try to greedily cram most\n+            \/\/ of the tasks for it. This exits when no scheduling classes can fit\n+            \/\/ the current state of the machine.\n+            for (SchedulingClass scl : scls) {\n+                while (byScl.containsKey(scl)) {\n+                    CPUMap cpuMap = scheduler.tryAcquire(scl);\n+                    if (cpuMap == null) {\n+                        \/\/ No more scheduling for this class\n+                        break;\n+                    }\n+\n+                    TestConfig cfg = byScl.removeLast(scl);\n@@ -122,2 +147,0 @@\n-                } else {\n-                    leftover.add(cfg);\n@@ -127,2 +150,0 @@\n-            configs = leftover;\n-\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/TestExecutor.java","additions":33,"deletions":12,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.util.concurrent.ArrayBlockingQueue;\n@@ -47,1 +48,1 @@\n-        results = new LinkedBlockingQueue<>();\n+        results = new ArrayBlockingQueue<>(1024);\n@@ -81,1 +82,5 @@\n-        results.add(result);\n+        try {\n+            results.put(result);\n+        } catch (InterruptedException e) {\n+            throw new IllegalStateException(e);\n+        }\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/infra\/collectors\/SerializedBufferCollector.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-    private final Set<SchedulingClass> failedClasses;\n@@ -50,1 +49,0 @@\n-        failedClasses = new HashSet<>();\n@@ -59,5 +57,0 @@\n-        if (failedClasses.contains(scl)) {\n-            \/\/ Already known to fail in current CPU population.\n-            return null;\n-        }\n-\n@@ -66,1 +59,0 @@\n-            failedClasses.add(scl);\n@@ -88,4 +80,0 @@\n-        if (cpuMap == null) {\n-            failedClasses.add(scl);\n-        }\n-\n@@ -331,2 +319,0 @@\n-        failedClasses.clear();\n-\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/os\/Scheduler.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -52,5 +52,1 @@\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n+import java.util.*;\n@@ -87,0 +83,5 @@\n+    @Override\n+    public boolean containsKey(K key) {\n+        return map.containsKey(key);\n+    }\n+\n@@ -115,0 +116,15 @@\n+\n+    @Override\n+    public V removeLast(K key) {\n+        Collection<V> vs = map.get(key);\n+        if (!vs.isEmpty()) {\n+            List<V> list = (List<V>) vs;\n+            V v = list.remove(list.size() - 1);\n+            if (list.isEmpty()) {\n+                map.remove(key);\n+            }\n+            return v;\n+        } else {\n+            return null;\n+        }\n+    }\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/util\/HashMultimap.java","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -100,0 +100,3 @@\n+    V removeLast(K key);\n+\n+    boolean containsKey(K key);\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/util\/Multimap.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -52,5 +52,1 @@\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Map;\n-import java.util.TreeMap;\n+import java.util.*;\n@@ -115,0 +111,10 @@\n+\n+    @Override\n+    public V removeLast(K key) {\n+        throw new IllegalStateException(\"Not implemented\");\n+    }\n+\n+    @Override\n+    public boolean containsKey(K key) {\n+        return map.containsKey(key);\n+    }\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/util\/TreeMultimap.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -52,6 +52,1 @@\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.TreeSet;\n+import java.util.*;\n@@ -116,0 +111,10 @@\n+\n+    @Override\n+    public V removeLast(K key) {\n+        throw new IllegalStateException(\"Not implemented\");\n+    }\n+\n+    @Override\n+    public boolean containsKey(K key) {\n+        return map.containsKey(key);\n+    }\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/util\/TreesetMultimap.java","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"}]}