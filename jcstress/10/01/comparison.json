{"files":[{"patch":"@@ -83,1 +83,1 @@\n-        TestExecutor executor = new TestExecutor(opts.getCPUCount(), opts.getBatchSize(), sink, true);\n+        TestExecutor executor = new TestExecutor(opts.getCPUCount(), sink, true);\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/JCStress.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,1 +70,0 @@\n-    private int batchSize;\n@@ -115,4 +114,0 @@\n-        OptionSpec<Integer> batchSize = parser.accepts(\"bs\", \"Maximum number of tests to execute in a single VM. Larger \" +\n-                \"values will improve test performance, at expense of testing accuracy\")\n-                .withRequiredArg().ofType(Integer.class).describedAs(\"#\");\n-\n@@ -193,1 +188,1 @@\n-            this.time = 0;\n+            this.time = 50;\n@@ -195,2 +190,1 @@\n-            this.forks = 1;\n-            this.batchSize = 500;\n+            this.forks = 0;\n@@ -205,1 +199,0 @@\n-            this.batchSize = 20;\n@@ -211,1 +204,0 @@\n-            this.batchSize = 5;\n@@ -217,1 +209,0 @@\n-            this.batchSize = 5;\n@@ -223,1 +214,0 @@\n-            this.batchSize = 1;\n@@ -235,1 +225,0 @@\n-        this.batchSize = orDefault(set.valueOf(batchSize), this.batchSize);\n@@ -279,1 +268,0 @@\n-        out.printf(\"  Each JVM would execute at most %d tests in the row.%n\", getBatchSize());\n@@ -370,3 +358,0 @@\n-    public int getBatchSize() {\n-        return batchSize;\n-    }\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/Options.java","additions":2,"deletions":17,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -35,2 +35,0 @@\n-import org.openjdk.jcstress.util.HashMultimap;\n-import org.openjdk.jcstress.util.Multimap;\n@@ -63,1 +61,0 @@\n-    private final int batchSize;\n@@ -65,1 +62,0 @@\n-    private final Multimap<BatchKey, TestConfig> tasks;\n@@ -71,1 +67,1 @@\n-    public TestExecutor(int maxThreads, int batchSize, TestResultCollector sink, boolean possiblyForked) throws IOException {\n+    public TestExecutor(int maxThreads, TestResultCollector sink, boolean possiblyForked) throws IOException {\n@@ -73,1 +69,0 @@\n-        this.batchSize = batchSize;\n@@ -75,2 +70,0 @@\n-\n-        this.tasks = new HashMultimap<>();\n@@ -89,1 +82,0 @@\n-                vmByToken.get(token).processResult(result);\n@@ -96,1 +88,1 @@\n-    public void runAll(List<TestConfig> configs) throws InterruptedException {\n+    public void runAll(List<TestConfig> configs) {\n@@ -98,0 +90,2 @@\n+            List<Integer> acquiredCPUs = acquireCPUs(cfg.threads);\n+\n@@ -100,1 +94,0 @@\n-                    List<Integer> acquiredCPUs = acquireCPUs(cfg.threads);\n@@ -104,8 +97,4 @@\n-                    BatchKey batchKey = BatchKey.getFrom(cfg);\n-                    tasks.put(batchKey, cfg);\n-\n-                    Collection<TestConfig> curBatch = tasks.get(batchKey);\n-                    if (curBatch.size() >= batchSize) {\n-                        tasks.remove(batchKey);\n-                        doSchedule(batchKey, curBatch);\n-                    }\n+                    String token = \"fork-token-\" + ID.incrementAndGet();\n+                    VM vm = new VM(server.getHost(), server.getPort(), token, cfg, acquiredCPUs);\n+                    vmByToken.put(token, vm);\n+                    vm.start();\n@@ -118,8 +107,0 @@\n-        \/\/ Run down the remaining tasks\n-        for (BatchKey key : tasks.keys()) {\n-            Collection<TestConfig> curBatch = tasks.get(key);\n-            if (!curBatch.isEmpty()) {\n-                doSchedule(key, curBatch);\n-            }\n-        }\n-\n@@ -132,9 +113,0 @@\n-    private void doSchedule(BatchKey batchKey, Collection<TestConfig> configs) {\n-        List<Integer> claimedCPUs = acquireCPUs(batchKey.threads);\n-\n-        String token = \"fork-token-\" + ID.incrementAndGet();\n-        VM vm = new VM(server.getHost(), server.getPort(), batchKey, token, configs, claimedCPUs);\n-        vmByToken.put(token, vm);\n-        vm.start();\n-    }\n-\n@@ -160,3 +132,2 @@\n-                \/\/ Record the failure for the actual test\n-                TestConfig failed = vm.getVictimTask();\n-                TestResult result = new TestResult(failed, Status.VM_ERROR, -1);\n+                TestConfig task = vm.getTask();\n+                TestResult result = new TestResult(task, Status.VM_ERROR, -1);\n@@ -171,6 +142,0 @@\n-\n-            \/\/ Remaining tasks from the fork need to get back on queue\n-            List<TestConfig> pending = vm.getPendingTasks();\n-            if (!pending.isEmpty()) {\n-                doSchedule(vm.key, pending);\n-            }\n@@ -183,1 +148,0 @@\n-        private final BatchKey key;\n@@ -187,3 +151,1 @@\n-        private final TestConfig firstTask;\n-        private Process process;\n-        private final List<TestConfig> pendingTasks;\n+        private final TestConfig task;\n@@ -191,2 +153,2 @@\n-        private TestConfig currentTask;\n-        private TestConfig lastTask;\n+        private Process process;\n+        private boolean processed;\n@@ -195,1 +157,1 @@\n-        public VM(String host, int port, BatchKey key, String token, Collection<TestConfig> configs, List<Integer> claimedCPUs) {\n+        public VM(String host, int port, String token, TestConfig task, List<Integer> claimedCPUs) {\n@@ -198,1 +160,0 @@\n-            this.key = key;\n@@ -200,1 +161,0 @@\n-            this.pendingTasks = new ArrayList<>(configs);\n@@ -202,1 +162,1 @@\n-            this.firstTask = pendingTasks.get(0);\n+            this.task = task;\n@@ -229,1 +189,1 @@\n-                command.addAll(key.jvmArgs);\n+                command.addAll(task.jvmArgs);\n@@ -285,1 +245,1 @@\n-            if (pendingTasks.isEmpty()) {\n+            if (processed) {\n@@ -287,16 +247,0 @@\n-            } else {\n-                TestConfig task = pendingTasks.remove(0);\n-                currentTask = task;\n-                return task;\n-            }\n-        }\n-\n-        public synchronized void processResult(TestResult result) {\n-            lastTask = currentTask;\n-            currentTask = null;\n-        }\n-\n-        public synchronized TestConfig getVictimTask() {\n-            if (currentTask != null) {\n-                \/\/ Current task had failed\n-                return currentTask;\n@@ -304,41 +248,2 @@\n-\n-            if (lastTask != null) {\n-                \/\/ Already replied the results for last task, blame it too\n-                return lastTask;\n-            }\n-\n-            \/\/ We have not executed anything yet, blame the first task\n-            return firstTask;\n-        }\n-\n-        public List<TestConfig> getPendingTasks() {\n-            return new ArrayList<>(pendingTasks);\n-        }\n-    }\n-\n-    static class BatchKey {\n-        private int threads;\n-        private List<String> jvmArgs;\n-\n-        BatchKey(int threads, List<String> jvmArgs) {\n-            this.threads = threads;\n-            this.jvmArgs = jvmArgs;\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (o == null || getClass() != o.getClass()) return false;\n-\n-            BatchKey batchKey = (BatchKey) o;\n-\n-            if (threads != batchKey.threads) return false;\n-            return jvmArgs.equals(batchKey.jvmArgs);\n-\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            int result = threads;\n-            result = 31 * result + jvmArgs.hashCode();\n-            return result;\n+            processed = true;\n+            return getTask();\n@@ -347,2 +252,2 @@\n-        static BatchKey getFrom(TestConfig cfg) {\n-            return new BatchKey(cfg.threads, cfg.jvmArgs);\n+        public TestConfig getTask() {\n+            return task;\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/TestExecutor.java","additions":21,"deletions":116,"binary":false,"changes":137,"status":"modified"}]}