{"files":[{"patch":"@@ -30,0 +30,1 @@\n+import org.openjdk.jcstress.os.NodeType;\n@@ -64,1 +65,1 @@\n-        TestConfig cfg = new TestConfig(opts, ti, 1, Collections.emptyList(), CompileMode.UNIFIED, new SchedulingClass(AffinityMode.NONE, 2, false));\n+        TestConfig cfg = new TestConfig(opts, ti, 1, Collections.emptyList(), CompileMode.UNIFIED, new SchedulingClass(AffinityMode.NONE, 2, NodeType.PACKAGE));\n@@ -68,1 +69,1 @@\n-        cfg.setCPUMap(new CPUMap(map, map, map, map, map, map, false));\n+        cfg.setCPUMap(new CPUMap(map, map, map, map, map, map, NodeType.PACKAGE));\n","filename":"jcstress-benchmarks\/src\/main\/java\/org\/openjdk\/jcstress\/SampleTestBench.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-    private final int[] threadToPackage;\n+    private final int[] threadToNode;\n@@ -37,1 +37,1 @@\n-    private final boolean groupIsNUMA;\n+    private final NodeType nodeType;\n@@ -40,2 +40,2 @@\n-                  int[] threadToPackage, int[] threadToCore, int[] threadToRealCPU,\n-                  boolean groupIsNUMA) {\n+                  int[] threadToNode, int[] threadToCore, int[] threadToRealCPU,\n+                  NodeType nodeType) {\n@@ -45,1 +45,1 @@\n-        this.threadToPackage = threadToPackage;\n+        this.threadToNode = threadToNode;\n@@ -48,1 +48,1 @@\n-        this.groupIsNUMA = groupIsNUMA;\n+        this.nodeType = nodeType;\n@@ -74,1 +74,1 @@\n-        int[] packageMap = map.threadToPackage;\n+        int[] nodeMap = map.threadToNode;\n@@ -77,1 +77,1 @@\n-        boolean groupIsNUMA = map.groupIsNUMA;\n+        NodeType nodeType = map.nodeType;\n@@ -92,6 +92,4 @@\n-                if (groupIsNUMA) {\n-                    sb.append(\" (NUMA node #\");\n-                } else {\n-                    sb.append(\" (package #\");\n-                }\n-                sb.append(packageMap[actorToThread[a]]);\n+                sb.append(\" (\");\n+                sb.append(nodeType.desc());\n+                sb.append(\" #\");\n+                sb.append(nodeMap[actorToThread[a]]);\n@@ -114,6 +112,4 @@\n-                if (groupIsNUMA) {\n-                    sb.append(\" (NUMA node #\");\n-                } else {\n-                    sb.append(\" (package #\");\n-                }\n-                sb.append(packageMap[systemMap[a]]);\n+                sb.append(\" (\");\n+                sb.append(nodeType.desc());\n+                sb.append(\" #\");\n+                sb.append(nodeMap[systemMap[a]]);\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/os\/CPUMap.java","additions":16,"deletions":20,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jcstress.os;\n+\n+public enum NodeType {\n+\n+    \/\/ Cores are grouped in NUMA nodes first, then in packages\n+    NUMA,\n+\n+    \/\/ Cores are grouped in packages first\n+    PACKAGE;\n+\n+    public String desc() {\n+        switch (this) {\n+            case NUMA: return \"NUMA node\";\n+            case PACKAGE: return \"package\";\n+            default:\n+                throw new IllegalStateException(\"Unknown enum\");\n+        }\n+    }\n+\n+    public String shortDesc() {\n+        switch (this) {\n+            case NUMA: return \"N\";\n+            case PACKAGE: return \"P\";\n+            default:\n+                throw new IllegalStateException(\"Unknown enum\");\n+        }\n+    }\n+\n+}\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/os\/NodeType.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -40,1 +40,1 @@\n-    private final PackageRecord[] freeMapPackage;\n+    private final NodeRecord[] freeMapNode;\n@@ -49,3 +49,3 @@\n-        freeMapPackage = new PackageRecord[topology.packagesPerSystem()];\n-        for (int p = 0; p < freeMapPackage.length; p++) {\n-            freeMapPackage[p] = new PackageRecord(-1, -1);\n+        freeMapNode = new NodeRecord[topology.nodesPerSystem()];\n+        for (int p = 0; p < freeMapNode.length; p++) {\n+            freeMapNode[p] = new NodeRecord(-1, -1);\n@@ -89,3 +89,3 @@\n-        \/\/ Perform initial assignment of package groups to packages.\n-        \/\/ Take the least busy packages first, to guarantee the rest of\n-        \/\/ the scheduling code sees as much cores on those packages as possible.\n+        \/\/ Perform initial assignment of node groups to nodes.\n+        \/\/ Take the least busy nodes first, to guarantee the rest of\n+        \/\/ the scheduling code sees as many cores on those nodes as possible.\n@@ -93,2 +93,2 @@\n-        int[] packageGroupToPackage = new int[scl.numPackages()];\n-        Arrays.fill(packageGroupToPackage, -1);\n+        int[] nodeGroupToNode = new int[scl.numNodes()];\n+        Arrays.fill(nodeGroupToNode, -1);\n@@ -97,1 +97,1 @@\n-        int[] coreGroupToPackage = new int[scl.numCores()];\n+        int[] coreGroupToNode = new int[scl.numCores()];\n@@ -99,2 +99,2 @@\n-            int packageGroup = scl.packages[a];\n-            if (packageGroup == -1) {\n+            int nodeGroup = scl.nodes[a];\n+            if (nodeGroup == -1) {\n@@ -103,1 +103,1 @@\n-            int p = packageGroupToPackage[packageGroup];\n+            int p = nodeGroupToNode[nodeGroup];\n@@ -105,2 +105,2 @@\n-                p = freeMapPackage[pIdx++].id;\n-                packageGroupToPackage[packageGroup] = p;\n+                p = freeMapNode[pIdx++].id;\n+                nodeGroupToNode[nodeGroup] = p;\n@@ -108,1 +108,1 @@\n-            coreGroupToPackage[scl.cores[a]] = p;\n+            coreGroupToNode[scl.cores[a]] = p;\n@@ -116,2 +116,2 @@\n-            \/\/ Find next core in the required package\n-            int wantPackage = coreGroupToPackage[coreGroup];\n+            \/\/ Find next core in the required node\n+            int wantNode = coreGroupToNode[coreGroup];\n@@ -125,1 +125,1 @@\n-                if (topology.coreToPackage(core) == wantPackage) {\n+                if (topology.coreToNode(core) == wantNode) {\n@@ -186,1 +186,1 @@\n-        int[] threadToPackage = new int[topology.totalThreads()];\n+        int[] threadToNode = new int[topology.totalThreads()];\n@@ -189,1 +189,1 @@\n-        Arrays.fill(threadToPackage, -1);\n+        Arrays.fill(threadToNode, -1);\n@@ -193,1 +193,1 @@\n-            threadToPackage[thread] = topology.threadToPackage(thread);\n+            threadToNode[thread] = topology.threadToNode(thread);\n@@ -198,1 +198,1 @@\n-            threadToPackage[thread] = topology.threadToPackage(thread);\n+            threadToNode[thread] = topology.threadToNode(thread);\n@@ -208,2 +208,2 @@\n-                threadToPackage, threadToCore, threadToRealCPU,\n-                topology.groupIsNUMA());\n+                threadToNode, threadToCore, threadToRealCPU,\n+                topology.nodeType());\n@@ -265,1 +265,1 @@\n-        int[] threadToPackage = new int[topology.totalThreads()];\n+        int[] threadToNode = new int[topology.totalThreads()];\n@@ -268,1 +268,1 @@\n-        Arrays.fill(threadToPackage, -1);\n+        Arrays.fill(threadToNode, -1);\n@@ -271,1 +271,1 @@\n-            threadToPackage[thread] = topology.threadToPackage(thread);\n+            threadToNode[thread] = topology.threadToNode(thread);\n@@ -277,2 +277,2 @@\n-                threadToPackage, threadToCore, threadToRealCPU,\n-                topology.groupIsNUMA());\n+                threadToNode, threadToCore, threadToRealCPU,\n+                topology.nodeType());\n@@ -309,1 +309,1 @@\n-        for (int p = 0; p < topology.packagesPerSystem(); p++) {\n+        for (int n = 0; n < topology.nodesPerSystem(); n++) {\n@@ -311,1 +311,1 @@\n-            for (int core : topology.packageCores(p)) {\n+            for (int core : topology.nodeCores(n)) {\n@@ -316,3 +316,3 @@\n-            for (PackageRecord pr : freeMapPackage) {\n-                if (pr.id == p && pr.avail != avail) {\n-                    throw new IllegalStateException(when + \": Package-core availability counts are inconsistent\");\n+            for (NodeRecord pr : freeMapNode) {\n+                if (pr.id == n && pr.avail != avail) {\n+                    throw new IllegalStateException(when + \": Node-core availability counts are inconsistent\");\n@@ -339,1 +339,1 @@\n-        for (int p = 0; p < topology.packagesPerSystem(); p++) {\n+        for (int n = 0; n < topology.nodesPerSystem(); n++) {\n@@ -341,1 +341,1 @@\n-            for (int core : topology.packageCores(p)) {\n+            for (int core : topology.nodeCores(n)) {\n@@ -346,2 +346,2 @@\n-            freeMapPackage[p].id = p;\n-            freeMapPackage[p].avail = avail;\n+            freeMapNode[n].id = n;\n+            freeMapNode[n].avail = avail;\n@@ -350,1 +350,1 @@\n-        Arrays.sort(freeMapPackage);\n+        Arrays.sort(freeMapNode);\n@@ -357,1 +357,1 @@\n-    private static class PackageRecord implements Comparable<PackageRecord> {\n+    private static class NodeRecord implements Comparable<NodeRecord> {\n@@ -361,1 +361,1 @@\n-        private PackageRecord(int id, int avail) {\n+        private NodeRecord(int id, int avail) {\n@@ -367,1 +367,1 @@\n-        public int compareTo(PackageRecord other) {\n+        public int compareTo(NodeRecord other) {\n@@ -381,1 +381,1 @@\n-        List<SchedulingClass> packageCases = new ArrayList<>();\n+        List<SchedulingClass> nodeCases = new ArrayList<>();\n@@ -383,4 +383,4 @@\n-        \/\/ Assign package groups\n-        int[][] packagePerms = classPermutation(actors, topology.packagesPerSystem());\n-        for (int[] pp : packagePerms) {\n-            SchedulingClass scl = new SchedulingClass(AffinityMode.LOCAL, actors, topology.groupIsNUMA());\n+        \/\/ Assign node groups\n+        int[][] nodePerms = classPermutation(actors, topology.nodesPerSystem());\n+        for (int[] pp : nodePerms) {\n+            SchedulingClass scl = new SchedulingClass(AffinityMode.LOCAL, actors, topology.nodeType());\n@@ -388,1 +388,1 @@\n-                scl.setPackage(a, pp[a]);\n+                scl.setNode(a, pp[a]);\n@@ -390,1 +390,1 @@\n-            packageCases.add(scl);\n+            nodeCases.add(scl);\n@@ -395,8 +395,8 @@\n-        for (SchedulingClass scl : packageCases) {\n-            int numPackages = scl.numPackages();\n-            int[] packageActors = scl.packageActors();\n-\n-            int[][][] packageCoreAssignments = new int[numPackages][][];\n-            for (int p = 0; p < numPackages; p++) {\n-                int[][] perms = classPermutation(packageActors[p], topology.coresPerPackage());\n-                packageCoreAssignments[p] = perms;\n+        for (SchedulingClass scl : nodeCases) {\n+            int numNodes = scl.numNodes();\n+            int[] nodeActors = scl.nodeActors();\n+\n+            int[][][] nodeCoreAssignments = new int[numNodes][][];\n+            for (int p = 0; p < numNodes; p++) {\n+                int[][] perms = classPermutation(nodeActors[p], topology.coresPerNode());\n+                nodeCoreAssignments[p] = perms;\n@@ -408,1 +408,1 @@\n-            for (int p = 0; p < numPackages; p++) {\n+            for (int p = 0; p < numNodes; p++) {\n@@ -411,1 +411,1 @@\n-                    \/\/ Compute last assigned core class for other packages\n+                    \/\/ Compute last assigned core class for other nodes\n@@ -415,1 +415,1 @@\n-                    for (int[] coreClasses : packageCoreAssignments[p]) {\n+                    for (int[] coreClasses : nodeCoreAssignments[p]) {\n@@ -419,1 +419,1 @@\n-                            if (scl.getPackage(i) == p) {\n+                            if (scl.getNode(i) == p) {\n@@ -529,1 +529,1 @@\n-        SchedulingClass scl = new SchedulingClass(mode, threads, topology.groupIsNUMA());\n+        SchedulingClass scl = new SchedulingClass(mode, threads, topology.nodeType());\n@@ -531,1 +531,1 @@\n-            scl.setPackage(t, -1);\n+            scl.setNode(t, -1);\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/os\/Scheduler.java","additions":64,"deletions":64,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.util.Collections;\n@@ -35,1 +34,1 @@\n-    final int[] packages;\n+    final int[] nodes;\n@@ -37,1 +36,1 @@\n-    final boolean groupIsNUMA;\n+    final NodeType nodeType;\n@@ -39,1 +38,1 @@\n-    public SchedulingClass(AffinityMode mode, int actors, boolean groupIsNUMA) {\n+    public SchedulingClass(AffinityMode mode, int actors, NodeType nodeType) {\n@@ -41,1 +40,1 @@\n-        this.packages = new int[actors];\n+        this.nodes = new int[actors];\n@@ -44,2 +43,2 @@\n-        this.groupIsNUMA = groupIsNUMA;\n-        Arrays.fill(packages, -1);\n+        this.nodeType = nodeType;\n+        Arrays.fill(nodes, -1);\n@@ -52,2 +51,2 @@\n-        this.groupIsNUMA = copy.groupIsNUMA;\n-        this.packages = Arrays.copyOf(copy.packages, copy.packages.length);\n+        this.nodeType = copy.nodeType;\n+        this.nodes = Arrays.copyOf(copy.nodes, copy.nodes.length);\n@@ -65,1 +64,1 @@\n-    public int numPackages() {\n+    public int numNodes() {\n@@ -67,1 +66,1 @@\n-        for (int p : packages) {\n+        for (int p : nodes) {\n@@ -81,3 +80,3 @@\n-    public int[] packageActors() {\n-        int[] r = new int[numPackages()];\n-        for (int p : packages) {\n+    public int[] nodeActors() {\n+        int[] r = new int[numNodes()];\n+        for (int p : nodes) {\n@@ -97,2 +96,2 @@\n-    public void setPackage(int a, int p) {\n-        packages[a] = p;\n+    public void setNode(int a, int n) {\n+        nodes[a] = n;\n@@ -101,2 +100,2 @@\n-    public int getPackage(int a) {\n-        return packages[a];\n+    public int getNode(int a) {\n+        return nodes[a];\n@@ -113,1 +112,1 @@\n-        return Arrays.equals(packages, scl.packages) &&\n+        return Arrays.equals(nodes, scl.nodes) &&\n@@ -119,1 +118,1 @@\n-        int result = Arrays.hashCode(packages);\n+        int result = Arrays.hashCode(nodes);\n@@ -131,6 +130,4 @@\n-            if (groupIsNUMA) {\n-                sb.append(\"(NG \");\n-            } else {\n-                sb.append(\"(PG \");\n-            }\n-            int p = packages[a];\n+            sb.append(\"(\");\n+            sb.append(nodeType.shortDesc());\n+            sb.append(\"G \");\n+            int p = nodes[a];\n@@ -164,6 +161,3 @@\n-            if (scl.groupIsNUMA) {\n-                sb.append(\"NUMA node group \");\n-            } else {\n-                sb.append(\"package group\");\n-            }\n-            int p = scl.packages[a];\n+            sb.append(scl.nodeType.desc());\n+            sb.append(\" group \");\n+            int p = scl.nodes[a];\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/os\/SchedulingClass.java","additions":26,"deletions":32,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import org.openjdk.jcstress.os.NodeType;\n@@ -33,1 +34,0 @@\n-import java.util.stream.Collectors;\n@@ -37,3 +37,3 @@\n-    private SortedSet<Integer> packages = new TreeSet<>();\n-    private SortedSet<Integer>   cores    = new TreeSet<>();\n-    private SortedSet<Integer> threads  = new TreeSet<>();\n+    private SortedSet<Integer> nodes   = new TreeSet<>();\n+    private SortedSet<Integer> cores   = new TreeSet<>();\n+    private SortedSet<Integer> threads = new TreeSet<>();\n@@ -41,3 +41,3 @@\n-    private SortedMap<Integer, Integer> threadToPackage = new TreeMap<>();\n-    private SortedMap<Integer, Integer> threadToCore    = new TreeMap<>();\n-    private SortedMap<Integer, Integer> coreToPackage   = new TreeMap<>();\n+    private SortedMap<Integer, Integer> threadToNode = new TreeMap<>();\n+    private SortedMap<Integer, Integer> threadToCore = new TreeMap<>();\n+    private SortedMap<Integer, Integer> coreToNode   = new TreeMap<>();\n@@ -45,2 +45,2 @@\n-    private Multimap<Integer, Integer>  coreToThread    = new TreesetMultimap<>();\n-    private Multimap<Integer, Integer>  packageToCore   = new TreesetMultimap<>();\n+    private Multimap<Integer, Integer> coreToThread = new TreesetMultimap<>();\n+    private Multimap<Integer, Integer> nodeToCore   = new TreesetMultimap<>();\n@@ -50,2 +50,2 @@\n-    private int packagesPerSystem = -1;\n-    private int coresPerPackage = -1;\n+    private int nodesPerSystem = -1;\n+    private int coresPerNode = -1;\n@@ -56,2 +56,2 @@\n-    protected void add(int packageId, int coreId, int threadId) throws TopologyParseException {\n-        String triplet = \"P\" + packageId + \", C\" + coreId + \", T\" + threadId;\n+    protected void add(int nodeId, int coreId, int threadId) throws TopologyParseException {\n+        String triplet = \"N\" + nodeId + \", C\" + coreId + \", T\" + threadId;\n@@ -59,2 +59,2 @@\n-        if (packageId == -1) {\n-            throw new TopologyParseException(\"Package is not initialized: \" + triplet);\n+        if (nodeId == -1) {\n+            throw new TopologyParseException(\"Node is not initialized: \" + triplet);\n@@ -71,1 +71,1 @@\n-        packages.add(packageId);\n+        nodes.add(nodeId);\n@@ -79,4 +79,4 @@\n-        if (coreToPackage.containsKey(coreId)) {\n-            Integer ex = coreToPackage.get(coreId);\n-            if (!ex.equals(packageId)) {\n-                throw new TopologyParseException(\"Core belongs to different packages: \" + triplet + \", \" + ex);\n+        if (coreToNode.containsKey(coreId)) {\n+            Integer ex = coreToNode.get(coreId);\n+            if (!ex.equals(nodeId)) {\n+                throw new TopologyParseException(\"Core belongs to different nodes: \" + triplet + \", \" + ex);\n@@ -85,1 +85,1 @@\n-            coreToPackage.put(coreId, packageId);\n+            coreToNode.put(coreId, nodeId);\n@@ -88,4 +88,4 @@\n-        if (threadToPackage.containsKey(threadId)) {\n-            Integer ex = threadToPackage.get(threadId);\n-            if (!ex.equals(packageId)) {\n-                throw new TopologyParseException(\"Thread belongs to different packages: \" + triplet + \", \" + ex);\n+        if (threadToNode.containsKey(threadId)) {\n+            Integer ex = threadToNode.get(threadId);\n+            if (!ex.equals(nodeId)) {\n+                throw new TopologyParseException(\"Thread belongs to different nodes: \" + triplet + \", \" + ex);\n@@ -94,1 +94,1 @@\n-            threadToPackage.put(threadId, packageId);\n+            threadToNode.put(threadId, nodeId);\n@@ -106,1 +106,1 @@\n-        packageToCore.put(packageId, coreId);\n+        nodeToCore.put(nodeId, coreId);\n@@ -157,1 +157,1 @@\n-        renumberPackages();\n+        renumberNodes();\n@@ -169,1 +169,1 @@\n-        coreToPackage = remapKeys(coreToPackage, renumber);\n+        coreToNode = remapKeys(coreToNode, renumber);\n@@ -171,1 +171,1 @@\n-        packageToCore = remapValues(packageToCore, renumber);\n+        nodeToCore = remapValues(nodeToCore, renumber);\n@@ -185,1 +185,1 @@\n-        threadToPackage = remapKeys(threadToPackage, renumber);\n+        threadToNode = remapKeys(threadToNode, renumber);\n@@ -188,1 +188,1 @@\n-    private void renumberPackages() {\n+    private void renumberNodes() {\n@@ -191,1 +191,1 @@\n-        Map<Integer, Integer> renumber = renumber(packages, x -> x);\n+        Map<Integer, Integer> renumber = renumber(nodes, x -> x);\n@@ -193,4 +193,4 @@\n-        packages = new TreeSet<>(renumber.values());\n-        threadToPackage = remapValues(threadToPackage, renumber);\n-        coreToPackage = remapValues(coreToPackage, renumber);\n-        packageToCore = remapKeys(packageToCore, renumber);\n+        nodes = new TreeSet<>(renumber.values());\n+        threadToNode = remapValues(threadToNode, renumber);\n+        coreToNode = remapValues(coreToNode, renumber);\n+        nodeToCore = remapKeys(nodeToCore, renumber);\n@@ -202,2 +202,2 @@\n-        if (packages.first() != 0 || packages.last() != packages.size() - 1) {\n-            throw new TopologyParseException(\"Package IDs are not consecutive: \" + packages);\n+        if (nodes.first() != 0 || nodes.last() != nodes.size() - 1) {\n+            throw new TopologyParseException(\"Node IDs are not consecutive: \" + nodes);\n@@ -214,1 +214,1 @@\n-        packagesPerSystem = packages.size();\n+        nodesPerSystem = nodes.size();\n@@ -216,4 +216,4 @@\n-        for (Integer p : packageToCore.keys()) {\n-            int size = packageToCore.get(p).size();\n-            if (coresPerPackage == -1) {\n-                coresPerPackage = size;\n+        for (Integer p : nodeToCore.keys()) {\n+            int size = nodeToCore.get(p).size();\n+            if (coresPerNode == -1) {\n+                coresPerNode = size;\n@@ -221,1 +221,1 @@\n-                coresPerPackage = Math.min(coresPerPackage, size);\n+                coresPerNode = Math.min(coresPerNode, size);\n@@ -253,6 +253,6 @@\n-                packagesPerSystem,\n-                groupIsNUMA() ? \"NUMA node\" : \"package\",\n-                packagesPerSystem > 1 ? \"s\" : \"\",\n-                coresPerPackage,\n-                coresPerPackage > 1 ? \"s\" : \"\",\n-                groupIsNUMA() ? \"NUMA node\" : \"package\",\n+                nodesPerSystem,\n+                nodeType().desc(),\n+                nodesPerSystem > 1 ? \"s\" : \"\",\n+                coresPerNode,\n+                coresPerNode > 1 ? \"s\" : \"\",\n+                nodeType().desc(),\n@@ -263,2 +263,2 @@\n-        for (Integer pack : packages) {\n-            for (Integer core : packageToCore.get(pack)) {\n+        for (Integer pack : nodes) {\n+            for (Integer core : nodeToCore.get(pack)) {\n@@ -268,1 +268,1 @@\n-                            groupIsNUMA() ? \"NUMA node\" : \"package\",\n+                            nodeType().desc(),\n@@ -280,1 +280,1 @@\n-    public int coresPerPackage() {\n+    public int coresPerNode() {\n@@ -282,1 +282,1 @@\n-        return coresPerPackage;\n+        return coresPerNode;\n@@ -285,1 +285,1 @@\n-    public int packagesPerSystem() {\n+    public int nodesPerSystem() {\n@@ -287,1 +287,1 @@\n-        return packagesPerSystem;\n+        return nodesPerSystem;\n@@ -308,1 +308,1 @@\n-    public Collection<Integer> packageCores(int packageId) {\n+    public Collection<Integer> nodeCores(int nodeId) {\n@@ -310,1 +310,1 @@\n-        return packageToCore.get(packageId);\n+        return nodeToCore.get(nodeId);\n@@ -314,1 +314,1 @@\n-    public int coreToPackage(int coreId) {\n+    public int coreToNode(int coreId) {\n@@ -316,1 +316,1 @@\n-        return coreToPackage.get(coreId);\n+        return coreToNode.get(coreId);\n@@ -320,1 +320,1 @@\n-    public int threadToPackage(int thread) {\n+    public int threadToNode(int thread) {\n@@ -322,1 +322,1 @@\n-        Integer v = threadToPackage.get(thread);\n+        Integer v = threadToNode.get(thread);\n@@ -324,1 +324,1 @@\n-            throw new IllegalArgumentException(\"Cannot find package mapping for thread \" + thread);\n+            throw new IllegalArgumentException(\"Cannot find node mapping for thread \" + thread);\n@@ -350,2 +350,2 @@\n-    public boolean groupIsNUMA() {\n-        return false;\n+    public NodeType nodeType() {\n+        return NodeType.PACKAGE;\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/os\/topology\/AbstractTopology.java","additions":67,"deletions":67,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import org.openjdk.jcstress.os.NodeType;\n@@ -167,1 +168,1 @@\n-                    int packageId = readInt(d.resolve(\"topology\/physical_package_id\"));\n+                    int nodeId = readInt(d.resolve(\"topology\/physical_package_id\"));\n@@ -169,2 +170,2 @@\n-                        \/\/ Prefer NUMA ID as \"package\"\n-                        packageId = cpuToNuma.get(threadId);\n+                        \/\/ Prefer NUMA ID as node\n+                        nodeId = cpuToNuma.get(threadId);\n@@ -177,1 +178,1 @@\n-                        if (packageId == -1) {\n+                        if (nodeId == -1) {\n@@ -182,1 +183,1 @@\n-                            packageId = knownPackage.get(list);\n+                            nodeId = knownPackage.get(list);\n@@ -185,1 +186,1 @@\n-                    add(packageId, packageId*cpuCount + coreId, threadId);\n+                    add(nodeId, nodeId*cpuCount + coreId, threadId);\n@@ -211,2 +212,2 @@\n-    public boolean groupIsNUMA() {\n-        return numaMode;\n+    public NodeType nodeType() {\n+        return numaMode ? NodeType.NUMA : NodeType.PACKAGE;\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/os\/topology\/LinuxSysfsTopology.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n-    public void add(int packageId, int coreId, int threadId) throws TopologyParseException {\n-        super.add(packageId, coreId, threadId);\n+    public void add(int nodeId, int coreId, int threadId) throws TopologyParseException {\n+        super.add(nodeId, coreId, threadId);\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/os\/topology\/PresetListTopology.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-    public PresetRegularTopology(int packagesPerSystem, int coresPerPackage, int threadsPerCore) throws TopologyParseException {\n+    public PresetRegularTopology(int nodesPerSystem, int coresPerNode, int threadsPerCore) throws TopologyParseException {\n@@ -31,3 +31,3 @@\n-            for (int p = 0; p < packagesPerSystem; p++) {\n-                for (int c = 0; c < coresPerPackage; c++) {\n-                    add(p, c + p*coresPerPackage, t*coresPerPackage*packagesPerSystem + c + p*coresPerPackage);\n+            for (int p = 0; p < nodesPerSystem; p++) {\n+                for (int c = 0; c < coresPerNode; c++) {\n+                    add(p, c + p*coresPerNode, t*coresPerNode*nodesPerSystem + c + p*coresPerNode);\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/os\/topology\/PresetRegularTopology.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import org.openjdk.jcstress.os.NodeType;\n@@ -65,2 +66,2 @@\n-    int coresPerPackage();\n-    int packagesPerSystem();\n+    int coresPerNode();\n+    int nodesPerSystem();\n@@ -71,1 +72,1 @@\n-    Collection<Integer> packageCores(int packageId);\n+    Collection<Integer> nodeCores(int nodeId);\n@@ -74,2 +75,2 @@\n-    int threadToPackage(int threadId);\n-    int coreToPackage(int coreId);\n+    int threadToNode(int threadId);\n+    int coreToNode(int coreId);\n@@ -79,1 +80,1 @@\n-    boolean groupIsNUMA();\n+    NodeType nodeType();\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/os\/topology\/Topology.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-                    if (scl.packages[a1] == scl.packages[a2]) {\n+                    if (scl.nodes[a1] == scl.nodes[a2]) {\n@@ -98,1 +98,1 @@\n-                                topo.threadToPackage(actorMap[a1]), topo.threadToPackage(actorMap[a2]));\n+                                topo.threadToNode(actorMap[a1]), topo.threadToNode(actorMap[a2]));\n@@ -101,1 +101,1 @@\n-                                topo.threadToPackage(actorMap[a1]), topo.threadToPackage(actorMap[a2]));\n+                                topo.threadToNode(actorMap[a1]), topo.threadToNode(actorMap[a2]));\n","filename":"jcstress-core\/src\/test\/java\/org\/openjdk\/jcstress\/os\/AbstractSchedulerAffinityTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,3 +38,3 @@\n-        SchedulingClass scl = new SchedulingClass(AffinityMode.LOCAL, 2, false);\n-        scl.setPackage(0, 0);\n-        scl.setPackage(1, 0);\n+        SchedulingClass scl = new SchedulingClass(AffinityMode.LOCAL, 2, NodeType.PACKAGE);\n+        scl.setNode(0, 0);\n+        scl.setNode(1, 0);\n@@ -57,3 +57,3 @@\n-        SchedulingClass scl = new SchedulingClass(AffinityMode.LOCAL, 2, false);\n-        scl.setPackage(0, 0);\n-        scl.setPackage(1, 0);\n+        SchedulingClass scl = new SchedulingClass(AffinityMode.LOCAL, 2, NodeType.PACKAGE);\n+        scl.setNode(0, 0);\n+        scl.setNode(1, 0);\n@@ -76,3 +76,3 @@\n-        SchedulingClass scl = new SchedulingClass(AffinityMode.LOCAL, 2, false);\n-        scl.setPackage(0, 0);\n-        scl.setPackage(1, 1);\n+        SchedulingClass scl = new SchedulingClass(AffinityMode.LOCAL, 2, NodeType.PACKAGE);\n+        scl.setNode(0, 0);\n+        scl.setNode(1, 1);\n@@ -87,1 +87,1 @@\n-                t.threadToPackage(schedule[0]) != t.threadToPackage(schedule[1]));\n+                t.threadToNode(schedule[0]) != t.threadToNode(schedule[1]));\n","filename":"jcstress-core\/src\/test\/java\/org\/openjdk\/jcstress\/os\/SchedulerTest.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-            for (int pa : scl.packageActors()) {\n+            for (int pa : scl.nodeActors()) {\n@@ -84,1 +84,1 @@\n-                    if (scl.packages[a1] != scl.packages[a2]) {\n+                    if (scl.nodes[a1] != scl.nodes[a2]) {\n","filename":"jcstress-core\/src\/test\/java\/org\/openjdk\/jcstress\/os\/SchedulingClassInvariantsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-        Assert.assertEquals(topo.packagesPerSystem() * topo.coresPerPackage() * topo.threadsPerCore(), topo.totalThreads());\n+        Assert.assertEquals(topo.nodesPerSystem() * topo.coresPerNode() * topo.threadsPerCore(), topo.totalThreads());\n@@ -44,5 +44,5 @@\n-        for (int p = 0; p < topo.packagesPerSystem(); p++) {\n-            Collection<Integer> packageCores = topo.packageCores(p);\n-            Assert.assertEquals(topo.coresPerPackage(), packageCores.size());\n-            for (int c : packageCores) {\n-                Assert.assertEquals(p, topo.coreToPackage(c));\n+        for (int n = 0; n < topo.nodesPerSystem(); n++) {\n+            Collection<Integer> nodeCores = topo.nodeCores(n);\n+            Assert.assertEquals(topo.coresPerNode(), nodeCores.size());\n+            for (int c : nodeCores) {\n+                Assert.assertEquals(n, topo.coreToNode(c));\n@@ -53,1 +53,1 @@\n-                    Assert.assertEquals(p, topo.threadToPackage(t));\n+                    Assert.assertEquals(n, topo.threadToNode(t));\n","filename":"jcstress-core\/src\/test\/java\/org\/openjdk\/jcstress\/os\/topology\/AbstractTopologyTest.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-        Assert.assertEquals(1, topo.packagesPerSystem());\n+        Assert.assertEquals(1, topo.nodesPerSystem());\n@@ -40,1 +40,1 @@\n-            Assert.assertEquals(0, topo.threadToPackage(t));\n+            Assert.assertEquals(0, topo.threadToNode(t));\n@@ -45,1 +45,1 @@\n-            Assert.assertEquals(0, topo.coreToPackage(c));\n+            Assert.assertEquals(0, topo.coreToNode(c));\n","filename":"jcstress-core\/src\/test\/java\/org\/openjdk\/jcstress\/os\/topology\/FallbackTopologyTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -51,2 +51,2 @@\n-        Assert.assertEquals(1,  topo.packagesPerSystem());\n-        Assert.assertEquals(32, topo.coresPerPackage());\n+        Assert.assertEquals(1,  topo.nodesPerSystem());\n+        Assert.assertEquals(32, topo.coresPerNode());\n@@ -58,2 +58,2 @@\n-            Assert.assertEquals(0, topo.threadToPackage(t));\n-            Assert.assertEquals(t % topo.coresPerPackage(), topo.threadToCore(t));\n+            Assert.assertEquals(0, topo.threadToNode(t));\n+            Assert.assertEquals(t % topo.coresPerNode(), topo.threadToCore(t));\n","filename":"jcstress-core\/src\/test\/java\/org\/openjdk\/jcstress\/os\/topology\/LinuxProcfsTopologyTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -65,2 +65,2 @@\n-        Assert.assertEquals(1,  topo.packagesPerSystem());\n-        Assert.assertEquals(32, topo.coresPerPackage());\n+        Assert.assertEquals(1,  topo.nodesPerSystem());\n+        Assert.assertEquals(32, topo.coresPerNode());\n@@ -72,1 +72,1 @@\n-            Assert.assertEquals(0, topo.threadToPackage(t));\n+            Assert.assertEquals(0, topo.threadToNode(t));\n@@ -84,2 +84,2 @@\n-        Assert.assertEquals(1, topo.packagesPerSystem());\n-        Assert.assertEquals(4, topo.coresPerPackage());\n+        Assert.assertEquals(1, topo.nodesPerSystem());\n+        Assert.assertEquals(4, topo.coresPerNode());\n@@ -91,1 +91,1 @@\n-            Assert.assertEquals(0, topo.threadToPackage(t));\n+            Assert.assertEquals(0, topo.threadToNode(t));\n@@ -103,2 +103,2 @@\n-        Assert.assertEquals(2,  topo.packagesPerSystem());\n-        Assert.assertEquals(5,  topo.coresPerPackage());\n+        Assert.assertEquals(2,  topo.nodesPerSystem());\n+        Assert.assertEquals(5,  topo.coresPerNode());\n@@ -110,1 +110,1 @@\n-            Assert.assertEquals(t \/ 40, topo.threadToPackage(t));\n+            Assert.assertEquals(t \/ 40, topo.threadToNode(t));\n@@ -122,2 +122,2 @@\n-        Assert.assertEquals(10, topo.packagesPerSystem());\n-        Assert.assertEquals(1,  topo.coresPerPackage());\n+        Assert.assertEquals(10, topo.nodesPerSystem());\n+        Assert.assertEquals(1,  topo.coresPerNode());\n@@ -129,1 +129,1 @@\n-            Assert.assertEquals(t \/ 8, topo.threadToPackage(t));\n+            Assert.assertEquals(t \/ 8, topo.threadToNode(t));\n@@ -141,2 +141,2 @@\n-        Assert.assertEquals(1,  topo.packagesPerSystem());\n-        Assert.assertEquals(64, topo.coresPerPackage());\n+        Assert.assertEquals(1,  topo.nodesPerSystem());\n+        Assert.assertEquals(64, topo.coresPerNode());\n@@ -148,1 +148,1 @@\n-            Assert.assertEquals(0, topo.threadToPackage(t));\n+            Assert.assertEquals(0, topo.threadToNode(t));\n@@ -160,2 +160,2 @@\n-        Assert.assertEquals(2,  topo.packagesPerSystem());\n-        Assert.assertEquals(1, topo.coresPerPackage());\n+        Assert.assertEquals(2,  topo.nodesPerSystem());\n+        Assert.assertEquals(1, topo.coresPerNode());\n@@ -167,1 +167,1 @@\n-            Assert.assertEquals(t, topo.threadToPackage(t));\n+            Assert.assertEquals(t, topo.threadToNode(t));\n@@ -179,2 +179,2 @@\n-        Assert.assertEquals(2, topo.packagesPerSystem());\n-        Assert.assertEquals(4, topo.coresPerPackage());\n+        Assert.assertEquals(2, topo.nodesPerSystem());\n+        Assert.assertEquals(4, topo.coresPerNode());\n@@ -186,1 +186,1 @@\n-            Assert.assertEquals(t % 2, topo.threadToPackage(t));\n+            Assert.assertEquals(t % 2, topo.threadToNode(t));\n@@ -198,2 +198,2 @@\n-        Assert.assertEquals(4, topo.packagesPerSystem());\n-        Assert.assertEquals(6, topo.coresPerPackage());\n+        Assert.assertEquals(4, topo.nodesPerSystem());\n+        Assert.assertEquals(6, topo.coresPerNode());\n@@ -205,1 +205,1 @@\n-            Assert.assertEquals(t \/ 12, topo.threadToPackage(t));\n+            Assert.assertEquals(t \/ 12, topo.threadToNode(t));\n@@ -217,2 +217,2 @@\n-        Assert.assertEquals(4,  topo.packagesPerSystem());\n-        Assert.assertEquals(8,  topo.coresPerPackage());\n+        Assert.assertEquals(4,  topo.nodesPerSystem());\n+        Assert.assertEquals(8,  topo.coresPerNode());\n@@ -224,1 +224,1 @@\n-            Assert.assertEquals(t % 32 \/ 8, topo.threadToPackage(t));\n+            Assert.assertEquals(t % 32 \/ 8, topo.threadToNode(t));\n","filename":"jcstress-core\/src\/test\/java\/org\/openjdk\/jcstress\/os\/topology\/LinuxSysfsTopologyTest.java","additions":27,"deletions":27,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-    @Parameterized.Parameters(name = \"p={0} c={1} t={2}\")\n+    @Parameterized.Parameters(name = \"n={0} c={1} t={2}\")\n@@ -41,1 +41,1 @@\n-        for (int p = 1; p <= 4; p++) {\n+        for (int n = 1; n <= 4; n++) {\n@@ -44,1 +44,1 @@\n-                    r.add(new Object[] { p, c, t });\n+                    r.add(new Object[] { n, c, t });\n@@ -52,1 +52,1 @@\n-    public int p;\n+    public int n;\n@@ -62,1 +62,1 @@\n-        Topology topo = new PresetRegularTopology(p, c, t);\n+        Topology topo = new PresetRegularTopology(n, c, t);\n@@ -64,2 +64,2 @@\n-        Assert.assertEquals(p, topo.packagesPerSystem());\n-        Assert.assertEquals(c, topo.coresPerPackage());\n+        Assert.assertEquals(n, topo.nodesPerSystem());\n+        Assert.assertEquals(c, topo.coresPerNode());\n@@ -73,1 +73,1 @@\n-            Assert.assertEquals(c \/ topo.coresPerPackage(), topo.coreToPackage(c));\n+            Assert.assertEquals(c \/ topo.coresPerNode(), topo.coreToNode(c));\n","filename":"jcstress-core\/src\/test\/java\/org\/openjdk\/jcstress\/os\/topology\/PresetRegularTopologyTest.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"}]}