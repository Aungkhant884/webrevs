{"files":[{"patch":"@@ -1,99 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.jcstress;\n-\n-import org.openjdk.jcstress.infra.Status;\n-import org.openjdk.jcstress.infra.collectors.TestResult;\n-import org.openjdk.jcstress.infra.collectors.TestResultCollector;\n-import org.openjdk.jcstress.infra.runners.Runner;\n-import org.openjdk.jcstress.infra.runners.TestConfig;\n-import org.openjdk.jcstress.os.CPUMap;\n-import org.openjdk.jcstress.os.Scheduler;\n-import org.openjdk.jcstress.util.StringUtils;\n-\n-import java.lang.reflect.Constructor;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.ThreadFactory;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-public class EmbeddedExecutor {\n-\n-    private final ExecutorService pool;\n-    private final TestResultCollector sink;\n-    private final Scheduler scheduler;\n-\n-    public EmbeddedExecutor(TestResultCollector sink) {\n-        this(sink, null);\n-    }\n-\n-    public EmbeddedExecutor(TestResultCollector sink, Scheduler cpuLayout) {\n-        this.sink = sink;\n-        this.scheduler = cpuLayout;\n-        pool = Executors.newCachedThreadPool(new ThreadFactory() {\n-            private final AtomicInteger id = new AtomicInteger();\n-\n-            @Override\n-            public Thread newThread(Runnable r) {\n-                Thread t = new Thread(r);\n-                t.setName(\"jcstress-worker-\" + id.incrementAndGet());\n-                t.setDaemon(true);\n-                return t;\n-            }\n-        });\n-    }\n-\n-    public void submit(TestConfig config, CPUMap acquiredCPUs) {\n-        pool.submit(task(config, acquiredCPUs));\n-    }\n-\n-    public void run(TestConfig config) {\n-        task(config, null).run();\n-    }\n-\n-    private Runnable task(TestConfig config, CPUMap acquiredCPUs) {\n-        return () -> {\n-            try {\n-                Class<?> aClass = Class.forName(config.generatedRunnerName);\n-                Constructor<?> cnstr = aClass.getConstructor(TestConfig.class, TestResultCollector.class, ExecutorService.class);\n-                Runner<?> o = (Runner<?>) cnstr.newInstance(config, sink, pool);\n-                o.run();\n-            } catch (ClassFormatError | NoClassDefFoundError | NoSuchMethodError | NoSuchFieldError e) {\n-                TestResult result = new TestResult(config, Status.API_MISMATCH);\n-                result.addMessage(StringUtils.getStacktrace(e));\n-                sink.add(result);\n-            } catch (Throwable ex) {\n-                TestResult result = new TestResult(config, Status.TEST_ERROR);\n-                result.addMessage(StringUtils.getStacktrace(ex));\n-                sink.add(result);\n-            } finally {\n-                if (acquiredCPUs != null) {\n-                    scheduler.release(acquiredCPUs);\n-                }\n-            }\n-        };\n-    }\n-}\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/EmbeddedExecutor.java","additions":0,"deletions":99,"binary":false,"changes":99,"status":"deleted"},{"patch":"@@ -27,0 +27,3 @@\n+import org.openjdk.jcstress.infra.Status;\n+import org.openjdk.jcstress.infra.collectors.TestResult;\n+import org.openjdk.jcstress.infra.runners.Runner;\n@@ -29,1 +32,1 @@\n-import org.openjdk.jcstress.os.AffinitySupport;\n+import org.openjdk.jcstress.util.StringUtils;\n@@ -32,0 +35,6 @@\n+import java.lang.reflect.Constructor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n@@ -55,1 +64,0 @@\n-        EmbeddedExecutor executor = new EmbeddedExecutor(result -> link.addResult(token, result));\n@@ -57,4 +65,2 @@\n-        TestConfig config;\n-        while ((config = link.nextJob(token)) != null) {\n-            executor.run(config);\n-        }\n+        ExecutorService pool = Executors.newCachedThreadPool(new ThreadFactory() {\n+            private final AtomicInteger id = new AtomicInteger();\n@@ -62,2 +68,10 @@\n-        link.done(token);\n-    }\n+            @Override\n+            public Thread newThread(Runnable r) {\n+                Thread t = new Thread(r);\n+                t.setName(\"jcstress-worker-\" + id.incrementAndGet());\n+                t.setDaemon(true);\n+                return t;\n+            }\n+        });\n+\n+        TestConfig config = link.nextJob(token);\n@@ -65,0 +79,1 @@\n+        TestResult result;\n@@ -66,0 +81,15 @@\n+        try {\n+            Class<?> aClass = Class.forName(config.generatedRunnerName);\n+            Constructor<?> cnstr = aClass.getConstructor(TestConfig.class, ExecutorService.class);\n+            Runner<?> o = (Runner<?>) cnstr.newInstance(config, pool);\n+            result = o.run();\n+        } catch (ClassFormatError | NoClassDefFoundError | NoSuchMethodError | NoSuchFieldError e) {\n+            result = new TestResult(config, Status.API_MISMATCH);\n+            result.addMessage(StringUtils.getStacktrace(e));\n+        } catch (Throwable ex) {\n+            result = new TestResult(config, Status.TEST_ERROR);\n+            result.addMessage(StringUtils.getStacktrace(ex));\n+        }\n+\n+        link.doneResult(token, result);\n+    }\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/ForkedMain.java","additions":38,"deletions":8,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -83,5 +83,0 @@\n-            }\n-\n-            @Override\n-            public void onDone(String token) {\n-                vmByToken.get(token).recordDone();\n@@ -191,1 +186,0 @@\n-        private boolean isDone;\n@@ -377,1 +371,1 @@\n-            if (!isDone && process.isAlive()) {\n+            if (result == null && process.isAlive()) {\n@@ -424,4 +418,0 @@\n-\n-        public synchronized void recordDone() {\n-            isDone = true;\n-        }\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/TestExecutor.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import org.openjdk.jcstress.infra.collectors.TestResult;\n@@ -333,2 +334,2 @@\n-        pw.println(\"    public \" + className + \"(TestConfig config, TestResultCollector collector, ExecutorService pool) {\");\n-        pw.println(\"        super(config, collector, pool, \\\"\" + getQualifiedName(info.getTest()) + \"\\\");\");\n+        pw.println(\"    public \" + className + \"(TestConfig config, ExecutorService pool) {\");\n+        pw.println(\"        super(config, pool, \\\"\" + getQualifiedName(info.getTest()) + \"\\\");\");\n@@ -418,1 +419,1 @@\n-        pw.println(\"    public Counter<\" + r + \"> internalRun() {\");\n+        pw.println(\"    public Collection<Future<Counter<\" + r + \">>> internalRun() {\");\n@@ -455,11 +456,1 @@\n-        pw.println(\"        waitFor(results);\");\n-        pw.println();\n-        pw.println(\"        Counter<\" + r + \"> counter = new Counter<>();\");\n-        pw.println(\"        for (Future<Counter<\" + r + \">> f : results) {\");\n-        pw.println(\"            try {\");\n-        pw.println(\"                counter.merge(f.get());\");\n-        pw.println(\"            } catch (Throwable e) {\");\n-        pw.println(\"                throw new IllegalStateException(e);\");\n-        pw.println(\"            }\");\n-        pw.println(\"        }\");\n-        pw.println(\"        return counter;\");\n+        pw.println(\"        return results;\");\n@@ -752,2 +743,2 @@\n-        pw.println(\"    public \" + generatedName + \"(TestConfig config, TestResultCollector collector, ExecutorService pool) {\");\n-        pw.println(\"        super(config, collector, pool, \\\"\" + getQualifiedName(info.getTest()) + \"\\\");\");\n+        pw.println(\"    public \" + generatedName + \"(TestConfig config, ExecutorService pool) {\");\n+        pw.println(\"        super(config, pool, \\\"\" + getQualifiedName(info.getTest()) + \"\\\");\");\n@@ -758,1 +749,1 @@\n-        pw.println(\"    public void run() {\");\n+        pw.println(\"    public TestResult run() {\");\n@@ -776,1 +767,1 @@\n-        pw.println(\"        dump(results);\");\n+        pw.println(\"        return dump(results);\");\n@@ -785,1 +776,1 @@\n-        pw.println(\"    public Counter<Outcome> internalRun() {\");\n+        pw.println(\"    public Collection<Future<Counter<Outcome>>> internalRun() {\");\n@@ -937,1 +928,1 @@\n-                TestConfig.class, TestResultCollector.class,\n+                TestConfig.class, TestResult.class,\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/infra\/processors\/JCStressTestProcessor.java","additions":11,"deletions":20,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-    protected final TestResultCollector collector;\n@@ -58,2 +57,1 @@\n-    public Runner(TestConfig config, TestResultCollector collector, ExecutorService pool, String testName) {\n-        this.collector = collector;\n+    public Runner(TestConfig config, ExecutorService pool, String testName) {\n@@ -71,3 +69,2 @@\n-    public void run() {\n-        @SuppressWarnings(\"unchecked\")\n-        Counter<R>[] results = (Counter<R>[]) new Counter[config.iters + 1];\n+    public TestResult run() {\n+        Counter<R> result = new Counter<>();\n@@ -76,1 +73,2 @@\n-            results[0] = sanityCheck();\n+            Counter<R> cnt = sanityCheck();\n+            result.merge(cnt);\n@@ -78,2 +76,1 @@\n-            dumpFailure(Status.API_MISMATCH, \"Test sanity check failed, skipping\", e);\n-            return;\n+            return dumpFailure(Status.API_MISMATCH, \"Test sanity check failed, skipping\", e);\n@@ -81,2 +78,1 @@\n-            dumpFailure(Status.CHECK_TEST_ERROR, \"Check test failed\", e);\n-            return;\n+            return dumpFailure(Status.CHECK_TEST_ERROR, \"Check test failed\", e);\n@@ -91,2 +87,30 @@\n-        for (int c = 1; c <= config.iters; c++) {\n-            results[c] = internalRun();\n+        for (int c = 0; c < config.iters; c++) {\n+            Collection<Future<Counter<R>>> futures = internalRun();\n+\n+            long startTime = System.nanoTime();\n+            boolean allStopped = false;\n+            while (!allStopped) {\n+                allStopped = true;\n+                for (Future<Counter<R>> t : futures) {\n+                    try {\n+                        t.get(1, TimeUnit.SECONDS);\n+                    } catch (TimeoutException e) {\n+                        allStopped = false;\n+                    } catch (ExecutionException | InterruptedException e) {\n+                        return dumpFailure(Status.TEST_ERROR, \"Unrecoverable error while running\", e.getCause());\n+                    }\n+                }\n+\n+                long timeSpent = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime);\n+                if (timeSpent > Math.max(10*config.time, MIN_TIMEOUT_MS)) {\n+                    return dumpFailure(Status.TIMEOUT_ERROR, \"Timeout waiting for tasks to complete: \" + timeSpent + \" ms\");\n+                }\n+            }\n+\n+            for (Future<Counter<R>> t : futures) {\n+                try {\n+                    result.merge(t.get());\n+                } catch (InterruptedException | ExecutionException e) {\n+                    \/\/ Cannot happen anymore.\n+                }\n+            }\n@@ -94,1 +118,2 @@\n-        dump(results);\n+\n+        return dump(result);\n@@ -106,1 +131,1 @@\n-    protected void dumpFailure(Status status, String message) {\n+    protected TestResult dumpFailure(Status status, String message) {\n@@ -108,2 +133,1 @@\n-        TestResult result = prepareResult(status);\n-        collector.add(result);\n+        return prepareResult(status);\n@@ -112,1 +136,1 @@\n-    protected void dumpFailure(Status status, String message, Throwable aux) {\n+    protected TestResult dumpFailure(Status status, String message, Throwable aux) {\n@@ -116,1 +140,1 @@\n-        collector.add(result);\n+        return result;\n@@ -119,1 +143,1 @@\n-    protected void dump(Counter<R> cnt) {\n+    protected TestResult dump(Counter<R> cnt) {\n@@ -124,11 +148,1 @@\n-        collector.add(result);\n-    }\n-\n-    protected void dump(Counter<R>[] results) {\n-        TestResult result = prepareResult(Status.NORMAL);\n-        for (Counter<R> cnt : results) {\n-            for (R e : cnt.elementSet()) {\n-                result.addState(String.valueOf(e), cnt.count(e));\n-            }\n-        }\n-        collector.add(result);\n+        return result;\n@@ -139,19 +153,1 @@\n-    public abstract Counter<R> internalRun();\n-\n-    protected <T> void waitFor(Collection<Future<T>> tasks) {\n-        long startTime = System.nanoTime();\n-        boolean allStopped = false;\n-        while (!allStopped) {\n-            allStopped = true;\n-            for (Future<?> t : tasks) {\n-                try {\n-                    t.get(1, TimeUnit.SECONDS);\n-                } catch (TimeoutException e) {\n-                    allStopped = false;\n-                } catch (ExecutionException e) {\n-                    dumpFailure(Status.TEST_ERROR, \"Unrecoverable error while running\", e.getCause());\n-                    return;\n-                } catch (InterruptedException e) {\n-                    return;\n-                }\n-            }\n+    public abstract Collection<Future<Counter<R>>> internalRun();\n@@ -159,7 +155,0 @@\n-            long timeSpent = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime);\n-            if (timeSpent > Math.max(10*config.time, MIN_TIMEOUT_MS)) {\n-                dumpFailure(Status.TIMEOUT_ERROR, \"Timeout waiting for tasks to complete: \" + timeSpent + \" ms\");\n-                return;\n-            }\n-        }\n-    }\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/infra\/runners\/Runner.java","additions":46,"deletions":57,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-    public void addResult(String token, TestResult result) {\n+    public void doneResult(String token, TestResult result) {\n@@ -86,7 +86,0 @@\n-    public void done(String token) {\n-        try {\n-            requestResponse(new DoneFrame(token));\n-        } catch (IOException e) {\n-            throw new IllegalStateException(e);\n-        }\n-    }\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/link\/BinaryLinkClient.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -131,4 +131,0 @@\n-                        } else if (obj instanceof DoneFrame) {\n-                            String tkn = ((DoneFrame) obj).getToken();\n-                            listener.onDone(tkn);\n-                            oos.writeObject(new OkResponseFrame());\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/link\/BinaryLinkServer.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.jcstress.link;\n-\n-import java.io.Serializable;\n-\n-class DoneFrame implements Serializable {\n-    private static final long serialVersionUID = -4528163874292325861L;\n-\n-    private final String token;\n-\n-    public DoneFrame(String token) {\n-        this.token = token;\n-    }\n-\n-    public String getToken() {\n-        return token;\n-    }\n-}\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/link\/DoneFrame.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -36,2 +36,0 @@\n-    void onDone(String token);\n-\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/link\/ServerListener.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}