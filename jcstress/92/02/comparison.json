{"files":[{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jcstress.samples.high.rmw;\n+\n+import org.openjdk.jcstress.annotations.Actor;\n+import org.openjdk.jcstress.annotations.JCStressTest;\n+import org.openjdk.jcstress.annotations.Outcome;\n+import org.openjdk.jcstress.annotations.State;\n+import org.openjdk.jcstress.infra.results.Z_Result;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+\n+import static org.openjdk.jcstress.annotations.Expect.*;\n+\n+public class RMW_01_UncontendedSuccess {\n+\n+    \/*\n+        How to run this test:\n+            $ java -jar jcstress-samples\/target\/jcstress.jar -t RMW_01_UncontendedSuccess[.SubTestName]\n+     *\/\n+\n+    \/*\n+      ----------------------------------------------------------------------------------------------------------\n+\n+        This test explores the behaviors of atomic RMW instructions.\n+\n+        It starts from a very basic property: whether the uncontended compare-and-set instruction\n+        completes successfully every time, or not. This test highlights the difference between\n+        \"strong\" and \"weak\" CASes.\n+\n+        The weak CASes are normally only seen on the platforms that implement LL\/SC-based atomics,\n+        so these tests are good to run on AArch64 without LSE atomics (in Hotspot, this is achieved\n+        with -XX:-UseLSE).\n+     *\/\n+\n+    @State\n+    public static class S {\n+        private int v;\n+        public static final VarHandle VH;\n+\n+        static {\n+            try {\n+                VH = MethodHandles.lookup().findVarHandle(S.class, \"v\", int.class);\n+            } catch (NoSuchFieldException | IllegalAccessException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }\n+    }\n+\n+    \/*\n+      ----------------------------------------------------------------------------------------------------------\n+\n+        The strong CAS should always succeed, as long as there is no conflicts.\n+\n+        Indeed, on both x86_64 and AArch64 this is the result:\n+\n+          RESULT      SAMPLES     FREQ      EXPECT  DESCRIPTION\n+           false            0    0.00%   Forbidden  Cannot happen\n+            true  128,018,432  100.00%  Acceptable  Trivial\n+     *\/\n+\n+    @JCStressTest\n+    @Outcome(id = \"true\",  expect = ACCEPTABLE, desc = \"Trivial\")\n+    @Outcome(id = \"false\", expect = FORBIDDEN,  desc = \"Cannot happen\")\n+    public static class Strong {\n+        @Actor\n+        public void actor(S s, Z_Result r) {\n+            r.r1 = S.VH.compareAndSet(s, 0, 1);\n+        }\n+    }\n+\n+    \/*\n+      ----------------------------------------------------------------------------------------------------------\n+\n+        The weak CAS can spuriously fail, even without any conflict.\n+\n+        It would not manifest on x86_64:\n+\n+          RESULT      SAMPLES     FREQ       EXPECT  DESCRIPTION\n+           false            0    0.00%  Interesting  Spurious failures are allowed\n+            true  125,427,712  100.00%   Acceptable  Trivial\n+\n+        But it would manifest on AArch64 -XX:-UseLSE:\n+\n+          RESULT     SAMPLES     FREQ       EXPECT  DESCRIPTION\n+           false         321   <0.01%  Interesting  Spurious failures are allowed\n+            true  76,365,503  100.00%   Acceptable  Trivial\n+     *\/\n+\n+    @JCStressTest\n+    @Outcome(id = \"true\",  expect = ACCEPTABLE,             desc = \"Trivial\")\n+    @Outcome(id = \"false\", expect = ACCEPTABLE_INTERESTING, desc = \"Spurious failures are allowed\")\n+    public static class Weak {\n+        @Actor\n+        public void actor(S s, Z_Result r) {\n+            r.r1 = S.VH.weakCompareAndSet(s, 0, 1);\n+        }\n+    }\n+\n+}\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/high\/rmw\/RMW_01_UncontendedSuccess.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jcstress.samples.high.rmw;\n+\n+import org.openjdk.jcstress.annotations.Actor;\n+import org.openjdk.jcstress.annotations.JCStressTest;\n+import org.openjdk.jcstress.annotations.Outcome;\n+import org.openjdk.jcstress.annotations.State;\n+import org.openjdk.jcstress.infra.results.ZZ_Result;\n+import org.openjdk.jcstress.infra.results.Z_Result;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+\n+import static org.openjdk.jcstress.annotations.Expect.*;\n+\n+public class RMW_02_ContendedSuccess {\n+\n+    \/*\n+        How to run this test:\n+            $ java -jar jcstress-samples\/target\/jcstress.jar -t RMW_02_ContendedSuccess[.SubTestName]\n+     *\/\n+\n+    \/*\n+      ----------------------------------------------------------------------------------------------------------\n+\n+        This tests explores a more advanced property of CASes:\n+          - for strong CASes, exactly one operation should succeed\n+          - for weak CASes, at most one operation should succeed (accept spurious failures)\n+\n+        The weak CASes are normally only seen on the platforms that implement LL\/SC-based atomics,\n+        so these tests are good to run on AArch64 without LSE atomics (in Hotspot, this is achieved\n+        with -XX:-UseLSE).\n+     *\/\n+\n+    @State\n+    public static class S {\n+        private int v;\n+        public static final VarHandle VH;\n+\n+        static {\n+            try {\n+                VH = MethodHandles.lookup().findVarHandle(S.class, \"v\", int.class);\n+            } catch (NoSuchFieldException | IllegalAccessException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }\n+    }\n+\n+    \/*\n+      ----------------------------------------------------------------------------------------------------------\n+\n+        The strong CAS should always succeed, as long as there is no conflicts.\n+\n+        Indeed, on both x86_64 and AArch64 this is the result:\n+\n+                RESULT      SAMPLES     FREQ      EXPECT  DESCRIPTION\n+          false, false            0    0.00%   Forbidden  Not even once\n+           false, true  232,042,522   52.44%  Acceptable  Trivial\n+           true, false  210,454,502   47.56%  Acceptable  Trivial\n+            true, true            0    0.00%   Forbidden  More than once\n+\n+     *\/\n+\n+    @JCStressTest\n+    @Outcome(id = {\"true, false\", \"false, true\"}, expect = ACCEPTABLE, desc = \"Trivial\")\n+    @Outcome(id = \"false, false\",                 expect = FORBIDDEN,  desc = \"Not even once\")\n+    @Outcome(id = \"true, true\",                   expect = FORBIDDEN,  desc = \"More than once\")\n+    public static class Strong {\n+        @Actor\n+        public void actor1(S s, ZZ_Result r) {\n+            r.r1 = S.VH.compareAndSet(s, 0, 1);\n+        }\n+\n+        @Actor\n+        public void actor2(S s, ZZ_Result r) {\n+            r.r2 = S.VH.compareAndSet(s, 0, 1);\n+        }\n+    }\n+\n+\n+    \/*\n+      ----------------------------------------------------------------------------------------------------------\n+\n+        The weak CAS can spuriously fail, even without any conflict, but otherwise they\n+        cannot succeed both.\n+\n+        It would not manifest on x86_64:\n+\n+                RESULT      SAMPLES     FREQ       EXPECT  DESCRIPTION\n+          false, false            0    0.00%  Interesting  Not even once\n+           false, true  240,890,038   51.04%   Acceptable  Trivial\n+           true, false  231,108,426   48.96%   Acceptable  Trivial\n+            true, true            0    0.00%    Forbidden  More than once\n+\n+        But it would manifest on AArch64 -XX:-UseLSE:\n+\n+                RESULT      SAMPLES     FREQ       EXPECT  DESCRIPTION\n+          false, false          385   <0.01%  Interesting  Not even once\n+           false, true  152,343,703   48.79%   Acceptable  Trivial\n+           true, false  159,898,088   51.21%   Acceptable  Trivial\n+            true, true            0    0.00%    Forbidden  More than once\n+     *\/\n+\n+    @JCStressTest\n+    @Outcome(id = {\"true, false\", \"false, true\"}, expect = ACCEPTABLE,             desc = \"Trivial\")\n+    @Outcome(id = \"false, false\",                 expect = ACCEPTABLE_INTERESTING, desc = \"Not even once\")\n+    @Outcome(id = \"true, true\",                   expect = FORBIDDEN,              desc = \"More than once\")\n+    public static class Weak {\n+        @Actor\n+        public void actor1(S s, ZZ_Result r) {\n+            r.r1 = S.VH.weakCompareAndSet(s, 0, 1);\n+        }\n+        @Actor\n+        public void actor2(S s, ZZ_Result r) {\n+            r.r2 = S.VH.weakCompareAndSet(s, 0, 1);\n+        }\n+    }\n+\n+}\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/high\/rmw\/RMW_02_ContendedSuccess.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jcstress.samples.high.rmw;\n+\n+import org.openjdk.jcstress.annotations.Actor;\n+import org.openjdk.jcstress.annotations.JCStressTest;\n+import org.openjdk.jcstress.annotations.Outcome;\n+import org.openjdk.jcstress.annotations.State;\n+import org.openjdk.jcstress.infra.results.Z_Result;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+\n+import static org.openjdk.jcstress.annotations.Expect.*;\n+\n+public class RMW_03_ConflictSameValue {\n+\n+    \/*\n+        How to run this test:\n+            $ java -jar jcstress-samples\/target\/jcstress.jar -t RMW_03_ConflictSameValue[.SubTestName]\n+     *\/\n+\n+    \/*\n+      ----------------------------------------------------------------------------------------------------------\n+\n+        This test explores the behaviors of atomic RMW instructions.\n+\n+        This shows the important caveat about the notion of conflict. Even if there is an intervening\n+        write to the same variable _that keeps the value the same_, the CAS is still guaranteed\n+        to succeed.\n+     *\/\n+\n+    @State\n+    public static class S {\n+        private int v;\n+        public static final VarHandle VH;\n+\n+        static {\n+            try {\n+                VH = MethodHandles.lookup().findVarHandle(S.class, \"v\", int.class);\n+            } catch (NoSuchFieldException | IllegalAccessException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }\n+    }\n+\n+    \/*\n+      ----------------------------------------------------------------------------------------------------------\n+\n+        The strong CAS should always succeed, even though there is a write to the same\n+        variable. Since that write brings the value still expected by the CAS, it would\n+        succeed.\n+\n+        Indeed, on both x86_64 and AArch64 this is the result:\n+\n+          RESULT      SAMPLES     FREQ      EXPECT  DESCRIPTION\n+           false            0    0.00%   Forbidden  Cannot happen\n+            true  515,528,704  100.00%  Acceptable  Trivial\n+     *\/\n+\n+    @JCStressTest\n+    @Outcome(id = \"true\",  expect = ACCEPTABLE, desc = \"Trivial\")\n+    @Outcome(id = \"false\", expect = FORBIDDEN,  desc = \"Cannot happen\")\n+    public static class Strong {\n+        @Actor\n+        public void actor1(S s, Z_Result r) {\n+            r.r1 = S.VH.compareAndSet(s, 0, 1);\n+        }\n+\n+        @Actor\n+        public void actor2(S s) {\n+            S.VH.setVolatile(s, 0);\n+        }\n+    }\n+\n+    \/*\n+      ----------------------------------------------------------------------------------------------------------\n+\n+        The weak CAS can spuriously fail, even without any conflict. But with the conflict like\n+        this, the chances that a weak CAS would fail are much greater. Compare with the failure\n+        frequency in RMW_02_ContendedSuccess.\n+\n+        It would not manifest on x86_64:\n+\n+          RESULT      SAMPLES     FREQ       EXPECT  DESCRIPTION\n+           false            0    0.00%  Interesting  Spurious failures are allowed\n+            true  430,516,224  100.00%   Acceptable  Trivial\n+\n+        But it would manifest on AArch64 -XX:-UseLSE:\n+\n+          RESULT      SAMPLES     FREQ       EXPECT  DESCRIPTION\n+           false    1,468,383    0.38%  Interesting  Spurious failures are allowed\n+            true  386,877,473   99.62%   Acceptable  Trivial\n+     *\/\n+\n+    @JCStressTest\n+    @Outcome(id = \"true\",  expect = ACCEPTABLE,             desc = \"Trivial\")\n+    @Outcome(id = \"false\", expect = ACCEPTABLE_INTERESTING, desc = \"Spurious failures are allowed\")\n+    public static class Weak {\n+        @Actor\n+        public void actor1(S s, Z_Result r) {\n+            r.r1 = S.VH.weakCompareAndSet(s, 0, 1);\n+        }\n+\n+        @Actor\n+        public void actor2(S s) {\n+            S.VH.setVolatile(s, 0);\n+        }\n+    }\n+\n+}\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/high\/rmw\/RMW_03_ConflictSameValue.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jcstress.samples.high.rmw;\n+\n+import org.openjdk.jcstress.annotations.Actor;\n+import org.openjdk.jcstress.annotations.JCStressTest;\n+import org.openjdk.jcstress.annotations.Outcome;\n+import org.openjdk.jcstress.annotations.State;\n+import org.openjdk.jcstress.infra.results.II_Result;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+\n+import static org.openjdk.jcstress.annotations.Expect.*;\n+\n+@JCStressTest\n+@Outcome(id = {\"0, 0\", \"1, 1\", \"0, 1\"}, expect = ACCEPTABLE, desc = \"Trivial\")\n+@Outcome(id = \"1, 0\",                   expect = FORBIDDEN,  desc = \"Cannot happen\")\n+@State\n+public class RMW_04_AcquireOnSuccess {\n+\n+    \/*\n+        How to run this test:\n+            $ java -jar jcstress-samples\/target\/jcstress.jar -t RMW_04_AcquireOnSuccess[.SubTestName]\n+     *\/\n+\n+    \/*\n+      ----------------------------------------------------------------------------------------------------------\n+\n+        This test shows that CAS provides \"acquire\" semantics on success. This is similar\n+        to other tests, for example BasicJMM_06_Causality: once we observe something\n+        \"release\"-d by another thread, using any primitive with \"acquire\" semantics,\n+        we are guaranteed to see things that happened before that release.\n+\n+        Indeed, on both x86_64 and AArch64 this would happen:\n+          RESULT      SAMPLES     FREQ      EXPECT  DESCRIPTION\n+            0, 0  138,542,022   42.99%  Acceptable  Trivial\n+            0, 1    3,232,097    1.00%  Acceptable  Trivial\n+            1, 0            0    0.00%   Forbidden  Cannot happen\n+            1, 1  180,464,345   56.00%  Acceptable  Trivial\n+     *\/\n+\n+    private int x, g;\n+    public static final VarHandle VH;\n+\n+    static {\n+        try {\n+            VH = MethodHandles.lookup().findVarHandle(RMW_04_AcquireOnSuccess.class, \"g\", int.class);\n+        } catch (NoSuchFieldException | IllegalAccessException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    @Actor\n+    public void actor1(II_Result r) {\n+        x = 1;\n+        VH.setVolatile(this, 1);\n+    }\n+\n+    @Actor\n+    public void actor2(II_Result r) {\n+        r.r1 = VH.compareAndSet(this, 1, 0) ? 1 : 0; \/\/ succeeds if (g == 1)\n+        r.r2 = x;\n+    }\n+\n+}\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/high\/rmw\/RMW_04_AcquireOnSuccess.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jcstress.samples.high.rmw;\n+\n+import org.openjdk.jcstress.annotations.Actor;\n+import org.openjdk.jcstress.annotations.JCStressTest;\n+import org.openjdk.jcstress.annotations.Outcome;\n+import org.openjdk.jcstress.annotations.State;\n+import org.openjdk.jcstress.infra.results.II_Result;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+\n+import static org.openjdk.jcstress.annotations.Expect.ACCEPTABLE;\n+import static org.openjdk.jcstress.annotations.Expect.FORBIDDEN;\n+\n+@JCStressTest\n+@Outcome(id = {\"0, 0\", \"1, 1\", \"0, 1\"}, expect = ACCEPTABLE, desc = \"Trivial\")\n+@Outcome(id = \"1, 0\",                   expect = FORBIDDEN,  desc = \"Cannot happen\")\n+@State\n+public class RMW_05_ReleaseOnSuccess {\n+\n+    \/*\n+        How to run this test:\n+            $ java -jar jcstress-samples\/target\/jcstress.jar -t RMW_05_ReleaseOnSuccess[.SubTestName]\n+     *\/\n+\n+    \/*\n+      ----------------------------------------------------------------------------------------------------------\n+\n+        This test shows that CAS provides \"release\" semantics on success. This is similar\n+        to other tests, for example BasicJMM_06_Causality: once we observe something\n+        \"release\"-d by another thread using any primitive with \"release\" semantics,\n+        by using any primitive with \"acquire\" semantics, we are guaranteed to see\n+        things that happened before that release.\n+\n+        Indeed, on both x86_64 and AArch64:\n+          RESULT      SAMPLES     FREQ      EXPECT  DESCRIPTION\n+            0, 0  138,542,022   42.99%  Acceptable  Trivial\n+            0, 1    3,232,097    1.00%  Acceptable  Trivial\n+            1, 0            0    0.00%   Forbidden  Cannot happen\n+            1, 1  180,464,345   56.00%  Acceptable  Trivial\n+     *\/\n+\n+    private int x, g;\n+    public static final VarHandle VH;\n+\n+    static {\n+        try {\n+            VH = MethodHandles.lookup().findVarHandle(RMW_05_ReleaseOnSuccess.class, \"g\", int.class);\n+        } catch (NoSuchFieldException | IllegalAccessException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    @Actor\n+    public void actor1(II_Result r) {\n+        x = 1;\n+        VH.compareAndSet(this, 0, 1); \/\/ always succeeds\n+    }\n+\n+    @Actor\n+    public void actor2(II_Result r) {\n+        r.r1 = (int)VH.getVolatile(this);\n+        r.r2 = x;\n+    }\n+\n+}\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/high\/rmw\/RMW_05_ReleaseOnSuccess.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jcstress.samples.high.rmw;\n+\n+import org.openjdk.jcstress.annotations.Actor;\n+import org.openjdk.jcstress.annotations.JCStressTest;\n+import org.openjdk.jcstress.annotations.Outcome;\n+import org.openjdk.jcstress.annotations.State;\n+import org.openjdk.jcstress.infra.results.II_Result;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+\n+import static org.openjdk.jcstress.annotations.Expect.*;\n+\n+@JCStressTest\n+@Outcome(id = {\"0, 0\", \"1, 1\", \"0, 1\"}, expect = ACCEPTABLE, desc = \"Trivial\")\n+@Outcome(id = \"1, 0\",                   expect = FORBIDDEN,  desc = \"Cannot happen\")\n+@State\n+public class RMW_06_AcquireOnFailure {\n+\n+    \/*\n+        How to run this test:\n+            $ java -jar jcstress-samples\/target\/jcstress.jar -t RMW_06_AcquireOnFailure[.SubTestName]\n+     *\/\n+\n+    \/*\n+      ----------------------------------------------------------------------------------------------------------\n+\n+        This test shows that even a failing CAS provides the \"acquire\" semantics:\n+        it still observes the value regardless of the subsequent CAS result.\n+\n+        x86_64, AArch64:\n+          RESULT      SAMPLES     FREQ      EXPECT  DESCRIPTION\n+            0, 0  146,825,939   44.46%  Acceptable  Trivial\n+            0, 1    4,112,904    1.25%  Acceptable  Trivial\n+            1, 0            0    0.00%   Forbidden  Cannot happen\n+            1, 1  179,276,581   54.29%  Acceptable  Trivial\n+     *\/\n+\n+    private int x, g;\n+    public static final VarHandle VH;\n+\n+    static {\n+        try {\n+            VH = MethodHandles.lookup().findVarHandle(RMW_06_AcquireOnFailure.class, \"g\", int.class);\n+        } catch (NoSuchFieldException | IllegalAccessException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    @Actor\n+    public void actor1(II_Result r) {\n+        x = 1;\n+        VH.setVolatile(this, 1);\n+    }\n+\n+    @Actor\n+    public void actor2(II_Result r) {\n+        \/\/ This CAS fails when it observes \"1\".\n+        \/\/ Ternary operator converts that failure to \"1\" explicitly.\n+        r.r1 = VH.compareAndSet(this, 0, 1) ? 0 : 1;\n+        r.r2 = x;\n+    }\n+\n+}\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/high\/rmw\/RMW_06_AcquireOnFailure.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jcstress.samples.high.rmw;\n+\n+import org.openjdk.jcstress.annotations.Actor;\n+import org.openjdk.jcstress.annotations.JCStressTest;\n+import org.openjdk.jcstress.annotations.Outcome;\n+import org.openjdk.jcstress.annotations.State;\n+import org.openjdk.jcstress.infra.results.II_Result;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+\n+import static org.openjdk.jcstress.annotations.Expect.ACCEPTABLE;\n+import static org.openjdk.jcstress.annotations.Expect.FORBIDDEN;\n+\n+@JCStressTest\n+@Outcome(id = {\"0, 0\", \"1, 1\", \"0, 1\"}, expect = ACCEPTABLE, desc = \"Trivial\")\n+@Outcome(id = {\"1, 0\", \"1, 1\"},         expect = FORBIDDEN,  desc = \"Cannot happen by construction\")\n+@State\n+public class RMW_07_ReleaseOnFailure {\n+\n+    \/*\n+        How to run this test:\n+            $ java -jar jcstress-samples\/target\/jcstress.jar -t RMW_07_ReleaseOnFailure[.SubTestName]\n+     *\/\n+\n+    \/*\n+      ----------------------------------------------------------------------------------------------------------\n+\n+        This test naively tries to show that a failing CAS does not provide \"release\" semantics.\n+        But there are no observable results, because failing CAS does not write anything.\n+        As far as reader side is concerned, no writes of \"g\" had been published.\n+\n+        x86_64, AArch64:\n+          RESULT      SAMPLES     FREQ      EXPECT  DESCRIPTION\n+            0, 0  161,650,705   52.25%  Acceptable  Trivial\n+            0, 1  147,757,039   47.75%  Acceptable  Trivial\n+            1, 0            0    0.00%   Forbidden  Cannot happen by construction\n+            1, 1            0    0.00%   Forbidden  Cannot happen by construction\n+     *\/\n+\n+    private int x, g;\n+    public static final VarHandle VH;\n+\n+    static {\n+        try {\n+            VH = MethodHandles.lookup().findVarHandle(RMW_07_ReleaseOnFailure.class, \"g\", int.class);\n+        } catch (NoSuchFieldException | IllegalAccessException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    @Actor\n+    public void actor1(II_Result r) {\n+        x = 1;\n+        \/\/ This CAS always fails: no release semantics.\n+        VH.compareAndSet(this, 1, 0);\n+    }\n+\n+    @Actor\n+    public void actor2(II_Result r) {\n+        r.r1 = (int)VH.getVolatile(this);\n+        r.r2 = x;\n+    }\n+\n+}\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/high\/rmw\/RMW_07_ReleaseOnFailure.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,315 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jcstress.samples.high.rmw;\n+\n+import org.openjdk.jcstress.annotations.Actor;\n+import org.openjdk.jcstress.annotations.JCStressTest;\n+import org.openjdk.jcstress.annotations.Outcome;\n+import org.openjdk.jcstress.annotations.State;\n+import org.openjdk.jcstress.infra.results.III_Result;\n+import org.openjdk.jcstress.infra.results.II_Result;\n+import org.openjdk.jcstress.infra.results.ZZ_Result;\n+import org.openjdk.jcstress.util.UnsafeHolder;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+\n+import static org.openjdk.jcstress.annotations.Expect.*;\n+\n+\n+public class RMW_08_GAS_Effects {\n+\n+    \/*\n+        How to run this test:\n+            $ java -jar jcstress-samples\/target\/jcstress.jar -t RMW_08_AtomicityEffects[.SubTestName]\n+     *\/\n+\n+    \/*\n+      ----------------------------------------------------------------------------------------------------------\n+\n+        This test construct a rather complicated example when the failing CAS semantics\n+        matters a bit, and why a stronger primitives might be needed. Since failing RMW\n+        operations do not produce observable writes, the tests are complicated, and have\n+        to test the memory semantics in a round-about way.\n+\n+        We shall build up the test case gradually. First, a very basic test.\n+\n+        This test produces (0, 0), and the justifying execution is:\n+\n+             w(x, 1) --po\/hb--> r(y):0\n+                                  |\n+                                  |  so (not sw)\n+                                  v\n+                                r(y):0 --po\/hb--> w(y, 1) --po\/hb --> r(x):0\n+\n+        In other words, this reads \"x\" through a race, and \"y\" has not been set yet.\n+\n+        Indeed, this is clearly visible on AArch64:\n+          RESULT     SAMPLES     FREQ       EXPECT  DESCRIPTION\n+            0, 0       4,930    0.02%  Interesting  Interesting\n+            0, 1  12,429,506   58.06%   Acceptable  Trivial\n+            1, 0   7,416,292   34.64%   Acceptable  Trivial\n+            1, 1   1,559,064    7.28%   Acceptable  Trivial\n+     *\/\n+\n+    @JCStressTest\n+    @Outcome(id = {\"0, 1\", \"1, 0\", \"1, 1\"}, expect = ACCEPTABLE,             desc = \"Trivial\")\n+    @Outcome(id = \"0, 0\",                   expect = ACCEPTABLE_INTERESTING, desc = \"Interesting\")\n+    @State\n+    public static class CTS_CTS {\n+        private int x;\n+        private volatile int y;\n+\n+        @Actor\n+        public void actor1(II_Result r) {\n+            x = 1;\n+            int t = y;\n+            if (t == 1) {\n+                y = 0;\n+            }\n+            r.r1 = t;\n+        }\n+\n+        @Actor\n+        public void actor2(II_Result r) {\n+            int t = y;\n+            if (t == 0) {\n+                y = 1;\n+            }\n+            r.r2 = x;\n+        }\n+    }\n+\n+    \/*\n+      ----------------------------------------------------------------------------------------------------------\n+\n+        Replacing both non-atomic checks with CAS yields the example that still produces\n+        (0, 0). The justifying execution for that outcome is:\n+\n+             w(x, 1) --po\/hb--> [ r(y):0; nothing happens ]\n+                                         |\n+                                         |  so (not sw)\n+                                         v\n+                                [ r(y):0; w(y, 1) ] --po\/hb --> r(x):0\n+\n+        ...where CAS actions are \"indivisible\" in \"[ ]\".\n+\n+        The fact these are atomic CASes changes nothing (yet): there is no store,\n+        and therefore no memory semantics can be assumed.\n+\n+        Indeed, this still happens on AArch64:\n+          RESULT     SAMPLES     FREQ       EXPECT  DESCRIPTION\n+            0, 0         868   <0.01%  Interesting  Interesting\n+            0, 1  13,122,195   63.29%   Acceptable  Trivial\n+            1, 0   6,171,450   29.76%   Acceptable  Trivial\n+            1, 1   1,439,439    6.94%   Acceptable  Trivial\n+     *\/\n+\n+    @JCStressTest\n+    @Outcome(id = {\"0, 1\", \"1, 0\", \"1, 1\"}, expect = ACCEPTABLE,             desc = \"Trivial\")\n+    @Outcome(id = \"0, 0\",                   expect = ACCEPTABLE_INTERESTING, desc = \"Interesting\")\n+    @State\n+    public static class CAS_CAS {\n+        public static final VarHandle VH_Y;\n+\n+        static {\n+            try {\n+                VH_Y = MethodHandles.lookup().findVarHandle(CAS_CAS.class, \"y\", int.class);\n+            } catch (NoSuchFieldException | IllegalAccessException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }\n+\n+        private int x;\n+        private volatile int y;\n+\n+        @Actor\n+        public void actor1(II_Result r) {\n+            x = 1;\n+            r.r1 = VH_Y.compareAndSet(this, 1, 0) ? 1 : 0;\n+        }\n+\n+        @Actor\n+        public void actor2(II_Result r) {\n+            VH_Y.compareAndSet(this, 0, 1);\n+            r.r2 = x;\n+        }\n+    }\n+\n+    \/*\n+      ----------------------------------------------------------------------------------------------------------\n+\n+        Doing the store to provide the release on one side still produces (0, 0),\n+        and the justifying execution is:\n+\n+        w(x,1) --po\/hb--> r(y):0 --po\/hb--> w(y,0)\n+                            |                 ^\n+                            | so              | so\n+                            v                 |\n+                        [ r(y):0     ;     w(y,1) ] --po\/hb--> r(x):0\n+\n+        It is similar as before, and the fact there is an unconditional volatile write\n+        changes nothing (yet).\n+\n+        Note that the order over \"y\" is still linearizable, as required for synchronization\n+        actions: r(y):0 --> r(y):0 --> w(y,1) --> w(y, 0).\n+\n+        Indeed, this is still possible on AArch64:\n+          RESULT     SAMPLES     FREQ       EXPECT  DESCRIPTION\n+            0, 0       2,087   <0.01%  Interesting  Interesting\n+            0, 1  11,400,418   52.20%   Acceptable  Trivial\n+            1, 0   9,820,853   44.97%   Acceptable  Trivial\n+            1, 1     616,514    2.82%   Acceptable  Trivial\n+     *\/\n+\n+    @JCStressTest\n+    @Outcome(id = {\"0, 1\", \"1, 0\", \"1, 1\"}, expect = ACCEPTABLE,             desc = \"Trivial\")\n+    @Outcome(id = \"0, 0\",                   expect = ACCEPTABLE_INTERESTING, desc = \"Interesting\")\n+    @State\n+    public static class GTS_CAS {\n+        public static final VarHandle VH_Y;\n+\n+        static {\n+            try {\n+                VH_Y = MethodHandles.lookup().findVarHandle(GTS_CAS.class, \"y\", int.class);\n+            } catch (NoSuchFieldException | IllegalAccessException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }\n+\n+        private int x;\n+        private volatile int y;\n+\n+        @Actor\n+        public void actor1(II_Result r) {\n+            x = 1;\n+            int t = y;\n+            y = 0;\n+            r.r1 = t;\n+        }\n+\n+        @Actor\n+        public void actor2(II_Result r) {\n+            VH_Y.compareAndSet(this, 0, 1);\n+            r.r2 = x;\n+        }\n+    }\n+\n+    \/*\n+      ----------------------------------------------------------------------------------------------------------\n+\n+        Now to the final test. This test cannot produce (0, 0), because it uses a much stronger\n+        primitive: Get-And-Set (GAS).\n+\n+        To reason whether we can produce (0, 0), we basically need to fill in the blanks\n+        in between the actions in GAS and CAS:\n+\n+        w(x,1) --po\/hb--> [ r(y):0 ; w(y,0) ]\n+\n+                               ????????\n+\n+                          [ r(y):0 ; w(y,1) ] --po\/hb--> r(x):0\n+\n+        The important thing is that both are *atomic*, which means we cannot split the\n+        first read-write pair like in the example before. Which means this execution\n+        is no longer valid:\n+\n+        w(x,1) --po\/hb--> [ r(y):0 ; w(y,0) ]\n+                              |         ^\n+                              | so      | so\n+                              v         |\n+                          [ r(y):0 ; w(y,1) ] --po\/hb--> r(x):0\n+\n+        The two valid executions are where both atomic groups are sequenced one after another.\n+        There are two such executions, and both executions are invalid.\n+\n+        This execution is invalid, because r(y):0 should have observed w(y,1), which\n+        fails synchronization order consistency.\n+\n+        w(x,1) --po\/hb--> [ r(y):0 ; w(y,0) ]\n+                              ^\n+                              \\---------\\\n+                                        |\n+                          [ r(y):0 ; w(y,1) ] --po\/hb--> r(x):0\n+\n+        This execution is invalid, because r(y) observes w(y), which means there\n+        is a synchronizes-with between them, which hooks w(x) and r(x), which\n+        fails happens-before consistency: r(x) should see 1.\n+\n+        w(x,1) --po\/hb--> [ r(y):0 ; w(y,0) ]\n+                                        |\n+                              \/--sw\/hb--\/\n+                              v\n+                          [ r(y):0 ; w(y,1) ] --po\/hb--> r(x):0\n+\n+        In the end, there is no execution that justifies (0, 0).\n+\n+        Note that it is an effect of all three:\n+          - GAS is being atomic;\n+          - GAS is carrying \"release\" semantics;\n+          - GAS is performing the unconditional store is detectable by CAS;\n+\n+        Previous examples show how failing any of these prerequisites exposes (0, 0).\n+\n+        Indeed, this does not happen on AArch64 anymore:\n+          RESULT    SAMPLES     FREQ      EXPECT  DESCRIPTION\n+            0, 0          0    0.00%   Forbidden  Nope\n+            0, 1  9,899,632   53.12%  Acceptable  Trivial\n+            1, 0  7,369,069   39.54%  Acceptable  Trivial\n+            1, 1  1,366,051    7.33%  Acceptable  Trivial\n+     *\/\n+\n+    @JCStressTest\n+    @Outcome(id = {\"0, 1\", \"1, 0\", \"1, 1\"}, expect = ACCEPTABLE, desc = \"Trivial\")\n+    @Outcome(id = \"0, 0\",                   expect = FORBIDDEN,  desc = \"Nope\")\n+    @State\n+    public static class GAS_CAS {\n+        public static final VarHandle VH_Y;\n+\n+        static {\n+            try {\n+                VH_Y = MethodHandles.lookup().findVarHandle(GAS_CAS.class, \"y\", int.class);\n+            } catch (NoSuchFieldException | IllegalAccessException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }\n+\n+        private int x;\n+        private volatile int y;\n+\n+        @Actor\n+        public void actor1(II_Result r) {\n+            x = 1;\n+            r.r1 = (int) VH_Y.getAndSet(this, 0);\n+        }\n+\n+        @Actor\n+        public void actor2(II_Result r) {\n+            VH_Y.compareAndSet(this, 0, 1);\n+            r.r2 = x;\n+        }\n+    }\n+\n+}\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/high\/rmw\/RMW_08_GAS_Effects.java","additions":315,"deletions":0,"binary":false,"changes":315,"status":"added"}]}