{"files":[{"patch":"@@ -49,3 +49,1 @@\n-        This test explores the behaviors of atomic RMW instructions.\n-\n-        A more advanced property of CASes:\n+        This tests explores a more advanced property of CASes:\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/high\/rmw\/RMW_02_ContendedSuccess.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -52,1 +52,4 @@\n-        This test explores the behaviors of atomic RMW instructions.\n+        This test shows that CAS provides \"acquire\" semantics on success. This is similar\n+        to other tests, for example BasicJMM_06_Causality: once we observe something\n+        \"release\"-d by another thread, using any primitive with \"acquire\" semantics,\n+        we are guaranteed to see things that happened before that release.\n@@ -54,3 +57,1 @@\n-        This shows that CAS provides \"acquire\" semantics on success.\n-\n-        x86_64, AArch64:\n+        Indeed, on both x86_64 and AArch64 this would happen:\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/high\/rmw\/RMW_04_AcquireOnSuccess.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -53,1 +53,5 @@\n-        This test explores the behaviors of atomic RMW instructions.\n+        This test shows that CAS provides \"release\" semantics on success. This is similar\n+        to other tests, for example BasicJMM_06_Causality: once we observe something\n+        \"release\"-d by another thread using any primitive with \"release\" semantics,\n+        by using any primitive with \"acquire\" semantics, we are guaranteed to see\n+        things that happened before that release.\n@@ -55,5 +59,1 @@\n-        This shows the important caveat about the notion of conflict. Even if there is an intervening\n-        write to the same variable _that keeps the value the same_, the CAS is still guaranteed\n-        to succeed.\n-\n-        x86_64, AArch64:\n+        Indeed, on both x86_64 and AArch64:\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/high\/rmw\/RMW_05_ReleaseOnSuccess.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -36,2 +36,1 @@\n-import static org.openjdk.jcstress.annotations.Expect.ACCEPTABLE;\n-import static org.openjdk.jcstress.annotations.Expect.FORBIDDEN;\n+import static org.openjdk.jcstress.annotations.Expect.*;\n@@ -53,1 +52,2 @@\n-        This test explores the behaviors of atomic RMW instructions.\n+        This test shows that even a failing CAS provides the \"acquire\" semantics:\n+        it still observes the value regardless of the subsequent CAS result.\n@@ -82,1 +82,3 @@\n-        r.r1 = VH.compareAndSet(this, 0, 1) ? 0 : 1; \/\/ fails if (g == 1)\n+        \/\/ This CAS fails when it observes \"1\".\n+        \/\/ Ternary operator converts that failure to \"1\" explicitly.\n+        r.r1 = VH.compareAndSet(this, 0, 1) ? 0 : 1;\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/high\/rmw\/RMW_06_AcquireOnFailure.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -53,1 +53,3 @@\n-        This test explores the behaviors of atomic RMW instructions.\n+        This test naively tries to show that a failing CAS does not provide \"release\" semantics.\n+        But there are no observable results, because failing CAS does not write anything.\n+        As far as reader side is concerned, no writes of \"g\" had been published.\n@@ -77,1 +79,2 @@\n-        VH.compareAndSet(this, 1, 0); \/\/ always fails\n+        \/\/ This CAS always fails: no release semantics.\n+        VH.compareAndSet(this, 1, 0);\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/high\/rmw\/RMW_07_ReleaseOnFailure.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,310 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.jcstress.samples.high.rmw;\n-\n-import org.openjdk.jcstress.annotations.Actor;\n-import org.openjdk.jcstress.annotations.JCStressTest;\n-import org.openjdk.jcstress.annotations.Outcome;\n-import org.openjdk.jcstress.annotations.State;\n-import org.openjdk.jcstress.infra.results.III_Result;\n-import org.openjdk.jcstress.infra.results.II_Result;\n-import org.openjdk.jcstress.infra.results.ZZ_Result;\n-import org.openjdk.jcstress.util.UnsafeHolder;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-\n-import static org.openjdk.jcstress.annotations.Expect.*;\n-\n-\n-public class RMW_08_AtomicityEffects {\n-\n-    \/*\n-        How to run this test:\n-            $ java -jar jcstress-samples\/target\/jcstress.jar -t RMW_08_AtomicBound[.SubTestName]\n-     *\/\n-\n-    \/*\n-      ----------------------------------------------------------------------------------------------------------\n-\n-        This test explores the behaviors of atomic RMW instructions. Since failing RMW operations do not\n-        produce observable writes, the tests are complicated, and have to test the memory semantics\n-        in a round-about way, gradually building up the test case.\n-\n-        First, a very basic test. This test produces (0, 0), and the justifying execution is:\n-\n-             w(x, 1) --po\/hb--> r(y):0\n-                                  |\n-                                  |  so (not sw)\n-                                  v\n-                                r(y):0 --po\/hb--> w(y, 1) --po\/hb --> r(x):0\n-\n-        In other words, this reads \"x\" through a race, and \"y\" has not been set yet.\n-\n-        Indeed, this is clearly visible on AArch64:\n-          RESULT     SAMPLES     FREQ       EXPECT  DESCRIPTION\n-            0, 0       4,930    0.02%  Interesting  Interesting\n-            0, 1  12,429,506   58.06%   Acceptable  Trivial\n-            1, 0   7,416,292   34.64%   Acceptable  Trivial\n-            1, 1   1,559,064    7.28%   Acceptable  Trivial\n-     *\/\n-\n-    @JCStressTest\n-    @Outcome(id = {\"0, 1\", \"1, 0\", \"1, 1\"}, expect = ACCEPTABLE,             desc = \"Trivial\")\n-    @Outcome(id = \"0, 0\",                   expect = ACCEPTABLE_INTERESTING, desc = \"Interesting\")\n-    @State\n-    public static class CTS_CTS {\n-        private int x;\n-        private volatile int y;\n-\n-        @Actor\n-        public void actor1(II_Result r) {\n-            x = 1;\n-            int t = y;\n-            if (t == 1) {\n-                y = 0;\n-            }\n-            r.r1 = t;\n-        }\n-\n-        @Actor\n-        public void actor2(II_Result r) {\n-            int t = y;\n-            if (t == 0) {\n-                y = 1;\n-            }\n-            r.r2 = x;\n-        }\n-    }\n-\n-    \/*\n-      ----------------------------------------------------------------------------------------------------------\n-\n-        Replacing both non-atomic checks with CAS yields the example that still produces\n-        (0, 0). The justifying execution for that outcome is:\n-\n-             w(x, 1) --po\/hb--> [ r(y):0; nothing happens ]\n-                                         |\n-                                         |  so (not sw)\n-                                         v\n-                                [ r(y):0; w(y, 1) ] --po\/hb --> r(x):0\n-\n-        ...where CAS actions are \"indivisible\" in \"[ ]\".\n-\n-        The fact these are atomic CASes changes nothing (yet).\n-\n-        AArch64:\n-          RESULT     SAMPLES     FREQ       EXPECT  DESCRIPTION\n-            0, 0         868   <0.01%  Interesting  Interesting\n-            0, 1  13,122,195   63.29%   Acceptable  Trivial\n-            1, 0   6,171,450   29.76%   Acceptable  Trivial\n-            1, 1   1,439,439    6.94%   Acceptable  Trivial\n-     *\/\n-\n-    @JCStressTest\n-    @Outcome(id = {\"0, 1\", \"1, 0\", \"1, 1\"}, expect = ACCEPTABLE,             desc = \"Trivial\")\n-    @Outcome(id = \"0, 0\",                   expect = ACCEPTABLE_INTERESTING, desc = \"Interesting\")\n-    @State\n-    public static class CAS_CAS {\n-        public static final VarHandle VH_Y;\n-\n-        static {\n-            try {\n-                VH_Y = MethodHandles.lookup().findVarHandle(CAS_CAS.class, \"y\", int.class);\n-            } catch (NoSuchFieldException | IllegalAccessException e) {\n-                throw new IllegalStateException(e);\n-            }\n-        }\n-\n-        private int x;\n-        private volatile int y;\n-\n-        @Actor\n-        public void actor1(II_Result r) {\n-            x = 1;\n-            r.r1 = VH_Y.compareAndSet(this, 1, 0) ? 1 : 0;\n-        }\n-\n-        @Actor\n-        public void actor2(II_Result r) {\n-            VH_Y.compareAndSet(this, 0, 1);\n-            r.r2 = x;\n-        }\n-    }\n-\n-    \/*\n-      ----------------------------------------------------------------------------------------------------------\n-\n-\n-\n-        This test produces (0, 0), and the justifying execution is:\n-\n-        w(x,1) --po\/hb--> r(y):0 --po\/hb--> w(y,0)\n-                            |                 ^\n-                            | so              | so\n-                            v                 |\n-                        [ r(y):0     ;     w(y,1) ] --po\/hb--> r(x):0\n-\n-        It is similar as before, and the fact there is an unconditional volatile write\n-        changes nothing (yet).\n-\n-        Note that the order over \"y\" is still linearizable, as required for synchronization\n-        actions: r(y):0 --> r(y):0 --> w(y,1) --> w(y, 0).\n-\n-        AArch64:\n-          RESULT     SAMPLES     FREQ       EXPECT  DESCRIPTION\n-            0, 0       2,087   <0.01%  Interesting  Interesting\n-            0, 1  11,400,418   52.20%   Acceptable  Trivial\n-            1, 0   9,820,853   44.97%   Acceptable  Trivial\n-            1, 1     616,514    2.82%   Acceptable  Trivial\n-     *\/\n-\n-    @JCStressTest\n-    @Outcome(id = {\"0, 1\", \"1, 0\", \"1, 1\"}, expect = ACCEPTABLE,             desc = \"Trivial\")\n-    @Outcome(id = \"0, 0\",                   expect = ACCEPTABLE_INTERESTING, desc = \"Interesting\")\n-    @State\n-    public static class GTS_CAS {\n-        public static final VarHandle VH_Y;\n-\n-        static {\n-            try {\n-                VH_Y = MethodHandles.lookup().findVarHandle(GTS_CAS.class, \"y\", int.class);\n-            } catch (NoSuchFieldException | IllegalAccessException e) {\n-                throw new IllegalStateException(e);\n-            }\n-        }\n-\n-        private int x;\n-        private volatile int y;\n-\n-        @Actor\n-        public void actor1(II_Result r) {\n-            x = 1;\n-            int t = y;\n-            y = 0;\n-            r.r1 = t;\n-        }\n-\n-        @Actor\n-        public void actor2(II_Result r) {\n-            VH_Y.compareAndSet(this, 0, 1);\n-            r.r2 = x;\n-        }\n-    }\n-\n-    \/*\n-      ----------------------------------------------------------------------------------------------------------\n-\n-        This test cannot produce (0, 0), because (drum roll, please). We basically need to\n-        fill in the blanks in between the actions in GAS and CAS:\n-\n-        w(x,1) --po\/hb--> [ r(y):0 ; w(y,0) ]\n-\n-                               ????????\n-\n-                          [ r(y):0 ; w(y,1) ] --po\/hb--> r(x):0\n-\n-        The important thing is that both are *atomic*, which means we cannot split the\n-        first read-write pair like in the example before. Which means this execution\n-        is no longer valid:\n-\n-        w(x,1) --po\/hb--> [ r(y):0 ; w(y,0) ]\n-                              |         ^\n-                              | so      | so\n-                              v         |\n-                          [ r(y):0 ; w(y,1) ] --po\/hb--> r(x):0\n-\n-        The two valid executions are where both atomic groups are sequenced one after another.\n-        There are two such executions, and both executions are invalid.\n-\n-        This execution is invalid, because r(y):0 should have observed w(y,1), which\n-        fails synchronization order consistency.\n-\n-        w(x,1) --po\/hb--> [ r(y):0 ; w(y,0) ]\n-                              ^\n-                              \\---------\\\n-                                        |\n-                          [ r(y):0 ; w(y,1) ] --po\/hb--> r(x):0\n-\n-\n-        This execution is invalid, because r(y) observes w(y), which means there\n-        is a synchronizes-with between them, which hooks w(x) and r(x), which\n-        fails happens-before consistency: r(x) should see 1.\n-\n-        w(x,1) --po\/hb--> [ r(y):0 ; w(y,0) ]\n-                                        |\n-                              \/--sw\/hb--\/\n-                              v\n-                          [ r(y):0 ; w(y,1) ] --po\/hb--> r(x):0\n-\n-        In the end, there is no execution that justifies (0, 0).\n-\n-        Note that it is an effect of all three:\n-          - GAS being atomic;\n-          - GAS carrying \"volatile\" semantics;\n-          - GAS performing the unconditional store that links the sw;\n-\n-        Previous examples show how failing any of these prerequisites exposes (0, 0).\n-\n-        AArch64:\n-          RESULT    SAMPLES     FREQ      EXPECT  DESCRIPTION\n-            0, 0          0    0.00%   Forbidden  Nope\n-            0, 1  9,899,632   53.12%  Acceptable  Trivial\n-            1, 0  7,369,069   39.54%  Acceptable  Trivial\n-            1, 1  1,366,051    7.33%  Acceptable  Trivial\n-     *\/\n-\n-    @JCStressTest\n-    @Outcome(id = {\"0, 1\", \"1, 0\", \"1, 1\"}, expect = ACCEPTABLE, desc = \"Trivial\")\n-    @Outcome(id = \"0, 0\",                   expect = FORBIDDEN,  desc = \"Nope\")\n-    @State\n-    public static class GAS_CAS {\n-        public static final VarHandle VH_Y;\n-\n-        static {\n-            try {\n-                VH_Y = MethodHandles.lookup().findVarHandle(GAS_CAS.class, \"y\", int.class);\n-            } catch (NoSuchFieldException | IllegalAccessException e) {\n-                throw new IllegalStateException(e);\n-            }\n-        }\n-\n-        private int x;\n-        private volatile int y;\n-\n-        @Actor\n-        public void actor1(II_Result r) {\n-            x = 1;\n-            r.r1 = (int) VH_Y.getAndSet(this, 0);\n-        }\n-\n-        @Actor\n-        public void actor2(II_Result r) {\n-            VH_Y.compareAndSet(this, 0, 1);\n-            r.r2 = x;\n-        }\n-    }\n-\n-}\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/high\/rmw\/RMW_08_AtomicityEffects.java","additions":0,"deletions":310,"binary":false,"changes":310,"status":"deleted"},{"patch":"@@ -0,0 +1,315 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jcstress.samples.high.rmw;\n+\n+import org.openjdk.jcstress.annotations.Actor;\n+import org.openjdk.jcstress.annotations.JCStressTest;\n+import org.openjdk.jcstress.annotations.Outcome;\n+import org.openjdk.jcstress.annotations.State;\n+import org.openjdk.jcstress.infra.results.III_Result;\n+import org.openjdk.jcstress.infra.results.II_Result;\n+import org.openjdk.jcstress.infra.results.ZZ_Result;\n+import org.openjdk.jcstress.util.UnsafeHolder;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+\n+import static org.openjdk.jcstress.annotations.Expect.*;\n+\n+\n+public class RMW_08_GAS_Effects {\n+\n+    \/*\n+        How to run this test:\n+            $ java -jar jcstress-samples\/target\/jcstress.jar -t RMW_08_AtomicityEffects[.SubTestName]\n+     *\/\n+\n+    \/*\n+      ----------------------------------------------------------------------------------------------------------\n+\n+        This test construct a rather complicated example when the failing CAS semantics\n+        matters a bit, and why a stronger primitives might be needed. Since failing RMW\n+        operations do not produce observable writes, the tests are complicated, and have\n+        to test the memory semantics in a round-about way.\n+\n+        We shall build up the test case gradually. First, a very basic test.\n+\n+        This test produces (0, 0), and the justifying execution is:\n+\n+             w(x, 1) --po\/hb--> r(y):0\n+                                  |\n+                                  |  so (not sw)\n+                                  v\n+                                r(y):0 --po\/hb--> w(y, 1) --po\/hb --> r(x):0\n+\n+        In other words, this reads \"x\" through a race, and \"y\" has not been set yet.\n+\n+        Indeed, this is clearly visible on AArch64:\n+          RESULT     SAMPLES     FREQ       EXPECT  DESCRIPTION\n+            0, 0       4,930    0.02%  Interesting  Interesting\n+            0, 1  12,429,506   58.06%   Acceptable  Trivial\n+            1, 0   7,416,292   34.64%   Acceptable  Trivial\n+            1, 1   1,559,064    7.28%   Acceptable  Trivial\n+     *\/\n+\n+    @JCStressTest\n+    @Outcome(id = {\"0, 1\", \"1, 0\", \"1, 1\"}, expect = ACCEPTABLE,             desc = \"Trivial\")\n+    @Outcome(id = \"0, 0\",                   expect = ACCEPTABLE_INTERESTING, desc = \"Interesting\")\n+    @State\n+    public static class CTS_CTS {\n+        private int x;\n+        private volatile int y;\n+\n+        @Actor\n+        public void actor1(II_Result r) {\n+            x = 1;\n+            int t = y;\n+            if (t == 1) {\n+                y = 0;\n+            }\n+            r.r1 = t;\n+        }\n+\n+        @Actor\n+        public void actor2(II_Result r) {\n+            int t = y;\n+            if (t == 0) {\n+                y = 1;\n+            }\n+            r.r2 = x;\n+        }\n+    }\n+\n+    \/*\n+      ----------------------------------------------------------------------------------------------------------\n+\n+        Replacing both non-atomic checks with CAS yields the example that still produces\n+        (0, 0). The justifying execution for that outcome is:\n+\n+             w(x, 1) --po\/hb--> [ r(y):0; nothing happens ]\n+                                         |\n+                                         |  so (not sw)\n+                                         v\n+                                [ r(y):0; w(y, 1) ] --po\/hb --> r(x):0\n+\n+        ...where CAS actions are \"indivisible\" in \"[ ]\".\n+\n+        The fact these are atomic CASes changes nothing (yet): there is no store,\n+        and therefore no memory semantics can be assumed.\n+\n+        Indeed, this still happens on AArch64:\n+          RESULT     SAMPLES     FREQ       EXPECT  DESCRIPTION\n+            0, 0         868   <0.01%  Interesting  Interesting\n+            0, 1  13,122,195   63.29%   Acceptable  Trivial\n+            1, 0   6,171,450   29.76%   Acceptable  Trivial\n+            1, 1   1,439,439    6.94%   Acceptable  Trivial\n+     *\/\n+\n+    @JCStressTest\n+    @Outcome(id = {\"0, 1\", \"1, 0\", \"1, 1\"}, expect = ACCEPTABLE,             desc = \"Trivial\")\n+    @Outcome(id = \"0, 0\",                   expect = ACCEPTABLE_INTERESTING, desc = \"Interesting\")\n+    @State\n+    public static class CAS_CAS {\n+        public static final VarHandle VH_Y;\n+\n+        static {\n+            try {\n+                VH_Y = MethodHandles.lookup().findVarHandle(CAS_CAS.class, \"y\", int.class);\n+            } catch (NoSuchFieldException | IllegalAccessException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }\n+\n+        private int x;\n+        private volatile int y;\n+\n+        @Actor\n+        public void actor1(II_Result r) {\n+            x = 1;\n+            r.r1 = VH_Y.compareAndSet(this, 1, 0) ? 1 : 0;\n+        }\n+\n+        @Actor\n+        public void actor2(II_Result r) {\n+            VH_Y.compareAndSet(this, 0, 1);\n+            r.r2 = x;\n+        }\n+    }\n+\n+    \/*\n+      ----------------------------------------------------------------------------------------------------------\n+\n+        Doing the store to provide the release on one side still produces (0, 0),\n+        and the justifying execution is:\n+\n+        w(x,1) --po\/hb--> r(y):0 --po\/hb--> w(y,0)\n+                            |                 ^\n+                            | so              | so\n+                            v                 |\n+                        [ r(y):0     ;     w(y,1) ] --po\/hb--> r(x):0\n+\n+        It is similar as before, and the fact there is an unconditional volatile write\n+        changes nothing (yet).\n+\n+        Note that the order over \"y\" is still linearizable, as required for synchronization\n+        actions: r(y):0 --> r(y):0 --> w(y,1) --> w(y, 0).\n+\n+        Indeed, this is still possible on AArch64:\n+          RESULT     SAMPLES     FREQ       EXPECT  DESCRIPTION\n+            0, 0       2,087   <0.01%  Interesting  Interesting\n+            0, 1  11,400,418   52.20%   Acceptable  Trivial\n+            1, 0   9,820,853   44.97%   Acceptable  Trivial\n+            1, 1     616,514    2.82%   Acceptable  Trivial\n+     *\/\n+\n+    @JCStressTest\n+    @Outcome(id = {\"0, 1\", \"1, 0\", \"1, 1\"}, expect = ACCEPTABLE,             desc = \"Trivial\")\n+    @Outcome(id = \"0, 0\",                   expect = ACCEPTABLE_INTERESTING, desc = \"Interesting\")\n+    @State\n+    public static class GTS_CAS {\n+        public static final VarHandle VH_Y;\n+\n+        static {\n+            try {\n+                VH_Y = MethodHandles.lookup().findVarHandle(GTS_CAS.class, \"y\", int.class);\n+            } catch (NoSuchFieldException | IllegalAccessException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }\n+\n+        private int x;\n+        private volatile int y;\n+\n+        @Actor\n+        public void actor1(II_Result r) {\n+            x = 1;\n+            int t = y;\n+            y = 0;\n+            r.r1 = t;\n+        }\n+\n+        @Actor\n+        public void actor2(II_Result r) {\n+            VH_Y.compareAndSet(this, 0, 1);\n+            r.r2 = x;\n+        }\n+    }\n+\n+    \/*\n+      ----------------------------------------------------------------------------------------------------------\n+\n+        Now to the final test. This test cannot produce (0, 0), because it uses a much stronger\n+        primitive: Get-And-Set (GAS).\n+\n+        To reason whether we can produce (0, 0), we basically need to fill in the blanks\n+        in between the actions in GAS and CAS:\n+\n+        w(x,1) --po\/hb--> [ r(y):0 ; w(y,0) ]\n+\n+                               ????????\n+\n+                          [ r(y):0 ; w(y,1) ] --po\/hb--> r(x):0\n+\n+        The important thing is that both are *atomic*, which means we cannot split the\n+        first read-write pair like in the example before. Which means this execution\n+        is no longer valid:\n+\n+        w(x,1) --po\/hb--> [ r(y):0 ; w(y,0) ]\n+                              |         ^\n+                              | so      | so\n+                              v         |\n+                          [ r(y):0 ; w(y,1) ] --po\/hb--> r(x):0\n+\n+        The two valid executions are where both atomic groups are sequenced one after another.\n+        There are two such executions, and both executions are invalid.\n+\n+        This execution is invalid, because r(y):0 should have observed w(y,1), which\n+        fails synchronization order consistency.\n+\n+        w(x,1) --po\/hb--> [ r(y):0 ; w(y,0) ]\n+                              ^\n+                              \\---------\\\n+                                        |\n+                          [ r(y):0 ; w(y,1) ] --po\/hb--> r(x):0\n+\n+        This execution is invalid, because r(y) observes w(y), which means there\n+        is a synchronizes-with between them, which hooks w(x) and r(x), which\n+        fails happens-before consistency: r(x) should see 1.\n+\n+        w(x,1) --po\/hb--> [ r(y):0 ; w(y,0) ]\n+                                        |\n+                              \/--sw\/hb--\/\n+                              v\n+                          [ r(y):0 ; w(y,1) ] --po\/hb--> r(x):0\n+\n+        In the end, there is no execution that justifies (0, 0).\n+\n+        Note that it is an effect of all three:\n+          - GAS is being atomic;\n+          - GAS is carrying \"release\" semantics;\n+          - GAS is performing the unconditional store is detectable by CAS;\n+\n+        Previous examples show how failing any of these prerequisites exposes (0, 0).\n+\n+        Indeed, this does not happen on AArch64 anymore:\n+          RESULT    SAMPLES     FREQ      EXPECT  DESCRIPTION\n+            0, 0          0    0.00%   Forbidden  Nope\n+            0, 1  9,899,632   53.12%  Acceptable  Trivial\n+            1, 0  7,369,069   39.54%  Acceptable  Trivial\n+            1, 1  1,366,051    7.33%  Acceptable  Trivial\n+     *\/\n+\n+    @JCStressTest\n+    @Outcome(id = {\"0, 1\", \"1, 0\", \"1, 1\"}, expect = ACCEPTABLE, desc = \"Trivial\")\n+    @Outcome(id = \"0, 0\",                   expect = FORBIDDEN,  desc = \"Nope\")\n+    @State\n+    public static class GAS_CAS {\n+        public static final VarHandle VH_Y;\n+\n+        static {\n+            try {\n+                VH_Y = MethodHandles.lookup().findVarHandle(GAS_CAS.class, \"y\", int.class);\n+            } catch (NoSuchFieldException | IllegalAccessException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }\n+\n+        private int x;\n+        private volatile int y;\n+\n+        @Actor\n+        public void actor1(II_Result r) {\n+            x = 1;\n+            r.r1 = (int) VH_Y.getAndSet(this, 0);\n+        }\n+\n+        @Actor\n+        public void actor2(II_Result r) {\n+            VH_Y.compareAndSet(this, 0, 1);\n+            r.r2 = x;\n+        }\n+    }\n+\n+}\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/high\/rmw\/RMW_08_GAS_Effects.java","additions":315,"deletions":0,"binary":false,"changes":315,"status":"added"}]}