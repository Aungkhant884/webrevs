{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import org.openjdk.jcstress.infra.runners.VoidThread;\n@@ -36,4 +37,0 @@\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.ThreadFactory;\n-import java.util.concurrent.atomic.AtomicInteger;\n@@ -53,2 +50,0 @@\n-        ExecutorService pool = Executors.newCachedThreadPool(new MyThreadFactory());\n-\n@@ -58,2 +53,1 @@\n-        pool.submit(new WarmupAffinityTask());\n-        pool.submit(new EmptyTask());\n+        new WarmupAffinityTask().start();\n@@ -74,2 +68,2 @@\n-            Constructor<?> cnstr = aClass.getConstructor(ForkedTestConfig.class, ExecutorService.class);\n-            Runner<?> o = (Runner<?>) cnstr.newInstance(config, pool);\n+            Constructor<?> cnstr = aClass.getConstructor(ForkedTestConfig.class);\n+            Runner<?> o = (Runner<?>) cnstr.newInstance(config);\n@@ -97,3 +91,1 @@\n-    private static class MyThreadFactory implements ThreadFactory {\n-        private final AtomicInteger id = new AtomicInteger();\n-\n+    private static class WarmupAffinityTask extends VoidThread {\n@@ -101,11 +93,1 @@\n-        public Thread newThread(Runnable r) {\n-            Thread t = new Thread(r);\n-            t.setName(\"jcstress-worker-\" + id.incrementAndGet());\n-            t.setDaemon(true);\n-            return t;\n-        }\n-    }\n-\n-    private static class WarmupAffinityTask implements Runnable {\n-        @Override\n-        public void run() {\n+        protected void internalRun() {\n@@ -120,6 +102,0 @@\n-    private static class EmptyTask implements Runnable {\n-        @Override\n-        public void run() {\n-            \/\/ Do nothing\n-        }\n-    }\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/ForkedMain.java","additions":6,"deletions":30,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -333,2 +333,2 @@\n-        pw.println(\"    public \" + className + \"(ForkedTestConfig config, ExecutorService pool) {\");\n-        pw.println(\"        super(config, pool);\");\n+        pw.println(\"    public \" + className + \"(ForkedTestConfig config) {\");\n+        pw.println(\"        super(config);\");\n@@ -354,1 +354,1 @@\n-            pw.println(\"        Future<?> a\" + a + \" = pool.submit(new Callable<Object>() { public Object call() {\");\n+            pw.println(\"        VoidThread a\" + a + \" = new VoidThread() { protected void internalRun() {\");\n@@ -358,2 +358,5 @@\n-            pw.println(\"            return null;\");\n-            pw.println(\"        }});\");\n+            pw.println(\"        }};\");\n+        }\n+\n+        for (int a = 0; a < actorsCount; a++) {\n+            pw.println(\"        a\" + a + \".start();\");\n@@ -363,4 +366,3 @@\n-            pw.println(\"        try {\");\n-            pw.println(\"            a\" + a + \".get();\");\n-            pw.println(\"        } catch (ExecutionException e) {\");\n-            pw.println(\"            throw e.getCause();\");\n+            pw.println(\"        a\" + a + \".join();\");\n+            pw.println(\"        if (a\" + a + \".throwable() != null) {\");\n+            pw.println(\"            throw a\" + a + \".throwable();\");\n@@ -371,3 +373,1 @@\n-            pw.println(\"        try {\");\n-            pw.println(\"            pool.submit(new Callable<Object>() { public Object call() {\");\n-            pw.print(\"                \");\n+            pw.print(\"            \");\n@@ -376,5 +376,0 @@\n-            pw.println(\"                return null;\");\n-            pw.println(\"            }}).get();\");\n-            pw.println(\"        } catch (ExecutionException e) {\");\n-            pw.println(\"            throw e.getCause();\");\n-            pw.println(\"        }\");\n@@ -407,1 +402,1 @@\n-            pw.println(\"            Future<Long> a\" + a + \" = pool.submit(new Callable<Long>() { public Long call() {\");\n+            pw.println(\"            LongThread a\" + a + \" = new LongThread() { public long internalRun() {\");\n@@ -416,1 +411,5 @@\n-            pw.println(\"            }});\");\n+            pw.println(\"            }};\");\n+        }\n+\n+        for (int a = 0; a < actorsCount; a++) {\n+            pw.println(\"            a\" + a + \".start();\");\n@@ -421,3 +420,3 @@\n-            pw.println(\"                cnts[0] += a\" + a + \".get();\");\n-            pw.println(\"            } catch (Throwable e) {\");\n-            pw.println(\"                \/\/ Should not happen, checked in API check\");\n+            pw.println(\"                a\" + a + \".join();\");\n+            pw.println(\"                cnts[0] += a\" + a + \".result();\");\n+            pw.println(\"            } catch (InterruptedException e) {\");\n@@ -428,5 +427,2 @@\n-            pw.println(\"            try {\");\n-            pw.println(\"                long a = pool.submit(new Callable<Long>() { public Long call() {\");\n-            pw.println(\"                    long a1 = AllocProfileSupport.getAllocatedBytes();\");\n-            pw.println(\"                    for (int c = 0; c < size; c++) {\");\n-            pw.print(\"                        \");\n+            pw.println(\"            for (int c = 0; c < size; c++) {\");\n+            pw.print(\"                \");\n@@ -435,7 +431,0 @@\n-            pw.println(\"                    }\");\n-            pw.println(\"                    long a2 = AllocProfileSupport.getAllocatedBytes();\");\n-            pw.println(\"                    return a2 - a1;\");\n-            pw.println(\"                }}).get();\");\n-            pw.println(\"                cnts[0] += a;\");\n-            pw.println(\"            } catch (Throwable e) {\");\n-            pw.println(\"                \/\/ Should not happen, checked in API check\");\n@@ -457,1 +446,1 @@\n-        pw.println(\"    public ArrayList<Future<Counter<\" + r + \">>> internalRun() {\");\n+        pw.println(\"    public ArrayList<CounterThread<\" + r + \">> internalRun() {\");\n@@ -471,1 +460,1 @@\n-        pw.println(\"        ArrayList<Future<Counter<\" + r + \">>> results = new ArrayList<>(\" + actorsCount + \");\");\n+        pw.println(\"        ArrayList<CounterThread<\" + r + \">> threads = new ArrayList<>(\" + actorsCount + \");\");\n@@ -473,1 +462,1 @@\n-            pw.println(\"        results.add(pool.submit(new Callable<Counter<\" + r + \">>() { public Counter<\" + r + \"> call() {\");\n+            pw.println(\"        threads.add(new CounterThread<\" + r + \">() { public Counter<\" + r + \"> internalRun() {\");\n@@ -475,1 +464,1 @@\n-            pw.println(\"        }}));\");\n+            pw.println(\"        }});\");\n@@ -478,0 +467,4 @@\n+        pw.println(\"        for (CounterThread t : threads) {\");\n+        pw.println(\"            t.start();\");\n+        pw.println(\"        }\");\n+        pw.println();\n@@ -487,1 +480,1 @@\n-        pw.println(\"        return results;\");\n+        pw.println(\"        return threads;\");\n@@ -774,2 +767,2 @@\n-        pw.println(\"    public \" + generatedName + \"(ForkedTestConfig config, ExecutorService pool) {\");\n-        pw.println(\"        super(config, pool);\");\n+        pw.println(\"    public \" + generatedName + \"(ForkedTestConfig config) {\");\n+        pw.println(\"        super(config);\");\n@@ -801,1 +794,1 @@\n-        pw.println(\"    public ArrayList<Future<Counter<Outcome>>> internalRun() {\");\n+        pw.println(\"    public ArrayList<CounterThread<Outcome>> internalRun() {\");\n@@ -952,1 +945,1 @@\n-                ExecutorService.class, Future.class, TimeUnit.class,\n+                TimeUnit.class,\n@@ -955,2 +948,0 @@\n-                ExecutionException.class,\n-                Callable.class,\n@@ -959,0 +950,1 @@\n+                VoidThread.class, LongThread.class, CounterThread.class\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/infra\/processors\/JCStressTestProcessor.java","additions":37,"deletions":45,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jcstress.infra.runners;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+public class AbstractThread extends Thread {\n+    private static final AtomicInteger ID = new AtomicInteger();\n+\n+    protected volatile Throwable throwable;\n+\n+    public AbstractThread() {\n+        setDaemon(true);\n+        setName(\"jcstress-worker-\" + ID.incrementAndGet());\n+    }\n+\n+    public Throwable throwable() { return throwable; }\n+\n+}\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/infra\/runners\/AbstractThread.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jcstress.infra.runners;\n+\n+import org.openjdk.jcstress.util.Counter;\n+\n+public abstract class CounterThread<R> extends AbstractThread {\n+    private Counter<R> result;\n+    public Counter<R> result() {\n+        return result;\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            result = internalRun();\n+        } catch (Throwable e) {\n+            throwable = e;\n+        }\n+    }\n+\n+    protected abstract Counter<R> internalRun();\n+}\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/infra\/runners\/CounterThread.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jcstress.infra.runners;\n+\n+public abstract class LongThread extends AbstractThread {\n+    private long result;\n+    public long result() {\n+        return result;\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            result = internalRun();\n+        } catch (Throwable e) {\n+            throwable = e;\n+        }\n+    }\n+\n+    protected abstract long internalRun();\n+\n+}\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/infra\/runners\/LongThread.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -48,1 +48,0 @@\n-    protected final ExecutorService pool;\n@@ -52,2 +51,1 @@\n-    public Runner(ForkedTestConfig config, ExecutorService pool) {\n-        this.pool = pool;\n+    public Runner(ForkedTestConfig config) {\n@@ -74,1 +72,1 @@\n-            ArrayList<Future<Counter<R>>> futures = internalRun();\n+            ArrayList<CounterThread<R>> workers = internalRun();\n@@ -78,2 +76,2 @@\n-                ArrayList<Future<Counter<R>>> leftovers = new ArrayList<>();\n-                for (Future<Counter<R>> t : futures) {\n+                ArrayList<CounterThread<R>> leftovers = new ArrayList<>();\n+                for (CounterThread<R> t : workers) {\n@@ -81,4 +79,12 @@\n-                        result.merge(t.get(1, TimeUnit.SECONDS));\n-                    } catch (TimeoutException e) {\n-                        leftovers.add(t);\n-                    } catch (ExecutionException | InterruptedException e) {\n+                        t.join(1000);\n+\n+                        if (t.throwable() != null) {\n+                            return dumpFailure(Status.TEST_ERROR, \"Unrecoverable error while running\", t.throwable());\n+                        }\n+                        Counter<R> res = t.result();\n+                        if (res != null) {\n+                            result.merge(res);\n+                        } else {\n+                            leftovers.add(t);\n+                        }\n+                    } catch (InterruptedException e) {\n@@ -95,2 +101,2 @@\n-                futures = leftovers;\n-            } while (!futures.isEmpty());\n+                workers = leftovers;\n+            } while (!workers.isEmpty());\n@@ -129,1 +135,1 @@\n-    public abstract ArrayList<Future<Counter<R>>> internalRun();\n+    public abstract ArrayList<CounterThread<R>> internalRun();\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/infra\/runners\/Runner.java","additions":19,"deletions":13,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jcstress.infra.runners;\n+\n+public abstract class VoidThread extends AbstractThread {\n+    @Override\n+    public void run() {\n+        try {\n+            internalRun();\n+        } catch (Throwable e) {\n+            throwable = e;\n+        }\n+    }\n+\n+    protected abstract void internalRun();\n+}\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/infra\/runners\/VoidThread.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"}]}