{"files":[{"patch":"@@ -60,1 +60,1 @@\n-        TestConfig cfg = new TestConfig(opts, ti, TestConfig.RunMode.EMBEDDED, 1, Collections.emptyList());\n+        TestConfig cfg = new TestConfig(opts, ti, TestConfig.RunMode.EMBEDDED, 1, Collections.emptyList(), CompileMode.UNIFIED);\n","filename":"jcstress-benchmarks\/src\/main\/java\/org\/openjdk\/jcstress\/SampleTestBench.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jcstress;\n+\n+import java.util.List;\n+\n+public class CompileMode {\n+\n+    public static final int VARIANTS = 3;\n+    public static final int UNIFIED = -1;\n+\n+    private final int mode;\n+    private final List<String> actorNames;\n+    private final int actors;\n+\n+    public CompileMode(int mode, List<String> actorNames, int actors) {\n+        this.mode = mode;\n+        this.actorNames = actorNames;\n+        this.actors = actors;\n+    }\n+\n+    public static int casesFor(int actors) {\n+        int cases = 1;\n+        for (int c = 0; c < actors; c++) {\n+            cases *= VARIANTS;\n+        }\n+        return cases;\n+    }\n+\n+    private int actorMode(int actor) {\n+        int m = mode;\n+        for (int a = 0; a < actor; a++) {\n+            m \/= VARIANTS;\n+        }\n+        return m % VARIANTS;\n+    }\n+\n+    public boolean isInt(int actor) {\n+        return (mode != UNIFIED) && (actorMode(actor) == 0);\n+    }\n+\n+    public boolean isC1(int actor) {\n+        return (mode != UNIFIED) && (actorMode(actor) == 1);\n+    }\n+\n+    public boolean isC2(int actor) {\n+        return (mode != UNIFIED) && (actorMode(actor) == 2);\n+    }\n+\n+    public boolean hasC2() {\n+        if (mode == UNIFIED) {\n+            return true;\n+        }\n+        for (int a = 0; a < actors; a++) {\n+            if (isC2(a)) return true;\n+        }\n+        return false;\n+    }\n+\n+    private String actorModeToString(int actor) {\n+        int v = actorMode(actor);\n+        switch (v) {\n+            case 0: return \"Interpreter\";\n+            case 1: return \"C1\";\n+            case 2: return \"C2\";\n+            default:\n+                throw new IllegalStateException(\"Unhandled variant: \" + v);\n+        }\n+    }\n+\n+    public String toString() {\n+        if (mode == UNIFIED) {\n+            return \"unified across all actors\";\n+        }\n+\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"split; \");\n+        for (int a = 0; a < actors; a++) {\n+            if (a != 0) {\n+                sb.append(\", \");\n+            }\n+            sb.append(\"\\\"\");\n+            sb.append(actorNames.get(a));\n+            sb.append(\"\\\"\");\n+            sb.append(\": \");\n+            sb.append(actorModeToString(a));\n+        }\n+        return sb.toString();\n+    }\n+\n+\n+}\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/CompileMode.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -39,1 +39,0 @@\n-import java.lang.management.ManagementFactory;\n@@ -62,3 +61,3 @@\n-        VMSupport.detectAvailableVMModes(opts.getJvmArgs(), opts.getJvmArgsPrepend());\n-        if (VMSupport.getAvailableVMModes().isEmpty()) {\n-            out.println(\"FATAL: No JVM modes to run with.\");\n+        VMSupport.detectAvailableVMConfigs(opts.isSplitCompilation(), opts.getJvmArgs(), opts.getJvmArgsPrepend());\n+        if (VMSupport.getAvailableVMConfigs().isEmpty()) {\n+            out.println(\"FATAL: No JVM configurations to run with.\");\n@@ -117,8 +116,20 @@\n-            List<String> inputArgs = ManagementFactory.getRuntimeMXBean().getInputArguments();\n-            for (String test : tests) {\n-                for (Collection<String> jvmArgs : VMSupport.getAvailableVMModes()) {\n-                    List<String> fullArgs = new ArrayList<>();\n-                    fullArgs.addAll(inputArgs);\n-                    fullArgs.addAll(jvmArgs);\n-                    for (int f = 0; f < opts.getForks(); f++) {\n-                        configs.add(new TestConfig(opts, TestList.getInfo(test), TestConfig.RunMode.FORKED, f, fullArgs));\n+            for (VMSupport.Config config : VMSupport.getAvailableVMConfigs()) {\n+                for (String test : tests) {\n+                    TestInfo info = TestList.getInfo(test);\n+                    if (opts.isSplitCompilation() && VMSupport.compilerDirectivesAvailable()) {\n+                        for (int cc = 0; cc < CompileMode.casesFor(info.threads()); cc++) {\n+                            CompileMode cm = new CompileMode(cc, info.actorNames(), info.threads());\n+                            if (config.onlyIfC2() && !cm.hasC2()) {\n+                                \/\/ This configuration is expected to run only when C2 is enabled,\n+                                \/\/ but compilation mode does not include C2. Can skip it to optimize\n+                                \/\/ testing time.\n+                                continue;\n+                            }\n+                            for (int f = 0; f < opts.getForks(); f++) {\n+                                configs.add(new TestConfig(opts, info, TestConfig.RunMode.FORKED, f, config.args(), cc));\n+                            }\n+                        }\n+                    } else {\n+                        for (int f = 0; f < opts.getForks(); f++) {\n+                            configs.add(new TestConfig(opts, info, TestConfig.RunMode.FORKED, f, config.args(), CompileMode.UNIFIED));\n+                        }\n@@ -132,1 +143,1 @@\n-                configs.add(new TestConfig(opts, info, mode, -1, Collections.emptyList()));\n+                configs.add(new TestConfig(opts, info, mode, -1, Collections.emptyList(), CompileMode.UNIFIED));\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/JCStress.java","additions":24,"deletions":13,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -40,4 +40,1 @@\n-import java.util.Collection;\n-import java.util.Date;\n-import java.util.List;\n-import java.util.Locale;\n+import java.util.*;\n@@ -67,2 +64,3 @@\n-    private Collection<String> jvmArgs;\n-    private Collection<String> jvmArgsPrepend;\n+    private List<String> jvmArgs;\n+    private List<String> jvmArgsPrepend;\n+    private boolean splitCompilation;\n@@ -138,0 +136,3 @@\n+        OptionSpec<Boolean> optSplitCompilation = parser.accepts(\"sc\", \"Use split per-actor compilation mode, if available.\")\n+                .withOptionalArg().ofType(Boolean.class).describedAs(\"bool\");\n+\n@@ -243,0 +244,2 @@\n+        this.splitCompilation = orDefault(set.valueOf(optSplitCompilation), true);\n+\n@@ -246,1 +249,1 @@\n-    private Collection<String> processArgs(OptionSpec<String> op, OptionSet set) {\n+    private List<String> processArgs(OptionSpec<String> op, OptionSet set) {\n@@ -259,1 +262,1 @@\n-            return null;\n+            return Collections.emptyList();\n@@ -351,1 +354,1 @@\n-    public Collection<String> getJvmArgs() {\n+    public List<String> getJvmArgs() {\n@@ -355,1 +358,1 @@\n-    public Collection<String> getJvmArgsPrepend() {\n+    public List<String> getJvmArgsPrepend() {\n@@ -368,0 +371,3 @@\n+    public boolean isSplitCompilation() {\n+        return splitCompilation;\n+    }\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/Options.java","additions":16,"deletions":10,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -177,4 +177,28 @@\n-        void generateDirectives() {\n-            try {\n-                PrintWriter pw = new PrintWriter(compilerDirectives);\n-                pw.println(\"[\");\n+        void generateDirectives() throws IOException {\n+            PrintWriter pw = new PrintWriter(compilerDirectives);\n+            pw.println(\"[\");\n+\n+            \/\/ The task loop:\n+            pw.println(\"  {\");\n+            pw.println(\"    match: \\\"\" + task.generatedRunnerName + \"::\" + JCStressTestProcessor.TASK_LOOP_PREFIX + \"*\\\",\");\n+\n+            \/\/ Avoid inlining the run loop, it should be compiled as separate hot code\n+            pw.println(\"    inline: \\\"-\" + task.generatedRunnerName + \"::\" + JCStressTestProcessor.RUN_LOOP_PREFIX + \"*\\\",\");\n+\n+            \/\/ Force inline the auxiliary methods and classes in the run loop\n+            pw.println(\"    inline: \\\"+\" + task.generatedRunnerName + \"::\" + JCStressTestProcessor.AUX_PREFIX + \"*\\\",\");\n+            pw.println(\"    inline: \\\"+\" + WorkerSync.class.getName() + \"::*\\\",\");\n+            pw.println(\"    inline: \\\"+java.util.concurrent.atomic.*::*\\\",\");\n+            pw.println(\"  },\");\n+\n+            \/\/ Force inline everything from WorkerSync. WorkerSync does not use anything\n+            \/\/ too deeply, so inlining everything is fine.\n+            pw.println(\"  {\");\n+            pw.println(\"    match: \\\"\" + WorkerSync.class.getName() + \"::*\" + \"\\\",\");\n+            pw.println(\"    inline: \\\"+*::*\\\",\");\n+            pw.println(\"  },\");\n+\n+            \/\/ The run loops:\n+            CompileMode cm = task.getCompileMode();\n+            for (int a = 0; a < task.threads; a++) {\n+                String an = task.actorNames.get(a);\n@@ -182,3 +206,0 @@\n-                \/\/ The task loop:\n-                \/\/   - avoid inlining the run loop, it should be compiled as hot code\n-                \/\/   - force inline the auxiliary methods and classes in the run loop\n@@ -186,2 +207,1 @@\n-                pw.println(\"    match: \\\"\" + task.generatedRunnerName + \"::\" + JCStressTestProcessor.TASK_LOOP_PREFIX + \"*\\\",\");\n-                pw.println(\"    inline: \\\"-\" + task.generatedRunnerName + \"::\" + JCStressTestProcessor.RUN_LOOP_PREFIX + \"*\\\",\");\n+                pw.println(\"    match: \\\"\" + task.generatedRunnerName + \"::\" + JCStressTestProcessor.RUN_LOOP_PREFIX + an + \"\\\",\");\n@@ -189,3 +209,0 @@\n-                pw.println(\"    inline: \\\"+\" + WorkerSync.class.getName() + \"::*\\\",\");\n-                pw.println(\"    inline: \\\"+java.util.concurrent.atomic.*::*\\\",\");\n-                pw.println(\"  },\");\n@@ -193,5 +210,27 @@\n-                \/\/ Force inline everything from WorkerSync. WorkerSync does not use anything\n-                \/\/ too deeply, so inlining everything is fine.\n-                pw.println(\"  {\");\n-                pw.println(\"    match: \\\"\" + WorkerSync.class.getName() + \"::*\" + \"\\\",\");\n-                pw.println(\"    inline: \\\"+*::*\\\",\");\n+                \/\/ Force inline of actor methods if run in compiled mode: this would inherit\n+                \/\/ compiler for them. Forbid inlining of actor methods in interpreted mode:\n+                \/\/ this would make sure that while actor methods are running in interpreter,\n+                \/\/ the run loop still runs in compiled mode, running faster. The call to interpreted\n+                \/\/ method would happen anyway, even though through c2i transition.\n+                if (cm.isInt(a)) {\n+                    pw.println(\"    inline: \\\"-\" + task.name + \"::\" + an + \"\\\",\");\n+                } else {\n+                    pw.println(\"    inline: \\\"+\" + task.name + \"::\" + an + \"\\\",\");\n+                }\n+\n+                \/\/ Run loop should be compiled with C2? Forbid C1 compilation then.\n+                if (cm.isC2(a)) {\n+                    pw.println(\"    c1: {\");\n+                    pw.println(\"      Exclude: true,\");\n+                    pw.println(\"    },\");\n+                }\n+\n+                \/\/ Run loop should be compiled with C1? Forbid C2 compilation then.\n+                if (cm.isC1(a)) {\n+                    pw.println(\"    c2: {\");\n+                    pw.println(\"      Exclude: true,\");\n+                    pw.println(\"    },\");\n+                }\n+                if (VMSupport.printAssemblyAvailable() && verbosity.printAssembly() && !cm.isInt(a)) {\n+                    pw.println(\"    PrintAssembly: true,\");\n+                }\n@@ -199,0 +238,1 @@\n+            }\n@@ -200,4 +240,6 @@\n-                \/\/ The run loop:\n-                \/\/   - force inline of the workload methods\n-                \/\/   - force inline of sink methods\n-                for (String an : task.actorNames) {\n+            for (int a = 0; a < task.threads; a++) {\n+                String an = task.actorNames.get(a);\n+\n+                \/\/ If this actor runs in interpreted mode, then actor method should not be compiled.\n+                \/\/ Allow run loop to be compiled with the best compiler available.\n+                if (cm.isInt(a)) {\n@@ -205,6 +247,7 @@\n-                    pw.println(\"    match: \\\"\" + task.generatedRunnerName + \"::\" + JCStressTestProcessor.RUN_LOOP_PREFIX + an + \"\\\",\");\n-                    pw.println(\"    inline: \\\"+\" + task.name + \"::\" + an + \"\\\",\");\n-                    pw.println(\"    inline: \\\"+\" + task.generatedRunnerName + \"::\" + JCStressTestProcessor.AUX_PREFIX + \"*\\\",\");\n-                    if (VMSupport.printAssemblyAvailable() && verbosity.printAssembly()) {\n-                        pw.println(\"    PrintAssembly: true,\");\n-                    }\n+                    pw.println(\"    match: \\\"+\" + task.name + \"::\" + an + \"\\\",\");\n+                    pw.println(\"    c1: {\");\n+                    pw.println(\"      Exclude: true,\");\n+                    pw.println(\"    },\");\n+                    pw.println(\"    c2: {\");\n+                    pw.println(\"      Exclude: true,\");\n+                    pw.println(\"    },\");\n@@ -213,5 +256,0 @@\n-                pw.println(\"]\");\n-                pw.flush();\n-                pw.close();\n-            } catch (FileNotFoundException e) {\n-                throw new IllegalStateException(e);\n@@ -219,0 +257,3 @@\n+            pw.println(\"]\");\n+            pw.flush();\n+            pw.close();\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/TestExecutor.java","additions":73,"deletions":32,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -112,0 +112,2 @@\n+        pw.format(\"    (compilation: %s)%n\", r.getConfig().getCompileMode());\n+        pw.format(\"    (JVM args: %s)%n\", r.getConfig().jvmArgs);\n@@ -113,8 +115,1 @@\n-            pw.format(\"    (fork: #%d, JVM args: %s)%n\",\n-                    r.getConfig().forkId + 1,\n-                    r.getConfig().jvmArgs\n-            );\n-        } else {\n-            pw.format(\"    (JVM args: %s)%n\",\n-                    r.getConfig().jvmArgs\n-            );\n+            pw.format(\"    (fork: #%d)%n\", r.getConfig().forkId + 1);\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/infra\/grading\/ReportUtils.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import org.openjdk.jcstress.CompileMode;\n@@ -51,0 +52,1 @@\n+    public final int compileMode;\n@@ -66,1 +68,1 @@\n-    public TestConfig(Options opts, TestInfo info, RunMode runMode, int forkId, List<String> jvmArgs) {\n+    public TestConfig(Options opts, TestInfo info, RunMode runMode, int forkId, List<String> jvmArgs, int compileMode) {\n@@ -81,0 +83,1 @@\n+        this.compileMode = compileMode;\n@@ -138,0 +141,4 @@\n+    public CompileMode getCompileMode() {\n+        return new CompileMode(compileMode, actorNames, threads);\n+    }\n+\n@@ -152,0 +159,1 @@\n+        if (compileMode != that.compileMode) return false;\n@@ -167,0 +175,1 @@\n+        result = 31 * result + compileMode;\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/infra\/runners\/TestConfig.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-    public static Collection<String> splitQuotedEscape(String src) {\n+    public static List<String> splitQuotedEscape(String src) {\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/util\/StringUtils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.lang.management.ManagementFactory;\n@@ -45,1 +46,2 @@\n-    private static final List<String> STRESS_C2_JVM_FLAGS = new ArrayList<>();\n+    private static final List<String> C2_STRESS_JVM_FLAGS = new ArrayList<>();\n+    private static final List<String> C2_ONLY_STRESS_JVM_FLAGS = new ArrayList<>();\n@@ -47,1 +49,1 @@\n-    private static final Collection<Collection<String>> AVAIL_JVM_MODES = new ArrayList<>();\n+    private static final List<Config> AVAIL_JVM_CONFIGS = new ArrayList<>();\n@@ -144,2 +146,0 @@\n-        STRESS_C2_JVM_FLAGS.add(\"-XX:-TieredCompilation\");\n-\n@@ -148,1 +148,1 @@\n-                STRESS_C2_JVM_FLAGS,\n+                C2_STRESS_JVM_FLAGS,\n@@ -154,1 +154,1 @@\n-                STRESS_C2_JVM_FLAGS,\n+                C2_STRESS_JVM_FLAGS,\n@@ -160,1 +160,1 @@\n-                STRESS_C2_JVM_FLAGS,\n+                C2_STRESS_JVM_FLAGS,\n@@ -166,1 +166,1 @@\n-                STRESS_C2_JVM_FLAGS,\n+                C2_STRESS_JVM_FLAGS,\n@@ -170,0 +170,3 @@\n+        C2_ONLY_STRESS_JVM_FLAGS.add(\"-XX:-TieredCompilation\");\n+        C2_ONLY_STRESS_JVM_FLAGS.addAll(C2_STRESS_JVM_FLAGS);\n+\n@@ -226,2 +229,13 @@\n-    public static void detectAvailableVMModes(Collection<String> jvmArgs, Collection<String> jvmArgsPrepend) {\n-        Collection<Collection<String>> modes;\n+    public static void detectAvailableVMConfigs(boolean splitCompilation, List<String> jvmArgs, List<String> jvmArgsPrepend) {\n+        System.out.println(\"Probing what VM configurations are available:\");\n+        System.out.println(\" (failures are non-fatal, but may miss some interesting cases)\");\n+\n+        List<Config> configs;\n+\n+        if (!jvmArgs.isEmpty()) {\n+            configs = Collections.singletonList(new Config(jvmArgs, false));\n+        } else if (splitCompilation && COMPILER_DIRECTIVES_AVAILABLE) {\n+            System.out.println(\" (split compilation is requested and compiler directives are available)\");\n+            configs = Arrays.asList(\n+                    \/\/ Default global\n+                    new Config(Collections.emptyList(), false),\n@@ -229,2 +243,3 @@\n-        if (jvmArgs != null) {\n-            modes = Collections.singleton(jvmArgs);\n+                    \/\/ C2 compilations stress\n+                    new Config(C2_STRESS_JVM_FLAGS, true)\n+            );\n@@ -232,3 +247,3 @@\n-            modes = Arrays.asList(\n-                    \/\/ Intepreted\n-                    Arrays.asList(\"-Xint\"),\n+            configs = Arrays.asList(\n+                    \/\/ Interpreted\n+                    new Config(Arrays.asList(\"-Xint\"), false),\n@@ -237,1 +252,1 @@\n-                    Arrays.asList(\"-XX:TieredStopAtLevel=1\"),\n+                    new Config(Arrays.asList(\"-XX:TieredStopAtLevel=1\"), false),\n@@ -240,1 +255,1 @@\n-                    Arrays.asList(\"-XX:-TieredCompilation\"),\n+                    new Config(Arrays.asList(\"-XX:-TieredCompilation\"), false),\n@@ -242,2 +257,2 @@\n-                    \/\/ C2 + stress\n-                    STRESS_C2_JVM_FLAGS\n+                    \/\/ C2 only + stress\n+                    new Config(C2_ONLY_STRESS_JVM_FLAGS, true)\n@@ -247,0 +262,11 @@\n+        \/\/ Mix in input arguments, if available\n+        List<String> inputArgs = ManagementFactory.getRuntimeMXBean().getInputArguments();\n+        if (!inputArgs.isEmpty()) {\n+            configs = configs.stream().map(c -> {\n+                List<String> l = new ArrayList<>();\n+                l.addAll(inputArgs);\n+                l.addAll(c.args());\n+                return new Config(l, c.onlyIfC2());\n+            }).collect(Collectors.toList());\n+        }\n+\n@@ -249,2 +275,2 @@\n-            modes = modes.stream().map(c -> {\n-                Collection<String> l = new ArrayList<>();\n+            configs = configs.stream().map(c -> {\n+                List<String> l = new ArrayList<>();\n@@ -252,2 +278,2 @@\n-                l.addAll(c);\n-                return l;\n+                l.addAll(c.args());\n+                return new Config(l, c.onlyIfC2());\n@@ -257,2 +283,0 @@\n-        System.out.println(\"Probing what VM modes are available:\");\n-        System.out.println(\" (failures are non-fatal, but may miss some interesting cases)\");\n@@ -260,1 +284,3 @@\n-        for (Collection<String> mode : modes) {\n+\n+        for (Config config : configs) {\n+            List<String> args = config.args();\n@@ -262,1 +288,1 @@\n-                List<String> line = new ArrayList<>(mode);\n+                List<String> line = new ArrayList<>(args);\n@@ -265,2 +291,2 @@\n-                AVAIL_JVM_MODES.add(mode);\n-                System.out.printf(\"----- [OK] %s%n\", mode);\n+                AVAIL_JVM_CONFIGS.add(config);\n+                System.out.printf(\"----- [OK] %s%n\", args);\n@@ -268,1 +294,1 @@\n-                System.out.printf(\"----- [N\/A] %s%n\", mode);\n+                System.out.printf(\"----- [N\/A] %s%n\", args);\n@@ -342,2 +368,2 @@\n-    public static Collection<Collection<String>> getAvailableVMModes() {\n-        return AVAIL_JVM_MODES;\n+    public static List<Config> getAvailableVMConfigs() {\n+        return AVAIL_JVM_CONFIGS;\n@@ -397,0 +423,18 @@\n+    public static class Config {\n+        private final List<String> args;\n+        private final boolean onlyIfC2;\n+\n+        private Config(List<String> args, boolean onlyIfC2) {\n+            this.args = args;\n+            this.onlyIfC2 = onlyIfC2;\n+        }\n+\n+        public boolean onlyIfC2() {\n+            return onlyIfC2;\n+        }\n+\n+        public List<String> args() {\n+            return args;\n+        }\n+    }\n+\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/vm\/VMSupport.java","additions":76,"deletions":32,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -0,0 +1,133 @@\n+package org.openjdk.jcstress;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+\n+public class CompileModeTest {\n+\n+    @Test\n+    public void unified() {\n+        CompileMode cm = new CompileMode(CompileMode.UNIFIED, Arrays.asList(\"actor1\", \"actor2\"), 2);\n+\n+        for (int a = 0; a < 2; a++) {\n+            Assert.assertTrue(!cm.isInt(a));\n+            Assert.assertTrue(!cm.isC1(a));\n+            Assert.assertTrue(!cm.isC2(a));\n+        }\n+\n+        Assert.assertTrue(cm.hasC2());\n+    }\n+\n+    @Test\n+    public void splitComplete_1() {\n+        int cases = CompileMode.casesFor(1);\n+\n+        CompileMode[] modes = new CompileMode[cases];\n+\n+        for (int c = 0; c < cases; c++) {\n+            modes[c] = new CompileMode(c, Arrays.asList(\"actor1\"), 1);\n+        }\n+\n+        \/\/ Check all these configs are present:\n+        for (int a0 = 0; a0 < CompileMode.VARIANTS; a0++) {\n+            boolean ex = false;\n+            for (CompileMode cm : modes) {\n+                ex |= select(a0, cm, 0);\n+            }\n+            Assert.assertTrue(\"Mode does not exist: \" + a0, ex);\n+        }\n+    }\n+\n+    @Test\n+    public void splitComplete_2() {\n+        int cases = CompileMode.casesFor(2);\n+\n+        CompileMode[] modes = new CompileMode[cases];\n+\n+        for (int c = 0; c < cases; c++) {\n+            modes[c] = new CompileMode(c, Arrays.asList(\"actor1\", \"actor2\"), 2);\n+        }\n+\n+        \/\/ Check all these configs are present:\n+        for (int a0 = 0; a0 < CompileMode.VARIANTS; a0++) {\n+            for (int a1 = 0; a1 < CompileMode.VARIANTS; a1++) {\n+                boolean ex = false;\n+                for (CompileMode cm : modes) {\n+                    ex |= select(a0, cm, 0) &&\n+                          select(a1, cm, 1);\n+                }\n+                Assert.assertTrue(\"Mode does not exist: \" + a0 + \", \" + a1, ex);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void splitComplete_3() {\n+        int cases = CompileMode.casesFor(3);\n+\n+        CompileMode[] modes = new CompileMode[cases];\n+\n+        for (int c = 0; c < cases; c++) {\n+            modes[c] = new CompileMode(c, Arrays.asList(\"actor1\", \"actor2\", \"actor3\"), 3);\n+        }\n+\n+        \/\/ Check all these configs are present:\n+        for (int a0 = 0; a0 < CompileMode.VARIANTS; a0++) {\n+            for (int a1 = 0; a1 < CompileMode.VARIANTS; a1++) {\n+                for (int a2 = 0; a2 < CompileMode.VARIANTS; a2++) {\n+                    boolean ex = false;\n+                    for (CompileMode cm : modes) {\n+                        ex |= select(a0, cm, 0) &&\n+                              select(a1, cm, 1) &&\n+                              select(a2, cm, 2);\n+                    }\n+                    Assert.assertTrue(\"Mode does not exist: \" + a0 + \", \" + a1 + \", \" + a2, ex);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void splitComplete_4() {\n+        int cases = CompileMode.casesFor(4);\n+\n+        CompileMode[] modes = new CompileMode[cases];\n+\n+        for (int c = 0; c < cases; c++) {\n+            modes[c] = new CompileMode(c, Arrays.asList(\"actor1\", \"actor2\", \"actor3\", \"actor4\"), 4);\n+        }\n+\n+        \/\/ Check all these configs are present:\n+        for (int a0 = 0; a0 < CompileMode.VARIANTS; a0++) {\n+            for (int a1 = 0; a1 < CompileMode.VARIANTS; a1++) {\n+                for (int a2 = 0; a2 < CompileMode.VARIANTS; a2++) {\n+                    for (int a3 = 0; a3 < CompileMode.VARIANTS; a3++) {\n+                        boolean ex = false;\n+                        for (CompileMode cm : modes) {\n+                            ex |= select(a0, cm, 0) &&\n+                                  select(a1, cm, 1) &&\n+                                  select(a2, cm, 2) &&\n+                                  select(a3, cm, 3);\n+                        }\n+                        Assert.assertTrue(\"Mode does not exist: \" + a0 + \", \" + a1 + \", \" + a2 + \", \" + a3, ex);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private boolean select(int m, CompileMode cm, int a) {\n+        switch (m) {\n+            case 0:\n+                return cm.isInt(a);\n+            case 1:\n+                return cm.isC1(a);\n+            case 2:\n+                return cm.isC2(a);\n+            default:\n+                throw new IllegalStateException(\"Unknown mode\");\n+        }\n+    }\n+}\n","filename":"jcstress-core\/src\/test\/java\/org\/openjdk\/jcstress\/CompileModeTest.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -67,1 +67,1 @@\n-        return new TestConfig(opts, info, TestConfig.RunMode.FORKED, 1, Collections.emptyList());\n+        return new TestConfig(opts, info, TestConfig.RunMode.FORKED, 1, Collections.emptyList(), CompileMode.UNIFIED);\n","filename":"jcstress-core\/src\/test\/java\/org\/openjdk\/jcstress\/EmbeddedExecutorTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}