{"files":[{"patch":"@@ -143,3 +143,2 @@\n-        for (int cc = 0; cc < CompileMode.casesFor(info.threads()); cc++) {\n-            CompileMode cm = new CompileMode(cc, info.actorNames(), info.threads());\n-            if (config.onlyIfC2() && !cm.hasC2()) {\n+        for (int cc : CompileMode.casesFor(info.threads(), VMSupport.c1Available(), VMSupport.c2Available())) {\n+            if (config.onlyIfC2() && CompileMode.hasC2(cc, info.threads())) {\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/JCStress.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -213,1 +213,1 @@\n-            CompileMode cm = task.getCompileMode();\n+            int cm = task.getCompileMode();\n@@ -226,1 +226,1 @@\n-                if (cm.isInt(a)) {\n+                if (CompileMode.isInt(cm, a)) {\n@@ -233,1 +233,1 @@\n-                if (cm.isC2(a)) {\n+                if (CompileMode.isC2(cm, a)) {\n@@ -240,1 +240,1 @@\n-                if (cm.isC1(a)) {\n+                if (CompileMode.isC1(cm, a)) {\n@@ -246,1 +246,1 @@\n-                if (VMSupport.printAssemblyAvailable() && verbosity.printAssembly() && !cm.isInt(a)) {\n+                if (VMSupport.printAssemblyAvailable() && verbosity.printAssembly() && !CompileMode.isInt(cm, a)) {\n@@ -262,1 +262,1 @@\n-                if (cm.isInt(a)) {\n+                if (CompileMode.isInt(cm, a)) {\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/TestExecutor.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import org.openjdk.jcstress.vm.CompileMode;\n@@ -121,1 +122,1 @@\n-        pw.format(\"    (compilation: %s)%n\", r.getConfig().getCompileMode());\n+        pw.format(\"    (compilation: %s)%n\", CompileMode.description(r.getConfig().getCompileMode(), r.getConfig().actorNames));\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/infra\/grading\/ReportUtils.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -141,2 +141,2 @@\n-    public CompileMode getCompileMode() {\n-        return new CompileMode(compileMode, actorNames, threads);\n+    public int getCompileMode() {\n+        return compileMode;\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/infra\/runners\/TestConfig.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,5 @@\n-    public static final int VARIANTS = 3;\n+    public static final int MAX_MODES = 3;\n+    private static final int MODE_INT = 0;\n+    private static final int MODE_C1 = 1;\n+    private static final int MODE_C2 = 2;\n+\n@@ -34,3 +38,2 @@\n-    private final int mode;\n-    private final List<String> actorNames;\n-    private final int actors;\n+    public static int[] casesFor(int actors, boolean c1, boolean c2) {\n+        int modes = 1 + (c1 ? 1 : 0) + (c2 ? 1 : 0);\n@@ -38,5 +41,6 @@\n-    public CompileMode(int mode, List<String> actorNames, int actors) {\n-        this.mode = mode;\n-        this.actorNames = actorNames;\n-        this.actors = actors;\n-    }\n+        int len = 1;\n+        int maxLen = 1;\n+        for (int a = 0; a < actors; a++) {\n+            len *= modes;\n+            maxLen *= MAX_MODES;\n+        }\n@@ -44,4 +48,6 @@\n-    public static int casesFor(int actors) {\n-        int cases = 1;\n-        for (int c = 0; c < actors; c++) {\n-            cases *= VARIANTS;\n+        int[] cases = new int[len];\n+        int idx = 0;\n+        for (int c = 0; c < maxLen; c++) {\n+            if (!c1 && hasC1(c, actors)) continue;\n+            if (!c2 && hasC2(c, actors)) continue;\n+            cases[idx++] = c;\n@@ -52,1 +58,1 @@\n-    private int actorMode(int actor) {\n+    private static int actorMode(int mode, int actor) {\n@@ -55,1 +61,1 @@\n-            m \/= VARIANTS;\n+            m \/= MAX_MODES;\n@@ -57,1 +63,1 @@\n-        return m % VARIANTS;\n+        return m % MAX_MODES;\n@@ -60,2 +66,2 @@\n-    public boolean isInt(int actor) {\n-        return (mode != UNIFIED) && (actorMode(actor) == 0);\n+    public static boolean isInt(int mode, int actor) {\n+        return (mode != UNIFIED) && (actorMode(mode, actor) == MODE_INT);\n@@ -64,2 +70,2 @@\n-    public boolean isC1(int actor) {\n-        return (mode != UNIFIED) && (actorMode(actor) == 1);\n+    public static boolean isC1(int mode, int actor) {\n+        return (mode != UNIFIED) && (actorMode(mode, actor) == MODE_C1);\n@@ -68,2 +74,2 @@\n-    public boolean isC2(int actor) {\n-        return (mode != UNIFIED) && (actorMode(actor) == 2);\n+    public static boolean isC2(int mode, int actor) {\n+        return (mode != UNIFIED) && (actorMode(mode, actor) == MODE_C2);\n@@ -72,1 +78,1 @@\n-    public boolean hasC2() {\n+    public static boolean hasC2(int mode, int actors) {\n@@ -77,1 +83,1 @@\n-            if (isC2(a)) return true;\n+            if (isC2(mode, a)) return true;\n@@ -82,8 +88,3 @@\n-    private String actorModeToString(int actor) {\n-        int v = actorMode(actor);\n-        switch (v) {\n-            case 0: return \"Interpreter\";\n-            case 1: return \"C1\";\n-            case 2: return \"C2\";\n-            default:\n-                throw new IllegalStateException(\"Unhandled variant: \" + v);\n+    private static boolean hasC1(int mode, int actors) {\n+        if (mode == UNIFIED) {\n+            return true;\n@@ -91,0 +92,4 @@\n+        for (int a = 0; a < actors; a++) {\n+            if (isC1(mode, a)) return true;\n+        }\n+        return false;\n@@ -93,1 +98,1 @@\n-    public String toString() {\n+    public static String description(int mode, List<String> actorNames) {\n@@ -100,1 +105,1 @@\n-        for (int a = 0; a < actors; a++) {\n+        for (int a = 0; a < actorNames.size(); a++) {\n@@ -108,1 +113,14 @@\n-            sb.append(actorModeToString(a));\n+            int v = actorMode(mode, a);\n+            switch (v) {\n+                case 0:\n+                    sb.append(\"Interpreter\");\n+                    break;\n+                case 1:\n+                    sb.append(\"C1\");\n+                    break;\n+                case 2:\n+                    sb.append(\"C2\");\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unhandled mode: \" + v);\n+            }\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/vm\/CompileMode.java","additions":53,"deletions":35,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -54,0 +54,4 @@\n+    private static volatile boolean C1_AVAILABLE;\n+    private static volatile boolean C2_AVAILABLE;\n+    private static volatile boolean COMPILERS_AVAILABLE;\n+\n@@ -66,0 +70,8 @@\n+    public static boolean c1Available() {\n+        return C1_AVAILABLE;\n+    }\n+\n+    public static boolean c2Available() {\n+        return C2_AVAILABLE;\n+    }\n+\n@@ -77,0 +89,14 @@\n+        C1_AVAILABLE = detect(\"Checking for C1 availability\",\n+                SimpleTestMain.class,\n+                null,\n+                \"-XX:+C1ProfileCalls\"\n+        );\n+\n+        C2_AVAILABLE = detect(\"Checking for C2 availability\",\n+                SimpleTestMain.class,\n+                null,\n+                \"-XX:+UseLoopPredicate\"\n+        );\n+\n+        COMPILERS_AVAILABLE = C1_AVAILABLE || C2_AVAILABLE;\n+\n@@ -118,5 +144,7 @@\n-        detect(\"Trimming down the number of compiler threads\",\n-                SimpleTestMain.class,\n-                GLOBAL_JVM_FLAGS,\n-                \"-XX:CICompilerCount=2\" \/\/ This is the absolute minimum for tiered configurations\n-        );\n+        if (COMPILERS_AVAILABLE) {\n+            detect(\"Trimming down the number of compiler threads\",\n+                    SimpleTestMain.class,\n+                    GLOBAL_JVM_FLAGS,\n+                    \"-XX:CICompilerCount=2\" \/\/ This is the absolute minimum for tiered configurations\n+            );\n+        }\n@@ -152,5 +180,6 @@\n-        detect(\"Unlocking C2 local code motion randomizer\",\n-                SimpleTestMain.class,\n-                C2_STRESS_JVM_FLAGS,\n-                \"-XX:+StressLCM\"\n-        );\n+        if (C2_AVAILABLE) {\n+            detect(\"Unlocking C2 local code motion randomizer\",\n+                    SimpleTestMain.class,\n+                    C2_STRESS_JVM_FLAGS,\n+                    \"-XX:+StressLCM\"\n+            );\n@@ -158,5 +187,5 @@\n-        detect(\"Unlocking C2 global code motion randomizer\",\n-                SimpleTestMain.class,\n-                C2_STRESS_JVM_FLAGS,\n-                \"-XX:+StressGCM\"\n-        );\n+            detect(\"Unlocking C2 global code motion randomizer\",\n+                    SimpleTestMain.class,\n+                    C2_STRESS_JVM_FLAGS,\n+                    \"-XX:+StressGCM\"\n+            );\n@@ -164,5 +193,5 @@\n-        detect(\"Unlocking C2 iterative global value numbering randomizer\",\n-                SimpleTestMain.class,\n-                C2_STRESS_JVM_FLAGS,\n-                \"-XX:+StressIGVN\"\n-        );\n+            detect(\"Unlocking C2 iterative global value numbering randomizer\",\n+                    SimpleTestMain.class,\n+                    C2_STRESS_JVM_FLAGS,\n+                    \"-XX:+StressIGVN\"\n+            );\n@@ -170,5 +199,5 @@\n-        detect(\"Unlocking C2 conditional constant propagation randomizer\",\n-                SimpleTestMain.class,\n-                C2_STRESS_JVM_FLAGS,\n-                \"-XX:+StressCCP\"\n-        );\n+            detect(\"Unlocking C2 conditional constant propagation randomizer\",\n+                    SimpleTestMain.class,\n+                    C2_STRESS_JVM_FLAGS,\n+                    \"-XX:+StressCCP\"\n+            );\n@@ -176,2 +205,3 @@\n-        C2_ONLY_STRESS_JVM_FLAGS.add(\"-XX:-TieredCompilation\");\n-        C2_ONLY_STRESS_JVM_FLAGS.addAll(C2_STRESS_JVM_FLAGS);\n+            C2_ONLY_STRESS_JVM_FLAGS.add(\"-XX:-TieredCompilation\");\n+            C2_ONLY_STRESS_JVM_FLAGS.addAll(C2_STRESS_JVM_FLAGS);\n+        }\n@@ -190,1 +220,2 @@\n-        PRINT_ASSEMBLY_AVAILABLE =\n+        if (COMPILERS_AVAILABLE) {\n+            PRINT_ASSEMBLY_AVAILABLE =\n@@ -197,17 +228,18 @@\n-        try {\n-            File temp = File.createTempFile(\"jcstress\", \"directives\");\n-\n-            PrintWriter pw = new PrintWriter(temp);\n-            pw.println(\"[ { match: \\\"*::*\\\", PrintInlining: true } ]\");\n-            pw.close();\n-\n-            COMPILER_DIRECTIVES_AVAILABLE =\n-                    detect(\"Testing compiler directives\",\n-                            SimpleTestMain.class,\n-                            null,\n-                            \"-XX:CompilerDirectivesFile=\" + temp.getAbsolutePath()\n-                    );\n-\n-            temp.delete();\n-        } catch (IOException e) {\n-            \/\/ Do nothing.\n+            try {\n+                File temp = File.createTempFile(\"jcstress\", \"directives\");\n+\n+                PrintWriter pw = new PrintWriter(temp);\n+                pw.println(\"[ { match: \\\"*::*\\\", PrintInlining: true } ]\");\n+                pw.close();\n+\n+                COMPILER_DIRECTIVES_AVAILABLE =\n+                        detect(\"Testing compiler directives\",\n+                                SimpleTestMain.class,\n+                                null,\n+                                \"-XX:CompilerDirectivesFile=\" + temp.getAbsolutePath()\n+                        );\n+\n+                temp.delete();\n+            } catch (IOException e) {\n+                \/\/ Do nothing.\n+            }\n@@ -239,1 +271,1 @@\n-        List<Config> configs;\n+        LinkedHashSet<Config> configs = new LinkedHashSet<>();\n@@ -242,1 +274,1 @@\n-            configs = Collections.singletonList(new Config(jvmArgs, false));\n+            configs.add(new Config(jvmArgs, false));\n@@ -245,7 +277,6 @@\n-            configs = Arrays.asList(\n-                    \/\/ Default global\n-                    new Config(Collections.emptyList(), false),\n-\n-                    \/\/ C2 compilations stress\n-                    new Config(C2_STRESS_JVM_FLAGS, true)\n-            );\n+            \/\/ Default global\n+            configs.add(new Config(Collections.emptyList(), false));\n+            if (C2_AVAILABLE) {\n+                \/\/ C2 compilations stress\n+                configs.add(new Config(C2_STRESS_JVM_FLAGS, true));\n+            }\n@@ -253,6 +284,13 @@\n-            configs = Arrays.asList(\n-                    \/\/ Interpreted\n-                    new Config(Arrays.asList(\"-Xint\"), false),\n-\n-                    \/\/ C1\n-                    new Config(Arrays.asList(\"-XX:TieredStopAtLevel=1\"), false),\n+            \/\/ Interpreted\n+            configs.add(new Config(Arrays.asList(\"-Xint\"), false));\n+            if (C1_AVAILABLE) {\n+                \/\/ C1\n+                configs.add(new Config(Arrays.asList(\"-XX:TieredStopAtLevel=1\"), false));\n+            }\n+            if (C2_AVAILABLE) {\n+                \/\/ C2\n+                configs.add(new Config(Arrays.asList(\"-XX:-TieredCompilation\"), false));\n+                \/\/ C2 only + stress\n+                configs.add(new Config(C2_ONLY_STRESS_JVM_FLAGS, true));\n+            }\n+        }\n@@ -260,2 +298,2 @@\n-                    \/\/ C2\n-                    new Config(Arrays.asList(\"-XX:-TieredCompilation\"), false),\n+        \/\/ Mix in input arguments, if available\n+        List<String> inputArgs = new ArrayList<>();\n@@ -263,3 +301,4 @@\n-                    \/\/ C2 only + stress\n-                    new Config(C2_ONLY_STRESS_JVM_FLAGS, true)\n-            );\n+        try {\n+            inputArgs.addAll(ManagementFactory.getRuntimeMXBean().getInputArguments());\n+        } catch (InternalError e) {\n+            System.out.println(\"Warning: cannot get input arguments: \" + e.getMessage());\n@@ -268,2 +307,0 @@\n-        \/\/ Mix in input arguments, if available\n-        List<String> inputArgs = ManagementFactory.getRuntimeMXBean().getInputArguments();\n@@ -276,1 +313,1 @@\n-            }).collect(Collectors.toList());\n+            }).collect(Collectors.toCollection(LinkedHashSet::new));\n@@ -286,1 +323,1 @@\n-            }).collect(Collectors.toList());\n+            }).collect(Collectors.toCollection(LinkedHashSet::new));\n@@ -445,0 +482,14 @@\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            Config config = (Config) o;\n+            return onlyIfC2 == config.onlyIfC2 &&\n+                    args.equals(config.args);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(args, onlyIfC2);\n+        }\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/vm\/VMSupport.java","additions":120,"deletions":69,"binary":false,"changes":189,"status":"modified"},{"patch":"@@ -7,2 +7,0 @@\n-import java.util.Arrays;\n-\n@@ -13,2 +11,0 @@\n-        CompileMode cm = new CompileMode(CompileMode.UNIFIED, Arrays.asList(\"actor1\", \"actor2\"), 2);\n-\n@@ -16,3 +12,3 @@\n-            Assert.assertTrue(!cm.isInt(a));\n-            Assert.assertTrue(!cm.isC1(a));\n-            Assert.assertTrue(!cm.isC2(a));\n+            Assert.assertTrue(!CompileMode.isInt(CompileMode.UNIFIED, a));\n+            Assert.assertTrue(!CompileMode.isC1(CompileMode.UNIFIED, a));\n+            Assert.assertTrue(!CompileMode.isC2(CompileMode.UNIFIED, a));\n@@ -21,1 +17,3 @@\n-        Assert.assertTrue(cm.hasC2());\n+        for (int a = 0; a < 4; a++) {\n+            Assert.assertTrue(CompileMode.hasC2(CompileMode.UNIFIED, a));\n+        }\n@@ -26,7 +24,1 @@\n-        int cases = CompileMode.casesFor(1);\n-\n-        CompileMode[] modes = new CompileMode[cases];\n-\n-        for (int c = 0; c < cases; c++) {\n-            modes[c] = new CompileMode(c, Arrays.asList(\"actor1\"), 1);\n-        }\n+        int[] cases = CompileMode.casesFor(1, true, true);\n@@ -35,1 +27,1 @@\n-        for (int a0 = 0; a0 < CompileMode.VARIANTS; a0++) {\n+        for (int a0 = 0; a0 < CompileMode.MAX_MODES; a0++) {\n@@ -37,1 +29,1 @@\n-            for (CompileMode cm : modes) {\n+            for (int cm : cases) {\n@@ -46,7 +38,1 @@\n-        int cases = CompileMode.casesFor(2);\n-\n-        CompileMode[] modes = new CompileMode[cases];\n-\n-        for (int c = 0; c < cases; c++) {\n-            modes[c] = new CompileMode(c, Arrays.asList(\"actor1\", \"actor2\"), 2);\n-        }\n+        int[] cases = CompileMode.casesFor(2, true, true);\n@@ -55,2 +41,2 @@\n-        for (int a0 = 0; a0 < CompileMode.VARIANTS; a0++) {\n-            for (int a1 = 0; a1 < CompileMode.VARIANTS; a1++) {\n+        for (int a0 = 0; a0 < CompileMode.MAX_MODES; a0++) {\n+            for (int a1 = 0; a1 < CompileMode.MAX_MODES; a1++) {\n@@ -58,1 +44,1 @@\n-                for (CompileMode cm : modes) {\n+                for (int cm : cases) {\n@@ -69,7 +55,1 @@\n-        int cases = CompileMode.casesFor(3);\n-\n-        CompileMode[] modes = new CompileMode[cases];\n-\n-        for (int c = 0; c < cases; c++) {\n-            modes[c] = new CompileMode(c, Arrays.asList(\"actor1\", \"actor2\", \"actor3\"), 3);\n-        }\n+        int[] cases = CompileMode.casesFor(3, true, true);\n@@ -78,3 +58,3 @@\n-        for (int a0 = 0; a0 < CompileMode.VARIANTS; a0++) {\n-            for (int a1 = 0; a1 < CompileMode.VARIANTS; a1++) {\n-                for (int a2 = 0; a2 < CompileMode.VARIANTS; a2++) {\n+        for (int a0 = 0; a0 < CompileMode.MAX_MODES; a0++) {\n+            for (int a1 = 0; a1 < CompileMode.MAX_MODES; a1++) {\n+                for (int a2 = 0; a2 < CompileMode.MAX_MODES; a2++) {\n@@ -82,1 +62,1 @@\n-                    for (CompileMode cm : modes) {\n+                    for (int cm : cases) {\n@@ -94,2 +74,13 @@\n-    public void splitComplete_4() {\n-        int cases = CompileMode.casesFor(4);\n+    public void splitOnlyC1_3() {\n+        boolean hasInt = false;\n+        boolean hasC1 = false;\n+        boolean hasC2 = false;\n+\n+        for (int cm : CompileMode.casesFor(3, true, false)) {\n+            for (int a = 0; a < 3; a++) {\n+                hasInt |= CompileMode.isInt(cm, a);\n+                hasC1 |= CompileMode.isC1(cm, a);\n+                hasC2 |= CompileMode.isC2(cm, a);\n+            }\n+            Assert.assertFalse(\"C2 modes should not exist: \" + cm, hasC2);\n+        }\n@@ -97,1 +88,3 @@\n-        CompileMode[] modes = new CompileMode[cases];\n+        Assert.assertTrue(\"Interpreter modes should not exist\", hasInt);\n+        Assert.assertTrue(\"C1 modes should exist\", hasC1);\n+    }\n@@ -99,2 +92,13 @@\n-        for (int c = 0; c < cases; c++) {\n-            modes[c] = new CompileMode(c, Arrays.asList(\"actor1\", \"actor2\", \"actor3\", \"actor4\"), 4);\n+    @Test\n+    public void splitOnlyC2_3() {\n+        boolean hasInt = false;\n+        boolean hasC1 = false;\n+        boolean hasC2 = false;\n+\n+        for (int cm : CompileMode.casesFor(3, false, true)) {\n+            for (int a = 0; a < 3; a++) {\n+                hasInt |= CompileMode.isInt(cm, a);\n+                hasC1 |= CompileMode.isC1(cm, a);\n+                hasC2 |= CompileMode.isC2(cm, a);\n+            }\n+            Assert.assertFalse(\"C1 modes should not exist: \" + cm, hasC1);\n@@ -103,15 +107,15 @@\n-        \/\/ Check all these configs are present:\n-        for (int a0 = 0; a0 < CompileMode.VARIANTS; a0++) {\n-            for (int a1 = 0; a1 < CompileMode.VARIANTS; a1++) {\n-                for (int a2 = 0; a2 < CompileMode.VARIANTS; a2++) {\n-                    for (int a3 = 0; a3 < CompileMode.VARIANTS; a3++) {\n-                        boolean ex = false;\n-                        for (CompileMode cm : modes) {\n-                            ex |= select(a0, cm, 0) &&\n-                                  select(a1, cm, 1) &&\n-                                  select(a2, cm, 2) &&\n-                                  select(a3, cm, 3);\n-                        }\n-                        Assert.assertTrue(\"Mode does not exist: \" + a0 + \", \" + a1 + \", \" + a2 + \", \" + a3, ex);\n-                    }\n-                }\n+        Assert.assertTrue(\"Interpreter modes should exist\", hasInt);\n+        Assert.assertTrue(\"C2 modes should exist\", hasC2);\n+    }\n+\n+    @Test\n+    public void splitOnlyInt_3() {\n+        boolean hasInt = false;\n+        boolean hasC1 = false;\n+        boolean hasC2 = false;\n+\n+        for (int cm : CompileMode.casesFor(3, false, false)) {\n+            for (int a = 0; a < 3; a++) {\n+                hasInt |= CompileMode.isInt(cm, a);\n+                hasC1 |= CompileMode.isC1(cm, a);\n+                hasC2 |= CompileMode.isC2(cm,a);\n@@ -119,0 +123,2 @@\n+            Assert.assertFalse(\"C1 modes should not exist: \" + cm, hasC1);\n+            Assert.assertFalse(\"C2 modes should not exist: \" + cm, hasC2);\n@@ -120,0 +126,2 @@\n+\n+        Assert.assertTrue(\"Interpreter modes should exist\", hasInt);\n@@ -122,1 +130,1 @@\n-    private boolean select(int m, CompileMode cm, int a) {\n+    private boolean select(int m, int cm, int a) {\n@@ -125,1 +133,1 @@\n-                return cm.isInt(a);\n+                return CompileMode.isInt(cm, a);\n@@ -127,1 +135,1 @@\n-                return cm.isC1(a);\n+                return CompileMode.isC1(cm, a);\n@@ -129,1 +137,1 @@\n-                return cm.isC2(a);\n+                return CompileMode.isC2(cm, a);\n","filename":"jcstress-core\/src\/test\/java\/org\/openjdk\/jcstress\/CompileModeTest.java","additions":70,"deletions":62,"binary":false,"changes":132,"status":"modified"}]}