{"files":[{"patch":"@@ -46,2 +46,1 @@\n-    would tell us something about the concurrent behavior. For example, running\n-    this test would yield:\n+    would tell us something about the concurrent behavior.\n@@ -49,1 +48,6 @@\n-        .......... [OK] org.openjdk.jcstress.samples.api.APISample_01_Simple\n+    How to run this test:\n+       $ java -jar jcstress-samples\/target\/jcstress.jar -t API_01_Simple\n+\n+       ...\n+\n+        .......... [OK] org.openjdk.jcstress.samples.api.API_01_Simple\n@@ -69,3 +73,0 @@\n-\n-     How to run this test:\n-       $ java -jar jcstress-samples\/target\/jcstress.jar -t APISample_01\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/api\/API_01_Simple.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-       $ java -jar jcstress-samples\/target\/jcstress.jar -t APISample_02_Arbiters\n+       $ java -jar jcstress-samples\/target\/jcstress.jar -t API_02_Arbiters\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/api\/API_02_Arbiters.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-       $ java -jar jcstress-samples\/target\/jcstress.jar -t APISample_03\n+       $ java -jar jcstress-samples\/target\/jcstress.jar -t API_03_Termination\n@@ -47,2 +47,2 @@\n-           STALE        4   30.77%  Interesting  Test hung up.\n-      TERMINATED        9   69.23%   Acceptable  Gracefully finished.\n+           STALE        1   <0.01%  Interesting  Test hung up.\n+      TERMINATED   13,168   99.99%   Acceptable  Gracefully finished.\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/api\/API_03_Termination.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-       $ java -jar jcstress-samples\/target\/jcstress.jar -t APISample_04\n+       $ java -jar jcstress-samples\/target\/jcstress.jar -t API_04_Nesting\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/api\/API_04_Nesting.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-       $ java -jar jcstress-samples\/target\/jcstress.jar -t APISample_05\n+       $ java -jar jcstress-samples\/target\/jcstress.jar -t API_05_SharedMetadata\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/api\/API_05_SharedMetadata.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-       $ java -jar jcstress-samples\/target\/jcstress.jar -t APISample_06\n+       $ java -jar jcstress-samples\/target\/jcstress.jar -t API_06_Descriptions\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/api\/API_06_Descriptions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,3 +75,3 @@\n-         to order the writes to \"x\" and \"y\" differently. JMM as stated allows\n-         this optimization: we are only required to see these stores in order if we are\n-         synchronizing on the same \"this\". Side observers can see the writes in whatever order.\n+         to order the writes to \"x\" and \"y\" differently. JMM as stated allows this optimization: we are only\n+         required to see these stores in order if we are synchronizing on the same \"this\". Side observers can\n+         see the writes in whatever order.\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/jmm\/advanced\/AdvancedJMM_01_SynchronizedBarriers.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-        On x86_64 -- that is multi-copy atomic architecture -- this test yields:\n+        On x86_64 -- that is total store order and multi-copy atomic architecture -- this test yields:\n@@ -82,1 +82,2 @@\n-        But on PPC64 -- that is not a multi-copy atomic architecture -- this test yields:\n+        But on PPC64 or ARM64 -- that are not the total store order architectures\n+        -- this test yields:\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/jmm\/advanced\/AdvancedJMM_02_MultiCopyAtomic.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n@@ -32,6 +34,0 @@\n-@JCStressTest\n-@State\n-@Outcome(id = \"10\",                      expect = ACCEPTABLE,             desc = \"Boring\")\n-@Outcome(id = {\"0\", \"1\"},                expect = FORBIDDEN,              desc = \"Boring\")\n-@Outcome(id = {\"9\", \"8\", \"7\", \"6\", \"5\"}, expect = ACCEPTABLE,             desc = \"Okay\")\n-@Outcome(                                expect = ACCEPTABLE_INTERESTING, desc = \"Whoa\")\n@@ -68,1 +64,1 @@\n-        The most interesting result, \"2\" can be explaned by this interleaving:\n+        The most interesting result, \"2\" can be explained by this interleaving:\n@@ -78,1 +74,8 @@\n-    volatile int x;\n+    @JCStressTest\n+    @State\n+    @Outcome(id = \"10\",                      expect = ACCEPTABLE,             desc = \"Boring\")\n+    @Outcome(id = {\"0\", \"1\"},                expect = FORBIDDEN,              desc = \"Boring\")\n+    @Outcome(id = {\"9\", \"8\", \"7\", \"6\", \"5\"}, expect = ACCEPTABLE,             desc = \"Okay\")\n+    @Outcome(                                expect = ACCEPTABLE_INTERESTING, desc = \"Whoa\")\n+    public static class Volatiles {\n+        volatile int x;\n@@ -80,4 +83,5 @@\n-    @Actor\n-    void actor1() {\n-        for (int i = 0; i < 5; i++) {\n-            x++;\n+        @Actor\n+        void actor1() {\n+            for (int i = 0; i < 5; i++) {\n+                x++;\n+            }\n@@ -85,1 +89,0 @@\n-    }\n@@ -87,4 +90,10 @@\n-    @Actor\n-    void actor2() {\n-        for (int i = 0; i < 5; i++) {\n-            x++;\n+        @Actor\n+        void actor2() {\n+            for (int i = 0; i < 5; i++) {\n+                x++;\n+            }\n+        }\n+\n+        @Arbiter\n+        public void arbiter(I_Result r) {\n+            r.r1 = x;\n@@ -94,3 +103,34 @@\n-    @Arbiter\n-    public void arbiter(I_Result r) {\n-        r.r1 = x;\n+    \/*\n+      ----------------------------------------------------------------------------------------------------------\n+\n+        Of course, if we do AtomicInteger, the only plausible result is \"10\".\n+\n+          RESULT      SAMPLES     FREQ      EXPECT  DESCRIPTION\n+              10  638,040,064  100.00%  Acceptable  Boring\n+     *\/\n+\n+    @JCStressTest\n+    @State\n+    @Outcome(id = \"10\", expect = ACCEPTABLE, desc = \"Boring\")\n+    @Outcome(           expect = FORBIDDEN,  desc = \"Whoa\")\n+    public static class Atomics {\n+        AtomicInteger ai = new AtomicInteger();\n+\n+        @Actor\n+        void actor1() {\n+            for (int i = 0; i < 5; i++) {\n+                ai.incrementAndGet();\n+            }\n+        }\n+\n+        @Actor\n+        void actor2() {\n+            for (int i = 0; i < 5; i++) {\n+                ai.incrementAndGet();\n+            }\n+        }\n+\n+        @Arbiter\n+        public void arbiter(I_Result r) {\n+            r.r1 = ai.get();\n+        }\n@@ -98,0 +138,1 @@\n+\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/jmm\/advanced\/AdvancedJMM_03_LosingUpdates.java","additions":61,"deletions":20,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -40,3 +40,2 @@\n-@Outcome(id = {\"-1\", \"42\"}, expect = ACCEPTABLE,             desc = \"Boring\")\n-@Outcome(id = \"0\",          expect = ACCEPTABLE_INTERESTING, desc = \"Whoa\")\n-@Outcome(id = {\"-2\", \"-3\"}, expect = ACCEPTABLE_INTERESTING, desc = \"Whoa-whoa\")\n+@Outcome(id = {\"-1\", \"42\"},       expect = ACCEPTABLE,             desc = \"Boring\")\n+@Outcome(id = {\"-2\", \"-3\", \"-4\"}, expect = ACCEPTABLE_INTERESTING, desc = \"Whoa-whoa\")\n@@ -58,1 +57,9 @@\n-        This test on x86_64:\n+        x86_64:\n+          RESULT        SAMPLES     FREQ       EXPECT  DESCRIPTION\n+              -1  9,508,599,695   81.61%   Acceptable  Boring\n+              -2     28,299,861    0.24%  Interesting  Whoa-whoa\n+              -3              0    0.00%  Interesting  Whoa-whoa\n+              -4          7,308   <0.01%  Interesting  Whoa-whoa\n+              42  2,114,748,816   18.15%   Acceptable  Boring\n+\n+        AArch64:\n@@ -60,4 +67,7 @@\n-              -1            0    0.00%   Acceptable  Boring\n-              -2            1   <0.01%  Interesting  Whoa-whoa\n-               0  256,502,626   56.64%  Interesting  Whoa\n-              42  196,385,437   43.36%   Acceptable  Boring\n+              -1  519,561,253   82.38%   Acceptable  Boring\n+              -2    1,241,751    0.20%  Interesting  Whoa-whoa\n+              -3        1,902   <0.01%  Interesting  Whoa-whoa\n+              -4            9   <0.01%  Interesting  Whoa-whoa\n+              42  109,901,261   17.43%   Acceptable  Boring\n+\n+        The \"-1\" outcome is very visible for obvious reasons, it is explainable by sequential execution.\n@@ -65,1 +75,2 @@\n-        The \"0\" outcome is very visible for obvious reasons, it is explainable by sequential execution.\n+        The \"-2\" and \"-3\" outcomes are possible due to simple visibility failures: the store\n+        to backing array is not yet visible.\n@@ -67,1 +78,1 @@\n-        There is also a very interesting \"-1\" outcome, which shows that mutating collections under\n+        There is also a very interesting \"-4\" outcome, which shows that mutating collections under\n@@ -73,1 +84,1 @@\n-    volatile List<Integer> list = new ArrayList<>();\n+    volatile List<Integer> list;\n@@ -84,16 +95,1 @@\n-        if (l != null) {\n-            if (l.isEmpty()) {\n-                r.r1 = 0;\n-            } else {\n-                try {\n-                    Integer li = l.get(0);\n-                    if (li != null) {\n-                        r.r1 = li;\n-                    } else {\n-                        r.r1 = -2;\n-                    }\n-                } catch (ArrayIndexOutOfBoundsException e) {\n-                    r.r1 = -3;\n-                }\n-            }\n-        } else {\n+        if (l == null) {\n@@ -101,0 +97,17 @@\n+            return;\n+        }\n+\n+        if (l.isEmpty()) {\n+            r.r1 = -2;\n+            return;\n+        }\n+\n+        try {\n+            Integer li = l.get(0);\n+            if (li == null) {\n+                r.r1 = -3;\n+                return;\n+            }\n+            r.r1 = li;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            r.r1 = -4;\n@@ -103,1 +116,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/jmm\/advanced\/AdvancedJMM_08_WrongListReleaseOrder.java","additions":41,"deletions":28,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-public class AdvancedJMM_13_VolatileVsFinal {\n+public class AdvancedJMM_11_VolatileVsFinal {\n@@ -40,1 +40,1 @@\n-            $ java -jar jcstress-samples\/target\/jcstress.jar -t AdvancedJMM_13_VolatileVsFinal[.SubTestName]\n+            $ java -jar jcstress-samples\/target\/jcstress.jar -t AdvancedJMM_11_VolatileVsFinal[.SubTestName]\n@@ -49,1 +49,1 @@\n-        volatile itself is in the wrong place. This is similar to AdvancedJMM_10_WrongAcquireReleaseOrder\n+        volatile itself is in the wrong place. This is similar to previous AdvancedJMM_10_WrongAcquireReleaseOrder\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/jmm\/advanced\/AdvancedJMM_11_VolatileVsFinal.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/jmm\/advanced\/AdvancedJMM_13_VolatileVsFinal.java","status":"renamed"},{"patch":"@@ -36,1 +36,1 @@\n-public class AdvancedJMM_11_SynchronizedAreNotFences {\n+public class AdvancedJMM_12_SynchronizedAreNotFences {\n@@ -40,1 +40,1 @@\n-            $ java -jar jcstress-samples\/target\/jcstress.jar -t AdvancedJMM_11_SynchronizedAreNotFences\n+            $ java -jar jcstress-samples\/target\/jcstress.jar -t AdvancedJMM_12_SynchronizedAreNotFences\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/jmm\/advanced\/AdvancedJMM_12_SynchronizedAreNotFences.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/jmm\/advanced\/AdvancedJMM_11_SynchronizedAreNotFences.java","status":"renamed"},{"patch":"@@ -37,1 +37,1 @@\n-public class AdvancedJMM_12_VolatilesAreNotFences {\n+public class AdvancedJMM_13_VolatilesAreNotFences {\n@@ -41,1 +41,1 @@\n-            $ java -jar jcstress-samples\/target\/jcstress.jar -t AdvancedJMM_12_VolatilesAreNotFences[.SubTestName]\n+            $ java -jar jcstress-samples\/target\/jcstress.jar -t AdvancedJMM_13_VolatilesAreNotFences[.SubTestName]\n@@ -47,1 +47,1 @@\n-        Similarly to AdvancedJMM_11_SynchronizedAreNotFences example, the volatile accesses cannot be reliably\n+        Similarly to AdvancedJMM_12_SynchronizedAreNotFences example, the volatile accesses cannot be reliably\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/jmm\/advanced\/AdvancedJMM_13_VolatilesAreNotFences.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/jmm\/advanced\/AdvancedJMM_12_VolatilesAreNotFences.java","status":"renamed"},{"patch":"@@ -46,3 +46,2 @@\n-        Java Memory Model prohibits word tearing. That is, it requires that\n-        every field and array element as distinct, and the operations for one\n-        element should not disturb others.\n+        Java Memory Model prohibits word tearing. That is, it requires that every field and array element\n+        as distinct, and the operations for one element should not disturb others.\n@@ -50,5 +49,4 @@\n-        Note this is a bit different from access atomicity. Access atomicity says\n-        that the accesses to a _wide_ logical field should be atomic, even if it\n-        requires several _narrower_ physical accesses. Prohibited word tearing\n-        means the accesses to a _narrow_ logical field should not disturb the\n-        adjacent fields, even if done with a _wider_ physical access.\n+        Note this is a bit different from access atomicity. Access atomicity says that the accesses to\n+        a _wide_ logical field should be atomic, even if it requires several _narrower_ physical accesses.\n+        Prohibited word tearing means the accesses to a _narrow_ logical field should not disturb the adjacent\n+        fields, even if done with a _wider_ physical access.\n@@ -89,4 +87,3 @@\n-        However, while that requirement is enforced for fields and array elements, the\n-        Java classes implementations may still violate this requirement, if, say, they\n-        pack elements densely, and read\/write adjacent elements routinely. The usual\n-        example of this is java.util.BitSet.\n+        However, while that requirement is enforced for fields and array elements, the Java classes\n+        implementations may still violate this requirement, if, say, they pack elements densely, and\n+        read\/write adjacent elements routinely. The usual example of this is java.util.BitSet.\n@@ -142,1 +139,1 @@\n-        For example, this test passes on ARM32 (that does not have byte-wide CASes). The test verifies\n+        For example, this test passes on ARM32, that does not have byte-wide CASes. The test verifies\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/jmm\/basic\/BasicJMM_03_WordTearing.java","additions":10,"deletions":13,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -151,2 +151,1 @@\n-         Indeed, in all configurations, we shall see zero samples for the now forbidden\n-         test case.\n+         Indeed, in all configurations, we shall see zero samples for the now forbidden test case.\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/jmm\/basic\/BasicJMM_06_Causality.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -48,4 +48,3 @@\n-        Another property comes for the inter-thread semantics deals not with\n-        partial, but total order. In JMM, synchronization order mandates that\n-        special \"synchronization\" actions always form a total order, consistent\n-        with program order.\n+        Another property comes for the inter-thread semantics deals not with partial, but total order.\n+        In JMM, synchronization order mandates that special \"synchronization\" actions always form a total\n+        order, consistent with program order.\n@@ -53,2 +52,2 @@\n-        The most famous example that needs total order of operation is Dekker\n-        idiom, the building block of Dekker lock.\n+        The most famous example that needs total order of operation is Dekker idiom, the building block\n+        of Dekker lock.\n@@ -88,3 +87,2 @@\n-        Adding volatile to both $x and $y bring them together into synchronization order,\n-        and thus require the results to be consistent with the case when reads\/writes\n-        form a total order.\n+        Adding volatile to both $x and $y bring them together into synchronization order, and thus require\n+        the results to be consistent with the case when reads\/writes form a total order.\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/jmm\/basic\/BasicJMM_07_Consensus.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"}]}