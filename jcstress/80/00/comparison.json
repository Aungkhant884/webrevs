{"files":[{"patch":"@@ -47,1 +47,1 @@\n-            $ java -jar jcstress-samples\/target\/jcstress.jar -t AdvancedJMM_01\n+            $ java -jar jcstress-samples\/target\/jcstress.jar -t AdvancedJMM_01_SynchronizedBarriers\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/jmm\/advanced\/AdvancedJMM_01_SynchronizedBarriers.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,279 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.jcstress.samples.jmm.advanced;\n-\n-import org.openjdk.jcstress.annotations.Actor;\n-import org.openjdk.jcstress.annotations.JCStressTest;\n-import org.openjdk.jcstress.annotations.Outcome;\n-import org.openjdk.jcstress.annotations.State;\n-import org.openjdk.jcstress.infra.results.IIII_Result;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-\n-import static org.openjdk.jcstress.annotations.Expect.*;\n-import static org.openjdk.jcstress.util.UnsafeHolder.UNSAFE;\n-\n-public class AdvancedJMM_02_MemorySynchronicity {\n-\n-    \/*\n-        How to run this test:\n-            $ java -jar jcstress-samples\/target\/jcstress.jar -t AdvancedJMM_02_MemorySynchronicity[.SubTestName]\n-     *\/\n-\n-    \/*\n-      ----------------------------------------------------------------------------------------------------------\n-\n-        Another interesting quirk that comes from wrong intuition is the belief that once values hit the\n-        memory\/barriers they would be globally exposed to the rest of the system. That is not necessarily\n-        true, because not all hardware provides the interesting property: multi-copy atomicity.\n-\n-        Multi-copy atomicity is \"either the new value is visible to all processors, or no processor sees it\".\n-        That is, multi-copy atomicity means the update to the single location is \"instantaneously\" visible\n-        to all processors in the system. To test this property, we can perform the \"Independent Reads of\n-        Independent Writes\" test. Doing this test with \"opaque\" accesses targets the underlying hardware,\n-        rather than optimizing compilers.\n-\n-        IRIW detects whether the independent writes to \"x\" and \"y\" are seen in different orders by two\n-        other workers.\n-\n-        On x86_64 -- that is multi-copy atomic architecture -- this test yields:\n-\n-              RESULT         SAMPLES     FREQ       EXPECT  DESCRIPTION\n-          0, 0, 0, 0   1,018,009,462    3.39%   Acceptable  Boring\n-          0, 0, 0, 1     192,218,036    0.64%   Acceptable  Boring\n-          0, 0, 1, 0     188,848,400    0.63%   Acceptable  Boring\n-          0, 0, 1, 1     726,013,966    2.42%   Acceptable  Boring\n-          0, 1, 0, 0     229,095,909    0.76%   Acceptable  Boring\n-          0, 1, 0, 1         610,683   <0.01%   Acceptable  Boring\n-          0, 1, 1, 0   2,968,164,366    9.88%   Acceptable  Boring\n-          0, 1, 1, 1   1,280,404,610    4.26%   Acceptable  Boring\n-          1, 0, 0, 0     164,642,284    0.55%   Acceptable  Boring\n-          1, 0, 0, 1   2,762,782,477    9.19%   Acceptable  Boring\n-          1, 0, 1, 0               0    0.00%  Interesting  Whoa\n-          1, 0, 1, 1   1,080,270,592    3.59%   Acceptable  Boring\n-          1, 1, 0, 0     793,200,776    2.64%   Acceptable  Boring\n-          1, 1, 0, 1   1,282,983,565    4.27%   Acceptable  Boring\n-          1, 1, 1, 0   1,248,633,288    4.15%   Acceptable  Boring\n-          1, 1, 1, 1  16,117,960,946   53.63%   Acceptable  Boring\n-\n-        But on PPC64 -- that is not a multi-copy atomic architecture -- this test yields:\n-\n-              RESULT      SAMPLES     FREQ       EXPECT  DESCRIPTION\n-          0, 0, 0, 0    8,000,004    0.78%   Acceptable  Boring\n-          0, 0, 0, 1    1,464,110    0.14%   Acceptable  Boring\n-          0, 0, 1, 0    1,179,814    0.12%   Acceptable  Boring\n-          0, 0, 1, 1   41,275,652    4.03%   Acceptable  Boring\n-          0, 1, 0, 0    1,038,437    0.10%   Acceptable  Boring\n-          0, 1, 0, 1       60,198   <0.01%   Acceptable  Boring\n-          0, 1, 1, 0    5,957,811    0.58%   Acceptable  Boring\n-          0, 1, 1, 1   19,326,879    1.88%   Acceptable  Boring\n-          1, 0, 0, 0      999,321    0.10%   Acceptable  Boring\n-          1, 0, 0, 1    6,711,610    0.65%   Acceptable  Boring\n-          1, 0, 1, 0       28,752   <0.01%  Interesting  Whoa\n-          1, 0, 1, 1   19,428,477    1.89%   Acceptable  Boring\n-          1, 1, 0, 0   21,080,890    2.06%   Acceptable  Boring\n-          1, 1, 0, 1   17,442,987    1.70%   Acceptable  Boring\n-          1, 1, 1, 0   15,403,205    1.50%   Acceptable  Boring\n-          1, 1, 1, 1  865,916,157   84.45%   Acceptable  Boring\n-     *\/\n-\n-    @JCStressTest\n-    @Outcome(id = \"1, 0, 1, 0\", expect = ACCEPTABLE_INTERESTING, desc = \"Whoa\")\n-    @Outcome(                   expect = ACCEPTABLE,             desc = \"Boring\")\n-    @State\n-    public static class OpaqueIRIW {\n-\n-        static final VarHandle VH_X, VH_Y;\n-\n-        static {\n-            try {\n-                VH_X = MethodHandles.lookup().findVarHandle(OpaqueIRIW.class, \"x\", int.class);\n-                VH_Y = MethodHandles.lookup().findVarHandle(OpaqueIRIW.class, \"y\", int.class);\n-            } catch (NoSuchFieldException | IllegalAccessException e) {\n-                throw new IllegalStateException(e);\n-            }\n-        }\n-\n-        public int x;\n-        public int y;\n-\n-        @Actor\n-        public void actor1() {\n-            VH_X.setOpaque(this, 1);\n-        }\n-\n-        @Actor\n-        public void actor2() {\n-            VH_Y.setOpaque(this, 1);\n-        }\n-\n-        @Actor\n-        public void actor3(IIII_Result r) {\n-            r.r1 = (int) VH_X.getOpaque(this);\n-            r.r2 = (int) VH_Y.getOpaque(this);\n-        }\n-\n-        @Actor\n-        public void actor4(IIII_Result r) {\n-            r.r3 = (int) VH_Y.getOpaque(this);\n-            r.r4 = (int) VH_X.getOpaque(this);\n-        }\n-    }\n-\n-    \/*\n-      ----------------------------------------------------------------------------------------------------------\n-\n-        To see why this is not a vanilla memory reordering, we can put fences around the critical accesses.\n-        If we follow the \"usual\" fencing around the seqc\n-\n-\n-PPC64:\n-      RESULT      SAMPLES     FREQ       EXPECT  DESCRIPTION\n-  0, 0, 0, 0  116,646,109   22.21%   Acceptable  Boring\n-  0, 0, 0, 1   19,589,207    3.73%   Acceptable  Boring\n-  0, 0, 1, 0   13,989,162    2.66%   Acceptable  Boring\n-  0, 0, 1, 1   22,118,188    4.21%   Acceptable  Boring\n-  0, 1, 0, 0   16,780,917    3.20%   Acceptable  Boring\n-  0, 1, 0, 1       44,960   <0.01%   Acceptable  Boring\n-  0, 1, 1, 0   54,578,089   10.39%   Acceptable  Boring\n-  0, 1, 1, 1    3,448,588    0.66%   Acceptable  Boring\n-  1, 0, 0, 0   15,474,140    2.95%   Acceptable  Boring\n-  1, 0, 0, 1   63,265,053   12.05%   Acceptable  Boring\n-  1, 0, 1, 0        2,151   <0.01%  Interesting  Whoa\n-  1, 0, 1, 1    2,820,992    0.54%   Acceptable  Boring\n-  1, 1, 0, 0   33,421,547    6.36%   Acceptable  Boring\n-  1, 1, 0, 1   10,101,731    1.92%   Acceptable  Boring\n-  1, 1, 1, 0    9,358,080    1.78%   Acceptable  Boring\n-  1, 1, 1, 1  143,471,870   27.32%   Acceptable  Boring\n-     *\/\n-\n-    @JCStressTest\n-    @Outcome(id = \"1, 0, 1, 0\", expect = ACCEPTABLE_INTERESTING, desc = \"Whoa\")\n-    @Outcome(                   expect = ACCEPTABLE,             desc = \"Boring\")\n-    @State\n-    public static class FencedIRIWTest {\n-\n-        public int x;\n-        public int y;\n-\n-        @Actor\n-        public void actor1() {\n-            UNSAFE.fullFence(); \/\/ \"SeqCst\" store\n-            x = 1;\n-        }\n-\n-        @Actor\n-        public void actor2() {\n-            UNSAFE.fullFence(); \/\/ \"SeqCst\" store\n-            y = 1;\n-        }\n-\n-        @Actor\n-        public void actor3(IIII_Result r) {\n-            r.r1 = x;\n-            UNSAFE.loadFence(); \/\/ \"SeqCst\" load x\n-            r.r2 = y;\n-            UNSAFE.loadFence(); \/\/ \"SeqCst\" load y\n-        }\n-\n-        @Actor\n-        public void actor4(IIII_Result r) {\n-            r.r3 = y;\n-            UNSAFE.loadFence(); \/\/ \"SeqCst\" load y\n-            r.r4 = x;\n-            UNSAFE.loadFence(); \/\/ \"SeqCst\" load x\n-        }\n-\n-    }\n-\n-    \/*\n-      ----------------------------------------------------------------------------------------------------------\n-\n-        To see why this is not a vanilla memory reordering, we can put fences around the critical accesses.\n-        If we follow the \"usual\" fencing around the seqc\n-\n-PPC64:\n-      RESULT      SAMPLES     FREQ       EXPECT  DESCRIPTION\n-  0, 0, 0, 0    3,162,682    0.63%   Acceptable  Boring\n-  0, 0, 0, 1      420,692    0.08%   Acceptable  Boring\n-  0, 0, 1, 0       49,183   <0.01%   Acceptable  Boring\n-  0, 0, 1, 1   17,923,289    3.55%   Acceptable  Boring\n-  0, 1, 0, 0      344,895    0.07%   Acceptable  Boring\n-  0, 1, 0, 1       58,153    0.01%   Acceptable  Boring\n-  0, 1, 1, 0      703,765    0.14%   Acceptable  Boring\n-  0, 1, 1, 1   17,055,833    3.38%   Acceptable  Boring\n-  1, 0, 0, 0       55,722    0.01%   Acceptable  Boring\n-  1, 0, 0, 1      926,450    0.18%   Acceptable  Boring\n-  1, 0, 1, 0            0    0.00%  Interesting  Whoa\n-  1, 0, 1, 1   15,951,198    3.16%   Acceptable  Boring\n-  1, 1, 0, 0   15,055,385    2.98%   Acceptable  Boring\n-  1, 1, 0, 1   23,580,682    4.67%   Acceptable  Boring\n-  1, 1, 1, 0   20,358,942    4.03%   Acceptable  Boring\n-  1, 1, 1, 1  389,383,273   77.10%   Acceptable  Boring\n-     *\/\n-\n-    @JCStressTest\n-    @Outcome(id = \"1, 0, 1, 0\", expect = ACCEPTABLE_INTERESTING, desc = \"Whoa\")\n-    @Outcome(                   expect = ACCEPTABLE,             desc = \"Boring\")\n-    @State\n-    public static class FullyFencedIRIWTest {\n-\n-        public int x;\n-        public int y;\n-\n-        @Actor\n-        public void actor1() {\n-            UNSAFE.fullFence(); \/\/ \"SeqCst\" store\n-            x = 1;\n-        }\n-\n-        @Actor\n-        public void actor2() {\n-            UNSAFE.fullFence(); \/\/ \"SeqCst\" store\n-            y = 1;\n-        }\n-\n-        @Actor\n-        public void actor3(IIII_Result r) {\n-            UNSAFE.fullFence(); \/\/ \"SeqCst\" load x, part 1\n-            r.r1 = x;\n-            UNSAFE.fullFence(); \/\/ \"SeqCst\" load x, part 2 (subsumed); \"SeqCst\" load y, part 1\n-            r.r2 = y;\n-            UNSAFE.loadFence(); \/\/ \"SeqCst\" load y, part 2\n-        }\n-\n-        @Actor\n-        public void actor4(IIII_Result r) {\n-            UNSAFE.fullFence();\n-            r.r3 = y;\n-            UNSAFE.fullFence(); \/\/ subsumes loadFence\n-            r.r4 = x;\n-            UNSAFE.loadFence();\n-        }\n-\n-    }\n-\n-}\n\\ No newline at end of file\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/jmm\/advanced\/AdvancedJMM_02_MemorySynchronicity.java","additions":0,"deletions":279,"binary":false,"changes":279,"status":"deleted"},{"patch":"@@ -0,0 +1,281 @@\n+\/*\n+ * Copyright (c) 2016, 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jcstress.samples.jmm.advanced;\n+\n+import org.openjdk.jcstress.annotations.Actor;\n+import org.openjdk.jcstress.annotations.JCStressTest;\n+import org.openjdk.jcstress.annotations.Outcome;\n+import org.openjdk.jcstress.annotations.State;\n+import org.openjdk.jcstress.infra.results.IIII_Result;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+\n+import static org.openjdk.jcstress.annotations.Expect.*;\n+import static org.openjdk.jcstress.util.UnsafeHolder.UNSAFE;\n+\n+public class AdvancedJMM_02_MultiCopyAtomic {\n+\n+    \/*\n+        How to run this test:\n+            $ java -jar jcstress-samples\/target\/jcstress.jar -t AdvancedJMM_02_MultiCopyAtomic[.SubTestName]\n+     *\/\n+\n+    \/*\n+      ----------------------------------------------------------------------------------------------------------\n+\n+        Another interesting quirk that comes from wrong intuition is the belief that once values hit the\n+        memory\/barriers they would be globally exposed to the rest of the system. That is not necessarily\n+        true, because not all hardware provides the interesting property: multi-copy atomicity.\n+\n+        Multi-copy atomicity is \"either the new value is visible to all processors, or no processor sees it\".\n+        That is, multi-copy atomicity means the update to the single location is \"instantaneously\" visible\n+        to all processors in the system. To test this property, we can perform the \"Independent Reads of\n+        Independent Writes\" test. Doing this test with \"opaque\" accesses targets the underlying hardware,\n+        rather than optimizing compilers.\n+\n+        IRIW detects whether the independent writes to \"x\" and \"y\" are seen in different orders by two\n+        other workers.\n+\n+        On x86_64 -- that is multi-copy atomic architecture -- this test yields:\n+\n+              RESULT         SAMPLES     FREQ       EXPECT  DESCRIPTION\n+          0, 0, 0, 0   1,018,009,462    3.39%   Acceptable  Boring\n+          0, 0, 0, 1     192,218,036    0.64%   Acceptable  Boring\n+          0, 0, 1, 0     188,848,400    0.63%   Acceptable  Boring\n+          0, 0, 1, 1     726,013,966    2.42%   Acceptable  Boring\n+          0, 1, 0, 0     229,095,909    0.76%   Acceptable  Boring\n+          0, 1, 0, 1         610,683   <0.01%   Acceptable  Boring\n+          0, 1, 1, 0   2,968,164,366    9.88%   Acceptable  Boring\n+          0, 1, 1, 1   1,280,404,610    4.26%   Acceptable  Boring\n+          1, 0, 0, 0     164,642,284    0.55%   Acceptable  Boring\n+          1, 0, 0, 1   2,762,782,477    9.19%   Acceptable  Boring\n+          1, 0, 1, 0               0    0.00%  Interesting  Whoa\n+          1, 0, 1, 1   1,080,270,592    3.59%   Acceptable  Boring\n+          1, 1, 0, 0     793,200,776    2.64%   Acceptable  Boring\n+          1, 1, 0, 1   1,282,983,565    4.27%   Acceptable  Boring\n+          1, 1, 1, 0   1,248,633,288    4.15%   Acceptable  Boring\n+          1, 1, 1, 1  16,117,960,946   53.63%   Acceptable  Boring\n+\n+        But on PPC64 -- that is not a multi-copy atomic architecture -- this test yields:\n+\n+              RESULT        SAMPLES     FREQ       EXPECT  DESCRIPTION\n+          0, 0, 0, 0     37,176,296    0.64%   Acceptable  Boring\n+          0, 0, 0, 1      9,400,698    0.16%   Acceptable  Boring\n+          0, 0, 1, 0      7,820,972    0.13%   Acceptable  Boring\n+          0, 0, 1, 1    264,268,403    4.54%   Acceptable  Boring\n+          0, 1, 0, 0      6,000,722    0.10%   Acceptable  Boring\n+          0, 1, 0, 1        285,037   <0.01%   Acceptable  Boring\n+          0, 1, 1, 0     33,201,729    0.57%   Acceptable  Boring\n+          0, 1, 1, 1    119,718,218    2.05%   Acceptable  Boring\n+          1, 0, 0, 0      5,952,891    0.10%   Acceptable  Boring\n+          1, 0, 0, 1     42,960,279    0.74%   Acceptable  Boring\n+          1, 0, 1, 0        144,597   <0.01%  Interesting  Whoa\n+          1, 0, 1, 1    111,705,898    1.92%   Acceptable  Boring\n+          1, 1, 0, 0    149,136,163    2.56%   Acceptable  Boring\n+          1, 1, 0, 1    108,356,855    1.86%   Acceptable  Boring\n+          1, 1, 1, 0    100,533,303    1.73%   Acceptable  Boring\n+          1, 1, 1, 1  4,829,074,643   82.89%   Acceptable  Boring\n+     *\/\n+\n+    @JCStressTest\n+    @Outcome(id = \"1, 0, 1, 0\", expect = ACCEPTABLE_INTERESTING, desc = \"Whoa\")\n+    @Outcome(                   expect = ACCEPTABLE,             desc = \"Boring\")\n+    @State\n+    public static class OpaqueIRIW {\n+\n+        static final VarHandle VH_X, VH_Y;\n+\n+        static {\n+            try {\n+                VH_X = MethodHandles.lookup().findVarHandle(OpaqueIRIW.class, \"x\", int.class);\n+                VH_Y = MethodHandles.lookup().findVarHandle(OpaqueIRIW.class, \"y\", int.class);\n+            } catch (NoSuchFieldException | IllegalAccessException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }\n+\n+        public int x;\n+        public int y;\n+\n+        @Actor\n+        public void actor1() {\n+            VH_X.setOpaque(this, 1);\n+        }\n+\n+        @Actor\n+        public void actor2() {\n+            VH_Y.setOpaque(this, 1);\n+        }\n+\n+        @Actor\n+        public void actor3(IIII_Result r) {\n+            r.r1 = (int) VH_X.getOpaque(this);\n+            r.r2 = (int) VH_Y.getOpaque(this);\n+        }\n+\n+        @Actor\n+        public void actor4(IIII_Result r) {\n+            r.r3 = (int) VH_Y.getOpaque(this);\n+            r.r4 = (int) VH_X.getOpaque(this);\n+        }\n+    }\n+\n+    \/*\n+      ----------------------------------------------------------------------------------------------------------\n+\n+        To see why this is not a vanilla memory reordering, we can put fences around the critical accesses.\n+        If we follow the \"usual\" fencing around the accesses, it would not help on non-multi-copy-atomic\n+        platforms. Even though we stick all accesses in their places, and prevent reads going one over the\n+        other, the asynchronous nature of memory updates would manifest on some platforms.\n+\n+        PPC64:\n+              RESULT      SAMPLES     FREQ       EXPECT  DESCRIPTION\n+          0, 0, 0, 0  626,124,064   22.51%   Acceptable  Boring\n+          0, 0, 0, 1  100,592,056    3.62%   Acceptable  Boring\n+          0, 0, 1, 0   86,443,974    3.11%   Acceptable  Boring\n+          0, 0, 1, 1  117,149,197    4.21%   Acceptable  Boring\n+          0, 1, 0, 0  102,075,205    3.67%   Acceptable  Boring\n+          0, 1, 0, 1      270,587   <0.01%   Acceptable  Boring\n+          0, 1, 1, 0  278,452,698   10.01%   Acceptable  Boring\n+          0, 1, 1, 1   18,548,574    0.67%   Acceptable  Boring\n+          1, 0, 0, 0   96,280,543    3.46%   Acceptable  Boring\n+          1, 0, 0, 1  311,153,395   11.19%   Acceptable  Boring\n+          1, 0, 1, 0        7,599   <0.01%  Interesting  Whoa\n+          1, 0, 1, 1   14,614,329    0.53%   Acceptable  Boring\n+          1, 1, 0, 0  195,921,897    7.04%   Acceptable  Boring\n+          1, 1, 0, 1   52,391,418    1.88%   Acceptable  Boring\n+          1, 1, 1, 0   42,992,478    1.55%   Acceptable  Boring\n+          1, 1, 1, 1  738,325,730   26.55%   Acceptable  Boring\n+     *\/\n+\n+    @JCStressTest\n+    @Outcome(id = \"1, 0, 1, 0\", expect = ACCEPTABLE_INTERESTING, desc = \"Whoa\")\n+    @Outcome(                   expect = ACCEPTABLE,             desc = \"Boring\")\n+    @State\n+    public static class FencedIRIWTest {\n+\n+        public int x;\n+        public int y;\n+\n+        @Actor\n+        public void actor1() {\n+            UNSAFE.fullFence(); \/\/ \"SeqCst\" store\n+            x = 1;\n+        }\n+\n+        @Actor\n+        public void actor2() {\n+            UNSAFE.fullFence(); \/\/ \"SeqCst\" store\n+            y = 1;\n+        }\n+\n+        @Actor\n+        public void actor3(IIII_Result r) {\n+            r.r1 = x;\n+            UNSAFE.loadFence(); \/\/ \"SeqCst\" load x\n+            r.r2 = y;\n+            UNSAFE.loadFence(); \/\/ \"SeqCst\" load y\n+        }\n+\n+        @Actor\n+        public void actor4(IIII_Result r) {\n+            r.r3 = y;\n+            UNSAFE.loadFence(); \/\/ \"SeqCst\" load y\n+            r.r4 = x;\n+            UNSAFE.loadFence(); \/\/ \"SeqCst\" load x\n+        }\n+\n+    }\n+\n+    \/*\n+      ----------------------------------------------------------------------------------------------------------\n+\n+        Depending on the hardware, a more thorough fencing might be required. For example, on PPC64,\n+        we would need to emit a full fence before the sequentially consistent read, if we want to stop\n+        seeing non-MCA behaviors. Indeed, in this test, the interesting cases are gone.\n+\n+        PPC64:\n+              RESULT        SAMPLES     FREQ       EXPECT  DESCRIPTION\n+          0, 0, 0, 0     16,428,729    0.62%   Acceptable  Boring\n+          0, 0, 0, 1      1,054,058    0.04%   Acceptable  Boring\n+          0, 0, 1, 0        219,026   <0.01%   Acceptable  Boring\n+          0, 0, 1, 1     82,801,314    3.11%   Acceptable  Boring\n+          0, 1, 0, 0      2,250,558    0.08%   Acceptable  Boring\n+          0, 1, 0, 1        248,656   <0.01%   Acceptable  Boring\n+          0, 1, 1, 0      3,318,302    0.12%   Acceptable  Boring\n+          0, 1, 1, 1     89,272,976    3.36%   Acceptable  Boring\n+          1, 0, 0, 0        375,410    0.01%   Acceptable  Boring\n+          1, 0, 0, 1      3,598,655    0.14%   Acceptable  Boring\n+          1, 0, 1, 0              0    0.00%  Interesting  Whoa\n+          1, 0, 1, 1     81,560,207    3.07%   Acceptable  Boring\n+          1, 1, 0, 0     94,117,189    3.54%   Acceptable  Boring\n+          1, 1, 0, 1    124,773,490    4.69%   Acceptable  Boring\n+          1, 1, 1, 0    107,590,486    4.05%   Acceptable  Boring\n+          1, 1, 1, 1  2,051,591,968   77.15%   Acceptable  Boring\n+     *\/\n+\n+    @JCStressTest\n+    @Outcome(id = \"1, 0, 1, 0\", expect = ACCEPTABLE_INTERESTING, desc = \"Whoa\")\n+    @Outcome(                   expect = ACCEPTABLE,             desc = \"Boring\")\n+    @State\n+    public static class FullyFencedIRIWTest {\n+\n+        public int x;\n+        public int y;\n+\n+        @Actor\n+        public void actor1() {\n+            UNSAFE.fullFence(); \/\/ \"SeqCst\" store\n+            x = 1;\n+        }\n+\n+        @Actor\n+        public void actor2() {\n+            UNSAFE.fullFence(); \/\/ \"SeqCst\" store\n+            y = 1;\n+        }\n+\n+        @Actor\n+        public void actor3(IIII_Result r) {\n+            UNSAFE.fullFence(); \/\/ \"SeqCst\" load x, part 1\n+            r.r1 = x;\n+            UNSAFE.fullFence(); \/\/ \"SeqCst\" load x, part 2 (subsumed); \"SeqCst\" load y, part 1\n+            r.r2 = y;\n+            UNSAFE.loadFence(); \/\/ \"SeqCst\" load y, part 2\n+        }\n+\n+        @Actor\n+        public void actor4(IIII_Result r) {\n+            UNSAFE.fullFence();\n+            r.r3 = y;\n+            UNSAFE.fullFence(); \/\/ subsumes loadFence\n+            r.r4 = x;\n+            UNSAFE.loadFence();\n+        }\n+\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/jmm\/advanced\/AdvancedJMM_02_MultiCopyAtomic.java","additions":281,"deletions":0,"binary":false,"changes":281,"status":"added"},{"patch":"@@ -40,1 +40,1 @@\n-            $ java -jar jcstress-samples\/target\/jcstress.jar -t AdvancedJMM_03_LosingUpdates[.SubTestName]\n+            $ java -jar jcstress-samples\/target\/jcstress.jar -t AdvancedJMM_04_MisplacedVolatile[.SubTestName]\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/jmm\/advanced\/AdvancedJMM_04_MisplacedVolatile.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-            $ java -jar jcstress-samples\/target\/jcstress.jar -t AdvancedJMM_08_WrongListReleaseOrder[.SubTestName]\n+            $ java -jar jcstress-samples\/target\/jcstress.jar -t AdvancedJMM_08_WrongListReleaseOrder\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/jmm\/advanced\/AdvancedJMM_08_WrongListReleaseOrder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-            $ java -jar jcstress-samples\/target\/jcstress.jar -t AdvancedJMM_12_SynchronizedAreNotFences[.SubTestName]\n+            $ java -jar jcstress-samples\/target\/jcstress.jar -t AdvancedJMM_12_VolatilesAreNotFences[.SubTestName]\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/jmm\/advanced\/AdvancedJMM_12_VolatilesAreNotFences.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,0 @@\n-\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/jmm\/basic\/BasicJMM_01_DataRaces.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-        Recovering the access atomicity is possible with making the field \"volatile\":\n+        Recovering the access atomicity is possible by making the field \"volatile\":\n@@ -197,4 +197,3 @@\n-        While the spec requirements for field and array element accesses are\n-        strict, the implementations of concrete classes may have a relaxed\n-        semantics. Take ByteBuffer where we can read the 4-byte integer from\n-        an arbitrary offset.\n+        While the spec requirements for field and array element accesses are strict, the implementations of\n+        concrete classes may have a relaxed semantics. Take ByteBuffer where we can read the 4-byte integer\n+        from an arbitrary offset.\n@@ -202,7 +201,5 @@\n-        Older ByteBuffer implementations accessed one byte at a time, and that\n-        required merging\/splitting anything larger than a byte into the individual\n-        operations. Of course, there is no access atomicity there by construction.\n-        In newer ByteBuffer implementations, the _aligned_ accesses are done with\n-        larger instructions that gives back atomicity. Misaligned accesses would\n-        still have to do several narrower accesses on machines that don't support\n-        misalignments.\n+        Older ByteBuffer implementations accessed one byte at a time, and that required merging\/splitting\n+        anything larger than a byte into the individual operations. Of course, there is no access atomicity\n+        there by construction. In newer ByteBuffer implementations, the _aligned_ accesses are done with\n+        larger instructions that gives back atomicity. Misaligned accesses would still have to do several\n+        narrower accesses on machines that don't support misalignments.\n@@ -250,3 +247,3 @@\n-        However, even if the misaligned accesses is supported by hardware, it would never\n-        be guaranteed atomic. For example, reading the value that spans two cache-lines would\n-        not be atomic, even if we manage to issue a single instruction for access.\n+        However, even if the misaligned accesses is supported by hardware, it would never be guaranteed atomic.\n+        For example, reading the value that spans two cache-lines would not be atomic, even if we manage to issue\n+        a single instruction for access.\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/jmm\/basic\/BasicJMM_02_AccessAtomicity.java","additions":12,"deletions":15,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -108,3 +108,3 @@\n-        In fact, the overwhelming majority of hardware makes writes eventually visible, so what\n-        we minimally want is to make the accesses opaque to the optimizing compilers. Luckily,\n-        that is simple to do with VarHandles.{set|get}Opaque.\n+        In fact, the overwhelming majority of hardware makes writes eventually visible, so what we minimally\n+        want is to make the accesses opaque to the optimizing compilers. Luckily, that is simple to do with\n+        VarHandles.{set|get}Opaque.\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/jmm\/basic\/BasicJMM_04_Progress.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -48,4 +48,3 @@\n-        Yet another subtle and intuitive property comes from the naive understanding\n-        of how programs work. Under Java Memory Model, in absence of synchronization,\n-        the order of independent reads is undefined. That includes reads of the *same*\n-        variable!\n+        Yet another subtle and intuitive property comes from the naive understanding of how programs work.\n+        Under Java Memory Model, in absence of synchronization, the order of independent reads is undefined.\n+        That includes reads of the *same* variable!\n@@ -104,3 +103,2 @@\n-        The stronger property -- coherence -- mandates that the writes to the same\n-        variable to be observed in a total order (that implies that _observers_ are\n-        also ordered). Java \"volatile\" assumes this property.\n+        The stronger property -- coherence -- mandates that the writes to the same variable to be observed in\n+        a total order (that implies that _observers_ are also ordered). Java \"volatile\" assumes this property.\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/jmm\/basic\/BasicJMM_05_Coherence.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -48,4 +48,3 @@\n-        The next property helps some inter-thread semantics. In JMM, happens-before mandates\n-        what results are plausible and what are not, when non-synchronized reads are involved.\n-        That order is partial, so there are pairs of reads\/writes we can tell nothing about\n-        order-wise.\n+        The next property helps some inter-thread semantics. In JMM, happens-before mandates what results are\n+        plausible and what are not, when non-synchronized reads are involved. That order is partial, so there\n+        are pairs of reads\/writes we can tell nothing about order-wise.\n@@ -146,5 +145,5 @@\n-         The easiest way to solve this is to mark $y as \"volatile\". In this case, JMM would\n-         disallow seeing (1, 0). Volatile write would now be \"release\"-ing write and volatile\n-         read would now be \"acquiring\" read. That means all writes that precede releasing store\n-         would be visible to readers of acquiring read. Note this effect is only guaranteed\n-         if the acquiring read sees the value written by releasing write.\n+         The easiest way to solve this is to mark $y as \"volatile\". In this case, JMM would disallow seeing\n+         (1, 0). Volatile write would now be \"release\"-ing write and volatile read would now be \"acquiring\"\n+         read. That means all writes that precede releasing store would be visible to readers of acquiring\n+         read. Note this effect is only guaranteed if the acquiring read sees the value written by releasing\n+         write.\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/jmm\/basic\/BasicJMM_06_Causality.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-package org.openjdk.jcstress.samples.jmm.advanced;\n+package org.openjdk.jcstress.samples.jmm.basic;\n@@ -35,1 +35,1 @@\n-public class AdvancedJMM_14_BenignRaces {\n+public class BasicJMM_09_BenignRaces {\n@@ -38,1 +38,1 @@\n-            $ java -jar jcstress-samples\/target\/jcstress.jar -t AdvancedJMM_14_BenignRaces[.SubTestName]\n+            $ java -jar jcstress-samples\/target\/jcstress.jar -t BasicJMM_09_BenignRaces[.SubTestName]\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/jmm\/basic\/BasicJMM_09_BenignRaces.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/jmm\/advanced\/AdvancedJMM_14_BenignRaces.java","status":"renamed"},{"patch":"@@ -36,1 +36,1 @@\n-public class BasicJMM_09_OOTA {\n+public class BasicJMM_10_OOTA {\n@@ -40,1 +40,1 @@\n-            $ java -jar jcstress-samples\/target\/jcstress.jar -t BasicJMM_09_OOTA\n+            $ java -jar jcstress-samples\/target\/jcstress.jar -t BasicJMM_10_OOTA\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/jmm\/basic\/BasicJMM_10_OOTA.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/jmm\/basic\/BasicJMM_09_OOTA.java","status":"renamed"}]}