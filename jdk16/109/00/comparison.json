{"files":[{"patch":"@@ -796,1 +796,1 @@\n-                    return new HeapByteBuffer(hb, offset, capacity, segment);\n+                    return new HeapByteBuffer(hb, -1, 0, capacity, capacity, offset, segment);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Buffer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+import java.util.Iterator;\n@@ -74,0 +75,1 @@\n+import java.util.function.Supplier;\n@@ -638,1 +640,2 @@\n-    public void testIOOnClosedConfinedSegment() throws IOException {\n+    @Test\n+    public void testIOOnConfinedSegment() throws IOException {\n@@ -651,0 +654,25 @@\n+    @Test(dataProvider=\"segments\")\n+    public void buffersAndArraysFromSlices(Supplier<MemorySegment> segmentSupplier) {\n+        try (MemorySegment segment = segmentSupplier.get()) {\n+            int newSize = 8;\n+            var slice = segment.asSlice(4, newSize);\n+\n+            var bytes = slice.toByteArray();\n+            assertEquals(newSize, bytes.length);\n+\n+            var buffer = slice.asByteBuffer();\n+            \/\/ Fails for heap segments, but passes for native segments:\n+            assertEquals(0, buffer.position());\n+            assertEquals(newSize, buffer.limit());\n+            assertEquals(newSize, buffer.capacity());\n+        }\n+    }\n+\n+    @DataProvider(name = \"segments\")\n+    public static Object[][] segments() throws Throwable {\n+        return new Object[][] {\n+                { (Supplier<MemorySegment>) () -> MemorySegment.allocateNative(16) },\n+                { (Supplier<MemorySegment>) () -> MemorySegment.ofArray(new byte[16]) }\n+        };\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"}]}