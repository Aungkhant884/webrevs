{"files":[{"patch":"@@ -2066,1 +2066,1 @@\n-        BranchConn branchConn = null;\n+        Node branchConn = null;\n@@ -2214,18 +2214,1 @@\n-            if (node instanceof LineEnding) {\n-                LineEnding le = (LineEnding)node;\n-                node = closureOfLineEnding(le);\n-\n-                if (node != le) {\n-                    \/\/ LineEnding was replaced with an anonymous group\n-                    if (head == null)\n-                        head = node;\n-                    else\n-                        tail.next = node;\n-                    \/\/ Double return: Tail was returned in root\n-                    tail = root;\n-                    continue;\n-                }\n-            } else {\n-                node = closure(node);\n-            }\n-\n+            node = closure(node);\n@@ -3099,13 +3082,0 @@\n-        return groupWithClosure(node, head, tail, capturingGroup);\n-    }\n-\n-    \/**\n-     * Transforms a Group with quantifiers into some special constructs\n-     * (such as Branch or Loop\/GroupCurly), if necessary.\n-     *\n-     * This method is applied either to actual groups or to the Unicode\n-     * linebreak (aka \\\\R) represented as an anonymous group.\n-     *\/\n-    private Node groupWithClosure(Node node, Node head, Node tail,\n-                                  boolean capturingGroup)\n-    {\n@@ -3118,2 +3088,2 @@\n-            BranchConn branchConn = new BranchConn();\n-            tail = tail.next = branchConn;\n+            tail.next = new BranchConn();\n+            tail = tail.next;\n@@ -3121,1 +3091,1 @@\n-                head = new Branch(head, null, branchConn);\n+                head = new Branch(head, null, tail);\n@@ -3123,1 +3093,1 @@\n-                head = new Branch(null, head, branchConn);\n+                head = new Branch(null, head, tail);\n@@ -3300,25 +3270,0 @@\n-    \/**\n-     * Processing repetition of a Unicode linebreak \\\\R.\n-     *\/\n-    private Node closureOfLineEnding(LineEnding le) {\n-        int ch = peek();\n-        if (ch != '?' && ch != '*' && ch != '+' && ch != '{') {\n-            return le;\n-        }\n-\n-        \/\/ Replace the LineEnding with an anonymous group\n-        \/\/ (?:\\\\u000D\\\\u000A|[\\\\u000A\\\\u000B\\\\u000C\\\\u000D\\\\u0085\\\\u2028\\\\u2029])\n-        Node grHead = createGroup(true);\n-        Node grTail = root;\n-        BranchConn branchConn = new BranchConn();\n-        branchConn.next = grTail;\n-        Node slice = new Slice(new int[] {0x0D, 0x0A});\n-        slice.next = branchConn;\n-        Node chClass = newCharProperty(x -> x == 0x0A || x == 0x0B ||\n-                x == 0x0C || x == 0x0D || x == 0x85 || x == 0x2028 ||\n-                x == 0x2029);\n-        chClass.next = branchConn;\n-        grHead.next = new Branch(slice, chClass, branchConn);\n-        return groupWithClosure(closure(grHead), grHead, grTail, false);\n-    }\n-\n@@ -4780,2 +4725,2 @@\n-        BranchConn conn;\n-        Branch(Node first, Node second, BranchConn branchConn) {\n+        Node conn;\n+        Branch(Node first, Node second, Node branchConn) {\n@@ -4789,4 +4734,3 @@\n-                int len = ArraysSupport.newLength(size,\n-                        1,    \/* minimum growth *\/\n-                        size  \/* preferred growth *\/);\n-                atoms = Arrays.copyOf(atoms, len);\n+                Node[] tmp = new Node[atoms.length*2];\n+                System.arraycopy(atoms, 0, tmp, 0, atoms.length);\n+                atoms = tmp;\n","filename":"src\/java.base\/share\/classes\/java\/util\/regex\/Pattern.java","additions":11,"deletions":67,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * 8216332 8214245 8237599 8241055 8247546\n+ * 8216332 8214245 8237599 8241055 8247546 8258259\n@@ -5066,1 +5066,9 @@\n-    \/\/ This test is for 8235812\n+    private static String s2x(String s) {\n+        StringBuilder sb = new StringBuilder();\n+        for (char ch : s.toCharArray()) {\n+            sb.append(String.format(\"\\\\u%04x\", (int)ch));\n+        }\n+        return sb.toString();\n+    }\n+\n+    \/\/ This test is for 8235812, with cases excluded by 8258259\n@@ -5076,2 +5084,2 @@\n-            Map.entry(\"\\\\R{2}\",    List.of(2)),\n-            Map.entry(\"\\\\R{3}\",    List.of(3)),\n+\/\/          Map.entry(\"\\\\R{2}\",    List.of(2)),            \/\/ 8258259\n+\/\/          Map.entry(\"\\\\R{3}\",    List.of(3)),            \/\/ 8258259\n@@ -5080,2 +5088,2 @@\n-            Map.entry(\"\\\\R{2,}\",   List.of(2, 3)),\n-            Map.entry(\"\\\\R{3,}\",   List.of(3)),\n+\/\/          Map.entry(\"\\\\R{2,}\",   List.of(2, 3)),         \/\/ 8258259\n+\/\/          Map.entry(\"\\\\R{3,}\",   List.of(3)),            \/\/ 8258259\n@@ -5089,3 +5097,3 @@\n-            Map.entry(\"\\\\R{2,2}\",  List.of(2)),\n-            Map.entry(\"\\\\R{2,3}\",  List.of(2, 3)),\n-            Map.entry(\"\\\\R{3,3}\",  List.of(3)),\n+\/\/          Map.entry(\"\\\\R{2,2}\",  List.of(2)),            \/\/ 8258259\n+\/\/          Map.entry(\"\\\\R{2,3}\",  List.of(2, 3)),         \/\/ 8258259\n+\/\/          Map.entry(\"\\\\R{3,3}\",  List.of(3)),            \/\/ 8258259\n@@ -5134,1 +5142,1 @@\n-                                    in + \"' =~ \/\" + p + \"\/\");\n+                                    s2x(in) + \"' =~ \/\" + p + \"\/\");\n","filename":"test\/jdk\/java\/util\/regex\/RegExTest.java","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"}]}