{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.util.Arrays;\n@@ -350,0 +351,2 @@\n+        byte[] paddingCopy = null;\n+        byte[] result = null;\n@@ -351,1 +354,0 @@\n-            byte[] data;\n@@ -354,2 +356,3 @@\n-                data = padding.pad(buffer, 0, bufOfs);\n-                return RSACore.rsa(data, privateKey, true);\n+                paddingCopy = padding.pad(buffer, 0, bufOfs);\n+                result = RSACore.rsa(paddingCopy, privateKey, true);\n+                break;\n@@ -358,2 +361,3 @@\n-                data = RSACore.rsa(verifyBuffer, publicKey);\n-                return padding.unpad(data);\n+                paddingCopy = RSACore.rsa(verifyBuffer, publicKey);\n+                result = padding.unpad(paddingCopy);\n+                break;\n@@ -361,2 +365,3 @@\n-                data = padding.pad(buffer, 0, bufOfs);\n-                return RSACore.rsa(data, publicKey);\n+                paddingCopy = padding.pad(buffer, 0, bufOfs);\n+                result = RSACore.rsa(paddingCopy, publicKey);\n+                break;\n@@ -365,2 +370,3 @@\n-                data = RSACore.rsa(decryptBuffer, privateKey, false);\n-                return padding.unpad(data);\n+                paddingCopy = RSACore.rsa(decryptBuffer, privateKey, false);\n+                result = padding.unpad(paddingCopy);\n+                break;\n@@ -370,0 +376,1 @@\n+            return result;\n@@ -371,0 +378,1 @@\n+            Arrays.fill(buffer, 0, bufOfs, (byte)0);\n@@ -372,0 +380,5 @@\n+            if (paddingCopy != null             \/\/ will not happen\n+                    && paddingCopy != buffer    \/\/ already cleaned\n+                    && paddingCopy != result) { \/\/ DO NOT CLEAN, THIS IS RESULT!\n+                Arrays.fill(paddingCopy, (byte)0);\n+            }\n@@ -407,0 +420,1 @@\n+        Arrays.fill(result, (byte)0);\n@@ -417,4 +431,0 @@\n-        if (encoded.length > buffer.length) {\n-            throw new InvalidKeyException(\"Key is too long for wrapping\");\n-        }\n-        update(encoded, 0, encoded.length);\n@@ -422,4 +432,12 @@\n-            return doFinal();\n-        } catch (BadPaddingException e) {\n-            \/\/ should not occur\n-            throw new InvalidKeyException(\"Wrapping failed\", e);\n+            if (encoded.length > buffer.length) {\n+                throw new InvalidKeyException(\"Key is too long for wrapping\");\n+            }\n+            update(encoded, 0, encoded.length);\n+            try {\n+                return doFinal();\n+            } catch (BadPaddingException e) {\n+                \/\/ should not occur\n+                throw new InvalidKeyException(\"Wrapping failed\", e);\n+            }\n+        } finally {\n+            Arrays.fill(encoded, (byte)0);\n@@ -456,4 +474,12 @@\n-        if (isTlsRsaPremasterSecret) {\n-            if (!(spec instanceof TlsRsaPremasterSecretParameterSpec)) {\n-                throw new IllegalStateException(\n-                        \"No TlsRsaPremasterSecretParameterSpec specified\");\n+        try {\n+            if (isTlsRsaPremasterSecret) {\n+                if (!(spec instanceof TlsRsaPremasterSecretParameterSpec)) {\n+                    throw new IllegalStateException(\n+                            \"No TlsRsaPremasterSecretParameterSpec specified\");\n+                }\n+\n+                \/\/ polish the TLS premaster secret\n+                encoded = KeyUtil.checkTlsPreMasterSecretKey(\n+                        ((TlsRsaPremasterSecretParameterSpec) spec).getClientVersion(),\n+                        ((TlsRsaPremasterSecretParameterSpec) spec).getServerVersion(),\n+                        random, encoded, (failover != null));\n@@ -462,5 +488,5 @@\n-            \/\/ polish the TLS premaster secret\n-            encoded = KeyUtil.checkTlsPreMasterSecretKey(\n-                ((TlsRsaPremasterSecretParameterSpec)spec).getClientVersion(),\n-                ((TlsRsaPremasterSecretParameterSpec)spec).getServerVersion(),\n-                random, encoded, (failover != null));\n+            return ConstructKeys.constructKey(encoded, algorithm, type);\n+        } finally {\n+            if (encoded != null) {\n+                Arrays.fill(encoded, (byte) 0);\n+            }\n@@ -468,2 +494,0 @@\n-\n-        return ConstructKeys.constructKey(encoded, algorithm, type);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/RSACipher.java","additions":53,"deletions":29,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -234,0 +234,1 @@\n+            Arrays.fill(b, (byte)0);\n@@ -240,0 +241,1 @@\n+        Arrays.fill(b, (byte)0);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSACore.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -241,3 +241,2 @@\n-    public byte[] pad(byte[] data, int ofs, int len)\n-            throws BadPaddingException {\n-        return pad(RSACore.convert(data, ofs, len));\n+    public byte[] pad(byte[] data) throws BadPaddingException {\n+        return pad(data, 0, data.length);\n@@ -249,2 +248,3 @@\n-    public byte[] pad(byte[] data) throws BadPaddingException {\n-        if (data.length > maxDataSize) {\n+    public byte[] pad(byte[] data, int ofs, int len)\n+            throws BadPaddingException {\n+        if (len > maxDataSize) {\n@@ -253,1 +253,1 @@\n-                + data.length + \" bytes.\");\n+                + len + \" bytes.\");\n@@ -257,1 +257,1 @@\n-            return data;\n+            return RSACore.convert(data, ofs, len);\n@@ -260,1 +260,1 @@\n-            return padV15(data);\n+            return padV15(data, ofs, len);\n@@ -262,1 +262,1 @@\n-            return padOAEP(data);\n+            return padOAEP(data, ofs, len);\n@@ -268,8 +268,0 @@\n-    \/**\n-     * Unpad the padded block and return the data.\n-     *\/\n-    public byte[] unpad(byte[] padded, int ofs, int len)\n-            throws BadPaddingException {\n-        return unpad(RSACore.convert(padded, ofs, len));\n-    }\n-\n@@ -301,1 +293,1 @@\n-    private byte[] padV15(byte[] data) throws BadPaddingException {\n+    private byte[] padV15(byte[] data, int ofs, int len) throws BadPaddingException {\n@@ -303,3 +295,2 @@\n-        System.arraycopy(data, 0, padded, paddedSize - data.length,\n-            data.length);\n-        int psSize = paddedSize - 3 - data.length;\n+        System.arraycopy(data, ofs, padded, paddedSize - len, len);\n+        int psSize = paddedSize - 3 - len;\n@@ -391,1 +382,1 @@\n-    private byte[] padOAEP(byte[] M) throws BadPaddingException {\n+    private byte[] padOAEP(byte[] M, int ofs, int len) throws BadPaddingException {\n@@ -418,1 +409,1 @@\n-        int mStart = paddedSize - M.length;\n+        int mStart = paddedSize - len;\n@@ -427,1 +418,1 @@\n-        System.arraycopy(M, 0, EM, mStart, M.length);\n+        System.arraycopy(M, ofs, EM, mStart, len);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPadding.java","additions":16,"deletions":25,"binary":false,"changes":41,"status":"modified"}]}