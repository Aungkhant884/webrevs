{"files":[{"patch":"@@ -1224,0 +1224,20 @@\n+      \/\/ Verify that memory-writing nodes (such as stores and calls) are placed\n+      \/\/ in their original loop L (given by the control input) or in an ancestor\n+      \/\/ of L. This is guaranteed by the freq. estimation model for reducible\n+      \/\/ CFGs, and by special handling in PhaseCFG::schedule_late() otherwise.\n+      if (n->is_Mach() && n->bottom_type()->has_memory() && n->in(0) != NULL) {\n+        Block *original_block = find_block_for_node(n->in(0));\n+        assert(original_block != NULL, \"missing block for memory-writing node\");\n+        CFGLoop* original_or_ancestor = original_block->_loop;\n+        assert(block->_loop != NULL && original_or_ancestor != NULL, \"no loop\");\n+        bool found = false;\n+        do {\n+          if (block->_loop == original_or_ancestor) {\n+            found = true;\n+            break;\n+          }\n+          original_or_ancestor = original_or_ancestor->parent();\n+        } while (original_or_ancestor != NULL);\n+        assert(found, \"memory-writing node is not placed in its original loop \"\n+                      \"or an ancestor of it\");\n+      }\n","filename":"src\/hotspot\/share\/opto\/block.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -504,2 +504,2 @@\n-  bool is_control_proj_or_safepoint(Node* n);\n-  Block* find_block_for_node(Node* n);\n+  bool is_control_proj_or_safepoint(Node* n) const;\n+  Block* find_block_for_node(Node* n) const;\n","filename":"src\/hotspot\/share\/opto\/block.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-bool PhaseCFG::is_control_proj_or_safepoint(Node* n) {\n+bool PhaseCFG::is_control_proj_or_safepoint(Node* n) const {\n@@ -162,1 +162,1 @@\n-Block* PhaseCFG::find_block_for_node(Node* n) {\n+Block* PhaseCFG::find_block_for_node(Node* n) const {\n@@ -1277,0 +1277,40 @@\n+      if (C->has_irreducible_loop() && self->bottom_type()->has_memory()) {\n+        \/\/ If the CFG is irreducible, keep memory-writing nodes as close as\n+        \/\/ possible to their original block (given by the control input). This\n+        \/\/ prevents PhaseCFG::hoist_to_cheaper_block() from placing such nodes\n+        \/\/ into descendants of their original loop, as in the following example:\n+        \/\/\n+        \/\/ Original placement of store in B1 (loop L1):\n+        \/\/\n+        \/\/ B1 (L1):\n+        \/\/   m1 <- ..\n+        \/\/   m2 <- store m1, ..\n+        \/\/ B2 (L2):\n+        \/\/   jump B2\n+        \/\/ B3 (L1):\n+        \/\/   .. <- .. m2, ..\n+        \/\/\n+        \/\/ Wrong \"hoisting\" of store to B2 (in loop L2, child of L1):\n+        \/\/\n+        \/\/ B1 (L1):\n+        \/\/   m1 <- ..\n+        \/\/ B2 (L2):\n+        \/\/   m2 <- store m1, ..\n+        \/\/   # Wrong: m1 and m2 interfere at this point.\n+        \/\/   jump B2\n+        \/\/ B3 (L1):\n+        \/\/   .. <- .. m2, ..\n+        \/\/\n+        \/\/ This \"hoist inversion\" can happen due to CFGLoop::compute_freq()'s\n+        \/\/ inaccurate estimation of frequencies for irreducible CFGs, which can\n+        \/\/ lead to for example assigning B1 and B3 a higher frequency than B2.\n+#ifndef PRODUCT\n+        if (trace_opto_pipelining()) {\n+          tty->print_cr(\"# Irreducible loops: schedule in earliest block B%d:\",\n+                        early->_pre_order);\n+          self->dump();\n+        }\n+#endif\n+        schedule_node_into_block(self, early);\n+        continue;\n+      }\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":42,"deletions":2,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.codegen;\n+\n+import jdk.test.lib.Asserts;\n+\n+\/**\n+ * @test\n+ * @bug 8255763\n+ * @summary Tests GCM's store placement for reducible and irreducible CFGs.\n+ * @library \/test\/lib \/\n+ * @run main\/othervm -Xbatch compiler.codegen.TestGCMStorePlacement reducible\n+ * @run main\/othervm -Xbatch compiler.codegen.TestGCMStorePlacement irreducible\n+ *\/\n+\n+public class TestGCMStorePlacement {\n+\n+    static int counter;\n+\n+    \/\/ Reducible case: counter++ should not be placed into the loop.\n+    static void testReducible() {\n+        counter++;\n+        int acc = 0;\n+        for (int i = 0; i < 50; i++) {\n+            if (i % 2 == 0) {\n+                acc += 1;\n+            }\n+        }\n+        return;\n+    }\n+\n+    \/\/ Irreducible case (due to OSR compilation): counter++ should not be placed\n+    \/\/ outside its switch case block.\n+    static void testIrreducible() {\n+        for (int i = 0; i < 30; i++) {\n+            switch (i % 3) {\n+            case 0:\n+                for (int j = 0; j < 50; j++) {\n+                    \/\/ OSR enters here.\n+                    for (int k = 0; k < 7000; k++) {}\n+                    if (i % 2 == 0) {\n+                        break;\n+                    }\n+                }\n+                counter++;\n+                break;\n+            case 1:\n+                break;\n+            case 2:\n+                break;\n+            }\n+        }\n+        return;\n+    }\n+\n+    public static void main(String[] args) {\n+        switch (args[0]) {\n+        case \"reducible\":\n+            \/\/ Cause a regular C2 compilation of testReducible.\n+            for (int i = 0; i < 100_000; i++) {\n+                counter = 0;\n+                testReducible();\n+                Asserts.assertEQ(counter, 1);\n+            }\n+            break;\n+        case \"irreducible\":\n+            \/\/ Cause an OSR C2 compilation of testIrreducible.\n+            counter = 0;\n+            testIrreducible();\n+            Asserts.assertEQ(counter, 10);\n+            break;\n+        default:\n+            System.out.println(\"invalid mode\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestGCMStorePlacement.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"}]}