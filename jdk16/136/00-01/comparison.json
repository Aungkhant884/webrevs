{"files":[{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2021, Huawei Technologies Co., Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8260585\n+ * @summary AArch64: Wrong code generated for shifting right and accumulating four unsigned short integers.\n+ * @run main\/othervm compiler.c2.TestShiftRightAndAccumulate\n+ *\n+ *\/\n+\n+package compiler.c2;\n+\n+import java.util.Random;\n+import java.util.Arrays;\n+\n+public class TestShiftRightAndAccumulate {\n+    private static final int SMALL_LEN = 16;\n+    private static final int LARGE_LEN = 1000;\n+    private static final int NUM_ITERS = 200000;\n+\n+    private static byte[]  bytesA,  bytesB,  bytesC,  bytesD,  bytesE;\n+    private static short[] shortsA, shortsB, shortsC, shortsD, shortsE;\n+    private static char[]  charsA,  charsB,  charsC,  charsD,  charsE;\n+    private static int[]   intsA,   intsB,   intsC,   intsD,   intsE;\n+    private static long[]  longsA,  longsB,  longsC,  longsD,  longsE;\n+\n+    private static Random r = new Random(32781);\n+\n+    public static void main(String args[]) {\n+      test_small();\n+      test_large();\n+      System.out.println(\"Test PASSED\");\n+    }\n+\n+    static void test_small() {\n+        test_init(SMALL_LEN);\n+        for (int i = 0; i < NUM_ITERS; i++) {\n+            test_bytes();\n+            test_shorts();\n+            test_chars();\n+            test_ints();\n+            test_longs();\n+        }\n+    }\n+\n+    static void test_large() {\n+        test_init(LARGE_LEN);\n+        for (int i = 0; i < NUM_ITERS; i++) {\n+            test_bytes();\n+            test_shorts();\n+            test_chars();\n+            test_ints();\n+            test_longs();\n+        }\n+    }\n+\n+    static void test_bytes() {\n+        for (int i = 0; i < bytesC.length; i++) {\n+            bytesC[i] = (byte) (bytesA[i] + (bytesB[i] >> 1));\n+        }\n+        assertTrue(Arrays.equals(bytesC, bytesD));\n+\n+        for (int i = 0; i < bytesC.length; i++) {\n+            bytesC[i] = (byte) (bytesA[i] + (((byte) (bytesB[i] >>> 3))));\n+        }\n+        assertTrue(Arrays.equals(bytesC, bytesE));\n+    }\n+\n+    static void test_shorts() {\n+        for (int i = 0; i < shortsC.length; i++) {\n+            shortsC[i] = (short) (shortsA[i] + (shortsB[i] >> 5));\n+        }\n+        assertTrue(Arrays.equals(shortsC, shortsD));\n+\n+        for (int i = 0; i < shortsC.length; i++) {\n+            shortsC[i] = (short) (shortsA[i] + (shortsB[i] >> 7));\n+        }\n+        assertTrue(Arrays.equals(shortsC, shortsE));\n+    }\n+\n+    static void test_chars() {\n+        for (int i = 0; i < charsC.length; i++) {\n+            charsC[i] = (char) (charsA[i] + (charsB[i] >>> 4));\n+        }\n+        assertTrue(Arrays.equals(charsC, charsD));\n+    }\n+\n+    static void test_ints() {\n+        for (int i = 0; i < intsC.length; i++) {\n+            intsC[i] = intsA[i] + (intsB[i] >> 2);\n+        }\n+        assertTrue(Arrays.equals(intsC, intsD));\n+\n+        for (int i = 0; i < intsC.length; i++) {\n+            intsC[i] = (intsB[i] >>> 2) + intsA[i];\n+        }\n+        assertTrue(Arrays.equals(intsC, intsE));\n+    }\n+\n+    static void test_longs() {\n+        for (int i = 0; i < longsC.length; i++) {\n+            longsC[i] = longsA[i] + (longsB[i] >> 5);\n+        }\n+        assertTrue(Arrays.equals(longsC, longsD));\n+\n+        for (int i = 0; i < longsC.length; i++) {\n+            longsC[i] = (longsB[i] >>> 2) + longsA[i];\n+        }\n+        assertTrue(Arrays.equals(longsC, longsE));\n+    }\n+\n+    static void test_init(int count) {\n+        bytesA  = new byte[count];\n+        shortsA = new short[count];\n+        charsA  = new char[count];\n+        intsA   = new int[count];\n+        longsA  = new long[count];\n+\n+        bytesB  = new byte[count];\n+        shortsB = new short[count];\n+        charsB  = new char[count];\n+        intsB   = new int[count];\n+        longsB  = new long[count];\n+\n+        bytesC  = new byte[count];\n+        shortsC = new short[count];\n+        charsC  = new char[count];\n+        intsC   = new int[count];\n+        longsC  = new long[count];\n+\n+        bytesD  = new byte[count];\n+        shortsD = new short[count];\n+        charsD  = new char[count];\n+        intsD   = new int[count];\n+        longsD  = new long[count];\n+\n+        bytesE  = new byte[count];\n+        shortsE = new short[count];\n+        charsE  = new char[count];\n+        intsE   = new int[count];\n+        longsE  = new long[count];\n+\n+        for (int i = 0; i < count; i++) {\n+            bytesA[i]  = (byte) r.nextInt();\n+            shortsA[i] = (short) r.nextInt();\n+            charsA[i]  = (char) r.nextInt();\n+            intsA[i]   = r.nextInt();\n+            longsA[i]  = r.nextLong();\n+\n+            bytesB[i]  = (byte) r.nextInt();\n+            shortsB[i] = (short) r.nextInt();\n+            charsB[i]  = (char) r.nextInt();\n+            intsB[i]   = r.nextInt();\n+            longsB[i]  = r.nextLong();\n+        }\n+\n+        for (int i = 0; i < count; i++) {\n+            bytesD[i]  = (byte) (bytesA[i] + (bytesB[i] >> 1));\n+            bytesE[i]  = (byte) (bytesA[i] + (((byte) (bytesB[i] >>> 3))));\n+            shortsD[i] = (short) (shortsA[i] + (shortsB[i] >> 5));\n+            shortsE[i] = (short) (shortsA[i] + (shortsB[i] >> 7));\n+            charsD[i]  = (char) (charsA[i] + (charsB[i] >>> 4));\n+            intsD[i]   = intsA[i] + (intsB[i] >> 2);\n+            intsE[i]   = (intsB[i] >>> 2) + intsA[i];\n+            longsD[i]  = longsA[i] + (longsB[i] >> 5);\n+            longsE[i]  = (longsB[i] >>> 2) + longsA[i];\n+        }\n+    }\n+\n+    static void assertTrue(boolean okay) {\n+        if (!okay) {\n+            throw new RuntimeException(\"Test Failed\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestShiftRightAndAccumulate.java","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"}]}