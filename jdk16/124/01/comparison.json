{"files":[{"patch":"@@ -4749,0 +4749,17 @@\n+static bool should_warn_invalid_processor_id() {\n+  if (os::processor_count() == 1) {\n+    \/\/ Don't warn if we only have one processor\n+    return false;\n+  }\n+\n+  static volatile int warn_once = 1;\n+\n+  if (Atomic::load(&warn_once) == 0 ||\n+      Atomic::xchg(&warn_once, 0) == 0) {\n+    \/\/ Don't warn more than once\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n@@ -4752,5 +4769,17 @@\n-#ifndef PRODUCT\n-  if (UseDebuggerErgo1 && id >= _processor_count) {\n-    \/\/ Some debuggers limit the processor count without limiting\n-    \/\/ the returned processor ids. Fake the processor id.\n-    return 0;\n+  if (id < processor_count()) {\n+    return (uint)id;\n+  }\n+\n+  \/\/ Some environments (e.g. openvz containers and the rr debugger) incorrectly\n+  \/\/ report a processor id that is higher than the number of processors available.\n+  \/\/ This is problematic, for example, when implementing CPU-local data structures,\n+  \/\/ where the processor id is used to index into an array of length processor_count().\n+  \/\/ If this happens we return 0 here. This is is safe since we always have at least\n+  \/\/ one processor, but it's not optimal for performance if we're actually executing\n+  \/\/ in an environment with more than one processor.\n+  if (should_warn_invalid_processor_id()) {\n+    log_warning(os)(\"Invalid processor id reported by the operating system \"\n+                    \"(got processor id %d, valid processor id range is 0-%d)\",\n+                    id, processor_count() - 1);\n+    log_warning(os)(\"Falling back to assuming processor id is 0. \"\n+                    \"This could have a negative impact on performance.\");\n@@ -4758,1 +4787,0 @@\n-#endif\n@@ -4760,2 +4788,1 @@\n-  assert(id >= 0 && id < _processor_count, \"Invalid processor id [%d]\", id);\n-  return (uint)id;\n+  return 0;\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":35,"deletions":8,"binary":false,"changes":43,"status":"modified"}]}