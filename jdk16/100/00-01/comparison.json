{"files":[{"patch":"@@ -1,2 +1,2 @@\n-\/\/ Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n-\/\/ Copyright (c) 2020, 2021, Arm Limited. All rights reserved.\n+\/\/ Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2020, Arm Limited. All rights reserved.\n@@ -87,1 +87,1 @@\n-  format %{ \" # reinterpret $dst,$src\\t# D2X\" %}\n+  format %{ \" # reinterpret $dst,$src\" %}\n@@ -89,2 +89,1 @@\n-    \/\/ If registers are the same, no register move is required - the\n-    \/\/ upper 64 bits of 'src' are expected to be initialized to zero.\n+    \/\/ If register is the same, then move is not needed.\n@@ -106,1 +105,1 @@\n-  format %{ \" # reinterpret $dst,$src\\t# X2D\" %}\n+  format %{ \" # reinterpret $dst,$src\" %}\n@@ -108,5 +107,6 @@\n-    \/\/ Resize the vector from 128-bits to 64-bits. The higher 64-bits of\n-    \/\/ the \"dst\" register must be cleared to zero.\n-    __ orr(as_FloatRegister($dst$$reg), __ T8B,\n-           as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n+    \/\/ If register is the same, then move is not needed.\n+    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+      __ orr(as_FloatRegister($dst$$reg), __ T8B,\n+             as_FloatRegister($src$$reg),\n+             as_FloatRegister($src$$reg));\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon.ad","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1,2 +1,2 @@\n-\/\/ Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n-\/\/ Copyright (c) 2020, 2021, Arm Limited. All rights reserved.\n+\/\/ Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2020, Arm Limited. All rights reserved.\n@@ -100,2 +100,2 @@\n-\n-instruct reinterpretD2X(vecX dst, vecD src)\n+define(`REINTERPRET_X', `\n+instruct reinterpret$1`'2$2`'(vec$2 dst, vec$1 src)\n@@ -103,2 +103,2 @@\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 16 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == 8);\n+  predicate(n->bottom_type()->is_vect()->length_in_bytes() == $3 &&\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == $4);\n@@ -107,1 +107,1 @@\n-  format %{ \" # reinterpret $dst,$src\\t# D2X\" %}\n+  format %{ \" # reinterpret $dst,$src\" %}\n@@ -109,2 +109,1 @@\n-    \/\/ If registers are the same, no register move is required - the\n-    \/\/ upper 64 bits of 'src' are expected to be initialized to zero.\n+    \/\/ If register is the same, then move is not needed.\n@@ -118,18 +117,5 @@\n-%}\n-\n-instruct reinterpretX2D(vecD dst, vecX src)\n-%{\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 8 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == 16);\n-  match(Set dst (VectorReinterpret src));\n-  ins_cost(INSN_COST);\n-  format %{ \" # reinterpret $dst,$src\\t# X2D\" %}\n-  ins_encode %{\n-    \/\/ Resize the vector from 128-bits to 64-bits. The higher 64-bits of\n-    \/\/ the \"dst\" register must be cleared to zero.\n-    __ orr(as_FloatRegister($dst$$reg), __ T8B,\n-           as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vlogical64);\n-%}\n+%}')dnl\n+dnl           $1 $2 $3  $4\n+REINTERPRET_X(D, X, 16, 8)\n+REINTERPRET_X(X, D, 8,  16)\n+dnl\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon_ad.m4","additions":13,"deletions":27,"binary":false,"changes":40,"status":"modified"}]}