{"files":[{"patch":"@@ -3633,10 +3633,2 @@\n-  \/\/ If we have a receiver, then null-check and handle it separately\n-  bool handle_receiver = x->needs_null_check();\n-  if (handle_receiver) {\n-    CodeEmitInfo* info = state_for(x);\n-    LIRItem vitem(x->receiver(), this);\n-    vitem.load_item();\n-    __ null_check(vitem.result(), info);\n-  }\n-\n-  for (int c = (handle_receiver ? 1 : 0); c < x->number_of_arguments(); c++) {\n+  assert(!x->has_receiver(), \"Should have been checked before: only static methods here\");\n+  for (int c = 0; c < x->number_of_arguments(); c++) {\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -427,0 +427,10 @@\n+  if (!method->is_empty_method()) {\n+    warning(\"Blackhole compile option only works for empty methods: %s\",\n+            method->name_and_sig_as_C_string());\n+    return false;\n+  }\n+  if (!method->is_static()) {\n+    warning(\"Blackhole compile option only works for static methods: %s\",\n+            method->name_and_sig_as_C_string());\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -6861,10 +6861,1 @@\n-  \/\/ To preserve the semantics of Java call, we need to null-check the receiver,\n-  \/\/ if present. Shortcut if receiver is unconditionally null.\n-  Node* receiver = NULL;\n-  bool has_receiver = !callee()->is_static();\n-  if (has_receiver) {\n-    receiver = null_check_receiver();\n-    if (stopped()) {\n-      return true;\n-    }\n-  }\n+  assert(callee()->is_static(), \"Should have been checked before: only static methods here\");\n@@ -6874,3 +6865,0 @@\n-  if (has_receiver) {\n-    bh->add_req(receiver);\n-  }\n@@ -6878,1 +6866,1 @@\n-  for (uint i = has_receiver ? 1 : 0; i < nargs; i++) {\n+  for (uint i = 0; i < nargs; i++) {\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":14,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1,183 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test id=c1\n- * @build compiler.blackhole.BlackholeTarget\n- *\n- * @run main\/othervm\n- *      -Xmx1g\n- *      -Xbatch -XX:TieredStopAtLevel=1\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n- *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n- *      compiler.blackhole.BlackholeInstanceReturnTest\n- *\/\n-\n-\/**\n- * @test id=c2\n- * @build compiler.blackhole.BlackholeTarget\n- *\n- * @run main\/othervm\n- *      -Xmx1g\n- *      -Xbatch -XX:-TieredCompilation\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n- *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n- *      compiler.blackhole.BlackholeInstanceReturnTest\n- *\/\n-\n-\/**\n- * @test id=c1-no-coops\n- * @requires vm.bits == \"64\"\n- * @build compiler.blackhole.BlackholeTarget\n- *\n- * @run main\/othervm\n- *      -Xmx1g -XX:-UseCompressedOops\n- *      -Xbatch -XX:TieredStopAtLevel=1\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n- *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n- *      compiler.blackhole.BlackholeInstanceReturnTest\n- *\/\n-\n-\/**\n- * @test id=c2-no-coops\n- * @requires vm.bits == \"64\"\n- * @build compiler.blackhole.BlackholeTarget\n- *\n- * @run main\/othervm\n- *      -Xmx1g -XX:-UseCompressedOops\n- *      -Xbatch -XX:-TieredCompilation\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n- *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n- *      compiler.blackhole.BlackholeInstanceReturnTest\n- *\/\n-\n-package compiler.blackhole;\n-\n-public class BlackholeInstanceReturnTest {\n-\n-    public static void main(String[] args) {\n-        runTries(BlackholeInstanceReturnTest::test_boolean);\n-        runTries(BlackholeInstanceReturnTest::test_byte);\n-        runTries(BlackholeInstanceReturnTest::test_char);\n-        runTries(BlackholeInstanceReturnTest::test_short);\n-        runTries(BlackholeInstanceReturnTest::test_int);\n-        runTries(BlackholeInstanceReturnTest::test_float);\n-        runTries(BlackholeInstanceReturnTest::test_long);\n-        runTries(BlackholeInstanceReturnTest::test_double);\n-        runTries(BlackholeInstanceReturnTest::test_Object);\n-    }\n-\n-    private static final int CYCLES = 1_000_000;\n-    private static final int TRIES = 10;\n-\n-    public static void runTries(Runnable r) {\n-        for (int t = 0; t < TRIES; t++) {\n-            BlackholeTarget.clear();\n-            r.run();\n-            BlackholeTarget.shouldBeEntered();\n-        }\n-    }\n-\n-    private static void test_boolean() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            if (t.bh_ir_boolean((c & 0x1) == 0) != false) {\n-                throw new AssertionError(\"Return value error\");\n-            }\n-        }\n-    }\n-\n-    private static void test_byte() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            if (t.bh_ir_byte((byte)c) != 0) {\n-                throw new AssertionError(\"Return value error\");\n-            }\n-        }\n-    }\n-\n-    private static void test_char() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            if (t.bh_ir_char((char)c) != 0) {\n-                throw new AssertionError(\"Return value error\");\n-            }\n-        }\n-    }\n-\n-    private static void test_short() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            if (t.bh_ir_short((short)c) != 0) {\n-                throw new AssertionError(\"Return value error\");\n-            }\n-        }\n-    }\n-\n-    private static void test_int() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            if (t.bh_ir_int(c) != 0) {\n-                throw new AssertionError(\"Return value error\");\n-            }\n-        }\n-    }\n-\n-    private static void test_float() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            if (t.bh_ir_float(c) != 0F) {\n-                throw new AssertionError(\"Return value error\");\n-            }\n-        }\n-    }\n-\n-    private static void test_long() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            if (t.bh_ir_long(c) != 0L) {\n-                throw new AssertionError(\"Return value error\");\n-            }\n-        }\n-    }\n-\n-    private static void test_double() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            if (t.bh_ir_double(c) != 0D) {\n-                throw new AssertionError(\"Return value error\");\n-            }\n-        }\n-    }\n-\n-    private static void test_Object() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            Object o = new Object();\n-            if (t.bh_ir_Object(o) != null) {\n-                throw new AssertionError(\"Return value error\");\n-            }\n-        }\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeInstanceReturnTest.java","additions":0,"deletions":183,"binary":false,"changes":183,"status":"deleted"},{"patch":"@@ -1,314 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test id=c1\n- * @build compiler.blackhole.BlackholeTarget\n- *\n- * @run main\/othervm\n- *      -Xmx1g\n- *      -Xbatch -XX:TieredStopAtLevel=1\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n- *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n- *      compiler.blackhole.BlackholeInstanceTest\n- *\/\n-\n-\/**\n- * @test id=c2\n- * @build compiler.blackhole.BlackholeTarget\n- *\n- * @run main\/othervm\n- *      -Xmx1g\n- *      -Xbatch -XX:-TieredCompilation\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n- *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n- *      compiler.blackhole.BlackholeInstanceTest\n- *\/\n-\n-\/**\n- * @test id=c1-no-coops\n- * @requires vm.bits == \"64\"\n- * @build compiler.blackhole.BlackholeTarget\n- *\n- * @run main\/othervm\n- *      -Xmx1g -XX:-UseCompressedOops\n- *      -Xbatch -XX:TieredStopAtLevel=1\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n- *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n- *      compiler.blackhole.BlackholeInstanceTest\n- *\/\n-\n-\/**\n- * @test id=c2-no-coops\n- * @requires vm.bits == \"64\"\n- * @build compiler.blackhole.BlackholeTarget\n- *\n- * @run main\/othervm\n- *      -Xmx1g -XX:-UseCompressedOops\n- *      -Xbatch -XX:-TieredCompilation\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n- *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n- *      compiler.blackhole.BlackholeInstanceTest\n- *\/\n-\n-package compiler.blackhole;\n-\n-public class BlackholeInstanceTest {\n-\n-    public static void main(String[] args) {\n-        runTries(BlackholeInstanceTest::test_boolean_0);\n-        runTries(BlackholeInstanceTest::test_byte_0);\n-        runTries(BlackholeInstanceTest::test_char_0);\n-        runTries(BlackholeInstanceTest::test_short_0);\n-        runTries(BlackholeInstanceTest::test_int_0);\n-        runTries(BlackholeInstanceTest::test_float_0);\n-        runTries(BlackholeInstanceTest::test_long_0);\n-        runTries(BlackholeInstanceTest::test_double_0);\n-        runTries(BlackholeInstanceTest::test_Object_0);\n-\n-        runTries(BlackholeInstanceTest::test_boolean_1);\n-        runTries(BlackholeInstanceTest::test_byte_1);\n-        runTries(BlackholeInstanceTest::test_char_1);\n-        runTries(BlackholeInstanceTest::test_short_1);\n-        runTries(BlackholeInstanceTest::test_int_1);\n-        runTries(BlackholeInstanceTest::test_float_1);\n-        runTries(BlackholeInstanceTest::test_long_1);\n-        runTries(BlackholeInstanceTest::test_double_1);\n-        runTries(BlackholeInstanceTest::test_Object_1);\n-\n-        runTries(BlackholeInstanceTest::test_boolean_2);\n-        runTries(BlackholeInstanceTest::test_byte_2);\n-        runTries(BlackholeInstanceTest::test_char_2);\n-        runTries(BlackholeInstanceTest::test_short_2);\n-        runTries(BlackholeInstanceTest::test_int_2);\n-        runTries(BlackholeInstanceTest::test_float_2);\n-        runTries(BlackholeInstanceTest::test_long_2);\n-        runTries(BlackholeInstanceTest::test_double_2);\n-        runTries(BlackholeInstanceTest::test_Object_2);\n-    }\n-\n-    private static final int CYCLES = 1_000_000;\n-    private static final int TRIES = 10;\n-\n-    public static void runTries(Runnable r) {\n-        for (int t = 0; t < TRIES; t++) {\n-            BlackholeTarget.clear();\n-            r.run();\n-            if (t == TRIES - 1) {\n-               BlackholeTarget.shouldNotBeEntered();\n-            }\n-        }\n-    }\n-\n-    private static void test_boolean_0() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            t.bh_i_boolean_0();\n-        }\n-    }\n-\n-    private static void test_byte_0() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            t.bh_i_byte_0();\n-        }\n-    }\n-\n-    private static void test_char_0() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            t.bh_i_char_0();\n-        }\n-    }\n-\n-    private static void test_short_0() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            t.bh_i_short_0();\n-        }\n-    }\n-\n-    private static void test_int_0() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            t.bh_i_int_0();\n-        }\n-    }\n-\n-    private static void test_float_0() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            t.bh_i_float_0();\n-        }\n-    }\n-\n-    private static void test_long_0() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            t.bh_i_long_0();\n-        }\n-    }\n-\n-    private static void test_double_0() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            t.bh_i_double_0();\n-        }\n-    }\n-\n-    private static void test_Object_0() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            t.bh_i_Object_0();\n-        }\n-    }\n-\n-    private static void test_boolean_1() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            t.bh_i_boolean_1((c & 0x1) == 0);\n-        }\n-    }\n-\n-    private static void test_byte_1() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            t.bh_i_byte_1((byte)c);\n-        }\n-    }\n-\n-    private static void test_char_1() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            t.bh_i_char_1((char)c);\n-        }\n-    }\n-\n-    private static void test_short_1() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            t.bh_i_short_1((short)c);\n-        }\n-    }\n-\n-    private static void test_int_1() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            t.bh_i_int_1(c);\n-        }\n-    }\n-\n-    private static void test_float_1() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            t.bh_i_float_1(c);\n-        }\n-    }\n-\n-    private static void test_long_1() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            t.bh_i_long_1(c);\n-        }\n-    }\n-\n-    private static void test_double_1() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            t.bh_i_double_1(c);\n-        }\n-    }\n-\n-    private static void test_Object_1() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            Object o = new Object();\n-            t.bh_i_Object_1(o);\n-        }\n-    }\n-\n-    private static void test_boolean_2() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            t.bh_i_boolean_2((c & 0x1) == 0, (c & 0x2) == 0);\n-        }\n-    }\n-\n-    private static void test_byte_2() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            t.bh_i_byte_2((byte)c, (byte)(c + 1));\n-        }\n-    }\n-\n-    private static void test_char_2() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            t.bh_i_char_2((char)c, (char)(c + 1));\n-        }\n-    }\n-\n-    private static void test_short_2() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            t.bh_i_short_2((short)c, (short)(c + 1));\n-        }\n-    }\n-\n-    private static void test_int_2() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            t.bh_i_int_2(c, c + 1);\n-        }\n-    }\n-\n-    private static void test_float_2() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            t.bh_i_float_2(c, c + 1);\n-        }\n-    }\n-\n-    private static void test_long_2() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            t.bh_i_long_2(c, c + 1);\n-        }\n-    }\n-\n-    private static void test_double_2() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            t.bh_i_double_2(c, c + 1);\n-        }\n-    }\n-\n-    private static void test_Object_2() {\n-        BlackholeTarget t = new BlackholeTarget();\n-        for (int c = 0; c < CYCLES; c++) {\n-            Object o1 = new Object();\n-            Object o2 = new Object();\n-            t.bh_i_Object_2(o1, o2);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeInstanceTest.java","additions":0,"deletions":314,"binary":false,"changes":314,"status":"deleted"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @build compiler.blackhole.BlackholeTarget\n+ * @run driver compiler.blackhole.BlackholeNonEmptyWarningTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class BlackholeNonEmptyWarningTest {\n+\n+    private static final int CYCLES = 1_000_000;\n+    private static final int TRIES = 10;\n+\n+    public static void main(String[] args) throws IOException {\n+        if (args.length == 0) {\n+            driver();\n+        } else {\n+            runner();\n+        }\n+    }\n+\n+    public static void driver() throws IOException {\n+       final String msg = \"Blackhole compile option only works for empty methods: compiler.blackhole.BlackholeTarget.bh_s_int_1_delegate(I)V\";\n+\n+       {\n+           ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+               \"-Xmx128m\",\n+               \"-Xbatch\",\n+               \"-XX:+UnlockDiagnosticVMOptions\",\n+               \"-XX:CompileCommand=quiet\",\n+               \"-XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\",\n+               \"compiler.blackhole.BlackholeNonEmptyWarningTest\",\n+               \"run\"\n+           );\n+           OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+           output.shouldHaveExitValue(0);\n+           output.shouldContain(msg);\n+       }\n+\n+       {\n+           ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+               \"-Xmx128m\",\n+               \"-XX:-PrintWarnings\",\n+               \"-XX:+UnlockDiagnosticVMOptions\",\n+               \"-XX:CompileCommand=quiet\",\n+               \"-XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\",\n+               \"compiler.blackhole.BlackholeNonEmptyWarningTest\",\n+               \"run\"\n+           );\n+           OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+           output.shouldHaveExitValue(0);\n+           output.shouldNotContain(msg);\n+       }\n+    }\n+\n+    public static void runner() {\n+        for (int t = 0; t < TRIES; t++) {\n+            run();\n+        }\n+    }\n+\n+    public static void run() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_int_1_delegate(c);\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeNonEmptyWarningTest.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @build compiler.blackhole.BlackholeTarget\n+ * @run driver compiler.blackhole.BlackholeNonStaticWarningTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class BlackholeNonStaticWarningTest {\n+\n+    private static final int CYCLES = 1_000_000;\n+    private static final int TRIES = 10;\n+\n+    public static void main(String[] args) throws IOException {\n+        if (args.length == 0) {\n+            driver();\n+        } else {\n+            runner();\n+        }\n+    }\n+\n+    public static void driver() throws IOException {\n+       final String msg = \"Blackhole compile option only works for static methods: compiler.blackhole.BlackholeTarget.bh_i_int_0()V\";\n+\n+       {\n+           ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+               \"-Xmx128m\",\n+               \"-Xbatch\",\n+               \"-XX:+UnlockDiagnosticVMOptions\",\n+               \"-XX:CompileCommand=quiet\",\n+               \"-XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\",\n+               \"compiler.blackhole.BlackholeNonStaticWarningTest\",\n+               \"run\"\n+           );\n+           OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+           output.shouldHaveExitValue(0);\n+           output.shouldContain(msg);\n+       }\n+\n+       {\n+           ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+               \"-Xmx128m\",\n+               \"-XX:-PrintWarnings\",\n+               \"-XX:+UnlockDiagnosticVMOptions\",\n+               \"-XX:CompileCommand=quiet\",\n+               \"-XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\",\n+               \"compiler.blackhole.BlackholeNonStaticWarningTest\",\n+               \"run\"\n+           );\n+           OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+           output.shouldHaveExitValue(0);\n+           output.shouldNotContain(msg);\n+       }\n+    }\n+\n+    public static void runner() {\n+        for (int t = 0; t < TRIES; t++) {\n+            run();\n+        }\n+    }\n+\n+    public static void run() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_int_0();\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeNonStaticWarningTest.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -1,173 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test id=c1\n- * @build compiler.blackhole.BlackholeTarget\n- *\n- * @run main\/othervm\n- *      -Xmx1g\n- *      -Xbatch -XX:TieredStopAtLevel=1\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n- *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n- *      compiler.blackhole.BlackholeNullCheckTest\n- *\/\n-\n-\/**\n- * @test id=c2\n- * @build compiler.blackhole.BlackholeTarget\n- *\n- * @run main\/othervm\n- *      -Xmx1g\n- *      -Xbatch -XX:-TieredCompilation\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n- *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n- *      compiler.blackhole.BlackholeNullCheckTest\n- *\/\n-\n-\/**\n- * @test id=c1-no-coops\n- * @requires vm.bits == \"64\"\n- * @build compiler.blackhole.BlackholeTarget\n- *\n- * @run main\/othervm\n- *      -Xmx1g -XX:-UseCompressedOops\n- *      -Xbatch -XX:TieredStopAtLevel=1\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n- *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n- *      compiler.blackhole.BlackholeNullCheckTest\n- *\/\n-\n-\/**\n- * @test id=c2-no-coops\n- * @requires vm.bits == \"64\"\n- * @build compiler.blackhole.BlackholeTarget\n- *\n- * @run main\/othervm\n- *      -Xmx1g -XX:-UseCompressedOops\n- *      -Xbatch -XX:-TieredCompilation\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n- *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n- *      compiler.blackhole.BlackholeNullCheckTest\n- *\/\n-\n-package compiler.blackhole;\n-\n-public class BlackholeNullCheckTest {\n-\n-    public static void main(String[] args) {\n-        BlackholeNullCheckTest t = new BlackholeNullCheckTest();\n-        runTries(t::test_local_sf);\n-        runTries(t::test_local_s);\n-        runTries(t::test_local);\n-        runTries(t::test_field_sf);\n-        runTries(t::test_field_s);\n-        runTries(t::test_field);\n-    }\n-\n-    private static final int CYCLES = 1_000_000;\n-    private static final int TRIES = 10;\n-\n-    public static void runTries(Runnable r) {\n-        for (int t = 0; t < TRIES; t++) {\n-            r.run();\n-        }\n-    }\n-\n-    static final BlackholeTarget BH_SF_TARGET = null;\n-    static       BlackholeTarget BH_S_TARGET = null;\n-                 BlackholeTarget BH_TARGET = null;\n-\n-    private void test_local_sf() {\n-        test_with(BH_SF_TARGET);\n-    }\n-\n-    private void test_local_s() {\n-        test_with(BH_S_TARGET);\n-    }\n-\n-    private void test_local() {\n-        test_with(BH_TARGET);\n-    }\n-\n-    private void test_with(BlackholeTarget t) {\n-        try {\n-            t.bh_i_boolean_1(false);\n-            throw new IllegalStateException(\"Expected NPE\");\n-        } catch (NullPointerException npe) {\n-        }\n-\n-        try {\n-            t.call_for_null_check();\n-            throw new IllegalStateException(\"Expected NPE\");\n-        } catch (NullPointerException npe) {\n-            \/\/ Expected\n-        }\n-    }\n-\n-    private void test_field_sf() {\n-        try {\n-            BH_SF_TARGET.bh_i_boolean_1(false);\n-            throw new IllegalStateException(\"Expected NPE\");\n-        } catch (NullPointerException npe) {\n-        }\n-\n-        try {\n-            BH_SF_TARGET.call_for_null_check();\n-            throw new IllegalStateException(\"Expected NPE\");\n-        } catch (NullPointerException npe) {\n-            \/\/ Expected\n-        }\n-    }\n-\n-    private void test_field_s() {\n-        try {\n-            BH_S_TARGET.bh_i_boolean_1(false);\n-            throw new IllegalStateException(\"Expected NPE\");\n-        } catch (NullPointerException npe) {\n-        }\n-\n-        try {\n-            BH_S_TARGET.call_for_null_check();\n-            throw new IllegalStateException(\"Expected NPE\");\n-        } catch (NullPointerException npe) {\n-            \/\/ Expected\n-        }\n-    }\n-\n-    private void test_field() {\n-        try {\n-            BH_TARGET.bh_i_boolean_1(false);\n-            throw new IllegalStateException(\"Expected NPE\");\n-        } catch (NullPointerException npe) {\n-        }\n-\n-        try {\n-            BH_TARGET.call_for_null_check();\n-            throw new IllegalStateException(\"Expected NPE\");\n-        } catch (NullPointerException npe) {\n-            \/\/ Expected\n-        }\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeNullCheckTest.java","additions":0,"deletions":173,"binary":false,"changes":173,"status":"deleted"},{"patch":"@@ -1,174 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test id=c1\n- * @build compiler.blackhole.BlackholeTarget\n- *\n- * @run main\/othervm\n- *      -Xmx1g\n- *      -Xbatch -XX:TieredStopAtLevel=1\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n- *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n- *      compiler.blackhole.BlackholeStaticReturnTest\n- *\/\n-\n-\/**\n- * @test id=c2\n- * @build compiler.blackhole.BlackholeTarget\n- *\n- * @run main\/othervm\n- *      -Xmx1g\n- *      -Xbatch -XX:-TieredCompilation\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n- *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n- *      compiler.blackhole.BlackholeStaticReturnTest\n- *\/\n-\n-\/**\n- * @test id=c1-no-coops\n- * @requires vm.bits == \"64\"\n- * @build compiler.blackhole.BlackholeTarget\n- *\n- * @run main\/othervm\n- *      -Xmx1g -XX:-UseCompressedOops\n- *      -Xbatch -XX:TieredStopAtLevel=1\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n- *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n- *      compiler.blackhole.BlackholeStaticReturnTest\n- *\/\n-\n-\/**\n- * @test id=c2-no-coops\n- * @requires vm.bits == \"64\"\n- * @build compiler.blackhole.BlackholeTarget\n- *\n- * @run main\/othervm\n- *      -Xmx1g -XX:-UseCompressedOops\n- *      -Xbatch -XX:-TieredCompilation\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n- *      -XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\n- *      compiler.blackhole.BlackholeStaticReturnTest\n- *\/\n-\n-package compiler.blackhole;\n-\n-public class BlackholeStaticReturnTest {\n-\n-    public static void main(String[] args) {\n-        runTries(BlackholeStaticReturnTest::test_boolean);\n-        runTries(BlackholeStaticReturnTest::test_byte);\n-        runTries(BlackholeStaticReturnTest::test_char);\n-        runTries(BlackholeStaticReturnTest::test_short);\n-        runTries(BlackholeStaticReturnTest::test_int);\n-        runTries(BlackholeStaticReturnTest::test_float);\n-        runTries(BlackholeStaticReturnTest::test_long);\n-        runTries(BlackholeStaticReturnTest::test_double);\n-        runTries(BlackholeStaticReturnTest::test_Object);\n-    }\n-\n-    private static final int CYCLES = 1_000_000;\n-    private static final int TRIES = 10;\n-\n-    public static void runTries(Runnable r) {\n-        for (int t = 0; t < TRIES; t++) {\n-            BlackholeTarget.clear();\n-            r.run();\n-            BlackholeTarget.shouldBeEntered();\n-        }\n-    }\n-\n-    private static void test_boolean() {\n-        for (int c = 0; c < CYCLES; c++) {\n-            if (BlackholeTarget.bh_sr_boolean((c & 0x1) == 0) != false) {\n-                throw new AssertionError(\"Return value error\");\n-            }\n-        }\n-    }\n-\n-    private static void test_byte() {\n-        for (int c = 0; c < CYCLES; c++) {\n-            if (BlackholeTarget.bh_sr_byte((byte)c) != 0) {\n-                throw new AssertionError(\"Return value error\");\n-            }\n-        }\n-    }\n-\n-    private static void test_char() {\n-        for (int c = 0; c < CYCLES; c++) {\n-            if (BlackholeTarget.bh_sr_char((char)c) != 0) {\n-                throw new AssertionError(\"Return value error\");\n-            }\n-        }\n-    }\n-\n-    private static void test_short() {\n-        for (int c = 0; c < CYCLES; c++) {\n-            if (BlackholeTarget.bh_sr_short((short)c) != 0) {\n-                throw new AssertionError(\"Return value error\");\n-            }\n-        }\n-    }\n-\n-    private static void test_int() {\n-        for (int c = 0; c < CYCLES; c++) {\n-            if (BlackholeTarget.bh_sr_int(c) != 0) {\n-                throw new AssertionError(\"Return value error\");\n-            }\n-        }\n-    }\n-\n-    private static void test_float() {\n-        for (int c = 0; c < CYCLES; c++) {\n-            if (BlackholeTarget.bh_sr_float(c) != 0F) {\n-                throw new AssertionError(\"Return value error\");\n-            }\n-        }\n-    }\n-\n-    private static void test_long() {\n-        for (int c = 0; c < CYCLES; c++) {\n-            if (BlackholeTarget.bh_sr_long(c) != 0L) {\n-                throw new AssertionError(\"Return value error\");\n-            }\n-        }\n-    }\n-\n-    private static void test_double() {\n-        for (int c = 0; c < CYCLES; c++) {\n-            if (BlackholeTarget.bh_sr_double(c) != 0D) {\n-                throw new AssertionError(\"Return value error\");\n-            }\n-        }\n-    }\n-\n-    private static void test_Object() {\n-        for (int c = 0; c < CYCLES; c++) {\n-            Object o = new Object();\n-            if (BlackholeTarget.bh_sr_Object(o) != null) {\n-                throw new AssertionError(\"Return value error\");\n-            }\n-        }\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeStaticReturnTest.java","additions":0,"deletions":174,"binary":false,"changes":174,"status":"deleted"},{"patch":"@@ -115,1 +115,0 @@\n-            BlackholeTarget.clear();\n@@ -117,3 +116,0 @@\n-            if (t == TRIES - 1) {\n-               BlackholeTarget.shouldNotBeEntered();\n-            }\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeStaticTest.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,26 +29,0 @@\n-    private static String entered;\n-\n-    private static void registerEntered(String label) {\n-        if (entered == null) {\n-           entered = label;\n-        } else if (!entered.equals(label)) {\n-           throw new IllegalStateException(\"Trying to register enter with overwrite: \" + entered + \" -> \" + label);\n-        }\n-    }\n-\n-    public static void clear() {\n-        entered = null;\n-    }\n-\n-    public static void shouldBeEntered() {\n-        if (entered == null) {\n-            throw new IllegalStateException(\"Should have been entered\");\n-        }\n-    }\n-\n-    public static void shouldNotBeEntered() {\n-        if (entered != null) {\n-            throw new IllegalStateException(\"Should not have been entered: \" + entered);\n-        }\n-    }\n-\n@@ -57,79 +31,59 @@\n-    public static void    bh_s_boolean_0()           { registerEntered(\"bh_s_boolean_0\"); }\n-    public static void    bh_s_byte_0()              { registerEntered(\"bh_s_byte_0\");    }\n-    public static void    bh_s_short_0()             { registerEntered(\"bh_s_short_0\");   }\n-    public static void    bh_s_char_0()              { registerEntered(\"bh_s_char_0\");    }\n-    public static void    bh_s_int_0()               { registerEntered(\"bh_s_int_0\");     }\n-    public static void    bh_s_float_0()             { registerEntered(\"bh_s_float_0\");   }\n-    public static void    bh_s_long_0()              { registerEntered(\"bh_s_long_0\");    }\n-    public static void    bh_s_double_0()            { registerEntered(\"bh_s_double_0\");  }\n-    public static void    bh_s_Object_0()            { registerEntered(\"bh_s_Object_0\");  }\n-\n-    public        void    bh_i_boolean_0()           { registerEntered(\"bh_i_boolean_0\"); }\n-    public        void    bh_i_byte_0()              { registerEntered(\"bh_i_byte_0\");    }\n-    public        void    bh_i_short_0()             { registerEntered(\"bh_i_short_0\");   }\n-    public        void    bh_i_char_0()              { registerEntered(\"bh_i_char_0\");    }\n-    public        void    bh_i_int_0()               { registerEntered(\"bh_i_int_0\");     }\n-    public        void    bh_i_float_0()             { registerEntered(\"bh_i_float_0\");   }\n-    public        void    bh_i_long_0()              { registerEntered(\"bh_i_long_0\");    }\n-    public        void    bh_i_double_0()            { registerEntered(\"bh_i_double_0\");  }\n-    public        void    bh_i_Object_0()            { registerEntered(\"bh_i_Object_0\");  }\n-\n-    public static void    bh_s_boolean_1(boolean v)  { registerEntered(\"bh_s_boolean_1\"); }\n-    public static void    bh_s_byte_1(byte v)        { registerEntered(\"bh_s_byte_1\");    }\n-    public static void    bh_s_short_1(short v)      { registerEntered(\"bh_s_short_1\");   }\n-    public static void    bh_s_char_1(char v)        { registerEntered(\"bh_s_char_1\");    }\n-    public static void    bh_s_int_1(int v)          { registerEntered(\"bh_s_int_1\");     }\n-    public static void    bh_s_float_1(float v)      { registerEntered(\"bh_s_float_1\");   }\n-    public static void    bh_s_long_1(long v)        { registerEntered(\"bh_s_long_1\");    }\n-    public static void    bh_s_double_1(double v)    { registerEntered(\"bh_s_double_1\");  }\n-    public static void    bh_s_Object_1(Object v)    { registerEntered(\"bh_s_Object_1\");  }\n-\n-    public        void    bh_i_boolean_1(boolean v)  { registerEntered(\"bh_i_boolean_1\"); }\n-    public        void    bh_i_byte_1(byte v)        { registerEntered(\"bh_i_byte_1\");    }\n-    public        void    bh_i_short_1(short v)      { registerEntered(\"bh_i_short_1\");   }\n-    public        void    bh_i_char_1(char v)        { registerEntered(\"bh_i_char_1\");    }\n-    public        void    bh_i_int_1(int v)          { registerEntered(\"bh_i_int_1\");     }\n-    public        void    bh_i_float_1(float v)      { registerEntered(\"bh_i_float_1\");   }\n-    public        void    bh_i_long_1(long v)        { registerEntered(\"bh_i_long_1\");    }\n-    public        void    bh_i_double_1(double v)    { registerEntered(\"bh_i_double_1\");  }\n-    public        void    bh_i_Object_1(Object v)    { registerEntered(\"bh_i_Object_1\");  }\n-\n-    public static void    bh_s_boolean_2(boolean v1, boolean v2) { registerEntered(\"bh_s_boolean_2\"); }\n-    public static void    bh_s_byte_2(byte v1, byte v2)          { registerEntered(\"bh_s_byte_2\");    }\n-    public static void    bh_s_short_2(short v1, short v2)       { registerEntered(\"bh_s_short_2\");   }\n-    public static void    bh_s_char_2(char v1, char v2)          { registerEntered(\"bh_s_char_2\");    }\n-    public static void    bh_s_int_2(int v1, int v2)             { registerEntered(\"bh_s_int_2\");     }\n-    public static void    bh_s_float_2(float v1, float v2)       { registerEntered(\"bh_s_float_2\");   }\n-    public static void    bh_s_long_2(long v1, long v2)          { registerEntered(\"bh_s_long_2\");    }\n-    public static void    bh_s_double_2(double v1, double v2)    { registerEntered(\"bh_s_double_2\");  }\n-    public static void    bh_s_Object_2(Object v1, Object v2)    { registerEntered(\"bh_s_Object_2\");  }\n-\n-    public        void    bh_i_boolean_2(boolean v1, boolean v2) { registerEntered(\"bh_i_boolean_2\"); }\n-    public        void    bh_i_byte_2(byte v1, byte v2)          { registerEntered(\"bh_i_byte_2\");    }\n-    public        void    bh_i_short_2(short v1, short v2)       { registerEntered(\"bh_i_short_2\");   }\n-    public        void    bh_i_char_2(char v1, char v2)          { registerEntered(\"bh_i_char_2\");    }\n-    public        void    bh_i_int_2(int v1, int v2)             { registerEntered(\"bh_i_int_2\");     }\n-    public        void    bh_i_float_2(float v1, float v2)       { registerEntered(\"bh_i_float_2\");   }\n-    public        void    bh_i_long_2(long v1, long v2)          { registerEntered(\"bh_i_long_2\");    }\n-    public        void    bh_i_double_2(double v1, double v2)    { registerEntered(\"bh_i_double_2\");  }\n-    public        void    bh_i_Object_2(Object v1, Object v2)    { registerEntered(\"bh_i_Object_2\");  }\n-\n-    public static boolean bh_sr_boolean(boolean v) { registerEntered(\"bh_sr_boolean\"); return false; }\n-    public static byte    bh_sr_byte(byte v)       { registerEntered(\"bh_sr_byte\");    return 0;     }\n-    public static short   bh_sr_short(short v)     { registerEntered(\"bh_sr_short\");   return 0;     }\n-    public static char    bh_sr_char(char v)       { registerEntered(\"bh_sr_char\");    return 0;     }\n-    public static int     bh_sr_int(int v)         { registerEntered(\"bh_sr_int\");     return 0;     }\n-    public static float   bh_sr_float(float v)     { registerEntered(\"bh_sr_float\");   return 0;     }\n-    public static long    bh_sr_long(long v)       { registerEntered(\"bh_sr_long\");    return 0;     }\n-    public static double  bh_sr_double(double v)   { registerEntered(\"bh_sr_double\");  return 0;     }\n-    public static Object  bh_sr_Object(Object v)   { registerEntered(\"bh_sr_Object\");  return null;  }\n-\n-    public        boolean bh_ir_boolean(boolean v) { registerEntered(\"bh_ir_boolean\"); return false; }\n-    public        byte    bh_ir_byte(byte v)       { registerEntered(\"bh_ir_byte\");    return 0;     }\n-    public        short   bh_ir_short(short v)     { registerEntered(\"bh_ir_short\");   return 0;     }\n-    public        char    bh_ir_char(char v)       { registerEntered(\"bh_ir_char\");    return 0;     }\n-    public        int     bh_ir_int(int v)         { registerEntered(\"bh_ir_int\");     return 0;     }\n-    public        float   bh_ir_float(float v)     { registerEntered(\"bh_ir_float\");   return 0;     }\n-    public        long    bh_ir_long(long v)       { registerEntered(\"bh_ir_long\");    return 0;     }\n-    public        double  bh_ir_double(double v)   { registerEntered(\"bh_ir_double\");  return 0;     }\n-    public        Object  bh_ir_Object(Object v)   { registerEntered(\"bh_ir_Object\");  return null;  }\n+    public        void    bh_i_boolean_0()           {}\n+    public        void    bh_i_byte_0()              {}\n+    public        void    bh_i_short_0()             {}\n+    public        void    bh_i_char_0()              {}\n+    public        void    bh_i_int_0()               {}\n+    public        void    bh_i_float_0()             {}\n+    public        void    bh_i_long_0()              {}\n+    public        void    bh_i_double_0()            {}\n+    public        void    bh_i_Object_0()            {}\n+\n+    public static void    bh_s_boolean_0()           {}\n+    public static void    bh_s_byte_0()              {}\n+    public static void    bh_s_short_0()             {}\n+    public static void    bh_s_char_0()              {}\n+    public static void    bh_s_int_0()               {}\n+    public static void    bh_s_float_0()             {}\n+    public static void    bh_s_long_0()              {}\n+    public static void    bh_s_double_0()            {}\n+    public static void    bh_s_Object_0()            {}\n+\n+    public static void    bh_s_boolean_1(boolean v)  {}\n+    public static void    bh_s_byte_1(byte v)        {}\n+    public static void    bh_s_short_1(short v)      {}\n+    public static void    bh_s_char_1(char v)        {}\n+    public static void    bh_s_int_1(int v)          {}\n+    public static void    bh_s_float_1(float v)      {}\n+    public static void    bh_s_long_1(long v)        {}\n+    public static void    bh_s_double_1(double v)    {}\n+    public static void    bh_s_Object_1(Object v)    {}\n+\n+    public static void    bh_s_boolean_1_delegate(boolean v)  { bh_s_boolean_1(v); }\n+    public static void    bh_s_byte_1_delegate(byte v)        { bh_s_byte_1(v);    }\n+    public static void    bh_s_short_1_delegate(short v)      { bh_s_short_1(v);   }\n+    public static void    bh_s_char_1_delegate(char v)        { bh_s_char_1(v);    }\n+    public static void    bh_s_int_1_delegate(int v)          { bh_s_int_1(v);     }\n+    public static void    bh_s_float_1_delegate(float v)      { bh_s_float_1(v);   }\n+    public static void    bh_s_long_1_delegate(long v)        { bh_s_long_1(v);    }\n+    public static void    bh_s_double_1_delegate(double v)    { bh_s_double_1(v);  }\n+    public static void    bh_s_Object_1_delegate(Object v)    { bh_s_Object_1(v);  }\n+\n+    public static void    bh_s_boolean_2(boolean v1, boolean v2) {}\n+    public static void    bh_s_byte_2(byte v1, byte v2)          {}\n+    public static void    bh_s_short_2(short v1, short v2)       {}\n+    public static void    bh_s_char_2(char v1, char v2)          {}\n+    public static void    bh_s_int_2(int v1, int v2)             {}\n+    public static void    bh_s_float_2(float v1, float v2)       {}\n+    public static void    bh_s_long_2(long v1, long v2)          {}\n+    public static void    bh_s_double_2(double v1, double v2)    {}\n+    public static void    bh_s_Object_2(Object v1, Object v2)    {}\n+\n+    public static boolean bh_sr_boolean(boolean v) { return false; }\n+    public static byte    bh_sr_byte(byte v)       { return 0;     }\n+    public static short   bh_sr_short(short v)     { return 0;     }\n+    public static char    bh_sr_char(char v)       { return 0;     }\n+    public static int     bh_sr_int(int v)         { return 0;     }\n+    public static float   bh_sr_float(float v)     { return 0;     }\n+    public static long    bh_sr_long(long v)       { return 0;     }\n+    public static double  bh_sr_double(double v)   { return 0;     }\n+    public static Object  bh_sr_Object(Object v)   { return null;  }\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeTarget.java","additions":59,"deletions":105,"binary":false,"changes":164,"status":"modified"}]}