{"files":[{"patch":"@@ -312,1 +312,1 @@\n-  ThreadInVMfromUnknown __tiv;  \/\/ get to VM state in case we block on CodeCache_lock\n+  assert(JavaThread::current()->thread_state() == _thread_in_vm, \"called with the wrong state\");\n@@ -321,1 +321,13 @@\n-    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    if (!CodeCache_lock->try_lock()) {\n+      \/\/ If we can't take the CodeCache_lock, then this is a bad time to perform the ongoing\n+      \/\/ IC transition to megamorphic, for which this stub will be needed. It is better to\n+      \/\/ bail out the transition, and wait for a more opportune moment. Not only is it not\n+      \/\/ worth waiting for the lock blockingly for the megamorphic transition, it might\n+      \/\/ also result in a deadlock to blockingly wait, when concurrent class unloading is\n+      \/\/ performed. At this point in time, the CompiledICLocker is taken, so we are not\n+      \/\/ allowed to blockingly wait for the CodeCache_lock, as these two locks are otherwise\n+      \/\/ consistently taken in the opposite order. Bailing out results in an IC transition to\n+      \/\/ the clean state instead, which will cause subsequent calls to retry the transitioning\n+      \/\/ eventually.\n+      return NULL;\n+    }\n@@ -323,0 +335,1 @@\n+    CodeCache_lock->unlock();\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"}]}