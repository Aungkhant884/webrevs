{"files":[{"patch":"@@ -307,0 +307,10 @@\n+void* VtableBlob::operator new(size_t s, unsigned size) throw() {\n+  \/\/ Handling of allocation failure stops compilation and prints a bunch of\n+  \/\/ stuff, which requires unlocking the CodeCache_lock, so that the Compile_lock\n+  \/\/ can be locked, and then re-locking the CodeCache_lock. That is not safe in\n+  \/\/ this context as we hold the CompiledICLocker. So we just don't handle code\n+  \/\/ cache exhaustion here; we leave that for a later allocation that does not\n+  \/\/ hold the CompiledICLocker.\n+  return CodeCache::allocate(size, CodeBlobType::NonNMethod, false \/* handle_alloc_failure *\/);\n+}\n+\n@@ -312,1 +322,1 @@\n-  ThreadInVMfromUnknown __tiv;  \/\/ get to VM state in case we block on CodeCache_lock\n+  assert(JavaThread::current()->thread_state() == _thread_in_vm, \"called with the wrong state\");\n@@ -321,1 +331,13 @@\n-    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    if (!CodeCache_lock->try_lock()) {\n+      \/\/ If we can't take the CodeCache_lock, then this is a bad time to perform the ongoing\n+      \/\/ IC transition to megamorphic, for which this stub will be needed. It is better to\n+      \/\/ bail out the transition, and wait for a more opportune moment. Not only is it not\n+      \/\/ worth waiting for the lock blockingly for the megamorphic transition, it might\n+      \/\/ also result in a deadlock to blockingly wait, when concurrent class unloading is\n+      \/\/ performed. At this point in time, the CompiledICLocker is taken, so we are not\n+      \/\/ allowed to blockingly wait for the CodeCache_lock, as these two locks are otherwise\n+      \/\/ consistently taken in the opposite order. Bailing out results in an IC transition to\n+      \/\/ the clean state instead, which will cause subsequent calls to retry the transitioning\n+      \/\/ eventually.\n+      return NULL;\n+    }\n@@ -323,0 +345,1 @@\n+    CodeCache_lock->unlock();\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":25,"deletions":2,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -444,0 +444,2 @@\n+  void* operator new(size_t s, unsigned size) throw();\n+\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -486,1 +486,1 @@\n-CodeBlob* CodeCache::allocate(int size, int code_blob_type, int orig_code_blob_type) {\n+CodeBlob* CodeCache::allocate(int size, int code_blob_type, bool handle_alloc_failure, int orig_code_blob_type) {\n@@ -534,1 +534,1 @@\n-          return allocate(size, type, orig_code_blob_type);\n+          return allocate(size, type, handle_alloc_failure, orig_code_blob_type);\n@@ -537,2 +537,4 @@\n-      MutexUnlocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n-      CompileBroker::handle_full_code_cache(orig_code_blob_type);\n+      if (handle_alloc_failure) {\n+        MutexUnlocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+        CompileBroker::handle_full_code_cache(orig_code_blob_type);\n+      }\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -139,1 +139,1 @@\n-  static CodeBlob* allocate(int size, int code_blob_type, int orig_code_blob_type = CodeBlobType::All); \/\/ allocates a new CodeBlob\n+  static CodeBlob* allocate(int size, int code_blob_type, bool handle_alloc_failure = true, int orig_code_blob_type = CodeBlobType::All); \/\/ allocates a new CodeBlob\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}