{"files":[{"patch":"@@ -115,0 +115,1 @@\n+    final boolean dumpMethodReferenceSearchResults;\n@@ -154,0 +155,1 @@\n+        dumpMethodReferenceSearchResults = options.isSet(\"debug.dumpMethodReferenceSearchResults\");\n@@ -2780,1 +2782,1 @@\n-                    spMethod.owner == sym.owner) {\n+                spMethod.owner == sym.owner) {\n@@ -3093,0 +3095,3 @@\n+        if (dumpMethodReferenceSearchResults) {\n+            dumpMethodReferenceSearchResults(referenceTree, boundSearchResolveContext, boundSym, true);\n+        }\n@@ -3106,0 +3111,3 @@\n+            if (dumpMethodReferenceSearchResults) {\n+                dumpMethodReferenceSearchResults(referenceTree, unboundSearchResolveContext, unboundSym, false);\n+            }\n@@ -3129,0 +3137,36 @@\n+    private void dumpMethodReferenceSearchResults(JCMemberReference referenceTree,\n+                                                  MethodResolutionContext resolutionContext,\n+                                                  Symbol bestSoFar,\n+                                                  boolean bound) {\n+        ListBuffer<JCDiagnostic> subDiags = new ListBuffer<>();\n+        int pos = 0;\n+        int mostSpecificPos = -1;\n+        for (Candidate c : resolutionContext.candidates) {\n+            if (resolutionContext.step != c.step || !c.isApplicable()) {\n+                continue;\n+            } else {\n+                JCDiagnostic subDiag = null;\n+                if (c.sym.type.hasTag(FORALL)) {\n+                    subDiag = diags.fragment(Fragments.PartialInstSig(c.mtype));\n+                }\n+\n+                String key = subDiag == null ?\n+                        \"applicable.method.found.2\" :\n+                        \"applicable.method.found.3\";\n+                subDiags.append(diags.fragment(key, pos,\n+                        c.sym.isStatic() ? Fragments.Static : Fragments.NonStatic, c.sym, subDiag));\n+                if (c.sym == bestSoFar)\n+                    mostSpecificPos = pos;\n+                pos++;\n+            }\n+        }\n+        JCDiagnostic main = diags.note(\n+                log.currentSource(),\n+                referenceTree,\n+                \"method.ref.search.results.multi\",\n+                bound ? Fragments.Bound : Fragments.Unbound,\n+                referenceTree.toString(), mostSpecificPos);\n+        JCDiagnostic d = new JCDiagnostic.MultilineDiagnostic(main, subDiags.toList());\n+        log.report(d);\n+    }\n+\n@@ -3283,1 +3327,1 @@\n-            if (boundRes.hasKind(StaticKind.STATIC) &&\n+            if (boundRes.isSuccess() && boundRes.sym.isStatic() &&\n@@ -3288,1 +3332,1 @@\n-            } else if (unboundRes.hasKind(StaticKind.NON_STATIC) &&\n+            } else if (unboundRes.isSuccess() && !unboundRes.sym.isStatic() &&\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":47,"deletions":3,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -3066,0 +3066,31 @@\n+########################################\n+# Diagnostics for method reference search\n+# results used by Resolve (debug only)\n+########################################\n+\n+# 0: fragment, 1: string, 2: number\n+compiler.note.method.ref.search.results.multi=\\\n+    {0} search results for {1}, with most specific {2}\\n\\\n+    applicable candidates:\n+\n+# 0: number, 1: fragment, 2: symbol\n+compiler.misc.applicable.method.found.2=\\\n+    #{0} applicable method found: {1} {2}\n+\n+# 0: number, 1: fragment, 2: symbol, 3: message segment\n+compiler.misc.applicable.method.found.3=\\\n+    #{0} applicable method found: {1} {2}\\n\\\n+    ({3})\n+\n+compiler.misc.static=\\\n+    static\n+\n+compiler.misc.non.static=\\\n+    non-static\n+\n+compiler.misc.bound=\\\n+    bound\n+\n+compiler.misc.unbound=\\\n+    unbound\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -124,0 +124,4 @@\n+    protected File assertOK(Consumer<Diagnostic<?>> diagConsumer, String... constructs) {\n+        return assertCompile(expandMarkers(constructs), () -> assertCompileSucceeded(diagConsumer), false);\n+    }\n+\n","filename":"test\/langtools\/lib\/combo\/tools\/javac\/combo\/CompilationTestCase.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,0 +69,4 @@\n+    public List<Diagnostic<?>> getAllDiags() {\n+        return diags.stream().map(d -> (Diagnostic<?>)d).collect(toList());\n+    }\n+\n","filename":"test\/langtools\/lib\/combo\/tools\/javac\/combo\/Diagnostics.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -180,0 +180,7 @@\n+    \/** Assert that all previous calls to compile() succeeded, also accepts a diagnostics consumer *\/\n+    protected void assertCompileSucceeded(Consumer<Diagnostic<?>> diagConsumer) {\n+        if (diags.errorsFound())\n+            fail(\"Expected successful compilation\");\n+        diags.getAllDiags().stream().forEach(diagConsumer);\n+    }\n+\n","filename":"test\/langtools\/lib\/combo\/tools\/javac\/combo\/JavacTemplateTestBase.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.note.method.ref.search.results.multi\n+\/\/ key: compiler.misc.bound\n+\/\/ key: compiler.misc.applicable.method.found.2\n+\/\/ key: compiler.misc.static\n+\/\/ key: compiler.misc.non.static\n+\/\/ key: compiler.misc.unbound\n+\/\/ options: --debug=dumpMethodReferenceSearchResults\n+\n+import java.util.function.*;\n+\n+class BoundUnboundMethRefSearch {\n+    public String foo(Object o) { return \"foo\"; }\n+    public static String foo(String o) { return \"bar\"; }\n+\n+    void m() {\n+        Function<String, String> f = BoundUnboundMethRefSearch::foo;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/BoundUnboundMethRefSearch.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.note.method.ref.search.results.multi\n+\/\/ key: compiler.misc.bound\n+\/\/ key: compiler.misc.applicable.method.found.3\n+\/\/ key: compiler.misc.static\n+\/\/ key: compiler.misc.partial.inst.sig\n+\/\/ key: compiler.misc.unbound\n+\/\/ options: --debug=dumpMethodReferenceSearchResults\n+\n+import java.util.function.*;\n+\n+class BoundUnboundMethRefSearch2 {\n+    interface SAM <T> {\n+        boolean test(T n, T m);\n+    }\n+\n+    static <T> boolean foo(T x, T y) {\n+        return false;\n+    }\n+\n+    void bar() {\n+        SAM <Integer> mRef = BoundUnboundMethRefSearch2::<Integer>foo;\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/BoundUnboundMethRefSearch2.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8231461\n+ * @summary static\/instance overload leads to 'unexpected static method found in unbound lookup' when resolving method reference\n+ * @library \/lib\/combo \/tools\/lib \/tools\/javac\/lib\n+ * @modules\n+ *      jdk.compiler\/com.sun.tools.javac.api\n+ *      jdk.compiler\/com.sun.tools.javac.util\n+ * @run testng BoundUnboundSearchTest\n+ *\/\n+\n+import java.util.function.*;\n+\n+import javax.tools.Diagnostic;\n+\n+import com.sun.tools.javac.api.ClientCodeWrapper.DiagnosticSourceUnwrapper;\n+import com.sun.tools.javac.util.Assert;\n+import com.sun.tools.javac.util.JCDiagnostic;\n+\n+import org.testng.annotations.Test;\n+import tools.javac.combo.CompilationTestCase;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+@Test\n+public class BoundUnboundSearchTest extends CompilationTestCase {\n+    static final String TEMPLATE =\n+            \"\"\"\n+            import java.util.function.*;\n+            class Test {\n+                #CANDIDATES\n+                void m() {\n+                    Function<String, String> f = Test::foo;\n+                }\n+            }\n+            \"\"\";\n+\n+    public BoundUnboundSearchTest() {\n+        setDefaultFilename(\"Test.java\");\n+        setCompileOptions(new String[]{\"--debug=dumpMethodReferenceSearchResults\"});\n+    }\n+\n+    private Consumer<Diagnostic<?>> getDiagConsumer(final int boundCandidate, final int unboundCandidate) {\n+        return diagWrapper -> {\n+            JCDiagnostic diagnostic = ((DiagnosticSourceUnwrapper)diagWrapper).d;\n+            Object[] args = diagnostic.getArgs();\n+            if (args[0].toString().equals(\"bound\")) {\n+                Assert.check(args[2].equals(boundCandidate));\n+            } else if (args[0].toString().equals(\"unbound\")) {\n+                Assert.check(args[2].equals(unboundCandidate));\n+            }\n+        };\n+    }\n+\n+    public void test() {\n+        assertOK(\n+            getDiagConsumer(0, -1),\n+                TEMPLATE.replaceFirst(\"#CANDIDATES\",\n+                    \"\"\"\n+                    public String foo(Object o) { return \"foo\"; }           \/\/ candidate 0\n+                    public static String foo(String o) { return \"bar\"; }    \/\/ candidate 1\n+                    \"\"\"\n+            )\n+        );\n+\n+        assertOK(\n+                getDiagConsumer(0, -1),\n+                TEMPLATE.replaceFirst(\"#CANDIDATES\",\n+                    \"\"\"\n+                    public static String foo(Object o) { return \"foo\"; }    \/\/ candidate 0\n+                    public static String foo(String o) { return \"bar\"; }    \/\/ candidate 0\n+                    \"\"\"\n+                )\n+        );\n+\n+        assertFail(\"compiler.err.prob.found.req\",\n+                getDiagConsumer(0, -1),\n+                TEMPLATE.replaceFirst(\"#CANDIDATES\",\n+                    \"\"\"\n+                    public static String foo(Object o) { return \"foo\"; }    \/\/ candidate 0\n+                    public String foo(String o) { return \"bar\"; }           \/\/ candidate 1\n+                    \"\"\"\n+                )\n+        );\n+\n+        assertFail(\"compiler.err.prob.found.req\",\n+                getDiagConsumer(0, -1),\n+                TEMPLATE.replaceFirst(\"#CANDIDATES\",\n+                    \"\"\"\n+                    public String foo(Object o) { return \"foo\"; }           \/\/ candidate 0\n+                    public String foo(String o) { return \"bar\"; }           \/\/ candidate 1\n+                    \"\"\"\n+                )\n+        );\n+\n+        assertFail(\"compiler.err.invalid.mref\",\n+                getDiagConsumer(-1, -1),\n+                \"\"\"\n+                import java.util.function.*;\n+\n+                public class Test {\n+                    public String foo(Object o) { return \"foo\"; }\n+                    public static String foo(String o) { return \"bar\"; }\n+\n+                    public void test() {\n+                        \/\/ method bar doesn't exist\n+                        Function<String, String> f = Test::bar;\n+                    }\n+                }\n+                \"\"\"\n+        );\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/lambda\/methodReference\/BoundUnboundSearchTest.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"}]}