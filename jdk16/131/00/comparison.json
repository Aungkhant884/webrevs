{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+import java.util.Iterator;\n@@ -854,0 +855,14 @@\n+\n+    public void removePath(SafePath path) {\n+        synchronized (recorder) {\n+            Iterator<RepositoryChunk> it = chunks.iterator();\n+            while (it.hasNext()) {\n+                RepositoryChunk c = it.next();\n+                if (c.getFile().equals(path)) {\n+                    it.remove();\n+                    removed(c);\n+                    return;\n+                }\n+            }\n+        }\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecording.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import jdk.jfr.internal.management.ChunkFilename;\n@@ -48,0 +49,1 @@\n+    private ChunkFilename chunkFilename;\n@@ -64,0 +66,1 @@\n+        this.chunkFilename = null;\n@@ -87,0 +90,1 @@\n+                chunkFilename = null;\n@@ -88,1 +92,5 @@\n-            return new RepositoryChunk(repository, timestamp);\n+            if (chunkFilename == null) {\n+                chunkFilename = ChunkFilename.newPriviliged(repository.toPath());\n+            }\n+            String filename = chunkFilename.next(timestamp.toLocalDateTime());\n+            return new RepositoryChunk(new SafePath(filename), timestamp.toInstant());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Repository.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import jdk.jfr.internal.management.ChunkFilename;\n@@ -50,1 +51,0 @@\n-    private final SafePath repositoryPath;\n@@ -59,4 +59,3 @@\n-    RepositoryChunk(SafePath path, ZonedDateTime timestamp) throws Exception {\n-        this.startTime = timestamp.toInstant();\n-        this.repositoryPath = path;\n-        this.chunkFile = findFileName(repositoryPath, timestamp.toLocalDateTime());\n+    RepositoryChunk(SafePath path, Instant startTime) throws Exception {\n+        this.startTime = startTime;\n+        this.chunkFile = path;\n@@ -66,15 +65,0 @@\n-    private static SafePath findFileName(SafePath directory, LocalDateTime time) throws Exception {\n-        String filename = Utils.formatDateTime(time);\n-        Path p = directory.toPath().resolve(filename + FILE_EXTENSION);\n-        for (int i = 1; i < MAX_CHUNK_NAMES; i++) {\n-            SafePath s = new SafePath(p);\n-            if (!SecuritySupport.exists(s)) {\n-                return s;\n-            }\n-            String extendedName = String.format(\"%s_%02d%s\", filename, i, FILE_EXTENSION);\n-            p = directory.toPath().resolve(extendedName);\n-        }\n-        p = directory.toPath().resolve(filename + \"_\" + System.currentTimeMillis() + FILE_EXTENSION);\n-        return new SafePath(p);\n-    }\n-\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/RepositoryChunk.java","additions":5,"deletions":21,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -503,0 +503,5 @@\n+\n+        @Override\n+        public boolean exists(Path p) throws IOException {\n+            return doPrivilegedIOWithReturn( () -> Files.exists(p));\n+        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/SecuritySupport.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -187,1 +187,1 @@\n-    static String formatDateTime(LocalDateTime time) {\n+    public static String formatDateTime(LocalDateTime time) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Utils.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,2 @@\n+    public abstract boolean exists(Path s) throws IOException;\n+\n@@ -74,0 +76,5 @@\n+\n+        @Override\n+        public boolean exists(Path p) {\n+            return Files.exists(p);\n+        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/FileAccess.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -122,2 +122,1 @@\n-                Instant timestamp = Utils.epochNanosToInstant(startTimeNanos);\n-                ManagementSupport.removeBefore(recording, timestamp);\n+                ManagementSupport.removePath(recording, path);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/OngoingStream.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.management;\n+\n+import java.nio.file.Paths;\n+import java.nio.file.Path;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import jdk.jfr.internal.SecuritySupport;\n+import jdk.jfr.internal.SecuritySupport.SafePath;\n+import jdk.jfr.internal.Utils;\n+import jdk.jfr.internal.consumer.FileAccess;\n+\n+\/\/ Allows a remote streaming client to create chunk files\n+\/\/ with same naming scheme as the JVM.\n+public final class ChunkFilename {\n+   private static final int MAX_CHUNK_NAMES = 100_000;\n+   private static final String FILE_EXTENSION = \".jfr\";\n+\n+   private final Path directory;\n+   private final FileAccess fileAcess;\n+\n+   private Path lastPath;\n+   private int counter;\n+\n+   public static ChunkFilename newUnpriviliged(Path directory) {\n+       return new ChunkFilename(directory, FileAccess.UNPRIVILEGED);\n+   }\n+\n+   public static ChunkFilename newPriviliged(Path directory) {\n+       return new ChunkFilename(directory, SecuritySupport.PRIVILEGED);\n+   }\n+\n+   private ChunkFilename(Path directory, FileAccess fileAccess) {\n+       \/\/ Avoid malicious implementations of Path interface\n+       this.directory = Paths.get(directory.toString());\n+       this.fileAcess = fileAccess;\n+   }\n+\n+   public String next(LocalDateTime time) throws IOException {\n+       String filename = Utils.formatDateTime(time);\n+       Path p = directory.resolve(filename + FILE_EXTENSION);\n+\n+       \/\/ If less than one file per second (typically case)\n+       if (lastPath == null || !p.equals(lastPath)) {\n+           if (!fileAcess.exists(p)) {\n+               counter = 1; \/\/ reset counter\n+               lastPath = p;\n+               return p.toString();\n+           }\n+       }\n+\n+       \/\/ If more than one file per second\n+       while (counter < MAX_CHUNK_NAMES) {\n+           String extendedName = String.format(\"%s_%02d%s\", filename, counter, FILE_EXTENSION);\n+           p = directory.resolve(extendedName);\n+           counter++;\n+           if (!fileAcess.exists(p)) {\n+               return p.toString();\n+           }\n+       }\n+       throw new IOException(\"Unable to find unused filename after \" + counter + \" attempts\");\n+   }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/ChunkFilename.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,0 +52,1 @@\n+import jdk.jfr.internal.SecuritySupport.SafePath;\n@@ -144,0 +145,1 @@\n+    }\n@@ -145,0 +147,4 @@\n+    \/\/ Needed callback to detect when a chunk has been parsed.\n+    public static void removePath(Recording recording, Path path) {\n+        PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);\n+        pr.removePath(new SafePath(path));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/ManagementSupport.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.nio.file.Paths;\n@@ -43,0 +44,1 @@\n+import jdk.jfr.internal.management.ChunkFilename;\n@@ -49,1 +51,2 @@\n-        final Instant startTime;\n+        final long startTimeNanos;\n+        long endTimeNanos;\n@@ -55,1 +58,1 @@\n-            this.startTime = ManagementSupport.epochNanosToInstant(startNanos);\n+            this.startTimeNanos = startNanos;\n@@ -77,0 +80,1 @@\n+    static final String FILE_EXTENSION = \".jfr\";\n@@ -83,0 +87,1 @@\n+    private final ChunkFilename chunkFilename;\n@@ -106,0 +111,1 @@\n+        this.chunkFilename = ChunkFilename.newUnpriviliged(path);\n@@ -298,2 +304,2 @@\n-            Duration d = Duration.ofNanos(durationNanos);\n-            currentChunk.endTime = currentChunk.startTime.plus(d);\n+            currentChunk.endTimeNanos = currentChunk.startTimeNanos + durationNanos;\n+            currentChunk.endTime = ManagementSupport.epochNanosToInstant(currentChunk.endTimeNanos);\n@@ -328,38 +334,2 @@\n-        String filename = formatDateTime(d);\n-        Path p1 = directory.resolve(filename + \".jfr\");\n-        if (!Files.exists(p1)) {\n-            return new DiskChunk(p1, nanos);\n-        }\n-        for (int i = 1; i < 100; i++) {\n-            String s = Integer.toString(i);\n-            if (i < 10) {\n-                s = \"0\" + s;\n-            }\n-            Path p2 = directory.resolve(filename + \"_\" + s + \".jfr\");\n-            if (!Files.exists(p2)) {\n-                return new DiskChunk(p2, nanos);\n-            }\n-        }\n-        throw new IOException(\"Could not create chunk for path \" + p1);\n-    }\n-\n-    static String formatDateTime(LocalDateTime time) {\n-        StringBuilder sb = new StringBuilder(19);\n-        sb.append(time.getYear() \/ 100);\n-        appendPadded(sb, time.getYear() % 100, true);\n-        appendPadded(sb, time.getMonth().getValue(), true);\n-        appendPadded(sb, time.getDayOfMonth(), true);\n-        appendPadded(sb, time.getHour(), true);\n-        appendPadded(sb, time.getMinute(), true);\n-        appendPadded(sb, time.getSecond(), false);\n-        return sb.toString();\n-    }\n-\n-    private static void appendPadded(StringBuilder text, int number, boolean separator) {\n-        if (number < 10) {\n-            text.append('0');\n-        }\n-        text.append(number);\n-        if (separator) {\n-            text.append('_');\n-        }\n+        String filename = chunkFilename.next(d);\n+        return new DiskChunk(Paths.get(filename), nanos);\n@@ -426,1 +396,1 @@\n-    public synchronized void onChunkComplete(Instant timestamp) {\n+    public synchronized void onChunkComplete(long endTimeNanos) {\n@@ -430,1 +400,1 @@\n-            if (oldestChunk.startTime.isBefore(timestamp)) {\n+            if (oldestChunk.startTimeNanos < endTimeNanos) {\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/DiskRepository.java","additions":15,"deletions":45,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+import jdk.jfr.internal.management.ManagementSupport;\n+\n@@ -38,1 +40,2 @@\n-    DownLoadThread(RemoteRecordingStream stream) {\n+    DownLoadThread(RemoteRecordingStream stream, String name) {\n+        super(name);\n@@ -68,1 +71,1 @@\n-           \/\/ ignore\n+            ManagementSupport.logDebug(ioe.getMessage());\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/DownLoadThread.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -136,2 +136,1 @@\n-            Instant t = ManagementSupport.epochNanosToInstant(endNanos);\n-            repository.onChunkComplete(t);\n+            repository.onChunkComplete(endNanos);\n@@ -555,2 +554,2 @@\n-        Thread downLoadThread = new DownLoadThread(this);\n-        downLoadThread.setName(\"JFR: Download Thread \" + creationTime);\n+        String name = \"JFR: Download Thread \" + creationTime;\n+        Thread downLoadThread = new DownLoadThread(this, name);\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/RemoteRecordingStream.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -852,1 +852,0 @@\n-jdk\/jfr\/jmx\/streaming\/TestRotate.java                           8257215 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n- * @run main\/othervm jdk.jfr.jmx.streaming.TestRotate\n+ * @run main\/othervm -Xlog:jfr=debug jdk.jfr.jmx.streaming.TestRotate\n","filename":"test\/jdk\/jdk\/jfr\/jmx\/streaming\/TestRotate.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}