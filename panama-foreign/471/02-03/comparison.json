{"files":[{"patch":"@@ -113,1 +113,1 @@\n-        -Xplugin:\"RestrictedMethodsFinder $(SUPPORT_OUTPUTDIR)\/link_opt\/restricted_native_methods.txt\" \\\n+        -Xplugin:\"NativeAccessMethodsFinder $(SUPPORT_OUTPUTDIR)\/link_opt\/native_access_methods.txt\" \\\n","filename":"make\/CompileJavaModules.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-\t$(ECHO) build.tools.panama.RestrictedMethodsFinder > $@\n+\t$(ECHO) build.tools.panama.NativeAccessMethodsFinder > $@\n","filename":"make\/CompileToolsJdk.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-RESTRICTED_NATIVE_METHODS_FILE := $(LINK_OPT_DIR)\/restricted_native_methods.txt\n+NATIVE_ACCESS_METHODS_FILE := $(LINK_OPT_DIR)\/native_access_methods.txt\n@@ -127,3 +127,3 @@\n-# Copy the restricted_native_methods.txt file into jdk.jlink\n-$(eval $(call SetupCopyFiles, COPY_RESTRICTED_NATIVE_METHODS, \\\n-    FILES := $(RESTRICTED_NATIVE_METHODS_FILE), \\\n+# Copy the native_access_methods.txt file into jdk.jlink\n+$(eval $(call SetupCopyFiles, COPY_NATIVE_ACCESS_METHODS, \\\n+    FILES := $(NATIVE_ACCESS_METHODS_FILE), \\\n@@ -138,1 +138,1 @@\n-TARGETS += $(COPY_JLI_TRACE) $(COPY_RESTRICTED_NATIVE_METHODS)\n+TARGETS += $(COPY_JLI_TRACE) $(COPY_NATIVE_ACCESS_METHODS)\n","filename":"make\/GenerateLinkOptData.gmk","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-JLINK_RESTRICTED_NATIVE := --restricted-native-marker=@$(SUPPORT_OUTPUTDIR)\/link_opt\/restricted_native_methods.txt\n+JLINK_NATIVE_ACCESS := --native-access-marker=@$(SUPPORT_OUTPUTDIR)\/link_opt\/native_access_methods.txt\n@@ -81,1 +81,1 @@\n-    $(JLINK_RESTRICTED_NATIVE) \\\n+    $(JLINK_NATIVE_ACCESS) \\\n","filename":"make\/Images.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-\t    --disable-plugin restricted-native-marker \\\n+\t    --disable-plugin native-access-marker \\\n","filename":"make\/InterimImage.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-public class RestrictedMethodsFinder implements Plugin {\n+public class NativeAccessMethodsFinder implements Plugin {\n@@ -59,1 +59,1 @@\n-    private static final String RESTRICTED_NATIVE = \"jdk.internal.vm.annotation.RestrictedNative\";\n+    private static final String NATIVE_ACCESS = \"jdk.internal.vm.annotation.NativeAccess\";\n@@ -162,1 +162,1 @@\n-        return checkAnnotation(execElem, RESTRICTED_NATIVE);\n+        return checkAnnotation(execElem, NATIVE_ACCESS);\n@@ -172,1 +172,1 @@\n-        return \"RestrictedMethodsFinder\";\n+        return \"NativeAccessMethodsFinder\";\n","filename":"make\/jdk\/src\/classes\/build\/tools\/panama\/NativeAccessMethodsFinder.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"make\/jdk\/src\/classes\/build\/tools\/panama\/RestrictedMethodsFinder.java","status":"renamed"},{"patch":"@@ -1093,1 +1093,1 @@\n-    _method_RestrictedNative,\n+    _method_NativeAccess,\n@@ -2132,1 +2132,1 @@\n-    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_RestrictedNative_signature): {\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_NativeAccess_signature): {\n@@ -2134,1 +2134,1 @@\n-      return _method_RestrictedNative;\n+      return _method_NativeAccess;\n@@ -2198,2 +2198,2 @@\n-  if (has_annotation(_method_RestrictedNative))\n-    m->set_restricted_native(true);\n+  if (has_annotation(_method_NativeAccess))\n+    m->set_native_access(true);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1626,1 +1626,1 @@\n-      jb_module->set_is_native(true);\n+      jb_module->set_is_native_access(true);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2948,1 +2948,1 @@\n-const int java_lang_reflect_Method::RESTRICTED_NATIVE = 0x1;\n+const int java_lang_reflect_Method::NATIVE_ACCESS = 0x1;\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -593,1 +593,1 @@\n-  static const int RESTRICTED_NATIVE;\n+  static const int NATIVE_ACCESS;\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -209,2 +209,2 @@\n-bool ModuleEntry::is_native() const {\n-  return _is_native || (name() == NULL && Modules::is_all_unnamed_native_access());\n+bool ModuleEntry::is_native_access() const {\n+  return _is_native_access || (name() == NULL && Modules::is_all_unnamed_native_access());\n@@ -219,2 +219,2 @@\n-\/\/ Set whether the module is native, i.e. restricted native operations are allowed by clients in this module\n-void ModuleEntry::set_is_native(bool is_native) {\n+\/\/ Set whether the module is native, i.e. native operations are allowed by clients in this module\n+void ModuleEntry::set_is_native_access(bool is_native_access) {\n@@ -222,1 +222,1 @@\n-  _is_native = is_native;\n+  _is_native_access = is_native_access;\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-  bool _is_native;                     \/\/ whether the module is native via --enable-native-access\n+  bool _is_native_access;              \/\/ whether the module is native via --enable-native-access\n@@ -99,1 +99,1 @@\n-    _is_native = false;\n+    _is_native_access = false;\n@@ -134,1 +134,1 @@\n-  bool             is_native() const;\n+  bool             is_native_access() const;\n@@ -137,1 +137,1 @@\n-  void             set_is_native(bool is_native);\n+  void             set_is_native_access(bool is_native_access);\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -796,1 +796,1 @@\n-  module_entry->set_is_native(true);\n+  module_entry->set_is_native_access(true);\n","filename":"src\/hotspot\/share\/classfile\/modules.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -309,1 +309,1 @@\n-  template(jdk_internal_vm_annotation_RestrictedNative_signature,    \"Ljdk\/internal\/vm\/annotation\/RestrictedNative;\") \\\n+  template(jdk_internal_vm_annotation_NativeAccess_signature,    \"Ljdk\/internal\/vm\/annotation\/NativeAccess;\") \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -668,1 +668,1 @@\n-void LinkResolver::check_restricted_method(const LinkInfo& link_info,\n+void LinkResolver::check_native_access_method(const LinkInfo& link_info,\n@@ -671,1 +671,1 @@\n-    if (resolved_method->is_restricted_native()) {\n+    if (resolved_method->is_native_access()) {\n@@ -673,1 +673,1 @@\n-      if (!module->is_native()) {\n+      if (!module->is_native_access()) {\n@@ -827,1 +827,1 @@\n-  check_restricted_method(link_info, resolved_method, CHECK_NULL);\n+  check_native_access_method(link_info, resolved_method, CHECK_NULL);\n@@ -924,1 +924,1 @@\n-  check_restricted_method(link_info, resolved_method, CHECK_NULL);\n+  check_native_access_method(link_info, resolved_method, CHECK_NULL);\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -226,1 +226,1 @@\n-  static void check_restricted_method(const LinkInfo& link_info,\n+  static void check_native_access_method(const LinkInfo& link_info,\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-    _restricted_native     = 1 << 9\n+    _native_access         = 1 << 9\n@@ -883,2 +883,2 @@\n-  bool is_restricted_native() const {\n-    return (_flags & _restricted_native) != 0;\n+  bool is_native_access() const {\n+    return (_flags & _native_access) != 0;\n@@ -887,2 +887,2 @@\n-  void set_restricted_native(bool x) {\n-    _flags = x ? (_flags | _restricted_native) : (_flags & ~_restricted_native);\n+  void set_native_access(bool x) {\n+    _flags = x ? (_flags | _native_access) : (_flags & ~_native_access);\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -827,2 +827,2 @@\n-  if (method->is_restricted_native()) {\n-    java_lang_reflect_Method::set_flags(mh(), java_lang_reflect_Method::RESTRICTED_NATIVE);\n+  if (method->is_native_access()) {\n+    java_lang_reflect_Method::set_flags(mh(), java_lang_reflect_Method::NATIVE_ACCESS);\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -73,2 +73,2 @@\n-    private static final int RESTRICTED_NATIVE = 0x1;\n-    \/\/ Method internal flags needed here. For now, only RESTRICTED_NATIVE.\n+    private static final int NATIVE_ACCESS = 0x1;\n+    \/\/ Method internal flags needed here. For now, only NATIVE_ACCESS.\n@@ -502,2 +502,2 @@\n-    private boolean isRestrictedNative() {\n-        return (flags & RESTRICTED_NATIVE) != 0;\n+    private boolean isNativeAccess() {\n+        return (flags & NATIVE_ACCESS) != 0;\n@@ -506,1 +506,1 @@\n-    private final void checkRestrictedNative(Class<?> caller) throws IllegalAccessException {\n+    private final void checkNativeAccess(Class<?> caller) throws IllegalAccessException {\n@@ -591,1 +591,1 @@\n-        if (isRestrictedNative()) {\n+        if (isNativeAccess()) {\n@@ -593,1 +593,1 @@\n-            checkRestrictedNative(caller);\n+            checkNativeAccess(caller);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * FIXME\n+ * Documents that the method is a native access method.\n@@ -38,1 +38,1 @@\n-public @interface RestrictedNative {\n+public @interface NativeAccess {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/NativeAccess.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/RestrictedNative.java","status":"renamed"},{"patch":"@@ -31,1 +31,1 @@\n-import jdk.internal.vm.annotation.RestrictedNative;\n+import jdk.internal.vm.annotation.NativeAccess;\n@@ -123,1 +123,1 @@\n-    @RestrictedNative\n+    @NativeAccess\n@@ -319,1 +319,1 @@\n-    @RestrictedNative\n+    @NativeAccess\n@@ -341,1 +341,1 @@\n-    @RestrictedNative\n+    @NativeAccess\n@@ -415,1 +415,1 @@\n-    @RestrictedNative\n+    @NativeAccess\n@@ -434,1 +434,1 @@\n-    @RestrictedNative\n+    @NativeAccess\n@@ -622,1 +622,1 @@\n-        @RestrictedNative\n+        @NativeAccess\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.internal.vm.annotation.RestrictedNative;\n+import jdk.internal.vm.annotation.NativeAccess;\n@@ -105,1 +105,1 @@\n-    @RestrictedNative\n+    @NativeAccess\n@@ -121,1 +121,1 @@\n-    @RestrictedNative\n+    @NativeAccess\n@@ -143,1 +143,1 @@\n-    @RestrictedNative\n+    @NativeAccess\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/LibraryLookup.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import jdk.internal.vm.annotation.RestrictedNative;\n+import jdk.internal.vm.annotation.NativeAccess;\n@@ -121,1 +121,1 @@\n-    @RestrictedNative\n+    @NativeAccess\n@@ -160,1 +160,1 @@\n-    @RestrictedNative\n+    @NativeAccess\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAddress.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-import jdk.internal.vm.annotation.RestrictedNative;\n+import jdk.internal.vm.annotation.NativeAccess;\n@@ -939,1 +939,1 @@\n-    @RestrictedNative\n+    @NativeAccess\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import jdk.internal.vm.annotation.RestrictedNative;\n+import jdk.internal.vm.annotation.NativeAccess;\n@@ -97,1 +97,1 @@\n-    @RestrictedNative\n+    @NativeAccess\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryAddressImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,283 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.tools.jlink.internal.plugins;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.EnumSet;\n+import java.util.HashSet;\n+import java.util.stream.Collectors;\n+\n+import jdk.internal.org.objectweb.asm.Attribute;\n+import jdk.internal.org.objectweb.asm.ByteVector;\n+import jdk.internal.org.objectweb.asm.ClassReader;\n+import jdk.internal.org.objectweb.asm.ClassVisitor;\n+import jdk.internal.org.objectweb.asm.ClassWriter;\n+import jdk.internal.org.objectweb.asm.MethodVisitor;\n+import jdk.internal.org.objectweb.asm.Opcodes;\n+\n+import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+import static jdk.internal.module.ClassFileConstants.*;\n+\n+import jdk.tools.jlink.plugin.PluginException;\n+import jdk.tools.jlink.plugin.ResourcePool;\n+import jdk.tools.jlink.plugin.ResourcePoolBuilder;\n+import jdk.tools.jlink.plugin.ResourcePoolEntry;\n+\n+\/**\n+ * Jlink plugin makes modules that use NativeAccessNative methods.\n+ *\/\n+public final class NativeAccessMarkerPlugin extends AbstractPlugin {\n+    private static final boolean DEBUG = Boolean.getBoolean(\"jlink.native_access_marker.debug\");\n+    private static final String NATIVE_ACCESS_METHODS_FILE = \"native_access_methods.txt\";\n+\n+    \/\/ info on @NativeAccess methods\n+    private List<NativeAccessMethod> nativeAccessMethods;\n+    \/\/ modules that call @NativeAccess methods\n+    private Set<String> nativeAccessCallerModules = new HashSet<>();\n+\n+    public NativeAccessMarkerPlugin() {\n+        super(\"native-access-marker\");\n+    }\n+\n+    @Override\n+    public Set<State> getState() {\n+        return EnumSet.of(State.AUTO_ENABLED, State.FUNCTIONAL);\n+    }\n+\n+    @Override\n+    public boolean hasArguments() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void configure(Map<String, String> config) {\n+        String mainArgument = config.get(getName());\n+        \/\/ Load configuration from the contents in the supplied input file\n+        \/\/ - if none was supplied we look for the default file\n+        if (mainArgument == null || !mainArgument.startsWith(\"@\")) {\n+            try (InputStream traceFile =\n+                         this.getClass().getResourceAsStream(NATIVE_ACCESS_METHODS_FILE)) {\n+                nativeAccessMethods = new BufferedReader(new InputStreamReader(traceFile)).\n+                        lines().map(NativeAccessMethod::new).collect(Collectors.toList());\n+            } catch (Exception e) {\n+                throw new PluginException(\"Couldn't read \" + NATIVE_ACCESS_METHODS_FILE, e);\n+            }\n+        } else {\n+            File file = new File(mainArgument.substring(1));\n+            nativeAccessMethods = fileLines(file);\n+        }\n+\n+        if (DEBUG) {\n+            System.err.println(\"====== NativeAccess methods start ======\");\n+            for (NativeAccessMethod rm : nativeAccessMethods) {\n+                rm.print();\n+            }\n+            System.err.println(\"====== NativeAccess methods end ======\");\n+        }\n+    }\n+\n+    private List<NativeAccessMethod> fileLines(File file) {\n+        try {\n+            return Files.lines(file.toPath()).map(NativeAccessMethod::new).collect(Collectors.toList());\n+        } catch (IOException io) {\n+            throw new PluginException(\"Couldn't read file\");\n+        }\n+    }\n+\n+    @Override\n+    public ResourcePool transform(ResourcePool in, ResourcePoolBuilder out) {\n+        \/\/ pass through all resources other than \"module-info.class\"es\n+        in.entries()\n+                .filter(data -> !data.path().endsWith(\"\/module-info.class\"))\n+                .forEach(data -> checkNative(data, out));\n+\n+        if (DEBUG) {\n+            System.err.printf(\"restricted panama modules: %s\\n\", nativeAccessCallerModules);\n+        }\n+\n+        \/\/ transform (if needed), and add the module-info.class files\n+        transformModuleInfos(in, out);\n+\n+        return out.build();\n+    }\n+\n+    private void checkNative(ResourcePoolEntry data, ResourcePoolBuilder out) {\n+        out.add(data);\n+        String moduleName = data.moduleName();\n+        if (isNativeAccessPanama(moduleName)) {\n+            \/\/ already detected to be restricted panama module. No need to check\n+            \/\/ further resources.\n+            if (DEBUG) {\n+                System.err.printf(\"module %s marked, skipping %s\\n\", moduleName, data.path());\n+            }\n+            return;\n+        }\n+\n+        \/\/ check only .class resources\n+        if (data.type().equals(ResourcePoolEntry.Type.CLASS_OR_RESOURCE) &&\n+                data.path().endsWith(\".class\")) {\n+            if (hasNativeAccessCalls(data.contentBytes())) {\n+                if (DEBUG) {\n+                    System.err.printf(\"module %s NativeAccessNative due to %s\\n\", moduleName, data.path());\n+                }\n+                nativeAccessCallerModules.add(moduleName);\n+            }\n+        }\n+    }\n+\n+    private boolean isNativeAccessPanama(String moduleName) {\n+        return nativeAccessCallerModules.contains(moduleName);\n+    }\n+\n+    \/\/ find if there are restricted calls in the given .class resource\n+    private boolean hasNativeAccessCalls(byte[] bytes) {\n+        ClassReader reader = new ClassReader(bytes);\n+        boolean[] foundNativeAccess = new boolean[1];\n+\n+        ClassVisitor cv = new ClassVisitor(Opcodes.ASM8) {\n+            @Override\n+            public MethodVisitor visitMethod(int access,\n+                                             String name, String descriptor,\n+                                             String signature, String[] exceptions) {\n+                if ((access & ACC_NATIVE) == 0 && (access & ACC_ABSTRACT) == 0) {\n+                    return new MethodVisitor(Opcodes.ASM8,\n+                            super.visitMethod(access, name, descriptor,\n+                                    signature, exceptions)) {\n+                        @Override\n+                        public void visitMethodInsn(int opcode, String owner,\n+                                                    String name, String descriptor, boolean isInterface) {\n+                            super.visitMethodInsn(opcode, owner, name, descriptor, isInterface);\n+                            if (!foundNativeAccess[0]) {\n+                                foundNativeAccess[0] = isNativeAccessMethod(owner, name, descriptor);\n+                            }\n+                        }\n+                    };\n+                } else {\n+                    return null;\n+                }\n+            }\n+        };\n+\n+        reader.accept(cv, 0);\n+        return foundNativeAccess[0];\n+    }\n+\n+    \/\/ check against known restricted methods\n+    private boolean isNativeAccessMethod(String owner, String name, String descriptor) {\n+        for (NativeAccessMethod rm : nativeAccessMethods) {\n+            if (rm.match(owner, name, descriptor)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Transforms the module-info.class files in the modules, marking native or not.\n+     *\/\n+    private void transformModuleInfos(ResourcePool in, ResourcePoolBuilder out) {\n+        in.moduleView().modules().forEach(module -> {\n+            ResourcePoolEntry data = module.findEntry(\"module-info.class\").orElseThrow(\n+                    \/\/ FIXME: automatic modules not supported yet\n+                    \/\/ add something in META-INFO?\n+                    () -> new PluginException(\"module-info.class not found for \" +\n+                            module.name() + \" module\")\n+            );\n+\n+            assert module.name().equals(data.moduleName());\n+\n+            String moduleName = data.moduleName();\n+            boolean isPanama = nativeAccessCallerModules.contains(moduleName);\n+            if (isPanama) {\n+                \/\/ add a class level attribute if we found a panama method\n+                \/\/ call from the currently visited module\n+                ClassReader reader = new ClassReader(data.contentBytes());\n+                ClassWriter cw = new ClassWriter(reader, 0);\n+                ClassVisitor cv = new ClassVisitor(Opcodes.ASM8, cw) {\n+                    @Override\n+                    public void visitEnd() {\n+                        cw.visitAttribute(newAttribute(MODULE_RESTRICTED_NATIVE));\n+                        super.visitEnd();\n+                    }\n+                };\n+\n+                reader.accept(cv, 0);\n+\n+                \/\/ add resource pool entry\n+                out.add(data.copyWithContent(cw.toByteArray()));\n+            } else {\n+                \/\/ not a native module. copy module-info 'as is'\n+                out.add(data);\n+            }\n+        });\n+    }\n+\n+    \/\/ empty .class attribute of given name\n+    private Attribute newAttribute(String name) {\n+        return new Attribute(name) {\n+            @Override\n+            protected ByteVector write(\n+                    final ClassWriter classWriter,\n+                    final byte[] code,\n+                    final int codeLength,\n+                    final int maxStack,\n+                    final int maxLocals) {\n+                return new ByteVector();\n+            }\n+        };\n+    }\n+\n+    \/\/ info about a restricted method\n+    private static class NativeAccessMethod {\n+        final String className;\n+        final String methodName;\n+        final String methodDesc;\n+\n+        NativeAccessMethod(String line) {\n+            String[] parts = line.split(\" \");\n+            this.className = parts[0];\n+            this.methodName = parts[1];\n+            this.methodDesc = parts[2];\n+        }\n+\n+        void print() {\n+            System.err.printf(\"NativeAccess method: %s %s %s\\n\", className, methodName, methodDesc);\n+        }\n+\n+        boolean match(String owner, String name, String descriptor) {\n+            return className.equals(owner) && methodName.equals(name) && methodDesc.equals(descriptor);\n+        }\n+    }\n+}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/NativeAccessMarkerPlugin.java","additions":283,"deletions":0,"binary":false,"changes":283,"status":"added"},{"patch":"@@ -1,283 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.tools.jlink.internal.plugins;\n-\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.BufferedReader;\n-import java.io.File;\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.EnumSet;\n-import java.util.HashSet;\n-import java.util.stream.Collectors;\n-\n-import jdk.internal.org.objectweb.asm.Attribute;\n-import jdk.internal.org.objectweb.asm.ByteVector;\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import jdk.internal.org.objectweb.asm.ClassVisitor;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n-import static jdk.internal.module.ClassFileConstants.*;\n-\n-import jdk.tools.jlink.plugin.PluginException;\n-import jdk.tools.jlink.plugin.ResourcePool;\n-import jdk.tools.jlink.plugin.ResourcePoolBuilder;\n-import jdk.tools.jlink.plugin.ResourcePoolEntry;\n-\n-\/**\n- * Jlink plugin makes modules that use RestrictedNative methods.\n- *\/\n-public final class RestrictedNativeMarkerPlugin extends AbstractPlugin {\n-    private static final boolean DEBUG = Boolean.getBoolean(\"jlink.restricted_native_marker.debug\");\n-    private static final String RESTRICTED_NATIVE_METHODS_FILE = \"restricted_native_methods.txt\";\n-\n-    \/\/ info on restricted methods\n-    private List<RestrictedMethod> restrictedMethods;\n-    \/\/ modules that use Panama RestrictedNative methods\n-    private Set<String> restrictedPanamaModules = new HashSet<>();\n-\n-    public RestrictedNativeMarkerPlugin() {\n-        super(\"restricted-native-marker\");\n-    }\n-\n-    @Override\n-    public Set<State> getState() {\n-        return EnumSet.of(State.AUTO_ENABLED, State.FUNCTIONAL);\n-    }\n-\n-    @Override\n-    public boolean hasArguments() {\n-        return true;\n-    }\n-\n-    @Override\n-    public void configure(Map<String, String> config) {\n-        String mainArgument = config.get(getName());\n-        \/\/ Load configuration from the contents in the supplied input file\n-        \/\/ - if none was supplied we look for the default file\n-        if (mainArgument == null || !mainArgument.startsWith(\"@\")) {\n-            try (InputStream traceFile =\n-                         this.getClass().getResourceAsStream(RESTRICTED_NATIVE_METHODS_FILE)) {\n-                restrictedMethods = new BufferedReader(new InputStreamReader(traceFile)).\n-                        lines().map(RestrictedMethod::new).collect(Collectors.toList());\n-            } catch (Exception e) {\n-                throw new PluginException(\"Couldn't read \" + RESTRICTED_NATIVE_METHODS_FILE, e);\n-            }\n-        } else {\n-            File file = new File(mainArgument.substring(1));\n-            restrictedMethods = fileLines(file);\n-        }\n-\n-        if (DEBUG) {\n-            System.err.println(\"====== Restricted methods start ======\");\n-            for (RestrictedMethod rm : restrictedMethods) {\n-                rm.print();\n-            }\n-            System.err.println(\"====== Restricted methods end ======\");\n-        }\n-    }\n-\n-    private List<RestrictedMethod> fileLines(File file) {\n-        try {\n-            return Files.lines(file.toPath()).map(RestrictedMethod::new).collect(Collectors.toList());\n-        } catch (IOException io) {\n-            throw new PluginException(\"Couldn't read file\");\n-        }\n-    }\n-\n-    @Override\n-    public ResourcePool transform(ResourcePool in, ResourcePoolBuilder out) {\n-        \/\/ pass through all resources other than \"module-info.class\"es\n-        in.entries()\n-                .filter(data -> !data.path().endsWith(\"\/module-info.class\"))\n-                .forEach(data -> checkNative(data, out));\n-\n-        if (DEBUG) {\n-            System.err.printf(\"restricted panama modules: %s\\n\", restrictedPanamaModules);\n-        }\n-\n-        \/\/ transform (if needed), and add the module-info.class files\n-        transformModuleInfos(in, out);\n-\n-        return out.build();\n-    }\n-\n-    private void checkNative(ResourcePoolEntry data, ResourcePoolBuilder out) {\n-        out.add(data);\n-        String moduleName = data.moduleName();\n-        if (isRestrictedPanama(moduleName)) {\n-            \/\/ already detected to be restricted panama module. No need to check\n-            \/\/ further resources.\n-            if (DEBUG) {\n-                System.err.printf(\"module %s marked, skipping %s\\n\", moduleName, data.path());\n-            }\n-            return;\n-        }\n-\n-        \/\/ check only .class resources\n-        if (data.type().equals(ResourcePoolEntry.Type.CLASS_OR_RESOURCE) &&\n-                data.path().endsWith(\".class\")) {\n-            if (hasRestrictedCalls(data.contentBytes())) {\n-                if (DEBUG) {\n-                    System.err.printf(\"module %s RestrictedNativedue to %s\\n\", moduleName, data.path());\n-                }\n-                restrictedPanamaModules.add(moduleName);\n-            }\n-        }\n-    }\n-\n-    private boolean isRestrictedPanama(String moduleName) {\n-        return restrictedPanamaModules.contains(moduleName);\n-    }\n-\n-    \/\/ find if there are restricted calls in the given .class resource\n-    private boolean hasRestrictedCalls(byte[] bytes) {\n-        ClassReader reader = new ClassReader(bytes);\n-        boolean[] foundRestricted = new boolean[1];\n-\n-        ClassVisitor cv = new ClassVisitor(Opcodes.ASM8) {\n-            @Override\n-            public MethodVisitor visitMethod(int access,\n-                                             String name, String descriptor,\n-                                             String signature, String[] exceptions) {\n-                if ((access & ACC_NATIVE) == 0 && (access & ACC_ABSTRACT) == 0) {\n-                    return new MethodVisitor(Opcodes.ASM8,\n-                            super.visitMethod(access, name, descriptor,\n-                                    signature, exceptions)) {\n-                        @Override\n-                        public void visitMethodInsn(int opcode, String owner,\n-                                                    String name, String descriptor, boolean isInterface) {\n-                            super.visitMethodInsn(opcode, owner, name, descriptor, isInterface);\n-                            if (!foundRestricted[0]) {\n-                                foundRestricted[0] = isRestrictedMethod(owner, name, descriptor);\n-                            }\n-                        }\n-                    };\n-                } else {\n-                    return null;\n-                }\n-            }\n-        };\n-\n-        reader.accept(cv, 0);\n-        return foundRestricted[0];\n-    }\n-\n-    \/\/ check against known restricted methods\n-    private boolean isRestrictedMethod(String owner, String name, String descriptor) {\n-        for (RestrictedMethod rm : restrictedMethods) {\n-            if (rm.match(owner, name, descriptor)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    \/**\n-     * Transforms the module-info.class files in the modules, marking native or not.\n-     *\/\n-    private void transformModuleInfos(ResourcePool in, ResourcePoolBuilder out) {\n-        in.moduleView().modules().forEach(module -> {\n-            ResourcePoolEntry data = module.findEntry(\"module-info.class\").orElseThrow(\n-                    \/\/ FIXME: automatic modules not supported yet\n-                    \/\/ add something in META-INFO?\n-                    () -> new PluginException(\"module-info.class not found for \" +\n-                            module.name() + \" module\")\n-            );\n-\n-            assert module.name().equals(data.moduleName());\n-\n-            String moduleName = data.moduleName();\n-            boolean isPanama = restrictedPanamaModules.contains(moduleName);\n-            if (isPanama) {\n-                \/\/ add a class level attribute if we found a panama method\n-                \/\/ call from the currently visited module\n-                ClassReader reader = new ClassReader(data.contentBytes());\n-                ClassWriter cw = new ClassWriter(reader, 0);\n-                ClassVisitor cv = new ClassVisitor(Opcodes.ASM8, cw) {\n-                    @Override\n-                    public void visitEnd() {\n-                        cw.visitAttribute(newAttribute(MODULE_RESTRICTED_NATIVE));\n-                        super.visitEnd();\n-                    }\n-                };\n-\n-                reader.accept(cv, 0);\n-\n-                \/\/ add resource pool entry\n-                out.add(data.copyWithContent(cw.toByteArray()));\n-            } else {\n-                \/\/ not a native module. copy module-info 'as is'\n-                out.add(data);\n-            }\n-        });\n-    }\n-\n-    \/\/ empty .class attribute of given name\n-    private Attribute newAttribute(String name) {\n-        return new Attribute(name) {\n-            @Override\n-            protected ByteVector write(\n-                    final ClassWriter classWriter,\n-                    final byte[] code,\n-                    final int codeLength,\n-                    final int maxStack,\n-                    final int maxLocals) {\n-                return new ByteVector();\n-            }\n-        };\n-    }\n-\n-    \/\/ info about a restricted method\n-    private static class RestrictedMethod {\n-        final String className;\n-        final String methodName;\n-        final String methodDesc;\n-\n-        RestrictedMethod(String line) {\n-            String[] parts = line.split(\" \");\n-            this.className = parts[0];\n-            this.methodName = parts[1];\n-            this.methodDesc = parts[2];\n-        }\n-\n-        void print() {\n-            System.err.printf(\"Restricted method: %s %s %s\\n\", className, methodName, methodDesc);\n-        }\n-\n-        boolean match(String owner, String name, String descriptor) {\n-            return className.equals(owner) && methodName.equals(name) && methodDesc.equals(descriptor);\n-        }\n-    }\n-}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/RestrictedNativeMarkerPlugin.java","additions":0,"deletions":283,"binary":false,"changes":283,"status":"deleted"},{"patch":"@@ -76,1 +76,1 @@\n-        jdk.tools.jlink.internal.plugins.RestrictedNativeMarkerPlugin,\n+        jdk.tools.jlink.internal.plugins.NativeAccessMarkerPlugin,\n","filename":"src\/jdk.jlink\/share\/classes\/module-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}