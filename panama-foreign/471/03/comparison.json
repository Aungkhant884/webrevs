{"files":[{"patch":"@@ -113,0 +113,1 @@\n+        -Xplugin:\"NativeAccessMethodsFinder $(SUPPORT_OUTPUTDIR)\/link_opt\/native_access_methods.txt\" \\\n","filename":"make\/CompileJavaModules.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -92,0 +92,18 @@\n+$(eval $(call SetupJavaCompilation, COMPILE_PANAMA, \\\n+    TARGET_RELEASE := $(TARGET_RELEASE_BOOTJDK), \\\n+    SRC := $(TOPDIR)\/make\/jdk\/src\/classes, \\\n+    INCLUDES := build\/tools\/panama, \\\n+    BIN := $(BUILDTOOLS_OUTPUTDIR)\/panama, \\\n+    DISABLED_WARNINGS := options, \\\n+))\n+\n+PANAMA_SERVICE_PROVIDER := $(BUILDTOOLS_OUTPUTDIR)\/panama\/META-INF\/services\/com.sun.source.util.Plugin\n+\n+$(PANAMA_SERVICE_PROVIDER):\n+\t$(call MakeDir, $(BUILDTOOLS_OUTPUTDIR)\/panama\/META-INF\/services)\n+\t$(ECHO) build.tools.panama.NativeAccessMethodsFinder > $@\n+\n+TARGETS += $(COMPILE_PANAMA) $(PANAMA_SERVICE_PROVIDER)\n+\n+################################################################################\n+\n","filename":"make\/CompileToolsJdk.gmk","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+NATIVE_ACCESS_METHODS_FILE := $(LINK_OPT_DIR)\/native_access_methods.txt\n@@ -126,0 +127,6 @@\n+# Copy the native_access_methods.txt file into jdk.jlink\n+$(eval $(call SetupCopyFiles, COPY_NATIVE_ACCESS_METHODS, \\\n+    FILES := $(NATIVE_ACCESS_METHODS_FILE), \\\n+    DEST := $(JDK_OUTPUTDIR)\/modules\/jdk.jlink\/jdk\/tools\/jlink\/internal\/plugins, \\\n+))\n+\n@@ -131,1 +138,1 @@\n-TARGETS += $(COPY_JLI_TRACE)\n+TARGETS += $(COPY_JLI_TRACE) $(COPY_NATIVE_ACCESS_METHODS)\n","filename":"make\/GenerateLinkOptData.gmk","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -73,0 +73,2 @@\n+JLINK_NATIVE_ACCESS := --native-access-marker=@$(SUPPORT_OUTPUTDIR)\/link_opt\/native_access_methods.txt\n+\n@@ -79,0 +81,1 @@\n+    $(JLINK_NATIVE_ACCESS) \\\n","filename":"make\/Images.gmk","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+\t    --disable-plugin native-access-marker \\\n","filename":"make\/InterimImage.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -438,1 +438,1 @@\n-          -classpath $$(BUILDTOOLS_OUTPUTDIR)\/depend \\\n+          -classpath $$(call PathList, $$(BUILDTOOLS_OUTPUTDIR)\/depend $$(BUILDTOOLS_OUTPUTDIR)\/panama) \\\n","filename":"make\/common\/JavaCompilation.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -208,0 +208,2 @@\n+JVM_AddModuleEnableNativeAccess\n+JVM_EnableNativeAccessAllUnnamed\n","filename":"make\/data\/hotspot-symbols\/symbols-unix","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package build.tools.panama;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.util.ArrayList;\n+import java.util.List;\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.util.JavacTask;\n+import com.sun.source.util.Plugin;\n+import com.sun.source.util.TaskEvent;\n+import com.sun.source.util.TaskEvent.Kind;\n+import com.sun.source.util.TaskListener;\n+import com.sun.source.util.TreePath;\n+import com.sun.source.util.TreePathScanner;\n+import com.sun.source.util.Trees;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.tools.Diagnostic;\n+import javax.lang.model.type.ArrayType;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.ExecutableType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.util.Types;\n+import static java.nio.file.StandardOpenOption.*;\n+\n+public class NativeAccessMethodsFinder implements Plugin {\n+    private static final boolean DEBUG = Boolean.getBoolean(\"panama.javac.plugin.debug\");\n+    private static final String NATIVE_ACCESS = \"jdk.internal.vm.annotation.NativeAccess\";\n+\n+    private final List<String> declarations = new ArrayList<>();\n+\n+    @Override\n+    public void init(JavacTask task, String... args) {\n+        Trees trees = Trees.instance(task);\n+        Types types = task.getTypes();\n+        task.addTaskListener(new TaskListener() {\n+            @Override\n+            public void finished(TaskEvent e) {\n+                if (e.getKind() == Kind.ANALYZE) {\n+                    CompilationUnitTree cut = e.getCompilationUnit();\n+                    new TreePathScanner<Void, Void>() {\n+                        @Override\n+                        public Void visitMethod(MethodTree node, Void p) {\n+                            TreePath curPath = getCurrentPath();\n+                            Element el = trees.getElement(curPath);\n+                            if (el instanceof ExecutableElement) {\n+                                ExecutableElement execElem = (ExecutableElement)el;\n+                                if (isRestrictedNative(execElem)) {\n+                                    if (DEBUG) {\n+                                        trees.printMessage(Diagnostic.Kind.NOTE,\n+                                            \"Found a method marked with @RestrictedNative\", node, cut);\n+                                    }\n+                                    StringBuilder buf = new StringBuilder();\n+                                    Element parent = trees.getElement(curPath.getParentPath());\n+                                    if (parent instanceof TypeElement) {\n+                                        buf.append(getInternalName((TypeElement)parent));\n+                                        buf.append(' ');\n+                                        buf.append(node.getName());\n+                                        buf.append(' ');\n+                                        buf.append(getInternalSignature(types, execElem));\n+                                        declarations.add(buf.toString());\n+                                    }\n+                                }\n+\n+                            }\n+                            return super.visitMethod(node, p);\n+                        }\n+                    }.scan(cut, null);\n+                } else if (e.getKind() == Kind.COMPILATION) {\n+                    File declsFile = new File(args[0]);\n+                    declsFile.getParentFile().mkdirs();\n+                    try (PrintWriter out = new PrintWriter(Files.newBufferedWriter(declsFile.toPath(), CREATE, APPEND))) {\n+                        for (String decl : declarations) {\n+                            out.println(decl);\n+                        }\n+                    } catch (IOException ioExp) {\n+                        throw new UncheckedIOException(ioExp);\n+                    }\n+                }\n+            }\n+        });\n+    }\n+\n+    private String getInternalName(TypeElement typeElem) {\n+        return typeElem.getQualifiedName().toString().replace(\".\", \"\/\");\n+    }\n+\n+    private String getInternalSignature(Types types, ExecutableElement execElem) {\n+        ExecutableType et = (ExecutableType)types.erasure(execElem.asType());\n+        StringBuilder buf = new StringBuilder();\n+        buf.append('(');\n+        for (TypeMirror pt : et.getParameterTypes()) {\n+            buf.append(getInternalSignature(pt));\n+        }\n+        buf.append(')');\n+        buf.append(getInternalSignature(et.getReturnType()));\n+        return buf.toString();\n+    }\n+\n+    private String getInternalSignature(TypeMirror type) {\n+        TypeKind kind = type.getKind();\n+        switch (kind) {\n+            case ARRAY:\n+                return \"[\" + getInternalSignature(((ArrayType)type).getComponentType());\n+            case BOOLEAN:\n+                return \"Z\";\n+            case BYTE:\n+                return \"B\";\n+            case CHAR:\n+                return \"C\";\n+            case DECLARED:\n+                return \"L\" + getInternalName((TypeElement)((DeclaredType)type).asElement()) + \";\";\n+            case DOUBLE:\n+                return \"D\";\n+            case FLOAT:\n+                return \"F\";\n+            case INT:\n+                return \"I\";\n+            case LONG:\n+                return \"J\";\n+            case SHORT:\n+                return \"S\";\n+            case VOID:\n+                return \"V\";\n+            default:\n+                throw new AssertionError(\"unexpected type kind: \" + kind);\n+        }\n+    }\n+\n+    private boolean isRestrictedNative(ExecutableElement execElem) {\n+        return checkAnnotation(execElem, NATIVE_ACCESS);\n+    }\n+\n+    private boolean checkAnnotation(Element execElem, String name) {\n+        return execElem.getAnnotationMirrors().stream().anyMatch(\n+            am -> ((TypeElement) am.getAnnotationType().asElement()).getQualifiedName().contentEquals(name));\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"NativeAccessMethodsFinder\";\n+    }\n+\n+    public boolean autoStart() {\n+        return false;\n+    }\n+}\n","filename":"make\/jdk\/src\/classes\/build\/tools\/panama\/NativeAccessMethodsFinder.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -1093,0 +1093,1 @@\n+    _method_NativeAccess,\n@@ -2131,0 +2132,4 @@\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_NativeAccess_signature): {\n+      if (_location != _in_method)  break;  \/\/ only allow for methods\n+      return _method_NativeAccess;\n+    }\n@@ -2193,0 +2198,2 @@\n+  if (has_annotation(_method_NativeAccess))\n+    m->set_native_access(true);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1626,0 +1626,1 @@\n+      jb_module->set_is_native_access(true);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2920,1 +2920,1 @@\n-\/\/ java_lang_AccessibleObject\n+\/\/ java_lang_reflect_AccessibleObject\n@@ -2948,0 +2948,3 @@\n+const int java_lang_reflect_Method::NATIVE_ACCESS = 0x1;\n+\n+int java_lang_reflect_Method::_flags_offset;\n@@ -2961,0 +2964,1 @@\n+  macro(_flags_offset,          k, vmSymbols::flags_name(),          int_signature,         false); \\\n@@ -2993,0 +2997,8 @@\n+int java_lang_reflect_Method::flags(oop reflect) {\n+  return reflect->int_field(_flags_offset);\n+}\n+\n+void java_lang_reflect_Method::set_flags(oop reflect, int value) {\n+  reflect->int_field_put(_flags_offset, value);\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -577,0 +577,1 @@\n+  static int _flags_offset;\n@@ -591,0 +592,3 @@\n+  \/\/ value should be in-sync with static field of java.lang.reflect.Method\n+  static const int NATIVE_ACCESS;\n+\n@@ -597,0 +601,3 @@\n+  static int flags(oop reflect);\n+  static void set_flags(oop reflect, int value);\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,0 +31,3 @@\n+#include \"classfile\/modules.hpp\"\n+#include \"classfile\/symbolTable.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -41,0 +44,1 @@\n+#include \"runtime\/jniHandles.inline.hpp\"\n@@ -205,0 +209,4 @@\n+bool ModuleEntry::is_native_access() const {\n+  return _is_native_access || (name() == NULL && Modules::is_all_unnamed_native_access());\n+}\n+\n@@ -211,0 +219,6 @@\n+\/\/ Set whether the module is native, i.e. native operations are allowed by clients in this module\n+void ModuleEntry::set_is_native_access(bool is_native_access) {\n+  assert_lock_strong(Module_lock);\n+  _is_native_access = is_native_access;\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+  bool _is_native_access;              \/\/ whether the module is native via --enable-native-access\n@@ -83,0 +84,2 @@\n+  void enable_native_access_all_unnamed_impl(TRAPS);\n+\n@@ -96,0 +99,1 @@\n+    _is_native_access = false;\n@@ -130,0 +134,2 @@\n+  bool             is_native_access() const;\n+\n@@ -131,0 +137,1 @@\n+  void             set_is_native_access(bool is_native_access);\n@@ -183,0 +190,2 @@\n+  void check_native_module(Symbol* exception_symbol, TRAPS);\n+\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -783,0 +783,29 @@\n+\n+\/\/ Mark module as native\n+void Modules::add_module_enable_native_access(Handle module, TRAPS) {\n+  if (module == NULL) {\n+    THROW_MSG(vmSymbols::java_lang_NullPointerException(),\n+              \"module is null\");\n+  }\n+  ModuleEntry* module_entry = get_module_entry(module, CHECK);\n+  if (module_entry == NULL) {\n+    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),\n+              \"module is invalid\");\n+  }\n+\n+  module_entry->set_is_native_access(true);\n+\n+  if (log_is_enabled(Debug, module)) {\n+    ResourceMark rm(THREAD);\n+    Symbol* name = module_entry->name();\n+    log_debug(module)(\"add_module_enable_native_access(): module\"\n+                      \" %s is marked as a native module\",\n+                       name == NULL ? UNNAMED_MODULE : name->as_C_string());\n+  }\n+}\n+\n+volatile bool Modules::_native_access_all_unnamed = false;\n+\n+void Modules::enable_native_access_all_unnamed() {\n+  _native_access_all_unnamed = true;\n+}\n","filename":"src\/hotspot\/share\/classfile\/modules.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -37,0 +37,3 @@\n+private:\n+  static volatile bool _native_access_all_unnamed;\n+\n@@ -117,0 +120,7 @@\n+  \/\/ Mark the module as native\n+  static void add_module_enable_native_access(Handle module, TRAPS);\n+  static void enable_native_access_all_unnamed();\n+  static bool is_all_unnamed_native_access() {\n+      return _native_access_all_unnamed;\n+  }\n+\n","filename":"src\/hotspot\/share\/classfile\/modules.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -309,0 +309,1 @@\n+  template(jdk_internal_vm_annotation_NativeAccess_signature,    \"Ljdk\/internal\/vm\/annotation\/NativeAccess;\") \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -483,0 +483,12 @@\n+\/*\n+ * Mark the module as native, so that access to restricted native operations is allowed.\n+ *\/\n+JNIEXPORT void JNICALL\n+JVM_AddModuleEnableNativeAccess(JNIEnv *env, jobject from_module);\n+\n+\/*\n+ * Enable native access for all unnamed modules\n+ *\/\n+JNIEXPORT void JNICALL\n+JVM_EnableNativeAccessAllUnnamed(JNIEnv *env);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"classfile\/moduleEntry.hpp\"\n@@ -667,0 +668,16 @@\n+void LinkResolver::check_native_access_method(const LinkInfo& link_info,\n+                                          const methodHandle& resolved_method, TRAPS) {\n+  if (link_info.current_klass() != NULL) {\n+    if (resolved_method->is_native_access()) {\n+      ModuleEntry* module = link_info.current_klass()->module();\n+      if (!module->is_native_access()) {\n+        ResourceMark rm(THREAD);\n+        stringStream ss;\n+        ss.print(\"Illegal native access from module: %s\",\n+            module->name() == NULL ? UNNAMED_MODULE : module->name()->as_C_string());\n+        THROW_MSG(vmSymbols::java_lang_IllegalAccessException(), ss.as_string());\n+      }\n+    }\n+  }\n+}\n+\n@@ -810,0 +827,1 @@\n+  check_native_access_method(link_info, resolved_method, CHECK_NULL);\n@@ -906,0 +924,1 @@\n+  check_native_access_method(link_info, resolved_method, CHECK_NULL);\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/packageEntry.hpp\"\n@@ -225,0 +226,2 @@\n+  static void check_native_access_method(const LinkInfo& link_info,\n+                                      const methodHandle& resolved_method, TRAPS);\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -95,1 +95,2 @@\n-    _scoped                = 1 << 8\n+    _scoped                = 1 << 8,\n+    _native_access         = 1 << 9\n@@ -882,0 +883,8 @@\n+  bool is_native_access() const {\n+    return (_flags & _native_access) != 0;\n+  }\n+\n+  void set_native_access(bool x) {\n+    _flags = x ? (_flags | _native_access) : (_flags & ~_native_access);\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1102,0 +1102,9 @@\n+JVM_ENTRY(void, JVM_AddModuleEnableNativeAccess(JNIEnv *env, jobject from_module))\n+  Handle h_module (THREAD, JNIHandles::resolve(from_module));\n+  Modules::add_module_enable_native_access(h_module, CHECK);\n+JVM_END\n+\n+JVM_ENTRY(void, JVM_EnableNativeAccessAllUnnamed(JNIEnv *env))\n+  Modules::enable_native_access_all_unnamed();\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1963,0 +1963,1 @@\n+unsigned int enable_native_access_count = 0;\n@@ -2406,0 +2407,4 @@\n+    } else if (match_option(option, \"--enable-native-access=\", &tail)) {\n+      if (!create_numbered_module_property(\"jdk.module.enable.native.access\", tail, enable_native_access_count++)) {\n+        return JNI_ENOMEM;\n+      }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -799,1 +799,0 @@\n-\n@@ -828,0 +827,4 @@\n+  if (method->is_native_access()) {\n+    java_lang_reflect_Method::set_flags(mh(), java_lang_reflect_Method::NATIVE_ACCESS);\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+import jdk.internal.module.IllegalNativeAccessChecker;\n@@ -1995,0 +1996,2 @@\n+\n+        Module.enableNativeAccessAllUnnamed();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassLoader.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-import jdk.internal.misc.VM;\n@@ -61,0 +60,1 @@\n+import jdk.internal.module.IllegalNativeAccessChecker;\n@@ -114,0 +114,3 @@\n+    \/\/ is this module a native module\n+    private boolean enableNativeAccess = false;\n+\n@@ -138,0 +141,4 @@\n+        if (loader == null || loader == ClassLoaders.platformClassLoader()) {\n+            \/\/ boot\/builtin modules are always native\n+            addEnableNativeAccess();\n+        }\n@@ -249,0 +256,4 @@\n+    boolean isEnableNativeAccess() {\n+        return enableNativeAccess;\n+    }\n+\n@@ -414,0 +425,12 @@\n+    Module addEnableNativeAccess() {\n+        enableNativeAccess = true;\n+        addEnableNativeAccess0(this);\n+        return this;\n+    }\n+\n+    static void enableNativeAccessAllUnnamed() {\n+        if (IllegalNativeAccessChecker.enableNativeAccessAllUnnamedModules()) {\n+            enableNativeAccessAllUnnamed0();\n+        }\n+    }\n+\n@@ -1724,0 +1747,5 @@\n+\n+    \/\/ JVM_AddPermitsNative\n+    private static native void addEnableNativeAccess0(Module from);\n+\n+    private static native void enableNativeAccessAllUnnamed0();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Module.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-\n@@ -2314,0 +2313,10 @@\n+\n+            @Override\n+            public Module addEnableNativeAccess(Module m) {\n+                return m.addEnableNativeAccess();\n+            }\n+\n+            @Override\n+            public boolean isNative(Module m) {\n+                return m.isEnableNativeAccess();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -488,1 +489,1 @@\n-        if (checkAccess)\n+        if (checkAccess) {\n@@ -490,0 +491,1 @@\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Constructor.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Executable.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.misc.VM;\n+import jdk.internal.module.IllegalNativeAccessChecker;\n@@ -70,0 +73,3 @@\n+    private static final int NATIVE_ACCESS = 0x1;\n+    \/\/ Method internal flags needed here. For now, only NATIVE_ACCESS.\n+    private final int           flags;\n@@ -121,1 +127,2 @@\n-    Method(Class<?> declaringClass,\n+    Method(int flags,\n+           Class<?> declaringClass,\n@@ -132,0 +139,1 @@\n+        this.flags = flags;\n@@ -161,1 +169,1 @@\n-        Method res = new Method(clazz, name, parameterTypes, returnType,\n+        Method res = new Method(flags, clazz, name, parameterTypes, returnType,\n@@ -177,1 +185,1 @@\n-        Method res = new Method(clazz, name, parameterTypes, returnType,\n+        Method res = new Method(flags, clazz, name, parameterTypes, returnType,\n@@ -494,0 +502,19 @@\n+    private boolean isNativeAccess() {\n+        return (flags & NATIVE_ACCESS) != 0;\n+    }\n+\n+    private final void checkNativeAccess(Class<?> caller) throws IllegalAccessException {\n+        Module module = caller.getModule();\n+        if (VM.isBooted()) {\n+            JavaLangAccess jla = SharedSecrets.getJavaLangAccess();\n+            if (!jla.isNative(module)) {\n+                String moduleName = module.isNamed() ?\n+                        module.getName() : \"<UNNAMED>\";\n+                if (module.isNamed() ||\n+                        !IllegalNativeAccessChecker.enableNativeAccessAllUnnamedModules()) {\n+                    throw new IllegalAccessException(\"Illegal native access from module: \" + moduleName);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -564,0 +591,4 @@\n+        if (isNativeAccess()) {\n+            Class<?> caller = Reflection.getCallerClass();\n+            checkNativeAccess(caller);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":34,"deletions":3,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -376,0 +376,4 @@\n+\n+    Module addEnableNativeAccess(Module m);\n+\n+    boolean isNative(Module m);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -63,1 +63,3 @@\n-        UNNAMED_MODULE = SharedSecrets.getJavaLangAccess().defineUnnamedModule(null);\n+        JavaLangAccess jla = SharedSecrets.getJavaLangAccess();\n+        UNNAMED_MODULE = jla.defineUnnamedModule(null);\n+        jla.addEnableNativeAccess(UNNAMED_MODULE);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/BootLoader.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+    public static final String MODULE_RESTRICTED_NATIVE = \"ModuleRestrictedNative\";\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ClassFileConstants.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -81,0 +81,5 @@\n+\n+    @Override\n+    public boolean[] restrictedNativeModules() {\n+        throw new InternalError();\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ExplodedSystemModules.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ *  Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.module;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public final class IllegalNativeAccessChecker {\n+\n+    private final Collection<String> allowedModuleNames;\n+    private final boolean allowAllUnnamedModules;\n+\n+    private IllegalNativeAccessChecker(Set<String> allowedModuleNames, boolean allowAllUnnamedModules) {\n+        this.allowedModuleNames = Collections.unmodifiableSet(allowedModuleNames);\n+        this.allowAllUnnamedModules = allowAllUnnamedModules;\n+    }\n+\n+    \/\/ system-wide IllegalNativeAccessChecker\n+    private static volatile IllegalNativeAccessChecker checker;\n+\n+    static Collection<String> enableNativeAccessModules() {\n+        return checker().allowedModuleNames;\n+    }\n+\n+    public static boolean enableNativeAccessAllUnnamedModules() {\n+        return checker().allowAllUnnamedModules;\n+    }\n+\n+    private static IllegalNativeAccessChecker checker() {\n+        if (checker == null) {\n+            Set<String> allowedModuleNames = new HashSet<>();\n+            boolean allowAllUnnamedModules = false;\n+            for (String str : decode()) {\n+                if (str.equals(\"ALL-UNNAMED\")) {\n+                    allowAllUnnamedModules = true;\n+                } else {\n+                    allowedModuleNames.add(str);\n+                }\n+            }\n+            checker = new IllegalNativeAccessChecker(allowedModuleNames, allowAllUnnamedModules);\n+        }\n+        return checker;\n+    }\n+\n+    \/**\n+     * Returns the set of module names specified by --enable-native-access options.\n+     *\/\n+    private static Set<String> decode() {\n+        String prefix = \"jdk.module.enable.native.access.\";\n+        int index = 0;\n+        \/\/ the system property is removed after decoding\n+        String value = getAndRemoveProperty(prefix + index);\n+        Set<String> modules = new HashSet<>();\n+        if (value == null) {\n+            return modules;\n+        }\n+        while (value != null) {\n+            for (String s : value.split(\",\")) {\n+                if (!s.isEmpty())\n+                    modules.add(s);\n+            }\n+            index++;\n+            value = getAndRemoveProperty(prefix + index);\n+        }\n+        return modules;\n+    }\n+\n+    \/**\n+     * Gets and remove the named system property\n+     *\/\n+    private static String getAndRemoveProperty(String key) {\n+        return (String)System.getProperties().remove(key);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/IllegalNativeAccessChecker.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -271,1 +271,2 @@\n-        Modules.defineModule(null, base.descriptor(), baseUri);\n+        SharedSecrets.getJavaLangAccess()\n+                .addEnableNativeAccess(Modules.defineModule(null, base.descriptor(), baseUri));\n@@ -448,0 +449,1 @@\n+\n@@ -471,0 +473,3 @@\n+        \/\/ add enable native access\n+        addEnableNativeAccess(bootLayer);\n+\n@@ -872,0 +877,32 @@\n+    private static void addEnableNativeAccess(ModuleLayer layer) {\n+        \/\/ add native modules explicitly provided on the command line\n+\n+        JavaLangAccess jla = SharedSecrets.getJavaLangAccess();\n+        for (String name : IllegalNativeAccessChecker.enableNativeAccessModules()) {\n+            Optional<Module> module = layer.findModule(name);\n+            if (module.isPresent()) {\n+                jla.addEnableNativeAccess(module.get());\n+            } else {\n+                \/\/ silently skip.\n+                \/\/ warnUnknownModule(ENABLE_NATIVE_ACCESS, name);\n+            }\n+        }\n+\n+        Configuration cf = layer.configuration();\n+        for (Module module : layer.modules()) {\n+            if (module.isNamed() && !jla.isNative(module)) {\n+                String moduleName = module.getName();\n+                Optional<ResolvedModule> optModRef = cf.findModule(moduleName);\n+                if (optModRef.isPresent()) {\n+                    ModuleReference mref = optModRef.get().reference();\n+                    if (mref instanceof ModuleReferenceImpl) {\n+                        ModuleReferenceImpl mrefImpl = (ModuleReferenceImpl) mref;\n+                        if (mrefImpl.usesRestrictedNative()) {\n+                            fail(\"Panama access from module not specified in --enable-native-access: \" + moduleName);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n@@ -995,1 +1032,1 @@\n-\n+    private static final String ENABLE_NATIVE_ACCESS = \"--enable-native-access\";\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleBootstrap.java","additions":39,"deletions":2,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -95,0 +95,2 @@\n+        private final boolean usesRestrictedNative;\n+\n@@ -98,1 +100,2 @@\n-                   ModuleResolution moduleResolution) {\n+                   ModuleResolution moduleResolution,\n+                   boolean usesRestrictedNative) {\n@@ -103,0 +106,2 @@\n+            this.usesRestrictedNative = usesRestrictedNative;\n+\n@@ -116,0 +121,1 @@\n+        public boolean usesRestrictedNative() { return usesRestrictedNative; }\n@@ -235,0 +241,1 @@\n+        boolean moduleRestrictedNative = false;\n@@ -277,0 +284,3 @@\n+                case MODULE_RESTRICTED_NATIVE:\n+                    moduleRestrictedNative = true;\n+                    break;\n@@ -340,1 +350,2 @@\n-                              moduleResolution);\n+                              moduleResolution,\n+                              moduleRestrictedNative);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleInfo.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -182,0 +182,1 @@\n+        boolean usesRestrictiveNative = false;\n@@ -188,0 +189,1 @@\n+            usesRestrictiveNative = impl.usesRestrictedNative();\n@@ -197,2 +199,2 @@\n-                                       mres);\n-\n+                                       mres,\n+                                       usesRestrictiveNative);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModulePatcher.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -645,1 +645,1 @@\n-                    attrs = new ModuleInfo.Attributes(md, null, null, null);\n+                    attrs = new ModuleInfo.Attributes(md, null, null, null, false);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModulePath.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,0 +65,2 @@\n+    private final boolean usesRestrictedNative;\n+\n@@ -78,1 +80,2 @@\n-                               ModuleResolution moduleResolution)\n+                               ModuleResolution moduleResolution,\n+                               boolean usesRestrictedNative)\n@@ -88,0 +91,1 @@\n+        this.usesRestrictedNative = usesRestrictedNative;\n@@ -135,0 +139,5 @@\n+    public boolean usesRestrictedNative() {\n+        return usesRestrictedNative;\n+    }\n+\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleReferenceImpl.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -81,1 +81,2 @@\n-                                                       attrs.moduleResolution());\n+                                                       attrs.moduleResolution(),\n+                                                       attrs.usesRestrictedNative());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleReferences.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -150,0 +150,1 @@\n+        boolean[] restrictedNative = systemModules.restrictedNativeModules();\n@@ -155,1 +156,1 @@\n-            = (Map.Entry<String, ModuleReference>[])new Map.Entry[moduleCount];\n+                = (Map.Entry<String, ModuleReference>[]) new Map.Entry[moduleCount];\n@@ -163,4 +164,5 @@\n-                                                     targets[i],\n-                                                     recordedHashes[i],\n-                                                     hashSupplier,\n-                                                     moduleResolutions[i]);\n+                    targets[i],\n+                    recordedHashes[i],\n+                    hashSupplier,\n+                    moduleResolutions[i],\n+                    restrictedNative[i]);\n@@ -262,1 +264,2 @@\n-                                                     attrs.moduleResolution());\n+                                                     attrs.moduleResolution(),\n+                                                     attrs.usesRestrictedNative());\n@@ -308,1 +311,2 @@\n-                                             ModuleResolution mres) {\n+                                             ModuleResolution mres,\n+                                             boolean usesRestrictedNative) {\n@@ -326,1 +330,2 @@\n-                                                       mres);\n+                                                       mres,\n+                                                       usesRestrictedNative);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/SystemModuleFinders.java","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -98,0 +98,5 @@\n+\n+    \/**\n+     * Returns the restricted native flags for modules\n+     *\/\n+    boolean[] restrictedNativeModules();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/SystemModules.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.vm.annotation;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+\/**\n+ * Documents that the method is a native access method.\n+ *\/\n+@Target(ElementType.METHOD)\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface NativeAccess {\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/NativeAccess.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -214,1 +214,2 @@\n-        jdk.jpackage;\n+        jdk.jpackage,\n+        jdk.incubator.foreign;\n@@ -230,1 +231,2 @@\n-        jdk.unsupported;\n+        jdk.unsupported,\n+        jdk.incubator.foreign;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -63,0 +63,3 @@\n+\\    --enable-native-access <module name>[,<module name>...]\\n\\\n+\\                  modules that are permitted to perform restricted native operations.\\n\\\n+\\                  <module name> can also be ALL-UNNAMED.\\n\\\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/resources\/launcher.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -68,0 +68,11 @@\n+\n+JNIEXPORT void JNICALL\n+Java_java_lang_Module_addEnableNativeAccess0(JNIEnv *env, jclass cls, jobject fromModule)\n+{\n+    JVM_AddModuleEnableNativeAccess(env, fromModule);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_java_lang_Module_enableNativeAccessAllUnnamed0(JNIEnv *env, jclass cls) {\n+    JVM_EnableNativeAccessAllUnnamed(env);\n+}\n","filename":"src\/java.base\/share\/native\/libjava\/Module.c","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -602,0 +602,1 @@\n+           JLI_StrCmp(name, \"--enable-native-access\") == 0 ||\n@@ -614,0 +615,1 @@\n+           JLI_StrCCmp(name, \"--enable-native-access=\") == 0 ||\n","filename":"src\/java.base\/share\/native\/libjli\/java.c","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.internal.foreign.Utils;\n@@ -32,0 +31,1 @@\n+import jdk.internal.vm.annotation.NativeAccess;\n@@ -123,0 +123,1 @@\n+    @NativeAccess\n@@ -124,1 +125,0 @@\n-        Utils.checkRestrictedAccess(\"CLinker.getInstance\");\n@@ -319,0 +319,1 @@\n+    @NativeAccess\n@@ -320,1 +321,0 @@\n-        Utils.checkRestrictedAccess(\"CLinker.toJavaStringRestricted\");\n@@ -341,0 +341,1 @@\n+    @NativeAccess\n@@ -342,1 +343,0 @@\n-        Utils.checkRestrictedAccess(\"CLinker.toJavaStringRestricted\");\n@@ -415,0 +415,1 @@\n+    @NativeAccess\n@@ -416,1 +417,0 @@\n-        Utils.checkRestrictedAccess(\"CLinker.allocateMemoryRestricted\");\n@@ -434,0 +434,1 @@\n+    @NativeAccess\n@@ -435,1 +436,0 @@\n-        Utils.checkRestrictedAccess(\"CLinker.freeMemoryRestricted\");\n@@ -622,0 +622,1 @@\n+        @NativeAccess\n@@ -623,1 +624,0 @@\n-            Utils.checkRestrictedAccess(\"VaList.ofAddressRestricted\");\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.vm.annotation.NativeAccess;\n@@ -104,0 +105,1 @@\n+    @NativeAccess\n@@ -119,0 +121,1 @@\n+    @NativeAccess\n@@ -140,0 +143,1 @@\n+    @NativeAccess\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/LibraryLookup.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-\n@@ -35,0 +34,1 @@\n+import jdk.internal.vm.annotation.NativeAccess;\n@@ -121,0 +121,1 @@\n+    @NativeAccess\n@@ -159,0 +160,1 @@\n+    @NativeAccess\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAddress.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-import jdk.internal.foreign.Utils;\n+import jdk.internal.vm.annotation.NativeAccess;\n@@ -939,0 +939,1 @@\n+    @NativeAccess\n@@ -940,1 +941,0 @@\n-        Utils.checkRestrictedAccess(\"MemorySegment.ofNativeRestricted\");\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.vm.annotation.NativeAccess;\n@@ -96,0 +97,1 @@\n+    @NativeAccess\n@@ -97,1 +99,0 @@\n-        Utils.checkRestrictedAccess(\"MemoryAddress.asSegmentRestricted\");\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryAddressImpl.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-\n@@ -110,16 +109,0 @@\n-    public static void checkRestrictedAccess(String method) {\n-        switch (foreignRestrictedAccess) {\n-            case \"deny\" -> throwIllegalAccessError(foreignRestrictedAccess, method);\n-            case \"warn\" -> System.err.println(\"WARNING: Accessing restricted foreign method: \" + method);\n-            case \"debug\" -> {\n-                StringBuilder sb = new StringBuilder(\"DEBUG: restricted foreign method: \\\" + method\");\n-                StackWalker.getInstance().forEach(f -> sb.append(System.lineSeparator())\n-                        .append(\"\\tat \")\n-                        .append(f));\n-                System.err.println(sb.toString());\n-            }\n-            case \"permit\" -> {}\n-            default -> throwIllegalAccessError(foreignRestrictedAccess, method);\n-        }\n-    }\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,283 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.tools.jlink.internal.plugins;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.EnumSet;\n+import java.util.HashSet;\n+import java.util.stream.Collectors;\n+\n+import jdk.internal.org.objectweb.asm.Attribute;\n+import jdk.internal.org.objectweb.asm.ByteVector;\n+import jdk.internal.org.objectweb.asm.ClassReader;\n+import jdk.internal.org.objectweb.asm.ClassVisitor;\n+import jdk.internal.org.objectweb.asm.ClassWriter;\n+import jdk.internal.org.objectweb.asm.MethodVisitor;\n+import jdk.internal.org.objectweb.asm.Opcodes;\n+\n+import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+import static jdk.internal.module.ClassFileConstants.*;\n+\n+import jdk.tools.jlink.plugin.PluginException;\n+import jdk.tools.jlink.plugin.ResourcePool;\n+import jdk.tools.jlink.plugin.ResourcePoolBuilder;\n+import jdk.tools.jlink.plugin.ResourcePoolEntry;\n+\n+\/**\n+ * Jlink plugin makes modules that use NativeAccessNative methods.\n+ *\/\n+public final class NativeAccessMarkerPlugin extends AbstractPlugin {\n+    private static final boolean DEBUG = Boolean.getBoolean(\"jlink.native_access_marker.debug\");\n+    private static final String NATIVE_ACCESS_METHODS_FILE = \"native_access_methods.txt\";\n+\n+    \/\/ info on @NativeAccess methods\n+    private List<NativeAccessMethod> nativeAccessMethods;\n+    \/\/ modules that call @NativeAccess methods\n+    private Set<String> nativeAccessCallerModules = new HashSet<>();\n+\n+    public NativeAccessMarkerPlugin() {\n+        super(\"native-access-marker\");\n+    }\n+\n+    @Override\n+    public Set<State> getState() {\n+        return EnumSet.of(State.AUTO_ENABLED, State.FUNCTIONAL);\n+    }\n+\n+    @Override\n+    public boolean hasArguments() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void configure(Map<String, String> config) {\n+        String mainArgument = config.get(getName());\n+        \/\/ Load configuration from the contents in the supplied input file\n+        \/\/ - if none was supplied we look for the default file\n+        if (mainArgument == null || !mainArgument.startsWith(\"@\")) {\n+            try (InputStream traceFile =\n+                         this.getClass().getResourceAsStream(NATIVE_ACCESS_METHODS_FILE)) {\n+                nativeAccessMethods = new BufferedReader(new InputStreamReader(traceFile)).\n+                        lines().map(NativeAccessMethod::new).collect(Collectors.toList());\n+            } catch (Exception e) {\n+                throw new PluginException(\"Couldn't read \" + NATIVE_ACCESS_METHODS_FILE, e);\n+            }\n+        } else {\n+            File file = new File(mainArgument.substring(1));\n+            nativeAccessMethods = fileLines(file);\n+        }\n+\n+        if (DEBUG) {\n+            System.err.println(\"====== NativeAccess methods start ======\");\n+            for (NativeAccessMethod rm : nativeAccessMethods) {\n+                rm.print();\n+            }\n+            System.err.println(\"====== NativeAccess methods end ======\");\n+        }\n+    }\n+\n+    private List<NativeAccessMethod> fileLines(File file) {\n+        try {\n+            return Files.lines(file.toPath()).map(NativeAccessMethod::new).collect(Collectors.toList());\n+        } catch (IOException io) {\n+            throw new PluginException(\"Couldn't read file\");\n+        }\n+    }\n+\n+    @Override\n+    public ResourcePool transform(ResourcePool in, ResourcePoolBuilder out) {\n+        \/\/ pass through all resources other than \"module-info.class\"es\n+        in.entries()\n+                .filter(data -> !data.path().endsWith(\"\/module-info.class\"))\n+                .forEach(data -> checkNative(data, out));\n+\n+        if (DEBUG) {\n+            System.err.printf(\"restricted panama modules: %s\\n\", nativeAccessCallerModules);\n+        }\n+\n+        \/\/ transform (if needed), and add the module-info.class files\n+        transformModuleInfos(in, out);\n+\n+        return out.build();\n+    }\n+\n+    private void checkNative(ResourcePoolEntry data, ResourcePoolBuilder out) {\n+        out.add(data);\n+        String moduleName = data.moduleName();\n+        if (isNativeAccessPanama(moduleName)) {\n+            \/\/ already detected to be restricted panama module. No need to check\n+            \/\/ further resources.\n+            if (DEBUG) {\n+                System.err.printf(\"module %s marked, skipping %s\\n\", moduleName, data.path());\n+            }\n+            return;\n+        }\n+\n+        \/\/ check only .class resources\n+        if (data.type().equals(ResourcePoolEntry.Type.CLASS_OR_RESOURCE) &&\n+                data.path().endsWith(\".class\")) {\n+            if (hasNativeAccessCalls(data.contentBytes())) {\n+                if (DEBUG) {\n+                    System.err.printf(\"module %s NativeAccessNative due to %s\\n\", moduleName, data.path());\n+                }\n+                nativeAccessCallerModules.add(moduleName);\n+            }\n+        }\n+    }\n+\n+    private boolean isNativeAccessPanama(String moduleName) {\n+        return nativeAccessCallerModules.contains(moduleName);\n+    }\n+\n+    \/\/ find if there are restricted calls in the given .class resource\n+    private boolean hasNativeAccessCalls(byte[] bytes) {\n+        ClassReader reader = new ClassReader(bytes);\n+        boolean[] foundNativeAccess = new boolean[1];\n+\n+        ClassVisitor cv = new ClassVisitor(Opcodes.ASM8) {\n+            @Override\n+            public MethodVisitor visitMethod(int access,\n+                                             String name, String descriptor,\n+                                             String signature, String[] exceptions) {\n+                if ((access & ACC_NATIVE) == 0 && (access & ACC_ABSTRACT) == 0) {\n+                    return new MethodVisitor(Opcodes.ASM8,\n+                            super.visitMethod(access, name, descriptor,\n+                                    signature, exceptions)) {\n+                        @Override\n+                        public void visitMethodInsn(int opcode, String owner,\n+                                                    String name, String descriptor, boolean isInterface) {\n+                            super.visitMethodInsn(opcode, owner, name, descriptor, isInterface);\n+                            if (!foundNativeAccess[0]) {\n+                                foundNativeAccess[0] = isNativeAccessMethod(owner, name, descriptor);\n+                            }\n+                        }\n+                    };\n+                } else {\n+                    return null;\n+                }\n+            }\n+        };\n+\n+        reader.accept(cv, 0);\n+        return foundNativeAccess[0];\n+    }\n+\n+    \/\/ check against known restricted methods\n+    private boolean isNativeAccessMethod(String owner, String name, String descriptor) {\n+        for (NativeAccessMethod rm : nativeAccessMethods) {\n+            if (rm.match(owner, name, descriptor)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Transforms the module-info.class files in the modules, marking native or not.\n+     *\/\n+    private void transformModuleInfos(ResourcePool in, ResourcePoolBuilder out) {\n+        in.moduleView().modules().forEach(module -> {\n+            ResourcePoolEntry data = module.findEntry(\"module-info.class\").orElseThrow(\n+                    \/\/ FIXME: automatic modules not supported yet\n+                    \/\/ add something in META-INFO?\n+                    () -> new PluginException(\"module-info.class not found for \" +\n+                            module.name() + \" module\")\n+            );\n+\n+            assert module.name().equals(data.moduleName());\n+\n+            String moduleName = data.moduleName();\n+            boolean isPanama = nativeAccessCallerModules.contains(moduleName);\n+            if (isPanama) {\n+                \/\/ add a class level attribute if we found a panama method\n+                \/\/ call from the currently visited module\n+                ClassReader reader = new ClassReader(data.contentBytes());\n+                ClassWriter cw = new ClassWriter(reader, 0);\n+                ClassVisitor cv = new ClassVisitor(Opcodes.ASM8, cw) {\n+                    @Override\n+                    public void visitEnd() {\n+                        cw.visitAttribute(newAttribute(MODULE_RESTRICTED_NATIVE));\n+                        super.visitEnd();\n+                    }\n+                };\n+\n+                reader.accept(cv, 0);\n+\n+                \/\/ add resource pool entry\n+                out.add(data.copyWithContent(cw.toByteArray()));\n+            } else {\n+                \/\/ not a native module. copy module-info 'as is'\n+                out.add(data);\n+            }\n+        });\n+    }\n+\n+    \/\/ empty .class attribute of given name\n+    private Attribute newAttribute(String name) {\n+        return new Attribute(name) {\n+            @Override\n+            protected ByteVector write(\n+                    final ClassWriter classWriter,\n+                    final byte[] code,\n+                    final int codeLength,\n+                    final int maxStack,\n+                    final int maxLocals) {\n+                return new ByteVector();\n+            }\n+        };\n+    }\n+\n+    \/\/ info about a restricted method\n+    private static class NativeAccessMethod {\n+        final String className;\n+        final String methodName;\n+        final String methodDesc;\n+\n+        NativeAccessMethod(String line) {\n+            String[] parts = line.split(\" \");\n+            this.className = parts[0];\n+            this.methodName = parts[1];\n+            this.methodDesc = parts[2];\n+        }\n+\n+        void print() {\n+            System.err.printf(\"NativeAccess method: %s %s %s\\n\", className, methodName, methodDesc);\n+        }\n+\n+        boolean match(String owner, String name, String descriptor) {\n+            return className.equals(owner) && methodName.equals(name) && methodDesc.equals(descriptor);\n+        }\n+    }\n+}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/NativeAccessMarkerPlugin.java","additions":283,"deletions":0,"binary":false,"changes":283,"status":"added"},{"patch":"@@ -57,0 +57,1 @@\n+import java.util.function.Function;\n@@ -116,0 +117,5 @@\n+    @Override\n+    public Category getType() {\n+        return Category.MODULEINFO_TRANSFORMER;\n+    }\n+\n@@ -365,0 +371,4 @@\n+        boolean usesRestrictedNative() {\n+            return attrs.usesRestrictedNative();\n+        }\n+\n@@ -628,0 +638,3 @@\n+            \/\/ generate restrictedNativeModules\n+            genRestrictedNativeModules(cw);\n+\n@@ -868,0 +881,35 @@\n+        \/**\n+         * Generate restrictedNativeModules.\n+         *\/\n+        private void genRestrictedNativeModules(ClassWriter cw) {\n+            genBooleanArrayMethod(cw, \"restrictedNativeModules\", ModuleInfo::usesRestrictedNative);\n+        }\n+\n+        private void genBooleanArrayMethod(ClassWriter cw, String methodName,\n+                                           Function<ModuleInfo, Boolean> isIncluded) {\n+            MethodVisitor mresmv =\n+                    cw.visitMethod(ACC_PUBLIC,\n+                            methodName,\n+                            \"()[Z\",\n+                            \"()[Z\",\n+                            null);\n+            mresmv.visitCode();\n+            pushInt(mresmv, moduleInfos.size());\n+            mresmv.visitIntInsn(NEWARRAY, T_BOOLEAN);\n+            mresmv.visitVarInsn(ASTORE, 0);\n+\n+            for (int index=0; index < moduleInfos.size(); index++) {\n+                ModuleInfo minfo = moduleInfos.get(index);\n+                if (isIncluded.apply(minfo)) {\n+                    mresmv.visitVarInsn(ALOAD, 0);\n+                    pushInt(mresmv, index);\n+                    pushInt(mresmv, 1);\n+                    mresmv.visitInsn(BASTORE);\n+                }\n+            }\n+            mresmv.visitVarInsn(ALOAD, 0);\n+            mresmv.visitInsn(ARETURN);\n+            mresmv.visitMaxs(0, 0);\n+            mresmv.visitEnd();\n+        }\n+\n@@ -1866,1 +1914,2 @@\n-                                          mi.moduleResolution());\n+                                          mi.moduleResolution(),\n+                                          mi.usesRestrictedNative());\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/SystemModulesPlugin.java","additions":50,"deletions":1,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -160,1 +160,7 @@\n-system-modules.argument=retainModuleTarget\n+restricted-native-marker.argument=@filename\n+restricted-native-marker.description=\\\n+Specify a file listing restricted native methods to check.\n+\n+restricted-native-marker.usage=\\\n+\\  --restricted-native-marker @filename\\n\\\n+\\                            Specify a file listing restricted native methods to check.\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/resources\/plugins.properties","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+        jdk.tools.jlink.internal.plugins.NativeAccessMarkerPlugin,\n","filename":"src\/jdk.jlink\/share\/classes\/module-info.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -Dforeign.restricted=permit StdLibTest\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED StdLibTest\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -Dforeign.restricted=permit TestArrays\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestArrays\n","filename":"test\/jdk\/java\/foreign\/TestArrays.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run testng\/othervm -Dforeign.restricted=permit TestByteBuffer\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestByteBuffer\n@@ -31,1 +31,0 @@\n-\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run testng\/othervm -Dforeign.restricted=permit TestCleaner\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestCleaner\n","filename":"test\/jdk\/java\/foreign\/TestCleaner.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- *   -Dforeign.restricted=permit\n+ *   --enable-native-access=ALL-UNNAMED\n","filename":"test\/jdk\/java\/foreign\/TestDowncall.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run testng\/othervm -Dforeign.restricted=permit TestFree\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestFree\n","filename":"test\/jdk\/java\/foreign\/TestFree.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run testng\/othervm -Dforeign.restricted=permit TestIllegalLink\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestIllegalLink\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- *   -Dforeign.restricted=permit\n+ *   --enable-native-access=ALL-UNNAMED\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run testng\/othervm -Dforeign.restricted=permit TestLibraryLookup\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestLibraryLookup\n","filename":"test\/jdk\/java\/foreign\/TestLibraryLookup.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run testng\/othervm -Dforeign.restricted=permit TestNative\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestNative\n","filename":"test\/jdk\/java\/foreign\/TestNative.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm TestNativeScope\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestNativeScope\n","filename":"test\/jdk\/java\/foreign\/TestNativeScope.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @run testng TestNoForeignUnsafeOverride\n- *\/\n-\n-import jdk.incubator.foreign.MemoryAddress;\n-\n-import jdk.incubator.foreign.MemorySegment;\n-import org.testng.annotations.Test;\n-\n-public class TestNoForeignUnsafeOverride {\n-    static {\n-        System.setProperty(\"foreign.restricted\", \"permit\");\n-    }\n-\n-    @Test(expectedExceptions = IllegalAccessError.class)\n-    public void testUnsafeAccess() {\n-        MemorySegment.ofNativeRestricted();\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestNoForeignUnsafeOverride.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -29,1 +29,3 @@\n- * @run testng\/othervm -Dforeign.restricted=permit TestNulls\n+ * @run testng\/othervm\n+ *     --enable-native-access=ALL-UNNAMED\n+ *     TestNulls\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.MemorySegment;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Method;\n+\n+\/*\n+ * @test\n+ * @run testng TestRestricted\n+ *\/\n+public class TestRestricted {\n+\n+    @Test(expectedExceptions = IllegalAccessException.class)\n+    public void testReflection() throws Throwable {\n+        Method method = MemorySegment.class.getDeclaredMethod(\"ofNativeRestricted\");\n+        method.invoke(null);\n+    }\n+\n+    @Test(expectedExceptions = IllegalAccessException.class)\n+    public void testLookup() throws Throwable {\n+        MethodHandles.lookup().findStatic(MemorySegment.class, \"ofNativeRestricted\", MethodType.methodType(MemorySegment.class));\n+    }\n+\n+    @Test(expectedExceptions = IllegalAccessException.class)\n+    public void testDirectAccess() throws Throwable {\n+        MemorySegment.ofNativeRestricted();\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestRestricted.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -Dforeign.restricted=permit TestSharedAccess\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestSharedAccess\n","filename":"test\/jdk\/java\/foreign\/TestSharedAccess.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- *   -Dforeign.restricted=permit\n+ *   --enable-native-access=ALL-UNNAMED\n","filename":"test\/jdk\/java\/foreign\/TestUpcall.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- *   -Dforeign.restricted=permit\n+ *   --enable-native-access=ALL-UNNAMED\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- *   -Dforeign.restricted=permit\n+ *   --enable-native-access=ALL-UNNAMED\n@@ -34,1 +34,1 @@\n- *   -Dforeign.restricted=permit\n+ *   --enable-native-access=ALL-UNNAMED\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run testng\/othervm -Dforeign.restricted=permit TestUpcallStubs\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestUpcallStubs\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStubs.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run testng\/othervm -Dforeign.restricted=permit TestVarArgs\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestVarArgs\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/**\n+ * @test id=panama_enable_native_access\n+ * @build panama_module\/*\n+ * @run main\/othervm --enable-native-access=panama_module panama_module\/org.openjdk.foreigntest.PanamaMain\n+ * @summary with --enable-native-access access to specific module Panama unsafe API succeeds\n+ *\/\n+\n+\/**\n+ * @test id=panama_enable_native_access_reflection\n+ * @build panama_module\/*\n+ * @run main\/othervm --enable-native-access=panama_module panama_module\/org.openjdk.foreigntest.PanamaMainReflection\n+ * @summary with --enable-native-access access to specific module Panama unsafe API succeeds\n+ *\/\n+\n+\/**\n+ * @test id=panama_enable_native_access_lookup\n+ * @build panama_module\/*\n+ * @run main\/othervm --enable-native-access=panama_module panama_module\/org.openjdk.foreigntest.PanamaMainLookup\n+ * @summary with --enable-native-access access to specific module Panama unsafe API succeeds\n+ *\/\n+\n+\/**\n+ * @test id=panama_comma_separated_enable\n+ * @build panama_module\/*\n+ * @run main\/othervm --enable-native-access=com.acme,panama_module panama_module\/org.openjdk.foreigntest.PanamaMain\n+ * @summary with --enable-native-access access to comma separated list of modules\n+ *\/\n+\n+\/**\n+ * @test id=panama_comma_separated_enable_reflection\n+ * @build panama_module\/*\n+ * @run main\/othervm --enable-native-access=com.acme,panama_module panama_module\/org.openjdk.foreigntest.PanamaMainReflection\n+ * @summary with --enable-native-access access to comma separated list of modules\n+ *\/\n+\n+\/**\n+ * @test id=panama_comma_separated_enable_lookup\n+ * @build panama_module\/*\n+ * @run main\/othervm --enable-native-access=com.acme,panama_module panama_module\/org.openjdk.foreigntest.PanamaMainLookup\n+ * @summary with --enable-native-access access to comma separated list of modules\n+ *\/\n+\n+\/**\n+ * @test id=panama_no_enable_native_access_fail\n+ * @build panama_module\/*\n+ * @run main\/othervm\/fail panama_module\/org.openjdk.foreigntest.PanamaMain\n+ * @summary without --enable-native-access access to Panama unsafe API fails\n+ *\/\n+\n+\/**\n+ * @test id=panama_no_enable_native_access_fail_reflection\n+ * @build panama_module\/*\n+ * @run main\/othervm\/fail panama_module\/org.openjdk.foreigntest.PanamaMainReflection\n+ * @summary without --enable-native-access access to Panama unsafe API fails\n+ *\/\n+\n+\/**\n+ * @test id=panama_no_enable_native_access_fail_lookup\n+ * @build panama_module\/*\n+ * @run main\/othervm\/fail panama_module\/org.openjdk.foreigntest.PanamaMainLookup\n+ * @summary without --enable-native-access access to Panama unsafe API fails\n+ *\/\n+\n+\/**\n+ * @test id=panama_no_all_module_path_blanket_native_access\n+ * @build panama_module\/*\n+ * @run main\/othervm\/fail --enable-native-access=ALL-MODULE-PATH panama_module\/org.openjdk.foreigntest.PanamaMain\n+ * @summary --enable-native-access does not work with ALL-MODULE-PATH\n+ *\/\n+\n+\/**\n+ * @test id=panama_no_unnamed_module_native_access\n+ * @build org.openjdk.foreigntest.PanamaMainUnnamedModule\n+ * @run testng\/othervm\/fail org.openjdk.foreigntest.PanamaMainUnnamedModule\n+ * @summary --enable-native-access does not work without ALL-UNNAMED\n+ *\/\n+\n+\/**\n+ * @test id=panama_all_unnamed_module_native_access\n+ * @build org.openjdk.foreigntest.PanamaMainUnnamedModule\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED org.openjdk.foreigntest.PanamaMainUnnamedModule\n+ * @summary --enable-native-access ALL-UNNAMED works\n+ *\/\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/TestDriver.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.foreigntest;\n+\n+import jdk.incubator.foreign.*;\n+import org.testng.annotations.Test;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Method;\n+\n+public class PanamaMainUnnamedModule {\n+   @Test\n+   public void testReflection() throws Throwable {\n+       Method method = CLinker.class.getDeclaredMethod(\"getInstance\");\n+       method.invoke(null);\n+   }\n+\n+   @Test\n+   public void testSetAccessible() throws Throwable {\n+       Method method = CLinker.class.getDeclaredMethod(\"getInstance\");\n+       method.setAccessible(true);\n+       method.invoke(null);\n+   }\n+\n+   @Test\n+   public void testLookup() throws Throwable {\n+       MethodHandles.lookup().findStatic(CLinker.class, \"getInstance\", MethodType.methodType(CLinker.class));\n+   }\n+\n+   @Test\n+   public void testDirectAccess() throws Throwable {\n+       CLinker.getInstance();\n+   }\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/org\/openjdk\/foreigntest\/PanamaMainUnnamedModule.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+module panama_module {\n+    requires jdk.incubator.foreign;\n+    exports org.openjdk.foreigntest;\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/module-info.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.foreigntest;\n+\n+import jdk.incubator.foreign.*;\n+\n+public class PanamaMain {\n+   public static void main(String[] args) {\n+       System.out.println(\"Trying to get CLinker\");\n+       CLinker.getInstance();\n+       System.out.println(\"Got CLinker\");\n+   }\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMain.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.foreigntest;\n+\n+import jdk.incubator.foreign.*;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+\n+public class PanamaMainLookup {\n+   public static void main(String[] args) throws Throwable {\n+       MethodHandles.lookup().findStatic(CLinker.class, \"getInstance\", MethodType.methodType(CLinker.class));\n+   }\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainLookup.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.foreigntest;\n+\n+import jdk.incubator.foreign.*;\n+import java.lang.reflect.Method;\n+\n+public class PanamaMainReflection {\n+   public static void main(String[] args) throws Throwable {\n+       Method method = CLinker.class.getDeclaredMethod(\"getInstance\");\n+       method.invoke(null);\n+   }\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainReflection.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -36,1 +36,1 @@\n- *   -Dforeign.restricted=permit\n+ *   --enable-native-access=ALL-UNNAMED\n@@ -45,1 +45,1 @@\n- *   -Dforeign.restricted=permit\n+ *   --enable-native-access=ALL-UNNAMED\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestStackWalk.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * @run testng\/othervm -Dforeign.restricted=permit VaListTest\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED VaListTest\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- *   -Dforeign.restricted=permit\n+ *   --enable-native-access=ALL-UNNAMED\n","filename":"test\/jdk\/java\/foreign\/virtual\/TestVirtualCalls.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import java.util.ArrayList;\n+import java.util.List;\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/LargeEntriesTest.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -173,0 +173,2 @@\n+                    } else if (line.contains(\"WARNING: JNI access from module not specified in --enable-native-access:\")) {\n+                        continue;\n","filename":"test\/jdk\/tools\/jar\/modularJar\/Basic.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"-Dforeign.restricted=permit\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"--enable-native-access=ALL-UNNAMED\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/Upcalls.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"-Dforeign.restricted=permit\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"--enable-native-access=ALL-UNNAMED\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/VaList.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"-Dforeign.restricted=permit\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"--enable-native-access=ALL-UNNAMED\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/points\/PointsAccess.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"-Dforeign.restricted=permit\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"--enable-native-access=ALL-UNNAMED\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/points\/PointsAlloc.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"-Dforeign.restricted=permit\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"--enable-native-access=ALL-UNNAMED\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/points\/PointsDistance.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"-Dforeign.restricted=permit\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"--enable-native-access=ALL-UNNAMED\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/points\/PointsFree.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}