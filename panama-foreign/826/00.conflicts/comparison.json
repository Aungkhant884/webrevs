{"files":[{"patch":"@@ -28,0 +28,1 @@\n+<<<<<<< HEAD\n@@ -30,0 +31,4 @@\n+=======\n+import jdk.internal.foreign.abi.fallback.FallbackLinker;\n+import jdk.internal.vm.ForeignLinkerSupport;\n+>>>>>>> 535eac7d896767e3fc2b0559650aa6577da51194\n@@ -39,1 +44,3 @@\n-    LINUX_RISCV_64;\n+    LINUX_RISCV_64,\n+    FALLBACK,\n+    UNSUPPORTED;\n@@ -41,0 +48,1 @@\n+<<<<<<< HEAD\n@@ -75,0 +83,8 @@\n+=======\n+    private static final CABI CURRENT = computeCurrent();\n+\n+    private static CABI computeCurrent() {\n+        String abi = privilegedGetProperty(\"jdk.internal.foreign.CABI\");\n+        if (abi != null) {\n+            return CABI.valueOf(abi);\n+>>>>>>> 535eac7d896767e3fc2b0559650aa6577da51194\n@@ -76,0 +92,33 @@\n+\n+        if (ForeignLinkerSupport.isSupported()) {\n+            \/\/ figure out the ABI based on the platform\n+            String arch = privilegedGetProperty(\"os.arch\");\n+            String os = privilegedGetProperty(\"os.name\");\n+            long addressSize = ADDRESS.bitSize();\n+            \/\/ might be running in a 32-bit VM on a 64-bit platform.\n+            \/\/ addressSize will be correctly 32\n+            if ((arch.equals(\"amd64\") || arch.equals(\"x86_64\")) && addressSize == 64) {\n+                if (os.startsWith(\"Windows\")) {\n+                    return WIN_64;\n+                } else {\n+                    return SYS_V;\n+                }\n+            } else if (arch.equals(\"aarch64\")) {\n+                if (os.startsWith(\"Mac\")) {\n+                    return MAC_OS_AARCH_64;\n+                } else if (os.startsWith(\"Windows\")) {\n+                    return WIN_AARCH_64;\n+                } else {\n+                    \/\/ The Linux ABI follows the standard AAPCS ABI\n+                    return LINUX_AARCH_64;\n+                }\n+            } else if (arch.equals(\"riscv64\")) {\n+                if (os.startsWith(\"Linux\")) {\n+                    return LINUX_RISCV_64;\n+                }\n+            }\n+        } else if (FallbackLinker.isSupported()) {\n+            return FALLBACK; \/\/ fallback linker\n+        }\n+\n+        return UNSUPPORTED;\n@@ -79,0 +128,1 @@\n+<<<<<<< HEAD\n@@ -85,0 +135,3 @@\n+=======\n+        return CURRENT;\n+>>>>>>> 535eac7d896767e3fc2b0559650aa6577da51194\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/CABI.java","additions":54,"deletions":1,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+<<<<<<< HEAD\n@@ -29,0 +30,4 @@\n+=======\n+ *\n+ * @run testng\/othervm -Djdk.internal.foreign.CABI=UNSUPPORTED --enable-native-access=ALL-UNNAMED TestUnsupportedLinker\n+>>>>>>> 535eac7d896767e3fc2b0559650aa6577da51194\n@@ -32,3 +37,0 @@\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.VaList;\n-import java.lang.foreign.ValueLayout;\n@@ -44,15 +46,0 @@\n-\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testEmptyVaList() {\n-        VaList.empty();\n-    }\n-\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testNonEmptyVaList() {\n-        VaList.make(builder -> builder.addVarg(ValueLayout.JAVA_INT, 42), SegmentScope.auto());\n-    }\n-\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testUnsafeVaList() {\n-        VaList.ofAddress(0L, SegmentScope.auto());\n-    }\n","filename":"test\/jdk\/java\/foreign\/TestUnsupportedLinker.java","additions":5,"deletions":18,"binary":false,"changes":23,"status":"modified"}]}