{"files":[{"patch":"@@ -146,0 +146,1 @@\n+<<<<<<< HEAD\n@@ -147,0 +148,3 @@\n+=======\n+  VMStorage shuffle_reg = VMS_R19;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -182,0 +186,1 @@\n+<<<<<<< HEAD\n@@ -187,0 +192,7 @@\n+=======\n+    allocated_frame_size += 8; \/\/ for address spill\n+  }\n+  if (_captured_state_mask != 0) {\n+    locs.set_frame_data(StubLocations::CAPTURED_STATE_MASK, allocated_frame_size);\n+    allocated_frame_size += 8;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -227,0 +239,1 @@\n+<<<<<<< HEAD\n@@ -228,0 +241,3 @@\n+=======\n+      } else if(reg.type() == StorageType::VECTOR) {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -241,0 +257,1 @@\n+<<<<<<< HEAD\n@@ -250,0 +267,11 @@\n+=======\n+    if(should_save_return_value) {\n+      out_reg_spiller.generate_spill(_masm, spill_offset);\n+    }\n+\n+    __ ldr(c_rarg0, Address(sp, locs.data_offset(StubLocations::CAPTURED_STATE_MASK)));\n+    __ movw(c_rarg1, _captured_state_mask);\n+    __ rt_call(CAST_FROM_FN_PTR(address, DowncallLinker::capture_state), tmp1);\n+\n+    if(should_save_return_value) {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/hotspot\/cpu\/aarch64\/downcallLinker_aarch64.cpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+<<<<<<< HEAD\n@@ -34,0 +35,3 @@\n+=======\n+#include \"prims\/vmstorage.inline.hpp\"\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -51,0 +55,1 @@\n+<<<<<<< HEAD\n@@ -61,0 +66,12 @@\n+=======\n+  parse_register_array(inputStorage, (int) StorageType::INTEGER, abi._integer_argument_registers, as_Register);\n+  parse_register_array(inputStorage, (int) StorageType::VECTOR, abi._vector_argument_registers, as_FloatRegister);\n+\n+  objArrayOop outputStorage = jdk_internal_foreign_abi_ABIDescriptor::outputStorage(abi_oop);\n+  parse_register_array(outputStorage, (int) StorageType::INTEGER, abi._integer_return_registers, as_Register);\n+  parse_register_array(outputStorage, (int) StorageType::VECTOR, abi._vector_return_registers, as_FloatRegister);\n+\n+  objArrayOop volatileStorage = jdk_internal_foreign_abi_ABIDescriptor::volatileStorage(abi_oop);\n+  parse_register_array(volatileStorage, (int) StorageType::INTEGER, abi._integer_additional_volatile_registers, as_Register);\n+  parse_register_array(volatileStorage, (int) StorageType::VECTOR, abi._vector_additional_volatile_registers, as_FloatRegister);\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/hotspot\/cpu\/aarch64\/foreignGlobals_aarch64.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -255,0 +255,1 @@\n+<<<<<<< HEAD\n@@ -260,0 +261,7 @@\n+=======\n+        j_expected_result_reg = VMS_R0;\n+        break;\n+        case T_FLOAT:\n+        case T_DOUBLE:\n+          j_expected_result_reg = VMS_V0;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/hotspot\/cpu\/aarch64\/upcallLinker_aarch64.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+<<<<<<< HEAD\n@@ -37,0 +38,3 @@\n+=======\n+                                                bool needs_return_buffer) {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/hotspot\/cpu\/arm\/downcallLinker_arm.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+<<<<<<< HEAD\n@@ -37,0 +38,3 @@\n+=======\n+                                                bool needs_return_buffer) {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/hotspot\/cpu\/ppc\/downcallLinker_ppc.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+<<<<<<< HEAD\n@@ -38,0 +39,3 @@\n+=======\n+                                                bool needs_return_buffer) {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/hotspot\/cpu\/riscv\/downcallLinker_riscv.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+<<<<<<< HEAD\n@@ -37,0 +38,3 @@\n+=======\n+                                                bool needs_return_buffer) {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/hotspot\/cpu\/s390\/downcallLinker_s390.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+<<<<<<< HEAD\n@@ -35,0 +36,3 @@\n+=======\n+                                                bool needs_return_buffer) {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/hotspot\/cpu\/x86\/downcallLinker_x86_32.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -142,0 +142,1 @@\n+<<<<<<< HEAD\n@@ -143,0 +144,3 @@\n+=======\n+  VMStorage shuffle_reg = VMS_RBX;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -180,0 +184,1 @@\n+<<<<<<< HEAD\n@@ -185,0 +190,7 @@\n+=======\n+    allocated_frame_size += 8;\n+  }\n+  if (_captured_state_mask != 0) {\n+    locs.set_frame_data(StubLocations::CAPTURED_STATE_MASK, allocated_frame_size);\n+    allocated_frame_size += 8;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -242,0 +254,1 @@\n+<<<<<<< HEAD\n@@ -247,0 +260,7 @@\n+=======\n+    if(should_save_return_value) {\n+      out_reg_spiller.generate_spill(_masm, spill_rsp_offset);\n+    }\n+\n+    __ movptr(c_rarg0, Address(rsp, locs.data_offset(StubLocations::CAPTURED_STATE_MASK)));\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -255,0 +275,1 @@\n+<<<<<<< HEAD\n@@ -256,0 +277,3 @@\n+=======\n+    if(should_save_return_value) {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -307,0 +331,1 @@\n+<<<<<<< HEAD\n@@ -308,0 +333,3 @@\n+=======\n+  if(should_save_return_value) {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -319,0 +347,1 @@\n+<<<<<<< HEAD\n@@ -320,0 +349,3 @@\n+=======\n+  if(should_save_return_value) {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -332,0 +364,1 @@\n+<<<<<<< HEAD\n@@ -333,0 +366,3 @@\n+=======\n+  if(should_save_return_value) {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -343,0 +379,1 @@\n+<<<<<<< HEAD\n@@ -344,0 +381,3 @@\n+=======\n+  if(should_save_return_value) {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/hotspot\/cpu\/x86\/downcallLinker_x86_64.cpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+<<<<<<< HEAD\n@@ -60,0 +61,14 @@\n+=======\n+  parse_register_array(inputStorage, (int) StorageType::INTEGER, abi._integer_argument_registers, as_Register);\n+  parse_register_array(inputStorage, (int) StorageType::VECTOR, abi._vector_argument_registers, as_XMMRegister);\n+\n+  objArrayOop outputStorage = jdk_internal_foreign_abi_ABIDescriptor::outputStorage(abi_oop);\n+  parse_register_array(outputStorage, (int) StorageType::INTEGER, abi._integer_return_registers, as_Register);\n+  parse_register_array(outputStorage, (int) StorageType::VECTOR, abi._vector_return_registers, as_XMMRegister);\n+  objArrayOop subarray = oop_cast<objArrayOop>(outputStorage->obj_at(((int) StorageType::X87)));\n+  abi._X87_return_registers_noof = subarray->length();\n+\n+  objArrayOop volatileStorage = jdk_internal_foreign_abi_ABIDescriptor::volatileStorage(abi_oop);\n+  parse_register_array(volatileStorage, (int) StorageType::INTEGER, abi._integer_additional_volatile_registers, as_Register);\n+  parse_register_array(volatileStorage, (int) StorageType::VECTOR, abi._vector_additional_volatile_registers, as_XMMRegister);\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/hotspot\/cpu\/x86\/foreignGlobals_x86_64.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -178,0 +178,1 @@\n+<<<<<<< HEAD\n@@ -179,0 +180,3 @@\n+=======\n+  VMStorage shuffle_reg = VMS_RBX;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -309,0 +313,1 @@\n+<<<<<<< HEAD\n@@ -314,0 +319,7 @@\n+=======\n+        j_expected_result_reg = VMS_RAX;\n+        break;\n+        case T_FLOAT:\n+        case T_DOUBLE:\n+          j_expected_result_reg = VMS_XMM0;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/hotspot\/cpu\/x86\/upcallLinker_x86_64.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+<<<<<<< HEAD\n@@ -35,0 +36,3 @@\n+=======\n+                                                bool needs_return_buffer) {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/hotspot\/cpu\/zero\/downcallLinker_zero.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,0 +65,33 @@\n+StubLocations::StubLocations() {\n+  for (uint32_t i = 0; i < MAX; i++) {\n+    _locs[i] = VMStorage::invalid();\n+  }\n+}\n+\n+void StubLocations::set(uint32_t loc, VMStorage storage) {\n+  assert(loc < MAX, \"oob\");\n+  _locs[loc] = storage;\n+}\n+\n+void StubLocations::set_frame_data(uint32_t loc, int offset) {\n+  set(loc, VMStorage(StorageType::FRAME_DATA, 8, offset));\n+}\n+\n+VMStorage StubLocations::get(uint32_t loc) const {\n+  assert(loc < MAX, \"oob\");\n+  VMStorage storage = _locs[loc];\n+  assert(storage.is_valid(), \"not set\");\n+  return storage;\n+}\n+\n+VMStorage StubLocations::get(VMStorage placeholder) const {\n+  assert(placeholder.type() == StorageType::PLACEHOLDER, \"must be\");\n+  return get(placeholder.index());\n+}\n+\n+int StubLocations::data_offset(uint32_t loc) const {\n+  VMStorage storage = get(loc);\n+  assert(storage.type() == StorageType::FRAME_DATA, \"must be\");\n+  return storage.offset();\n+}\n+\n@@ -120,0 +153,1 @@\n+<<<<<<< HEAD\n@@ -124,0 +158,7 @@\n+=======\n+    BasicType arg_bt   = move.bt;\n+    VMStorage from_reg = move.from;\n+    VMStorage to_reg   = move.to;\n+\n+    os->print(\"Move a %s from \", null_safe_string(type2name(arg_bt)));\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -209,0 +250,1 @@\n+<<<<<<< HEAD\n@@ -218,0 +260,18 @@\n+=======\n+    VMStorage        _src;\n+    VMStorage        _dst;\n+    bool             _processed;\n+    MoveOperation*  _next;\n+    MoveOperation*  _prev;\n+    BasicType       _bt;\n+\n+    static int get_id(VMStorage r) {\n+      assert((r.index_or_offset() & 0xFF000000) == 0, \"index or offset too large\");\n+      \/\/ assuming mask and size doesn't matter for now\n+      return ((int) r.type()) | (r.index_or_offset() << 8);\n+    }\n+\n+   public:\n+    MoveOperation(VMStorage src, VMStorage dst, BasicType bt):\n+      _src(src), _dst(dst), _processed(false), _next(NULL), _prev(NULL), _bt(bt) {}\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -298,0 +358,1 @@\n+<<<<<<< HEAD\n@@ -299,0 +360,3 @@\n+=======\n+      if (out_reg.is_stack()) {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -323,0 +387,1 @@\n+<<<<<<< HEAD\n@@ -325,0 +390,5 @@\n+=======\n+    \/\/ Record which moves kill which values\n+    \/\/ FIXME should be a map\n+    GrowableArray<MoveOperation*> killer; \/\/ essentially a map of register id -> MoveOperation*\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/hotspot\/share\/prims\/foreignGlobals.cpp","additions":70,"deletions":0,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+<<<<<<< HEAD\n@@ -30,0 +31,3 @@\n+=======\n+#include \"prims\/vmstorage.inline.hpp\"\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -44,0 +48,1 @@\n+<<<<<<< HEAD\n@@ -49,0 +54,7 @@\n+=======\n+    CAPTURED_STATE_MASK,\n+    MAX\n+  };\n+private:\n+  VMStorage _locs[MAX];\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -76,0 +88,1 @@\n+<<<<<<< HEAD\n@@ -77,0 +90,3 @@\n+=======\n+  static void parse_register_array(objArrayOop jarray, int type_index, GrowableArray<T>& array, T (*converter)(int));\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -119,0 +135,4 @@\n+<<<<<<< HEAD\n+=======\n+  BasicType bt;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/hotspot\/share\/prims\/foreignGlobals.hpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+<<<<<<< HEAD\n@@ -37,0 +38,4 @@\n+=======\n+void ForeignGlobals::parse_register_array(objArrayOop jarray, int type_index, GrowableArray<T>& array, T (*converter)(int)) {\n+  objArrayOop subarray = oop_cast<objArrayOop>(jarray->obj_at(type_index));\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/hotspot\/share\/prims\/foreignGlobals.inline.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+<<<<<<< HEAD\n@@ -26,0 +27,3 @@\n+=======\n+#include \"prims\/vmstorage.inline.hpp\"\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/hotspot\/share\/prims\/vmstorage.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -270,0 +270,1 @@\n+<<<<<<< HEAD\n@@ -272,0 +273,2 @@\n+=======\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -280,0 +283,1 @@\n+<<<<<<< HEAD\n@@ -324,0 +328,46 @@\n+=======\n+    }\n+\n+    \/\/ Returns the Module object that holds the enableNativeAccess\n+    \/\/ flag for this module.\n+    private Module moduleForNativeAccess() {\n+        return isNamed() ? this : ALL_UNNAMED_MODULE;\n+    }\n+\n+    \/\/ This is invoked from Reflection.ensureNativeAccess\n+    void ensureNativeAccess(Class<?> owner, String methodName) {\n+        \/\/ The target module whose enableNativeAccess flag is ensured\n+        Module target = moduleForNativeAccess();\n+        \/\/ racy read of the enable native access flag\n+        boolean isNativeAccessEnabled = target.enableNativeAccess;\n+        if (!isNativeAccessEnabled) {\n+            synchronized (target) {\n+                \/\/ safe read of the enableNativeAccess of the target module\n+                isNativeAccessEnabled = target.enableNativeAccess;\n+\n+                \/\/ check again with the safely read flag\n+                if (isNativeAccessEnabled) {\n+                    \/\/ another thread beat us to it - nothing to do\n+                    return;\n+                } else if (ModuleBootstrap.hasEnableNativeAccessFlag()) {\n+                    throw new IllegalCallerException(\"Illegal native access from: \" + this);\n+                } else {\n+                    \/\/ warn and set flag, so that only one warning is reported per module\n+                    String cls = owner.getName();\n+                    String mtd = cls + \"::\" + methodName;\n+                    String mod = isNamed() ? \"module \" + getName() : \"the unnamed module\";\n+                    String modflag = isNamed() ? getName() : \"ALL-UNNAMED\";\n+                    System.err.printf(\"\"\"\n+                        WARNING: A restricted method in %s has been called\n+                        WARNING: %s has been called by %s\n+                        WARNING: Use --enable-native-access=%s to avoid a warning for this module\n+                        %n\"\"\", cls, mtd, mod, modflag);\n+\n+                    \/\/ set the flag\n+                    target.enableNativeAccess = true;\n+                }\n+            }\n+        }\n+    }\n+\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Module.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -323,0 +323,1 @@\n+<<<<<<< HEAD\n@@ -335,0 +336,12 @@\n+=======\n+         *\/\n+         @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n+         @CallerSensitive\n+         public Controller enableNativeAccess(Module target) {\n+             ensureInLayer(target);\n+             Reflection.ensureNativeAccess(Reflection.getCallerClass(), Module.class,\n+                 \"enableNativeAccess\");\n+             target.implAddEnableNativeAccess();\n+             return this;\n+         }\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ModuleLayer.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+<<<<<<< HEAD\n@@ -48,0 +49,15 @@\n+=======\n+ * An arena allocates and manages the lifecycle of native segments.\n+ * <p>\n+ * An arena is a {@linkplain AutoCloseable closeable} segment allocator that is associated with a {@link #session() memory session}.\n+ * This session is created with the arena, and is closed when the arena is {@linkplain #close() closed}.\n+ * Furthermore, all the native segments {@linkplain #allocate(long, long) allocated} by the arena are associated\n+ * with that session.\n+ * <p>\n+ * The <a href=\"MemorySession.html#thread-confinement\">confinement properties<\/a> of the session associated with an\n+ * arena are determined by the factory used to create the arena. For instance, an arena created with {@link #openConfined()}\n+ * is associated with a <em>confined<\/em> memory session. Conversely, an arena created with {@link #openShared()} is\n+ * associated with a <em>shared<\/em> memory session.\n+ * <p>\n+ * An arena is extremely useful when interacting with foreign code, as shown below:\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -53,0 +69,1 @@\n+<<<<<<< HEAD\n@@ -54,0 +71,3 @@\n+=======\n+ *     MemorySegment upcallStub = linker.upcallStub(handle, desc, arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -58,0 +78,1 @@\n+<<<<<<< HEAD\n@@ -83,0 +104,2 @@\n+=======\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -89,0 +112,1 @@\n+<<<<<<< HEAD\n@@ -107,0 +131,13 @@\n+=======\n+     * Creates a native memory segment with the given size (in bytes), alignment constraint (in bytes).\n+     * The returned segment is associated with the same memory session associated with this arena.\n+     * The {@link MemorySegment#address()} of the returned memory segment is the starting address of the\n+     * allocated off-heap memory region backing the segment. Moreover, the {@linkplain MemorySegment#address() address}\n+     * of the returned segment is aligned according the provided alignment constraint.\n+     *\n+     * @implSpec\n+     * The default implementation of this method is equivalent to the following code:\n+     * {@snippet lang=java :\n+     * MemorySegment.allocateNative(bytesSize, byteAlignment, session());\n+     * }\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -113,0 +150,1 @@\n+<<<<<<< HEAD\n@@ -143,0 +181,24 @@\n+=======\n+     * @throws IllegalStateException if the session associated with this arena is not {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread\n+     * {@linkplain MemorySession#isOwnedBy(Thread) owning} the session associated with this arena.\n+     * @see MemorySegment#allocateNative(long, long, MemorySession)\n+     *\/\n+    @Override\n+    default MemorySegment allocate(long byteSize, long byteAlignment) {\n+        return MemorySegment.allocateNative(byteSize, byteAlignment, session());\n+    }\n+\n+    \/**\n+     * {@return the session associated with this arena}\n+     *\/\n+    MemorySession session();\n+\n+    \/**\n+     * Closes this arena. This closes the {@linkplain #session() session} associated with this arena and invalidates\n+     * all the memory segments associated with it. Any off-heap region of memory backing the segments associated with\n+     * that memory session are also released.\n+     * @throws IllegalStateException if the session associated with this arena is not {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread\n+     * {@linkplain MemorySession#isOwnedBy(Thread) owning} the session associated with this arena.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -148,0 +210,1 @@\n+<<<<<<< HEAD\n@@ -165,0 +228,29 @@\n+=======\n+     * Creates a new arena, associated with a new confined session.\n+     * @return a new arena, associated with a new confined session.\n+     *\/\n+    static Arena openConfined() {\n+        return makeArena(MemorySessionImpl.createConfined(Thread.currentThread()));\n+    }\n+\n+    \/**\n+     * Creates a new arena, associated with a new shared session.\n+     * @return a new arena, associated with a new shared session.\n+     *\/\n+    static Arena openShared() {\n+        return makeArena(MemorySessionImpl.createShared());\n+    }\n+\n+    private static Arena makeArena(MemorySessionImpl sessionImpl) {\n+        return new Arena() {\n+            @Override\n+            public MemorySession session() {\n+                return sessionImpl;\n+            }\n+\n+            @Override\n+            public void close() {\n+                sessionImpl.close();\n+            }\n+        };\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Arena.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+<<<<<<< HEAD\n@@ -41,0 +42,6 @@\n+=======\n+ * A function descriptor is made up of zero or more argument layouts and zero or one return layout. A function descriptor\n+ * is used to model the signature of foreign functions when creating\n+ * {@linkplain Linker#downcallHandle(MemorySegment, FunctionDescriptor, Linker.Option...) downcall method handles} or\n+ * {@linkplain Linker#upcallStub(MethodHandle, FunctionDescriptor, MemorySession) upcall stubs}.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/FunctionDescriptor.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+<<<<<<< HEAD\n@@ -65,0 +66,5 @@\n+=======\n+    @Override\n+    GroupLayout withName(String name);\n+\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/GroupLayout.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+<<<<<<< HEAD\n@@ -78,0 +79,12 @@\n+=======\n+ * More specifically, given each layout {@code L} in the function descriptor, a corresponding carrier {@code C} is inferred,\n+ * as described below:\n+ * <ul>\n+ * <li>if {@code L} is a {@link ValueLayout} with carrier {@code E} then {@code C = E}; or<\/li>\n+ * <li>if {@code L} is a {@link GroupLayout}, then {@code C} is set to {@code MemorySegment.class}<\/li>\n+ * <\/ul>\n+ * <p>\n+ * The downcall method handle type, derived as above, might be decorated by additional leading parameters,\n+ * in the given order if both are present:\n+ * <ul>\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -92,0 +105,1 @@\n+<<<<<<< HEAD\n@@ -97,0 +111,13 @@\n+=======\n+ * The type of the provided method handle has to {@linkplain FunctionDescriptor#toMethodType() match} the Java\n+ * {@linkplain java.lang.invoke.MethodType method type} associated with the upcall stub, which is derived from the argument\n+ * and return layouts in the function descriptor. More specifically, given each layout {@code L} in the function descriptor,\n+ * a corresponding carrier {@code C} is inferred, as described below:\n+ * <ul>\n+ * <li>if {@code L} is a {@link ValueLayout} with carrier {@code E} then {@code C = E}; or<\/li>\n+ * <li>if {@code L} is a {@link GroupLayout}, then {@code C} is set to {@code MemorySegment.class}<\/li>\n+ * <\/ul>\n+ * Upcall stubs are modelled by instances of type {@link MemorySegment}; upcall stubs can be passed by reference to other\n+ * downcall method handles and, when no longer required, they can be closed, via their associated\n+ * {@linkplain MemorySession memory session}.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -108,0 +135,1 @@\n+<<<<<<< HEAD\n@@ -117,0 +145,11 @@\n+=======\n+ *     <li>The memory session of {@code A} is {@linkplain MemorySession#isAlive() alive}. Otherwise, the invocation throws\n+ *     {@link IllegalStateException};<\/li>\n+ *     <li>The invocation occurs in same thread as the one {@linkplain MemorySession#isOwnedBy(Thread) owning} the memory session of {@code R},\n+ *     if said session is confined. Otherwise, the invocation throws {@link WrongThreadException}; and<\/li>\n+ *     <li>The memory session of {@code R} is <em>kept alive<\/em> (and cannot be closed) during the invocation.<\/li>\n+ *<\/ul>\n+ * A downcall method handle created from a function descriptor whose return layout is an\n+ * {@linkplain ValueLayout.OfAddress address layout} returns a native segment associated with\n+ * the {@linkplain MemorySession#global() global session}. Under normal conditions, the size of the returned segment is {@code 0}.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -129,0 +168,1 @@\n+<<<<<<< HEAD\n@@ -130,0 +170,3 @@\n+=======\n+ * is a native segment associated with the {@linkplain MemorySession#global() global session}.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -162,0 +205,1 @@\n+<<<<<<< HEAD\n@@ -163,0 +207,3 @@\n+=======\n+     * {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, MemorySession) upcall stub}.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -246,0 +293,1 @@\n+<<<<<<< HEAD\n@@ -248,0 +296,3 @@\n+=======\n+     * the provided memory session. When such session is closed, the corresponding upcall stub will be deallocated.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -257,0 +308,1 @@\n+<<<<<<< HEAD\n@@ -258,0 +310,3 @@\n+=======\n+     * @param session the upcall stub memory session.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -262,0 +317,1 @@\n+<<<<<<< HEAD\n@@ -265,0 +321,5 @@\n+=======\n+     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread\n+     * {@linkplain MemorySession#isOwnedBy(Thread) owning} {@code session}.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -284,0 +345,1 @@\n+<<<<<<< HEAD\n@@ -289,0 +351,5 @@\n+=======\n+     * A linker option that can be used to indicate additional linking requirements to the linker,\n+     * besides what is described by a function descriptor.\n+     *\/\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -294,0 +361,1 @@\n+<<<<<<< HEAD\n@@ -295,0 +363,3 @@\n+=======\n+         * {@return A linker option used to denote the index of the first variadic argument layout in a\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -305,0 +376,1 @@\n+<<<<<<< HEAD\n@@ -306,0 +378,3 @@\n+=======\n+         *          before it can be overwritten by the runtime, or read through conventional means}\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -326,0 +401,1 @@\n+<<<<<<< HEAD\n@@ -327,0 +403,3 @@\n+=======\n+         * State is captured by a downcall method handle on invocation, by writing it\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -357,0 +357,1 @@\n+<<<<<<< HEAD\n@@ -358,0 +359,3 @@\n+=======\n+     * Creates an access var handle that can be used to access a memory segment at the layout selected by the given layout path,\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+<<<<<<< HEAD\n@@ -70,0 +71,6 @@\n+=======\n+ * Native segments can be obtained by calling one of the {@link MemorySegment#allocateNative(long, long, MemorySession)}\n+ * factory methods, which return a memory segment backed by a newly allocated off-heap region with the given size\n+ * and aligned to the given alignment constraint. Alternatively, native segments can be obtained by\n+ * {@link FileChannel#map(MapMode, long, long, MemorySession) mapping} a file into a new off-heap region\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -94,0 +101,1 @@\n+<<<<<<< HEAD\n@@ -111,0 +119,18 @@\n+=======\n+ * (as in {@link MemorySegment#allocateNative(long, MemorySession)}) or derived from a {@link MemoryLayout}\n+ * (as in {@link MemorySegment#allocateNative(MemoryLayout, MemorySession)}). The size of a memory segment is typically\n+ * a positive number but may be <a href=\"#wrapping-addresses\">zero<\/a>, but never negative.\n+ * <p>\n+ * The address and size of a memory segment jointly ensure that access operations on the segment cannot fall\n+ * <em>outside<\/em> the boundaries of the region of memory which backs the segment.\n+ * That is, a memory segment has <em>spatial bounds<\/em>.\n+ * <p>\n+ * Every memory segment is associated with a {@linkplain MemorySession memory session}. This ensures that access operations\n+ * on a memory segment cannot occur when the region of memory which backs the memory segment is no longer available\n+ * (e.g. after the memory session associated with the accessed memory segment is no longer {@link MemorySession#isAlive() alive}.\n+ * That is, a memory segment has <em>temporal bounds<\/em>.\n+ * <p>\n+ * Finally, access operations on a memory segment are subject to the thread-confinement checks enforced by the associated memory\n+ * session; that is, if the segment is associated with a shared session, it can be accessed by multiple threads; if it is\n+ * associated with a confined session, it can only be accessed by the thread which owns the memory session.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -131,0 +157,1 @@\n+<<<<<<< HEAD\n@@ -133,0 +160,4 @@\n+=======\n+ * {@linkplain MethodHandles#memorySegmentViewVarHandle(ValueLayout) memory segment view var handle},\n+ * that is, a var handle that accepts a segment and a {@code long} offset. More complex access var handles\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -175,0 +206,1 @@\n+<<<<<<< HEAD\n@@ -178,0 +210,5 @@\n+=======\n+ * {@code slice} segment will result in an exception. The {@linkplain MemorySession temporal bounds} of the original segment\n+ * are inherited by its slices; that is, when the memory session associated with {@code segment} is closed, {@code slice}\n+ * will also be become inaccessible.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -244,0 +281,1 @@\n+<<<<<<< HEAD\n@@ -246,0 +284,4 @@\n+=======\n+ * the segment should be allocated by specifying a 8-byte alignment constraint, either via {@link #allocateNative(long, long, MemorySession)}\n+ * or {@link #allocateNative(MemoryLayout, MemorySession)}. These factories ensure that the off-heap region of memory backing\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -313,0 +355,1 @@\n+<<<<<<< HEAD\n@@ -388,0 +431,77 @@\n+=======\n+ * Heap segment can only be accessed using a layout whose alignment is smaller or equal to the\n+ * maximum alignment associated with the heap segment. Attempting to access a heap segment using a layout\n+ * whose alignment is greater than the maximum alignment associated with the heap segment will fail,\n+ * as demonstrated in the following example:\n+ *\n+ * {@snippet lang=java :\n+ * MemorySegment byteSegment = MemorySegment.ofArray(new byte[10]);\n+ * byteSegment.get(ValueLayout.JAVA_INT, 0); \/\/ fails: layout alignment is 4, segment max alignment is 1\n+ * }\n+ *\n+ * In such circumstances, clients have two options. They can use a heap segment backed by a different array\n+ * type (e.g. {@code long[]}), capable of supporting greater maximum alignment:\n+ *\n+ * {@snippet lang=java :\n+ * MemorySegment longSegment = MemorySegment.ofArray(new long[10]);\n+ * longSegment.get(ValueLayout.JAVA_INT, 0); \/\/ ok: layout alignment is 4, segment max alignment is 8\n+ * }\n+ *\n+ * Alternatively, they can invoke the access operation with a layout whose alignment is smaller:\n+ *\n+ * {@snippet lang=java :\n+ * MemorySegment byteSegment = MemorySegment.ofArray(new byte[10]);\n+ * byteSegment.get(ValueLayout.JAVA_INT.withBitAlignment(8), 0); \/\/ ok: layout alignment is 1, segment max alignment is 1\n+ * }\n+ *\n+ * <h2 id=\"wrapping-addresses\">Zero-length memory segments<\/h2>\n+ *\n+ * When interacting with <a href=\"package-summary.html#ffa\">foreign functions<\/a>, it is common for those functions\n+ * to allocate a region of memory and return a pointer to that region. Modeling the region of memory with a memory segment\n+ * is challenging because the Java runtime has no insight into the size of the region. Only the address of the start of\n+ * the region, stored in the pointer, is available. For example, a C function with return type {@code char*} might return\n+ * a pointer to a region containing a single {@code char} value, or to a region containing an array of {@code char} values,\n+ * where the size of the array might be provided in a separate parameter. The size of the array is not readily apparent\n+ * to the code calling the foreign function and hoping to use its result.\n+ * <p>\n+ * The {@link Linker} represents a pointer returned from a foreign function with a <em>zero-length memory segment<\/em>.\n+ * The address of the segment is the address stored in the pointer. The size of the segment is zero. Similarly, when a\n+ * client reads an <em>address<\/em> from a memory segment, a zero-length memory segment is returned.\n+ * <p>\n+ * Since a zero-length segment features trivial spatial bounds, any attempt to access these segments will fail with\n+ * {@link IndexOutOfBoundsException}. This is a crucial safety feature: as these segments are associated with a region\n+ * of memory whose size is not known, any access operations involving these segments cannot be validated.\n+ * In effect, a zero-length memory segment <em>wraps<\/em> an address, and it cannot be used without explicit intent.\n+ * <p>\n+ * Zero-length memory segments obtained when interacting with foreign functions are associated with the\n+ * {@link MemorySession#global() global} memory session. This is because the Java runtime, in addition to having no insight\n+ * into the size of the region of memory backing a pointer returned from a foreign function, also has no insight\n+ * into the lifetime intended for said region of memory by the foreign function that allocated it. The global memory\n+ * session ensures that the obtained segment can be passed, opaquely, to other pointer-accepting foreign functions.\n+ * <p>\n+ * To access native zero-length memory segments, clients have two options, both of which are <em>unsafe<\/em>. Clients\n+ * can {@linkplain java.lang.foreign.MemorySegment#ofAddress(long, long, MemorySession) obtain}\n+ * a <em>new<\/em> native segment, with new spatial and temporal bounds, as follows:\n+ *\n+ * {@snippet lang = java:\n+ * MemorySession session = ... \/\/ initialize a memory session\n+ * MemorySegment foreign = someSegment.get(ValueLayout.ADDRESS, 0); \/\/ wrap address into segment (size = 0)\n+ * MemorySegment segment = MemorySegment.ofAddress(foreign.address(), 4, session); \/\/ create new segment (size = 4)\n+ * int x = segment.get(ValueLayout.JAVA_INT, 0); \/\/ok\n+ *}\n+ *\n+ * Alternatively, clients can obtain an {@linkplain java.lang.foreign.ValueLayout.OfAddress#asUnbounded() unbounded}\n+ * address value layout. When an access operation, or a function descriptor that is passed to a downcall method handle,\n+ * uses an unbounded address value layouts, the runtime will wrap any corresponding raw addresses with native segments\n+ * with <em>maximal<\/em> size (i.e. {@linkplain java.lang.Long#MAX_VALUE}). As such, these segments can be accessed directly, as follows:\n+ *\n+ * {@snippet lang = java:\n+ * MemorySegment foreign = someSegment.get(ValueLayout.ADDRESS.asUnbounded(), 0); \/\/ wrap address into segment (size = Long.MAX_VALUE)\n+ * int x = foreign.get(ValueLayout.JAVA_INT, 0); \/\/ok\n+ *}\n+ *\n+ * Both {@link #ofAddress(long, long, MemorySession)} and {@link ValueLayout.OfAddress#asUnbounded()} are\n+ * <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a> methods, and should be used with caution:\n+ * for instance, sizing a segment incorrectly could result in a VM crash when attempting to access the memory segment.\n+ * <p>\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -509,0 +629,1 @@\n+<<<<<<< HEAD\n@@ -510,0 +631,3 @@\n+=======\n+     * created e.g. using the {@link #allocateNative(long, MemorySession)} (and related) factory, or by\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -517,0 +641,1 @@\n+<<<<<<< HEAD\n@@ -518,0 +643,3 @@\n+=======\n+     * {@link FileChannel#map(FileChannel.MapMode, long, long, MemorySession)} factory, or by\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -754,0 +882,1 @@\n+<<<<<<< HEAD\n@@ -757,0 +886,6 @@\n+=======\n+     * after the memory session associated with this segment is no longer {@linkplain MemorySession#isAlive() alive}, will\n+     * throw an {@link IllegalStateException}. Similarly, accessing the returned buffer from a thread other than\n+     * the thread {@linkplain MemorySession#isOwnedBy(Thread) owning} this segment's memory session will throw\n+     * a {@link WrongThreadException}.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -909,0 +1044,1 @@\n+<<<<<<< HEAD\n@@ -913,0 +1049,6 @@\n+=======\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -927,0 +1069,1 @@\n+<<<<<<< HEAD\n@@ -933,0 +1076,10 @@\n+=======\n+     * The memory session {@code S} associated with the returned segment is\n+     * computed as follows:\n+     * <ul>\n+     *     <li>if the buffer has been obtained by calling {@link #asByteBuffer()} on a memory segment whose session\n+     *     is {@code S'}, then {@code S = S'}; or<\/li>\n+     *     <li>if the buffer is a heap buffer, then {@code S} is the {@linkplain MemorySession#global() global session}; or\n+     *     <li>if the buffer is a direct buffer, then {@code S} is an\n+     *     {@linkplain MemorySession#implicit() implicit session} that keeps the buffer reachable.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -950,0 +1103,1 @@\n+<<<<<<< HEAD\n@@ -951,0 +1105,3 @@\n+=======\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session, and\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -962,0 +1119,1 @@\n+<<<<<<< HEAD\n@@ -963,0 +1121,3 @@\n+=======\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session, and\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -974,0 +1135,1 @@\n+<<<<<<< HEAD\n@@ -975,0 +1137,3 @@\n+=======\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session, and\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -986,0 +1151,1 @@\n+<<<<<<< HEAD\n@@ -987,0 +1153,3 @@\n+=======\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session, and\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -998,0 +1167,1 @@\n+<<<<<<< HEAD\n@@ -999,0 +1169,3 @@\n+=======\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session, and\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -1010,0 +1183,1 @@\n+<<<<<<< HEAD\n@@ -1011,0 +1185,3 @@\n+=======\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session, and\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -1022,0 +1199,1 @@\n+<<<<<<< HEAD\n@@ -1023,0 +1201,3 @@\n+=======\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session, and\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -1036,0 +1217,1 @@\n+<<<<<<< HEAD\n@@ -1059,0 +1241,25 @@\n+=======\n+\n+    \/**\n+     * Creates a zero-length native segment from the given {@linkplain #address() address value}.\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * ofAddress(address, 0);\n+     *}\n+     * @param address the address of the returned native segment.\n+     * @return a zero-length native segment with the given address.\n+     *\/\n+    static MemorySegment ofAddress(long address) {\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address, 0);\n+    }\n+\n+    \/**\n+     * Creates a native segment with the given size and {@linkplain #address() address value}.\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * ofAddress(address, byteSize, MemorySession.global());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -1075,0 +1282,1 @@\n+<<<<<<< HEAD\n@@ -1080,0 +1288,7 @@\n+=======\n+        return MemorySegment.ofAddress(address, byteSize, MemorySession.global());\n+    }\n+\n+    \/**\n+     * Creates a native segment with the given size, address, and memory session.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -1124,0 +1339,37 @@\n+     * This is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * ofAddress(address, byteSize, session, null);\n+     *}\n+     *\n+     * @param address the returned segment's address.\n+     * @param byteSize the desired size.\n+     * @param session the native segment memory session.\n+     * @return a native segment with the given address, size and memory session.\n+     * @throws IllegalArgumentException if {@code byteSize < 0}.\n+     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread\n+     * {@linkplain MemorySession#isOwnedBy(Thread) owning} {@code session}.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    @ForceInline\n+    static MemorySegment ofAddress(long address, long byteSize, MemorySession session) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemorySegment.class, \"ofAddress\");\n+        Objects.requireNonNull(session);\n+        Utils.checkAllocationSizeAndAlign(byteSize, 1);\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address, byteSize, session, null);\n+    }\n+\n+    \/**\n+     * Creates a native segment with the given size, address, and memory session.\n+     * This method can be useful when interacting with custom memory sources (e.g. custom allocators),\n+     * where an address to some underlying region of memory is typically obtained from foreign code\n+     * (often as a plain {@code long} value).\n+     * <p>\n+     * The returned segment is not read-only (see {@link MemorySegment#isReadOnly()}), and is associated with the\n+     * provided memory session.\n+     * <p>\n+     * The provided cleanup action (if any) will be invoked <em>after<\/em> the provided session is closed.\n+     * <p>\n@@ -1136,0 +1388,1 @@\n+<<<<<<< HEAD\n@@ -1143,0 +1396,9 @@\n+=======\n+     * @param session the native segment memory session.\n+     * @param cleanupAction the custom cleanup action to be associated to the returned segment (can be null).\n+     * @return a native segment with the given address, size and memory session.\n+     * @throws IllegalArgumentException if {@code byteSize < 0}.\n+     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread\n+     * {@linkplain MemorySession#isOwnedBy(Thread) owning} {@code session}.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -1148,0 +1410,1 @@\n+<<<<<<< HEAD\n@@ -1165,0 +1428,16 @@\n+=======\n+    static MemorySegment ofAddress(long address, long byteSize, MemorySession session, Runnable cleanupAction) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemorySegment.class, \"ofAddress\");\n+        Objects.requireNonNull(session);\n+        Utils.checkAllocationSizeAndAlign(byteSize, 1);\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address, byteSize, session, cleanupAction);\n+    }\n+\n+    \/**\n+     * Creates a native segment with the given layout and memory session.\n+     * <p>\n+     * Clients are responsible for ensuring that the memory session associated with the returned segment is\n+     * closed when segments are no longer in use. Failure to do so will result in off-heap memory leaks. As an\n+     * alternative, an {@linkplain MemorySession#implicit() implicitly closed} session can be used, allowing\n+     * the returned segment to be automatically released some unspecified time after the session is no longer referenced.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -1178,0 +1457,1 @@\n+<<<<<<< HEAD\n@@ -1200,0 +1480,21 @@\n+=======\n+     * @param session the session to which the returned segment is associated.\n+     * @return a new native segment.\n+     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread\n+     * {@linkplain MemorySession#isOwnedBy(Thread) owning} {@code session}.\n+     *\/\n+    static MemorySegment allocateNative(MemoryLayout layout, MemorySession session) {\n+        Objects.requireNonNull(layout);\n+        Objects.requireNonNull(session);\n+        return allocateNative(layout.byteSize(), layout.byteAlignment(), session);\n+    }\n+\n+    \/**\n+     * Creates a native segment with the given size (in bytes) and memory session.\n+     * <p>\n+     * Clients are responsible for ensuring that the memory session associated with the returned segment is\n+     * closed when segments are no longer in use. Failure to do so will result in off-heap memory leaks. As an\n+     * alternative, an {@linkplain MemorySession#implicit() implicitly closed} session can be used, allowing\n+     * the returned segment to be automatically released some unspecified time after the session is no longer referenced.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -1213,0 +1514,1 @@\n+<<<<<<< HEAD\n@@ -1234,0 +1536,20 @@\n+=======\n+     * @param session the session to which the returned segment is associated.\n+     * @return a new native memory segment.\n+     * @throws IllegalArgumentException if {@code byteSize < 0}.\n+     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread\n+     * {@linkplain MemorySession#isOwnedBy(Thread) owning} {@code session}.\n+     *\/\n+    static MemorySegment allocateNative(long byteSize, MemorySession session) {\n+        return allocateNative(byteSize, 1, session);\n+    }\n+\n+    \/**\n+     * Creates a native segment with the given size (in bytes), alignment (in bytes) and session.\n+     * <p>\n+     * Clients are responsible for ensuring that the memory session associated with the returned segment is\n+     * closed when segments are no longer in use. Failure to do so will result in off-heap memory leaks. As an\n+     * alternative, an {@linkplain MemorySession#implicit() implicitly closed} session can be used, allowing\n+     * the returned segment to be automatically released some unspecified time after the session is no longer referenced.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -1243,0 +1565,1 @@\n+<<<<<<< HEAD\n@@ -1255,0 +1578,14 @@\n+=======\n+     * @param session the scope to which the returned segment is associated.\n+     * @return a new native memory segment.\n+     * @throws IllegalArgumentException if {@code byteSize < 0}, {@code byteAlignment <= 0}, or if {@code byteAlignment}\n+     *                                  is not a power of 2.\n+     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread\n+     * {@linkplain MemorySession#isOwnedBy(Thread) owning} {@code session}.\n+     *\/\n+    static MemorySegment allocateNative(long byteSize, long byteAlignment, MemorySession session) {\n+        Objects.requireNonNull(session);\n+        Utils.checkAllocationSizeAndAlign(byteSize, byteAlignment);\n+        return NativeMemorySegmentImpl.makeNativeSegment(byteSize, byteAlignment, session);\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -1380,0 +1717,1 @@\n+<<<<<<< HEAD\n@@ -1384,0 +1722,6 @@\n+=======\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -1400,0 +1744,1 @@\n+<<<<<<< HEAD\n@@ -1404,0 +1749,6 @@\n+=======\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -1421,0 +1772,1 @@\n+<<<<<<< HEAD\n@@ -1425,0 +1777,6 @@\n+=======\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -1441,0 +1799,1 @@\n+<<<<<<< HEAD\n@@ -1445,0 +1804,6 @@\n+=======\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -1462,0 +1827,1 @@\n+<<<<<<< HEAD\n@@ -1466,0 +1832,6 @@\n+=======\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -1482,0 +1854,1 @@\n+<<<<<<< HEAD\n@@ -1486,0 +1859,6 @@\n+=======\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -1503,0 +1882,1 @@\n+<<<<<<< HEAD\n@@ -1507,0 +1887,6 @@\n+=======\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -1523,0 +1909,1 @@\n+<<<<<<< HEAD\n@@ -1527,0 +1914,6 @@\n+=======\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -1544,0 +1937,1 @@\n+<<<<<<< HEAD\n@@ -1548,0 +1942,6 @@\n+=======\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -1564,0 +1964,1 @@\n+<<<<<<< HEAD\n@@ -1568,0 +1969,6 @@\n+=======\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -1585,0 +1992,1 @@\n+<<<<<<< HEAD\n@@ -1589,0 +1997,6 @@\n+=======\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -1605,0 +2019,1 @@\n+<<<<<<< HEAD\n@@ -1609,0 +2024,6 @@\n+=======\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -1626,0 +2047,1 @@\n+<<<<<<< HEAD\n@@ -1630,0 +2052,6 @@\n+=======\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -1646,0 +2074,1 @@\n+<<<<<<< HEAD\n@@ -1650,0 +2079,6 @@\n+=======\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -1667,0 +2102,1 @@\n+<<<<<<< HEAD\n@@ -1671,0 +2107,6 @@\n+=======\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -1687,0 +2129,1 @@\n+<<<<<<< HEAD\n@@ -1691,0 +2134,6 @@\n+=======\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -1704,0 +2153,1 @@\n+<<<<<<< HEAD\n@@ -1705,0 +2155,3 @@\n+=======\n+     * a native segment, associated with the {@linkplain MemorySession#global() global} memory session. Under normal conditions,\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -1711,0 +2164,1 @@\n+<<<<<<< HEAD\n@@ -1715,0 +2169,6 @@\n+=======\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -1731,0 +2191,1 @@\n+<<<<<<< HEAD\n@@ -1735,0 +2196,6 @@\n+=======\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -1753,0 +2220,1 @@\n+<<<<<<< HEAD\n@@ -1757,0 +2225,6 @@\n+=======\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -1777,0 +2251,1 @@\n+<<<<<<< HEAD\n@@ -1781,0 +2256,6 @@\n+=======\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -1802,0 +2283,1 @@\n+<<<<<<< HEAD\n@@ -1806,0 +2288,6 @@\n+=======\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -1826,0 +2314,1 @@\n+<<<<<<< HEAD\n@@ -1830,0 +2319,6 @@\n+=======\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -1851,0 +2346,1 @@\n+<<<<<<< HEAD\n@@ -1855,0 +2351,6 @@\n+=======\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -1875,0 +2377,1 @@\n+<<<<<<< HEAD\n@@ -1879,0 +2382,6 @@\n+=======\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -1900,0 +2409,1 @@\n+<<<<<<< HEAD\n@@ -1904,0 +2414,6 @@\n+=======\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -1924,0 +2440,1 @@\n+<<<<<<< HEAD\n@@ -1928,0 +2445,6 @@\n+=======\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -1949,0 +2472,1 @@\n+<<<<<<< HEAD\n@@ -1953,0 +2477,6 @@\n+=======\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -1973,0 +2503,1 @@\n+<<<<<<< HEAD\n@@ -1977,0 +2508,6 @@\n+=======\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -1998,0 +2535,1 @@\n+<<<<<<< HEAD\n@@ -2002,0 +2540,6 @@\n+=======\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -2022,0 +2566,1 @@\n+<<<<<<< HEAD\n@@ -2026,0 +2571,6 @@\n+=======\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -2042,0 +2593,1 @@\n+<<<<<<< HEAD\n@@ -2043,0 +2595,3 @@\n+=======\n+     * a native segment, associated with the {@linkplain MemorySession#global() global} memory session. Under normal conditions,\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -2051,0 +2606,1 @@\n+<<<<<<< HEAD\n@@ -2055,0 +2611,6 @@\n+=======\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -2075,0 +2637,1 @@\n+<<<<<<< HEAD\n@@ -2079,0 +2642,6 @@\n+=======\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -2212,0 +2781,1 @@\n+<<<<<<< HEAD\n@@ -2220,0 +2790,10 @@\n+=======\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code srcSegment} is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with {@code srcSegment}.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code dstSegment} is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with {@code dstSegment}.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":580,"deletions":0,"binary":false,"changes":580,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.foreign;\n+\n+import jdk.internal.foreign.MemorySessionImpl;\n+import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.ref.CleanerFactory;\n+\n+\/**\n+ * A memory session manages the lifecycle of memory segments.\n+ * <p>\n+ * Segments associated with a memory session can only be accessed while the session is {@linkplain #isAlive() alive},\n+ * and by the {@linkplain #isOwnedBy(Thread) thread} associated with the session (if any).\n+ * <p>\n+ * Memory sessions can be closed, either explicitly (i.e. using an {@linkplain Arena arena}) or implicitly, by the garbage\n+ * collector. When a memory session is closed, it is no longer {@linkplain #isAlive() alive}, and subsequent operations\n+ * on the segments associated with that session (e.g. {@link MemorySegment#get(ValueLayout.OfInt, long)})\n+ * will fail with {@link IllegalStateException}.\n+ *\n+ * <h2 id = \"thread-confinement\">Safety and thread-confinement<\/h2>\n+ *\n+ * Memory sessions provide strong temporal safety guarantees: a memory segment associated with a session cannot be accessed\n+ * <em>after<\/em> the session has been closed. The costs associated with maintaining this safety invariant can vary greatly,\n+ * depending on how many threads have access to the memory segment associated to a memory session. For instance,\n+ * if a memory session is created and closed by one thread, and the segments associated with it are only ever accessed by that very same\n+ * thread, it is easy to show that there cannot be situations where a memory segment is accessed <em>while<\/em> its\n+ * associated session is being closed.\n+ * <p>\n+ * Conversely, if a session is associated with segments that can be accessed by multiple threads, or if the session can be\n+ * closed by a thread other than the accessing thread, the situation is much more complex. For instance, it would\n+ * be possible for a segment to be accessed while its associated session is being closed, concurrently,\n+ * by another thread. Even in this case, memory sessions provide strong temporal safety guarantees, but doing\n+ * so can incur in a higher performance impact: when closing a memory session the Java runtime has to determine\n+ * that no segment associated with that session is being accessed.\n+ * <p>\n+ * For this reason, memory sessions can be divided into two categories: <em>thread-confined<\/em> memory sessions, and <em>shared<\/em>\n+ * memory sessions.\n+ * <p>\n+ * Confined memory sessions, support strong thread-confinement guarantees. Upon creation,\n+ * they are assigned an {@linkplain #isOwnedBy(Thread) owner thread}, typically the thread which initiated the creation operation.\n+ * After creating a confined memory session, only the owner thread will be allowed to directly manipulate the resources\n+ * associated with this memory session. Any attempt to perform resource access from a thread other than the\n+ * owner thread will fail with {@link WrongThreadException}.\n+ * <p>\n+ * Shared memory sessions, on the other hand, have no owner thread; as such, resources associated with shared memory sessions\n+ * can be accessed by multiple threads. This might be useful when multiple threads need to access the same resource concurrently\n+ * (e.g. in the case of parallel processing).\n+ *\n+ * <h2 id=\"implicit\">Implicitly closed sessions<\/h2>\n+ *\n+ * Memory sessions that can be closed explicitly, while powerful, must be used with caution. These sessions must be closed\n+ * when no longer in use (via their associated arenas), by calling the {@link Arena#close} method. A failure to do so\n+ * might result in memory leaks. To mitigate this problem, clients can use {@linkplain #implicit() sessions} that\n+ * are closed implicitly, by the garbage collector. These sessions are closed at some unspecified time <em>after<\/em>\n+ * they become <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>, as shown below:\n+ *\n+ * {@snippet lang = java:\n+ * MemorySegment segment = MemorySegment.allocateNative(100, MemorySession.implicit());\n+ * ...\n+ * segment = null; \/\/ the segment session is unreacheable here and becomes available for implicit close\n+ *}\n+ *\n+ * Sessions closed implicitly can be useful to manage long-lived segments, where timely deallocation is not critical,\n+ * or in unstructured cases where it is not easy to determine <em>when<\/em> a session should be closed.\n+ *\n+ * @implSpec\n+ * Implementations of this interface are thread-safe.\n+ *\n+ * @see Arena\n+ * @see MemorySegment\n+ * @see SymbolLookup\n+ * @see Linker\n+ * @see VaList\n+ *\n+ * @since 19\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n+public sealed interface MemorySession permits MemorySessionImpl {\n+\n+    \/**\n+     * {@return {@code true}, if this memory session is alive}\n+     *\/\n+    boolean isAlive();\n+\n+    \/**\n+     * {@return test if the provided thread is the owner thread associated with this memory session}\n+     * @param thread the thread to be compared against this session's owner thread.\n+     *\/\n+    boolean isOwnedBy(Thread thread);\n+\n+    \/**\n+     * Runs a critical action while this memory session is kept alive.\n+     * @param action the action to be run.\n+     *\/\n+    void whileAlive(Runnable action);\n+\n+    \/**\n+     * Creates a new memory session that is closed, implicitly, by the garbage collector.\n+     * The returned session can be shared across threads.\n+     *\n+     * @return a new memory session that is closed, implicitly, by the garbage collector.\n+     *\/\n+    static MemorySession implicit() {\n+        return MemorySessionImpl.createImplicit(CleanerFactory.cleaner());\n+    }\n+\n+    \/**\n+     * {@return the global memory session}\n+     *\/\n+    static MemorySession global() {\n+        return MemorySessionImpl.GLOBAL;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySession.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+<<<<<<< HEAD\n@@ -30,0 +31,2 @@\n+=======\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -37,0 +40,1 @@\n+<<<<<<< HEAD\n@@ -41,0 +45,3 @@\n+=======\n+ *\/\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/PaddingLayout.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+<<<<<<< HEAD\n@@ -50,0 +51,3 @@\n+=======\n+ *     <li>{@link #nativeAllocator(MemorySession)} obtains a simple allocator which can\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -392,0 +396,1 @@\n+<<<<<<< HEAD\n@@ -395,0 +400,4 @@\n+=======\n+     * Each native segment obtained by the returned allocator is associated with the provided session. As such, the\n+     * off-heap region which backs the returned segment is freed when the session is closed.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -405,0 +414,1 @@\n+<<<<<<< HEAD\n@@ -413,0 +423,10 @@\n+=======\n+     *     MemorySegment.allocateNative(byteSize, byteAlignment, session);\n+     * }\n+     * @param session the memory session associated with the segments returned by the native allocator.\n+     * @return a simple allocator used to allocate native segments.\n+     *\/\n+    static SegmentAllocator nativeAllocator(MemorySession session) {\n+        Objects.requireNonNull(session);\n+        return (MemorySessionImpl)session;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+<<<<<<< HEAD\n@@ -33,0 +34,3 @@\n+=======\n+ * A <em>struct<\/em> layout where member layouts are laid out one after the other (see {@link MemoryLayout#structLayout(MemoryLayout...)}).\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -37,0 +41,1 @@\n+<<<<<<< HEAD\n@@ -38,0 +43,3 @@\n+=======\n+ * @since 19\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/StructLayout.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+<<<<<<< HEAD\n@@ -58,0 +59,3 @@\n+=======\n+ *     {@link MemorySegment#ofAddress(long, long, MemorySession) resizing} the segment first).<\/li>\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -65,0 +69,1 @@\n+<<<<<<< HEAD\n@@ -70,0 +75,7 @@\n+=======\n+ * with a {@linkplain  MemorySession memory session}; when the session is closed, the library is unloaded:\n+ *\n+ * {@snippet lang = java:\n+ * try (Arena arena = Arena.openConfined()) {\n+ *     SymbolLookup libGL = SymbolLookup.libraryLookup(\"libGL.so\", arena.session()); \/\/ libGL.so loaded here\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -95,0 +107,1 @@\n+<<<<<<< HEAD\n@@ -96,0 +109,3 @@\n+=======\n+ * libraryLookup(\"libGL.so\", session).find(\"glGetString\").isPresent(); \/\/ true\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -104,0 +120,1 @@\n+<<<<<<< HEAD\n@@ -105,0 +122,3 @@\n+=======\n+ * libraryLookup(\"libGL.so\", session).find(\"glGetString\").isPresent(); \/\/ true\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -142,0 +162,1 @@\n+<<<<<<< HEAD\n@@ -143,0 +164,3 @@\n+=======\n+     * returned by this method is backed by a shared memory session that is always alive and which keeps the caller's\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -177,0 +201,1 @@\n+<<<<<<< HEAD\n@@ -179,0 +204,3 @@\n+=======\n+     * The library will be unloaded when the provided memory session is closed, if no other library lookup is still using it.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -204,0 +232,1 @@\n+<<<<<<< HEAD\n@@ -206,0 +235,4 @@\n+=======\n+     * in that library. The library will be unloaded when the provided memory session is closed,\n+     * if no other library lookup is still using it.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -249,0 +282,1 @@\n+<<<<<<< HEAD\n@@ -250,0 +284,3 @@\n+=======\n+                    Optional.of(MemorySegment.ofAddress(addr, 0, session));\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+<<<<<<< HEAD\n@@ -33,0 +34,3 @@\n+=======\n+ * A <em>union<\/em> layout where member layouts are laid out at the same starting offset (see {@link MemoryLayout#unionLayout(MemoryLayout...)}).\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -37,0 +41,1 @@\n+<<<<<<< HEAD\n@@ -38,0 +43,3 @@\n+=======\n+ * @since 19\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -42,0 +50,1 @@\n+<<<<<<< HEAD\n@@ -51,0 +60,5 @@\n+=======\n+    @Override\n+    UnionLayout withName(String name);\n+\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/UnionLayout.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+<<<<<<< HEAD\n@@ -45,0 +46,3 @@\n+=======\n+ * A variable argument list segment can be created using the {@link #make(Consumer, MemorySession)} factory, as follows:\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -50,0 +54,1 @@\n+<<<<<<< HEAD\n@@ -51,0 +56,3 @@\n+=======\n+ * Once created, clients can obtain the platform-dependent {@linkplain #segment() memory segment} associated a variable\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -59,0 +67,1 @@\n+<<<<<<< HEAD\n@@ -60,0 +69,3 @@\n+=======\n+ *        VaList vaList = VaList.ofAddress(vaListSegment.address(), arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -97,0 +109,1 @@\n+<<<<<<< HEAD\n@@ -103,0 +116,8 @@\n+=======\n+ *     <li>Variable argument lists created <em>safely<\/em>, using {@link #make(Consumer, MemorySession)} are capable of detecting out-of-bounds reads;<\/li>\n+ *     <li>Variable argument lists created <em>unsafely<\/em>, using {@link #ofAddress(long, MemorySession)} are not capable of detecting out-of-bounds reads<\/li>\n+ * <\/ul>\n+ * <p>\n+ * This class is not thread safe, and all accesses should occur within a single thread\n+ * (regardless of the session associated with the variable arity list).\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -115,0 +136,1 @@\n+<<<<<<< HEAD\n@@ -119,0 +141,6 @@\n+=======\n+     * @throws IllegalStateException if the session associated with this variable argument list is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the session associated with this variable argument list.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -129,0 +157,1 @@\n+<<<<<<< HEAD\n@@ -133,0 +162,6 @@\n+=======\n+     * @throws IllegalStateException if the session associated with this variable argument list is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the session associated with this variable argument list.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -143,0 +178,1 @@\n+<<<<<<< HEAD\n@@ -147,0 +183,6 @@\n+=======\n+     * @throws IllegalStateException if the session associated with this variable argument list is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the session associated with this variable argument list.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -155,0 +197,1 @@\n+<<<<<<< HEAD\n@@ -156,0 +199,3 @@\n+=======\n+     * is associated with the {@linkplain MemorySession#global() global} memory session. Under normal conditions, the size of the returned\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -162,0 +208,1 @@\n+<<<<<<< HEAD\n@@ -166,0 +213,6 @@\n+=======\n+     * @throws IllegalStateException if the session associated with this variable argument list is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the session associated with this variable argument list.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -185,0 +238,1 @@\n+<<<<<<< HEAD\n@@ -189,0 +243,6 @@\n+=======\n+     * @throws IllegalStateException if the session associated with this variable argument list is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the session associated with this variable argument list.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -197,0 +257,1 @@\n+<<<<<<< HEAD\n@@ -201,0 +262,6 @@\n+=======\n+     * @throws IllegalStateException if the session associated with this variable argument list is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the session associated with this variable argument list.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -215,0 +282,1 @@\n+<<<<<<< HEAD\n@@ -219,0 +287,6 @@\n+=======\n+     * @throws IllegalStateException if the session associated with this variable argument list is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the session associated with this variable argument list.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -226,0 +300,1 @@\n+<<<<<<< HEAD\n@@ -227,0 +302,4 @@\n+=======\n+     * platform-dependent. The returned segment's memory session is the session which manages the lifecycle of this\n+     * variable argument list.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -232,0 +311,1 @@\n+<<<<<<< HEAD\n@@ -237,0 +317,6 @@\n+=======\n+     * Creates a variable argument list from the give address value and memory session. The address is typically obtained\n+     * by calling {@link MemorySegment#address()} on a foreign memory segment instance. The provided session determines\n+     * the lifecycle of the returned variable argument list: when the session is closed,\n+     * the returned variable argument list will no longer be accessible.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -244,0 +330,1 @@\n+<<<<<<< HEAD\n@@ -249,0 +336,7 @@\n+=======\n+     * @param session the memory session to be associated with the returned variable argument list.\n+     * @return a new variable argument list backed by an off-heap region of memory starting at the given address value.\n+     * @throws IllegalStateException         if {@code session} is not {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException          if this method is called from a thread other than the thread\n+     *                                       {@linkplain MemorySession#isOwnedBy(Thread) owning} {@code session}.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -255,0 +349,1 @@\n+<<<<<<< HEAD\n@@ -259,0 +354,6 @@\n+=======\n+    static VaList ofAddress(long address, MemorySession session) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass(), VaList.class, \"ofAddress\");\n+        Objects.requireNonNull(session);\n+        return SharedUtils.newVaListOfAddress(address, session);\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -263,0 +364,1 @@\n+<<<<<<< HEAD\n@@ -266,0 +368,6 @@\n+=======\n+     * memory session.\n+     * <p>\n+     * If this method needs to allocate memory, such memory will be managed by the given\n+     * session, and will be released when the session is closed.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -277,0 +385,1 @@\n+<<<<<<< HEAD\n@@ -280,0 +389,5 @@\n+=======\n+     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread\n+     * {@linkplain MemorySession#isOwnedBy(Thread) owning} {@code session}.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -288,0 +402,1 @@\n+<<<<<<< HEAD\n@@ -290,0 +405,4 @@\n+=======\n+     * Returns an empty variable argument list, associated with the {@linkplain MemorySession#global() global}\n+     * memory session. The resulting variable argument list does not contain any argument, and throws {@link UnsupportedOperationException}\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/VaList.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+<<<<<<< HEAD\n@@ -73,0 +74,3 @@\n+=======\n+     * Creates a <em>strided<\/em> access var handle that can be used to access a memory segment as multi-dimensional\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -136,0 +140,1 @@\n+<<<<<<< HEAD\n@@ -139,0 +144,2 @@\n+=======\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -142,3 +149,0 @@\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n@@ -151,0 +155,2 @@\n+     * <p>\n+     * New instances of this type can be created using {@link #JAVA_BOOLEAN}.\n@@ -180,0 +186,2 @@\n+     * <p>\n+     * New instances of this type can be created using {@link #JAVA_BYTE}.\n@@ -209,0 +217,2 @@\n+     * <p>\n+     * New instances of this type can be created using {@link #JAVA_CHAR}.\n@@ -239,0 +249,2 @@\n+     * <p>\n+     * New instances of this type can be created using {@link #JAVA_SHORT}.\n@@ -269,0 +281,2 @@\n+     * <p>\n+     * New instances of this type can be created using {@link #JAVA_INT}.\n@@ -299,0 +313,2 @@\n+     * <p>\n+     * New instances of this type can be created using {@link #JAVA_FLOAT}.\n@@ -329,0 +345,2 @@\n+     * <p>\n+     * New instances of this type can be created using {@link #JAVA_LONG}.\n@@ -359,0 +377,2 @@\n+     * <p>\n+     * New instances of this type can be created using {@link #JAVA_LONG}.\n@@ -389,0 +409,5 @@\n+<<<<<<< HEAD\n+=======\n+     * <p>\n+     * New instances of this type can be created using {@link #ADDRESS}.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -397,0 +422,1 @@\n+<<<<<<< HEAD\n@@ -437,0 +463,33 @@\n+=======\n+        @Override\n+        OfAddress withName(String name);\n+\n+        @Override\n+        OfAddress withBitAlignment(long bitAlignment);\n+\n+        @Override\n+        OfAddress withOrder(ByteOrder order);\n+\n+        \/**\n+         * Returns an <em>unbounded<\/em> address layout with the same carrier, alignment constraint, name and order as this address layout,\n+         * but with the specified pointee layout. An unbounded address layouts allow raw addresses to be accessed\n+         * as {@linkplain MemorySegment memory segments} whose size is set to {@link Long#MAX_VALUE}. As such,\n+         * these segments can be used in subsequent access operations.\n+         * <p>\n+         * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+         * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+         * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+         * restricted methods, and use safe and supported functionalities, where possible.\n+         *\n+         * @return an unbounded address layout with same characteristics as this layout.\n+         * @see #isUnbounded()\n+         *\/\n+        @CallerSensitive\n+        OfAddress asUnbounded();\n+\n+        \/**\n+         * {@return {@code true}, if this address layout is an {@linkplain #asUnbounded() unbounded address layout}}.\n+         *\/\n+        boolean isUnbounded();\n+\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -444,0 +503,1 @@\n+<<<<<<< HEAD\n@@ -445,0 +505,4 @@\n+=======\n+     * ADDRESS.of(ByteOrder.nativeOrder())\n+     *             .withBitAlignment(<address size>);\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -454,0 +518,1 @@\n+<<<<<<< HEAD\n@@ -455,0 +520,3 @@\n+=======\n+     * JAVA_BYTE.of(ByteOrder.nativeOrder()).withBitAlignment(8);\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -464,0 +532,1 @@\n+<<<<<<< HEAD\n@@ -465,0 +534,3 @@\n+=======\n+     * JAVA_BOOLEAN.of(ByteOrder.nativeOrder()).withBitAlignment(8);\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -474,0 +546,1 @@\n+<<<<<<< HEAD\n@@ -475,0 +548,3 @@\n+=======\n+     * JAVA_CHAR.of(ByteOrder.nativeOrder()).withBitAlignment(16);\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -484,0 +560,1 @@\n+<<<<<<< HEAD\n@@ -485,0 +562,3 @@\n+=======\n+     * JAVA_SHORT.of(ByteOrder.nativeOrder()).withBitAlignment(16);\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -494,0 +574,1 @@\n+<<<<<<< HEAD\n@@ -495,0 +576,3 @@\n+=======\n+     * JAVA_INT.of(ByteOrder.nativeOrder()).withBitAlignment(32);\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -504,0 +588,1 @@\n+<<<<<<< HEAD\n@@ -505,0 +590,3 @@\n+=======\n+     * JAVA_LONG.of(ByteOrder.nativeOrder()).withBitAlignment(64);\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -514,1 +602,1 @@\n-     * MemoryLayout.valueLayout(float.class, ByteOrder.nativeOrder()).withBitAlignment(32);\n+     * JAVA_FLOAT.of(ByteOrder.nativeOrder()).withBitAlignment(32);\n@@ -524,0 +612,1 @@\n+<<<<<<< HEAD\n@@ -541,0 +630,29 @@\n+    \/**\n+     * An unaligned value layout constant whose size is the same as that of a Java {@code char}\n+     * and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * JAVA_CHAR.withBitAlignment(8);\n+=======\n+     * JAVA_DOUBLE.of(ByteOrder.nativeOrder()).withBitAlignment(64);\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n+     * }\n+     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n+     *          performance and portability issues.\n+     *\/\n+<<<<<<< HEAD\n+=======\n+    OfDouble JAVA_DOUBLE = ValueLayouts.OfDoubleImpl.of(ByteOrder.nativeOrder());\n+\n+    \/**\n+     * An unaligned value layout constant whose size is the same as that of a machine address ({@code size_t}),\n+     * and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * ADDRESS.withBitAlignment(8);\n+     * }\n+     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n+     *          performance and portability issues.\n+     *\/\n+    OfAddress ADDRESS_UNALIGNED = ADDRESS.withBitAlignment(8);\n+\n@@ -551,0 +669,1 @@\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":123,"deletions":4,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+<<<<<<< HEAD\n@@ -39,0 +40,3 @@\n+=======\n+ * using {@linkplain java.lang.foreign.MemoryLayout#varHandle(java.lang.foreign.MemoryLayout.PathElement...) access var handles},\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -45,0 +49,1 @@\n+<<<<<<< HEAD\n@@ -46,0 +51,3 @@\n+=======\n+ * MemorySegment segment = MemorySegment.allocateNative(10 * 4, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -53,0 +61,1 @@\n+<<<<<<< HEAD\n@@ -56,0 +65,4 @@\n+=======\n+ * The segment is associated with a memory session that is {@linkplain java.lang.foreign.MemorySession#implicit() implicitly} closed,\n+ * by the garbage collector. As such, the off-heap memory backing the native segment will be released at some unspecified\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -88,0 +101,1 @@\n+<<<<<<< HEAD\n@@ -89,0 +103,3 @@\n+=======\n+ * allocated by the arena will be associated with the same {@linkplain java.lang.foreign.MemorySession memory session}.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -104,0 +121,1 @@\n+<<<<<<< HEAD\n@@ -105,0 +123,3 @@\n+=======\n+ * operation either succeeds - and accesses a valid location of the region of memory backing the memory segment - or fails.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -170,0 +191,1 @@\n+<<<<<<< HEAD\n@@ -171,0 +193,3 @@\n+=======\n+ *                                                 Linker.upcallType(comparFunction));\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -182,0 +207,1 @@\n+<<<<<<< HEAD\n@@ -185,0 +211,5 @@\n+=======\n+ * MemorySession session = ...\n+ * MemorySegment comparFunc = Linker.nativeLinker().upcallStub(\n+ *     intCompareHandle, intCompareDescriptor, session);\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -189,0 +220,1 @@\n+<<<<<<< HEAD\n@@ -190,0 +222,3 @@\n+=======\n+ * {@linkplain java.lang.foreign.Linker#upcallStub(java.lang.invoke.MethodHandle, FunctionDescriptor, MemorySession) create}\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -200,0 +235,1 @@\n+<<<<<<< HEAD\n@@ -207,0 +243,8 @@\n+=======\n+ * the restricted method {@link java.lang.foreign.MemorySegment#ofAddress(long, long, MemorySession)}\n+ * can be used to create a fresh segment with the given spatial bounds out of a native address.\n+ * <p>\n+ * Binding foreign data and\/or functions is generally unsafe and, if done incorrectly, can result in VM crashes, or memory corruption when the bound Java API element is accessed.\n+ * For instance, in the case of {@link java.lang.foreign.MemorySegment#ofAddress(long, long, MemorySession)},\n+ * if the provided spatial bounds are incorrect, a client of the segment returned by that method might crash the VM, or corrupt\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+<<<<<<< HEAD\n@@ -68,0 +69,3 @@\n+=======\n+        for (Class<?> pType : type.parameterArray()) {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/NativeMethodHandle.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1002,0 +1002,1 @@\n+<<<<<<< HEAD\n@@ -1007,0 +1008,5 @@\n+=======\n+     * Maps a region of this channel's file into a new mapped memory segment, with the given offset,\n+     * size and memory session. The {@linkplain MemorySegment#address() address} of the returned memory segment\n+     * is the starting address of the mapped off-heap region backing the segment.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -1063,0 +1069,1 @@\n+<<<<<<< HEAD\n@@ -1064,0 +1071,3 @@\n+=======\n+     *          {@linkplain MemorySession#isOwnedBy(Thread) owning} the\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/FileChannel.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,0 +28,4 @@\n+<<<<<<< HEAD\n+=======\n+import java.lang.foreign.MemorySession;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -71,0 +75,1 @@\n+<<<<<<< HEAD\n@@ -72,0 +77,3 @@\n+=======\n+        implements MemorySegment, SegmentAllocator, Scoped, BiFunction<String, List<Number>, RuntimeException>\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -152,0 +160,9 @@\n+<<<<<<< HEAD\n+=======\n+    }\n+\n+    @Override\n+    public long mismatch(MemorySegment other) {\n+        Objects.requireNonNull(other);\n+        return MemorySegment.mismatch(this, 0, byteSize(), other, 0, other.byteSize());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -484,0 +501,1 @@\n+<<<<<<< HEAD\n@@ -485,0 +503,3 @@\n+=======\n+        final MemorySession bufferSession;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+<<<<<<< HEAD\n@@ -58,0 +59,3 @@\n+=======\n+    public final Optional<MemoryLayout> returnLayout() {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -64,0 +68,1 @@\n+<<<<<<< HEAD\n@@ -65,0 +70,3 @@\n+=======\n+    public final List<MemoryLayout> argumentLayouts() {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -75,0 +83,1 @@\n+<<<<<<< HEAD\n@@ -76,0 +85,3 @@\n+=======\n+    public final FunctionDescriptorImpl appendArgumentLayouts(MemoryLayout... addedLayouts) {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -144,0 +156,1 @@\n+<<<<<<< HEAD\n@@ -145,0 +158,3 @@\n+=======\n+    public final String toString() {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -165,0 +181,1 @@\n+<<<<<<< HEAD\n@@ -166,0 +183,3 @@\n+=======\n+    public final boolean equals(Object other) {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -175,0 +195,1 @@\n+<<<<<<< HEAD\n@@ -176,0 +197,3 @@\n+=======\n+    public final int hashCode() {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/FunctionDescriptorImpl.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+<<<<<<< HEAD\n@@ -50,0 +51,3 @@\n+=======\n+ * such as the elimination of store barriers in methods like {@link HeapMemorySegmentImpl#dup(long, long, boolean, MemorySession)}.\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -71,0 +75,1 @@\n+<<<<<<< HEAD\n@@ -72,0 +77,3 @@\n+=======\n+        super(length, readOnly, MemorySession.global());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+<<<<<<< HEAD\n@@ -55,0 +56,3 @@\n+=======\n+        implements MemorySession, SegmentAllocator\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -80,0 +84,1 @@\n+<<<<<<< HEAD\n@@ -101,0 +106,2 @@\n+=======\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -178,0 +185,1 @@\n+<<<<<<< HEAD\n@@ -185,0 +193,9 @@\n+=======\n+    public static boolean sameOwnerThread(MemorySession session1, MemorySession session2) {\n+        return MemorySessionImpl.toSessionImpl(session1).ownerThread() ==\n+                MemorySessionImpl.toSessionImpl(session2).ownerThread();\n+    }\n+\n+    @Override\n+    public final boolean isOwnedBy(Thread thread) {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -197,0 +214,8 @@\n+<<<<<<< HEAD\n+=======\n+    @ForceInline\n+    public static MemorySessionImpl toSessionImpl(MemorySession session) {\n+        return (MemorySessionImpl)session;\n+    }\n+\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+<<<<<<< HEAD\n@@ -31,0 +32,4 @@\n+=======\n+import java.lang.foreign.MemorySession;\n+import java.lang.foreign.MemorySegment;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -63,0 +68,1 @@\n+<<<<<<< HEAD\n@@ -68,0 +74,2 @@\n+=======\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -72,0 +80,1 @@\n+<<<<<<< HEAD\n@@ -73,0 +82,9 @@\n+=======\n+    public Optional<Object> array() {\n+        return Optional.empty();\n+    }\n+\n+    @ForceInline\n+    @Override\n+    NativeMemorySegmentImpl dup(long offset, long size, boolean readOnly, MemorySession session) {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -104,0 +122,1 @@\n+<<<<<<< HEAD\n@@ -106,0 +125,4 @@\n+=======\n+    public static MemorySegment makeNativeSegment(long byteSize, long byteAlignment, MemorySession session) {\n+        MemorySessionImpl sessionImpl = MemorySessionImpl.toSessionImpl(session);\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -141,0 +164,1 @@\n+<<<<<<< HEAD\n@@ -143,0 +167,4 @@\n+=======\n+    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, MemorySession session, Runnable action) {\n+        MemorySessionImpl sessionImpl = MemorySessionImpl.toSessionImpl(session);\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -152,0 +180,1 @@\n+<<<<<<< HEAD\n@@ -154,0 +183,4 @@\n+=======\n+    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, MemorySession session) {\n+        MemorySessionImpl sessionImpl = MemorySessionImpl.toSessionImpl(session);\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -160,0 +193,1 @@\n+<<<<<<< HEAD\n@@ -161,0 +195,3 @@\n+=======\n+        return new NativeMemorySegmentImpl(min, byteSize, false, MemorySession.global());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -33,0 +33,5 @@\n+<<<<<<< HEAD\n+=======\n+    public static final long DEFAULT_BLOCK_SIZE = 4 * 1024;\n+\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SlicingAllocator.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -89,0 +89,1 @@\n+<<<<<<< HEAD\n@@ -93,0 +94,6 @@\n+=======\n+                ADDRESS.byteSize() * numSymbols, MemorySession.global());\n+\n+            Function<String, Optional<MemorySegment>> fallbackLookup = name -> Optional.ofNullable(WindowsFallbackSymbols.valueOfOrNull(name))\n+                .map(symbol -> MemorySegment.ofAddress(funcs.getAtIndex(ADDRESS, symbol.ordinal()).address(), 0L, MemorySession.global()));\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -109,0 +116,1 @@\n+<<<<<<< HEAD\n@@ -110,0 +118,3 @@\n+=======\n+                        Optional.of(MemorySegment.ofAddress(addr, 0, MemorySession.global()));\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+<<<<<<< HEAD\n@@ -37,0 +38,3 @@\n+=======\n+import java.lang.foreign.MemorySession;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+<<<<<<< HEAD\n@@ -29,0 +30,2 @@\n+=======\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -200,0 +203,1 @@\n+<<<<<<< HEAD\n@@ -201,0 +205,3 @@\n+=======\n+     * the allocation operation, or {@link BoxAddress} bindings, by providing the {@link MemorySession} that\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -230,0 +237,1 @@\n+<<<<<<< HEAD\n@@ -231,0 +239,3 @@\n+=======\n+            return new Context(SegmentAllocator.slicingAllocator(MemorySegment.allocateNative(size, arena.session())), arena.session()) {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -257,0 +268,1 @@\n+<<<<<<< HEAD\n@@ -258,0 +270,3 @@\n+=======\n+            return new Context(null, arena.session()) {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -371,0 +386,1 @@\n+<<<<<<< HEAD\n@@ -393,0 +409,3 @@\n+=======\n+        return new Cast(fromType, toType);\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -701,0 +720,1 @@\n+<<<<<<< HEAD\n@@ -703,0 +723,4 @@\n+=======\n+            MemorySession session = needsSession ?\n+                    context.session() : MemorySession.global();\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -729,0 +753,1 @@\n+<<<<<<< HEAD\n@@ -763,0 +788,2 @@\n+=======\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -765,0 +792,1 @@\n+<<<<<<< HEAD\n@@ -786,0 +814,23 @@\n+=======\n+    \/**\n+     * CAST([fromType], [toType])\n+     *   Pop a [fromType] from the stack, convert it to [toType], and push the resulting\n+     *   value onto the stack.\n+     *\n+     *\/\n+    record Cast(Class<?> fromType, Class<?> toType) implements Binding {\n+\n+        @Override\n+        public Tag tag() {\n+            return Tag.CAST;\n+        }\n+\n+        @Override\n+        public void verify(Deque<Class<?>> stack) {\n+            Class<?> actualType = stack.pop();\n+            SharedUtils.checkType(actualType, fromType);\n+            stack.push(toType);\n+        }\n+\n+        @Override\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+<<<<<<< HEAD\n@@ -30,0 +31,5 @@\n+=======\n+import jdk.internal.foreign.MemorySessionImpl;\n+import jdk.internal.foreign.NativeMemorySegmentImpl;\n+import jdk.internal.foreign.Scoped;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -91,0 +97,1 @@\n+<<<<<<< HEAD\n@@ -92,0 +99,3 @@\n+=======\n+    private static final String OF_LONG_UNCHECKED_DESC = methodType(MemorySegment.class, long.class, long.class, MemorySession.class).descriptorString();\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -679,0 +689,1 @@\n+<<<<<<< HEAD\n@@ -682,0 +693,6 @@\n+=======\n+        if (fromType == int.class) {\n+            popType(int.class);\n+\n+            if (toType == boolean.class) {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -690,0 +707,1 @@\n+<<<<<<< HEAD\n@@ -700,0 +718,24 @@\n+=======\n+            } else if (toType == byte.class) {\n+                mv.visitInsn(I2B);\n+            } else if (toType == short.class) {\n+                mv.visitInsn(I2S);\n+            } else {\n+                assert toType == char.class;\n+                mv.visitInsn(I2C);\n+            }\n+\n+            pushType(toType);\n+        } else {\n+            popType(fromType);\n+\n+            assert fromType == boolean.class\n+                    || fromType == byte.class\n+                    || fromType == short.class\n+                    || fromType == char.class;\n+            \/\/ no-op in bytecode\n+\n+            assert toType == int.class;\n+            pushType(int.class);\n+        }\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+<<<<<<< HEAD\n@@ -79,0 +80,3 @@\n+=======\n+            throw new IllegalArgumentException(\"Address expected as first param: \" + methodType);\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -83,0 +87,1 @@\n+<<<<<<< HEAD\n@@ -84,0 +89,3 @@\n+=======\n+            throw new IllegalArgumentException(\"return buffer and\/or preserved value address expected: \" + methodType);\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/NativeEntryPoint.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+<<<<<<< HEAD\n@@ -43,0 +44,4 @@\n+=======\n+import java.lang.foreign.MemorySession;\n+import java.lang.foreign.PaddingLayout;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -300,0 +305,1 @@\n+<<<<<<< HEAD\n@@ -301,0 +307,3 @@\n+=======\n+    public static VaList newVaListOfAddress(long address, MemorySession session) {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -25,0 +25,30 @@\n+<<<<<<< HEAD\n+=======\n+<<<<<<< HEAD:src\/java.base\/share\/classes\/jdk\/internal\/io\/JdkConsoleProvider.java\n+package jdk.internal.io;\n+\n+import java.nio.charset.Charset;\n+\n+\/**\n+ * Service provider interface for JdkConsole implementations.\n+ * The provider used for instantiating JdkConsole instance can be\n+ * specified with the system property \"jdk.console\", whose value\n+ * designates the module name of the implementation, and which defaults\n+ * to \"jdk.internal.le\" (jline). If no providers is available,\n+ * or instantiation failed, java.base built-in Console implementation\n+ * is used.\n+ *\/\n+public interface JdkConsoleProvider {\n+    \/**\n+     * The module name of the JdkConsole default provider.\n+     *\/\n+    String DEFAULT_PROVIDER_MODULE_NAME = \"jdk.internal.le\";\n+\n+    \/**\n+     * {@return the Console instance, or {@code null} if not available}\n+     * @param isTTY indicates if the jvm is attached to a terminal\n+     * @param charset charset of the platform console\n+     *\/\n+    JdkConsole console(boolean isTTY, Charset charset);\n+=======\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -31,0 +61,1 @@\n+<<<<<<< HEAD\n@@ -32,0 +63,3 @@\n+=======\n+    CAPTURED_STATE_MASK;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -36,0 +70,4 @@\n+<<<<<<< HEAD\n+=======\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63:src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/StubLocations.java\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/StubLocations.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -172,0 +172,1 @@\n+<<<<<<< HEAD\n@@ -173,0 +174,3 @@\n+=======\n+            StubLocations.CAPTURED_STATE_MASK.storage(StorageType.PLACEHOLDER));\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64Architecture.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+<<<<<<< HEAD\n@@ -33,0 +34,3 @@\n+=======\n+import java.lang.foreign.MemorySession;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -74,0 +78,1 @@\n+<<<<<<< HEAD\n@@ -75,0 +80,3 @@\n+=======\n+    public static VaList newVaListOfAddress(long address, MemorySession session) {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+<<<<<<< HEAD\n@@ -32,0 +33,3 @@\n+=======\n+import java.lang.foreign.MemorySession;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -57,0 +61,4 @@\n+<<<<<<< HEAD\n+=======\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -123,0 +131,1 @@\n+<<<<<<< HEAD\n@@ -124,0 +133,3 @@\n+=======\n+    private static LinuxAArch64VaList readFromAddress(long address, MemorySession session) {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -132,0 +144,1 @@\n+<<<<<<< HEAD\n@@ -133,0 +146,5 @@\n+=======\n+        long ptr = UNSAFE.allocateMemory(LAYOUT.byteSize());\n+        MemorySegment ms = MemorySegment.ofAddress(ptr, LAYOUT.byteSize(),\n+                MemorySession.implicit(), () -> UNSAFE.freeMemory(ptr));\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -138,0 +156,1 @@\n+<<<<<<< HEAD\n@@ -139,0 +158,3 @@\n+=======\n+        return ms;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -320,0 +342,1 @@\n+<<<<<<< HEAD\n@@ -321,0 +344,3 @@\n+=======\n+                    MemorySegment slice = MemorySegment.ofAddress(ptr.address(), layout.byteSize(), segment.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -364,0 +390,1 @@\n+<<<<<<< HEAD\n@@ -365,0 +392,3 @@\n+=======\n+        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -391,0 +421,1 @@\n+<<<<<<< HEAD\n@@ -392,0 +423,3 @@\n+=======\n+    public static VaList ofAddress(long address, MemorySession session) {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -404,0 +438,1 @@\n+<<<<<<< HEAD\n@@ -405,0 +440,2 @@\n+=======\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -563,0 +600,1 @@\n+<<<<<<< HEAD\n@@ -565,0 +603,4 @@\n+=======\n+            assert MemorySessionImpl.sameOwnerThread(gpRegs.session(), vaListSegment.session());\n+            assert MemorySessionImpl.sameOwnerThread(fpRegs.session(), vaListSegment.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64VaList.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+<<<<<<< HEAD\n@@ -75,0 +76,3 @@\n+=======\n+    public static VaList newVaListOfAddress(long address, MemorySession session) {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+<<<<<<< HEAD\n@@ -32,0 +33,3 @@\n+=======\n+import java.lang.foreign.MemorySession;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -108,0 +112,1 @@\n+<<<<<<< HEAD\n@@ -109,0 +114,3 @@\n+=======\n+                    MemorySegment struct = MemorySegment.ofAddress(structAddr.address(), layout.byteSize(), segment.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -143,0 +151,1 @@\n+<<<<<<< HEAD\n@@ -144,0 +153,3 @@\n+=======\n+        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -159,0 +171,1 @@\n+<<<<<<< HEAD\n@@ -160,0 +173,3 @@\n+=======\n+    static MacOsAArch64VaList ofAddress(long address, MemorySession session) {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -170,0 +186,1 @@\n+<<<<<<< HEAD\n@@ -171,0 +188,3 @@\n+=======\n+        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -176,0 +196,1 @@\n+<<<<<<< HEAD\n@@ -177,0 +198,2 @@\n+=======\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64VaList.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -158,1 +158,3 @@\n-                IntStream.range(0, numX87Outputs).mapToObj(X86_64Architecture::x87Storage).toArray(VMStorage[]::new)\n+                IntStream.range(0, numX87Outputs)\n+                        .mapToObj(X86_64Architecture::x87Storage)\n+                        .toArray(VMStorage[]::new)\n@@ -169,0 +171,1 @@\n+<<<<<<< HEAD\n@@ -170,0 +173,3 @@\n+=======\n+            StubLocations.CAPTURED_STATE_MASK.storage(StorageType.PLACEHOLDER));\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/X86_64Architecture.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+<<<<<<< HEAD\n@@ -41,0 +42,3 @@\n+=======\n+import java.lang.foreign.MemorySession;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+<<<<<<< HEAD\n@@ -32,0 +33,3 @@\n+=======\n+import java.lang.foreign.MemorySession;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -53,0 +57,4 @@\n+<<<<<<< HEAD\n+=======\n+    private static final Unsafe U = Unsafe.getUnsafe();\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -133,0 +141,1 @@\n+<<<<<<< HEAD\n@@ -134,0 +143,3 @@\n+=======\n+    private static SysVVaList readFromAddress(long address, MemorySession session) {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -141,0 +153,1 @@\n+<<<<<<< HEAD\n@@ -142,0 +155,5 @@\n+=======\n+        long ptr = U.allocateMemory(LAYOUT.byteSize());\n+        MemorySegment base = MemorySegment.ofAddress(ptr, LAYOUT.byteSize(),\n+                MemorySession.implicit(), () -> U.freeMemory(ptr));\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -146,0 +164,1 @@\n+<<<<<<< HEAD\n@@ -147,0 +166,3 @@\n+=======\n+        return base;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -309,0 +331,1 @@\n+<<<<<<< HEAD\n@@ -310,0 +333,3 @@\n+=======\n+        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -329,0 +355,1 @@\n+<<<<<<< HEAD\n@@ -330,0 +357,3 @@\n+=======\n+    public static VaList ofAddress(long address, MemorySession session) {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -342,0 +372,1 @@\n+<<<<<<< HEAD\n@@ -343,0 +374,2 @@\n+=======\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -475,0 +508,1 @@\n+<<<<<<< HEAD\n@@ -476,0 +510,3 @@\n+=======\n+            assert MemorySessionImpl.sameOwnerThread(reg_save_area.session(), vaListSegment.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+<<<<<<< HEAD\n@@ -32,0 +33,3 @@\n+=======\n+import java.lang.foreign.MemorySession;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -71,0 +75,1 @@\n+<<<<<<< HEAD\n@@ -72,0 +77,3 @@\n+=======\n+    public static VaList newVaListOfAddress(long address, MemorySession session) {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+<<<<<<< HEAD\n@@ -40,0 +41,3 @@\n+=======\n+import java.lang.foreign.MemorySession;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+<<<<<<< HEAD\n@@ -32,0 +33,3 @@\n+=======\n+import java.lang.foreign.MemorySession;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -118,0 +122,1 @@\n+<<<<<<< HEAD\n@@ -119,0 +124,3 @@\n+=======\n+                    MemorySegment struct = MemorySegment.ofAddress(structAddr.address(), layout.byteSize(), segment.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -144,0 +152,1 @@\n+<<<<<<< HEAD\n@@ -145,0 +154,3 @@\n+=======\n+        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -152,0 +164,1 @@\n+<<<<<<< HEAD\n@@ -153,0 +166,3 @@\n+=======\n+    static WinVaList ofAddress(long address, MemorySession session) {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -162,0 +178,1 @@\n+<<<<<<< HEAD\n@@ -163,0 +180,3 @@\n+=======\n+        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -168,0 +188,1 @@\n+<<<<<<< HEAD\n@@ -169,0 +190,2 @@\n+=======\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+<<<<<<< HEAD\n@@ -72,0 +73,3 @@\n+=======\n+    public static VaList newVaListOfAddress(long address, MemorySession session) {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+<<<<<<< HEAD:src\/java.base\/share\/classes\/jdk\/internal\/io\/JdkConsoleProvider.java\n@@ -50,0 +51,13 @@\n+=======\n+package jdk.internal.foreign.abi;\n+\n+\/\/ must keep in sync with StubLocations in VM code\n+public enum StubLocations {\n+    TARGET_ADDRESS,\n+    RETURN_BUFFER,\n+    CAPTURED_STATE_MASK;\n+\n+    public VMStorage storage(byte type) {\n+        return new VMStorage(type, (short) 8, ordinal());\n+    }\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63:src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/StubLocations.java\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/io\/JdkConsoleProvider.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -476,0 +476,1 @@\n+<<<<<<< HEAD\n@@ -483,0 +484,2 @@\n+=======\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/ProblemList.txt","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -382,0 +382,1 @@\n+<<<<<<< HEAD\n@@ -387,0 +388,7 @@\n+=======\n+            MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n+            initStruct(segment, (GroupLayout)layout, checks, check);\n+            return segment;\n+        } else if (isPointer(layout)) {\n+            MemorySegment segment = MemorySegment.allocateNative(1L, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/CallGeneratorHelper.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+<<<<<<< HEAD\n@@ -28,0 +29,3 @@\n+=======\n+import java.lang.foreign.MemorySession;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -55,0 +59,1 @@\n+<<<<<<< HEAD\n@@ -60,0 +65,7 @@\n+=======\n+            callFunc(loadLibrary(arena0.session()));\n+            try (Arena arena1 = Arena.openConfined()) {\n+                callFunc(loadLibrary(arena1.session()));\n+                try (Arena arena2 = Arena.openConfined()) {\n+                    callFunc(loadLibrary(arena2.session()));\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -69,0 +81,1 @@\n+<<<<<<< HEAD\n@@ -70,0 +83,3 @@\n+=======\n+            addr = loadLibrary(arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -74,0 +90,1 @@\n+<<<<<<< HEAD\n@@ -78,0 +95,6 @@\n+=======\n+    private static MemorySegment loadLibrary(MemorySession session) {\n+        SymbolLookup lib = SymbolLookup.libraryLookup(LIB_PATH, session);\n+        MemorySegment addr = lib.find(\"inc\").get();\n+        assertEquals(addr.session(), session);\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -120,0 +143,1 @@\n+<<<<<<< HEAD\n@@ -121,0 +145,3 @@\n+=======\n+                    callFunc(loadLibrary(arena.session()));\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -129,0 +156,1 @@\n+<<<<<<< HEAD\n@@ -130,0 +158,3 @@\n+=======\n+        MemorySegment addr = loadLibrary(arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/LibraryLookupTest.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+<<<<<<< HEAD\n@@ -38,0 +39,3 @@\n+=======\n+public class MemoryLayoutPrincipalTotalityTest extends NativeTestHelper {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/MemoryLayoutPrincipalTotalityTest.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+<<<<<<< HEAD\n@@ -39,0 +40,3 @@\n+=======\n+public class MemoryLayoutTypeRetentionTest extends NativeTestHelper {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/MemoryLayoutTypeRetentionTest.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+<<<<<<< HEAD\n@@ -30,0 +31,3 @@\n+=======\n+import java.lang.foreign.MemorySession;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -124,0 +128,1 @@\n+<<<<<<< HEAD\n@@ -125,0 +130,3 @@\n+=======\n+            return LINKER.upcallStub(target, descriptor, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,0 +32,4 @@\n+<<<<<<< HEAD\n+=======\n+import java.lang.foreign.MemorySession;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -96,0 +100,1 @@\n+<<<<<<< HEAD\n@@ -99,0 +104,5 @@\n+=======\n+                    assertFalse(allocations[j].drop().session().isAlive());\n+                } else {\n+                    assertTrue(allocations[j].drop().session().isAlive());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -119,0 +129,1 @@\n+<<<<<<< HEAD\n@@ -122,0 +133,5 @@\n+=======\n+            list = VaList.make(b -> b.addVarg(C_INT, 42), arena.session());\n+        }\n+        assertFalse(list.segment().session().isAlive());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -134,0 +150,1 @@\n+<<<<<<< HEAD\n@@ -135,0 +152,3 @@\n+=======\n+            upcall = Linker.nativeLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -153,0 +173,1 @@\n+<<<<<<< HEAD\n@@ -154,0 +175,3 @@\n+=======\n+            VaList list = VaList.make(b -> b.addVarg(C_INT, 42), arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -178,0 +202,1 @@\n+<<<<<<< HEAD\n@@ -179,0 +204,3 @@\n+=======\n+            MemorySegment upcall = Linker.nativeLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -188,0 +216,1 @@\n+<<<<<<< HEAD\n@@ -189,0 +218,3 @@\n+=======\n+            return Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/SafeFunctionAccessTest.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -282,0 +282,1 @@\n+<<<<<<< HEAD\n@@ -283,0 +284,3 @@\n+=======\n+                MemorySegment qsortUpcallStub = abi.upcallStub(qsortCompar, qsortComparFunction, arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -311,0 +315,1 @@\n+<<<<<<< HEAD\n@@ -312,0 +317,3 @@\n+=======\n+                VaList vaList = VaList.make(b -> args.forEach(a -> a.accept(b, arena)), arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -97,0 +97,1 @@\n+<<<<<<< HEAD\n@@ -98,0 +99,3 @@\n+=======\n+        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -116,0 +120,1 @@\n+<<<<<<< HEAD\n@@ -117,0 +122,3 @@\n+=======\n+        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -137,0 +145,1 @@\n+<<<<<<< HEAD\n@@ -138,0 +147,3 @@\n+=======\n+        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -195,0 +207,1 @@\n+<<<<<<< HEAD\n@@ -196,0 +209,3 @@\n+=======\n+            MemorySegment seg = MemorySegment.allocateNative(ValueLayout.JAVA_INT, arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -206,0 +222,1 @@\n+<<<<<<< HEAD\n@@ -207,0 +224,3 @@\n+=======\n+            MemorySegment seg = MemorySegment.allocateNative(ValueLayout.JAVA_INT, arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -214,0 +234,1 @@\n+<<<<<<< HEAD\n@@ -215,0 +236,3 @@\n+=======\n+        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -257,0 +281,1 @@\n+<<<<<<< HEAD\n@@ -258,0 +283,3 @@\n+=======\n+        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -295,0 +323,1 @@\n+<<<<<<< HEAD\n@@ -296,0 +325,3 @@\n+=======\n+        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -334,0 +366,1 @@\n+<<<<<<< HEAD\n@@ -335,0 +368,3 @@\n+=======\n+        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -377,0 +413,1 @@\n+<<<<<<< HEAD\n@@ -378,0 +415,3 @@\n+=======\n+        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/TestAdaptVarHandles.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -111,0 +111,1 @@\n+<<<<<<< HEAD\n@@ -112,0 +113,3 @@\n+=======\n+        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -122,0 +126,1 @@\n+<<<<<<< HEAD\n@@ -123,0 +128,3 @@\n+=======\n+        MemorySegment segment = MemorySegment.ofAddress(0, seq.byteSize(), MemorySession.global());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -131,0 +139,1 @@\n+<<<<<<< HEAD\n@@ -132,0 +141,3 @@\n+=======\n+            MemorySegment segment = MemorySegment.allocateNative(layout.byteSize() + 1, layout.byteSize(), arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -140,0 +152,1 @@\n+<<<<<<< HEAD\n@@ -141,0 +154,3 @@\n+=======\n+        MemorySegment segment = MemorySegment.allocateNative(layout, arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/TestArrays.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -189,0 +189,1 @@\n+<<<<<<< HEAD\n@@ -190,0 +191,3 @@\n+=======\n+            MemorySegment segment = MemorySegment.allocateNative(tuples, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -235,0 +239,1 @@\n+<<<<<<< HEAD\n@@ -236,0 +241,3 @@\n+=======\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 8L, arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -241,0 +249,1 @@\n+<<<<<<< HEAD\n@@ -242,0 +251,3 @@\n+=======\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, 8L, arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -255,0 +267,1 @@\n+<<<<<<< HEAD\n@@ -256,0 +269,3 @@\n+=======\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, tuples.byteSize(), arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -263,0 +279,1 @@\n+<<<<<<< HEAD\n@@ -264,0 +281,3 @@\n+=======\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, tuples.byteSize(), arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -276,0 +296,1 @@\n+<<<<<<< HEAD\n@@ -277,0 +298,3 @@\n+=======\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 8L, arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -296,0 +320,1 @@\n+<<<<<<< HEAD\n@@ -297,0 +322,3 @@\n+=======\n+                MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, i, tuples.byteSize(), arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -307,0 +335,1 @@\n+<<<<<<< HEAD\n@@ -308,0 +337,3 @@\n+=======\n+                MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, tuples.byteSize(), arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -327,0 +359,1 @@\n+<<<<<<< HEAD\n@@ -328,0 +361,3 @@\n+=======\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, LARGE_SIZE, arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -364,0 +400,1 @@\n+<<<<<<< HEAD\n@@ -365,0 +402,3 @@\n+=======\n+            MemorySegment segment = MemorySegment.allocateNative(bytes, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -390,0 +430,1 @@\n+<<<<<<< HEAD\n@@ -391,0 +432,3 @@\n+=======\n+            MemorySegment segment = MemorySegment.allocateNative(bytes, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -424,0 +468,1 @@\n+<<<<<<< HEAD\n@@ -425,0 +470,3 @@\n+=======\n+            MemorySegment segment = MemorySegment.allocateNative(bytes, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -437,0 +485,1 @@\n+<<<<<<< HEAD\n@@ -438,0 +487,3 @@\n+=======\n+            MemorySegment segment = MemorySegment.allocateNative(seq, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -475,0 +527,1 @@\n+<<<<<<< HEAD\n@@ -476,0 +529,3 @@\n+=======\n+            MemorySegment segment = MemorySegment.allocateNative(seq, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -486,0 +542,1 @@\n+<<<<<<< HEAD\n@@ -487,0 +544,3 @@\n+=======\n+            leaked = MemorySegment.allocateNative(bytes, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -494,0 +554,1 @@\n+<<<<<<< HEAD\n@@ -495,0 +556,3 @@\n+=======\n+        MemorySegment segment = MemorySegment.ofAddress(0, Integer.MAX_VALUE + 10L, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -504,0 +568,1 @@\n+<<<<<<< HEAD\n@@ -505,0 +570,3 @@\n+=======\n+            fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, -1L, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -514,0 +582,1 @@\n+<<<<<<< HEAD\n@@ -515,0 +584,3 @@\n+=======\n+            fileChannel.map(FileChannel.MapMode.READ_WRITE, -1L, 1L, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -528,0 +600,1 @@\n+<<<<<<< HEAD\n@@ -529,0 +602,3 @@\n+=======\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, SIZE, arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -538,0 +614,1 @@\n+<<<<<<< HEAD\n@@ -539,0 +616,3 @@\n+=======\n+                MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, offset, SIZE - offset, arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -552,0 +632,1 @@\n+<<<<<<< HEAD\n@@ -553,0 +634,3 @@\n+=======\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 0L, arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -564,0 +648,1 @@\n+<<<<<<< HEAD\n@@ -565,0 +650,3 @@\n+=======\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, 0L, arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -579,0 +667,1 @@\n+<<<<<<< HEAD\n@@ -580,0 +669,3 @@\n+=======\n+            fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 0L, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -588,0 +680,1 @@\n+<<<<<<< HEAD\n@@ -589,0 +682,3 @@\n+=======\n+            MemorySegment nativeArray = MemorySegment.allocateNative(bytes, 1, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -601,0 +697,1 @@\n+<<<<<<< HEAD\n@@ -602,0 +699,3 @@\n+=======\n+            MemorySegment nativeArray = MemorySegment.allocateNative(seq, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -673,0 +773,1 @@\n+<<<<<<< HEAD\n@@ -674,0 +775,3 @@\n+=======\n+            MemorySegment ms = MemorySegment.allocateNative(4, 1, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -683,0 +787,1 @@\n+<<<<<<< HEAD\n@@ -684,0 +789,3 @@\n+=======\n+        MemorySegment s1 = MemorySegment.allocateNative(JAVA_INT, arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -698,0 +806,1 @@\n+<<<<<<< HEAD\n@@ -699,0 +808,3 @@\n+=======\n+            MemorySegment segment = MemorySegment.allocateNative(10, 1, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -719,0 +831,1 @@\n+<<<<<<< HEAD\n@@ -720,0 +833,3 @@\n+=======\n+            MemorySegment segment = MemorySegment.allocateNative(10, arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -737,0 +853,1 @@\n+<<<<<<< HEAD\n@@ -738,0 +855,3 @@\n+=======\n+            MemorySegment segment = MemorySegment.allocateNative(16, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -755,0 +875,1 @@\n+<<<<<<< HEAD\n@@ -756,0 +877,3 @@\n+=======\n+            MemorySegment segment = MemorySegment.allocateNative(16, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -765,0 +889,1 @@\n+<<<<<<< HEAD\n@@ -767,0 +892,4 @@\n+=======\n+                { (Supplier<MemorySegment>) () -> MemorySegment.allocateNative(16, MemorySession.implicit()) },\n+                { (Supplier<MemorySegment>) () -> MemorySegment.allocateNative(16, Arena.openConfined().session()) },\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+<<<<<<< HEAD\n@@ -70,0 +71,3 @@\n+=======\n+                    SegmentAllocator.nativeAllocator(arena.session()) :\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -76,0 +80,1 @@\n+<<<<<<< HEAD\n@@ -77,0 +82,3 @@\n+=======\n+                    assertEquals(((MemorySegment)res).session(), arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/TestDowncallScope.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+<<<<<<< HEAD\n@@ -66,0 +67,3 @@\n+=======\n+                    SegmentAllocator.nativeAllocator(arena.session()) :\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -72,0 +76,1 @@\n+<<<<<<< HEAD\n@@ -73,0 +78,3 @@\n+=======\n+                    assertEquals(((MemorySegment)res).session(), arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/TestDowncallStack.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+<<<<<<< HEAD\n@@ -72,0 +73,3 @@\n+=======\n+            MemorySegment segment = MemorySegment.allocateNative(SEGMENT_SIZE, 1, arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/TestHandshake.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -103,0 +103,1 @@\n+<<<<<<< HEAD\n@@ -104,0 +105,3 @@\n+=======\n+        NATIVE(MemorySegment.allocateNative(8, MemorySession.implicit()), -1);\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/TestHeapAlignment.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+<<<<<<< HEAD\n@@ -29,0 +30,2 @@\n+=======\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -49,0 +52,1 @@\n+<<<<<<< HEAD\n@@ -50,0 +54,3 @@\n+=======\n+            var segment = MemorySegment.allocateNative((long) longArrayLength * Long.BYTES, Long.SIZE, arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/TestLargeSegmentCopy.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -437,0 +437,1 @@\n+<<<<<<< HEAD\n@@ -438,0 +439,3 @@\n+=======\n+            MemorySegment segment = MemorySegment.allocateNative(layout, arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -472,0 +476,1 @@\n+<<<<<<< HEAD\n@@ -473,0 +478,3 @@\n+=======\n+            MemorySegment segment = MemorySegment.allocateNative(layout, arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+<<<<<<< HEAD\n@@ -57,0 +58,3 @@\n+=======\n+            MemorySegment segment = MemorySegment.allocateNative(seq, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/TestLayouts.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+<<<<<<< HEAD\n@@ -28,0 +29,2 @@\n+=======\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/TestLinker.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -95,0 +95,1 @@\n+<<<<<<< HEAD\n@@ -96,0 +97,3 @@\n+=======\n+            MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(layout, arena.session()));\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -127,0 +131,1 @@\n+<<<<<<< HEAD\n@@ -128,0 +133,3 @@\n+=======\n+            MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq, arena.session()));\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -196,0 +204,1 @@\n+<<<<<<< HEAD\n@@ -197,0 +206,3 @@\n+=======\n+            MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq, arena.session()));\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccess.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+<<<<<<< HEAD\n@@ -84,0 +85,3 @@\n+=======\n+                MemorySegment segment = MemorySegment.allocateNative(128, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -96,0 +100,1 @@\n+<<<<<<< HEAD\n@@ -97,0 +102,3 @@\n+=======\n+                MemorySegment segment = MemorySegment.allocateNative(64, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccessInstance.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+<<<<<<< HEAD\n@@ -57,0 +58,3 @@\n+=======\n+            MemorySegment segment = MemorySegment.allocateNative(aligned, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -74,0 +78,1 @@\n+<<<<<<< HEAD\n@@ -75,0 +80,3 @@\n+=======\n+            MemorySegment segment = MemorySegment.allocateNative(alignedGroup, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -101,0 +109,1 @@\n+<<<<<<< HEAD\n@@ -102,0 +111,3 @@\n+=======\n+                MemorySegment segment = MemorySegment.allocateNative(layout, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -125,0 +137,1 @@\n+<<<<<<< HEAD\n@@ -126,0 +139,3 @@\n+=======\n+            MemorySegment segment = MemorySegment.allocateNative(g, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAlignment.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+<<<<<<< HEAD\n@@ -58,0 +59,3 @@\n+=======\n+            addCloseAction(arena.session(), () -> acc.addAndGet(delta));\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -68,0 +72,1 @@\n+<<<<<<< HEAD\n@@ -69,0 +74,3 @@\n+=======\n+        MemorySession session = sessionSupplier.get();\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -91,0 +99,1 @@\n+<<<<<<< HEAD\n@@ -93,0 +102,4 @@\n+=======\n+        MemorySession session = sessionSupplier.get();\n+        AtomicReference<MemorySession> sessionRef = new AtomicReference<>(session);\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -149,0 +162,1 @@\n+<<<<<<< HEAD\n@@ -150,0 +164,3 @@\n+=======\n+            keepAlive(handle.session(), arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -173,0 +190,1 @@\n+<<<<<<< HEAD\n@@ -174,0 +192,3 @@\n+=======\n+                    keepAlive(handle.session(), arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -208,0 +229,1 @@\n+<<<<<<< HEAD\n@@ -209,0 +231,3 @@\n+=======\n+        keepAlive(handle.session(), arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -229,0 +254,1 @@\n+<<<<<<< HEAD\n@@ -230,0 +256,3 @@\n+=======\n+        MemorySession session = sessionSupplier.get();\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -235,0 +264,1 @@\n+<<<<<<< HEAD\n@@ -238,0 +268,5 @@\n+=======\n+    private void acquireRecursive(MemorySession session, int acquireCount) {\n+        try (Arena arena = Arena.openConfined()) {\n+            keepAlive(arena.session(), session);\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -253,0 +288,1 @@\n+<<<<<<< HEAD\n@@ -254,0 +290,3 @@\n+=======\n+            keepAlive(MemorySession.implicit(), root.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -266,0 +305,1 @@\n+<<<<<<< HEAD\n@@ -267,0 +307,3 @@\n+=======\n+                        keepAlive(arena.session(), root.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -282,0 +325,1 @@\n+<<<<<<< HEAD\n@@ -283,0 +327,3 @@\n+=======\n+            keepAlive(arena.session(), root.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -289,0 +336,1 @@\n+<<<<<<< HEAD\n@@ -290,0 +338,3 @@\n+=======\n+                keepAlive(arena.session(), root.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -329,0 +380,1 @@\n+<<<<<<< HEAD\n@@ -331,0 +383,4 @@\n+=======\n+    private void keepAlive(MemorySession child, MemorySession parent) {\n+        MemorySessionImpl parentImpl = MemorySessionImpl.toSessionImpl(parent);\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -335,0 +391,1 @@\n+<<<<<<< HEAD\n@@ -347,0 +404,14 @@\n+=======\n+    private void addCloseAction(MemorySession session, Runnable action) {\n+        MemorySessionImpl sessionImpl = MemorySessionImpl.toSessionImpl(session);\n+        sessionImpl.addCloseAction(action);\n+    }\n+\n+    interface SessionSupplier extends Supplier<MemorySession> {\n+\n+        static void close(MemorySession session) {\n+            ((MemorySessionImpl)session).close();\n+        }\n+\n+        static boolean isImplicit(MemorySession session) {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -351,0 +422,1 @@\n+<<<<<<< HEAD\n@@ -356,0 +428,7 @@\n+=======\n+            return MemorySession::implicit;\n+        }\n+\n+        static SessionSupplier ofArena(Supplier<Arena> arenaSupplier) {\n+            return () -> arenaSupplier.get().session();\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/TestMemorySession.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+<<<<<<< HEAD\n@@ -32,0 +33,3 @@\n+=======\n+import java.lang.foreign.MemorySession;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -176,0 +180,1 @@\n+<<<<<<< HEAD\n@@ -177,0 +182,3 @@\n+=======\n+            var nativeSegment = MemorySegment.allocateNative(4, 4, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -188,0 +196,1 @@\n+<<<<<<< HEAD\n@@ -190,0 +199,4 @@\n+=======\n+                var s1 = MemorySegment.allocateNative((long) Integer.MAX_VALUE + 10L, 8, arena.session());;\n+                var s2 = MemorySegment.allocateNative((long) Integer.MAX_VALUE + 10L, 8, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -232,0 +245,1 @@\n+<<<<<<< HEAD\n@@ -234,0 +248,4 @@\n+=======\n+            s1 = MemorySegment.allocateNative(4, 1, arena.session());;\n+            s2 = MemorySegment.allocateNative(4, 1, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -243,0 +261,1 @@\n+<<<<<<< HEAD\n@@ -244,0 +263,3 @@\n+=======\n+            var segment = MemorySegment.allocateNative(4, 1, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -284,0 +306,1 @@\n+<<<<<<< HEAD\n@@ -285,0 +308,3 @@\n+=======\n+        NATIVE(i -> MemorySegment.allocateNative(i, MemorySession.implicit())),\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/TestMismatch.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+<<<<<<< HEAD\n@@ -37,0 +38,6 @@\n+=======\n+import java.lang.foreign.MemorySession;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemoryLayout.PathElement;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -149,0 +156,1 @@\n+<<<<<<< HEAD\n@@ -150,0 +158,3 @@\n+=======\n+            MemorySegment segment = MemorySegment.allocateNative(seq, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -159,0 +170,1 @@\n+<<<<<<< HEAD\n@@ -160,0 +172,3 @@\n+=======\n+            MemorySegment segment = MemorySegment.allocateNative(doubles, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -173,0 +188,1 @@\n+<<<<<<< HEAD\n@@ -174,0 +190,3 @@\n+=======\n+                    arena.session(), () -> freeMemory(addr));\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -184,0 +203,1 @@\n+<<<<<<< HEAD\n@@ -185,0 +205,3 @@\n+=======\n+                    arena.session(), () -> freeMemory(addr));\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -202,0 +225,1 @@\n+<<<<<<< HEAD\n@@ -204,0 +228,4 @@\n+=======\n+            MemorySegment segment = MemorySegment.allocateNative(4, 1, arena.session());;\n+            MemorySegment.ofAddress(segment.address(), -1, MemorySession.global());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/TestNative.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -110,0 +110,1 @@\n+<<<<<<< HEAD\n@@ -113,0 +114,5 @@\n+=======\n+            \"java.lang.foreign.MemorySegment\/ofAddress(long,long,java.lang.foreign.MemorySession,java.lang.Runnable)\/3\/0\",\n+            \"java.lang.foreign.MemorySession\/openConfined(java.lang.ref.Cleaner)\/0\/0\",\n+            \"java.lang.foreign.MemorySession\/openShared(java.lang.ref.Cleaner)\/0\/0\",\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -187,0 +193,1 @@\n+<<<<<<< HEAD\n@@ -188,0 +195,3 @@\n+=======\n+        addDefaultMapping(MemorySession.class, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -202,0 +212,1 @@\n+<<<<<<< HEAD\n@@ -203,0 +214,3 @@\n+=======\n+            }, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+<<<<<<< HEAD\n@@ -79,0 +80,3 @@\n+=======\n+        Z obj = scopedOperation.apply(arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -91,0 +95,1 @@\n+<<<<<<< HEAD\n@@ -92,0 +97,3 @@\n+=======\n+            Z obj = scopedOperation.apply(arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -96,0 +96,1 @@\n+<<<<<<< HEAD\n@@ -97,0 +98,3 @@\n+=======\n+                    assertFalse(address.session().isAlive());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -191,0 +195,1 @@\n+<<<<<<< HEAD\n@@ -192,0 +197,3 @@\n+=======\n+                return MemorySegment.allocateNative(byteSize, byteAlignment, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -351,0 +359,1 @@\n+<<<<<<< HEAD\n@@ -353,0 +362,4 @@\n+=======\n+        SLICING(true, (size, drop) -> SegmentAllocator.slicingAllocator(MemorySegment.allocateNative(size, drop.session()))),\n+        NATIVE_ALLOCATOR(false, (size, drop) -> SegmentAllocator.nativeAllocator(drop.session()));\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -484,0 +497,1 @@\n+<<<<<<< HEAD\n@@ -486,0 +500,4 @@\n+=======\n+                { SegmentAllocator.nativeAllocator(MemorySession.global()) },\n+                { SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(10, MemorySession.global())) },\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/TestSegmentAllocators.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -147,0 +147,1 @@\n+<<<<<<< HEAD\n@@ -148,0 +149,3 @@\n+=======\n+            NATIVE(i -> MemorySegment.allocateNative(i, MemorySession.implicit())),\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/TestSegmentCopy.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -84,0 +84,1 @@\n+<<<<<<< HEAD\n@@ -85,0 +86,3 @@\n+=======\n+            NATIVE(i -> MemorySegment.allocateNative(i, MemorySession.implicit())),\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/TestSegmentOffset.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+<<<<<<< HEAD\n@@ -69,0 +70,6 @@\n+=======\n+                () -> MemorySegment.allocateNative(16, MemorySession.implicit()),\n+                () -> {\n+                    try (FileChannel fileChannel = FileChannel.open(tempPath, StandardOpenOption.READ, StandardOpenOption.WRITE)) {\n+                        return fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 16L, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -135,0 +142,1 @@\n+<<<<<<< HEAD\n@@ -136,0 +144,3 @@\n+=======\n+        NATIVE(() -> MemorySegment.allocateNative(16, MemorySession.implicit())),\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/TestSegmentOverlap.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+<<<<<<< HEAD\n@@ -54,0 +55,3 @@\n+=======\n+        MemorySegment.allocateNative(size, align, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -59,0 +63,1 @@\n+<<<<<<< HEAD\n@@ -60,0 +65,3 @@\n+=======\n+            MemorySession session = arena.session();\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -78,0 +86,1 @@\n+<<<<<<< HEAD\n@@ -79,0 +88,3 @@\n+=======\n+        MemorySegment.allocateNative(Long.MAX_VALUE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -83,0 +95,1 @@\n+<<<<<<< HEAD\n@@ -84,0 +97,3 @@\n+=======\n+        MemorySegment segment = MemorySegment.allocateNative(1024L * 1024 * 8 * 2, MemorySession.implicit()); \/\/ 2M\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -90,0 +106,1 @@\n+<<<<<<< HEAD\n@@ -91,0 +108,3 @@\n+=======\n+            MemorySegment segment = MemorySegment.allocateNative(1000, 1, arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -101,0 +121,1 @@\n+<<<<<<< HEAD\n@@ -102,0 +123,3 @@\n+=======\n+            MemorySegment segment = MemorySegment.allocateNative(10, 1, arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -121,0 +145,1 @@\n+<<<<<<< HEAD\n@@ -122,0 +147,3 @@\n+=======\n+            MemorySegment segment = MemorySegment.allocateNative(100, arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -126,0 +154,1 @@\n+<<<<<<< HEAD\n@@ -128,0 +157,4 @@\n+=======\n+            assertEquals(segment, MemorySegment.ofAddress(segment.address(), 100, MemorySession.global()));\n+            MemorySegment segment2 = MemorySegment.allocateNative(100, arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -146,0 +179,1 @@\n+<<<<<<< HEAD\n@@ -151,0 +185,7 @@\n+=======\n+            MemorySegment segment = MemorySegment.allocateNative(100, arena.session());\n+            assertEquals(segment.hashCode(), segment.asReadOnly().hashCode());\n+            assertEquals(segment.hashCode(), segment.asSlice(0, 100).hashCode());\n+            assertEquals(segment.hashCode(), segment.asSlice(0, 90).hashCode());\n+            assertEquals(segment.hashCode(), MemorySegment.ofAddress(segment.address(), 100, MemorySession.global()).hashCode());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -165,0 +206,1 @@\n+<<<<<<< HEAD\n@@ -166,0 +208,3 @@\n+=======\n+        MemorySegment memorySegment = MemorySegment.allocateNative(10, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -172,0 +217,1 @@\n+<<<<<<< HEAD\n@@ -173,0 +219,3 @@\n+=======\n+        MemorySegment memorySegment = MemorySegment.allocateNative(10L, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -204,0 +253,1 @@\n+<<<<<<< HEAD\n@@ -210,0 +260,8 @@\n+=======\n+                () -> MemorySegment.allocateNative(4L, MemorySession.implicit()),\n+                () -> MemorySegment.allocateNative(4L, 8, MemorySession.implicit()),\n+                () -> MemorySegment.allocateNative(JAVA_INT, MemorySession.implicit()),\n+                () -> MemorySegment.allocateNative(4L, MemorySession.implicit()),\n+                () -> MemorySegment.allocateNative(4L, 8, MemorySession.implicit()),\n+                () -> MemorySegment.allocateNative(JAVA_INT, MemorySession.implicit())\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -267,0 +325,1 @@\n+<<<<<<< HEAD\n@@ -268,0 +327,3 @@\n+=======\n+        if (segment.session().isOwnedBy(Thread.currentThread())) {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+<<<<<<< HEAD\n@@ -54,0 +55,3 @@\n+=======\n+            MemorySegment s = MemorySegment.allocateNative(layout, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -98,0 +102,1 @@\n+<<<<<<< HEAD\n@@ -103,0 +108,7 @@\n+=======\n+            MemorySegment s = MemorySegment.allocateNative(4, 1, arena.session());;\n+            setInt(s, 42);\n+            assertEquals(getInt(s), 42);\n+            List<Thread> threads = new ArrayList<>();\n+            MemorySegment sharedSegment = MemorySegment.ofAddress(s.address(), s.byteSize(), arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -125,0 +137,1 @@\n+<<<<<<< HEAD\n@@ -126,0 +139,3 @@\n+=======\n+            MemorySegment s1 = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(2, ValueLayout.JAVA_INT), arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/TestSharedAccess.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+<<<<<<< HEAD\n@@ -51,0 +52,3 @@\n+=======\n+            MemorySegment segment = MemorySegment.allocateNative(LAYOUT, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -65,0 +69,1 @@\n+<<<<<<< HEAD\n@@ -66,0 +71,3 @@\n+=======\n+            MemorySegment segment = MemorySegment.allocateNative(LAYOUT, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/TestSlices.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+<<<<<<< HEAD\n@@ -64,0 +65,3 @@\n+=======\n+            MemorySegment segment = MemorySegment.allocateNative(layout, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -89,0 +93,1 @@\n+<<<<<<< HEAD\n@@ -90,0 +95,3 @@\n+=======\n+        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/TestSpliterator.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+<<<<<<< HEAD\n@@ -58,0 +59,3 @@\n+=======\n+            MemorySegment s = MemorySegment.allocateNative(8, 8, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -65,0 +69,1 @@\n+<<<<<<< HEAD\n@@ -66,0 +71,3 @@\n+=======\n+            MemorySegment s = MemorySegment.allocateNative(8, 8, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -73,0 +81,1 @@\n+<<<<<<< HEAD\n@@ -74,0 +83,3 @@\n+=======\n+            MemorySegment s = MemorySegment.allocateNative(8, 8, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -81,0 +93,1 @@\n+<<<<<<< HEAD\n@@ -82,0 +95,3 @@\n+=======\n+            MemorySegment s = MemorySegment.allocateNative(8, 8, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/TestTypeAccess.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+<<<<<<< HEAD\n@@ -33,0 +34,3 @@\n+=======\n+import java.lang.foreign.MemorySession;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -52,0 +56,1 @@\n+<<<<<<< HEAD\n@@ -53,0 +58,3 @@\n+=======\n+        VaList.make(builder -> builder.addVarg(ValueLayout.JAVA_INT, 42), MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -57,0 +65,1 @@\n+<<<<<<< HEAD\n@@ -58,0 +67,3 @@\n+=======\n+        VaList.ofAddress(0L, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/TestUnsupportedLinker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -41,0 +41,4 @@\n+<<<<<<< HEAD\n+=======\n+import java.lang.foreign.MemorySession;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -68,0 +72,1 @@\n+<<<<<<< HEAD\n@@ -69,0 +74,3 @@\n+=======\n+            Object[] args = makeArgs(MemorySession.implicit(), ret, paramTypes, fields, returnChecks, argChecks);\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -75,0 +83,1 @@\n+<<<<<<< HEAD\n@@ -76,0 +85,3 @@\n+=======\n+            MemorySegment callback = ABI.upcallStub(mh, callbackDesc, arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -81,0 +93,1 @@\n+<<<<<<< HEAD\n@@ -82,0 +95,3 @@\n+=======\n+                    ? invoker.invoke(arena.session(), callback)\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/TestUpcallAsync.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+<<<<<<< HEAD\n@@ -69,0 +70,3 @@\n+=======\n+        DUMMY_STUB = ABI.upcallStub(DUMMY, FunctionDescriptor.ofVoid(), MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -101,0 +105,1 @@\n+<<<<<<< HEAD\n@@ -102,0 +107,3 @@\n+=======\n+    static MemorySegment makeCallback(MemorySession session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -155,0 +163,1 @@\n+<<<<<<< HEAD\n@@ -156,0 +165,3 @@\n+=======\n+                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize(), MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/TestUpcallBase.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -42,0 +42,4 @@\n+<<<<<<< HEAD\n+=======\n+import java.lang.foreign.MemorySession;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -90,0 +94,1 @@\n+<<<<<<< HEAD\n@@ -91,0 +96,3 @@\n+=======\n+                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize(), MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -106,0 +114,1 @@\n+<<<<<<< HEAD\n@@ -107,0 +116,3 @@\n+=======\n+            MemorySegment upcallStub = LINKER.upcallStub(target, upcallDescriptor, arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+<<<<<<< HEAD\n@@ -59,0 +60,3 @@\n+=======\n+            Object[] args = makeArgs(arena.session(), ret, paramTypes, fields, returnChecks, argChecks);\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/TestUpcallScope.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+<<<<<<< HEAD\n@@ -39,0 +40,3 @@\n+=======\n+import java.lang.foreign.MemorySession;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -60,0 +64,1 @@\n+<<<<<<< HEAD\n@@ -61,0 +66,3 @@\n+=======\n+            Object[] args = makeArgsStack(arena.session(), ret, paramTypes, fields, returnChecks, argChecks);\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStack.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -93,0 +93,1 @@\n+<<<<<<< HEAD\n@@ -95,0 +96,4 @@\n+=======\n+            MemorySegment upcallStub = LINKER.upcallStub(target, upcallDesc, arena.session());\n+            MemorySegment argSegment = MemorySegment.allocateNative(S_PDI_LAYOUT, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+<<<<<<< HEAD\n@@ -78,0 +79,5 @@\n+=======\n+            MemorySegment writeBack = LINKER.upcallStub(checker, FunctionDescriptor.ofVoid(C_INT, C_POINTER), arena.session());\n+            MemorySegment callInfo = MemorySegment.allocateNative(CallInfo.LAYOUT, arena.session());;\n+            MemorySegment argIDs = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(args.size(), C_INT), arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -129,0 +135,1 @@\n+<<<<<<< HEAD\n@@ -130,0 +137,3 @@\n+=======\n+            MemorySegment seg = MemorySegment.ofAddress(ptr.address(), layout.byteSize(), arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+<<<<<<< HEAD\n@@ -33,0 +34,3 @@\n+=======\n+import java.lang.foreign.MemorySession;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -69,0 +73,1 @@\n+<<<<<<< HEAD\n@@ -70,0 +75,3 @@\n+=======\n+        MemorySegment segment = MemorySegment.allocateNative(1L, 2, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -106,0 +114,1 @@\n+<<<<<<< HEAD\n@@ -107,0 +116,3 @@\n+=======\n+            MemorySegment segment = MemorySegment.allocateNative(inner_size * outer_size * 8, 4, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/TestVarHandleCombinators.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+<<<<<<< HEAD\n@@ -77,0 +78,3 @@\n+=======\n+            MemorySegment stub = Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -89,0 +93,1 @@\n+<<<<<<< HEAD\n@@ -90,0 +95,3 @@\n+=======\n+            MemorySegment stub = Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.of(C_INT, C_INT), arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/ThrowingUpcall.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * @run testng TestAarch64CallArranger\n+ * @run testng TestLinuxAArch64CallArranger\n@@ -57,0 +57,1 @@\n+<<<<<<< HEAD:test\/jdk\/java\/foreign\/callarranger\/TestAarch64CallArranger.java\n@@ -58,0 +59,2 @@\n+=======\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63:test\/jdk\/java\/foreign\/callarranger\/TestLinuxAArch64CallArranger.java\n@@ -62,1 +65,4 @@\n-public class TestAarch64CallArranger extends CallArrangerTestBase {\n+public class TestLinuxAArch64CallArranger extends CallArrangerTestBase {\n+\n+    private static final VMStorage TARGET_ADDRESS_STORAGE = StubLocations.TARGET_ADDRESS.storage(StorageType.PLACEHOLDER);\n+    private static final VMStorage RETURN_BUFFER_STORAGE = StubLocations.RETURN_BUFFER.storage(StorageType.PLACEHOLDER);\n@@ -429,0 +435,1 @@\n+<<<<<<< HEAD:test\/jdk\/java\/foreign\/callarranger\/TestAarch64CallArranger.java\n@@ -649,0 +656,2 @@\n+=======\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63:test\/jdk\/java\/foreign\/callarranger\/TestLinuxAArch64CallArranger.java\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestLinuxAArch64CallArranger.java","additions":11,"deletions":2,"binary":false,"changes":13,"previous_filename":"test\/jdk\/java\/foreign\/callarranger\/TestAarch64CallArranger.java","status":"copied"},{"patch":"@@ -54,0 +54,1 @@\n+<<<<<<< HEAD\n@@ -55,0 +56,2 @@\n+=======\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestSysVCallArranger.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+<<<<<<< HEAD\n@@ -57,0 +58,2 @@\n+=======\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestWindowsCallArranger.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,0 +40,4 @@\n+<<<<<<< HEAD\n+=======\n+import java.lang.foreign.MemorySession;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/capturecallstate\/TestCaptureCallState.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+<<<<<<< HEAD\n@@ -79,0 +80,3 @@\n+=======\n+            var segment = MemorySegment.allocateNative(10, 1, drop.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -111,0 +115,1 @@\n+<<<<<<< HEAD\n@@ -113,0 +118,4 @@\n+=======\n+            ByteBuffer bb = segmentBufferOfSize(drop.session(), 64);\n+            ByteBuffer[] buffers = segmentBuffersOfSize(8, drop.session(), 32);\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -163,0 +172,1 @@\n+<<<<<<< HEAD\n@@ -165,0 +175,4 @@\n+=======\n+            MemorySegment segment1 = MemorySegment.allocateNative(10, 1, drop.session());\n+            MemorySegment segment2 = MemorySegment.allocateNative(10, 1, drop.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -187,0 +201,1 @@\n+<<<<<<< HEAD\n@@ -189,0 +204,4 @@\n+=======\n+                var writeBuffers = mixedBuffersOfSize(16, drop.session(), 32);\n+                var readBuffers = mixedBuffersOfSize(16, drop.session(), 32);\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -210,0 +229,1 @@\n+<<<<<<< HEAD\n@@ -211,0 +231,3 @@\n+=======\n+            var segment = MemorySegment.allocateNative(10, 1, drop.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -224,0 +247,1 @@\n+<<<<<<< HEAD\n@@ -225,0 +249,3 @@\n+=======\n+                assertTrue(drop.session().isAlive());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -231,0 +258,1 @@\n+<<<<<<< HEAD\n@@ -232,0 +260,3 @@\n+=======\n+                assertTrue(drop.session().isAlive());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -255,0 +286,1 @@\n+<<<<<<< HEAD\n@@ -256,0 +288,3 @@\n+=======\n+            var bba = segmentBuffersOfSize(32, drop.session(), 128);\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -264,0 +299,1 @@\n+<<<<<<< HEAD\n@@ -265,0 +301,3 @@\n+=======\n+                                var bba = segmentBuffersOfSize(32, drop.session(), 128);\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -275,0 +314,1 @@\n+<<<<<<< HEAD\n@@ -276,0 +316,3 @@\n+=======\n+            assertTrue(drop.session().isAlive());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -283,0 +326,1 @@\n+<<<<<<< HEAD\n@@ -284,0 +328,3 @@\n+=======\n+            assertTrue(drop.session().isAlive());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/channels\/TestAsyncSocketChannels.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+<<<<<<< HEAD\n@@ -69,0 +70,3 @@\n+=======\n+            ByteBuffer bb = segmentBufferOfSize(drop.session(), 16);\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -87,0 +91,1 @@\n+<<<<<<< HEAD\n@@ -88,0 +93,3 @@\n+=======\n+            ByteBuffer[] buffers = segmentBuffersOfSize(8, drop.session(), 16);\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -105,0 +113,1 @@\n+<<<<<<< HEAD\n@@ -107,0 +116,4 @@\n+=======\n+            MemorySegment segment1 = MemorySegment.allocateNative(10, 1, drop.session());\n+            MemorySegment segment2 = MemorySegment.allocateNative(10, 1, drop.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -144,0 +157,1 @@\n+<<<<<<< HEAD\n@@ -145,0 +159,3 @@\n+=======\n+            var segment = MemorySegment.allocateNative(10, 1, drop.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -174,0 +191,1 @@\n+<<<<<<< HEAD\n@@ -176,0 +194,4 @@\n+=======\n+            var writeBuffers = mixedBuffersOfSize(32, drop.session(), 64);\n+            var readBuffers = mixedBuffersOfSize(32, drop.session(), 64);\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -192,0 +214,1 @@\n+<<<<<<< HEAD\n@@ -196,0 +219,6 @@\n+=======\n+            var writeBuffers = Stream.of(mixedBuffersOfSize(16, drop1.session(), 64), mixedBuffersOfSize(16, drop2.session(), 64))\n+                                     .flatMap(Arrays::stream)\n+                                     .toArray(ByteBuffer[]::new);\n+            var readBuffers = Stream.of(mixedBuffersOfSize(16, drop1.session(), 64), mixedBuffersOfSize(16, drop2.session(), 64))\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/channels\/TestSocketChannels.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -37,0 +37,4 @@\n+<<<<<<< HEAD\n+=======\n+import java.lang.foreign.MemorySession;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -54,0 +58,1 @@\n+<<<<<<< HEAD\n@@ -55,0 +60,3 @@\n+=======\n+            arena.session().whileAlive(() -> {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/dontrelease\/TestDontRelease.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+<<<<<<< HEAD\n@@ -44,0 +45,3 @@\n+=======\n+        MemorySegment.ofAddress(0, 4000, MemorySession.global());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainDirect.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+<<<<<<< HEAD\n@@ -49,0 +50,4 @@\n+=======\n+                MethodType.methodType(MemorySegment.class, long.class, long.class, MemorySession.class));\n+        var seg = (MemorySegment)mh.invokeExact(0L, 4000L, MemorySession.global());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainInvoke.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+<<<<<<< HEAD\n@@ -47,0 +48,4 @@\n+=======\n+        Method method = MemorySegment.class.getDeclaredMethod(\"ofAddress\", long.class, long.class, MemorySession.class);\n+        method.invoke(null, 0L, 4000L, MemorySession.global());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainReflection.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+<<<<<<< HEAD\n@@ -27,0 +28,3 @@\n+=======\n+import java.lang.foreign.MemorySession;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -75,0 +79,1 @@\n+<<<<<<< HEAD\n@@ -76,0 +81,3 @@\n+=======\n+        addDefaultMapping(MemorySession.class, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/handles\/invoker_module\/handle\/invoker\/MethodHandleInvoker.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+<<<<<<< HEAD\n@@ -27,0 +28,3 @@\n+=======\n+import java.lang.foreign.MemorySession;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -54,0 +58,1 @@\n+<<<<<<< HEAD\n@@ -55,0 +60,3 @@\n+=======\n+                            MethodType.methodType(MemorySegment.class, long.class, long.class, MemorySession.class)),\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/handles\/lookup_module\/handle\/lookup\/MethodHandleLookup.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -121,0 +121,1 @@\n+<<<<<<< HEAD\n@@ -122,0 +123,3 @@\n+=======\n+            MemorySegment upcallStub = LINKER.upcallStub(saver, upcallDesc, arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -189,0 +193,1 @@\n+<<<<<<< HEAD\n@@ -190,0 +195,3 @@\n+=======\n+            MemorySegment callback = LINKER.upcallStub(upcallTarget, FunctionDescriptor.ofVoid(JAVA_BOOLEAN), arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -203,0 +211,1 @@\n+<<<<<<< HEAD\n@@ -204,0 +213,3 @@\n+=======\n+            { 0b01,          true  }, \/\/ zero least significant bit, but non-zero first byte\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/normalize\/TestNormalize.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -119,0 +119,1 @@\n+<<<<<<< HEAD\n@@ -120,0 +121,3 @@\n+=======\n+            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestAsyncStackWalk.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -118,0 +118,1 @@\n+<<<<<<< HEAD\n@@ -119,0 +120,3 @@\n+=======\n+            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestStackWalk.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+<<<<<<< HEAD\n@@ -84,0 +85,3 @@\n+=======\n+            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(C_INT, C_INT, C_INT, C_INT), arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/upcalldeopt\/TestUpcallDeopt.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -130,0 +130,1 @@\n+<<<<<<< HEAD\n@@ -139,0 +140,11 @@\n+=======\n+            = actions -> Windowsx64Linker.newVaList(actions, MemorySession.implicit());\n+    private static final Function<Consumer<VaList.Builder>, VaList> sysvVaListFactory\n+            = actions -> SysVx64Linker.newVaList(actions, MemorySession.implicit());\n+    private static final Function<Consumer<VaList.Builder>, VaList> linuxAArch64VaListFactory\n+            = actions -> LinuxAArch64Linker.newVaList(actions, MemorySession.implicit());\n+    private static final Function<Consumer<VaList.Builder>, VaList> macAArch64VaListFactory\n+            = actions -> MacOsAArch64Linker.newVaList(actions, MemorySession.implicit());\n+    private static final Function<Consumer<VaList.Builder>, VaList> platformVaListFactory\n+            = (builder) -> VaList.make(builder, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -230,0 +242,1 @@\n+<<<<<<< HEAD\n@@ -231,0 +244,3 @@\n+=======\n+            MemorySegment msInt = MemorySegment.allocateNative(JAVA_INT, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -248,0 +264,1 @@\n+<<<<<<< HEAD\n@@ -249,0 +266,3 @@\n+=======\n+                    MemorySegment struct = MemorySegment.allocateNative(pointLayout, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -285,0 +305,1 @@\n+<<<<<<< HEAD\n@@ -286,0 +307,3 @@\n+=======\n+            MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -301,0 +325,1 @@\n+<<<<<<< HEAD\n@@ -302,0 +327,3 @@\n+=======\n+                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -338,0 +366,1 @@\n+<<<<<<< HEAD\n@@ -339,0 +368,3 @@\n+=======\n+            MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -354,0 +386,1 @@\n+<<<<<<< HEAD\n@@ -355,0 +388,3 @@\n+=======\n+                    MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -392,0 +428,1 @@\n+<<<<<<< HEAD\n@@ -393,0 +430,3 @@\n+=======\n+            MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -412,0 +452,1 @@\n+<<<<<<< HEAD\n@@ -413,0 +454,3 @@\n+=======\n+                    MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -456,0 +500,1 @@\n+<<<<<<< HEAD\n@@ -457,0 +502,3 @@\n+=======\n+            MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -508,0 +556,1 @@\n+<<<<<<< HEAD\n@@ -510,0 +559,4 @@\n+=======\n+            MemorySegment longSum = MemorySegment.allocateNative(longLayout, arena.session());;\n+            MemorySegment doubleSum = MemorySegment.allocateNative(doubleLayout, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -536,0 +589,1 @@\n+<<<<<<< HEAD\n@@ -537,0 +591,3 @@\n+=======\n+            MemorySegment stub = abi.upcallStub(callback, desc, arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -578,0 +635,1 @@\n+<<<<<<< HEAD\n@@ -579,0 +637,3 @@\n+=======\n+                    .addVarg(intLayout, 8), arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -583,0 +644,1 @@\n+<<<<<<< HEAD\n@@ -584,0 +646,3 @@\n+=======\n+        assertFalse(listLeaked.segment().session().isAlive());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -593,0 +658,1 @@\n+<<<<<<< HEAD\n@@ -598,0 +664,7 @@\n+=======\n+                MemorySegment pointIn = MemorySegment.allocateNative(Point_LAYOUT, innerArena.session());;\n+                VH_Point_x.set(pointIn, 3);\n+                VH_Point_y.set(pointIn, 6);\n+                VaList list = vaListFactory.apply(b -> b.addVarg(Point_LAYOUT, pointIn));\n+                pointOut = MemorySegment.allocateNative(Point_LAYOUT, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -619,0 +692,1 @@\n+<<<<<<< HEAD\n@@ -623,0 +697,6 @@\n+=======\n+    public void testCopy(BiFunction<Consumer<VaList.Builder>, MemorySession, VaList> vaListFactory, ValueLayout.OfInt intLayout) {\n+        try (var arena = Arena.openConfined()) {\n+            VaList list = vaListFactory.apply(b -> b.addVarg(intLayout, 4)\n+                    .addVarg(intLayout, 8), arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -646,0 +726,1 @@\n+<<<<<<< HEAD\n@@ -647,0 +728,3 @@\n+=======\n+                    .addVarg(intLayout, 8), arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -684,0 +768,1 @@\n+<<<<<<< HEAD\n@@ -685,0 +770,3 @@\n+=======\n+                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -691,0 +779,1 @@\n+<<<<<<< HEAD\n@@ -692,0 +781,3 @@\n+=======\n+                    MemorySegment struct =  MemorySegment.allocateNative(BigPoint_LAYOUT, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -705,0 +797,1 @@\n+<<<<<<< HEAD\n@@ -706,0 +799,3 @@\n+=======\n+                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -717,0 +813,1 @@\n+<<<<<<< HEAD\n@@ -718,0 +815,3 @@\n+=======\n+                    MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -723,0 +823,1 @@\n+<<<<<<< HEAD\n@@ -724,0 +825,3 @@\n+=======\n+                    MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -730,0 +834,1 @@\n+<<<<<<< HEAD\n@@ -731,0 +836,3 @@\n+=======\n+                    MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -775,0 +883,1 @@\n+<<<<<<< HEAD\n@@ -776,0 +885,3 @@\n+=======\n+                    MemorySegment buffer = MemorySegment.allocateNative(BigPoint_LAYOUT, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -825,0 +937,1 @@\n+<<<<<<< HEAD\n@@ -826,0 +939,3 @@\n+=======\n+        return VaList.ofAddress(segment.address(), MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+<<<<<<< HEAD\n@@ -47,0 +48,3 @@\n+=======\n+                    MemorySegment.allocateNative(s, MemorySession.implicit())\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -54,0 +58,1 @@\n+<<<<<<< HEAD\n@@ -55,0 +60,3 @@\n+=======\n+                    MemorySegment.allocateNative(s, MemorySession.implicit())\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/jdk\/incubator\/vector\/AbstractVectorLoadStoreTest.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -482,0 +482,1 @@\n+<<<<<<< HEAD\n@@ -484,0 +485,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -511,0 +516,1 @@\n+<<<<<<< HEAD\n@@ -513,0 +519,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -575,0 +585,1 @@\n+<<<<<<< HEAD\n@@ -577,0 +588,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -606,0 +621,1 @@\n+<<<<<<< HEAD\n@@ -608,0 +624,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorLoadStoreTests.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -482,0 +482,1 @@\n+<<<<<<< HEAD\n@@ -484,0 +485,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -511,0 +516,1 @@\n+<<<<<<< HEAD\n@@ -513,0 +519,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -575,0 +585,1 @@\n+<<<<<<< HEAD\n@@ -577,0 +588,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -606,0 +621,1 @@\n+<<<<<<< HEAD\n@@ -608,0 +624,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorLoadStoreTests.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -482,0 +482,1 @@\n+<<<<<<< HEAD\n@@ -484,0 +485,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -511,0 +516,1 @@\n+<<<<<<< HEAD\n@@ -513,0 +519,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -575,0 +585,1 @@\n+<<<<<<< HEAD\n@@ -577,0 +588,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -606,0 +621,1 @@\n+<<<<<<< HEAD\n@@ -608,0 +624,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorLoadStoreTests.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -482,0 +482,1 @@\n+<<<<<<< HEAD\n@@ -484,0 +485,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -511,0 +516,1 @@\n+<<<<<<< HEAD\n@@ -513,0 +519,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -575,0 +585,1 @@\n+<<<<<<< HEAD\n@@ -577,0 +588,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -606,0 +621,1 @@\n+<<<<<<< HEAD\n@@ -608,0 +624,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorLoadStoreTests.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -489,0 +489,1 @@\n+<<<<<<< HEAD\n@@ -491,0 +492,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -518,0 +523,1 @@\n+<<<<<<< HEAD\n@@ -520,0 +526,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -582,0 +592,1 @@\n+<<<<<<< HEAD\n@@ -584,0 +595,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -613,0 +628,1 @@\n+<<<<<<< HEAD\n@@ -615,0 +631,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorLoadStoreTests.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -482,0 +482,1 @@\n+<<<<<<< HEAD\n@@ -484,0 +485,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -511,0 +516,1 @@\n+<<<<<<< HEAD\n@@ -513,0 +519,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -575,0 +585,1 @@\n+<<<<<<< HEAD\n@@ -577,0 +588,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -606,0 +621,1 @@\n+<<<<<<< HEAD\n@@ -608,0 +624,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorLoadStoreTests.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -482,0 +482,1 @@\n+<<<<<<< HEAD\n@@ -484,0 +485,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -511,0 +516,1 @@\n+<<<<<<< HEAD\n@@ -513,0 +519,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -575,0 +585,1 @@\n+<<<<<<< HEAD\n@@ -577,0 +588,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -606,0 +621,1 @@\n+<<<<<<< HEAD\n@@ -608,0 +624,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorLoadStoreTests.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -482,0 +482,1 @@\n+<<<<<<< HEAD\n@@ -484,0 +485,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -511,0 +516,1 @@\n+<<<<<<< HEAD\n@@ -513,0 +519,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -575,0 +585,1 @@\n+<<<<<<< HEAD\n@@ -577,0 +588,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -606,0 +621,1 @@\n+<<<<<<< HEAD\n@@ -608,0 +624,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorLoadStoreTests.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -482,0 +482,1 @@\n+<<<<<<< HEAD\n@@ -484,0 +485,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -511,0 +516,1 @@\n+<<<<<<< HEAD\n@@ -513,0 +519,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -575,0 +585,1 @@\n+<<<<<<< HEAD\n@@ -577,0 +588,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -606,0 +621,1 @@\n+<<<<<<< HEAD\n@@ -608,0 +624,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorLoadStoreTests.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -489,0 +489,1 @@\n+<<<<<<< HEAD\n@@ -491,0 +492,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -518,0 +523,1 @@\n+<<<<<<< HEAD\n@@ -520,0 +526,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -582,0 +592,1 @@\n+<<<<<<< HEAD\n@@ -584,0 +595,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -613,0 +628,1 @@\n+<<<<<<< HEAD\n@@ -615,0 +631,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorLoadStoreTests.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -482,0 +482,1 @@\n+<<<<<<< HEAD\n@@ -484,0 +485,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -511,0 +516,1 @@\n+<<<<<<< HEAD\n@@ -513,0 +519,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -575,0 +585,1 @@\n+<<<<<<< HEAD\n@@ -577,0 +588,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -606,0 +621,1 @@\n+<<<<<<< HEAD\n@@ -608,0 +624,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorLoadStoreTests.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -482,0 +482,1 @@\n+<<<<<<< HEAD\n@@ -484,0 +485,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -511,0 +516,1 @@\n+<<<<<<< HEAD\n@@ -513,0 +519,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -575,0 +585,1 @@\n+<<<<<<< HEAD\n@@ -577,0 +588,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -606,0 +621,1 @@\n+<<<<<<< HEAD\n@@ -608,0 +624,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorLoadStoreTests.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -482,0 +482,1 @@\n+<<<<<<< HEAD\n@@ -484,0 +485,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -511,0 +516,1 @@\n+<<<<<<< HEAD\n@@ -513,0 +519,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -575,0 +585,1 @@\n+<<<<<<< HEAD\n@@ -577,0 +588,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -606,0 +621,1 @@\n+<<<<<<< HEAD\n@@ -608,0 +624,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorLoadStoreTests.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -482,0 +482,1 @@\n+<<<<<<< HEAD\n@@ -484,0 +485,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -511,0 +516,1 @@\n+<<<<<<< HEAD\n@@ -513,0 +519,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -575,0 +585,1 @@\n+<<<<<<< HEAD\n@@ -577,0 +588,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -606,0 +621,1 @@\n+<<<<<<< HEAD\n@@ -608,0 +624,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorLoadStoreTests.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -489,0 +489,1 @@\n+<<<<<<< HEAD\n@@ -491,0 +492,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -518,0 +523,1 @@\n+<<<<<<< HEAD\n@@ -520,0 +526,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -582,0 +592,1 @@\n+<<<<<<< HEAD\n@@ -584,0 +595,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -613,0 +628,1 @@\n+<<<<<<< HEAD\n@@ -615,0 +631,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorLoadStoreTests.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -482,0 +482,1 @@\n+<<<<<<< HEAD\n@@ -484,0 +485,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -511,0 +516,1 @@\n+<<<<<<< HEAD\n@@ -513,0 +519,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -575,0 +585,1 @@\n+<<<<<<< HEAD\n@@ -577,0 +588,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -606,0 +621,1 @@\n+<<<<<<< HEAD\n@@ -608,0 +624,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorLoadStoreTests.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -482,0 +482,1 @@\n+<<<<<<< HEAD\n@@ -484,0 +485,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -511,0 +516,1 @@\n+<<<<<<< HEAD\n@@ -513,0 +519,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -575,0 +585,1 @@\n+<<<<<<< HEAD\n@@ -577,0 +588,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -606,0 +621,1 @@\n+<<<<<<< HEAD\n@@ -608,0 +624,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorLoadStoreTests.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -482,0 +482,1 @@\n+<<<<<<< HEAD\n@@ -484,0 +485,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -511,0 +516,1 @@\n+<<<<<<< HEAD\n@@ -513,0 +519,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -575,0 +585,1 @@\n+<<<<<<< HEAD\n@@ -577,0 +588,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -606,0 +621,1 @@\n+<<<<<<< HEAD\n@@ -608,0 +624,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorLoadStoreTests.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -482,0 +482,1 @@\n+<<<<<<< HEAD\n@@ -484,0 +485,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -511,0 +516,1 @@\n+<<<<<<< HEAD\n@@ -513,0 +519,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -575,0 +585,1 @@\n+<<<<<<< HEAD\n@@ -577,0 +588,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -606,0 +621,1 @@\n+<<<<<<< HEAD\n@@ -608,0 +624,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorLoadStoreTests.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -489,0 +489,1 @@\n+<<<<<<< HEAD\n@@ -491,0 +492,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -518,0 +523,1 @@\n+<<<<<<< HEAD\n@@ -520,0 +526,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -582,0 +592,1 @@\n+<<<<<<< HEAD\n@@ -584,0 +595,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -613,0 +628,1 @@\n+<<<<<<< HEAD\n@@ -615,0 +631,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorLoadStoreTests.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -482,0 +482,1 @@\n+<<<<<<< HEAD\n@@ -484,0 +485,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -511,0 +516,1 @@\n+<<<<<<< HEAD\n@@ -513,0 +519,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -575,0 +585,1 @@\n+<<<<<<< HEAD\n@@ -577,0 +588,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -606,0 +621,1 @@\n+<<<<<<< HEAD\n@@ -608,0 +624,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorLoadStoreTests.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -482,0 +482,1 @@\n+<<<<<<< HEAD\n@@ -484,0 +485,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -511,0 +516,1 @@\n+<<<<<<< HEAD\n@@ -513,0 +519,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -575,0 +585,1 @@\n+<<<<<<< HEAD\n@@ -577,0 +588,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -606,0 +621,1 @@\n+<<<<<<< HEAD\n@@ -608,0 +624,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorLoadStoreTests.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -482,0 +482,1 @@\n+<<<<<<< HEAD\n@@ -484,0 +485,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -511,0 +516,1 @@\n+<<<<<<< HEAD\n@@ -513,0 +519,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -575,0 +585,1 @@\n+<<<<<<< HEAD\n@@ -577,0 +588,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -606,0 +621,1 @@\n+<<<<<<< HEAD\n@@ -608,0 +624,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorLoadStoreTests.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -482,0 +482,1 @@\n+<<<<<<< HEAD\n@@ -484,0 +485,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -511,0 +516,1 @@\n+<<<<<<< HEAD\n@@ -513,0 +519,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -575,0 +585,1 @@\n+<<<<<<< HEAD\n@@ -577,0 +588,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -606,0 +621,1 @@\n+<<<<<<< HEAD\n@@ -608,0 +624,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorLoadStoreTests.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -489,0 +489,1 @@\n+<<<<<<< HEAD\n@@ -491,0 +492,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -518,0 +523,1 @@\n+<<<<<<< HEAD\n@@ -520,0 +526,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -582,0 +592,1 @@\n+<<<<<<< HEAD\n@@ -584,0 +595,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -613,0 +628,1 @@\n+<<<<<<< HEAD\n@@ -615,0 +631,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorLoadStoreTests.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -482,0 +482,1 @@\n+<<<<<<< HEAD\n@@ -484,0 +485,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -511,0 +516,1 @@\n+<<<<<<< HEAD\n@@ -513,0 +519,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -575,0 +585,1 @@\n+<<<<<<< HEAD\n@@ -577,0 +588,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -606,0 +621,1 @@\n+<<<<<<< HEAD\n@@ -608,0 +624,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorLoadStoreTests.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -482,0 +482,1 @@\n+<<<<<<< HEAD\n@@ -484,0 +485,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -511,0 +516,1 @@\n+<<<<<<< HEAD\n@@ -513,0 +519,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -575,0 +585,1 @@\n+<<<<<<< HEAD\n@@ -577,0 +588,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -606,0 +621,1 @@\n+<<<<<<< HEAD\n@@ -608,0 +624,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorLoadStoreTests.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -482,0 +482,1 @@\n+<<<<<<< HEAD\n@@ -484,0 +485,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -511,0 +516,1 @@\n+<<<<<<< HEAD\n@@ -513,0 +519,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -575,0 +585,1 @@\n+<<<<<<< HEAD\n@@ -577,0 +588,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -606,0 +621,1 @@\n+<<<<<<< HEAD\n@@ -608,0 +624,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorLoadStoreTests.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -482,0 +482,1 @@\n+<<<<<<< HEAD\n@@ -484,0 +485,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -511,0 +516,1 @@\n+<<<<<<< HEAD\n@@ -513,0 +519,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -575,0 +585,1 @@\n+<<<<<<< HEAD\n@@ -577,0 +588,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -606,0 +621,1 @@\n+<<<<<<< HEAD\n@@ -608,0 +624,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorLoadStoreTests.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -489,0 +489,1 @@\n+<<<<<<< HEAD\n@@ -491,0 +492,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -518,0 +523,1 @@\n+<<<<<<< HEAD\n@@ -520,0 +526,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -582,0 +592,1 @@\n+<<<<<<< HEAD\n@@ -584,0 +595,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -613,0 +628,1 @@\n+<<<<<<< HEAD\n@@ -615,0 +631,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorLoadStoreTests.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -502,0 +502,1 @@\n+<<<<<<< HEAD\n@@ -504,0 +505,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, $Boxtype$.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), $Boxtype$.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -531,0 +536,1 @@\n+<<<<<<< HEAD\n@@ -533,0 +539,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, $Boxtype$.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), $Boxtype$.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -595,0 +605,1 @@\n+<<<<<<< HEAD\n@@ -597,0 +608,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, $Boxtype$.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), $Boxtype$.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -626,0 +641,1 @@\n+<<<<<<< HEAD\n@@ -628,0 +644,4 @@\n+=======\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, $Boxtype$.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), $Boxtype$.SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/X-LoadStoreTest.java.template","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+<<<<<<< HEAD\n@@ -68,0 +69,6 @@\n+=======\n+    final Arena arena = Arena.openConfined();\n+\n+    final long unsafe_addr = unsafe.allocateMemory(ALLOC_SIZE);\n+    final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -76,0 +83,1 @@\n+<<<<<<< HEAD\n@@ -78,0 +86,4 @@\n+=======\n+    final MemorySegment mismatchSegmentLarge1 = MemorySegment.allocateNative(SIZE_WITH_TAIL, arena.session());\n+    final MemorySegment mismatchSegmentLarge2 = MemorySegment.allocateNative(SIZE_WITH_TAIL, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -82,0 +94,1 @@\n+<<<<<<< HEAD\n@@ -84,0 +97,4 @@\n+=======\n+    final MemorySegment mismatchSegmentSmall1 = MemorySegment.allocateNative(7, arena.session());;\n+    final MemorySegment mismatchSegmentSmall2 = MemorySegment.allocateNative(7, arena.session());;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/BulkOps.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -26,0 +26,4 @@\n+<<<<<<< HEAD\n+=======\n+import java.lang.foreign.MemorySession;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -30,0 +34,1 @@\n+<<<<<<< HEAD\n@@ -31,0 +36,2 @@\n+=======\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -84,0 +91,1 @@\n+<<<<<<< HEAD\n@@ -90,0 +98,8 @@\n+=======\n+    static final MemorySegment sharedPoint = MemorySegment.allocateNative(POINT_LAYOUT, Arena.openShared().session());\n+    static final MemorySegment confinedPoint = MemorySegment.allocateNative(POINT_LAYOUT, Arena.openConfined().session());\n+\n+    static final MemorySegment point = MemorySegment.allocateNative(POINT_LAYOUT, MemorySession.implicit());\n+\n+    static final SegmentAllocator recycling_allocator = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(POINT_LAYOUT, MemorySession.implicit()));\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadHelper.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+<<<<<<< HEAD\n@@ -68,0 +69,3 @@\n+=======\n+        return LINKER.upcallStub(BLANK, BLANK_DESC, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LinkUpcall.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+<<<<<<< HEAD\n@@ -73,0 +74,3 @@\n+=======\n+    static final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverConstant.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,4 @@\n+<<<<<<< HEAD\n+=======\n+import java.lang.foreign.MemorySession;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -64,0 +68,1 @@\n+<<<<<<< HEAD\n@@ -65,0 +70,3 @@\n+=======\n+    final SegmentAllocator recyclingAlloc = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(ALLOC_LAYOUT, arena.session()));\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -138,0 +146,1 @@\n+<<<<<<< HEAD\n@@ -139,0 +148,3 @@\n+=======\n+        MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, 4, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNew.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+<<<<<<< HEAD\n@@ -74,0 +75,3 @@\n+=======\n+        segment = MemorySegment.allocateNative(ALLOC_SIZE, arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstant.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+<<<<<<< HEAD\n@@ -78,0 +79,4 @@\n+=======\n+        segmentIn = MemorySegment.allocateNative(ALLOC_SIZE, arena.session());\n+        segmentOut = MemorySegment.allocateNative(ALLOC_SIZE, arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantFP.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+<<<<<<< HEAD\n@@ -80,0 +81,3 @@\n+=======\n+            MemorySegment s = MemorySegment.allocateNative(ALLOC_SIZE, 1, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantHeap.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -99,0 +99,1 @@\n+<<<<<<< HEAD\n@@ -100,0 +101,3 @@\n+=======\n+        segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, ALLOC_SIZE, arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantMapped.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+<<<<<<< HEAD\n@@ -73,0 +74,3 @@\n+=======\n+        segment = MemorySegment.allocateNative(ALLOC_SIZE, CARRIER_SIZE, arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantShared.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+<<<<<<< HEAD\n@@ -27,0 +28,3 @@\n+=======\n+import java.lang.foreign.MemorySession;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -38,0 +42,1 @@\n+<<<<<<< HEAD\n@@ -39,0 +44,2 @@\n+=======\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -73,0 +80,1 @@\n+<<<<<<< HEAD\n@@ -74,0 +82,3 @@\n+=======\n+            res += MemorySegment.ofAddress(i, i % 100, MemorySession.global()).address();\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverOfAddress.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+<<<<<<< HEAD\n@@ -75,0 +76,4 @@\n+=======\n+        nativeSegment = MemorySegment.allocateNative(ALLOC_SIZE, 4, confinedArena.session());\n+        nativeSharedSegment = MemorySegment.allocateNative(ALLOC_SIZE, 4, sharedArena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverPollutedSegments.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+<<<<<<< HEAD\n@@ -68,0 +69,3 @@\n+=======\n+        nativeSegment = MemorySegment.allocateNative(ALLOC_SIZE, arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverSlice.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,4 @@\n+<<<<<<< HEAD\n+=======\n+import java.lang.foreign.MemorySession;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -121,0 +125,1 @@\n+<<<<<<< HEAD\n@@ -122,0 +127,3 @@\n+=======\n+        return MemorySegment.allocateNative(ALLOC_SIZE, 4, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -127,0 +135,1 @@\n+<<<<<<< HEAD\n@@ -128,0 +137,3 @@\n+=======\n+        return MemorySegment.allocateNative(ALLOC_SIZE, 4, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/MemorySessionClose.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+<<<<<<< HEAD\n@@ -84,0 +85,3 @@\n+=======\n+        segment = MemorySegment.allocateNative(ALLOC_SIZE, CARRIER_SIZE, arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ParallelSum.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+<<<<<<< HEAD\n@@ -57,0 +58,3 @@\n+=======\n+    MemorySegment segment = MemorySegment.allocateNative(100, arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -90,0 +94,1 @@\n+<<<<<<< HEAD\n@@ -91,0 +96,3 @@\n+=======\n+        MemorySegment newSegment = MemorySegment.ofAddress(segment.address(), 100, arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/PointerInvoke.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+<<<<<<< HEAD\n@@ -64,0 +65,3 @@\n+=======\n+    SegmentAllocator arenaAllocator = new RingAllocator(arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -84,0 +88,1 @@\n+<<<<<<< HEAD\n@@ -85,0 +90,3 @@\n+=======\n+        segmentAllocator = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(size + 1, arena.session()));\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -151,0 +159,1 @@\n+<<<<<<< HEAD\n@@ -152,0 +161,3 @@\n+=======\n+        public RingAllocator(MemorySession session) {\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -162,0 +174,1 @@\n+<<<<<<< HEAD\n@@ -164,0 +177,3 @@\n+=======\n+            rem = segment.byteSize() - segment.segmentOffset(res);\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/StrLenTest.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+<<<<<<< HEAD\n@@ -72,0 +73,3 @@\n+=======\n+        srcSegmentImplicit = MemorySegment.allocateNative(size, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/TestLoadBytes.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+<<<<<<< HEAD\n@@ -28,0 +29,2 @@\n+=======\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -70,0 +73,1 @@\n+<<<<<<< HEAD\n@@ -72,0 +76,4 @@\n+=======\n+            this.inputSegment = MemorySegment.ofAddress(inputAddress, 8*SIZE, MemorySession.global());\n+            this.outputSegment = MemorySegment.ofAddress(outputAddress, 8*SIZE, MemorySession.global());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/UnrolledAccess.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+<<<<<<< HEAD\n@@ -80,0 +81,3 @@\n+=======\n+                            .addVarg(C_LONG_LONG, 3L), arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/VaList.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+<<<<<<< HEAD\n@@ -68,0 +69,3 @@\n+=======\n+        data = MemorySegment.allocateNative(JAVA_INT, arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/VarHandleExact.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+<<<<<<< HEAD\n@@ -71,0 +72,3 @@\n+=======\n+        this.segment = MemorySegment.allocateNative(LAYOUT, arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/points\/support\/PanamaPoint.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+<<<<<<< HEAD\n@@ -74,0 +75,4 @@\n+=======\n+    nativeIn = MemorySegment.allocateNative(size, MemorySession.implicit());\n+    nativeOut = MemorySegment.allocateNative(size, MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/MemorySegmentVectorAccess.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -88,0 +88,1 @@\n+<<<<<<< HEAD\n@@ -90,0 +91,4 @@\n+=======\n+    srcSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), MemorySession.implicit());\n+    dstSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -167,0 +172,1 @@\n+<<<<<<< HEAD\n@@ -169,0 +175,4 @@\n+=======\n+      final var srcSegmentConfined = MemorySegment.ofAddress(srcSegment.address(), size, arena.session());\n+      final var dstSegmentConfined = MemorySegment.ofAddress(dstSegment.address(), size, arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreBytes.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+<<<<<<< HEAD\n@@ -28,0 +29,3 @@\n+=======\n+import java.lang.foreign.MemorySession;\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -93,0 +97,1 @@\n+<<<<<<< HEAD\n@@ -95,0 +100,4 @@\n+=======\n+    srcSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), MemorySession.implicit());\n+    dstSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), MemorySession.implicit());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n@@ -165,0 +174,1 @@\n+<<<<<<< HEAD\n@@ -167,0 +177,4 @@\n+=======\n+      final var srcSegmentConfined = MemorySegment.ofAddress(srcSegment.address(), size, arena.session());\n+      final var dstSegmentConfined = MemorySegment.ofAddress(dstSegment.address(), size, arena.session());\n+>>>>>>> d379ca1ca32926591fbf8a4afdae1a4a52b3cb63\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreShorts.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"}]}