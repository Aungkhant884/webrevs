{"files":[{"patch":"@@ -38,1 +38,1 @@\n-        default: 'linux-x64, linux-x86, linux-x64-variants, linux-cross-compile, macos-x64, macos-aarch64, windows-x64, windows-aarch64'\n+        default: 'linux-x64, linux-x86, linux-x64-variants, linux-cross-compile, macos-x64, macos-aarch64, windows-x64, windows-aarch64, docs'\n@@ -68,0 +68,1 @@\n+      docs: ${{ steps.include.outputs.docs }}\n@@ -80,6 +81,0 @@\n-            if [[ '${{ !secrets.JDK_SUBMIT_FILTER || startsWith(github.ref, 'refs\/heads\/submit\/') }}' == 'false' ]]; then\n-              # If JDK_SUBMIT_FILTER is set, and this is not a \"submit\/\" branch, don't run anything\n-              echo 'false'\n-              return\n-            fi\n-\n@@ -89,4 +84,8 @@\n-              input='${{ secrets.JDK_SUBMIT_PLATFORMS }}'\n-            else\n-              echo 'Internal error in GHA'\n-              exit 1\n+              if [[ '${{ !secrets.JDK_SUBMIT_FILTER || startsWith(github.ref, 'refs\/heads\/submit\/') }}' == 'false' ]]; then\n+                # If JDK_SUBMIT_FILTER is set, and this is not a \"submit\/\" branch, don't run anything\n+                >&2 echo 'JDK_SUBMIT_FILTER is set and not a \"submit\/\" branch'\n+                echo 'false'\n+                return\n+              else\n+                input='${{ secrets.JDK_SUBMIT_PLATFORMS }}'\n+              fi\n@@ -121,0 +120,1 @@\n+          echo \"docs=$(check_platform docs)\" >> $GITHUB_OUTPUT\n@@ -281,0 +281,17 @@\n+  build-docs:\n+    name: docs\n+    needs: select\n+    uses: .\/.github\/workflows\/build-linux.yml\n+    with:\n+      platform: linux-x64\n+      debug-levels: '[ \"debug\" ]'\n+      make-target: 'docs-jdk-bundles'\n+      # Make sure we never try to make full docs, since that would require a\n+      # build JDK, and we do not need the additional testing of the graphs.\n+      extra-conf-options: '--disable-full-docs'\n+      gcc-major-version: '10'\n+      apt-gcc-version: '10.4.0-4ubuntu1~22.04'\n+      configure-arguments: ${{ github.event.inputs.configure-arguments }}\n+      make-arguments: ${{ github.event.inputs.make-arguments }}\n+    if: needs.select.outputs.docs == 'true'\n+\n","filename":".github\/workflows\/main.yml","additions":28,"deletions":11,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-version=20\n+version=21\n","filename":".jcheck\/conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -105,0 +105,4 @@\n+# Allow overriding on the command line\n+# (intentionally sharing name with the javac option)\n+JAVA_WARNINGS_ARE_ERRORS ?= -Werror\n+\n@@ -336,0 +340,1 @@\n+  $1_OPTIONS += $$(JAVA_WARNINGS_ARE_ERRORS)\n","filename":"make\/Docs.gmk","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -535,1 +535,1 @@\n-    TOOLCHAIN_CFLAGS_JVM=\"-qtbtable=full -qtune=balanced \\\n+    TOOLCHAIN_CFLAGS_JVM=\"-qtbtable=full -qtune=balanced -fno-exceptions \\\n","filename":"make\/autoconf\/flags-cflags.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -506,1 +506,1 @@\n-  FLAGS_C_COMPILER_CHECK_ARGUMENTS(ARGUMENT: [ARG_ARGUMENT],\n+  FLAGS_C_COMPILER_CHECK_ARGUMENTS(ARGUMENT: ARG_ARGUMENT,\n@@ -509,2 +509,2 @@\n-      PREFIX: [ARG_PREFIX])\n-  FLAGS_CXX_COMPILER_CHECK_ARGUMENTS(ARGUMENT: [ARG_ARGUMENT],\n+      PREFIX: ARG_PREFIX)\n+  FLAGS_CXX_COMPILER_CHECK_ARGUMENTS(ARGUMENT: ARG_ARGUMENT,\n@@ -513,1 +513,1 @@\n-      PREFIX: [ARG_PREFIX])\n+      PREFIX: ARG_PREFIX)\n","filename":"make\/autoconf\/flags.m4","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-JTREG_MINIMUM_VERSION=7.1\n+JTREG_MINIMUM_VERSION=7.1.1\n","filename":"make\/autoconf\/lib-tests.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-    m4_foreach(arg, m4_split(m4_normalize($2)), [\n+    m4_foreach([arg], m4_split(m4_normalize($2)), [\n@@ -67,3 +67,8 @@\n-    m4_foreach([arg], [$3], [\n-      m4_if(m4_bregexp(arg, [: ]), -1, m4_define([arg], m4_bpatsubst(arg, [:], [: ])))\n-      m4_define(arg_name, m4_substr(arg, 0, m4_bregexp(arg, [: ])))\n+    # Delicate quoting and unquoting sequence to ensure the actual value is passed along unchanged\n+    # For details on how this works, see https:\/\/git.openjdk.org\/jdk\/pull\/11458#discussion_r1038173051\n+    # WARNING: Proceed at the risk of your own sanity, getting this to work has made me completely\n+    # incapable of feeling love or any other positive emotion\n+    # ~Julian\n+    m4_foreach([arg], m4_dquote(m4_dquote_elt($3)), [\n+      m4_if(m4_index(arg, [: ]), -1, [m4_define([arg], m4_dquote(m4_bpatsubst(m4_dquote(arg), [:], [: ])))])\n+      m4_define(arg_name, m4_substr(arg, 0, m4_index(arg, [: ])))\n@@ -73,1 +78,1 @@\n-      m4_pushdef([ARG_][]arg_name, m4_bpatsubst(m4_substr(arg, m4_incr(m4_incr(m4_bregexp(arg, [: ])))), [^\\s*], []))\n+      m4_pushdef([ARG_][]arg_name, m4_bpatsubst(m4_bpatsubst(m4_dquote(m4_dquote(arg)), arg_name[: ]), [^\\s*]))\n@@ -379,1 +384,1 @@\n-  m4_define([ARG_DESC], m4_if(ARG_DESC, , [Enable the ARG_NAME feature], m4_normalize(ARG_DESC)))\n+  m4_define([ARG_DESC], m4_if(m4_quote(ARG_DESC), , [[Enable the ARG_NAME feature]], [m4_normalize(ARG_DESC)]))\n@@ -382,1 +387,1 @@\n-  m4_define([ARG_CHECKING_MSG], m4_if(ARG_CHECKING_MSG, , [for --enable-ARG_NAME], m4_normalize(ARG_CHECKING_MSG)))\n+  m4_define([ARG_CHECKING_MSG], m4_if(m4_quote(ARG_CHECKING_MSG), , [[for --enable-ARG_NAME]], [m4_normalize(ARG_CHECKING_MSG)]))\n@@ -386,5 +391,5 @@\n-  m4_define([ARG_CHECK_AVAILABLE], m4_if(ARG_CHECK_AVAILABLE, , :, ARG_CHECK_AVAILABLE))\n-  m4_define([ARG_IF_GIVEN], m4_if(ARG_IF_GIVEN, , :, ARG_IF_GIVEN))\n-  m4_define([ARG_IF_NOT_GIVEN], m4_if(ARG_IF_NOT_GIVEN, , :, ARG_IF_NOT_GIVEN))\n-  m4_define([ARG_IF_ENABLED], m4_if(ARG_IF_ENABLED, , :, ARG_IF_ENABLED))\n-  m4_define([ARG_IF_DISABLED], m4_if(ARG_IF_DISABLED, , :, ARG_IF_DISABLED))\n+  m4_if(ARG_CHECK_AVAILABLE, , [m4_define([ARG_CHECK_AVAILABLE], [:])])\n+  m4_if(ARG_IF_GIVEN, , [m4_define([ARG_IF_GIVEN], [:])])\n+  m4_if(ARG_IF_NOT_GIVEN, , [m4_define([ARG_IF_NOT_GIVEN], [:])])\n+  m4_if(ARG_IF_ENABLED, , [m4_define([ARG_IF_ENABLED], [:])])\n+  m4_if(ARG_IF_DISABLED, , [m4_define([ARG_IF_DISABLED], [:])])\n@@ -653,1 +658,1 @@\n-  m4_define([ARG_DESC], m4_if(ARG_DESC, , [Give a value for the ARG_NAME feature], m4_normalize(ARG_DESC)))\n+  m4_define([ARG_DESC], m4_if(m4_quote(ARG_DESC), , [[Give a value for the ARG_NAME feature]], [m4_normalize(ARG_DESC)]))\n@@ -656,1 +661,1 @@\n-  m4_define([ARG_CHECKING_MSG], m4_if(ARG_CHECKING_MSG, , [for --with-ARG_NAME], m4_normalize(ARG_CHECKING_MSG)))\n+  m4_define([ARG_CHECKING_MSG], m4_if(m4_quote(ARG_CHECKING_MSG), , [[for --with-ARG_NAME]], [m4_normalize(ARG_CHECKING_MSG)]))\n@@ -662,6 +667,6 @@\n-  m4_define([ARG_CHECK_AVAILABLE], m4_if(ARG_CHECK_AVAILABLE, , :, ARG_CHECK_AVAILABLE))\n-  m4_define([ARG_CHECK_VALUE], m4_if(ARG_CHECK_VALUE, , :, ARG_CHECK_VALUE))\n-  m4_define([ARG_CHECK_FOR_FILES], m4_if(ARG_CHECK_FOR_FILES, , :, ARG_CHECK_FOR_FILES))\n-  m4_define([ARG_IF_AUTO], m4_if(ARG_IF_AUTO, , :, ARG_IF_AUTO))\n-  m4_define([ARG_IF_GIVEN], m4_if(ARG_IF_GIVEN, , :, ARG_IF_GIVEN))\n-  m4_define([ARG_IF_NOT_GIVEN], m4_if(ARG_IF_NOT_GIVEN, , :, ARG_IF_NOT_GIVEN))\n+  m4_if(ARG_CHECK_AVAILABLE, , [m4_define([ARG_CHECK_AVAILABLE], [:])])\n+  m4_if(ARG_CHECK_VALUE, , [m4_define([ARG_CHECK_VALUE], [:])])\n+  m4_if(ARG_CHECK_FOR_FILES, , [m4_define([ARG_CHECK_FOR_FILES], [:])])\n+  m4_if(ARG_IF_AUTO, , [m4_define([ARG_IF_AUTO], [:])])\n+  m4_if(ARG_IF_GIVEN, , [m4_define([ARG_IF_GIVEN], [:])])\n+  m4_if(ARG_IF_NOT_GIVEN, , [m4_define([ARG_IF_NOT_GIVEN], [:])])\n","filename":"make\/autoconf\/util.m4","additions":25,"deletions":20,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-JTREG_VERSION=7.1+1\n+JTREG_VERSION=7.1.1+1\n","filename":"make\/conf\/github-actions.conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1138,1 +1138,1 @@\n-            version: \"7.1\",\n+            version: \"7.1.1\",\n@@ -1140,1 +1140,1 @@\n-            file: \"bundles\/jtreg-7.1+1.zip\",\n+            file: \"bundles\/jtreg-7.1.1+1.zip\",\n","filename":"make\/conf\/jib-profiles.js","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-DEFAULT_VERSION_FEATURE=20\n+DEFAULT_VERSION_FEATURE=21\n@@ -36,2 +36,2 @@\n-DEFAULT_VERSION_DATE=2023-03-21\n-DEFAULT_VERSION_CLASSFILE_MAJOR=64  # \"`$EXPR $DEFAULT_VERSION_FEATURE + 44`\"\n+DEFAULT_VERSION_DATE=2023-09-19\n+DEFAULT_VERSION_CLASSFILE_MAJOR=65  # \"`$EXPR $DEFAULT_VERSION_FEATURE + 44`\"\n@@ -40,2 +40,2 @@\n-DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"19 20\"\n-DEFAULT_JDK_SOURCE_TARGET_VERSION=20\n+DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"19 20 21\"\n+DEFAULT_JDK_SOURCE_TARGET_VERSION=21\n","filename":"make\/conf\/version-numbers.conf","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -283,0 +283,1 @@\n+            <type name=\"mxcjs\" description=\"Ciudad Juárez, Mexico\" alias=\"America\/Ciudad_Juarez\"\/>\n","filename":"make\/data\/cldr\/common\/bcp47\/timezone.xml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2997,0 +2997,12 @@\n+\t\t\t<zone type=\"America\/Bahia_Banderas\">\n+\t\t\t\t<exemplarCity>Bahía de Banderas<\/exemplarCity>\n+\t\t\t<\/zone>\n+\t\t\t<zone type=\"America\/Cancun\">\n+\t\t\t\t<exemplarCity>Cancún<\/exemplarCity>\n+\t\t\t<\/zone>\n+\t\t\t<zone type=\"America\/Ciudad_Juarez\">\n+\t\t\t\t<exemplarCity>Ciudad Juárez<\/exemplarCity>\n+\t\t\t<\/zone>\n+\t\t\t<zone type=\"America\/Merida\">\n+\t\t\t\t<exemplarCity>Mérida<\/exemplarCity>\n+\t\t\t<\/zone>\n","filename":"make\/data\/cldr\/common\/main\/root.xml","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -336,0 +336,6 @@\n+\t\t\t<timezone type=\"America\/Ciudad_Juarez\">\n+\t\t\t\t<usesMetazone to=\"1998-04-05 09:00\" mzone=\"America_Central\"\/>\n+\t\t\t\t<usesMetazone to=\"2022-10-30 08:00\" from=\"1998-04-05 09:00\" mzone=\"Mexico_Pacific\"\/>\n+\t\t\t\t<usesMetazone to=\"2022-11-30 06:00\" from=\"2022-10-30 08:00\" mzone=\"America_Central\"\/>\n+\t\t\t\t<usesMetazone from=\"2022-11-30 06:00\" mzone=\"America_Mountain\"\/>\n+\t\t\t<\/timezone>\n@@ -624,2 +630,1 @@\n-\t\t\t\t<usesMetazone to=\"1995-04-02 06:00\" mzone=\"Atlantic\"\/>\n-\t\t\t\t<usesMetazone to=\"1999-10-31 06:00\" from=\"1995-04-02 06:00\" mzone=\"America_Eastern\"\/>\n+\t\t\t\t<usesMetazone to=\"1999-10-31 06:00\" mzone=\"America_Eastern\"\/>\n","filename":"make\/data\/cldr\/common\/supplemental\/metaZones.xml","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -197,2 +197,0 @@\n-JVM_ExtentLocalCache\n-JVM_SetExtentLocalCache\n@@ -228,0 +226,6 @@\n+\n+# Scoped values\n+JVM_EnsureMaterializedForStackWalk_func\n+JVM_FindScopedValueBindings\n+JVM_ScopedValueCache\n+JVM_SetScopedValueCache\n","filename":"make\/data\/hotspot-symbols\/symbols-unix","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,25 @@\n+\/*\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n@@ -576,0 +601,2 @@\n+            out.write(\"enum PeriodicType {BEGIN_CHUNK, INTERVAL, END_CHUNK};\");\n+            out.write(\"\");\n@@ -578,1 +605,3 @@\n-            out.write(\"  static void requestEvent(JfrEventId id) {\");\n+            out.write(\"  static void requestEvent(JfrEventId id, jlong timestamp, PeriodicType periodicType) {\");\n+            out.write(\"    _timestamp = Ticks(timestamp);\");\n+            out.write(\"    _type = periodicType;\");\n@@ -598,0 +627,4 @@\n+            out.write(\" static Ticks timestamp(void);\");\n+            out.write(\" static Ticks _timestamp;\");\n+            out.write(\" static PeriodicType type(void);\");\n+            out.write(\" static PeriodicType _type;\");\n","filename":"make\/src\/classes\/build\/tools\/jfr\/GenerateJfrFiles.java","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -3635,0 +3635,5 @@\n+    } else if (_method->intrinsic_id() == vmIntrinsicID::_ensureMaterializedForStackWalk) {\n+      \/\/ The NOP here is purely to ensure that eliding a call to\n+      \/\/ JVM_EnsureMaterializedForStackWalk doesn't change the code size.\n+      __ nop();\n+      __ block_comment(\"call JVM_EnsureMaterializedForStackWalk (elided)\");\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -135,0 +135,2 @@\n+          (opcode == Op_CountLeadingZerosV && bt == T_LONG) ||\n+          (opcode == Op_CountTrailingZerosV && bt == T_LONG) ||\n@@ -5675,1 +5677,0 @@\n-  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n@@ -5691,26 +5692,0 @@\n-\/\/ If the PopCountVL is generated by auto-vectorization, the dst basic\n-\/\/ type is T_INT. And once we have unified the type definition for\n-\/\/ Vector API and auto-vectorization, this rule can be merged with\n-\/\/ \"vpopcountL\" rule.\n-\n-instruct vpopcountL_I(vReg dst, vReg src, vReg tmp) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_INT);\n-  match(Set dst (PopCountVL src));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"vpopcountL_I $dst, $src\\t# KILL $tmp\" %}\n-  ins_encode %{\n-    if (UseSVE == 0) {\n-      __ cnt($dst$$FloatRegister, __ T16B, $src$$FloatRegister);\n-      __ uaddlp($dst$$FloatRegister, __ T16B, $dst$$FloatRegister);\n-      __ uaddlp($dst$$FloatRegister, __ T8H, $dst$$FloatRegister);\n-      __ uaddlp($dst$$FloatRegister, __ T4S, $dst$$FloatRegister);\n-      __ xtn($dst$$FloatRegister, __ T2S, $dst$$FloatRegister, __ T2D);\n-    } else {\n-      __ sve_cnt($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n-      __ sve_vector_narrow($dst$$FloatRegister, __ S,\n-                           $dst$$FloatRegister, __ D, $tmp$$FloatRegister);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -5732,1 +5707,1 @@\n-  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n) == T_LONG);\n+  predicate(UseSVE > 0);\n@@ -5897,1 +5872,1 @@\n-instruct vtest_anytrue_neon(iRegINoSp dst, vReg src1, vReg src2, vReg tmp, rFlagsReg cr) %{\n+instruct vtest_anytrue_neon(rFlagsReg cr, vReg src1, vReg src2, vReg tmp) %{\n@@ -5900,3 +5875,3 @@\n-  match(Set dst (VectorTest src1 src2 ));\n-  effect(TEMP tmp, KILL cr);\n-  format %{ \"vtest_anytrue_neon $dst, $src1\\t# KILL $tmp, cr\" %}\n+  match(Set cr (VectorTest src1 src2));\n+  effect(TEMP tmp);\n+  format %{ \"vtest_anytrue_neon $src1\\t# KILL $tmp\" %}\n@@ -5908,3 +5883,2 @@\n-    __ umov($dst$$Register, $tmp$$FloatRegister, __ B, 0);\n-    __ cmpw($dst$$Register, zr);\n-    __ csetw($dst$$Register, Assembler::NE);\n+    __ umov(rscratch1, $tmp$$FloatRegister, __ B, 0);\n+    __ cmpw(rscratch1, zr);\n@@ -5915,1 +5889,1 @@\n-instruct vtest_anytrue_sve(iRegINoSp dst, pReg src1, pReg src2, rFlagsReg cr) %{\n+instruct vtest_anytrue_sve(rFlagsReg cr, pReg src1, pReg src2) %{\n@@ -5918,3 +5892,2 @@\n-  match(Set dst (VectorTest src1 src2));\n-  effect(KILL cr);\n-  format %{ \"vtest_anytrue_sve $dst, $src1\\t# KILL cr\" %}\n+  match(Set cr (VectorTest src1 src2));\n+  format %{ \"vtest_anytrue_sve $src1\" %}\n@@ -5924,1 +5897,0 @@\n-    __ csetw($dst$$Register, Assembler::NE);\n@@ -5931,1 +5903,1 @@\n-instruct vtest_alltrue_neon(iRegINoSp dst, vReg src1, vReg src2, vReg tmp, rFlagsReg cr) %{\n+instruct vtest_alltrue_neon(rFlagsReg cr, vReg src1, vReg src2, vReg tmp) %{\n@@ -5934,3 +5906,3 @@\n-  match(Set dst (VectorTest src1 src2));\n-  effect(TEMP tmp, KILL cr);\n-  format %{ \"vtest_alltrue_neon $dst, $src1\\t# KILL $tmp, cr\" %}\n+  match(Set cr (VectorTest src1 src2));\n+  effect(TEMP tmp);\n+  format %{ \"vtest_alltrue_neon $src1\\t# KILL $tmp\" %}\n@@ -5942,3 +5914,2 @@\n-    __ umov($dst$$Register, $tmp$$FloatRegister, __ B, 0);\n-    __ cmpw($dst$$Register, 0xff);\n-    __ csetw($dst$$Register, Assembler::EQ);\n+    __ umov(rscratch1, $tmp$$FloatRegister, __ B, 0);\n+    __ cmpw(rscratch1, 0xff);\n@@ -5949,1 +5920,1 @@\n-instruct vtest_alltrue_sve(iRegINoSp dst, pReg src1, pReg src2, pReg ptmp, rFlagsReg cr) %{\n+instruct vtest_alltrue_sve(rFlagsReg cr, pReg src1, pReg src2, pReg ptmp) %{\n@@ -5952,3 +5923,3 @@\n-  match(Set dst (VectorTest src1 src2));\n-  effect(TEMP ptmp, KILL cr);\n-  format %{ \"vtest_alltrue_sve $dst, $src1, $src2\\t# KILL $ptmp, cr\" %}\n+  match(Set cr (VectorTest src1 src2));\n+  effect(TEMP ptmp);\n+  format %{ \"vtest_alltrue_sve $src1, $src2\\t# KILL $ptmp\" %}\n@@ -5957,1 +5928,0 @@\n-    __ csetw($dst$$Register, Assembler::EQ);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":22,"deletions":52,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -125,0 +125,2 @@\n+          (opcode == Op_CountLeadingZerosV && bt == T_LONG) ||\n+          (opcode == Op_CountTrailingZerosV && bt == T_LONG) ||\n@@ -4058,1 +4060,0 @@\n-  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n@@ -4074,26 +4075,0 @@\n-\/\/ If the PopCountVL is generated by auto-vectorization, the dst basic\n-\/\/ type is T_INT. And once we have unified the type definition for\n-\/\/ Vector API and auto-vectorization, this rule can be merged with\n-\/\/ \"vpopcountL\" rule.\n-\n-instruct vpopcountL_I(vReg dst, vReg src, vReg tmp) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_INT);\n-  match(Set dst (PopCountVL src));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"vpopcountL_I $dst, $src\\t# KILL $tmp\" %}\n-  ins_encode %{\n-    if (UseSVE == 0) {\n-      __ cnt($dst$$FloatRegister, __ T16B, $src$$FloatRegister);\n-      __ uaddlp($dst$$FloatRegister, __ T16B, $dst$$FloatRegister);\n-      __ uaddlp($dst$$FloatRegister, __ T8H, $dst$$FloatRegister);\n-      __ uaddlp($dst$$FloatRegister, __ T4S, $dst$$FloatRegister);\n-      __ xtn($dst$$FloatRegister, __ T2S, $dst$$FloatRegister, __ T2D);\n-    } else {\n-      __ sve_cnt($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n-      __ sve_vector_narrow($dst$$FloatRegister, __ S,\n-                           $dst$$FloatRegister, __ D, $tmp$$FloatRegister);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -4104,1 +4079,1 @@\n-  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n) == T_LONG);\n+  predicate(UseSVE > 0);\n@@ -4269,1 +4244,1 @@\n-instruct vtest_anytrue_neon(iRegINoSp dst, vReg src1, vReg src2, vReg tmp, rFlagsReg cr) %{\n+instruct vtest_anytrue_neon(rFlagsReg cr, vReg src1, vReg src2, vReg tmp) %{\n@@ -4272,3 +4247,3 @@\n-  match(Set dst (VectorTest src1 src2 ));\n-  effect(TEMP tmp, KILL cr);\n-  format %{ \"vtest_anytrue_neon $dst, $src1\\t# KILL $tmp, cr\" %}\n+  match(Set cr (VectorTest src1 src2));\n+  effect(TEMP tmp);\n+  format %{ \"vtest_anytrue_neon $src1\\t# KILL $tmp\" %}\n@@ -4280,3 +4255,2 @@\n-    __ umov($dst$$Register, $tmp$$FloatRegister, __ B, 0);\n-    __ cmpw($dst$$Register, zr);\n-    __ csetw($dst$$Register, Assembler::NE);\n+    __ umov(rscratch1, $tmp$$FloatRegister, __ B, 0);\n+    __ cmpw(rscratch1, zr);\n@@ -4287,1 +4261,1 @@\n-instruct vtest_anytrue_sve(iRegINoSp dst, pReg src1, pReg src2, rFlagsReg cr) %{\n+instruct vtest_anytrue_sve(rFlagsReg cr, pReg src1, pReg src2) %{\n@@ -4290,3 +4264,2 @@\n-  match(Set dst (VectorTest src1 src2));\n-  effect(KILL cr);\n-  format %{ \"vtest_anytrue_sve $dst, $src1\\t# KILL cr\" %}\n+  match(Set cr (VectorTest src1 src2));\n+  format %{ \"vtest_anytrue_sve $src1\" %}\n@@ -4296,1 +4269,0 @@\n-    __ csetw($dst$$Register, Assembler::NE);\n@@ -4303,1 +4275,1 @@\n-instruct vtest_alltrue_neon(iRegINoSp dst, vReg src1, vReg src2, vReg tmp, rFlagsReg cr) %{\n+instruct vtest_alltrue_neon(rFlagsReg cr, vReg src1, vReg src2, vReg tmp) %{\n@@ -4306,3 +4278,3 @@\n-  match(Set dst (VectorTest src1 src2));\n-  effect(TEMP tmp, KILL cr);\n-  format %{ \"vtest_alltrue_neon $dst, $src1\\t# KILL $tmp, cr\" %}\n+  match(Set cr (VectorTest src1 src2));\n+  effect(TEMP tmp);\n+  format %{ \"vtest_alltrue_neon $src1\\t# KILL $tmp\" %}\n@@ -4314,3 +4286,2 @@\n-    __ umov($dst$$Register, $tmp$$FloatRegister, __ B, 0);\n-    __ cmpw($dst$$Register, 0xff);\n-    __ csetw($dst$$Register, Assembler::EQ);\n+    __ umov(rscratch1, $tmp$$FloatRegister, __ B, 0);\n+    __ cmpw(rscratch1, 0xff);\n@@ -4321,1 +4292,1 @@\n-instruct vtest_alltrue_sve(iRegINoSp dst, pReg src1, pReg src2, pReg ptmp, rFlagsReg cr) %{\n+instruct vtest_alltrue_sve(rFlagsReg cr, pReg src1, pReg src2, pReg ptmp) %{\n@@ -4324,3 +4295,3 @@\n-  match(Set dst (VectorTest src1 src2));\n-  effect(TEMP ptmp, KILL cr);\n-  format %{ \"vtest_alltrue_sve $dst, $src1, $src2\\t# KILL $ptmp, cr\" %}\n+  match(Set cr (VectorTest src1 src2));\n+  effect(TEMP ptmp);\n+  format %{ \"vtest_alltrue_sve $src1, $src2\\t# KILL $ptmp\" %}\n@@ -4329,1 +4300,0 @@\n-    __ csetw($dst$$Register, Assembler::EQ);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":22,"deletions":52,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2438,0 +2438,1 @@\n+      Rm = 0;  \/\/ unreachable\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -55,1 +55,8 @@\n-    masm.align(wordSize);\n+    if (!is_aligned(masm.offset(), wordSize)) {\n+      if (cb->stubs()->maybe_expand_to_ensure_remaining(NativeInstruction::instruction_size) && cb->blob() == NULL) {\n+        ciEnv::current()->record_failure(\"CodeCache is full\");\n+        p_succeeded = false;\n+        return p_succeeded;\n+      }\n+      masm.align(wordSize);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/codeBuffer_aarch64.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -199,5 +199,0 @@\n-void ThawBase::patch_chunk_pd(intptr_t* sp) {\n-  intptr_t* fp = _cont.entryFP();\n-  *(intptr_t**)(sp - frame::sender_sp_offset) = fp;\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationFreezeThaw_aarch64.inline.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n-  VMStorage shuffle_reg = VMS_R19;\n+  VMStorage shuffle_reg = as_VMStorage(r19);\n@@ -182,1 +182,1 @@\n-    allocated_frame_size += 8; \/\/ for address spill\n+    allocated_frame_size += BytesPerWord; \/\/ for address spill\n@@ -185,2 +185,2 @@\n-    locs.set_frame_data(StubLocations::CAPTURED_STATE_MASK, allocated_frame_size);\n-    allocated_frame_size += 8;\n+    locs.set_frame_data(StubLocations::CAPTURED_STATE_BUFFER, allocated_frame_size);\n+    allocated_frame_size += BytesPerWord;\n@@ -227,1 +227,1 @@\n-      } else if(reg.type() == StorageType::VECTOR) {\n+      } else if (reg.type() == StorageType::VECTOR) {\n@@ -241,1 +241,1 @@\n-    if(should_save_return_value) {\n+    if (should_save_return_value) {\n@@ -245,1 +245,1 @@\n-    __ ldr(c_rarg0, Address(sp, locs.data_offset(StubLocations::CAPTURED_STATE_MASK)));\n+    __ ldr(c_rarg0, Address(sp, locs.data_offset(StubLocations::CAPTURED_STATE_BUFFER)));\n@@ -249,1 +249,1 @@\n-    if(should_save_return_value) {\n+    if (should_save_return_value) {\n","filename":"src\/hotspot\/cpu\/aarch64\/downcallLinker_aarch64.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"prims\/vmstorage.inline.hpp\"\n+#include \"prims\/vmstorage.hpp\"\n@@ -51,2 +51,2 @@\n-  parse_register_array(inputStorage, (int) StorageType::INTEGER, abi._integer_argument_registers, as_Register);\n-  parse_register_array(inputStorage, (int) StorageType::VECTOR, abi._vector_argument_registers, as_FloatRegister);\n+  parse_register_array(inputStorage, StorageType::INTEGER, abi._integer_argument_registers, as_Register);\n+  parse_register_array(inputStorage, StorageType::VECTOR, abi._vector_argument_registers, as_FloatRegister);\n@@ -55,2 +55,2 @@\n-  parse_register_array(outputStorage, (int) StorageType::INTEGER, abi._integer_return_registers, as_Register);\n-  parse_register_array(outputStorage, (int) StorageType::VECTOR, abi._vector_return_registers, as_FloatRegister);\n+  parse_register_array(outputStorage, StorageType::INTEGER, abi._integer_return_registers, as_Register);\n+  parse_register_array(outputStorage, StorageType::VECTOR, abi._vector_return_registers, as_FloatRegister);\n@@ -59,2 +59,2 @@\n-  parse_register_array(volatileStorage, (int) StorageType::INTEGER, abi._integer_additional_volatile_registers, as_Register);\n-  parse_register_array(volatileStorage, (int) StorageType::VECTOR, abi._vector_additional_volatile_registers, as_FloatRegister);\n+  parse_register_array(volatileStorage, StorageType::INTEGER, abi._integer_additional_volatile_registers, as_Register);\n+  parse_register_array(volatileStorage, StorageType::VECTOR, abi._vector_additional_volatile_registers, as_FloatRegister);\n","filename":"src\/hotspot\/cpu\/aarch64\/foreignGlobals_aarch64.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -4390,1 +4390,1 @@\n-  decorators = AccessInternal::decorator_fixup(decorators);\n+  decorators = AccessInternal::decorator_fixup(decorators, type);\n@@ -4403,1 +4403,1 @@\n-  decorators = AccessInternal::decorator_fixup(decorators);\n+  decorators = AccessInternal::decorator_fixup(decorators, type);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -166,0 +166,10 @@\n+  \/\/ An all-set mask is used for the alltrue vector test with SVE\n+  static constexpr bool vectortest_needs_second_argument(bool is_alltrue, bool is_predicate) {\n+    return is_predicate && is_alltrue;\n+  }\n+\n+  \/\/ BoolTest mask for vector test intrinsics\n+  static constexpr BoolTest::mask vectortest_mask(bool is_alltrue, bool is_predicate, int vlen) {\n+    return is_alltrue ? BoolTest::eq : BoolTest::ne;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/matcher_aarch64.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -55,3 +55,3 @@\n-    int raw_encoding() const { return this - first(); }\n-    int encoding() const     { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n-    bool is_valid() const    { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n+    constexpr int raw_encoding() const { return this - first(); }\n+    constexpr int     encoding() const { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n+    constexpr bool    is_valid() const { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n@@ -74,1 +74,1 @@\n-  const RegisterImpl* operator->() const { return RegisterImpl::first() + _encoding; }\n+  constexpr const RegisterImpl* operator->() const { return RegisterImpl::first() + _encoding; }\n@@ -178,3 +178,3 @@\n-    int raw_encoding() const { return this - first(); }\n-    int encoding() const     { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n-    bool is_valid() const    { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n+    constexpr int raw_encoding() const { return this - first(); }\n+    constexpr int     encoding() const { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n+    constexpr bool    is_valid() const { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n@@ -195,1 +195,1 @@\n-  const FloatRegisterImpl* operator->() const { return FloatRegisterImpl::first() + _encoding; }\n+  constexpr const FloatRegisterImpl* operator->() const { return FloatRegisterImpl::first() + _encoding; }\n","filename":"src\/hotspot\/cpu\/aarch64\/register_aarch64.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -79,6 +79,0 @@\n-template <ChunkFrames frame_kind>\n-intptr_t* StackChunkFrameStream<frame_kind>::next_sp_for_interpreter_frame() const {\n-  assert_is_interpreted_and_frame_type_mixed();\n-  return (derelativize(frame::interpreter_frame_locals_offset) + 1 >= _end) ? _end : fp() + frame::sender_sp_offset;\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/stackChunkFrameStream_aarch64.inline.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -255,1 +255,1 @@\n-        j_expected_result_reg = VMS_R0;\n+        j_expected_result_reg = as_VMStorage(r0);\n@@ -259,1 +259,1 @@\n-          j_expected_result_reg = VMS_V0;\n+          j_expected_result_reg = as_VMStorage(v0);\n","filename":"src\/hotspot\/cpu\/aarch64\/upcallLinker_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef CPU_AARCH64_VMSTORAGE_AARCH64_INLINE_HPP\n+#define CPU_AARCH64_VMSTORAGE_AARCH64_INLINE_HPP\n+\n+#include <cstdint>\n+\n+#include \"asm\/register.hpp\"\n+\n+\/\/ keep in sync with jdk\/internal\/foreign\/abi\/aarch64\/AArch64Architecture\n+enum class StorageType : int8_t {\n+  INTEGER = 0,\n+  VECTOR = 1,\n+  STACK = 2,\n+  PLACEHOLDER = 3,\n+\/\/ special locations used only by native code\n+  FRAME_DATA = PLACEHOLDER + 1,\n+  INVALID = -1\n+};\n+\n+\/\/ need to define this before constructing VMStorage (below)\n+constexpr inline bool VMStorage::is_reg(StorageType type) {\n+   return type == StorageType::INTEGER || type == StorageType::VECTOR;\n+}\n+constexpr inline StorageType VMStorage::stack_type() { return StorageType::STACK; }\n+constexpr inline StorageType VMStorage::placeholder_type() { return StorageType::PLACEHOLDER; }\n+constexpr inline StorageType VMStorage::frame_data_type() { return StorageType::FRAME_DATA; }\n+\n+constexpr uint16_t REG64_MASK = 0b0000000000000001;\n+constexpr uint16_t V128_MASK  = 0b0000000000000001;\n+\n+inline Register as_Register(VMStorage vms) {\n+  assert(vms.type() == StorageType::INTEGER, \"not the right type\");\n+  return ::as_Register(vms.index());\n+}\n+\n+inline FloatRegister as_FloatRegister(VMStorage vms) {\n+  assert(vms.type() == StorageType::VECTOR, \"not the right type\");\n+  return ::as_FloatRegister(vms.index());\n+}\n+\n+constexpr inline VMStorage as_VMStorage(Register reg) {\n+  return VMStorage::reg_storage(StorageType::INTEGER, REG64_MASK, reg->encoding());\n+}\n+\n+constexpr inline VMStorage as_VMStorage(FloatRegister reg) {\n+  return VMStorage::reg_storage(StorageType::VECTOR, V128_MASK, reg->encoding());\n+}\n+\n+inline VMStorage as_VMStorage(VMReg reg) {\n+  if (reg->is_Register()) {\n+    return as_VMStorage(reg->as_Register());\n+  } else if (reg->is_FloatRegister()) {\n+    return as_VMStorage(reg->as_FloatRegister());\n+  } else if (reg->is_stack()) {\n+    return VMStorage::stack_storage(reg);\n+  } else if (!reg->is_valid()) {\n+    return VMStorage::invalid();\n+  }\n+\n+  ShouldNotReachHere();\n+  return VMStorage::invalid();\n+}\n+\n+#endif \/\/ CPU_AARCH64_VMSTORAGE_AARCH64_INLINE_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/aarch64\/vmstorage_aarch64.hpp","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -1,91 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifndef CPU_AARCH64_VMSTORAGE_AARCH64_INLINE_HPP\n-#define CPU_AARCH64_VMSTORAGE_AARCH64_INLINE_HPP\n-\n-#include <cstdint>\n-\n-#include \"asm\/register.hpp\"\n-#include \"prims\/vmstorageBase.inline.hpp\"\n-\n-\/\/ keep in sync with jdk\/internal\/foreign\/abi\/aarch64\/AArch64Architecture\n-enum class StorageType : int8_t {\n-  INTEGER = 0,\n-  VECTOR = 1,\n-  STACK = 2,\n-  PLACEHOLDER = 3,\n-\/\/ special locations used only by native code\n-  FRAME_DATA = PLACEHOLDER + 1,\n-  INVALID = -1\n-};\n-\n-\/\/ need to define this before constructing VMStorage (below)\n-constexpr inline bool VMStorage::is_reg(StorageType type) {\n-   return type == StorageType::INTEGER || type == StorageType::VECTOR;\n-}\n-constexpr inline StorageType VMStorage::stack_type() { return StorageType::STACK; }\n-constexpr inline StorageType VMStorage::placeholder_type() { return StorageType::PLACEHOLDER; }\n-constexpr inline StorageType VMStorage::frame_data_type() { return StorageType::FRAME_DATA; }\n-\n-constexpr uint16_t REG64_MASK = 0b0000000000000001;\n-constexpr uint16_t V128_MASK  = 0b0000000000000001;\n-\n-constexpr VMStorage VMS_R0 = VMStorage::reg_storage(StorageType::INTEGER, REG64_MASK, 0);\n-constexpr VMStorage VMS_R19 = VMStorage::reg_storage(StorageType::INTEGER, REG64_MASK, 19);\n-constexpr VMStorage VMS_V0 = VMStorage::reg_storage(StorageType::VECTOR, V128_MASK, 0);\n-\n-inline Register as_Register(VMStorage vms) {\n-  assert(vms.type() == StorageType::INTEGER, \"not the right type\");\n-  return ::as_Register(vms.index());\n-}\n-\n-inline FloatRegister as_FloatRegister(VMStorage vms) {\n-  assert(vms.type() == StorageType::VECTOR, \"not the right type\");\n-  return ::as_FloatRegister(vms.index());\n-}\n-\n-inline VMStorage as_VMStorage(Register reg) {\n-  return VMStorage::reg_storage(StorageType::INTEGER, REG64_MASK, reg->encoding());\n-}\n-\n-inline VMStorage as_VMStorage(FloatRegister reg) {\n-  return VMStorage::reg_storage(StorageType::VECTOR, V128_MASK, reg->encoding());\n-}\n-\n-inline VMStorage as_VMStorage(VMReg reg) {\n-  if (reg->is_Register()) {\n-    return as_VMStorage(reg->as_Register());\n-  } else if (reg->is_FloatRegister()) {\n-    return as_VMStorage(reg->as_FloatRegister());\n-  } else if (reg->is_stack()) {\n-    return VMStorage::stack_storage(reg);\n-  } else if (!reg->is_valid()) {\n-    return VMStorage::invalid();\n-  }\n-\n-  ShouldNotReachHere();\n-  return VMStorage::invalid();\n-}\n-\n-#endif \/\/ CPU_AARCH64_VMSTORAGE_AARCH64_INLINE_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/aarch64\/vmstorage_aarch64.inline.hpp","additions":0,"deletions":91,"binary":false,"changes":91,"status":"deleted"},{"patch":"@@ -90,4 +90,0 @@\n-void ThawBase::patch_chunk_pd(intptr_t* sp) {\n-  Unimplemented();\n-}\n-\n","filename":"src\/hotspot\/cpu\/arm\/continuationFreezeThaw_arm.inline.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +35,2 @@\n-                                                bool needs_return_buffer) {\n+                                                bool needs_return_buffer,\n+                                                int captured_state_mask) {\n","filename":"src\/hotspot\/cpu\/arm\/downcallLinker_arm.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/arm\/foreignGlobals_arm.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1646,1 +1646,1 @@\n-  decorators = AccessInternal::decorator_fixup(decorators);\n+  decorators = AccessInternal::decorator_fixup(decorators, type);\n@@ -1658,1 +1658,1 @@\n-  decorators = AccessInternal::decorator_fixup(decorators);\n+  decorators = AccessInternal::decorator_fixup(decorators, type);\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -158,0 +158,10 @@\n+  \/\/ Some architecture needs a helper to check for alltrue vector\n+  static constexpr bool vectortest_needs_second_argument(bool is_alltrue, bool is_predicate) {\n+    return false;\n+  }\n+\n+  \/\/ BoolTest mask for vector test intrinsics\n+  static constexpr BoolTest::mask vectortest_mask(bool is_alltrue, bool is_predicate, int vlen) {\n+    return BoolTest::illegal;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/arm\/matcher_arm.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -70,6 +70,0 @@\n-template <ChunkFrames frame_kind>\n-intptr_t* StackChunkFrameStream<frame_kind>::next_sp_for_interpreter_frame() const {\n-  Unimplemented();\n-  return NULL;\n-}\n-\n","filename":"src\/hotspot\/cpu\/arm\/stackChunkFrameStream_arm.inline.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"prims\/vmstorageBase.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/arm\/vmstorage_arm.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"previous_filename":"src\/hotspot\/cpu\/arm\/vmstorage_arm.inline.hpp","status":"renamed"},{"patch":"@@ -35,1 +35,2 @@\n-                                                bool needs_return_buffer) {\n+                                                bool needs_return_buffer,\n+                                                int captured_state_mask) {\n","filename":"src\/hotspot\/cpu\/ppc\/downcallLinker_ppc.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -360,1 +360,1 @@\n-  decorators = AccessInternal::decorator_fixup(decorators);\n+  decorators = AccessInternal::decorator_fixup(decorators, type);\n@@ -380,1 +380,1 @@\n-  decorators = AccessInternal::decorator_fixup(decorators);\n+  decorators = AccessInternal::decorator_fixup(decorators, type);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -167,0 +167,10 @@\n+  \/\/ Some architecture needs a helper to check for alltrue vector\n+  static constexpr bool vectortest_needs_second_argument(bool is_alltrue, bool is_predicate) {\n+    return false;\n+  }\n+\n+  \/\/ BoolTest mask for vector test intrinsics\n+  static constexpr BoolTest::mask vectortest_mask(bool is_alltrue, bool is_predicate, int vlen) {\n+    return BoolTest::illegal;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/matcher_ppc.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -83,6 +83,0 @@\n-template <ChunkFrames frame_kind>\n-intptr_t* StackChunkFrameStream<frame_kind>::next_sp_for_interpreter_frame() const {\n-  Unimplemented();\n-  return NULL;\n-}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/stackChunkFrameStream_ppc.inline.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"prims\/vmstorageBase.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/ppc\/vmstorage_ppc.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"previous_filename":"src\/hotspot\/cpu\/ppc\/vmstorage_ppc.inline.hpp","status":"renamed"},{"patch":"@@ -46,1 +46,3 @@\n-    __ la(t0, safepoint_pc.target());\n+    int32_t offset;\n+    __ la_patchable(t0, safepoint_pc.target(), offset);\n+    __ addi(t0, t0, offset);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_CodeStubs_riscv.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,1 +43,3 @@\n-    __ la(t0, safepoint_pc.target());\n+    int32_t offset;\n+    __ la_patchable(t0, safepoint_pc.target(), offset);\n+    __ addi(t0, t0, offset);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_safepointPollStubTable_riscv.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,1 +56,8 @@\n-    masm.align(wordSize, NativeCallTrampolineStub::data_offset);\n+    if (!is_aligned(masm.offset() + NativeCallTrampolineStub::data_offset, wordSize)) {\n+      if (cb->stubs()->maybe_expand_to_ensure_remaining(NativeInstruction::instruction_size) && cb->blob() == NULL) {\n+        ciEnv::current()->record_failure(\"CodeCache is full\");\n+        p_succeeded = false;\n+        return p_succeeded;\n+      }\n+      masm.align(wordSize, NativeCallTrampolineStub::data_offset);\n+    }\n","filename":"src\/hotspot\/cpu\/riscv\/codeBuffer_riscv.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -202,5 +202,0 @@\n-void ThawBase::patch_chunk_pd(intptr_t* sp) {\n-  intptr_t* fp = _cont.entryFP();\n-  *(intptr_t**)(sp - 2) = fp;\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/continuationFreezeThaw_riscv.inline.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,1 +36,2 @@\n-                                                bool needs_return_buffer) {\n+                                                bool needs_return_buffer,\n+                                                int captured_state_mask) {\n","filename":"src\/hotspot\/cpu\/riscv\/downcallLinker_riscv.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -213,0 +213,1 @@\n+    li32(zr, 0);\n@@ -1386,1 +1387,1 @@\n-static int patch_imm_in_li32(address branch, int32_t target) {\n+int MacroAssembler::patch_imm_in_li32(address branch, int32_t target) {\n@@ -1450,1 +1451,1 @@\n-static address get_target_of_li32(address insn_addr) {\n+address MacroAssembler::get_target_of_li32(address insn_addr) {\n@@ -1996,1 +1997,1 @@\n-  decorators = AccessInternal::decorator_fixup(decorators);\n+  decorators = AccessInternal::decorator_fixup(decorators, type);\n@@ -2021,1 +2022,1 @@\n-  decorators = AccessInternal::decorator_fixup(decorators);\n+  decorators = AccessInternal::decorator_fixup(decorators, type);\n@@ -3131,0 +3132,3 @@\n+  \/\/ We are always 4-byte aligned here.\n+  assert_alignment(pc());\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -390,0 +390,3 @@\n+  static address get_target_of_li32(address insn_addr);\n+  static int patch_imm_in_li32(address branch, int32_t target);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -164,0 +164,10 @@\n+  \/\/ Some architecture needs a helper to check for alltrue vector\n+  static constexpr bool vectortest_needs_second_argument(bool is_alltrue, bool is_predicate) {\n+    return false;\n+  }\n+\n+  \/\/ BoolTest mask for vector test intrinsics\n+  static constexpr BoolTest::mask vectortest_mask(bool is_alltrue, bool is_predicate, int vlen) {\n+    return BoolTest::illegal;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/matcher_riscv.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -447,0 +447,5 @@\n+int NativePostCallNop::displacement() const {\n+  \/\/ Discard the high 32 bits\n+  return (int)(intptr_t)MacroAssembler::get_target_of_li32(addr_at(4));\n+}\n+\n@@ -448,1 +453,4 @@\n-  \/\/ unsupported for now\n+  assert(diff != 0, \"must be\");\n+  assert(is_lui_to_zr_at(addr_at(4)) && is_addiw_to_zr_at(addr_at(8)), \"must be\");\n+\n+  MacroAssembler::patch_imm_in_li32(addr_at(4), diff);\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+  static bool is_addiw_to_zr_at(address instr) { assert_cond(instr != NULL); return is_addiw_at(instr) && extract_rd(instr) == zr; }\n@@ -82,0 +83,1 @@\n+  static bool is_lui_to_zr_at(address instr)  { assert_cond(instr != NULL); return is_lui_at(instr) && extract_rd(instr) == zr; }\n@@ -557,0 +559,6 @@\n+\/\/ A NativePostCallNop takes the form of three instructions:\n+\/\/     nop; lui zr, hi20; addiw zr, lo12\n+\/\/\n+\/\/ The nop is patchable for a deoptimization trap. The lui and addiw\n+\/\/ instructions execute as nops but have a 20\/12-bit payload in which we\n+\/\/ can store an offset from the initial nop to the nmethod.\n@@ -559,2 +567,8 @@\n-  bool check() const { return is_nop(); }\n-  int displacement() const { return 0; }\n+  bool check() const {\n+    \/\/ Check for two instructions: nop; lui zr, hi20\n+    \/\/ These instructions only ever appear together in a post-call\n+    \/\/ NOP, so it's unnecessary to check that the third instruction is\n+    \/\/ an addiw as well.\n+    return is_nop() && is_lui_to_zr_at(addr_at(4));\n+  }\n+  int displacement() const;\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.hpp","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -79,6 +79,0 @@\n-template <ChunkFrames frame_kind>\n-intptr_t* StackChunkFrameStream<frame_kind>::next_sp_for_interpreter_frame() const {\n-  assert_is_interpreted_and_frame_type_mixed();\n-  return (derelativize(frame::interpreter_frame_locals_offset) + 1 >= _end) ? _end : fp() + frame::sender_sp_offset;\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/stackChunkFrameStream_riscv.inline.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"prims\/vmstorageBase.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/riscv\/vmstorage_riscv.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"previous_filename":"src\/hotspot\/cpu\/riscv\/vmstorage_riscv.inline.hpp","status":"renamed"},{"patch":"@@ -90,4 +90,0 @@\n-void ThawBase::patch_chunk_pd(intptr_t* sp) {\n-  Unimplemented();\n-}\n-\n","filename":"src\/hotspot\/cpu\/s390\/continuationFreezeThaw_s390.inline.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +35,2 @@\n-                                                bool needs_return_buffer) {\n+                                                bool needs_return_buffer,\n+                                                int captured_state_mask) {\n","filename":"src\/hotspot\/cpu\/s390\/downcallLinker_s390.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/s390\/foreignGlobals_s390.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3861,1 +3861,1 @@\n-  decorators = AccessInternal::decorator_fixup(decorators);\n+  decorators = AccessInternal::decorator_fixup(decorators, type);\n@@ -3880,1 +3880,1 @@\n-  decorators = AccessInternal::decorator_fixup(decorators);\n+  decorators = AccessInternal::decorator_fixup(decorators, type);\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -156,0 +156,10 @@\n+  \/\/ Some architecture needs a helper to check for alltrue vector\n+  static constexpr bool vectortest_needs_second_argument(bool is_alltrue, bool is_predicate) {\n+    return false;\n+  }\n+\n+  \/\/ BoolTest mask for vector test intrinsics\n+  static constexpr BoolTest::mask vectortest_mask(bool is_alltrue, bool is_predicate, int vlen) {\n+    return BoolTest::illegal;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/s390\/matcher_s390.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -70,6 +70,0 @@\n-template <ChunkFrames frame_kind>\n-intptr_t* StackChunkFrameStream<frame_kind>::next_sp_for_interpreter_frame() const {\n-  Unimplemented();\n-  return NULL;\n-}\n-\n","filename":"src\/hotspot\/cpu\/s390\/stackChunkFrameStream_s390.inline.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"prims\/vmstorageBase.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/s390\/vmstorage_s390.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"previous_filename":"src\/hotspot\/cpu\/s390\/vmstorage_s390.inline.hpp","status":"renamed"},{"patch":"@@ -1934,1 +1934,1 @@\n-  assert(VM_Version::supports_avx512vl() || VM_Version::supports_f16c(), \"\");\n+  assert(VM_Version::supports_evex() || VM_Version::supports_f16c(), \"\");\n@@ -1941,1 +1941,1 @@\n-  assert(VM_Version::supports_avx512vl(), \"\");\n+  assert(VM_Version::supports_evex(), \"\");\n@@ -1954,0 +1954,11 @@\n+void Assembler::vcvtps2ph(Address dst, XMMRegister src, int imm8, int vector_len) {\n+  assert(VM_Version::supports_evex() || VM_Version::supports_f16c(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/*uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_HVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(dst, 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int8(0x1D);\n+  emit_operand(src, dst, 1);\n+  emit_int8(imm8);\n+}\n+\n@@ -1955,1 +1966,1 @@\n-  assert(VM_Version::supports_avx512vl() || VM_Version::supports_f16c(), \"\");\n+  assert(VM_Version::supports_evex() || VM_Version::supports_f16c(), \"\");\n@@ -1961,0 +1972,10 @@\n+void Assembler::vcvtph2ps(XMMRegister dst, Address src, int vector_len) {\n+  assert(VM_Version::supports_evex() || VM_Version::supports_f16c(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/*uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_HVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0x13);\n+  emit_operand(dst, src, 0);\n+}\n+\n@@ -5429,0 +5450,7 @@\n+void Assembler::vtestps(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x0E, (0xC0 | encode));\n+}\n+\n@@ -5430,2 +5458,2 @@\n-  assert(VM_Version::supports_avx512vlbw(), \"\");\n-  \/\/ Encoding: EVEX.NDS.XXX.66.0F.W0 DB \/r\n+  assert(vector_len == AVX_512bit ? VM_Version::supports_avx512bw() : VM_Version::supports_avx512vlbw(), \"\");\n+  \/\/ Encoding: EVEX.NDS.XXX.66.0F38.W0 DB \/r\n@@ -5435,1 +5463,19 @@\n-  emit_int16((unsigned char)0x26, (0xC0 | encode));\n+  emit_int16(0x26, (0xC0 | encode));\n+}\n+\n+void Assembler::evptestmd(KRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(vector_len == AVX_512bit ? VM_Version::supports_evex() : VM_Version::supports_avx512vl(), \"\");\n+  \/\/ Encoding: EVEX.NDS.XXX.66.0F38.W0 DB \/r\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x27, (0xC0 | encode));\n+}\n+\n+void Assembler::evptestnmd(KRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(vector_len == AVX_512bit ? VM_Version::supports_evex() : VM_Version::supports_avx512vl(), \"\");\n+  \/\/ Encoding: EVEX.NDS.XXX.F3.0F38.W0 DB \/r\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x27, (0xC0 | encode));\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":52,"deletions":6,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -1163,0 +1163,2 @@\n+  void vcvtps2ph(Address dst, XMMRegister src, int imm8, int vector_len);\n+  void vcvtph2ps(XMMRegister dst, Address src, int vector_len);\n@@ -1974,0 +1976,2 @@\n+  void evptestmd(KRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evptestnmd(KRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n@@ -1977,0 +1981,1 @@\n+  void vtestps(XMMRegister dst, XMMRegister src, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2418,52 +2418,26 @@\n-void C2_MacroAssembler::vectortest(int bt, int vlen, XMMRegister src1, XMMRegister src2,\n-                                   XMMRegister vtmp1, XMMRegister vtmp2, KRegister mask) {\n-  switch(vlen) {\n-    case 4:\n-      assert(vtmp1 != xnoreg, \"required.\");\n-      \/\/ Broadcast lower 32 bits to 128 bits before ptest\n-      pshufd(vtmp1, src1, 0x0);\n-      if (bt == BoolTest::overflow) {\n-        assert(vtmp2 != xnoreg, \"required.\");\n-        pshufd(vtmp2, src2, 0x0);\n-      } else {\n-        assert(vtmp2 == xnoreg, \"required.\");\n-        vtmp2 = src2;\n-      }\n-      ptest(vtmp1, vtmp2);\n-     break;\n-    case 8:\n-      assert(vtmp1 != xnoreg, \"required.\");\n-      \/\/ Broadcast lower 64 bits to 128 bits before ptest\n-      pshufd(vtmp1, src1, 0x4);\n-      if (bt == BoolTest::overflow) {\n-        assert(vtmp2 != xnoreg, \"required.\");\n-        pshufd(vtmp2, src2, 0x4);\n-      } else {\n-        assert(vtmp2 == xnoreg, \"required.\");\n-        vtmp2 = src2;\n-      }\n-      ptest(vtmp1, vtmp2);\n-     break;\n-    case 16:\n-      assert((vtmp1 == xnoreg) && (vtmp2 == xnoreg), \"required.\");\n-      ptest(src1, src2);\n-      break;\n-    case 32:\n-      assert((vtmp1 == xnoreg) && (vtmp2 == xnoreg), \"required.\");\n-      vptest(src1, src2, Assembler::AVX_256bit);\n-      break;\n-    case 64:\n-      {\n-        assert((vtmp1 == xnoreg) && (vtmp2 == xnoreg), \"required.\");\n-        evpcmpeqb(mask, src1, src2, Assembler::AVX_512bit);\n-        if (bt == BoolTest::ne) {\n-          ktestql(mask, mask);\n-        } else {\n-          assert(bt == BoolTest::overflow, \"required\");\n-          kortestql(mask, mask);\n-        }\n-      }\n-      break;\n-    default:\n-      assert(false,\"Should not reach here.\");\n-      break;\n+void C2_MacroAssembler::vectortest(BasicType bt, XMMRegister src1, XMMRegister src2, XMMRegister vtmp, int vlen_in_bytes) {\n+  assert(vlen_in_bytes <= 32, \"\");\n+  int esize = type2aelembytes(bt);\n+  if (vlen_in_bytes == 32) {\n+    assert(vtmp == xnoreg, \"required.\");\n+    if (esize >= 4) {\n+      vtestps(src1, src2, AVX_256bit);\n+    } else {\n+      vptest(src1, src2, AVX_256bit);\n+    }\n+    return;\n+  }\n+  if (vlen_in_bytes < 16) {\n+    \/\/ Duplicate the lower part to fill the whole register,\n+    \/\/ Don't need to do so for src2\n+    assert(vtmp != xnoreg, \"required\");\n+    int shuffle_imm = (vlen_in_bytes == 4) ? 0x00 : 0x04;\n+    pshufd(vtmp, src1, shuffle_imm);\n+  } else {\n+    assert(vtmp == xnoreg, \"required\");\n+    vtmp = src1;\n+  }\n+  if (esize >= 4 && VM_Version::supports_avx()) {\n+    vtestps(vtmp, src2, AVX_128bit);\n+  } else {\n+    ptest(vtmp, src2);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":26,"deletions":52,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -141,2 +141,1 @@\n-  void vectortest(int bt, int vlen, XMMRegister src1, XMMRegister src2,\n-                  XMMRegister vtmp1 = xnoreg, XMMRegister vtmp2 = xnoreg, KRegister mask = knoreg);\n+  void vectortest(BasicType bt, XMMRegister src1, XMMRegister src2, XMMRegister vtmp, int vlen_in_bytes);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -202,5 +202,0 @@\n-void ThawBase::patch_chunk_pd(intptr_t* sp) {\n-  intptr_t* fp = _cont.entryFP();\n-  *(intptr_t**)(sp - frame::sender_sp_offset) = fp;\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/continuationFreezeThaw_x86.inline.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,1 +33,2 @@\n-                                                bool needs_return_buffer) {\n+                                                bool needs_return_buffer,\n+                                                int captured_state_mask) {\n","filename":"src\/hotspot\/cpu\/x86\/downcallLinker_x86_32.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-  VMStorage shuffle_reg = VMS_RBX;\n+  VMStorage shuffle_reg = as_VMStorage(rbx);\n@@ -180,1 +180,1 @@\n-    allocated_frame_size += 8;\n+    allocated_frame_size += BytesPerWord;\n@@ -183,2 +183,2 @@\n-    locs.set_frame_data(StubLocations::CAPTURED_STATE_MASK, allocated_frame_size);\n-    allocated_frame_size += 8;\n+    locs.set_frame_data(StubLocations::CAPTURED_STATE_BUFFER, allocated_frame_size);\n+    allocated_frame_size += BytesPerWord;\n@@ -242,1 +242,1 @@\n-    if(should_save_return_value) {\n+    if (should_save_return_value) {\n@@ -246,1 +246,1 @@\n-    __ movptr(c_rarg0, Address(rsp, locs.data_offset(StubLocations::CAPTURED_STATE_MASK)));\n+    __ movptr(c_rarg0, Address(rsp, locs.data_offset(StubLocations::CAPTURED_STATE_BUFFER)));\n@@ -255,1 +255,1 @@\n-    if(should_save_return_value) {\n+    if (should_save_return_value) {\n@@ -307,1 +307,1 @@\n-  if(should_save_return_value) {\n+  if (should_save_return_value) {\n@@ -319,1 +319,1 @@\n-  if(should_save_return_value) {\n+  if (should_save_return_value) {\n@@ -332,1 +332,1 @@\n-  if(should_save_return_value) {\n+  if (should_save_return_value) {\n@@ -343,1 +343,1 @@\n-  if(should_save_return_value) {\n+  if (should_save_return_value) {\n","filename":"src\/hotspot\/cpu\/x86\/downcallLinker_x86_64.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -48,2 +48,2 @@\n-  parse_register_array(inputStorage, (int) StorageType::INTEGER, abi._integer_argument_registers, as_Register);\n-  parse_register_array(inputStorage, (int) StorageType::VECTOR, abi._vector_argument_registers, as_XMMRegister);\n+  parse_register_array(inputStorage, StorageType::INTEGER, abi._integer_argument_registers, as_Register);\n+  parse_register_array(inputStorage, StorageType::VECTOR, abi._vector_argument_registers, as_XMMRegister);\n@@ -52,3 +52,3 @@\n-  parse_register_array(outputStorage, (int) StorageType::INTEGER, abi._integer_return_registers, as_Register);\n-  parse_register_array(outputStorage, (int) StorageType::VECTOR, abi._vector_return_registers, as_XMMRegister);\n-  objArrayOop subarray = oop_cast<objArrayOop>(outputStorage->obj_at(((int) StorageType::X87)));\n+  parse_register_array(outputStorage, StorageType::INTEGER, abi._integer_return_registers, as_Register);\n+  parse_register_array(outputStorage, StorageType::VECTOR, abi._vector_return_registers, as_XMMRegister);\n+  objArrayOop subarray = oop_cast<objArrayOop>(outputStorage->obj_at((int) StorageType::X87));\n@@ -58,2 +58,2 @@\n-  parse_register_array(volatileStorage, (int) StorageType::INTEGER, abi._integer_additional_volatile_registers, as_Register);\n-  parse_register_array(volatileStorage, (int) StorageType::VECTOR, abi._vector_additional_volatile_registers, as_XMMRegister);\n+  parse_register_array(volatileStorage, StorageType::INTEGER, abi._integer_additional_volatile_registers, as_Register);\n+  parse_register_array(volatileStorage, StorageType::VECTOR, abi._vector_additional_volatile_registers, as_XMMRegister);\n","filename":"src\/hotspot\/cpu\/x86\/foreignGlobals_x86_64.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -5111,1 +5111,1 @@\n-  decorators = AccessInternal::decorator_fixup(decorators);\n+  decorators = AccessInternal::decorator_fixup(decorators, type);\n@@ -5123,1 +5123,1 @@\n-  decorators = AccessInternal::decorator_fixup(decorators);\n+  decorators = AccessInternal::decorator_fixup(decorators, type);\n@@ -9016,20 +9016,0 @@\n-void MacroAssembler::anytrue(Register dst, uint masklen, KRegister src1, KRegister src2) {\n-   masklen = masklen < 8 ? 8 : masklen;\n-   ktest(masklen, src1, src2);\n-   setb(Assembler::notZero, dst);\n-   movzbl(dst, dst);\n-}\n-\n-void MacroAssembler::alltrue(Register dst, uint masklen, KRegister src1, KRegister src2, KRegister kscratch) {\n-  if (masklen < 8) {\n-    knotbl(kscratch, src2);\n-    kortestbl(src1, kscratch);\n-    setb(Assembler::carrySet, dst);\n-    movzbl(dst, dst);\n-  } else {\n-    ktest(masklen, src1, src2);\n-    setb(Assembler::carrySet, dst);\n-    movzbl(dst, dst);\n-  }\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":2,"deletions":22,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1771,3 +1771,0 @@\n-  void alltrue(Register dst, uint masklen, KRegister src1, KRegister src2, KRegister kscratch);\n-  void anytrue(Register dst, uint masklen, KRegister src, KRegister kscratch);\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -186,0 +186,19 @@\n+  \/\/ Without predicated input, an all-one vector is needed for the alltrue vector test\n+  static constexpr bool vectortest_needs_second_argument(bool is_alltrue, bool is_predicate) {\n+    return is_alltrue && !is_predicate;\n+  }\n+\n+  \/\/ BoolTest mask for vector test intrinsics\n+  static constexpr BoolTest::mask vectortest_mask(bool is_alltrue, bool is_predicate, int vlen) {\n+    if (!is_alltrue) {\n+      return BoolTest::ne;\n+    }\n+    if (!is_predicate) {\n+      return BoolTest::lt;\n+    }\n+    if ((vlen == 8 && !VM_Version::supports_avx512dq()) || vlen < 8) {\n+      return BoolTest::eq;\n+    }\n+    return BoolTest::lt;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/matcher_x86.hpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -59,3 +59,3 @@\n-    int   raw_encoding() const      { return this - first(); }\n-    int   encoding() const          { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n-    bool  is_valid() const          { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n+    constexpr int   raw_encoding() const { return this - first(); }\n+    constexpr int       encoding() const { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n+    constexpr bool      is_valid() const { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n@@ -77,1 +77,1 @@\n-  const RegisterImpl* operator->() const { return RegisterImpl::first() + _encoding; }\n+  constexpr const RegisterImpl* operator->() const { return RegisterImpl::first() + _encoding; }\n@@ -205,3 +205,3 @@\n-    int raw_encoding() const  { return this - first(); }\n-    int   encoding() const    { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n-    bool  is_valid() const    { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n+    constexpr int raw_encoding() const { return this - first(); }\n+    constexpr int     encoding() const { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n+    constexpr bool    is_valid() const { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n@@ -222,1 +222,1 @@\n-  const XMMRegisterImpl* operator->() const { return XMMRegisterImpl::first() + _encoding; }\n+  constexpr const XMMRegisterImpl* operator->() const { return XMMRegisterImpl::first() + _encoding; }\n","filename":"src\/hotspot\/cpu\/x86\/register_x86.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -79,6 +79,0 @@\n-template <ChunkFrames frame_kind>\n-intptr_t* StackChunkFrameStream<frame_kind>::next_sp_for_interpreter_frame() const {\n-  assert_is_interpreted_and_frame_type_mixed();\n-  return (derelativize(frame::interpreter_frame_locals_offset) + 1 >= _end) ? _end : fp() + frame::sender_sp_offset;\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/stackChunkFrameStream_x86.inline.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -178,1 +178,1 @@\n-  VMStorage shuffle_reg = VMS_RBX;\n+  VMStorage shuffle_reg = as_VMStorage(rbx);\n@@ -309,1 +309,1 @@\n-        j_expected_result_reg = VMS_RAX;\n+        j_expected_result_reg = as_VMStorage(rax);\n@@ -313,1 +313,1 @@\n-          j_expected_result_reg = VMS_XMM0;\n+          j_expected_result_reg = as_VMStorage(xmm0);\n","filename":"src\/hotspot\/cpu\/x86\/upcallLinker_x86_64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -959,0 +959,1 @@\n+    _features &= ~CPU_F16C;\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef CPU_X86_VMSTORAGE_X86_INLINE_HPP\n+#define CPU_X86_VMSTORAGE_X86_INLINE_HPP\n+\n+#include <cstdint>\n+\n+#include \"asm\/register.hpp\"\n+#include \"code\/vmreg.inline.hpp\"\n+\n+\/\/ keep in sync with jdk\/internal\/foreign\/abi\/x64\/X86_64Architecture\n+enum class StorageType : int8_t {\n+  INTEGER = 0,\n+  VECTOR = 1,\n+  X87 = 2,\n+  STACK = 3,\n+  PLACEHOLDER = 4,\n+\/\/ special locations used only by native code\n+  FRAME_DATA = PLACEHOLDER + 1,\n+  INVALID = -1\n+};\n+\n+\/\/ need to define this before constructing VMStorage (below)\n+constexpr inline bool VMStorage::is_reg(StorageType type) {\n+   return type == StorageType::INTEGER || type == StorageType::VECTOR || type == StorageType::X87;\n+}\n+constexpr inline StorageType VMStorage::stack_type() { return StorageType::STACK; }\n+constexpr inline StorageType VMStorage::placeholder_type() { return StorageType::PLACEHOLDER; }\n+constexpr inline StorageType VMStorage::frame_data_type() { return StorageType::FRAME_DATA; }\n+\n+constexpr uint16_t REG64_MASK = 0b0000000000001111;\n+constexpr uint16_t XMM_MASK   = 0b0000000000000001;\n+\n+inline Register as_Register(VMStorage vms) {\n+  assert(vms.type() == StorageType::INTEGER, \"not the right type\");\n+  return ::as_Register(vms.index());\n+}\n+\n+inline XMMRegister as_XMMRegister(VMStorage vms) {\n+  assert(vms.type() == StorageType::VECTOR, \"not the right type\");\n+  return ::as_XMMRegister(vms.index());\n+}\n+\n+inline VMReg as_VMReg(VMStorage vms) {\n+  switch (vms.type()) {\n+    case StorageType::INTEGER: return as_Register(vms)->as_VMReg();\n+    case StorageType::VECTOR:  return as_XMMRegister(vms)->as_VMReg();\n+    case StorageType::STACK: {\n+      assert((vms.index() % VMRegImpl::stack_slot_size) == 0, \"can not represent as VMReg\");\n+      return VMRegImpl::stack2reg(vms.index() \/ VMRegImpl::stack_slot_size);\n+    }\n+    default: ShouldNotReachHere(); return VMRegImpl::Bad();\n+  }\n+}\n+\n+constexpr inline VMStorage as_VMStorage(Register reg) {\n+  return VMStorage::reg_storage(StorageType::INTEGER, REG64_MASK, reg->encoding());\n+}\n+\n+constexpr inline VMStorage as_VMStorage(XMMRegister reg) {\n+  return VMStorage::reg_storage(StorageType::VECTOR, XMM_MASK, reg->encoding());\n+}\n+\n+inline VMStorage as_VMStorage(VMReg reg) {\n+  if (reg->is_Register()) {\n+    return as_VMStorage(reg->as_Register());\n+  } else if (reg->is_XMMRegister()) {\n+    return as_VMStorage(reg->as_XMMRegister());\n+  } else if (reg->is_stack()) {\n+    return VMStorage::stack_storage(reg);\n+  } else if (!reg->is_valid()) {\n+    return VMStorage::invalid();\n+  }\n+\n+  ShouldNotReachHere();\n+  return VMStorage::invalid();\n+}\n+\n+#endif \/\/ CPU_X86_VMSTORAGE_X86_INLINE_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/x86\/vmstorage_x86.hpp","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -1,105 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifndef CPU_X86_VMSTORAGE_X86_INLINE_HPP\n-#define CPU_X86_VMSTORAGE_X86_INLINE_HPP\n-\n-#include <cstdint>\n-\n-#include \"asm\/register.hpp\"\n-#include \"code\/vmreg.inline.hpp\"\n-#include \"prims\/vmstorageBase.inline.hpp\"\n-\n-\/\/ keep in sync with jdk\/internal\/foreign\/abi\/x64\/X86_64Architecture\n-enum class StorageType : int8_t {\n-  INTEGER = 0,\n-  VECTOR = 1,\n-  X87 = 2,\n-  STACK = 3,\n-  PLACEHOLDER = 4,\n-\/\/ special locations used only by native code\n-  FRAME_DATA = PLACEHOLDER + 1,\n-  INVALID = -1\n-};\n-\n-\/\/ need to define this before constructing VMStorage (below)\n-constexpr inline bool VMStorage::is_reg(StorageType type) {\n-   return type == StorageType::INTEGER || type == StorageType::VECTOR || type == StorageType::X87;\n-}\n-constexpr inline StorageType VMStorage::stack_type() { return StorageType::STACK; }\n-constexpr inline StorageType VMStorage::placeholder_type() { return StorageType::PLACEHOLDER; }\n-constexpr inline StorageType VMStorage::frame_data_type() { return StorageType::FRAME_DATA; }\n-\n-constexpr uint16_t REG64_MASK = 0b0000000000001111;\n-constexpr uint16_t XMM_MASK   = 0b0000000000000001;\n-\n-constexpr VMStorage VMS_RAX = VMStorage::reg_storage(StorageType::INTEGER, REG64_MASK, 0);\n-constexpr VMStorage VMS_RBX = VMStorage::reg_storage(StorageType::INTEGER, REG64_MASK, 3);\n-constexpr VMStorage VMS_XMM0 = VMStorage::reg_storage(StorageType::VECTOR, XMM_MASK, 0);\n-\n-inline Register as_Register(VMStorage vms) {\n-  assert(vms.type() == StorageType::INTEGER, \"not the right type\");\n-  return ::as_Register(vms.index());\n-}\n-\n-inline XMMRegister as_XMMRegister(VMStorage vms) {\n-  assert(vms.type() == StorageType::VECTOR, \"not the right type\");\n-  return ::as_XMMRegister(vms.index());\n-}\n-\n-inline VMReg as_VMReg(VMStorage vms) {\n-  switch (vms.type()) {\n-    case StorageType::INTEGER: return as_Register(vms)->as_VMReg();\n-    case StorageType::VECTOR:  return as_XMMRegister(vms)->as_VMReg();\n-    case StorageType::STACK: {\n-      assert((vms.index() % VMRegImpl::stack_slot_size) == 0, \"can not represent as VMReg\");\n-      return VMRegImpl::stack2reg(vms.index() \/ VMRegImpl::stack_slot_size);\n-    }\n-    default: ShouldNotReachHere(); return VMRegImpl::Bad();\n-  }\n-}\n-\n-inline VMStorage as_VMStorage(Register reg) {\n-  return VMStorage::reg_storage(StorageType::INTEGER, REG64_MASK, reg->encoding());\n-}\n-\n-inline VMStorage as_VMStorage(XMMRegister reg) {\n-  return VMStorage::reg_storage(StorageType::VECTOR, XMM_MASK, reg->encoding());\n-}\n-\n-inline VMStorage as_VMStorage(VMReg reg) {\n-  if (reg->is_Register()) {\n-    return as_VMStorage(reg->as_Register());\n-  } else if (reg->is_XMMRegister()) {\n-    return as_VMStorage(reg->as_XMMRegister());\n-  } else if (reg->is_stack()) {\n-    return VMStorage::stack_storage(reg);\n-  } else if (!reg->is_valid()) {\n-    return VMStorage::invalid();\n-  }\n-\n-  ShouldNotReachHere();\n-  return VMStorage::invalid();\n-}\n-\n-#endif \/\/ CPU_X86_VMSTORAGE_X86_INLINE_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/x86\/vmstorage_x86.inline.hpp","additions":0,"deletions":105,"binary":false,"changes":105,"status":"deleted"},{"patch":"@@ -1690,0 +1690,6 @@\n+    case Op_VectorCastF2HF:\n+    case Op_VectorCastHF2F:\n+      if (!VM_Version::supports_f16c() && !VM_Version::supports_evex()) {\n+        return false;\n+      }\n+      break;\n@@ -1847,2 +1853,0 @@\n-      } else if (size_in_bits == 512 && (VM_Version::supports_avx512bw() == false)) {\n-        return false; \/\/ Implementation limitation\n@@ -1904,0 +1908,8 @@\n+    case Op_VectorCastF2HF:\n+    case Op_VectorCastHF2F:\n+      if (!VM_Version::supports_f16c() &&\n+         ((!VM_Version::supports_evex() ||\n+         ((size_in_bits != 512) && !VM_Version::supports_avx512vl())))) {\n+        return false;\n+      }\n+      break;\n@@ -3676,0 +3688,20 @@\n+instruct vconvF2HF(vec dst, vec src) %{\n+  match(Set dst (VectorCastF2HF src));\n+  format %{ \"vector_conv_F2HF $dst $src\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    __ vcvtps2ph($dst$$XMMRegister, $src$$XMMRegister, 0x04, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vconvF2HF_mem_reg(memory mem, vec src) %{\n+  match(Set mem (StoreVector mem (VectorCastF2HF src)));\n+  format %{ \"vcvtps2ph $mem,$src\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    __ vcvtps2ph($mem$$Address, $src$$XMMRegister, 0x04, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -3686,0 +3718,21 @@\n+instruct vconvHF2F_reg_mem(vec dst, memory mem) %{\n+  match(Set dst (VectorCastHF2F (LoadVector mem)));\n+  format %{ \"vcvtph2ps $dst,$mem\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vcvtph2ps($dst$$XMMRegister, $mem$$Address, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vconvHF2F(vec dst, vec src) %{\n+  match(Set dst (VectorCastHF2F src));\n+  ins_cost(125);\n+  format %{ \"vector_conv_HF2F $dst,$src\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vcvtph2ps($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -7996,8 +8049,5 @@\n-instruct vptest_alltrue_lt16(rRegI dst, legVec src1, legVec src2, legVec vtmp1, legVec vtmp2, rFlagsReg cr) %{\n-  predicate(!VM_Version::supports_avx512bwdq() &&\n-            Matcher::vector_length_in_bytes(n->in(1)) >= 4 &&\n-            Matcher::vector_length_in_bytes(n->in(1)) < 16 &&\n-            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow);\n-  match(Set dst (VectorTest src1 src2 ));\n-  effect(TEMP vtmp1, TEMP vtmp2, KILL cr);\n-  format %{ \"vptest_alltrue_lt16 $dst,$src1, $src2\\t! using $vtmp1, $vtmp2 and $cr as TEMP\" %}\n+instruct vptest_lt16(rFlagsRegU cr, legVec src1, legVec src2, legVec vtmp) %{\n+  predicate(Matcher::vector_length_in_bytes(n->in(1)) < 16);\n+  match(Set cr (VectorTest src1 src2));\n+  effect(TEMP vtmp);\n+  format %{ \"vptest_lt16  $src1, $src2\\t! using $vtmp as TEMP\" %}\n@@ -8005,0 +8055,1 @@\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src1);\n@@ -8006,3 +8057,1 @@\n-    __ vectortest(BoolTest::overflow, vlen, $src1$$XMMRegister, $src2$$XMMRegister, $vtmp1$$XMMRegister, $vtmp2$$XMMRegister);\n-    __ setb(Assembler::carrySet, $dst$$Register);\n-    __ movzbl($dst$$Register, $dst$$Register);\n+    __ vectortest(bt, $src1$$XMMRegister, $src2$$XMMRegister, $vtmp$$XMMRegister, vlen);\n@@ -8013,8 +8062,4 @@\n-instruct vptest_alltrue_ge16(rRegI dst, legVec src1, legVec src2, rFlagsReg cr) %{\n-  predicate(!VM_Version::supports_avx512bwdq() &&\n-            Matcher::vector_length_in_bytes(n->in(1)) >= 16 &&\n-            Matcher::vector_length_in_bytes(n->in(1)) <  64 &&\n-            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow);\n-  match(Set dst (VectorTest src1 src2 ));\n-  effect(KILL cr);\n-  format %{ \"vptest_alltrue_ge16  $dst,$src1, $src2\\t! using $cr as TEMP\" %}\n+instruct vptest_ge16(rFlagsRegU cr, legVec src1, legVec src2) %{\n+  predicate(Matcher::vector_length_in_bytes(n->in(1)) >= 16);\n+  match(Set cr (VectorTest src1 src2));\n+  format %{ \"vptest_ge16  $src1, $src2\\n\\t\" %}\n@@ -8022,0 +8067,1 @@\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src1);\n@@ -8023,3 +8069,1 @@\n-    __ vectortest(BoolTest::overflow, vlen, $src1$$XMMRegister, $src2$$XMMRegister, xnoreg, xnoreg, knoreg);\n-    __ setb(Assembler::carrySet, $dst$$Register);\n-    __ movzbl($dst$$Register, $dst$$Register);\n+    __ vectortest(bt, $src1$$XMMRegister, $src2$$XMMRegister, xnoreg, vlen);\n@@ -8030,27 +8074,7 @@\n-instruct vptest_alltrue_lt8_evex(rRegI dst, kReg src1, kReg src2, kReg kscratch, rFlagsReg cr) %{\n-  predicate(VM_Version::supports_avx512bwdq() &&\n-            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow &&\n-            n->in(1)->bottom_type()->isa_vectmask() &&\n-            Matcher::vector_length(n->in(1)) < 8);\n-  match(Set dst (VectorTest src1 src2));\n-  effect(KILL cr, TEMP kscratch);\n-  format %{ \"vptest_alltrue_lt8_evex $dst,$src1,$src2\\t! using $cr as TEMP\" %}\n-  ins_encode %{\n-    const MachNode* mask1 = static_cast<const MachNode*>(this->in(this->operand_index($src1)));\n-    const MachNode* mask2 = static_cast<const MachNode*>(this->in(this->operand_index($src2)));\n-    assert(0 == Type::cmp(mask1->bottom_type(), mask2->bottom_type()), \"\");\n-    uint masklen = Matcher::vector_length(this, $src1);\n-    __ alltrue($dst$$Register, masklen, $src1$$KRegister, $src2$$KRegister, $kscratch$$KRegister);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-\n-instruct vptest_alltrue_ge8_evex(rRegI dst, kReg src1, kReg src2, rFlagsReg cr) %{\n-  predicate(VM_Version::supports_avx512bwdq() &&\n-            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow &&\n-            n->in(1)->bottom_type()->isa_vectmask() &&\n-            Matcher::vector_length(n->in(1)) >= 8);\n-  match(Set dst (VectorTest src1 src2));\n-  effect(KILL cr);\n-  format %{ \"vptest_alltrue_ge8_evex $dst,$src1,$src2\\t! using $cr as TEMP\" %}\n+instruct ktest_alltrue_le8(rFlagsRegU cr, kReg src1, kReg src2, rRegI tmp) %{\n+  predicate((Matcher::vector_length(n->in(1)) < 8 ||\n+             (Matcher::vector_length(n->in(1)) == 8 && !VM_Version::supports_avx512dq())) &&\n+            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow);\n+  match(Set cr (VectorTest src1 src2));\n+  effect(TEMP tmp);\n+  format %{ \"ktest_alltrue_le8  $src1, $src2\\t! using $tmp as TEMP\" %}\n@@ -8058,3 +8082,0 @@\n-    const MachNode* mask1 = static_cast<const MachNode*>(this->in(this->operand_index($src1)));\n-    const MachNode* mask2 = static_cast<const MachNode*>(this->in(this->operand_index($src2)));\n-    assert(0 == Type::cmp(mask1->bottom_type(), mask2->bottom_type()), \"\");\n@@ -8062,19 +8083,3 @@\n-    __ alltrue($dst$$Register, masklen, $src1$$KRegister, $src2$$KRegister, knoreg);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-\n-instruct vptest_anytrue_lt16(rRegI dst, legVec src1, legVec src2, legVec vtmp, rFlagsReg cr) %{\n-  predicate(!VM_Version::supports_avx512bwdq() &&\n-            Matcher::vector_length_in_bytes(n->in(1)) >= 4 &&\n-            Matcher::vector_length_in_bytes(n->in(1)) < 16 &&\n-            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::ne);\n-  match(Set dst (VectorTest src1 src2 ));\n-  effect(TEMP vtmp, KILL cr);\n-  format %{ \"vptest_anytrue_lt16 $dst,$src1,$src2\\t! using $vtmp, $cr as TEMP\" %}\n-  ins_encode %{\n-    int vlen = Matcher::vector_length_in_bytes(this, $src1);\n-    __ vectortest(BoolTest::ne, vlen, $src1$$XMMRegister, $src2$$XMMRegister, $vtmp$$XMMRegister);\n-    __ setb(Assembler::notZero, $dst$$Register);\n-    __ movzbl($dst$$Register, $dst$$Register);\n+    __ kmovwl($tmp$$Register, $src1$$KRegister);\n+    __ andl($tmp$$Register, (1 << masklen) - 1);\n+    __ cmpl($tmp$$Register, (1 << masklen) - 1);\n@@ -8085,4 +8090,3 @@\n-instruct vptest_anytrue_ge16(rRegI dst, legVec src1, legVec src2, rFlagsReg cr) %{\n-  predicate(!VM_Version::supports_avx512bwdq() &&\n-            Matcher::vector_length_in_bytes(n->in(1)) >= 16 &&\n-            Matcher::vector_length_in_bytes(n->in(1)) < 64  &&\n+instruct ktest_anytrue_le8(rFlagsRegU cr, kReg src1, kReg src2, rRegI tmp) %{\n+  predicate((Matcher::vector_length(n->in(1)) < 8 ||\n+             (Matcher::vector_length(n->in(1)) == 8 && !VM_Version::supports_avx512dq())) &&\n@@ -8090,50 +8094,3 @@\n-  match(Set dst (VectorTest src1 src2 ));\n-  effect(KILL cr);\n-  format %{ \"vptest_anytrue_ge16 $dst,$src1,$src2\\t! using $cr as TEMP\" %}\n-  ins_encode %{\n-    int vlen = Matcher::vector_length_in_bytes(this, $src1);\n-    __ vectortest(BoolTest::ne, vlen, $src1$$XMMRegister, $src2$$XMMRegister, xnoreg, xnoreg, knoreg);\n-    __ setb(Assembler::notZero, $dst$$Register);\n-    __ movzbl($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct vptest_anytrue_evex(rRegI dst, kReg src1, kReg src2, rFlagsReg cr) %{\n-  predicate(VM_Version::supports_avx512bwdq() &&\n-            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::ne);\n-  match(Set dst (VectorTest src1 src2));\n-  effect(KILL cr);\n-  format %{ \"vptest_anytrue_lt8_evex $dst,$src1,$src2\\t! using $cr as TEMP\" %}\n-  ins_encode %{\n-    const MachNode* mask1 = static_cast<const MachNode*>(this->in(this->operand_index($src1)));\n-    const MachNode* mask2 = static_cast<const MachNode*>(this->in(this->operand_index($src2)));\n-    assert(0 == Type::cmp(mask1->bottom_type(), mask2->bottom_type()), \"\");\n-    uint  masklen = Matcher::vector_length(this, $src1);\n-    __ anytrue($dst$$Register, masklen, $src1$$KRegister, $src2$$KRegister);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct cmpvptest_anytrue_lt16(rFlagsReg cr, legVec src1, legVec src2, immI_0 zero, legVec vtmp) %{\n-  predicate(!VM_Version::supports_avx512bwdq() &&\n-            Matcher::vector_length_in_bytes(n->in(1)->in(1)) >= 4 &&\n-            Matcher::vector_length_in_bytes(n->in(1)->in(1)) < 16 &&\n-            static_cast<const VectorTestNode*>(n->in(1))->get_predicate() == BoolTest::ne);\n-  match(Set cr (CmpI (VectorTest src1 src2) zero));\n-  effect(TEMP vtmp);\n-  format %{ \"cmpvptest_anytrue_lt16 $src1,$src2\\t! using $vtmp as TEMP\" %}\n-  ins_encode %{\n-    int vlen = Matcher::vector_length_in_bytes(this, $src1);\n-    __ vectortest(BoolTest::ne, vlen, $src1$$XMMRegister, $src2$$XMMRegister, $vtmp$$XMMRegister);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct cmpvptest_anytrue_ge16(rFlagsReg cr, legVec src1, legVec src2, immI_0 zero) %{\n-  predicate(!VM_Version::supports_avx512bwdq() &&\n-            Matcher::vector_length_in_bytes(n->in(1)->in(1)) >= 16 &&\n-            Matcher::vector_length_in_bytes(n->in(1)->in(1)) <  64 &&\n-            static_cast<const VectorTestNode*>(n->in(1))->get_predicate() == BoolTest::ne);\n-  match(Set cr (CmpI (VectorTest src1 src2) zero));\n-  format %{ \"cmpvptest_anytrue_ge16 $src1,$src2\\t!\" %}\n+  match(Set cr (VectorTest src1 src2));\n+  effect(TEMP tmp);\n+  format %{ \"ktest_anytrue_le8  $src1, $src2\\t! using $tmp as TEMP\" %}\n@@ -8141,2 +8098,3 @@\n-    int vlen = Matcher::vector_length_in_bytes(this, $src1);\n-    __ vectortest(BoolTest::ne, vlen, $src1$$XMMRegister, $src2$$XMMRegister, xnoreg, xnoreg, knoreg);\n+    uint masklen = Matcher::vector_length(this, $src1);\n+    __ kmovwl($tmp$$Register, $src1$$KRegister);\n+    __ andl($tmp$$Register, (1 << masklen) - 1);\n@@ -8147,5 +8105,5 @@\n-instruct cmpvptest_anytrue_evex(rFlagsReg cr, kReg src1, kReg src2, immI_0 zero) %{\n-  predicate(VM_Version::supports_avx512bwdq() &&\n-            static_cast<const VectorTestNode*>(n->in(1))->get_predicate() == BoolTest::ne);\n-  match(Set cr (CmpI (VectorTest src1 src2) zero));\n-  format %{ \"cmpvptest_anytrue_evex $src1,$src2\\t!\" %}\n+instruct ktest_ge8(rFlagsRegU cr, kReg src1, kReg src2) %{\n+  predicate(Matcher::vector_length(n->in(1)) >= 16 ||\n+            (Matcher::vector_length(n->in(1)) == 8 && VM_Version::supports_avx512dq()));\n+  match(Set cr (VectorTest src1 src2));\n+  format %{ \"ktest_ge8  $src1, $src2\\n\\t\" %}\n@@ -8154,5 +8112,1 @@\n-    const MachNode* mask1 = static_cast<const MachNode*>(this->in(this->operand_index($src1)));\n-    const MachNode* mask2 = static_cast<const MachNode*>(this->in(this->operand_index($src2)));\n-    assert(0 == Type::cmp(mask1->bottom_type(), mask2->bottom_type()), \"\");\n-    masklen = masklen < 8 ? 8 : masklen;\n-    __ ktest(masklen, $src1$$KRegister, $src2$$KRegister);\n+    __ kortest(masklen, $src1$$KRegister, $src1$$KRegister);\n@@ -8878,6 +8832,0 @@\n-    \/\/ TODO: Once auto-vectorizer supports ConvL2I operation, PopCountVL\n-    \/\/ should be succeeded by its corresponding vector IR and following\n-    \/\/ special handling should be removed.\n-    if (opcode == Op_PopCountVL && Matcher::vector_element_basic_type(this) == T_INT) {\n-      __ evpmovqd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    }\n@@ -8914,12 +8862,0 @@\n-    \/\/ TODO: Once auto-vectorizer supports ConvL2I operation, PopCountVL\n-    \/\/ should be succeeded by its corresponding vector IR and following\n-    \/\/ special handling should be removed.\n-    if (opcode == Op_PopCountVL && Matcher::vector_element_basic_type(this) == T_INT) {\n-      if (VM_Version::supports_avx512vl()) {\n-        __ evpmovqd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-      } else {\n-        assert(VM_Version::supports_avx2(), \"\");\n-        __ vpshufd($dst$$XMMRegister, $dst$$XMMRegister, 8, vlen_enc);\n-        __ vpermq($dst$$XMMRegister, $dst$$XMMRegister, 8, vlen_enc);\n-      }\n-    }\n@@ -8942,1 +8878,0 @@\n-    BasicType rbt = Matcher::vector_element_basic_type(this);\n@@ -8945,6 +8880,0 @@\n-    \/\/ TODO: Once auto-vectorizer supports ConvL2I operation, CountTrailingZerosV\n-    \/\/ should be succeeded by its corresponding vector IR and following\n-    \/\/ special handling should be removed.\n-    if (bt == T_LONG && rbt == T_INT) {\n-      __ evpmovqd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    }\n@@ -8996,1 +8925,0 @@\n-    BasicType rbt = Matcher::vector_element_basic_type(this);\n@@ -8999,8 +8927,0 @@\n-    \/\/ TODO: Once auto-vectorizer supports ConvL2I operation, PopCountVL\n-    \/\/ should be succeeded by its corresponding vector IR and following\n-    \/\/ special handling should be removed.\n-    if (bt == T_LONG && rbt == T_INT) {\n-      assert(VM_Version::supports_avx2(), \"\");\n-      __ vpshufd($dst$$XMMRegister, $dst$$XMMRegister, 8, vlen_enc);\n-      __ vpermq($dst$$XMMRegister, $dst$$XMMRegister, 8, vlen_enc);\n-    }\n@@ -9411,1 +9331,0 @@\n-     BasicType rbt = Matcher::vector_element_basic_type(this);\n@@ -9414,6 +9333,0 @@\n-     \/\/ TODO: Once auto-vectorizer supports ConvL2I operation, CountLeadingZerosV\n-     \/\/ should be succeeded by its corresponding vector IR and following\n-     \/\/ special handling should be removed.\n-     if (rbt == T_INT && bt == T_LONG) {\n-       __ evpmovqd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-     }\n@@ -9494,1 +9407,0 @@\n-    BasicType rbt = Matcher::vector_element_basic_type(this);\n@@ -9497,6 +9409,0 @@\n-    \/\/ TODO: Once auto-vectorizer supports ConvL2I operation, CountLeadingZerosV\n-    \/\/ should be succeeded by its corresponding vector IR and following\n-    \/\/ special handling should be removed.\n-    if (rbt == T_INT && bt == T_LONG) {\n-      __ evpmovqd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    }\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":93,"deletions":187,"binary":false,"changes":280,"status":"modified"},{"patch":"@@ -2167,1 +2167,0 @@\n-    $$$emit8$primary;\n@@ -2170,0 +2169,1 @@\n+      $$$emit8$primary;\n@@ -2173,0 +2173,5 @@\n+    } else if (_method->intrinsic_id() == vmIntrinsicID::_ensureMaterializedForStackWalk) {\n+      \/\/ The NOP here is purely to ensure that eliding a call to\n+      \/\/ JVM_EnsureMaterializedForStackWalk doesn't change the code size.\n+      __ addr_nop_5();\n+      __ block_comment(\"call JVM_EnsureMaterializedForStackWalk (elided)\");\n@@ -2174,0 +2179,1 @@\n+      $$$emit8$primary;\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -90,4 +90,0 @@\n-void ThawBase::patch_chunk_pd(intptr_t* sp) {\n-  Unimplemented();\n-}\n-\n","filename":"src\/hotspot\/cpu\/zero\/continuationFreezeThaw_zero.inline.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,2 @@\n-                                                bool needs_return_buffer) {\n+                                                bool needs_return_buffer,\n+                                                int captured_state_mask) {\n","filename":"src\/hotspot\/cpu\/zero\/downcallLinker_zero.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -70,6 +70,0 @@\n-template <ChunkFrames frame_kind>\n-intptr_t* StackChunkFrameStream<frame_kind>::next_sp_for_interpreter_frame() const {\n-  Unimplemented();\n-  return NULL;\n-}\n-\n","filename":"src\/hotspot\/cpu\/zero\/stackChunkFrameStream_zero.inline.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -194,1 +194,0 @@\n-    StubRoutines::_atomic_xchg_long_entry    = ShouldNotCallThisStub();\n@@ -196,1 +195,0 @@\n-    StubRoutines::_atomic_cmpxchg_byte_entry = ShouldNotCallThisStub();\n@@ -199,1 +197,0 @@\n-    StubRoutines::_atomic_add_long_entry     = ShouldNotCallThisStub();\n","filename":"src\/hotspot\/cpu\/zero\/stubGenerator_zero.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"prims\/vmstorageBase.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/zero\/vmstorage_zero.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"previous_filename":"src\/hotspot\/cpu\/zero\/vmstorage_zero.inline.hpp","status":"renamed"},{"patch":"@@ -290,3 +290,0 @@\n-  if (pidsmax == NULL) {\n-    return NULL;\n-  }\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -95,3 +95,0 @@\n-  if (cpus == NULL) {\n-    return NULL;\n-  }\n@@ -103,4 +100,1 @@\n-                     \"Raw value for CPU quota is: %s\", \"%s %*d\", quota, 1024);\n-  if (quota == NULL) {\n-    return NULL;\n-  }\n+                     \"Raw value for CPU quota is: %s\", \"%1023s %*d\", quota, 1024);\n@@ -113,3 +107,0 @@\n-  if (mems == NULL) {\n-    return NULL;\n-  }\n@@ -153,4 +144,1 @@\n-                         \"Memory Soft Limit is: %s\", \"%s\", mem_soft_limit_str, 1024);\n-  if (mem_soft_limit_str == NULL) {\n-    return NULL;\n-  }\n+                         \"Memory Soft Limit is: %s\", \"%1023s\", mem_soft_limit_str, 1024);\n@@ -178,4 +166,1 @@\n-                         \"Memory and Swap Limit is: %s\", \"%s\", mem_swp_limit_str, 1024);\n-  if (mem_swp_limit_str == NULL) {\n-    return NULL;\n-  }\n+                         \"Memory and Swap Limit is: %s\", \"%1023s\", mem_swp_limit_str, 1024);\n@@ -188,4 +173,1 @@\n-                         \"Swap currently used is: %s\", \"%s\", mem_swp_current_str, 1024);\n-  if (mem_swp_current_str == NULL) {\n-    return NULL;\n-  }\n+                         \"Swap currently used is: %s\", \"%1023s\", mem_swp_current_str, 1024);\n@@ -218,4 +200,1 @@\n-                         \"Raw value for memory limit is: %s\", \"%s\", mem_limit_str, 1024);\n-  if (mem_limit_str == NULL) {\n-    return NULL;\n-  }\n+                         \"Raw value for memory limit is: %s\", \"%1023s\", mem_limit_str, 1024);\n@@ -247,4 +226,1 @@\n-                     \"Maximum number of tasks is: %s\", \"%s %*d\", pidsmax, 1024);\n-  if (pidsmax == NULL) {\n-    return NULL;\n-  }\n+                     \"Maximum number of tasks is: %s\", \"%1023s %*d\", pidsmax, 1024);\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":6,"deletions":30,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -4226,1 +4226,1 @@\n-    \"VectorCastL2X\", \"VectorCastF2X\", \"VectorCastD2X\",\n+    \"VectorCastL2X\", \"VectorCastF2X\", \"VectorCastD2X\", \"VectorCastF2HF\", \"VectorCastHF2F\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -157,1 +157,1 @@\n-  case vmIntrinsics::_extentLocalCache:\n+  case vmIntrinsics::_scopedValueCache:\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1431,2 +1431,2 @@\n-void LIRGenerator::do_extentLocalCache(Intrinsic* x) {\n-  do_JavaThreadField(x, JavaThread::extentLocalCache_offset());\n+void LIRGenerator::do_scopedValueCache(Intrinsic* x) {\n+  do_JavaThreadField(x, JavaThread::scopedValueCache_offset());\n@@ -2951,1 +2951,1 @@\n-  case vmIntrinsics::_extentLocalCache: do_extentLocalCache(x); break;\n+  case vmIntrinsics::_scopedValueCache: do_scopedValueCache(x); break;\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -260,1 +260,1 @@\n-  void do_extentLocalCache(Intrinsic* x);\n+  void do_scopedValueCache(Intrinsic* x);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -228,1 +228,1 @@\n-      holder->is_in_package(\"jdk\/internal\/foreign\") || holder->is_in_package(\"java\/lang\/foreign\") ||\n+      holder->is_in_package(\"jdk\/internal\/foreign\/layout\") || holder->is_in_package(\"jdk\/internal\/foreign\") ||\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -145,0 +145,2 @@\n+#define JAVA_21_VERSION                   65\n+\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -674,0 +674,12 @@\n+\/\/ Gets the exploded path for the named module. The memory for the path\n+\/\/ is allocated on the C heap if `c_heap` is true otherwise in the resource area.\n+static const char* get_exploded_module_path(const char* module_name, bool c_heap) {\n+  const char *home = Arguments::get_java_home();\n+  const char file_sep = os::file_separator()[0];\n+  \/\/ 10 represents the length of \"modules\" + 2 file separators + \\0\n+  size_t len = strlen(home) + strlen(module_name) + 10;\n+  char *path = c_heap ? NEW_C_HEAP_ARRAY(char, len, mtModule) : NEW_RESOURCE_ARRAY(char, len);\n+  jio_snprintf(path, len, \"%s%cmodules%c%s\", home, file_sep, file_sep, module_name);\n+  return path;\n+}\n+\n@@ -683,6 +695,1 @@\n-  const char *home = Arguments::get_java_home();\n-  const char file_sep = os::file_separator()[0];\n-  \/\/ 10 represents the length of \"modules\" + 2 file separators + \\0\n-  size_t len = strlen(home) + strlen(module_name) + 10;\n-  char *path = NEW_RESOURCE_ARRAY(char, len);\n-  jio_snprintf(path, len, \"%s%cmodules%c%s\", home, file_sep, file_sep, module_name);\n+  const char *path = get_exploded_module_path(module_name, false);\n@@ -1418,0 +1425,14 @@\n+bool ClassLoader::is_module_observable(const char* module_name) {\n+  assert(JImageOpen != NULL, \"jimage library should have been opened\");\n+  if (JImage_file == NULL) {\n+    struct stat st;\n+    const char *path = get_exploded_module_path(module_name, true);\n+    bool res = os::stat(path, &st) == 0;\n+    FREE_C_HEAP_ARRAY(char, path);\n+    return res;\n+  }\n+  jlong size;\n+  const char *jimage_version = get_jimage_version_string();\n+  return (*JImageFindResource)(JImage_file, module_name, jimage_version, \"module-info.class\", &size) != 0;\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":27,"deletions":6,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -377,0 +377,4 @@\n+  \/\/ Determines if the named module is present in the\n+  \/\/ modules jimage file or in the exploded modules directory.\n+  static bool is_module_observable(const char* module_name);\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -827,0 +827,1 @@\n+    ResourceMark rm;\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1686,1 +1686,1 @@\n-int java_lang_Thread::_extentLocalBindings_offset;\n+int java_lang_Thread::_scopedValueBindings_offset;\n@@ -1699,1 +1699,1 @@\n-  macro(_extentLocalBindings_offset, k, \"extentLocalBindings\", object_signature, false);\n+  macro(_scopedValueBindings_offset, k, \"scopedValueBindings\", object_signature, false);\n@@ -1732,2 +1732,3 @@\n-void java_lang_Thread::clear_extentLocalBindings(oop java_thread) {\n-  java_thread->obj_field_put(_extentLocalBindings_offset, NULL);\n+void java_lang_Thread::clear_scopedValueBindings(oop java_thread) {\n+  assert(java_thread != NULL, \"need a java_lang_Thread pointer here\");\n+  java_thread->obj_field_put(_scopedValueBindings_offset, NULL);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -355,1 +355,1 @@\n-  static int _extentLocalBindings_offset;\n+  static int _scopedValueBindings_offset;\n@@ -401,2 +401,2 @@\n-  \/\/ Clear all extent local bindings on error\n-  static void clear_extentLocalBindings(oop java_thread);\n+  \/\/ Clear all scoped value bindings on error\n+  static void clear_scopedValueBindings(oop java_thread);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-  case vmIntrinsics::_extentLocalCache:\n+  case vmIntrinsics::_scopedValueCache:\n@@ -130,2 +130,2 @@\n-  case vmIntrinsics::_extentLocalCache:\n-  case vmIntrinsics::_setExtentLocalCache:\n+  case vmIntrinsics::_scopedValueCache:\n+  case vmIntrinsics::_setScopedValueCache:\n@@ -268,2 +268,2 @@\n-  case vmIntrinsics::_extentLocalCache:\n-  case vmIntrinsics::_setExtentLocalCache:\n+  case vmIntrinsics::_scopedValueCache:\n+  case vmIntrinsics::_setScopedValueCache:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -273,1 +273,1 @@\n-                                                                                                                       \\\n+                                                                                                                        \\\n@@ -289,6 +289,9 @@\n-  do_intrinsic(_extentLocalCache,          java_lang_Thread,       extentLocalCache_name, extentLocalCache_signature, F_SN) \\\n-   do_name(     extentLocalCache_name,                            \"extentLocalCache\")                                     \\\n-   do_signature(extentLocalCache_signature,                       \"()[Ljava\/lang\/Object;\")                               \\\n-  do_intrinsic(_setExtentLocalCache,       java_lang_Thread,       setExtentLocalCache_name, setExtentLocalCache_signature, F_SN) \\\n-   do_name(     setExtentLocalCache_name,                         \"setExtentLocalCache\")                                  \\\n-   do_signature(setExtentLocalCache_signature,                    \"([Ljava\/lang\/Object;)V\")                              \\\n+  do_intrinsic(_scopedValueCache,         java_lang_Thread,       scopedValueCache_name, scopedValueCache_signature, F_SN) \\\n+   do_name(     scopedValueCache_name,                           \"scopedValueCache\")                                    \\\n+   do_signature(scopedValueCache_signature,                      \"()[Ljava\/lang\/Object;\")                               \\\n+  do_intrinsic(_setScopedValueCache,      java_lang_Thread,       setScopedValueCache_name, setScopedValueCache_signature, F_SN) \\\n+   do_name(     setScopedValueCache_name,                        \"setScopedValueCache\")                                 \\\n+   do_signature(setScopedValueCache_signature,                   \"([Ljava\/lang\/Object;)V\")                              \\\n+  do_intrinsic(_findScopedValueBindings,  java_lang_Thread,       findScopedValueBindings_name, void_object_signature, F_SN) \\\n+   do_name(     findScopedValueBindings_name,                    \"findScopedValueBindings\")                             \\\n+                                                                                                                        \\\n@@ -334,0 +337,3 @@\n+  do_intrinsic(_ensureMaterializedForStackWalk, java_lang_Thread, ensureMaterializedForStackWalk_name, object_void_signature, F_SN)  \\\n+   do_name(     ensureMaterializedForStackWalk_name,              \"ensureMaterializedForStackWalk\")                     \\\n+                                                                                                                        \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -159,0 +159,2 @@\n+  template(jdk_incubator_concurrent_ScopedValue,      \"jdk\/incubator\/concurrent\/ScopedValue\")     \\\n+  template(jdk_incubator_concurrent_ScopedValue_Carrier, \"jdk\/incubator\/concurrent\/ScopedValue$Carrier\") \\\n@@ -399,0 +401,1 @@\n+  template(runWith_method_name,                       \"runWith\")                                  \\\n@@ -604,0 +607,1 @@\n+  template(runnable_void_signature,                   \"(Ljava\/lang\/Runnable;)V\")                                   \\\n@@ -744,0 +748,4 @@\n+  template(serializeSavedPropertiesToByteArray_name,   \"serializeSavedPropertiesToByteArray\")                     \\\n+  template(encodeThrowable_name,                       \"encodeThrowable\")                                         \\\n+  template(encodeThrowable_signature,                  \"(Ljava\/lang\/Throwable;JI)I\")                              \\\n+  template(decodeAndThrowThrowable_name,               \"decodeAndThrowThrowable\")                                 \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -454,0 +454,36 @@\n+#ifdef ASSERT\n+class CheckForOopsClosure : public OopClosure {\n+  bool _found_oop = false;\n+ public:\n+  virtual void do_oop(oop* o) { _found_oop = true; }\n+  virtual void do_oop(narrowOop* o) { _found_oop = true; }\n+  bool found_oop() { return _found_oop; }\n+};\n+class CheckForMetadataClosure : public MetadataClosure {\n+  bool _found_metadata = false;\n+  Metadata* _ignore = nullptr;\n+ public:\n+  CheckForMetadataClosure(Metadata* ignore) : _ignore(ignore) {}\n+  virtual void do_metadata(Metadata* md) { if (md != _ignore) _found_metadata = true; }\n+  bool found_metadata() { return _found_metadata; }\n+};\n+\n+static void assert_no_oops_or_metadata(nmethod* nm) {\n+  if (nm == nullptr) return;\n+  assert(nm->oop_maps() == nullptr, \"expectation\");\n+\n+  CheckForOopsClosure cfo;\n+  nm->oops_do(&cfo);\n+  assert(!cfo.found_oop(), \"no oops allowed\");\n+\n+  \/\/ We allow an exception for the own Method, but require its class to be permanent.\n+  Method* own_method = nm->method();\n+  CheckForMetadataClosure cfm(\/* ignore reference to own Method *\/ own_method);\n+  nm->metadata_do(&cfm);\n+  assert(!cfm.found_metadata(), \"no metadata allowed\");\n+\n+  assert(own_method->method_holder()->class_loader_data()->is_permanent_class_loader_data(),\n+         \"Method's class needs to be permanent\");\n+}\n+#endif\n+\n@@ -477,1 +513,5 @@\n-    nm = new (native_nmethod_size, CompLevel_none)\n+\n+    \/\/ MH intrinsics are dispatch stubs which are compatible with NonNMethod space.\n+    \/\/ IsUnloadingBehaviour::is_unloading needs to handle them separately.\n+    bool allow_NonNMethod_space = method->can_be_allocated_in_NonNMethod_space();\n+    nm = new (native_nmethod_size, allow_NonNMethod_space)\n@@ -484,1 +524,2 @@\n-    NOT_PRODUCT(if (nm != NULL)  native_nmethod_stats.note_native_nmethod(nm));\n+    DEBUG_ONLY( if (allow_NonNMethod_space) assert_no_oops_or_metadata(nm); )\n+    NOT_PRODUCT(if (nm != NULL) native_nmethod_stats.note_native_nmethod(nm));\n@@ -719,0 +760,8 @@\n+void* nmethod::operator new(size_t size, int nmethod_size, bool allow_NonNMethod_space) throw () {\n+  \/\/ Try MethodNonProfiled and MethodProfiled.\n+  void* return_value = CodeCache::allocate(nmethod_size, CodeBlobType::MethodNonProfiled);\n+  if (return_value != nullptr || !allow_NonNMethod_space) return return_value;\n+  \/\/ Try NonNMethod or give up.\n+  return CodeCache::allocate(nmethod_size, CodeBlobType::NonNMethod);\n+}\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":51,"deletions":2,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -301,0 +301,4 @@\n+  \/\/ For method handle intrinsics: Try MethodNonProfiled, MethodProfiled and NonNMethod.\n+  \/\/ Attention: Only allow NonNMethod space for special nmethods which don't need to be\n+  \/\/ findable by nmethod iterators! In particular, they must not contain oops!\n+  void* operator new(size_t size, int nmethod_size, bool allow_NonNMethod_space) throw();\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1469,0 +1469,1 @@\n+  _card_set_freelist_pool(G1CardSetConfiguration::num_mem_object_types()),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"gc\/g1\/g1MonotonicArenaFreePool.hpp\"\n@@ -790,0 +791,2 @@\n+  G1MonotonicArenaFreePool _card_set_freelist_pool;\n+\n@@ -916,0 +919,3 @@\n+  const G1MonotonicArenaFreePool* card_set_freelist_pool() const { return &_card_set_freelist_pool; }\n+  G1MonotonicArenaFreePool* card_set_freelist_pool() { return &_card_set_freelist_pool; }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3055,0 +3055,2 @@\n+  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+  _total_remset_bytes += g1h->card_set_freelist_pool()->mem_size();\n@@ -3056,1 +3058,1 @@\n-  _total_remset_bytes += G1CardSetFreePool::free_list_pool()->mem_size() + HeapRegionRemSet::static_mem_size();\n+  _total_remset_bytes += HeapRegionRemSet::static_mem_size();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-    _monitoring_scope(monitoring_support, true \/* full_gc *\/, true \/* all_memory_pools_affected *\/),\n+    _monitoring_scope(monitoring_support),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCScope.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-  G1MonitoringScope       _monitoring_scope;\n+  G1FullGCMonitoringScope _monitoring_scope;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCScope.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,0 +93,1 @@\n+  _conc_gc_memory_manager(\"G1 Concurrent GC\", \"end of concurrent GC pause\"),\n@@ -202,0 +203,2 @@\n+  _conc_gc_memory_manager.add_pool(_old_gen_pool);\n+\n@@ -213,1 +216,1 @@\n-  GrowableArray<GCMemoryManager*> memory_managers(2);\n+  GrowableArray<GCMemoryManager*> memory_managers(3);\n@@ -216,0 +219,1 @@\n+  memory_managers.append(&_conc_gc_memory_manager);\n@@ -347,1 +351,4 @@\n-G1MonitoringScope::G1MonitoringScope(G1MonitoringSupport* monitoring_support, bool full_gc, bool all_memory_pools_affected) :\n+G1MonitoringScope::G1MonitoringScope(G1MonitoringSupport* monitoring_support,\n+                                     CollectorCounters* collection_counters,\n+                                     GCMemoryManager* gc_memory_manager,\n+                                     bool all_memory_pools_affected) :\n@@ -349,2 +356,2 @@\n-  _tcs(full_gc ? monitoring_support->_full_collection_counters : monitoring_support->_incremental_collection_counters),\n-  _tms(full_gc ? &monitoring_support->_full_gc_memory_manager : &monitoring_support->_incremental_memory_manager,\n+  _tcs(collection_counters),\n+  _tms(gc_memory_manager,\n@@ -359,0 +366,20 @@\n+\n+G1YoungGCMonitoringScope::G1YoungGCMonitoringScope(G1MonitoringSupport* monitoring_support,\n+                                                   bool all_memory_pools_affected) :\n+  G1MonitoringScope(monitoring_support,\n+                    monitoring_support->_incremental_collection_counters,\n+                    &monitoring_support->_incremental_memory_manager,\n+                    all_memory_pools_affected) {\n+}\n+\n+G1FullGCMonitoringScope::G1FullGCMonitoringScope(G1MonitoringSupport* monitoring_support) :\n+  G1MonitoringScope(monitoring_support,\n+                    monitoring_support->_full_collection_counters,\n+                    &monitoring_support->_full_gc_memory_manager) {\n+}\n+\n+G1ConcGCMonitoringScope::G1ConcGCMonitoringScope(G1MonitoringSupport* monitoring_support) :\n+  G1MonitoringScope(monitoring_support,\n+                    monitoring_support->_conc_collection_counters,\n+                    &monitoring_support->_conc_gc_memory_manager) {\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MonitoringSupport.cpp","additions":31,"deletions":4,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -124,1 +124,3 @@\n-  friend class G1MonitoringScope;\n+  friend class G1YoungGCMonitoringScope;\n+  friend class G1FullGCMonitoringScope;\n+  friend class G1ConcGCMonitoringScope;\n@@ -131,0 +133,1 @@\n+  GCMemoryManager _conc_gc_memory_manager;\n@@ -213,4 +216,0 @@\n-  CollectorCounters* conc_collection_counters() {\n-    return _conc_collection_counters;\n-  }\n-\n@@ -244,2 +243,5 @@\n-public:\n-  G1MonitoringScope(G1MonitoringSupport* monitoring_support, bool full_gc, bool all_memory_pools_affected);\n+protected:\n+  G1MonitoringScope(G1MonitoringSupport* monitoring_support,\n+                    CollectorCounters* collection_counters,\n+                    GCMemoryManager* gc_memory_manager,\n+                    bool all_memory_pools_affected = true);\n@@ -249,0 +251,14 @@\n+class G1YoungGCMonitoringScope : public G1MonitoringScope {\n+public:\n+  G1YoungGCMonitoringScope(G1MonitoringSupport* monitoring_support, bool all_memory_pools_affected);\n+};\n+\n+class G1FullGCMonitoringScope : public G1MonitoringScope {\n+public:\n+  G1FullGCMonitoringScope(G1MonitoringSupport* monitoring_support);\n+};\n+\n+class G1ConcGCMonitoringScope : public G1MonitoringScope {\n+public:\n+  G1ConcGCMonitoringScope(G1MonitoringSupport* monitoring_support);\n+};\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MonitoringSupport.hpp","additions":23,"deletions":7,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/g1\/g1MonotonicArenaFreePool.hpp\"\n@@ -56,1 +57,3 @@\n-  G1MonotonicArenaMemoryStats free = G1MonotonicArenaFreePool::free_list_sizes();\n+  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+  G1MonotonicArenaFreePool* freelist_pool = g1h->card_set_freelist_pool();\n+  G1MonotonicArenaMemoryStats free = freelist_pool->memory_sizes();\n@@ -72,1 +75,1 @@\n-  G1MonotonicArenaFreePool::update_unlink_processors(_return_info);\n+  freelist_pool->update_unlink_processors(_return_info);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MonotonicArenaFreeMemoryTask.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-  uint num_free_lists = _freelist_pool.num_free_lists();\n@@ -49,2 +48,2 @@\n-  for (uint i = 0; i < num_free_lists; i++) {\n-    unlink_processor->at(i)->visit_free_list(_freelist_pool.free_list(i));\n+  for (uint i = 0; i < num_free_lists(); i++) {\n+    unlink_processor->at(i)->visit_free_list(free_list(i));\n@@ -151,2 +150,0 @@\n-G1MonotonicArenaFreePool G1MonotonicArenaFreePool::_freelist_pool(G1CardSetConfiguration::num_mem_object_types());\n-\n@@ -187,2 +184,2 @@\n-void G1MonotonicArenaFreePool::print_on(outputStream* out) {\n-  out->print_cr(\"  Free Pool: size %zu\", free_list_pool()->mem_size());\n+void G1MonotonicArenaFreePool::print_on(outputStream* out) const {\n+  out->print_cr(\"  Free Pool: size %zu\", mem_size());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MonotonicArenaFreePool.cpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -61,2 +61,0 @@\n-  \/\/ The global free pool.\n-  static G1MonotonicArenaFreePool _freelist_pool;\n@@ -68,3 +66,0 @@\n-  static G1MonotonicArenaFreePool* free_list_pool() { return &_freelist_pool; }\n-  static G1MonotonicArenaMemoryStats free_list_sizes() { return _freelist_pool.memory_sizes(); }\n-\n@@ -74,1 +69,1 @@\n-  static void update_unlink_processors(G1ReturnMemoryProcessorSet* unlink_processors);\n+  void update_unlink_processors(G1ReturnMemoryProcessorSet* unlink_processors);\n@@ -89,1 +84,1 @@\n-  void print_on(outputStream* out);\n+  void print_on(outputStream* out) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MonotonicArenaFreePool.hpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -191,0 +191,1 @@\n+  assert(!Universe::is_fully_initialized() || SafepointSynchronize::is_at_safepoint(), \"must be\");\n@@ -192,0 +193,2 @@\n+  \/\/ Request at least one eden region to ensure progress.\n+  bool after_gc = true;\n@@ -193,1 +196,2 @@\n-                             _analytics->predict_rs_length(for_young_only_phase));\n+                             _analytics->predict_rs_length(for_young_only_phase),\n+                             after_gc);\n@@ -196,1 +200,1 @@\n-void G1Policy::update_young_length_bounds(size_t pending_cards, size_t rs_length) {\n+void G1Policy::update_young_length_bounds(size_t pending_cards, size_t rs_length, bool after_gc) {\n@@ -199,1 +203,1 @@\n-  uint new_young_list_desired_length = calculate_young_desired_length(pending_cards, rs_length);\n+  uint new_young_list_desired_length = calculate_young_desired_length(pending_cards, rs_length, after_gc);\n@@ -227,2 +231,2 @@\n-\/\/ - MMU goal influencing eden to make GCs spaced apart.\n-\/\/ - a minimum one eden region length.\n+\/\/ - MMU goal influencing eden to make GCs spaced apart\n+\/\/ - if after a GC, request at least one eden region to avoid immediate full gcs\n@@ -230,5 +234,3 @@\n-\/\/ We may enter with already allocated eden and survivor regions, that may be\n-\/\/ higher than the maximum, or the above goals may result in a desired value\n-\/\/ smaller than are already allocated.\n-\/\/ The main reason is revising young length, with or without the GCLocker being\n-\/\/ active.\n+\/\/ We may enter with already allocated eden and survivor regions because there\n+\/\/ are survivor regions (after gc). Young gen revising can call this method at any\n+\/\/ time too.\n@@ -236,1 +238,5 @@\n-uint G1Policy::calculate_young_desired_length(size_t pending_cards, size_t rs_length) const {\n+\/\/ For this method it does not matter if the above goals may result in a desired\n+\/\/ value smaller than what is already allocated or what can actually be allocated.\n+\/\/ This return value is only an expectation.\n+\/\/\n+uint G1Policy::calculate_young_desired_length(size_t pending_cards, size_t rs_length, bool after_gc) const {\n@@ -243,6 +249,0 @@\n-  \/\/ Absolute minimum eden length.\n-  \/\/ Enforcing a minimum eden length helps at startup when the predictors are not\n-  \/\/ yet trained on the application to avoid unnecessary (but very short) full gcs\n-  \/\/ on very small (initial) heaps.\n-  uint const MinDesiredEdenLength = 1;\n-\n@@ -264,0 +264,4 @@\n+  \/\/ The absolute minimum young gen length (as provided by the young gen sizer) ensures\n+  \/\/ that we desire at least one young gen region.\n+  assert(absolute_min_young_length > 0, \"must be\");\n+\n@@ -280,4 +284,2 @@\n-    \/\/ Also request at least one eden region, see above for reasons.\n-    uint desired_eden_length = MAX3(desired_eden_length_by_pause,\n-                                    desired_eden_length_by_mmu,\n-                                    MinDesiredEdenLength);\n+    uint desired_eden_length = MAX2(desired_eden_length_by_pause,\n+                                    desired_eden_length_by_mmu);\n@@ -294,1 +296,14 @@\n-  log_trace(gc, ergo, heap)(\"Young desired length %u \"\n+  \/\/ After a garbage collection, make room for at least one eden region (i.e. in addition to\n+  \/\/ already allocated survivor regions).\n+  \/\/ This may make desired regions go over absolute maximum length by the heap sizer, however\n+  \/\/ the immediate full gcs after that young gc (particularly on small heaps) are worse.\n+  if (after_gc && (allocated_young_length >= desired_young_length)) {\n+   log_trace(gc, ergo, heap)(\"Young desired length: Desired young region length less than already \"\n+                              \"allocated region length, but requesting one eden region minimum. \"\n+                              \"Expanding desired young length from %u to %u.\",\n+                              desired_young_length,\n+                              allocated_young_length + 1);\n+    desired_young_length = allocated_young_length + 1;\n+  }\n+\n+  log_trace(gc, ergo, heap)(\"Young desired length %u (after gc: %s) \"\n@@ -300,3 +315,3 @@\n-                            \"desired eden length by pause %u \"\n-                            \"desired eden length by default %u\",\n-                            desired_young_length, survivor_length,\n+                            \"desired eden length by pause %u \",\n+                            desired_young_length, BOOL_TO_STR(after_gc),\n+                            survivor_length,\n@@ -305,2 +320,1 @@\n-                            desired_eden_length_by_pause,\n-                            MinDesiredEdenLength);\n+                            desired_eden_length_by_pause);\n@@ -537,1 +551,4 @@\n-  update_young_length_bounds(pending_cards, rs_length);\n+  \/\/ We are only revising young gen length to meet pause time goal, so do not request\n+  \/\/ at least one eden region for progress. At this point we actually want to run into\n+  \/\/ a GC soon if young gen is already (too) large.\n+  update_young_length_bounds(pending_cards, rs_length, false \/* need_one_eden_region *\/);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":45,"deletions":28,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -213,1 +213,2 @@\n-  \/\/ the prediction model.\n+  \/\/ the prediction model. If after_gc is set, make sure that there is one eden region\n+  \/\/ available (if there is enough space) to guarantee some progress.\n@@ -215,1 +216,1 @@\n-  void update_young_length_bounds(size_t pending_cards, size_t rs_length);\n+  void update_young_length_bounds(size_t pending_cards, size_t rs_length, bool after_gc);\n@@ -243,1 +244,1 @@\n-  uint calculate_young_desired_length(size_t pending_cards, size_t rs_length) const;\n+  uint calculate_young_desired_length(size_t pending_cards, size_t rs_length, bool after_gc) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -288,1 +288,2 @@\n-    G1CardSetFreePool::free_list_pool()->print_on(out);\n+    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+    g1h->card_set_freelist_pool()->print_on(out);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetSummary.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-  TraceCollectorStats tcs(g1h->monitoring_support()->conc_collection_counters());\n+  G1ConcGCMonitoringScope monitoring_scope(g1h->monitoring_support());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1059,3 +1059,2 @@\n-  G1MonitoringScope ms(monitoring_support(),\n-                       false \/* full_gc *\/,\n-                       collector_state()->in_mixed_phase() \/* all_memory_pools_affected *\/);\n+  G1YoungGCMonitoringScope ms(monitoring_support(),\n+                              collector_state()->in_mixed_phase() \/* all_memory_pools_affected *\/);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-  _card_set_mm(config, G1MonotonicArenaFreePool::free_list_pool()),\n+  _card_set_mm(config, G1CollectedHeap::heap()->card_set_freelist_pool()),\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-    return G1CardSet::static_mem_size() + G1CodeRootSet::static_mem_size() + sizeof(G1CardSetFreePool);\n+    return G1CardSet::static_mem_size() + G1CodeRootSet::static_mem_size();\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -188,6 +188,7 @@\n-    gch->full_process_roots(false, \/\/ not the adjust phase\n-                            GenCollectedHeap::SO_None,\n-                            ClassUnloading, \/\/ only strong roots if ClassUnloading\n-                                            \/\/ is enabled\n-                            &follow_root_closure,\n-                            &follow_cld_closure);\n+    CLDClosure* weak_cld_closure = ClassUnloading ? NULL : &follow_cld_closure;\n+    MarkingCodeBlobClosure mark_code_closure(&follow_root_closure, !CodeBlobToOopClosure::FixRelocations, true);\n+    gch->process_roots(GenCollectedHeap::SO_None,\n+                       &follow_root_closure,\n+                       &follow_cld_closure,\n+                       weak_cld_closure,\n+                       &mark_code_closure);\n@@ -265,9 +266,6 @@\n-  {\n-    StrongRootsScope srs(0);\n-\n-    gch->full_process_roots(true,  \/\/ this is the adjust phase\n-                            GenCollectedHeap::SO_AllCodeCache,\n-                            false, \/\/ all roots\n-                            &adjust_pointer_closure,\n-                            &adjust_cld_closure);\n-  }\n+  CodeBlobToOopClosure code_closure(&adjust_pointer_closure, CodeBlobToOopClosure::FixRelocations);\n+  gch->process_roots(GenCollectedHeap::SO_AllCodeCache,\n+                     &adjust_pointer_closure,\n+                     &adjust_cld_closure,\n+                     &adjust_cld_closure,\n+                     &code_closure);\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.cpp","additions":13,"deletions":15,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-    _decorators(AccessInternal::decorator_fixup(decorators)),\n+    _decorators(AccessInternal::decorator_fixup(decorators, type)),\n","filename":"src\/hotspot\/share\/gc\/shared\/c1\/barrierSetC1.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -361,1 +361,1 @@\n-  _decorators = AccessInternal::decorator_fixup(_decorators);\n+  _decorators = AccessInternal::decorator_fixup(_decorators, _type);\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,5 @@\n+  if (cm->method()->can_be_allocated_in_NonNMethod_space()) {\n+    \/\/ When the nmethod is in NonNMethod space, we may reach here without IsUnloadingBehaviour.\n+    \/\/ However, we only allow this for special methods which never get unloaded.\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/gc\/shared\/gcBehaviours.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -392,0 +392,1 @@\n+      event.set_endtime(_needs_gc_start_timestamp);\n","filename":"src\/hotspot\/share\/gc\/shared\/gcTraceSend.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -796,14 +796,0 @@\n-void GenCollectedHeap::full_process_roots(bool is_adjust_phase,\n-                                          ScanningOption so,\n-                                          bool only_strong_roots,\n-                                          OopClosure* root_closure,\n-                                          CLDClosure* cld_closure) {\n-  \/\/ Called from either the marking phase or the adjust phase.\n-  const bool is_marking_phase = !is_adjust_phase;\n-\n-  MarkingCodeBlobClosure mark_code_closure(root_closure, is_adjust_phase, is_marking_phase);\n-  CLDClosure* weak_cld_closure = only_strong_roots ? NULL : cld_closure;\n-\n-  process_roots(so, root_closure, cld_closure, weak_cld_closure, &mark_code_closure);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -329,0 +329,5 @@\n+  virtual void gc_prologue(bool full);\n+  virtual void gc_epilogue(bool full);\n+\n+ public:\n+  \/\/ Apply closures on various roots in Young GC or marking\/adjust phases of Full GC.\n@@ -335,10 +340,0 @@\n-  virtual void gc_prologue(bool full);\n-  virtual void gc_epilogue(bool full);\n-\n- public:\n-  void full_process_roots(bool is_adjust_phase,\n-                          ScanningOption so,\n-                          bool only_strong_roots,\n-                          OopClosure* root_closure,\n-                          CLDClosure* cld_closure);\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.hpp","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,2 @@\n+    event.set_starttime(timestamp);\n+    event.set_endtime(timestamp);\n@@ -61,1 +63,0 @@\n-    event.set_endtime(timestamp);\n","filename":"src\/hotspot\/share\/gc\/shared\/objectCountEventSender.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -135,1 +135,0 @@\n-  bool not_empty() const             { return used() > 0; }\n@@ -261,1 +260,0 @@\n-  NOT_PRODUCT(HeapWord* _last_explicit_min_done;)\n@@ -286,1 +284,0 @@\n-    NOT_PRODUCT(_last_explicit_min_done = NULL);\n@@ -289,11 +286,1 @@\n-  void do_MemRegion(MemRegion mr);\n-\n-  void set_min_done(HeapWord* min_done) {\n-    _min_done = min_done;\n-    NOT_PRODUCT(_last_explicit_min_done = _min_done);\n-  }\n-#ifndef PRODUCT\n-  void set_last_bottom(HeapWord* last_bottom) {\n-    _last_bottom = last_bottom;\n-  }\n-#endif\n+  void do_MemRegion(MemRegion mr) override;\n@@ -333,2 +320,2 @@\n-  virtual void initialize(MemRegion mr, bool clear_space, bool mangle_space);\n-  virtual void clear(bool mangle_space);\n+  void initialize(MemRegion mr, bool clear_space, bool mangle_space) override;\n+  void clear(bool mangle_space) override;\n@@ -375,1 +362,1 @@\n-  virtual void adjust_pointers();\n+  void adjust_pointers() override;\n@@ -402,7 +389,0 @@\n-\n-  \/\/ Return a size with adjustments as required of the space.\n-  virtual size_t adjust_object_size_v(size_t size) const { return size; }\n-\n-  void set_first_dead(HeapWord* value) { _first_dead = value; }\n-  void set_end_of_live(HeapWord* value) { _end_of_live = value; }\n-\n@@ -441,2 +421,2 @@\n-  virtual void initialize(MemRegion mr, bool clear_space, bool mangle_space);\n-  virtual void clear(bool mangle_space);\n+  void initialize(MemRegion mr, bool clear_space, bool mangle_space) override;\n+  void clear(bool mangle_space) override;\n@@ -463,1 +443,1 @@\n-  void mangle_unused_area() PRODUCT_RETURN;\n+  void mangle_unused_area() override PRODUCT_RETURN;\n@@ -465,1 +445,1 @@\n-  void mangle_unused_area_complete() PRODUCT_RETURN;\n+  void mangle_unused_area_complete() override PRODUCT_RETURN;\n@@ -474,3 +454,2 @@\n-  size_t capacity() const        { return byte_size(bottom(), end()); }\n-  size_t used() const            { return byte_size(bottom(), top()); }\n-  size_t free() const            { return byte_size(top(),    end()); }\n+  size_t used() const override   { return byte_size(bottom(), top()); }\n+  size_t free() const override   { return byte_size(top(),    end()); }\n@@ -478,1 +457,1 @@\n-  virtual bool is_free_block(const HeapWord* p) const;\n+  bool is_free_block(const HeapWord* p) const override;\n@@ -482,1 +461,1 @@\n-  MemRegion used_region() const { return MemRegion(bottom(), top()); }\n+  MemRegion used_region() const override { return MemRegion(bottom(), top()); }\n@@ -485,2 +464,2 @@\n-  virtual HeapWord* allocate(size_t word_size);\n-  virtual HeapWord* par_allocate(size_t word_size);\n+  HeapWord* allocate(size_t word_size) override;\n+  HeapWord* par_allocate(size_t word_size) override;\n@@ -489,2 +468,2 @@\n-  void oop_iterate(OopIterateClosure* cl);\n-  void object_iterate(ObjectClosure* blk);\n+  void oop_iterate(OopIterateClosure* cl) override;\n+  void object_iterate(ObjectClosure* blk) override;\n@@ -493,1 +472,1 @@\n-  virtual void reset_after_compaction() {\n+  void reset_after_compaction() override {\n@@ -501,1 +480,1 @@\n-                                     HeapWord* boundary);\n+                                     HeapWord* boundary) override;\n@@ -519,2 +498,2 @@\n-  virtual HeapWord* block_start_const(const void* p) const;\n-  size_t block_size(const HeapWord* p) const;\n+  HeapWord* block_start_const(const void* p) const override;\n+  size_t block_size(const HeapWord* p) const override;\n@@ -522,1 +501,1 @@\n-  bool block_is_obj(const HeapWord* p) const { return p < top(); }\n+  bool block_is_obj(const HeapWord* p) const override { return p < top(); }\n@@ -530,1 +509,1 @@\n-  void prepare_for_compaction(CompactPoint* cp);\n+  void prepare_for_compaction(CompactPoint* cp) override;\n@@ -533,1 +512,1 @@\n-  virtual void print_on(outputStream* st) const;\n+  void print_on(outputStream* st) const override;\n@@ -536,1 +515,1 @@\n-  virtual ContiguousSpace* toContiguousSpace() {\n+  ContiguousSpace* toContiguousSpace() override {\n@@ -541,1 +520,1 @@\n-  virtual void verify() const;\n+  void verify() const override;\n@@ -557,1 +536,1 @@\n-                       HeapWord* bottom, HeapWord* top);\n+                       HeapWord* bottom, HeapWord* top) override;\n@@ -559,1 +538,1 @@\n-  HeapWord* get_actual_top(HeapWord* top, HeapWord* top_obj);\n+  HeapWord* get_actual_top(HeapWord* top, HeapWord* top_obj) override;\n@@ -600,2 +579,2 @@\n-  void set_bottom(HeapWord* value);\n-  void set_end(HeapWord* value);\n+  void set_bottom(HeapWord* value) override;\n+  void set_end(HeapWord* value) override;\n@@ -603,1 +582,1 @@\n-  void clear(bool mangle_space);\n+  void clear(bool mangle_space) override;\n@@ -605,1 +584,1 @@\n-  inline HeapWord* block_start_const(const void* p) const;\n+  inline HeapWord* block_start_const(const void* p) const override;\n@@ -608,2 +587,2 @@\n-  virtual inline HeapWord* allocate(size_t word_size);\n-  inline HeapWord* par_allocate(size_t word_size);\n+  inline HeapWord* allocate(size_t word_size) override;\n+  inline HeapWord* par_allocate(size_t word_size) override;\n@@ -612,2 +591,2 @@\n-  virtual void initialize_threshold();\n-  virtual void alloc_block(HeapWord* start, HeapWord* end);\n+  void initialize_threshold() override;\n+  void alloc_block(HeapWord* start, HeapWord* end) override;\n@@ -615,1 +594,1 @@\n-  virtual void print_on(outputStream* st) const;\n+  void print_on(outputStream* st) const override;\n@@ -618,1 +597,1 @@\n-  void verify() const;\n+  void verify() const override;\n@@ -628,1 +607,1 @@\n-  size_t allowed_dead_ratio() const;\n+  size_t allowed_dead_ratio() const override;\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":38,"deletions":59,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    while (v > 1) {\n+    while (v >= 1) {\n@@ -74,1 +74,1 @@\n-  \/\/ Defensively saturate for product bits:\n+  \/\/ Defensively saturate for product bits\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNumberSeq.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-class BinaryMagnitudeSeq {\n+class BinaryMagnitudeSeq : public CHeapObj<mtGC> {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNumberSeq.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -244,1 +245,7 @@\n-  if (JavaThread::current()->is_attaching_via_jni()) {\n+  \/\/\n+  \/\/ Thread which is not an active Java thread should also not block.\n+  \/\/ This can happen during VM init when main thread is still not an\n+  \/\/ active Java thread.\n+  JavaThread* current = JavaThread::current();\n+  if (current->is_attaching_via_jni() ||\n+      !current->is_active_Java_thread()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPacer.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -313,1 +313,1 @@\n-JVM_ExtentLocalCache(JNIEnv *env, jclass threadClass);\n+JVM_ScopedValueCache(JNIEnv *env, jclass threadClass);\n@@ -316,1 +316,4 @@\n-JVM_SetExtentLocalCache(JNIEnv *env, jclass threadClass, jobject theCache);\n+JVM_SetScopedValueCache(JNIEnv *env, jclass threadClass, jobject theCache);\n+\n+JNIEXPORT jobject JNICALL\n+JVM_FindScopedValueBindings(JNIEnv *env, jclass threadClass);\n@@ -745,0 +748,2 @@\n+JNIEXPORT void JNICALL\n+JVM_EnsureMaterializedForStackWalk_func(JNIEnv* env, jobject vthread, jobject value);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -375,0 +375,3 @@\n+  \/\/ Remove the ScopedValue bindings in case we got a StackOverflowError\n+  \/\/ while we were trying to manipulate ScopedValue bindings.\n+  current->clear_scopedValueBindings();\n@@ -386,0 +389,3 @@\n+  \/\/ Remove the ScopedValue bindings in case we got a StackOverflowError\n+  \/\/ while we were trying to manipulate ScopedValue bindings.\n+  current->clear_scopedValueBindings();\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1527,16 +1527,13 @@\n-  {\n-    ResourceMark rm(THREAD);\n-    const ClassFileStream* const stream = parser.clone_stream();\n-    assert(stream != NULL, \"invariant\");\n-    const jclass clazz = static_cast<jclass>(JfrJavaSupport::local_jni_handle(existing_klass->java_mirror(), THREAD));\n-    JfrUpcalls::on_retransform(JfrTraceId::load_raw(existing_klass),\n-                               clazz,\n-                               stream->length(),\n-                               stream->buffer(),\n-                               &size_of_new_bytes,\n-                               &new_bytes,\n-                               THREAD);\n-    JfrJavaSupport::destroy_local_jni_handle(clazz);\n-    if (has_pending_exception(THREAD)) {\n-      return NULL;\n-    }\n+  const ClassFileStream* const stream = parser.clone_stream();\n+  assert(stream != NULL, \"invariant\");\n+  const jclass clazz = static_cast<jclass>(JfrJavaSupport::local_jni_handle(existing_klass->java_mirror(), THREAD));\n+  JfrUpcalls::on_retransform(JfrTraceId::load_raw(existing_klass),\n+                              clazz,\n+                              stream->length(),\n+                              stream->buffer(),\n+                              &size_of_new_bytes,\n+                              &new_bytes,\n+                              THREAD);\n+  JfrJavaSupport::destroy_local_jni_handle(clazz);\n+  if (has_pending_exception(THREAD)) {\n+    return NULL;\n","filename":"src\/hotspot\/share\/jfr\/instrumentation\/jfrEventClassTransformer.cpp","additions":13,"deletions":16,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -241,2 +241,2 @@\n-JVM_ENTRY_NO_ENV(jboolean, jfr_emit_event(JNIEnv* env, jobject jvm, jlong eventTypeId, jlong timeStamp, jlong when))\n-  JfrPeriodicEventSet::requestEvent((JfrEventId)eventTypeId);\n+JVM_ENTRY_NO_ENV(jboolean, jfr_emit_event(JNIEnv* env, jobject jvm, jlong event_type_id, jlong timestamp, jlong periodic_type))\n+  JfrPeriodicEventSet::requestEvent((JfrEventId)event_type_id, timestamp, static_cast<PeriodicType>(periodic_type));\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -144,3 +144,1 @@\n-  \/\/ memory space must be malloced as mtInternal\n-  \/\/ as it will be deallocated by JVMTI routines\n-  unsigned char* const new_bytes = (unsigned char* const)os::malloc(new_bytes_length, mtInternal);\n+  unsigned char* const new_bytes = NEW_RESOURCE_ARRAY_IN_THREAD_RETURN_NULL(THREAD, unsigned char, new_bytes_length);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrUpcalls.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -569,1 +569,3 @@\n-  <Event name=\"JITRestart\" category=\"Java Virtual Machine, Compiler\" label=\"JIT Restart\" stackTrace=\"false\" startTime=\"false\" thread=\"true\">\n+  <Event name=\"JITRestart\" category=\"Java Virtual Machine, Compiler\" label=\"JIT Restart\"\n+         description=\"Restart of the JIT compilers after they were stopped\"\n+         stackTrace=\"false\" startTime=\"false\" thread=\"true\">\n@@ -574,1 +576,3 @@\n-  <Event name=\"Compilation\" category=\"Java Virtual Machine, Compiler\" label=\"Compilation\" thread=\"true\">\n+  <Event name=\"Compilation\" category=\"Java Virtual Machine, Compiler\" label=\"Compilation\"\n+         description=\"Results of method compilation attempts\"\n+         thread=\"true\">\n@@ -585,1 +589,3 @@\n-  <Event name=\"CompilerPhase\" category=\"Java Virtual Machine, Compiler\" label=\"Compiler Phase\" thread=\"true\" >\n+  <Event name=\"CompilerPhase\" category=\"Java Virtual Machine, Compiler\" label=\"Compiler Phase\"\n+         description=\"Describes various phases of the compilation process like inlining or string optimization related phases\"\n+         thread=\"true\">\n@@ -591,1 +597,3 @@\n-  <Event name=\"CompilationFailure\" category=\"Java Virtual Machine, Compiler\" label=\"Compilation Failure\" thread=\"true\"  startTime=\"false\">\n+  <Event name=\"CompilationFailure\" category=\"Java Virtual Machine, Compiler\" label=\"Compilation Failure\"\n+         description=\"In case a JIT compilation failed, a compilation failure is triggered, reporting the reason\"\n+         thread=\"true\" startTime=\"false\">\n@@ -602,1 +610,3 @@\n-  <Event name=\"CompilerInlining\" category=\"Java Virtual Machine, Compiler, Optimization\" label=\"Method Inlining\" thread=\"true\" startTime=\"false\">\n+  <Event name=\"CompilerInlining\" category=\"Java Virtual Machine, Compiler, Optimization\" label=\"Method Inlining\"\n+         description=\"Describes the result of a method inlining attempt\"\n+         thread=\"true\" startTime=\"false\">\n@@ -611,1 +621,3 @@\n-  <Event name=\"CodeCacheFull\" category=\"Java Virtual Machine, Code Cache\" label=\"Code Cache Full\" thread=\"true\" startTime=\"false\">\n+  <Event name=\"CodeCacheFull\" category=\"Java Virtual Machine, Code Cache\" label=\"Code Cache Full\"\n+         description=\"A code heap is full, this leads to disabling the compiler\"\n+         thread=\"true\" startTime=\"false\">\n@@ -624,1 +636,3 @@\n-  <Event name=\"Deoptimization\" category=\"Java Virtual Machine, Compiler\" label=\"Deoptimization\" thread=\"true\" stackTrace=\"true\" startTime=\"false\">\n+  <Event name=\"Deoptimization\" category=\"Java Virtual Machine, Compiler\" label=\"Deoptimization\"\n+         description=\"Describes the detection of an uncommon situation in a compiled method which may lead to deoptimization of the method\"\n+         thread=\"true\" stackTrace=\"true\" startTime=\"false\">\n@@ -709,0 +723,13 @@\n+  <Event name=\"NativeMemoryUsage\" category=\"Java Virtual Machine, Memory\" label=\"Native Memory Usage Per Type\"\n+    description=\"Native memory usage for a given memory type in the JVM\" period=\"everyChunk\">\n+    <Field type=\"string\" name=\"type\" label=\"Memory Type\" description=\"Type used for the native memory allocation\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"reserved\" label=\"Reserved Memory\" description=\"Reserved bytes for this type\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"committed\" label=\"Committed Memory\" description=\"Committed bytes for this type\" \/>\n+  <\/Event>\n+\n+  <Event name=\"NativeMemoryUsageTotal\" category=\"Java Virtual Machine, Memory\" label=\"Total Native Memory Usage\"\n+    description=\"Total native memory usage for the JVM. Might not be the exact sum of the NativeMemoryUsage events due to timeing.\" period=\"everyChunk\">\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"reserved\" label=\"Reserved Memory\" description=\"Total amount of reserved bytes for the JVM\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"committed\" label=\"Committed Memory\" description=\"Total amount of committed bytes for the JVM\" \/>\n+  <\/Event>\n+\n@@ -735,1 +762,3 @@\n-  <Event name=\"OSInformation\" category=\"Operating System\" label=\"OS Information\" period=\"endChunk\">\n+  <Event name=\"OSInformation\" category=\"Operating System\" label=\"OS Information\"\n+         description=\"Description of the OS the JVM runs on, for example, a uname-like output\"\n+         period=\"endChunk\">\n@@ -739,1 +768,3 @@\n-  <Event name=\"VirtualizationInformation\" category=\"Operating System\" label=\"Virtualization Information\" period=\"endChunk\">\n+  <Event name=\"VirtualizationInformation\" category=\"Operating System\" label=\"Virtualization Information\"\n+         description=\"Description of the virtualization technology the JVM runs on\"\n+         period=\"endChunk\">\n@@ -748,1 +779,3 @@\n-  <Event name=\"InitialEnvironmentVariable\" category=\"Operating System\" label=\"Initial Environment Variable\" period=\"endChunk\">\n+  <Event name=\"InitialEnvironmentVariable\" category=\"Operating System\" label=\"Initial Environment Variable\"\n+         description=\"Key-value pairs for environment variables at JVM startup\"\n+         period=\"endChunk\">\n@@ -907,0 +940,1 @@\n+    <Field type=\"boolean\" name=\"dynamicCompilerThreadCount\" label=\"Uses Dynamic Number of Compiler Threads\" \/>\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":44,"deletions":10,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,1 @@\n+  event.set_starttime(timestamp);\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrFinalizerStatisticsEvent.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,0 +63,1 @@\n+  event.set_starttime(invocation_time);\n@@ -71,0 +72,1 @@\n+  event.set_starttime(invocation_time);\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrModuleEvent.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -295,0 +295,1 @@\n+        event.set_starttime(time_stamp);\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrOSInterface.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+#include \"services\/memJfrReporter.hpp\"\n@@ -83,0 +84,12 @@\n+\/\/ Timestamp to correlate events in the same batch\/generation\n+Ticks JfrPeriodicEventSet::_timestamp;\n+PeriodicType JfrPeriodicEventSet::_type;\n+\n+Ticks JfrPeriodicEventSet::timestamp(void) {\n+  return _timestamp;\n+}\n+\n+PeriodicType JfrPeriodicEventSet::type(void) {\n+  return _type;\n+}\n+\n@@ -141,0 +154,1 @@\n+  event.set_starttime(*(JfrTicks*)param);\n@@ -415,0 +429,1 @@\n+      event.set_starttime(time_stamp);\n@@ -441,0 +456,1 @@\n+    event.set_starttime(time_stamp);\n@@ -575,0 +591,1 @@\n+  event.set_dynamicCompilerThreadCount(UseDynamicNumberOfCompilerThreads);\n@@ -627,0 +644,8 @@\n+\n+TRACE_REQUEST_FUNC(NativeMemoryUsage) {\n+  MemJFRReporter::send_type_events();\n+}\n+\n+TRACE_REQUEST_FUNC(NativeMemoryUsageTotal) {\n+  MemJFRReporter::send_total_event();\n+}\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrPeriodic.cpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -123,0 +123,1 @@\n+      event.set_endtime(event_time);\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrThreadCPULoadEvent.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -303,5 +303,5 @@\n-static const juint starttime_offset = sizeof(jlong);\n-static const juint duration_offset = starttime_offset + sizeof(jlong);\n-static const juint checkpoint_type_offset = duration_offset + sizeof(jlong);\n-static const juint types_offset = checkpoint_type_offset + sizeof(juint);\n-static const juint payload_offset = types_offset + sizeof(juint);\n+static const size_t starttime_offset = sizeof(int64_t);\n+static const size_t duration_offset = starttime_offset + sizeof(int64_t);\n+static const size_t checkpoint_type_offset = duration_offset + sizeof(int64_t);\n+static const size_t types_offset = checkpoint_type_offset + sizeof(uint32_t);\n+static const size_t payload_offset = types_offset + sizeof(uint32_t);\n@@ -314,2 +314,4 @@\n-static jlong total_size(const u1* data) {\n-  return read_data<jlong>(data);\n+static size_t total_size(const u1* data) {\n+  const int64_t size = read_data<int64_t>(data);\n+  assert(size > 0, \"invariant\");\n+  return static_cast<size_t>(size);\n@@ -318,2 +320,2 @@\n-static jlong starttime(const u1* data) {\n-  return read_data<jlong>(data + starttime_offset);\n+static int64_t starttime(const u1* data) {\n+  return read_data<int64_t>(data + starttime_offset);\n@@ -322,2 +324,2 @@\n-static jlong duration(const u1* data) {\n-  return read_data<jlong>(data + duration_offset);\n+static int64_t duration(const u1* data) {\n+  return read_data<int64_t>(data + duration_offset);\n@@ -326,2 +328,2 @@\n-static juint checkpoint_type(const u1* data) {\n-  return read_data<juint>(data + checkpoint_type_offset);\n+static int32_t checkpoint_type(const u1* data) {\n+  return read_data<int32_t>(data + checkpoint_type_offset);\n@@ -330,2 +332,2 @@\n-static juint number_of_types(const u1* data) {\n-  return read_data<juint>(data + types_offset);\n+static uint32_t number_of_types(const u1* data) {\n+  return read_data<uint32_t>(data + types_offset);\n@@ -334,8 +336,2 @@\n-static void write_checkpoint_header(JfrChunkWriter& cw, int64_t delta_to_last_checkpoint, const u1* data) {\n-  cw.reserve(sizeof(u4));\n-  cw.write<u8>(EVENT_CHECKPOINT);\n-  cw.write(starttime(data));\n-  cw.write(duration(data));\n-  cw.write(delta_to_last_checkpoint);\n-  cw.write(checkpoint_type(data));\n-  cw.write(number_of_types(data));\n+static size_t payload_size(const u1* data) {\n+  return total_size(data) - sizeof(JfrCheckpointEntry);\n@@ -344,14 +340,10 @@\n-static void write_checkpoint_content(JfrChunkWriter& cw, const u1* data, size_t size) {\n-  assert(data != NULL, \"invariant\");\n-  cw.write_unbuffered(data + payload_offset, size - sizeof(JfrCheckpointEntry));\n-}\n-\n-static size_t write_thread_checkpoint_content(JfrChunkWriter& cw, const u1* data) {\n-  assert(data != NULL, \"invariant\");\n-  const size_t size = total_size(data);\n-  assert(size > sizeof(JfrCheckpointEntry), \"invariant\");\n-  assert(checkpoint_type(data) == THREADS, \"invariant\");\n-  assert(number_of_types(data) == 1, \"invariant\");\n-  \/\/ Thread checkpoints are small so write them buffered to cache as much as possible before flush.\n-  cw.write_buffered(data + payload_offset, size - sizeof(JfrCheckpointEntry));\n-  return size;\n+static uint64_t calculate_event_size_bytes(JfrChunkWriter& cw, const u1* data, int64_t event_begin, int64_t delta_to_last_checkpoint) {\n+  assert(data != nullptr, \"invariant\");\n+  size_t bytes = cw.size_in_bytes(EVENT_CHECKPOINT);\n+  bytes += cw.size_in_bytes(starttime(data));\n+  bytes += cw.size_in_bytes(duration(data));\n+  bytes += cw.size_in_bytes(delta_to_last_checkpoint);\n+  bytes += cw.size_in_bytes(checkpoint_type(data));\n+  bytes += cw.size_in_bytes(number_of_types(data));\n+  bytes += payload_size(data); \/\/ in bytes already.\n+  return bytes + cw.size_in_bytes(bytes + cw.size_in_bytes(bytes));\n@@ -364,6 +356,0 @@\n-  const int64_t delta_to_last_checkpoint = last_checkpoint_event == 0 ? 0 : last_checkpoint_event - event_begin;\n-  const int64_t checkpoint_size = total_size(data);\n-  write_checkpoint_header(cw, delta_to_last_checkpoint, data);\n-  write_checkpoint_content(cw, data, checkpoint_size);\n-  const int64_t event_size = cw.current_offset() - event_begin;\n-  cw.write_padded_at_offset<u4>(event_size, event_begin);\n@@ -371,1 +357,12 @@\n-  return (size_t)checkpoint_size;\n+  const int64_t delta_to_last_checkpoint = last_checkpoint_event == 0 ? 0 : last_checkpoint_event - event_begin;\n+  const uint64_t event_size = calculate_event_size_bytes(cw, data, event_begin, delta_to_last_checkpoint);\n+  cw.write(event_size);\n+  cw.write(EVENT_CHECKPOINT);\n+  cw.write(starttime(data));\n+  cw.write(duration(data));\n+  cw.write(delta_to_last_checkpoint);\n+  cw.write(checkpoint_type(data));\n+  cw.write(number_of_types(data));\n+  cw.write_unbuffered(data + payload_offset, payload_size(data));\n+  assert(static_cast<uint64_t>(cw.current_offset() - event_begin) == event_size, \"invariant\");\n+  return total_size(data);\n@@ -390,0 +387,11 @@\n+static size_t write_thread_checkpoint_content(JfrChunkWriter& cw, const u1* data) {\n+  assert(data != NULL, \"invariant\");\n+  const size_t size = total_size(data);\n+  assert(size > 0, \"invariant\");\n+  assert(checkpoint_type(data) == THREADS, \"invariant\");\n+  assert(number_of_types(data) == 1, \"invariant\");\n+  \/\/ Thread checkpoints are small so write them buffered to cache as much as possible before flush.\n+  cw.write_buffered(data + payload_offset, payload_size(data));\n+  return size;\n+}\n+\n@@ -422,1 +430,0 @@\n-\n@@ -431,1 +438,1 @@\n-  u4 _elements;\n+  uint32_t _elements;\n@@ -437,2 +444,2 @@\n-    cw.reserve(sizeof(u4));\n-    cw.write<u8>(EVENT_CHECKPOINT);\n+    cw.reserve(sizeof(uint64_t));\n+    cw.write(EVENT_CHECKPOINT);\n@@ -446,1 +453,1 @@\n-    cw.reserve(sizeof(u4));\n+    cw.reserve(sizeof(uint32_t));\n@@ -456,2 +463,2 @@\n-    _cw.write_padded_at_offset<u4>(_elements, _elements_offset);\n-    _cw.write_padded_at_offset<u4>(event_size, _begin_offset);\n+    _cw.write_padded_at_offset(_elements, _elements_offset);\n+    _cw.write_padded_at_offset(event_size, _begin_offset);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointManager.cpp","additions":58,"deletions":51,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -277,1 +277,4 @@\n-  HandleMark hm(jt); \/\/ RegisterMap uses Handles to support continuations.\n+  \/\/ Must use ResetNoHandleMark here to bypass if any NoHandleMark exist on stack.\n+  \/\/ This is because RegisterMap uses Handles to support continuations.\n+  ResetNoHandleMark rnhm;\n+  HandleMark hm(jt);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTrace.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,3 @@\n+  template <typename T>\n+  static size_t size_in_bytes(T value);\n+\n@@ -132,0 +135,11 @@\n+template <typename T>\n+inline size_t BigEndianEncoderImpl::size_in_bytes(T value) {\n+  switch (sizeof(T)) {\n+    case 1: return 1;\n+    case 2: return 2;\n+    case 4: return 4;\n+    case 8:return 8;\n+  }\n+  ShouldNotReachHere();\n+  return 0;\n+}\n@@ -163,0 +177,3 @@\n+  template <typename T>\n+  static size_t size_in_bytes(T value);\n+\n@@ -298,0 +315,30 @@\n+template <typename T>\n+inline size_t Varint128EncoderImpl::size_in_bytes(T value) {\n+  const u8 v = to_u8(value);\n+  if (LESS_THAN_128(v)) {\n+    return 1;\n+  }\n+  if (LESS_THAN_128(v >> 7)) {\n+    return 2;\n+  }\n+  if (LESS_THAN_128(v >> 14)) {\n+    return 3;\n+  }\n+  if (LESS_THAN_128(v >> 21)) {\n+    return 4;\n+  }\n+  if (LESS_THAN_128(v >> 28)) {\n+    return 5;\n+  }\n+  if (LESS_THAN_128(v >> 35)) {\n+    return 6;\n+  }\n+  if (LESS_THAN_128(v >> 42)) {\n+    return 7;\n+  }\n+  if (LESS_THAN_128(v >> 49)) {\n+    return 8;\n+  }\n+  return 9;\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrEncoders.hpp","additions":48,"deletions":1,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -72,0 +72,5 @@\n+  template <typename T>\n+  static size_t size_in_bytes(T value) {\n+    return IntegerEncoder::size_in_bytes(value);\n+  }\n+\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrEncoding.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -101,0 +101,2 @@\n+  template <typename T>\n+  size_t size_in_bytes(T value);\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrWriterHost.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -366,0 +366,6 @@\n+template <typename BE, typename IE, typename WriterPolicyImpl>\n+template <typename T>\n+inline size_t WriterHost<BE, IE, WriterPolicyImpl>::size_in_bytes(T value) {\n+  return IE::size_in_bytes(value);\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrWriterHost.inline.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -231,3 +232,11 @@\n-    if (thread != nullptr) {\n-      ResourceMark rm;\n-      tty->print(\"JVMCITrace-%d[%s]:%*c\", level, thread->name(), level, ' ');\n+    if (thread != nullptr && thread->is_Java_thread()) {\n+      ResourceMark rm(thread);\n+      JavaThreadState state = JavaThread::cast(thread)->thread_state();\n+      if (state == _thread_in_vm || state == _thread_in_Java || state == _thread_new) {\n+        tty->print(\"JVMCITrace-%d[%s]:%*c\", level, thread->name(), level, ' ');\n+      } else {\n+        \/\/ According to check_access_thread_state, it's unsafe to\n+        \/\/ resolve the j.l.Thread object unless the thread is in\n+        \/\/ one of the states above.\n+        tty->print(\"JVMCITrace-%d[%s@\" PTR_FORMAT \"]:%*c\", level, thread->type_name(), p2i(thread), level, ' ');\n+      }\n","filename":"src\/hotspot\/share\/jvmci\/jvmci.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -145,2 +145,2 @@\n-  JVMCITraceMark jtm(\"CompilerToVM::\" #name);            \\\n-  C2V_BLOCK(result_type, name, signature)\n+  C2V_BLOCK(result_type, name, signature)                \\\n+  JVMCITraceMark jtm(\"CompilerToVM::\" #name);\n@@ -156,2 +156,2 @@\n-  JVMCITraceMark jtm(\"CompilerToVM::\" #name);            \\\n-  C2V_BLOCK(result_type, name, signature)\n+  C2V_BLOCK(result_type, name, signature)                \\\n+  JVMCITraceMark jtm(\"CompilerToVM::\" #name);\n@@ -506,1 +506,1 @@\n-    JVMCIENV->runtime()->initialize(JVMCIENV);\n+    JVMCIENV->runtime()->initialize(JVMCI_CHECK_NULL);\n@@ -1612,1 +1612,1 @@\n-    GrowableArray<ScopeValue*>* extentLocals = cvf->scope()->locals();\n+    GrowableArray<ScopeValue*>* scopedValues = cvf->scope()->locals();\n@@ -1617,1 +1617,1 @@\n-        if (var->type() == T_OBJECT && extentLocals->at(i2)->is_object()) {\n+        if (var->type() == T_OBJECT && scopedValues->at(i2)->is_object()) {\n@@ -2315,1 +2315,0 @@\n-  JVMCITraceMark jtm(\"isCurrentThreadAttached\");\n@@ -2318,0 +2317,1 @@\n+    JVMCITraceMark jtm(\"isCurrentThreadAttached\");\n@@ -2334,1 +2334,0 @@\n-  JVMCITraceMark jtm(\"getCurrentJavaThread\");\n@@ -2380,1 +2379,0 @@\n-  JVMCITraceMark jtm(\"attachCurrentThread\");\n@@ -2384,0 +2382,1 @@\n+    JVMCITraceMark jtm(\"attachCurrentThread\");\n@@ -2438,1 +2437,0 @@\n-  JVMCITraceMark jtm(\"detachCurrentThread\");\n@@ -2442,0 +2440,1 @@\n+    JVMCITraceMark jtm(\"detachCurrentThread\");\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"runtime\/thread.inline.hpp\"\n@@ -47,0 +48,3 @@\n+jbyte* JVMCIEnv::_serialized_saved_properties = nullptr;\n+int JVMCIEnv::_serialized_saved_properties_len = 0;\n+\n@@ -101,4 +105,6 @@\n-void JVMCIEnv::copy_saved_properties() {\n-  assert(!is_hotspot(), \"can only copy saved properties from HotSpot to native image\");\n-\n-  JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n+jbyte* JVMCIEnv::get_serialized_saved_properties(int& props_len, TRAPS) {\n+  jbyte* props = _serialized_saved_properties;\n+  if (props == nullptr) {\n+    \/\/ load VMSupport\n+    Symbol* klass = vmSymbols::jdk_internal_vm_VMSupport();\n+    Klass* k = SystemDictionary::resolve_or_fail(klass, true, CHECK_NULL);\n@@ -106,9 +112,3 @@\n-  Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_vm_ci_services_Services(), Handle(), Handle(), true, THREAD);\n-  if (HAS_PENDING_EXCEPTION) {\n-    JVMCIRuntime::fatal_exception(NULL, \"Error initializing jdk.vm.ci.services.Services\");\n-  }\n-  InstanceKlass* ik = InstanceKlass::cast(k);\n-  if (ik->should_be_initialized()) {\n-    ik->initialize(THREAD);\n-    if (HAS_PENDING_EXCEPTION) {\n-      JVMCIRuntime::fatal_exception(NULL, \"Error initializing jdk.vm.ci.services.Services\");\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+    if (ik->should_be_initialized()) {\n+      ik->initialize(CHECK_NULL);\n@@ -116,1 +116,0 @@\n-  }\n@@ -118,7 +117,26 @@\n-  \/\/ Get the serialized saved properties from HotSpot\n-  TempNewSymbol serializeSavedProperties = SymbolTable::new_symbol(\"serializeSavedProperties\");\n-  JavaValue result(T_OBJECT);\n-  JavaCallArguments args;\n-  JavaCalls::call_static(&result, ik, serializeSavedProperties, vmSymbols::void_byte_array_signature(), &args, THREAD);\n-  if (HAS_PENDING_EXCEPTION) {\n-    JVMCIRuntime::fatal_exception(NULL, \"Error calling jdk.vm.ci.services.Services.serializeSavedProperties\");\n+    \/\/ invoke the serializeSavedPropertiesToByteArray method\n+    JavaValue result(T_OBJECT);\n+    JavaCallArguments args;\n+\n+    Symbol* signature = vmSymbols::void_byte_array_signature();\n+    JavaCalls::call_static(&result,\n+                           ik,\n+                           vmSymbols::serializeSavedPropertiesToByteArray_name(),\n+                           signature,\n+                           &args,\n+                           CHECK_NULL);\n+\n+    oop res = result.get_oop();\n+    assert(res->is_typeArray(), \"must be\");\n+    assert(TypeArrayKlass::cast(res->klass())->element_type() == T_BYTE, \"must be\");\n+    typeArrayOop ba = typeArrayOop(res);\n+    props_len = ba->length();\n+\n+    \/\/ Copy serialized saved properties from HotSpot object into C heap\n+    props = NEW_C_HEAP_ARRAY(jbyte, props_len, mtJVMCI);\n+    memcpy(props, ba->byte_at_addr(0), props_len);\n+\n+    _serialized_saved_properties_len = props_len;\n+    _serialized_saved_properties = props;\n+  } else {\n+    props_len = _serialized_saved_properties_len;\n@@ -126,5 +144,2 @@\n-  oop res = result.get_oop();\n-  assert(res->is_typeArray(), \"must be\");\n-  assert(TypeArrayKlass::cast(res->klass())->element_type() == T_BYTE, \"must be\");\n-  typeArrayOop ba = typeArrayOop(res);\n-  int serialized_properties_len = ba->length();\n+  return props;\n+}\n@@ -132,3 +147,3 @@\n-  \/\/ Copy serialized saved properties from HotSpot object into native buffer\n-  jbyte* serialized_properties = NEW_RESOURCE_ARRAY(jbyte, serialized_properties_len);\n-  memcpy(serialized_properties, ba->byte_at_addr(0), serialized_properties_len);\n+void JVMCIEnv::copy_saved_properties(jbyte* properties, int properties_len, JVMCI_TRAPS) {\n+  assert(!is_hotspot(), \"can only copy saved properties from HotSpot to native image\");\n+  JavaThread* thread = JavaThread::current(); \/\/ For exception macros.\n@@ -137,1 +152,1 @@\n-  JVMCIPrimitiveArray buf = new_byteArray(serialized_properties_len, this);\n+  JVMCIPrimitiveArray buf = new_byteArray(properties_len, this);\n@@ -139,2 +154,1 @@\n-    describe_pending_exception(true);\n-    fatal(\"Error in copy_saved_properties\");\n+    _runtime->fatal_exception(JVMCIENV, \"Error in copy_saved_properties\");\n@@ -142,1 +156,1 @@\n-  copy_bytes_from(serialized_properties, buf, 0, serialized_properties_len);\n+  copy_bytes_from(properties, buf, 0, properties_len);\n@@ -144,2 +158,1 @@\n-    describe_pending_exception(true);\n-    fatal(\"Error in copy_saved_properties\");\n+    _runtime->fatal_exception(JVMCIENV, \"Error in copy_saved_properties\");\n@@ -151,5 +164,8 @@\n-  JNIAccessMark jni(this, THREAD);\n-  jni()->CallStaticVoidMethod(servicesClass, initializeSavedProperties, buf.as_jobject());\n-  if (jni()->ExceptionCheck()) {\n-    jni()->ExceptionDescribe();\n-    fatal(\"Error calling jdk.vm.ci.services.Services.initializeSavedProperties\");\n+  bool exception = false;\n+  {\n+    JNIAccessMark jni(this, thread);\n+    jni()->CallStaticVoidMethod(servicesClass, initializeSavedProperties, buf.as_jobject());\n+    exception = jni()->ExceptionCheck();\n+  }\n+  if (exception) {\n+    _runtime->fatal_exception(JVMCIENV, \"Error calling jdk.vm.ci.services.Services.initializeSavedProperties\");\n@@ -305,1 +321,1 @@\n-  virtual int encode(JavaThread* THREAD, Klass* runtimeKlass, jlong buffer, int buffer_size) = 0;\n+  virtual int encode(JavaThread* THREAD, Klass* vmSupport, jlong buffer, int buffer_size) = 0;\n@@ -308,1 +324,1 @@\n-  virtual void decode(JavaThread* THREAD, Klass* runtimeKlass, jlong buffer) = 0;\n+  virtual void decode(JavaThread* THREAD, Klass* vmSupport, jlong buffer) = 0;\n@@ -312,1 +328,1 @@\n-    \/\/ Resolve HotSpotJVMCIRuntime class explicitly as HotSpotJVMCI::compute_offsets\n+    \/\/ Resolve VMSupport class explicitly as HotSpotJVMCI::compute_offsets\n@@ -314,1 +330,2 @@\n-    Klass* runtimeKlass = SystemDictionary::resolve_or_fail(vmSymbols::jdk_vm_ci_hotspot_HotSpotJVMCIRuntime(), true, CHECK);\n+    Klass* vmSupport = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_vm_VMSupport(), true, THREAD);\n+    guarantee(!HAS_PENDING_EXCEPTION, \"\");\n@@ -321,1 +338,1 @@\n-        decode(THREAD, runtimeKlass, 0L);\n+        decode(THREAD, vmSupport, 0L);\n@@ -324,1 +341,1 @@\n-      int res = encode(THREAD, runtimeKlass, buffer, buffer_size);\n+      int res = encode(THREAD, vmSupport, buffer, buffer_size);\n@@ -329,1 +346,1 @@\n-        decode(THREAD, runtimeKlass, -2L);\n+        decode(THREAD, vmSupport, -2L);\n@@ -335,1 +352,1 @@\n-          decode(THREAD, runtimeKlass, -1L);\n+          decode(THREAD, vmSupport, -1L);\n@@ -337,1 +354,1 @@\n-          decode(THREAD, runtimeKlass, -2L);\n+          decode(THREAD, vmSupport, -2L);\n@@ -346,1 +363,1 @@\n-        decode(THREAD, runtimeKlass, buffer);\n+        decode(THREAD, vmSupport, buffer);\n@@ -348,1 +365,1 @@\n-          _to_env->throw_InternalError(\"HotSpotJVMCIRuntime.decodeAndThrowThrowable should have thrown an exception\");\n+          _to_env->throw_InternalError(\"decodeAndThrowThrowable should have thrown an exception\");\n@@ -361,1 +378,1 @@\n-  int encode(JavaThread* THREAD, Klass* runtimeKlass, jlong buffer, int buffer_size) {\n+  int encode(JavaThread* THREAD, Klass* vmSupport, jlong buffer, int buffer_size) {\n@@ -368,1 +385,1 @@\n-                            runtimeKlass,\n+                            vmSupport,\n@@ -374,1 +391,1 @@\n-  void decode(JavaThread* THREAD, Klass* runtimeKlass, jlong buffer) {\n+  void decode(JavaThread* THREAD, Klass* vmSupport, jlong buffer) {\n@@ -376,2 +393,2 @@\n-    jni()->CallStaticVoidMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(),\n-                                JNIJVMCI::HotSpotJVMCIRuntime::decodeAndThrowThrowable_method(),\n+    jni()->CallStaticVoidMethod(JNIJVMCI::VMSupport::clazz(),\n+                                JNIJVMCI::VMSupport::decodeAndThrowThrowable_method(),\n@@ -390,1 +407,1 @@\n-  int encode(JavaThread* THREAD, Klass* runtimeKlass, jlong buffer, int buffer_size) {\n+  int encode(JavaThread* THREAD, Klass* vmSupport, jlong buffer, int buffer_size) {\n@@ -392,2 +409,2 @@\n-    return jni()->CallStaticIntMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(),\n-                                      JNIJVMCI::HotSpotJVMCIRuntime::encodeThrowable_method(),\n+    return jni()->CallStaticIntMethod(JNIJVMCI::VMSupport::clazz(),\n+                                      JNIJVMCI::VMSupport::encodeThrowable_method(),\n@@ -397,1 +414,1 @@\n-  void decode(JavaThread* THREAD, Klass* runtimeKlass, jlong buffer) {\n+  void decode(JavaThread* THREAD, Klass* vmSupport, jlong buffer) {\n@@ -402,1 +419,1 @@\n-                            runtimeKlass,\n+                            vmSupport,\n@@ -419,0 +436,10 @@\n+jboolean JVMCIEnv::transfer_pending_exception_to_jni(JavaThread* THREAD, JVMCIEnv* hotspot_env, JVMCIEnv* jni_env) {\n+  if (HAS_PENDING_EXCEPTION) {\n+    Handle throwable = Handle(THREAD, PENDING_EXCEPTION);\n+    CLEAR_PENDING_EXCEPTION;\n+    translate_to_jni_exception(THREAD, throwable, hotspot_env, jni_env);\n+    return true;\n+  }\n+  return false;\n+}\n+\n@@ -421,15 +448,6 @@\n-    if (HAS_PENDING_EXCEPTION) {\n-      Handle throwable = Handle(THREAD, PENDING_EXCEPTION);\n-      CLEAR_PENDING_EXCEPTION;\n-      translate_to_jni_exception(THREAD, throwable, this, peer_env);\n-      return true;\n-    }\n-  } else {\n-    jthrowable ex = nullptr;\n-    {\n-      JNIAccessMark jni(this, THREAD);\n-      ex = jni()->ExceptionOccurred();\n-      if (ex != nullptr) {\n-        jni()->ExceptionClear();\n-      }\n-    }\n+    return transfer_pending_exception_to_jni(THREAD, this, peer_env);\n+  }\n+  jthrowable ex = nullptr;\n+  {\n+    JNIAccessMark jni(this, THREAD);\n+    ex = jni()->ExceptionOccurred();\n@@ -437,2 +455,1 @@\n-      translate_from_jni_exception(THREAD, ex, peer_env, this);\n-      return true;\n+      jni()->ExceptionClear();\n@@ -441,0 +458,4 @@\n+  if (ex != nullptr) {\n+    translate_from_jni_exception(THREAD, ex, peer_env, this);\n+    return true;\n+  }\n@@ -444,1 +465,0 @@\n-\n@@ -472,1 +492,2 @@\n-      jio_snprintf(message, 256, \"Uncaught exception exiting JVMCIEnv scope entered at %s:%d\", _file, _line);\n+      jio_snprintf(message, 256, \"Uncaught exception exiting %s JVMCIEnv scope entered at %s:%d\",\n+          is_hotspot() ? \"HotSpot\" : \"libjvmci\", _file, _line);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":101,"deletions":80,"binary":false,"changes":181,"status":"modified"},{"patch":"@@ -183,0 +183,6 @@\n+  \/\/ Used by copy_saved_properties() to avoid OutOfMemoryErrors when\n+  \/\/ initializing a libjvmci runtime in low HotSpot heap conditions.\n+  \/\/ Must hold JVMCI_lock when initializing.\n+  static jbyte* _serialized_saved_properties;\n+  static int _serialized_saved_properties_len;\n+\n@@ -224,3 +230,7 @@\n-  \/\/ Initializes Services.savedProperties in the shared library by copying\n-  \/\/ the values from the same field in the HotSpot heap.\n-  void copy_saved_properties();\n+  \/\/ Gets the serialized saved properties from the HotSpot heap.\n+  \/\/ The length of the returned array is saved in `len`.\n+  jbyte* get_serialized_saved_properties(int& len, TRAPS);\n+\n+  \/\/ Initializes Services.savedProperties in the shared library from the given\n+  \/\/ properties in the format produced by `get_serialized_saved_properties`.\n+  void copy_saved_properties(jbyte* properties, int properties_len, JVMCI_TRAPS);\n@@ -236,0 +246,5 @@\n+  \/\/ If there is a pending HotSpot exception, clears it and translates it to the shared library heap.\n+  \/\/ The translated exception is pending in the shared library upon returning.\n+  \/\/ Returns true if a pending exception was transferred, false otherwise.\n+  static jboolean transfer_pending_exception_to_jni(JavaThread* THREAD, JVMCIEnv* hotspot_env, JVMCIEnv* jni_env);\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.hpp","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -349,1 +349,1 @@\n-      \/* values across all JavaVMs executing on the same native image. *\/                   \\\n+      \/* value across all JavaVMs executing on the same native image. *\/                    \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciJavaClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -194,2 +194,0 @@\n-    jvmci_method(CallStaticBooleanMethod, GetStaticMethodID, call_static, bool, HotSpotJVMCIRuntime, encodeThrowable, encodeThrowable_signature, (JVMCIObject throwable, jlong buffer, int buffer_size)) \\\n-    jvmci_method(CallStaticVoidMethod, GetStaticMethodID, call_static, void, HotSpotJVMCIRuntime, decodeAndThrowThrowable, long_void_signature, (jlong buffer)) \\\n@@ -219,0 +217,4 @@\n+  start_class(VMSupport, jdk_internal_vm_VMSupport)                                                           \\\n+    jvmci_method(CallStaticIntMethod, GetStaticMethodID, call_static, int, VMSupport, encodeThrowable, encodeThrowable_signature, (JVMCIObject throwable, jlong buffer, int buffer_size)) \\\n+    jvmci_method(CallStaticVoidMethod, GetStaticMethodID, call_static, void, VMSupport, decodeAndThrowThrowable, long_void_signature, (jlong buffer)) \\\n+  end_class                                                                                                   \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciJavaClasses.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -752,1 +752,1 @@\n-  initialize(JVMCIENV);\n+  initialize(JVMCI_CHECK);\n@@ -1318,1 +1318,1 @@\n-  initialize(JVMCIENV);\n+  initialize(JVMCI_CHECK);\n@@ -1373,1 +1373,1 @@\n-void JVMCIRuntime::initialize(JVMCIEnv* JVMCIENV) {\n+void JVMCIRuntime::initialize(JVMCI_TRAPS) {\n@@ -1379,0 +1379,5 @@\n+  JavaThread* THREAD = JavaThread::current();\n+\n+  int properties_len = 0;\n+  jbyte* properties = NULL;\n+\n@@ -1400,1 +1405,0 @@\n-    JavaThread* THREAD = JavaThread::current();\n@@ -1444,1 +1448,6 @@\n-      JVMCIENV->copy_saved_properties();\n+      Handle properties_exception;\n+      properties = JVMCIENV->get_serialized_saved_properties(properties_len, THREAD);\n+      if (JVMCIEnv::transfer_pending_exception_to_jni(THREAD, nullptr, JVMCIENV)) {\n+        return;\n+      }\n+      JVMCIENV->copy_saved_properties(properties, properties_len, JVMCI_CHECK);\n@@ -1487,1 +1496,1 @@\n-  initialize(JVMCIENV);\n+  initialize(JVMCI_CHECK_(JVMCIObject()));\n@@ -1995,1 +2004,7 @@\n-    fatal_exception(JVMCIENV, \"Exception during HotSpotJVMCIRuntime initialization\");\n+    if (PrintWarnings) {\n+      ResourceMark rm(thread);\n+      warning(\"HotSpotJVMCIRuntime initialization failed when compiling %s\", method->name_and_sig_as_C_string());\n+      JVMCIENV->describe_pending_exception(true);\n+    }\n+    compile_state->set_failure(false, \"exception during HotSpotJVMCIRuntime initialization\");\n+    return;\n@@ -1999,1 +2014,5 @@\n-    JVMCIENV->describe_pending_exception(true);\n+    if (PrintWarnings) {\n+      ResourceMark rm(thread);\n+      warning(\"Error creating JVMCI wrapper for %s\", method->name_and_sig_as_C_string());\n+      JVMCIENV->describe_pending_exception(true);\n+    }\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":27,"deletions":8,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -177,1 +177,1 @@\n-  nonstatic_field(JavaThread,                  _extentLocalCache,                             OopHandle)                             \\\n+  nonstatic_field(JavaThread,                  _scopedValueCache,                             OopHandle)                             \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,3 +82,0 @@\n-  template(encodeThrowable_name,                                  \"encodeThrowable\")                                                      \\\n-  template(encodeThrowable_signature,                             \"(Ljava\/lang\/Throwable;JI)I\")                                           \\\n-  template(decodeAndThrowThrowable_name,                          \"decodeAndThrowThrowable\")                                              \\\n","filename":"src\/hotspot\/share\/jvmci\/vmSymbols_jvmci.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -678,0 +678,1 @@\n+  out->cr();\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -276,4 +276,0 @@\n-  if (UseMallocOnly && _first != NULL) {\n-    char* end = _first->next() ? _first->top() : _hwm;\n-    free_malloced_objects(_first, _first->bottom(), end, _hwm);\n-  }\n@@ -345,13 +341,0 @@\n-#ifdef ASSERT\n-  if (UseMallocOnly) {\n-    \/\/ always allocate a new object  (otherwise we'll free this one twice)\n-    char* copy = (char*)Amalloc(new_size, alloc_failmode);\n-    if (copy == NULL) {\n-      return NULL;\n-    }\n-    size_t n = MIN2(old_size, new_size);\n-    if (n > 0) memcpy(copy, old_ptr, n);\n-    Afree(old_ptr,old_size);    \/\/ Mostly done to keep stats accurate\n-    return copy;\n-  }\n-#endif\n@@ -389,18 +372,0 @@\n-#ifdef ASSERT\n-  if (UseMallocOnly) {\n-    \/\/ really slow, but not easy to make fast\n-    if (_chunk == NULL) return false;\n-    char** bottom = (char**)_chunk->bottom();\n-    for (char** p = (char**)_hwm - 1; p >= bottom; p--) {\n-      if (*p == ptr) return true;\n-    }\n-    for (Chunk *c = _first; c != NULL; c = c->next()) {\n-      if (c == _chunk) continue;  \/\/ current chunk has been processed\n-      char** bottom = (char**)c->bottom();\n-      for (char** p = (char**)c->top() - 1; p >= bottom; p--) {\n-        if (*p == ptr) return true;\n-      }\n-    }\n-    return false;\n-  }\n-#endif\n@@ -417,48 +382,0 @@\n-\n-\n-#ifdef ASSERT\n-void* Arena::malloc(size_t size) {\n-  assert(UseMallocOnly, \"shouldn't call\");\n-  \/\/ use malloc, but save pointer in res. area for later freeing\n-  char** save = (char**)internal_amalloc(sizeof(char*));\n-  return (*save = (char*)os::malloc(size, mtChunk));\n-}\n-#endif\n-\n-\n-\/\/--------------------------------------------------------------------------------------\n-\/\/ Non-product code\n-\n-#ifndef PRODUCT\n-\n-\/\/ debugging code\n-inline void Arena::free_all(char** start, char** end) {\n-  for (char** p = start; p < end; p++) if (*p) os::free(*p);\n-}\n-\n-void Arena::free_malloced_objects(Chunk* chunk, char* hwm, char* max, char* hwm2) {\n-  assert(UseMallocOnly, \"should not call\");\n-  \/\/ free all objects malloced since resource mark was created; resource area\n-  \/\/ contains their addresses\n-  if (chunk->next()) {\n-    \/\/ this chunk is full, and some others too\n-    for (Chunk* c = chunk->next(); c != NULL; c = c->next()) {\n-      char* top = c->top();\n-      if (c->next() == NULL) {\n-        top = hwm2;     \/\/ last junk is only used up to hwm2\n-        assert(c->contains(hwm2), \"bad hwm2\");\n-      }\n-      free_all((char**)c->bottom(), (char**)top);\n-    }\n-    assert(chunk->contains(hwm), \"bad hwm\");\n-    assert(chunk->contains(max), \"bad max\");\n-    free_all((char**)hwm, (char**)max);\n-  } else {\n-    \/\/ this chunk was partially used\n-    assert(chunk->contains(hwm), \"bad hwm\");\n-    assert(chunk->contains(hwm2), \"bad hwm2\");\n-    free_all((char**)hwm, (char**)hwm2);\n-  }\n-}\n-\n-#endif \/\/ Non-product\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":0,"deletions":83,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -104,2 +104,0 @@\n-  debug_only(void* malloc(size_t size);)\n-\n@@ -128,1 +126,0 @@\n-    debug_only(if (UseMallocOnly) return malloc(x);)\n@@ -141,1 +138,0 @@\n-    debug_only(if (UseMallocOnly) return malloc(x);)\n@@ -152,1 +148,0 @@\n-    if (UseMallocOnly) return true;\n@@ -179,3 +174,0 @@\n-  static void free_malloced_objects(Chunk* chunk, char* hwm, char* max, char* hwm2)  PRODUCT_RETURN;\n-  static void free_all(char** start, char** end)                                     PRODUCT_RETURN;\n-\n","filename":"src\/hotspot\/share\/memory\/arena.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -108,4 +108,0 @@\n-    if (UseMallocOnly) {\n-      free_malloced_objects(state._chunk, state._hwm, state._max, _hwm);\n-    }\n-\n","filename":"src\/hotspot\/share\/memory\/resourceArea.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,5 +35,0 @@\n-  if (UseMallocOnly) {\n-    \/\/ use malloc, but save pointer in res. area for later freeing\n-    char** save = (char**)internal_amalloc(sizeof(char*));\n-    return (*save = (char*)os::malloc(size, mtThread, CURRENT_PC));\n-  }\n","filename":"src\/hotspot\/share\/memory\/resourceArea.inline.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -239,1 +239,3 @@\n-  inline DecoratorSet decorator_fixup(DecoratorSet input_decorators) {\n+  inline DecoratorSet decorator_fixup(DecoratorSet input_decorators, BasicType type) {\n+    \/\/ Some call-sites don't specify that the access is performed on oops\n+    DecoratorSet with_oop_decorators = input_decorators |= (is_reference_type(type) ? INTERNAL_VALUE_IS_OOP : 0);\n@@ -241,2 +243,2 @@\n-    DecoratorSet ref_strength_default = input_decorators |\n-      (((ON_DECORATOR_MASK & input_decorators) == 0 && (INTERNAL_VALUE_IS_OOP & input_decorators) != 0) ?\n+    DecoratorSet ref_strength_default = with_oop_decorators |\n+      (((ON_DECORATOR_MASK & with_oop_decorators) == 0 && (INTERNAL_VALUE_IS_OOP & input_decorators) != 0) ?\n","filename":"src\/hotspot\/share\/oops\/accessDecorators.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/javaClasses.inline.hpp\"\n@@ -68,4 +68,0 @@\n-void Klass::replace_java_mirror(oop mirror) {\n-  _java_mirror.replace(mirror);\n-}\n-\n@@ -791,1 +787,1 @@\n-    guarantee(oopDesc::is_oop(java_mirror_no_keepalive()), \"should be instance\");\n+    guarantee(java_lang_Class::is_instance(java_mirror_no_keepalive()), \"should be instance\");\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -272,1 +272,2 @@\n-  void replace_java_mirror(oop mirror);\n+  OopHandle java_mirror_handle() const { return _java_mirror; }\n+  void swap_java_mirror_handle(OopHandle& mirror) { _java_mirror.swap(mirror); }\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -725,1 +725,2 @@\n-\n+  \/\/ Some special methods don't need to be findable by nmethod iterators and are permanent.\n+  bool can_be_allocated_in_NonNMethod_space() const { return is_method_handle_intrinsic(); }\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,4 @@\n+  void swap(OopHandle& copy) {\n+    ::swap(_obj, copy._obj);\n+  }\n+\n@@ -69,1 +73,0 @@\n-  \/\/ Used only for removing handle.\n","filename":"src\/hotspot\/share\/oops\/oopHandle.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -683,2 +683,2 @@\n-  case vmIntrinsics::_extentLocalCache:\n-  case vmIntrinsics::_setExtentLocalCache:\n+  case vmIntrinsics::_scopedValueCache:\n+  case vmIntrinsics::_setScopedValueCache:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"opto\/regalloc.hpp\"\n@@ -621,1 +622,1 @@\n-          assert(opaq->Opcode() == Op_Opaque1, \"\");\n+          assert(opaq->Opcode() == Op_OpaqueZeroTripGuard, \"\");\n@@ -2817,0 +2818,22 @@\n+\n+#ifndef PRODUCT\n+void BlackholeNode::format(PhaseRegAlloc* ra, outputStream* st) const {\n+  st->print(\"blackhole \");\n+  bool first = true;\n+  for (uint i = 0; i < req(); i++) {\n+    Node* n = in(i);\n+    if (n != NULL && OptoReg::is_valid(ra->get_reg_first(n))) {\n+      if (first) {\n+        first = false;\n+      } else {\n+        st->print(\", \");\n+      }\n+      char buf[128];\n+      ra->dump_register(n, buf);\n+      st->print(\"%s\", buf);\n+    }\n+  }\n+  st->cr();\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+class     BlackholeNode;\n@@ -607,0 +608,24 @@\n+\/\/------------------------------BlackholeNode----------------------------\n+\/\/ Blackhole all arguments. This node would survive through the compiler\n+\/\/ the effects on its arguments, and would be finally matched to nothing.\n+class BlackholeNode : public MultiNode {\n+public:\n+  BlackholeNode(Node* ctrl) : MultiNode(1) {\n+    init_req(TypeFunc::Control, ctrl);\n+  }\n+  virtual int   Opcode() const;\n+  virtual uint ideal_reg() const { return 0; } \/\/ not matched in the AD file\n+  virtual const Type* bottom_type() const { return TypeTuple::MEMBAR; }\n+\n+  const RegMask &in_RegMask(uint idx) const {\n+    \/\/ Fake the incoming arguments mask for blackholes: accept all registers\n+    \/\/ and all stack slots. This would avoid any redundant register moves\n+    \/\/ for blackhole inputs.\n+    return RegMask::All;\n+  }\n+#ifndef PRODUCT\n+  virtual void format(PhaseRegAlloc* ra, outputStream* st) const;\n+#endif\n+};\n+\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -271,1 +271,1 @@\n-macro(Opaque2)\n+macro(OpaqueZeroTripGuard)\n@@ -509,0 +509,2 @@\n+macro(VectorCastF2HF)\n+macro(VectorCastHF2F)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3164,1 +3164,0 @@\n-  case Op_Opaque2:              \/\/ Remove Opaque Nodes before matching\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -736,0 +736,1 @@\n+    ctrl->in(0)->in(1)->in(1)->in(1) != igvn->C->top() &&\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -475,2 +475,2 @@\n-  case vmIntrinsics::_extentLocalCache:          return inline_native_extentLocalCache();\n-  case vmIntrinsics::_setExtentLocalCache:       return inline_native_setExtentLocalCache();\n+  case vmIntrinsics::_scopedValueCache:          return inline_native_scopedValueCache();\n+  case vmIntrinsics::_setScopedValueCache:       return inline_native_setScopedValueCache();\n@@ -3360,1 +3360,1 @@\n-Node* LibraryCallKit::extentLocalCache_helper() {\n+Node* LibraryCallKit::scopedValueCache_helper() {\n@@ -3367,3 +3367,7 @@\n-  Node* p = basic_plus_adr(top()\/*!oop*\/, thread, in_bytes(JavaThread::extentLocalCache_offset()));\n-  return _gvn.transform(LoadNode::make(_gvn, NULL, immutable_memory(), p, p->bottom_type()->is_ptr(),\n-        TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered));\n+  Node* p = basic_plus_adr(top()\/*!oop*\/, thread, in_bytes(JavaThread::scopedValueCache_offset()));\n+  \/\/ We cannot use immutable_memory() because we might flip onto a\n+  \/\/ different carrier thread, at which point we'll need to use that\n+  \/\/ carrier thread's cache.\n+  \/\/ return _gvn.transform(LoadNode::make(_gvn, NULL, immutable_memory(), p, p->bottom_type()->is_ptr(),\n+  \/\/       TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered));\n+  return make_load(NULL, p, p->bottom_type()->is_ptr(), T_ADDRESS, MemNode::unordered);\n@@ -3372,2 +3376,2 @@\n-\/\/------------------------inline_native_extentLocalCache------------------\n-bool LibraryCallKit::inline_native_extentLocalCache() {\n+\/\/------------------------inline_native_scopedValueCache------------------\n+bool LibraryCallKit::inline_native_scopedValueCache() {\n@@ -3378,1 +3382,1 @@\n-  \/\/ Because we create the extentLocal cache lazily we have to make the\n+  \/\/ Because we create the scopedValue cache lazily we have to make the\n@@ -3382,1 +3386,1 @@\n-  Node* cache_obj_handle = extentLocalCache_helper();\n+  Node* cache_obj_handle = scopedValueCache_helper();\n@@ -3388,2 +3392,2 @@\n-\/\/------------------------inline_native_setExtentLocalCache------------------\n-bool LibraryCallKit::inline_native_setExtentLocalCache() {\n+\/\/------------------------inline_native_setScopedValueCache------------------\n+bool LibraryCallKit::inline_native_setScopedValueCache() {\n@@ -3391,1 +3395,1 @@\n-  Node* cache_obj_handle = extentLocalCache_helper();\n+  Node* cache_obj_handle = scopedValueCache_helper();\n@@ -7844,0 +7848,8 @@\n+  \/\/ Blackhole node pinches only the control, not memory. This allows\n+  \/\/ the blackhole to be pinned in the loop that computes blackholed\n+  \/\/ values, but have no other side effects, like breaking the optimizations\n+  \/\/ across the blackhole.\n+\n+  Node* bh = _gvn.transform(new BlackholeNode(control()));\n+  set_control(_gvn.transform(new ProjNode(bh, TypeFunc::Control)));\n+\n@@ -7845,1 +7857,0 @@\n-  Node* bh = insert_mem_bar(Op_Blackhole);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":25,"deletions":14,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -242,3 +242,3 @@\n-  bool inline_native_extentLocalCache();\n-  Node* extentLocalCache_helper();\n-  bool inline_native_setExtentLocalCache();\n+  bool inline_native_scopedValueCache();\n+  Node* scopedValueCache_helper();\n+  bool inline_native_setScopedValueCache();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -112,3 +112,3 @@\n-                                                      Deoptimization::DeoptReason reason, int opcode,\n-                                                      bool if_cont_is_true_proj, Node_List* old_new,\n-                                                      UnswitchingAction unswitching_action) {\n+                                                      Deoptimization::DeoptReason reason,\n+                                                      const int opcode, const bool rewire_uncommon_proj_phi_inputs,\n+                                                      const bool if_cont_is_true_proj) {\n@@ -199,14 +199,13 @@\n-      if (unswitching_action == UnswitchingAction::FastLoopCloning\n-          && !phi_input->is_CFG() && !phi_input->is_Phi() && get_ctrl(phi_input) == uncommon_proj) {\n-        \/\/ There are some control dependent nodes on the uncommon projection and we are currently copying predicates\n-        \/\/ to the fast loop in loop unswitching (first step, slow loop is processed afterwards). For the fast loop,\n-        \/\/ we need to clone all the data nodes in the chain from the phi ('use') up until the node whose control input\n-        \/\/ is the uncommon_proj. The slow loop can reuse the old data nodes and thus only needs to update the control\n-        \/\/ input to the uncommon_proj (done on the next invocation of this method when 'unswitch_is_slow_loop' is true.\n-        assert(LoopUnswitching, \"sanity check\");\n-        phi_input = clone_data_nodes_for_fast_loop(phi_input, uncommon_proj, if_uct, old_new);\n-      } else if (unswitching_action == UnswitchingAction::SlowLoopRewiring) {\n-        \/\/ Replace phi input for the old predicate path with TOP as the predicate is dying anyways. This avoids the need\n-        \/\/ to clone the data nodes again for the slow loop.\n-        assert(LoopUnswitching, \"sanity check\");\n-        _igvn.replace_input_of(use, proj_index, C->top());\n+\n+      if (uncommon_proj->outcnt() > 1 && !phi_input->is_CFG() && !phi_input->is_Phi() && get_ctrl(phi_input) == uncommon_proj) {\n+        \/\/ There are some control dependent nodes on the uncommon projection. We cannot simply reuse these data nodes.\n+        \/\/ We either need to rewire them from the old uncommon projection to the newly created uncommon proj (if the old\n+        \/\/ If is dying) or clone them and update their control (if the old If is not dying).\n+        if (rewire_uncommon_proj_phi_inputs) {\n+          \/\/ Replace phi input for the old uncommon projection with TOP as the If is dying anyways. Reuse the old data\n+          \/\/ nodes by simply updating control inputs and ctrl.\n+          _igvn.replace_input_of(use, proj_index, C->top());\n+          set_ctrl_of_nodes_with_same_ctrl(phi_input, uncommon_proj, if_uct);\n+        } else {\n+          phi_input = clone_nodes_with_same_ctrl(phi_input, uncommon_proj, if_uct);\n+        }\n@@ -219,13 +218,0 @@\n-  if (unswitching_action == UnswitchingAction::SlowLoopRewiring) {\n-    \/\/ Rewire the control dependent data nodes for the slow loop from the old to the new uncommon projection.\n-    assert(uncommon_proj->outcnt() > 1 && old_new == NULL, \"sanity\");\n-    for (DUIterator_Fast jmax, j = uncommon_proj->fast_outs(jmax); j < jmax; j++) {\n-      Node* data = uncommon_proj->fast_out(j);\n-      if (!data->is_CFG()) {\n-        _igvn.replace_input_of(data, 0, if_uct);\n-        set_ctrl(data, if_uct);\n-        --j;\n-        --jmax;\n-      }\n-    }\n-  }\n@@ -243,13 +229,19 @@\n-\/\/ Clone data nodes for the fast loop while creating a new If with create_new_if_for_predicate. Returns the node which is\n-\/\/ used for the uncommon trap phi input.\n-Node* PhaseIdealLoop::clone_data_nodes_for_fast_loop(Node* phi_input, ProjNode* uncommon_proj, Node* if_uct, Node_List* old_new) {\n-  \/\/ Step 1: Clone all nodes on the data chain but do not rewire anything, yet. Keep track of the cloned nodes\n-  \/\/ by using the old_new mapping. This mapping is then used in step 2 to rewire the cloned nodes accordingly.\n-  DEBUG_ONLY(uint last_idx = C->unique();)\n-  Unique_Node_List list;\n-  list.push(phi_input);\n-  for (uint j = 0; j < list.size(); j++) {\n-    Node* next = list.at(j);\n-    Node* clone = next->clone();\n-    _igvn.register_new_node_with_optimizer(clone);\n-    old_new->map(next->_idx, clone);\n+\/\/ Update ctrl and control inputs of all data nodes starting from 'node' to 'new_ctrl' which have 'old_ctrl' as\n+\/\/ current ctrl.\n+void PhaseIdealLoop::set_ctrl_of_nodes_with_same_ctrl(Node* node, ProjNode* old_ctrl, Node* new_ctrl) {\n+  Unique_Node_List nodes_with_same_ctrl = find_nodes_with_same_ctrl(node, old_ctrl);\n+  for (uint j = 0; j < nodes_with_same_ctrl.size(); j++) {\n+    Node* next = nodes_with_same_ctrl[j];\n+    if (next->in(0) == old_ctrl) {\n+      _igvn.replace_input_of(next, 0, new_ctrl);\n+    }\n+    set_ctrl(next, new_ctrl);\n+  }\n+}\n+\n+\/\/ Recursively find all input nodes with the same ctrl.\n+Unique_Node_List PhaseIdealLoop::find_nodes_with_same_ctrl(Node* node, const ProjNode* ctrl) {\n+  Unique_Node_List nodes_with_same_ctrl;\n+  nodes_with_same_ctrl.push(node);\n+  for (uint j = 0; j < nodes_with_same_ctrl.size(); j++) {\n+    Node* next = nodes_with_same_ctrl[j];\n@@ -258,2 +250,2 @@\n-      if (!in->is_Phi() && get_ctrl(in) == uncommon_proj) {\n-        list.push(in);\n+      if (!in->is_Phi() && get_ctrl(in) == ctrl) {\n+        nodes_with_same_ctrl.push(in);\n@@ -263,0 +255,26 @@\n+  return nodes_with_same_ctrl;\n+}\n+\n+\/\/ Clone all nodes with the same ctrl as 'old_ctrl' starting from 'node' by following its inputs. Rewire the cloned nodes\n+\/\/ to 'new_ctrl'. Returns the clone of 'node'.\n+Node* PhaseIdealLoop::clone_nodes_with_same_ctrl(Node* node, ProjNode* old_ctrl, Node* new_ctrl) {\n+  DEBUG_ONLY(uint last_idx = C->unique();)\n+  Unique_Node_List nodes_with_same_ctrl = find_nodes_with_same_ctrl(node, old_ctrl);\n+  Dict old_new_mapping = clone_nodes(nodes_with_same_ctrl); \/\/ Cloned but not rewired, yet\n+  rewire_cloned_nodes_to_ctrl(old_ctrl, new_ctrl, nodes_with_same_ctrl, old_new_mapping);\n+  Node* clone_phi_input = static_cast<Node*>(old_new_mapping[node]);\n+  assert(clone_phi_input != NULL && clone_phi_input->_idx >= last_idx, \"must exist and be a proper clone\");\n+  return clone_phi_input;\n+}\n+\n+\/\/ Clone all the nodes on 'list_to_clone' and return an old->new mapping.\n+Dict PhaseIdealLoop::clone_nodes(const Node_List& list_to_clone) {\n+  Dict old_new_mapping(cmpkey, hashkey);\n+  for (uint i = 0; i < list_to_clone.size(); i++) {\n+    Node* next = list_to_clone[i];\n+    Node* clone = next->clone();\n+    _igvn.register_new_node_with_optimizer(clone);\n+    old_new_mapping.Insert(next, clone);\n+  }\n+  return old_new_mapping;\n+}\n@@ -264,6 +282,8 @@\n-  \/\/ Step 2: All nodes are cloned. Rewire them by using the old_new mapping.\n-  for (uint j = 0; j < list.size(); j++) {\n-    Node* next = list.at(j);\n-    Node* clone = old_new->at(next->_idx);\n-    assert(clone != NULL && clone->_idx >= last_idx, \"must exist and be a proper clone\");\n-    if (next->in(0) == uncommon_proj) {\n+\/\/ Rewire inputs of the unprocessed cloned nodes (inputs are not updated, yet, and still point to the old nodes) by\n+\/\/ using the old_new_mapping.\n+void PhaseIdealLoop::rewire_cloned_nodes_to_ctrl(const ProjNode* old_ctrl, Node* new_ctrl,\n+                                                 const Node_List& nodes_with_same_ctrl, const Dict& old_new_mapping) {\n+  for (uint i = 0; i < nodes_with_same_ctrl.size(); i++) {\n+    Node* next = nodes_with_same_ctrl[i];\n+    Node* clone = static_cast<Node*>(old_new_mapping[next]);\n+    if (next->in(0) == old_ctrl) {\n@@ -272,2 +292,2 @@\n-      _igvn.replace_input_of(clone, 0, if_uct);\n-      set_ctrl(clone, if_uct);\n+      _igvn.replace_input_of(clone, 0, new_ctrl);\n+      set_ctrl(clone, new_ctrl);\n@@ -275,0 +295,3 @@\n+    rewire_inputs_of_clones_to_clones(new_ctrl, clone, old_new_mapping, next);\n+  }\n+}\n@@ -276,11 +299,11 @@\n-    \/\/ Rewire the inputs of the cloned nodes to the old nodes to the new clones.\n-    for (uint k = 1; k < next->req(); k++) {\n-      Node* in = next->in(k);\n-      if (!in->is_Phi()) {\n-        assert(!in->is_CFG(), \"must be data node\");\n-        Node* in_clone = old_new->at(in->_idx);\n-        if (in_clone != NULL) {\n-          assert(in_clone->_idx >= last_idx, \"must be a valid clone\");\n-          _igvn.replace_input_of(clone, k, in_clone);\n-          set_ctrl(clone, if_uct);\n-        }\n+\/\/ Rewire the inputs of the cloned nodes to the old nodes to the new clones.\n+void PhaseIdealLoop::rewire_inputs_of_clones_to_clones(Node* new_ctrl, Node* clone, const Dict& old_new_mapping,\n+                                                       const Node* next) {\n+  for (uint i = 1; i < next->req(); i++) {\n+    Node* in = next->in(i);\n+    if (!in->is_Phi()) {\n+      assert(!in->is_CFG(), \"must be data node\");\n+      Node* in_clone = static_cast<Node*>(old_new_mapping[in]);\n+      if (in_clone != NULL) {\n+        _igvn.replace_input_of(clone, i, in_clone);\n+        set_ctrl(clone, new_ctrl);\n@@ -290,3 +313,0 @@\n-  Node* clone_phi_input = old_new->at(phi_input->_idx);\n-  assert(clone_phi_input != NULL && clone_phi_input->_idx >= last_idx, \"must exist and be a proper clone\");\n-  return clone_phi_input;\n@@ -294,0 +314,1 @@\n+\n@@ -296,8 +317,1 @@\n-                                                             Deoptimization::DeoptReason reason, Node_List* old_new) {\n-  UnswitchingAction unswitching_action;\n-  if (predicate_proj->other_if_proj()->outcnt() > 1) {\n-    \/\/ There are some data dependencies that need to be taken care of when cloning a predicate.\n-    unswitching_action = old_new == NULL ? UnswitchingAction::SlowLoopRewiring : UnswitchingAction::FastLoopCloning;\n-  } else {\n-    unswitching_action = UnswitchingAction::None;\n-  }\n+                                                             Deoptimization::DeoptReason reason, const bool slow_loop) {\n@@ -306,1 +320,1 @@\n-                                                             true, old_new, unswitching_action);\n+                                                             slow_loop);\n@@ -405,1 +419,2 @@\n-  ProjNode* proj = create_new_if_for_predicate(output_proj, NULL, reason, iff->Opcode(), predicate->is_IfTrue());\n+  ProjNode* proj = create_new_if_for_predicate(output_proj, NULL, reason, iff->Opcode(),\n+                                               false, predicate->is_IfTrue());\n@@ -438,2 +453,2 @@\n-    iffast_pred = clone_predicate_to_unswitched_loop(predicate_proj, iffast_pred, Deoptimization::Reason_predicate, &old_new);\n-    ifslow_pred = clone_predicate_to_unswitched_loop(predicate_proj, ifslow_pred, Deoptimization::Reason_predicate);\n+    iffast_pred = clone_predicate_to_unswitched_loop(predicate_proj, iffast_pred, Deoptimization::Reason_predicate,false);\n+    ifslow_pred = clone_predicate_to_unswitched_loop(predicate_proj, ifslow_pred, Deoptimization::Reason_predicate,true);\n@@ -447,2 +462,2 @@\n-    iffast_pred = clone_predicate_to_unswitched_loop(profile_predicate_proj, iffast_pred, Deoptimization::Reason_profile_predicate, &old_new);\n-    ifslow_pred = clone_predicate_to_unswitched_loop(profile_predicate_proj, ifslow_pred, Deoptimization::Reason_profile_predicate);\n+    iffast_pred = clone_predicate_to_unswitched_loop(profile_predicate_proj, iffast_pred,Deoptimization::Reason_profile_predicate, false);\n+    ifslow_pred = clone_predicate_to_unswitched_loop(profile_predicate_proj, ifslow_pred,Deoptimization::Reason_profile_predicate, true);\n@@ -458,2 +473,2 @@\n-    iffast_pred = clone_predicate_to_unswitched_loop(limit_check_proj, iffast_pred, Deoptimization::Reason_loop_limit_check, &old_new);\n-    ifslow_pred = clone_predicate_to_unswitched_loop(limit_check_proj, ifslow_pred, Deoptimization::Reason_loop_limit_check);\n+    iffast_pred = clone_predicate_to_unswitched_loop(limit_check_proj, iffast_pred,Deoptimization::Reason_loop_limit_check, false);\n+    ifslow_pred = clone_predicate_to_unswitched_loop(limit_check_proj, ifslow_pred,Deoptimization::Reason_loop_limit_check, true);\n@@ -1340,7 +1355,5 @@\n-    \/\/ Fall through into rest of the clean up code which will move\n-    \/\/ any dependent nodes onto the upper bound test.\n-    new_predicate_proj = upper_bound_proj;\n-\n-    if (iff->is_RangeCheck()) {\n-      new_predicate_proj = insert_initial_skeleton_predicate(iff, loop, proj, predicate_proj, upper_bound_proj, scale, offset, init, limit, stride, rng, overflow, reason);\n-    }\n+    \/\/ Fall through into rest of the cleanup code which will move any dependent nodes to the skeleton predicates of the\n+    \/\/ upper bound test. We always need to create skeleton predicates in order to properly remove dead loops when later\n+    \/\/ splitting the predicated loop into (unreachable) sub-loops (i.e. done by unrolling, peeling, pre\/main\/post etc.).\n+    new_predicate_proj = insert_initial_skeleton_predicate(iff, loop, proj, predicate_proj, upper_bound_proj, scale,\n+                                                           offset, init, limit, stride, rng, overflow, reason);\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":103,"deletions":90,"binary":false,"changes":193,"status":"modified"},{"patch":"@@ -1303,1 +1303,1 @@\n-  assert(zer_opaq != NULL && zer_opaq->Opcode() == Op_Opaque1, \"must be Opaque1\");\n+  assert(zer_opaq != NULL && zer_opaq->Opcode() == Op_OpaqueZeroTripGuard, \"must be OpaqueZeroTripGuard\");\n@@ -1708,1 +1708,1 @@\n-  Node *min_opaq = new Opaque1Node(C, limit);\n+  Node *min_opaq = new OpaqueZeroTripGuardNode(C, limit);\n@@ -1997,1 +1997,1 @@\n-  Node *zer_opaq = new Opaque1Node(C, incr);\n+  Node *zer_opaq = new OpaqueZeroTripGuardNode(C, incr);\n@@ -2290,12 +2290,1 @@\n-      if (loop_head->unrolled_count() == 1) { \/\/ only for first unroll\n-        \/\/ Separate limit by Opaque node in case it is an incremented\n-        \/\/ variable from previous loop to avoid using pre-incremented\n-        \/\/ value which could increase register pressure.\n-        \/\/ Otherwise reorg_offsets() optimization will create a separate\n-        \/\/ Opaque node for each use of trip-counter and as result\n-        \/\/ zero trip guard limit will be different from loop limit.\n-        assert(has_ctrl(opaq), \"should have it\");\n-        Node* opaq_ctrl = get_ctrl(opaq);\n-        limit = new Opaque2Node(C, limit);\n-        register_new_node(limit, opaq_ctrl);\n-      }\n+      assert(loop_head->unrolled_count() != 1 || has_ctrl(opaq), \"should have opaque for first unroll\");\n@@ -2349,14 +2338,0 @@\n-      if (loop_head->unrolled_count() == 1) {\n-        \/\/ The Opaque2 node created above (in the case of the first unrolling) hides the type of the loop limit.\n-        \/\/ As a result, if the iv Phi constant folds (because it captured the iteration range), the exit test won't\n-        \/\/ constant fold and the graph contains a broken counted loop.\n-        const Type* new_limit_t;\n-        if (stride_con > 0) {\n-          new_limit_t = TypeInt::make(min_jint, limit_type->_hi, limit_type->_widen);\n-        } else {\n-          assert(stride_con < 0, \"stride can't be 0\");\n-          new_limit_t = TypeInt::make(limit_type->_lo, max_jint, limit_type->_widen);\n-        }\n-        new_limit = new CastIINode(new_limit, new_limit_t);\n-        register_new_node(new_limit, ctrl);\n-      }\n@@ -3604,1 +3579,1 @@\n-  \/\/ Remove the Opaque1Node of the main loop so it can be optimized out\n+  \/\/ Remove the OpaqueZeroTripGuardNode of the main loop so it can be optimized out\n@@ -3606,1 +3581,1 @@\n-  assert(main_cmp->in(2)->Opcode() == Op_Opaque1, \"main loop has no opaque node?\");\n+  assert(main_cmp->in(2)->Opcode() == Op_OpaqueZeroTripGuard, \"main loop has no opaque node?\");\n@@ -3943,4 +3918,0 @@\n-  \/\/ Minor offset re-organization to remove loop-fallout uses of\n-  \/\/ trip counter when there was no major reshaping.\n-  phase->reorg_offsets(this);\n-\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":6,"deletions":35,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -3660,1 +3660,1 @@\n-  if (!cl->is_valid_counted_loop(T_INT))\n+  if (!cl->is_valid_counted_loop(T_INT)) {\n@@ -3662,0 +3662,1 @@\n+  }\n@@ -3663,1 +3664,1 @@\n-  if (incr == NULL)\n+  if (incr == NULL) {\n@@ -3665,0 +3666,1 @@\n+  }\n@@ -3673,1 +3675,1 @@\n-    if (!out->is_Phi() || out == phi || !has_node(out))\n+    if (!out->is_Phi() || out == phi || !has_node(out)) {\n@@ -3675,0 +3677,2 @@\n+    }\n+\n@@ -3676,1 +3680,1 @@\n-    Node *incr2 = phi2->in( LoopNode::LoopBackControl );\n+    Node* incr2 = phi2->in(LoopNode::LoopBackControl);\n@@ -3683,1 +3687,1 @@\n-        !incr2->in(2)->is_Con())\n+        !incr2->in(2)->is_Con()) {\n@@ -3685,0 +3689,1 @@\n+    }\n@@ -3686,0 +3691,5 @@\n+    if (incr2->in(1)->is_ConstraintCast() &&\n+        !(incr2->in(1)->in(0)->is_IfProj() && incr2->in(1)->in(0)->in(0)->is_RangeCheck())) {\n+      \/\/ Skip AddI->CastII->Phi case if CastII is not controlled by local RangeCheck\n+      continue;\n+    }\n@@ -3691,1 +3701,1 @@\n-    Node *init2 = phi2->in( LoopNode::EntryControl );\n+    Node* init2 = phi2->in(LoopNode::EntryControl);\n@@ -4183,2 +4193,2 @@\n-\/\/ Goes over all children of the root of the loop tree, collects all controls for the loop and its inner loops then\n-\/\/ checks whether any control is a branch out of the loop and if it is, whether it's not a NeverBranch.\n+\/\/ Goes over all children of the root of the loop tree. Check if any of them have a path\n+\/\/ down to Root, that does not go via a NeverBranch exit.\n@@ -4186,0 +4196,3 @@\n+  ResourceMark rm;\n+  Unique_Node_List worklist;\n+  \/\/ start traversal at all loop heads of first-level loops\n@@ -4187,1 +4200,0 @@\n-    Unique_Node_List wq;\n@@ -4190,28 +4202,20 @@\n-    for (uint i = 1; i < head->req(); ++i) {\n-      Node* in = head->in(i);\n-      if (get_loop(in) != _ltree_root) {\n-        wq.push(in);\n-      }\n-    }\n-    for (uint i = 0; i < wq.size(); ++i) {\n-      Node* c = wq.at(i);\n-      if (c == head) {\n-        continue;\n-      } else if (c->is_Region()) {\n-        for (uint j = 1; j < c->req(); ++j) {\n-          wq.push(c->in(j));\n-        }\n-      } else {\n-        wq.push(c->in(0));\n-      }\n-    }\n-    assert(wq.member(head), \"\");\n-    for (uint i = 0; i < wq.size(); ++i) {\n-      Node* c = wq.at(i);\n-      if (c->is_MultiBranch()) {\n-        for (DUIterator_Fast jmax, j = c->fast_outs(jmax); j < jmax; j++) {\n-          Node* u = c->fast_out(j);\n-          assert(u->is_CFG(), \"\");\n-          if (!wq.member(u) && c->Opcode() != Op_NeverBranch) {\n-            return false;\n-          }\n+    worklist.push(head);\n+  }\n+  \/\/ BFS traversal down the CFG, except through NeverBranch exits\n+  for (uint i = 0; i < worklist.size(); ++i) {\n+    Node* n = worklist.at(i);\n+    assert(n->is_CFG(), \"only traverse CFG\");\n+    if (n->is_Root()) {\n+      \/\/ Found root -> there was an exit!\n+      return false;\n+    } else if (n->Opcode() == Op_NeverBranch) {\n+      \/\/ Only follow the loop-internal projection, not the NeverBranch exit\n+      ProjNode* proj = n->as_Multi()->proj_out_or_null(0);\n+      assert(proj != nullptr, \"must find loop-internal projection of NeverBranch\");\n+      worklist.push(proj);\n+    } else {\n+      \/\/ Traverse all CFG outputs\n+      for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+        Node* use = n->fast_out(i);\n+        if (use->is_CFG()) {\n+          worklist.push(use);\n@@ -4222,0 +4226,1 @@\n+  \/\/ No exit found for any loop -> all are infinite\n@@ -5473,1 +5478,1 @@\n-  bool res = cmpzm->in(input)->Opcode() == Op_Opaque1;\n+  bool res = cmpzm->in(input)->Opcode() == Op_OpaqueZeroTripGuard;\n@@ -5478,1 +5483,1 @@\n-    if (opnd && opnd->Opcode() == Op_Opaque1) {\n+    if (opnd && opnd->is_Opaque1()) {\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":44,"deletions":39,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -1311,8 +1311,0 @@\n-\n-  \/\/ Enum to determine the action to be performed in create_new_if_for_predicate() when processing phis of UCT regions.\n-  enum class UnswitchingAction {\n-    None,            \/\/ No special action.\n-    FastLoopCloning, \/\/ Need to clone nodes for the fast loop.\n-    SlowLoopRewiring \/\/ Need to rewire nodes for the slow loop.\n-  };\n-\n@@ -1321,2 +1313,2 @@\n-                                        int opcode, bool if_cont_is_true_proj = true, Node_List* old_new = NULL,\n-                                        UnswitchingAction unswitching_action = UnswitchingAction::None);\n+                                        int opcode, bool rewire_uncommon_proj_phi_inputs = false,\n+                                        bool if_cont_is_true_proj = true);\n@@ -1324,2 +1316,9 @@\n-  \/\/ Clone data nodes for the fast loop while creating a new If with create_new_if_for_predicate.\n-  Node* clone_data_nodes_for_fast_loop(Node* phi_input, ProjNode* uncommon_proj, Node* if_uct, Node_List* old_new);\n+ private:\n+  \/\/ Helper functions for create_new_if_for_predicate()\n+  void set_ctrl_of_nodes_with_same_ctrl(Node* node, ProjNode* old_ctrl, Node* new_ctrl);\n+  Unique_Node_List find_nodes_with_same_ctrl(Node* node, const ProjNode* ctrl);\n+  Node* clone_nodes_with_same_ctrl(Node* node, ProjNode* old_ctrl, Node* new_ctrl);\n+  Dict clone_nodes(const Node_List& list_to_clone);\n+  void rewire_cloned_nodes_to_ctrl(const ProjNode* old_ctrl, Node* new_ctrl, const Node_List& nodes_with_same_ctrl,\n+                                   const Dict& old_new_mapping);\n+  void rewire_inputs_of_clones_to_clones(Node* new_ctrl, Node* clone, const Dict& old_new_mapping, const Node* next);\n@@ -1327,0 +1326,1 @@\n+ public:\n@@ -1525,6 +1525,0 @@\n-  \/\/ Reorganize offset computations to lower register pressure.\n-  \/\/ Mostly prevent loop-fallout uses of the pre-incremented trip counter\n-  \/\/ (which are then alive with the post-incremented trip counter\n-  \/\/ forcing an extra register move)\n-  void reorg_offsets( IdealLoopTree *loop );\n-\n@@ -1649,2 +1643,2 @@\n-  ProjNode* clone_predicate_to_unswitched_loop(ProjNode* predicate_proj, Node* new_entry, Deoptimization::DeoptReason reason,\n-                                               Node_List* old_new = NULL);\n+  ProjNode* clone_predicate_to_unswitched_loop(ProjNode* predicate_proj, Node* new_entry,\n+                                               Deoptimization::DeoptReason reason, bool slow_loop);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":14,"deletions":20,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1026,2 +1026,1 @@\n-  if (n->is_Opaque1() ||     \/\/ Opaque nodes cannot be mod'd\n-      n_op == Op_Opaque2) {\n+  if (n->is_Opaque1()) { \/\/ Opaque nodes cannot be mod'd\n@@ -1429,8 +1428,0 @@\n-\n-  \/\/ Check for Opaque2's who's loop has disappeared - who's input is in the\n-  \/\/ same loop nest as their output.  Remove 'em, they are no longer useful.\n-  if( n_op == Op_Opaque2 &&\n-      n->in(1) != NULL &&\n-      get_loop(get_ctrl(n)) == get_loop(get_ctrl(n->in(1))) ) {\n-    _igvn.replace_node( n, n->in(1) );\n-  }\n@@ -4109,86 +4100,0 @@\n-\n-\/\/------------------------------reorg_offsets----------------------------------\n-\/\/ Reorganize offset computations to lower register pressure.  Mostly\n-\/\/ prevent loop-fallout uses of the pre-incremented trip counter (which are\n-\/\/ then alive with the post-incremented trip counter forcing an extra\n-\/\/ register move):\n-\/\/\n-\/\/     iv Phi            iv Phi\n-\/\/       |                 |\n-\/\/       |                AddI (+stride)\n-\/\/       |                 |\n-\/\/       |              Opaque2  # Blocks IGVN from folding these nodes until loop opts are over.\n-\/\/       |     ====>       |\n-\/\/       |                AddI (-stride)\n-\/\/       |                 |\n-\/\/       |               CastII  # Preserve type of iv Phi\n-\/\/       |                 |\n-\/\/   Outside Use       Outside Use\n-\/\/\n-void PhaseIdealLoop::reorg_offsets(IdealLoopTree *loop) {\n-  \/\/ Perform it only for canonical counted loops.\n-  \/\/ Loop's shape could be messed up by iteration_split_impl.\n-  if (!loop->_head->is_CountedLoop())\n-    return;\n-  if (!loop->_head->as_Loop()->is_valid_counted_loop(T_INT))\n-    return;\n-\n-  CountedLoopNode *cl = loop->_head->as_CountedLoop();\n-  CountedLoopEndNode *cle = cl->loopexit();\n-  Node *exit = cle->proj_out(false);\n-  Node *phi = cl->phi();\n-\n-  \/\/ Check for the special case when using the pre-incremented trip-counter on\n-  \/\/ the fall-out  path (forces the pre-incremented  and post-incremented trip\n-  \/\/ counter to be live  at the same time).  Fix this by  adjusting to use the\n-  \/\/ post-increment trip counter.\n-\n-  bool progress = true;\n-  while (progress) {\n-    progress = false;\n-    for (DUIterator_Fast imax, i = phi->fast_outs(imax); i < imax; i++) {\n-      Node* use = phi->fast_out(i);   \/\/ User of trip-counter\n-      if (!has_ctrl(use))  continue;\n-      Node *u_ctrl = get_ctrl(use);\n-      if (use->is_Phi()) {\n-        u_ctrl = NULL;\n-        for (uint j = 1; j < use->req(); j++)\n-          if (use->in(j) == phi)\n-            u_ctrl = dom_lca(u_ctrl, use->in(0)->in(j));\n-      }\n-      IdealLoopTree *u_loop = get_loop(u_ctrl);\n-      \/\/ Look for loop-invariant use\n-      if (u_loop == loop) continue;\n-      if (loop->is_member(u_loop)) continue;\n-      \/\/ Check that use is live out the bottom.  Assuming the trip-counter\n-      \/\/ update is right at the bottom, uses of of the loop middle are ok.\n-      if (dom_lca(exit, u_ctrl) != exit) continue;\n-      \/\/ Hit!  Refactor use to use the post-incremented tripcounter.\n-      \/\/ Compute a post-increment tripcounter.\n-      Node* c = exit;\n-      if (cl->is_strip_mined()) {\n-        IdealLoopTree* outer_loop = get_loop(cl->outer_loop());\n-        if (!outer_loop->is_member(u_loop)) {\n-          c = cl->outer_loop_exit();\n-        }\n-      }\n-      Node *opaq = new Opaque2Node(C, cle->incr());\n-      register_new_node(opaq, c);\n-      Node *neg_stride = _igvn.intcon(-cle->stride_con());\n-      set_ctrl(neg_stride, C->root());\n-      Node *post = new AddINode(opaq, neg_stride);\n-      register_new_node(post, c);\n-      post = new CastIINode(post, phi->bottom_type()); \/\/ preserve the iv phi's type\n-      register_new_node(post, c);\n-      _igvn.rehash_node_delayed(use);\n-      for (uint j = 1; j < use->req(); j++) {\n-        if (use->in(j) == phi)\n-          use->set_req(j, post);\n-      }\n-      \/\/ Since DU info changed, rerun loop\n-      progress = true;\n-      break;\n-    }\n-  }\n-\n-}\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":1,"deletions":96,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -2374,1 +2374,0 @@\n-               n->Opcode() == Op_Opaque2   ||\n@@ -2417,1 +2416,1 @@\n-      } else if (n->is_Opaque1() || n->Opcode() == Op_Opaque2) {\n+      } else if (n->is_Opaque1()) {\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"opto\/subnode.hpp\"\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -868,1 +868,1 @@\n-      in_bytes(JavaThread::extentLocalCache_offset()),\n+      in_bytes(JavaThread::scopedValueCache_offset()),\n@@ -3264,1 +3264,0 @@\n-  case Op_Blackhole:         return new BlackholeNode(C, atp, pn);\n@@ -3504,20 +3503,0 @@\n-#ifndef PRODUCT\n-void BlackholeNode::format(PhaseRegAlloc* ra, outputStream* st) const {\n-  st->print(\"blackhole \");\n-  bool first = true;\n-  for (uint i = 0; i < req(); i++) {\n-    Node* n = in(i);\n-    if (n != NULL && OptoReg::is_valid(ra->get_reg_first(n))) {\n-      if (first) {\n-        first = false;\n-      } else {\n-        st->print(\", \");\n-      }\n-      char buf[128];\n-      ra->dump_register(n, buf);\n-      st->print(\"%s\", buf);\n-    }\n-  }\n-  st->cr();\n-}\n-#endif\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":1,"deletions":22,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1299,20 +1299,0 @@\n-\/\/------------------------------BlackholeNode----------------------------\n-\/\/ Blackhole all arguments. This node would survive through the compiler\n-\/\/ the effects on its arguments, and would be finally matched to nothing.\n-class BlackholeNode : public MemBarNode {\n-public:\n-  BlackholeNode(Compile* C, int alias_idx, Node* precedent)\n-    : MemBarNode(C, alias_idx, precedent) {}\n-  virtual int   Opcode() const;\n-  virtual uint ideal_reg() const { return 0; } \/\/ not matched in the AD file\n-  const RegMask &in_RegMask(uint idx) const {\n-    \/\/ Fake the incoming arguments mask for blackholes: accept all registers\n-    \/\/ and all stack slots. This would avoid any redundant register moves\n-    \/\/ for blackhole inputs.\n-    return RegMask::All;\n-  }\n-#ifndef PRODUCT\n-  virtual void format(PhaseRegAlloc* ra, outputStream* st) const;\n-#endif\n-};\n-\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -47,14 +47,2 @@\n-\/\/=============================================================================\n-\/\/ A node to prevent unwanted optimizations.  Allows constant folding.  Stops\n-\/\/ value-numbering, most Ideal calls or Identity functions.  This Node is\n-\/\/ specifically designed to prevent the pre-increment value of a loop trip\n-\/\/ counter from being live out of the bottom of the loop (hence causing the\n-\/\/ pre- and post-increment values both being live and thus requiring an extra\n-\/\/ temp register and an extra move).  If we \"accidentally\" optimize through\n-\/\/ this kind of a Node, we'll get slightly pessimal, but correct, code.  Thus\n-\/\/ it's OK to be slightly sloppy on optimizations here.\n-\n-\/\/ Do NOT remove the opaque node until no more loop opts can happen. Opaque1\n-\/\/ and Opaque2 nodes are removed together in order to optimize loops away\n-\/\/ before macro expansion.\n-Node* Opaque2Node::Identity(PhaseGVN* phase) {\n+\/\/ Do NOT remove the opaque node until no more loop opts can happen.\n+Node* Opaque3Node::Identity(PhaseGVN* phase) {\n@@ -70,2 +58,2 @@\n-uint Opaque2Node::hash() const { return NO_HASH; }\n-bool Opaque2Node::cmp( const Node &n ) const {\n+uint Opaque3Node::hash() const { return NO_HASH; }\n+bool Opaque3Node::cmp(const Node &n) const {\n","filename":"src\/hotspot\/share\/opto\/opaquenode.cpp","additions":4,"deletions":16,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -73,17 +73,3 @@\n-\/\/------------------------------Opaque2Node------------------------------------\n-\/\/ A node to prevent unwanted optimizations.  Allows constant folding.  Stops\n-\/\/ value-numbering, most Ideal calls or Identity functions.  This Node is\n-\/\/ specifically designed to prevent the pre-increment value of a loop trip\n-\/\/ counter from being live out of the bottom of the loop (hence causing the\n-\/\/ pre- and post-increment values both being live and thus requiring an extra\n-\/\/ temp register and an extra move).  If we \"accidentally\" optimize through\n-\/\/ this kind of a Node, we'll get slightly pessimal, but correct, code.  Thus\n-\/\/ it's OK to be slightly sloppy on optimizations here.\n-class Opaque2Node : public Node {\n-  virtual uint hash() const ;                  \/\/ { return NO_HASH; }\n-  virtual bool cmp( const Node &n ) const;\n-  public:\n-  Opaque2Node( Compile* C, Node *n ) : Node(0,n) {\n-    \/\/ Put it on the Macro nodes list to removed during macro nodes expansion.\n-    init_flags(Flag_is_macro);\n-    C->add_macro_node(this);\n+class OpaqueZeroTripGuardNode : public Opaque1Node {\n+public:\n+  OpaqueZeroTripGuardNode(Compile* C, Node *n) : Opaque1Node(C, n) {\n@@ -92,2 +78,0 @@\n-  virtual const Type* bottom_type() const { return TypeInt::INT; }\n-  virtual Node* Identity(PhaseGVN* phase);\n@@ -99,1 +83,1 @@\n-class Opaque3Node : public Opaque2Node {\n+class Opaque3Node : public Node {\n@@ -101,0 +85,2 @@\n+  virtual uint hash() const;\n+  virtual bool cmp(const Node &n) const;\n@@ -103,1 +89,5 @@\n-  Opaque3Node(Compile* C, Node *n, int opt) : Opaque2Node(C, n), _opt(opt) {}\n+  Opaque3Node(Compile* C, Node* n, int opt) : Node(0, n), _opt(opt) {\n+    \/\/ Put it on the Macro nodes list to removed during macro nodes expansion.\n+    init_flags(Flag_is_macro);\n+    C->add_macro_node(this);\n+  }\n@@ -105,0 +95,2 @@\n+  virtual const Type* bottom_type() const { return TypeInt::INT; }\n+  virtual Node* Identity(PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/opaquenode.hpp","additions":13,"deletions":21,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1251,0 +1251,5 @@\n+  \/\/ Allow Bool -> Cmp idealisation in late inlining intrinsics that return a bool\n+  if (n->is_Cmp()) {\n+    add_users_to_worklist(n);\n+  }\n+\n@@ -1780,0 +1785,1 @@\n+  DEBUG_ONLY(Unique_Node_List worklist_verify;)\n@@ -1788,0 +1794,1 @@\n+    DEBUG_ONLY(worklist_verify.push(n);)\n@@ -1801,0 +1808,1 @@\n+  DEBUG_ONLY(verify_analyze(worklist_verify);)\n@@ -1803,0 +1811,45 @@\n+#ifdef ASSERT\n+\/\/ For every node n on verify list, check if type(n) == n->Value()\n+\/\/ We have a list of exceptions, see comments in code.\n+void PhaseCCP::verify_analyze(Unique_Node_List& worklist_verify) {\n+  bool failure = false;\n+  while (worklist_verify.size()) {\n+    Node* n = worklist_verify.pop();\n+    const Type* told = type(n);\n+    const Type* tnew = n->Value(this);\n+    if (told != tnew) {\n+      \/\/ Check special cases that are ok\n+      if (told->isa_integer(tnew->basic_type()) != nullptr) { \/\/ both either int or long\n+        const TypeInteger* t0 = told->is_integer(tnew->basic_type());\n+        const TypeInteger* t1 = tnew->is_integer(tnew->basic_type());\n+        if (t0->lo_as_long() == t1->lo_as_long() &&\n+            t0->hi_as_long() == t1->hi_as_long()) {\n+          continue; \/\/ ignore integer widen\n+        }\n+      }\n+      if (n->is_Load()) {\n+        \/\/ MemNode::can_see_stored_value looks up through many memory nodes,\n+        \/\/ which means we would need to notify modifications from far up in\n+        \/\/ the inputs all the way down to the LoadNode. We don't do that.\n+        continue;\n+      }\n+      tty->cr();\n+      tty->print_cr(\"Missed optimization (PhaseCCP):\");\n+      n->dump_bfs(1, 0, \"\");\n+      tty->print_cr(\"Current type:\");\n+      told->dump_on(tty);\n+      tty->cr();\n+      tty->print_cr(\"Optimized type:\");\n+      tnew->dump_on(tty);\n+      tty->cr();\n+      failure = true;\n+    }\n+  }\n+  \/\/ If we get this assert, check why the reported nodes were not processed again in CCP.\n+  \/\/ We should either make sure that these nodes are properly added back to the CCP worklist\n+  \/\/ in PhaseCCP::push_child_nodes_to_worklist() to update their type or add an exception\n+  \/\/ in the verification code above if that is not possible for some reason (like Load nodes).\n+  assert(!failure, \"Missed optimization opportunity in PhaseCCP\");\n+}\n+#endif\n+\n@@ -1850,0 +1903,1 @@\n+  push_cast_ii(worklist, parent, use);\n@@ -1953,0 +2007,16 @@\n+\/\/ CastII::Value() optimizes CmpI\/If patterns if the right input of the CmpI has a constant type. If the CastII input is\n+\/\/ the same node as the left input into the CmpI node, the type of the CastII node can be improved accordingly. Add the\n+\/\/ CastII node back to the worklist to re-apply Value() to either not miss this optimization or to undo it because it\n+\/\/ cannot be applied anymore. We could have optimized the type of the CastII before but now the type of the right input\n+\/\/ of the CmpI (i.e. 'parent') is no longer constant. The type of the CastII must be widened in this case.\n+void PhaseCCP::push_cast_ii(Unique_Node_List& worklist, const Node* parent, const Node* use) const {\n+  if (use->Opcode() == Op_CmpI && use->in(2) == parent) {\n+    Node* other_cmp_input = use->in(1);\n+    for (DUIterator_Fast imax, i = other_cmp_input->fast_outs(imax); i < imax; i++) {\n+      Node* cast_ii = other_cmp_input->fast_out(i);\n+      if (cast_ii->is_CastII()) {\n+        push_if_not_bottom_type(worklist, cast_ii);\n+      }\n+    }\n+  }\n+}\n@@ -2102,1 +2172,0 @@\n-  case Op_Opaque2:\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":70,"deletions":1,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -598,0 +598,1 @@\n+  void push_cast_ii(Unique_Node_List& worklist, const Node* parent, const Node* use) const;\n@@ -605,0 +606,4 @@\n+#ifdef ASSERT\n+  \/\/ For every node n on verify list, check if type(n) == n->Value()\n+  void verify_analyze(Unique_Node_List& worklist_verify);\n+#endif\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"opto\/opaquenode.hpp\"\n@@ -223,0 +224,18 @@\n+  if (n->Opcode() == Op_OpaqueZeroTripGuard) {\n+    \/\/ If this Opaque1 is part of the zero trip guard for a loop:\n+    \/\/ 1- it can't be shared\n+    \/\/ 2- the zero trip guard can't be the if that's being split\n+    \/\/ As a consequence, this node could be assigned control anywhere between its current control and the zero trip guard.\n+    \/\/ Move it down to get it out of the way of split if and avoid breaking the zero trip guard shape.\n+    Node* cmp = n->unique_out();\n+    assert(cmp->Opcode() == Op_CmpI, \"bad zero trip guard shape\");\n+    Node* bol = cmp->unique_out();\n+    assert(bol->Opcode() == Op_Bool, \"bad zero trip guard shape\");\n+    Node* iff = bol->unique_out();\n+    assert(iff->Opcode() == Op_If, \"bad zero trip guard shape\");\n+    set_ctrl(n, iff->in(0));\n+    set_ctrl(cmp, iff->in(0));\n+    set_ctrl(bol, iff->in(0));\n+    return true;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -72,9 +72,0 @@\n-\n-    \/\/ Also catch: \"(X + Opaque2(Y)) - Y\".  In this case, 'Y' is a loop-varying\n-    \/\/ trip counter and X is likely to be loop-invariant (that's how O2 Nodes\n-    \/\/ are originally used, although the optimizer sometimes jiggers things).\n-    \/\/ This folding through an O2 removes a loop-exit use of a loop-varying\n-    \/\/ value and generally lowers register pressure in and around the loop.\n-    if (in(1)->in(2)->Opcode() == Op_Opaque2 && in(1)->in(2)->in(1) == in(2)) {\n-      return in(1)->in(1);\n-    }\n@@ -1439,1 +1430,4 @@\n-  if( cop == Op_FastLock || cop == Op_FastUnlock || cmp->is_SubTypeCheck()) return NULL;\n+  if( cop == Op_FastLock || cop == Op_FastUnlock ||\n+      cmp->is_SubTypeCheck() || cop == Op_VectorTest ) {\n+    return NULL;\n+  }\n@@ -1456,1 +1450,1 @@\n-  if( con->is_Con() && !cmp2->is_Con() && cmp2_op != Op_Opaque1 &&\n+  if (con->is_Con() && !cmp2->is_Con() && cmp2_op != Op_OpaqueZeroTripGuard &&\n@@ -1471,0 +1465,14 @@\n+  \/\/ Change \"bool eq\/ne (cmp (cmove (bool tst (cmp2)) 1 0) 0)\" into \"bool tst\/~tst (cmp2)\"\n+  if (cop == Op_CmpI &&\n+      (_test._test == BoolTest::eq || _test._test == BoolTest::ne) &&\n+      cmp1_op == Op_CMoveI && cmp2->find_int_con(1) == 0) {\n+    \/\/ 0 should be on the true branch\n+    if (cmp1->in(CMoveNode::IfTrue)->find_int_con(1) == 0 &&\n+        cmp1->in(CMoveNode::IfFalse)->find_int_con(0) != 0) {\n+      BoolNode* target = cmp1->in(CMoveNode::Condition)->as_Bool();\n+      return new BoolNode(target->in(1),\n+                          (_test._test == BoolTest::eq) ? target->_test._test :\n+                                                          target->_test.negate());\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":19,"deletions":11,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2082,0 +2082,8 @@\n+    } else if (requires_long_to_int_conversion(opc)) {\n+      \/\/ Java API for Long.bitCount\/numberOfLeadingZeros\/numberOfTrailingZeros\n+      \/\/ returns int type, but Vector API for them returns long type. To unify\n+      \/\/ the implementation in backend, superword splits the vector implementation\n+      \/\/ for Java API into an execution node with long type plus another node\n+      \/\/ converting long to int.\n+      retValue = VectorNode::implemented(opc, size, T_LONG) &&\n+                 VectorCastNode::implemented(Op_ConvL2I, size, T_LONG, T_INT);\n@@ -2099,0 +2107,12 @@\n+\n+bool SuperWord::requires_long_to_int_conversion(int opc) {\n+  switch(opc) {\n+    case Op_PopCountL:\n+    case Op_CountLeadingZerosL:\n+    case Op_CountTrailingZerosL:\n+      return true;\n+    default:\n+      return false;\n+  }\n+}\n+\n@@ -2669,1 +2689,0 @@\n-                 opc == Op_PopCountI || opc == Op_PopCountL ||\n@@ -2673,2 +2692,2 @@\n-                 opc == Op_CountLeadingZerosI || opc == Op_CountLeadingZerosL ||\n-                 opc == Op_CountTrailingZerosI || opc == Op_CountTrailingZerosL) {\n+                 opc == Op_PopCountI || opc == Op_CountLeadingZerosI ||\n+                 opc == Op_CountTrailingZerosI) {\n@@ -2679,0 +2698,13 @@\n+      } else if (requires_long_to_int_conversion(opc)) {\n+        \/\/ Java API for Long.bitCount\/numberOfLeadingZeros\/numberOfTrailingZeros\n+        \/\/ returns int type, but Vector API for them returns long type. To unify\n+        \/\/ the implementation in backend, superword splits the vector implementation\n+        \/\/ for Java API into an execution node with long type plus another node\n+        \/\/ converting long to int.\n+        assert(n->req() == 2, \"only one input expected\");\n+        Node* in = vector_opd(p, 1);\n+        Node* longval = VectorNode::make(opc, in, NULL, vlen, T_LONG);\n+        _igvn.register_new_node_with_optimizer(longval);\n+        _phase->set_ctrl(longval, _phase->get_ctrl(p->at(0)));\n+        vn = VectorCastNode::make(Op_VectorCastL2X, longval, T_INT, vlen);\n+        vlen_in_bytes = vn->as_Vector()->length_in_bytes();\n@@ -2683,1 +2715,1 @@\n-        int vopc = VectorCastNode::opcode(in->bottom_type()->is_vect()->element_basic_type());\n+        int vopc = VectorCastNode::opcode(opc, in->bottom_type()->is_vect()->element_basic_type());\n@@ -3201,16 +3233,0 @@\n-  if (VectorNode::is_type_transition_long_to_int(use)) {\n-    \/\/ PopCountL\/CountLeadingZerosL\/CountTrailingZerosL takes long and produces\n-    \/\/ int - hence the special checks on alignment and size.\n-    if (u_pk->size() != d_pk->size()) {\n-      return false;\n-    }\n-    for (uint i = 0; i < MIN2(d_pk->size(), u_pk->size()); i++) {\n-      Node* ui = u_pk->at(i);\n-      Node* di = d_pk->at(i);\n-      if (alignment(ui) * 2 != alignment(di)) {\n-        return false;\n-      }\n-    }\n-    return true;\n-  }\n-\n@@ -3221,1 +3237,1 @@\n-    \/\/ type conversion takes a type of a kind of size and produces a type of\n+    \/\/ These opcodes take a type of a kind of size and produce a type of\n@@ -3470,1 +3486,2 @@\n-  if (!VectorNode::is_convert_opcode(n->Opcode()) ||\n+  if (!(VectorNode::is_convert_opcode(n->Opcode()) ||\n+        requires_long_to_int_conversion(n->Opcode())) ||\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":39,"deletions":22,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -460,0 +460,1 @@\n+  static bool requires_long_to_int_conversion(int opc);\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -778,1 +778,1 @@\n-  int cast_vopc = VectorCastNode::opcode(T_BYTE); \/\/ from shuffle of type T_BYTE\n+  int cast_vopc = VectorCastNode::opcode(-1, T_BYTE); \/\/ from shuffle of type T_BYTE\n@@ -1802,1 +1802,7 @@\n-  Node* opd2 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n+  Node* opd2;\n+  if (Matcher::vectortest_needs_second_argument(booltest == BoolTest::overflow,\n+                                                opd1->bottom_type()->isa_vectmask())) {\n+    opd2 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n+  } else {\n+    opd2 = opd1;\n+  }\n@@ -1806,2 +1812,0 @@\n-  Node* test = new VectorTestNode(opd1, opd2, booltest);\n-  test = gvn().transform(test);\n@@ -1809,1 +1813,7 @@\n-  set_result(test);\n+  Node* cmp = gvn().transform(new VectorTestNode(opd1, opd2, booltest));\n+  BoolTest::mask test = Matcher::vectortest_mask(booltest == BoolTest::overflow,\n+                                                 opd1->bottom_type()->isa_vectmask(), num_elem);\n+  Node* bol = gvn().transform(new BoolNode(cmp, test));\n+  Node* res = gvn().transform(new CMoveINode(bol, gvn().intcon(0), gvn().intcon(1), TypeInt::BOOL));\n+\n+  set_result(res);\n@@ -2492,1 +2502,1 @@\n-    int cast_vopc = VectorCastNode::opcode(elem_bt_from, !is_ucast);\n+    int cast_vopc = VectorCastNode::opcode(-1, elem_bt_from, !is_ucast);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -172,0 +172,5 @@\n+  case Op_ReverseBytesUS:\n+    \/\/ Subword operations in superword usually don't have precise info\n+    \/\/ about signedness. But the behavior of reverseBytes for short and\n+    \/\/ char are exactly the same.\n+    return ((bt == T_SHORT || bt == T_CHAR) ? Op_ReverseBytesV : 0);\n@@ -173,0 +178,4 @@\n+    \/\/ There is no reverseBytes() in Byte class but T_BYTE may appear\n+    \/\/ in VectorAPI calls. We still use ReverseBytesI for T_BYTE to\n+    \/\/ ensure vector intrinsification succeeds.\n+    return ((bt == T_INT || bt == T_BYTE) ? Op_ReverseBytesV : 0);\n@@ -174,2 +183,1 @@\n-  case Op_ReverseBytesUS:\n-    return (is_integral_type(bt) ? Op_ReverseBytesV : 0);\n+    return (bt == T_LONG ? Op_ReverseBytesV : 0);\n@@ -338,11 +346,0 @@\n-bool VectorNode::is_type_transition_long_to_int(Node* n) {\n-  switch(n->Opcode()) {\n-    case Op_PopCountL:\n-    case Op_CountLeadingZerosL:\n-    case Op_CountTrailingZerosL:\n-       return true;\n-    default:\n-       return false;\n-  }\n-}\n-\n@@ -473,0 +470,2 @@\n+    case Op_ConvF2HF:\n+    case Op_ConvHF2F:\n@@ -1334,0 +1333,2 @@\n+    case Op_VectorCastHF2F: return new VectorCastHF2FNode(n1, vt);\n+    case Op_VectorCastF2HF: return new VectorCastF2HFNode(n1, vt);\n@@ -1340,1 +1341,1 @@\n-int VectorCastNode::opcode(BasicType bt, bool is_signed) {\n+int VectorCastNode::opcode(int sopc, BasicType bt, bool is_signed) {\n@@ -1342,0 +1343,15 @@\n+\n+  \/\/ Handle special case for to\/from Half Float conversions\n+  switch (sopc) {\n+    case Op_ConvHF2F:\n+      assert(bt == T_SHORT, \"\");\n+      return Op_VectorCastHF2F;\n+    case Op_ConvF2HF:\n+      assert(bt == T_FLOAT, \"\");\n+      return Op_VectorCastF2HF;\n+    default:\n+      \/\/ Handled normally below\n+      break;\n+  }\n+\n+  \/\/ Handle normal conversions\n@@ -1360,1 +1376,1 @@\n-    int vopc = VectorCastNode::opcode(src_type);\n+    int vopc = VectorCastNode::opcode(opc, src_type);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":31,"deletions":15,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -102,1 +102,0 @@\n-  static bool is_type_transition_long_to_int(Node* n);\n@@ -554,1 +553,3 @@\n-  PopCountVLNode(Node* in, const TypeVect* vt) : VectorNode(in,vt) {}\n+  PopCountVLNode(Node* in, const TypeVect* vt) : VectorNode(in,vt) {\n+    assert(vt->element_basic_type() == T_LONG, \"must be long\");\n+  }\n@@ -1424,1 +1425,1 @@\n-class VectorTestNode : public Node {\n+class VectorTestNode : public CmpNode {\n@@ -1432,1 +1433,1 @@\n-  VectorTestNode(Node* in1, Node* in2, BoolTest::mask predicate) : Node(NULL, in1, in2), _predicate(predicate) {\n+  VectorTestNode(Node* in1, Node* in2, BoolTest::mask predicate) : CmpNode(in1, in2), _predicate(predicate) {\n@@ -1437,0 +1438,4 @@\n+  virtual const Type* Value(PhaseGVN* phase) const { return TypeInt::CC; }\n+  virtual const Type* sub(const Type*, const Type*) const { return TypeInt::CC; }\n+  BoolTest::mask get_predicate() const { return _predicate; }\n+\n@@ -1440,4 +1445,0 @@\n-  virtual const Type *bottom_type() const { return TypeInt::BOOL; }\n-  virtual uint ideal_reg() const { return Op_RegI; }  \/\/ TODO Should be RegFlags but due to missing comparison flags for BoolTest\n-                                                      \/\/ in middle-end, we make it boolean result directly.\n-  BoolTest::mask get_predicate() const { return _predicate; }\n@@ -1544,1 +1545,1 @@\n-  static int  opcode(BasicType bt, bool is_signed = true);\n+  static int  opcode(int opc, BasicType bt, bool is_signed = true);\n@@ -1630,0 +1631,16 @@\n+class VectorCastHF2FNode : public VectorCastNode {\n+ public:\n+  VectorCastHF2FNode(Node* in, const TypeVect* vt) : VectorCastNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == T_SHORT, \"must be short\");\n+  }\n+  virtual int Opcode() const;\n+};\n+\n+class VectorCastF2HFNode : public VectorCastNode {\n+ public:\n+  VectorCastF2HFNode(Node* in, const TypeVect* vt) : VectorCastNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == T_FLOAT, \"must be float\");\n+  }\n+  virtual int Opcode() const;\n+};\n+\n@@ -1735,1 +1752,4 @@\n-  : VectorNode(in, vt) {}\n+  : VectorNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == vt->element_basic_type(),\n+           \"must be the same\");\n+  }\n@@ -1743,1 +1763,4 @@\n-  : VectorNode(in, vt) {}\n+  : VectorNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == vt->element_basic_type(),\n+           \"must be the same\");\n+  }\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":34,"deletions":11,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/resourceHash.hpp\"\n@@ -32,1 +33,1 @@\n-  for (uint32_t i = 0; i < MAX; i++) {\n+  for (uint32_t i = 0; i < LOCATION_LIMIT; i++) {\n@@ -38,1 +39,1 @@\n-  assert(loc < MAX, \"oob\");\n+  assert(loc < LOCATION_LIMIT, \"oob\");\n@@ -47,1 +48,1 @@\n-  assert(loc < MAX, \"oob\");\n+  assert(loc < LOCATION_LIMIT, \"oob\");\n@@ -119,1 +120,0 @@\n-    BasicType arg_bt   = move.bt;\n@@ -123,1 +123,1 @@\n-    os->print(\"Move a %s from \", null_safe_string(type2name(arg_bt)));\n+    os->print(\"Move from \");\n@@ -185,0 +185,21 @@\n+  class MoveOperation;\n+\n+  \/\/ segment_mask_or_size is not taken into account since\n+  \/\/ VMStorages that differ only in mask or size can still\n+  \/\/ conflict\n+  static inline unsigned hash(const VMStorage& vms) {\n+    return static_cast<unsigned int>(vms.type()) ^ vms.index_or_offset();\n+  }\n+  static inline bool equals(const VMStorage& a, const VMStorage& b) {\n+    return a.type() == b.type() && a.index_or_offset() == b.index_or_offset();\n+  }\n+\n+  using KillerTable = ResourceHashtable<\n+    VMStorage, MoveOperation*,\n+    32, \/\/ doesn't need to be big. don't have that many argument registers (in known ABIs)\n+    AnyObj::RESOURCE_AREA,\n+    mtInternal,\n+    ComputeMoveOrder::hash,\n+    ComputeMoveOrder::equals\n+    >;\n+\n@@ -188,3 +209,3 @@\n-    VMStorage        _src;\n-    VMStorage        _dst;\n-    bool             _processed;\n+    VMStorage       _src;\n+    VMStorage       _dst;\n+    bool            _processed;\n@@ -193,7 +214,0 @@\n-    BasicType       _bt;\n-\n-    static int get_id(VMStorage r) {\n-      assert((r.index_or_offset() & 0xFF000000) == 0, \"index or offset too large\");\n-      \/\/ assuming mask and size doesn't matter for now\n-      return ((int) r.type()) | (r.index_or_offset() << 8);\n-    }\n@@ -202,2 +216,2 @@\n-    MoveOperation(VMStorage src, VMStorage dst, BasicType bt):\n-      _src(src), _dst(dst), _processed(false), _next(NULL), _prev(NULL), _bt(bt) {}\n+    MoveOperation(VMStorage src, VMStorage dst):\n+      _src(src), _dst(dst), _processed(false), _next(nullptr), _prev(nullptr) {}\n@@ -205,6 +219,6 @@\n-    int src_id() const          { return get_id(_src); }\n-    int dst_id() const          { return get_id(_dst); }\n-    MoveOperation* next() const { return _next; }\n-    MoveOperation* prev() const { return _prev; }\n-    void set_processed()        { _processed = true; }\n-    bool is_processed() const   { return _processed; }\n+    const VMStorage& src() const { return _src; }\n+    const VMStorage& dst() const { return _dst; }\n+    MoveOperation* next()  const { return _next; }\n+    MoveOperation* prev()  const { return _prev; }\n+    void set_processed()         { _processed = true; }\n+    bool is_processed()    const { return _processed; }\n@@ -216,1 +230,1 @@\n-      MoveOperation* new_store = new MoveOperation(temp_register, _dst, _bt);\n+      MoveOperation* new_store = new MoveOperation(temp_register, _dst);\n@@ -222,1 +236,1 @@\n-      _prev = NULL;\n+      _prev = nullptr;\n@@ -230,1 +244,1 @@\n-    void link(GrowableArray<MoveOperation*>& killer) {\n+    void link(KillerTable& killer) {\n@@ -232,5 +246,6 @@\n-      MoveOperation* n = killer.at_grow(src_id(), NULL);\n-      if (n != NULL) {\n-        assert(_next == NULL && n->_prev == NULL, \"shouldn't have been set yet\");\n-        _next = n;\n-        n->_prev = this;\n+      MoveOperation** n = killer.get(_src);\n+      if (n != nullptr) {\n+        MoveOperation* src_killer = *n;\n+        assert(_next == nullptr && src_killer->_prev == nullptr, \"shouldn't have been set yet\");\n+        _next = src_killer;\n+        src_killer->_prev = this;\n@@ -241,1 +256,1 @@\n-      return {_bt, _src, _dst};\n+      return {_src, _dst};\n@@ -283,1 +298,1 @@\n-      if (out_reg.is_stack()) {\n+      if (out_reg.is_stack() || out_reg.is_frame_data()) {\n@@ -287,1 +302,1 @@\n-        Move move{bt, in_reg, out_reg};\n+        Move move{in_reg, out_reg};\n@@ -297,1 +312,1 @@\n-        _edges.append(new MoveOperation(in_reg, out_reg, bt));\n+        _edges.append(new MoveOperation(in_reg, out_reg));\n@@ -308,3 +323,2 @@\n-    \/\/ Record which moves kill which values\n-    \/\/ FIXME should be a map\n-    GrowableArray<MoveOperation*> killer; \/\/ essentially a map of register id -> MoveOperation*\n+    \/\/ Record which moves kill which registers\n+    KillerTable killer; \/\/ a map of VMStorage -> MoveOperation*\n@@ -313,1 +327,1 @@\n-      assert(killer.at_grow(s->dst_id(), NULL) == NULL,\n+      assert(!killer.contains(s->dst()),\n@@ -315,1 +329,1 @@\n-      killer.at_put_grow(s->dst_id(), s, NULL);\n+      killer.put(s->dst(), s);\n@@ -317,1 +331,1 @@\n-    assert(killer.at_grow(MoveOperation::get_id(temp_register), NULL) == NULL,\n+    assert(!killer.contains(temp_register),\n@@ -335,1 +349,1 @@\n-        while (start->prev() != NULL && start->prev() != s) {\n+        while (start->prev() != nullptr && start->prev() != s) {\n@@ -342,1 +356,1 @@\n-        while (start != NULL) {\n+        while (start != nullptr) {\n","filename":"src\/hotspot\/share\/prims\/foreignGlobals.cpp","additions":57,"deletions":43,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"prims\/vmstorage.inline.hpp\"\n+#include \"prims\/vmstorage.hpp\"\n@@ -44,2 +44,2 @@\n-    CAPTURED_STATE_MASK,\n-    MAX\n+    CAPTURED_STATE_BUFFER,\n+    LOCATION_LIMIT\n@@ -48,1 +48,1 @@\n-  VMStorage _locs[MAX];\n+  VMStorage _locs[LOCATION_LIMIT];\n@@ -76,1 +76,1 @@\n-  static void parse_register_array(objArrayOop jarray, int type_index, GrowableArray<T>& array, T (*converter)(int));\n+  static void parse_register_array(objArrayOop jarray, StorageType type_index, GrowableArray<T>& array, T (*converter)(int));\n@@ -119,1 +119,0 @@\n-  BasicType bt;\n","filename":"src\/hotspot\/share\/prims\/foreignGlobals.hpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n-void ForeignGlobals::parse_register_array(objArrayOop jarray, int type_index, GrowableArray<T>& array, T (*converter)(int)) {\n-  objArrayOop subarray = oop_cast<objArrayOop>(jarray->obj_at(type_index));\n+void ForeignGlobals::parse_register_array(objArrayOop jarray, StorageType type_index, GrowableArray<T>& array, T (*converter)(int)) {\n+  objArrayOop subarray = oop_cast<objArrayOop>(jarray->obj_at((int) type_index));\n","filename":"src\/hotspot\/share\/prims\/foreignGlobals.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -609,3 +609,0 @@\n-  \/\/ !important! make sure all to call thread->set_in_asgct(false) before every return\n-  thread->set_in_asgct(true);\n-\n@@ -669,1 +666,0 @@\n-  thread->set_in_asgct(false);\n","filename":"src\/hotspot\/share\/prims\/forte.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1366,0 +1366,48 @@\n+class ScopedValueBindingsResolver {\n+public:\n+  InstanceKlass* Carrier_klass;\n+  ScopedValueBindingsResolver(JavaThread* THREAD) {\n+    Klass *k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_incubator_concurrent_ScopedValue_Carrier(), true, THREAD);\n+    Carrier_klass = InstanceKlass::cast(k);\n+  }\n+};\n+\n+JVM_ENTRY(jobject, JVM_FindScopedValueBindings(JNIEnv *env, jclass cls))\n+  ResourceMark rm(THREAD);\n+  GrowableArray<Handle>* local_array = new GrowableArray<Handle>(12);\n+  JvmtiVMObjectAllocEventCollector oam;\n+\n+  static ScopedValueBindingsResolver resolver(THREAD);\n+\n+  \/\/ Iterate through Java frames\n+  vframeStream vfst(thread);\n+  for(; !vfst.at_end(); vfst.next()) {\n+    int loc = -1;\n+    \/\/ get method of frame\n+    Method* method = vfst.method();\n+\n+    Symbol *name = method->name();\n+\n+    InstanceKlass* holder = method->method_holder();\n+    if (name == vmSymbols::runWith_method_name()) {\n+      if ((holder == resolver.Carrier_klass\n+           || holder == vmClasses::VirtualThread_klass()\n+           || holder == vmClasses::Thread_klass())) {\n+        loc = 1;\n+      }\n+    }\n+\n+    if (loc != -1) {\n+      javaVFrame *frame = vfst.asJavaVFrame();\n+      StackValueCollection* locals = frame->locals();\n+      StackValue* head_sv = locals->at(loc); \/\/ jdk\/incubator\/concurrent\/ScopedValue$Snapshot\n+      Handle result = head_sv->get_obj();\n+      assert(!head_sv->obj_is_scalar_replaced(), \"found scalar-replaced object\");\n+      if (result() != NULL) {\n+        return JNIHandles::make_local(THREAD, result());\n+      }\n+    }\n+  }\n+\n+  return NULL;\n+JVM_END\n@@ -3117,6 +3165,2 @@\n-JVM_ENTRY(jobject, JVM_ExtentLocalCache(JNIEnv* env, jclass threadClass))\n-  oop theCache = thread->extentLocalCache();\n-  if (theCache) {\n-    arrayOop objs = arrayOop(theCache);\n-    assert(objs->length() == ExtentLocalCacheSize * 2, \"wrong length\");\n-  }\n+JVM_ENTRY(jobject, JVM_ScopedValueCache(JNIEnv* env, jclass threadClass))\n+  oop theCache = thread->scopedValueCache();\n@@ -3126,1 +3170,1 @@\n-JVM_ENTRY(void, JVM_SetExtentLocalCache(JNIEnv* env, jclass threadClass,\n+JVM_ENTRY(void, JVM_SetScopedValueCache(JNIEnv* env, jclass threadClass,\n@@ -3129,4 +3173,1 @@\n-  if (objs != NULL) {\n-    assert(objs->length() == ExtentLocalCacheSize * 2, \"wrong length\");\n-  }\n-  thread->set_extentLocalCache(objs);\n+  thread->set_scopedValueCache(objs);\n@@ -4022,0 +4063,9 @@\n+\n+\/*\n+ * Ensure that code doing a stackwalk and using javaVFrame::locals() to\n+ * get the value will see a materialized value and not a scalar-replaced\n+ * null value.\n+ *\/\n+JVM_ENTRY(void, JVM_EnsureMaterializedForStackWalk_func(JNIEnv* env, jobject vthread, jobject value))\n+  JVM_EnsureMaterializedForStackWalk(env, value);\n+JVM_END\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":61,"deletions":11,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -1327,1 +1327,1 @@\n-  Handle            _scratch_mirror;\n+  OopHandle         _scratch_mirror;\n@@ -1335,2 +1335,2 @@\n-    _scratch_mirror = Handle(_state->get_thread(), _scratch_class->java_mirror());\n-    _scratch_class->replace_java_mirror(the_class->java_mirror());\n+    _scratch_mirror = the_class->java_mirror_handle();  \/\/ this is a copy that is swapped\n+    _scratch_class->swap_java_mirror_handle(_scratch_mirror);\n@@ -1342,1 +1342,1 @@\n-    _scratch_class->replace_java_mirror(_scratch_mirror());\n+    _scratch_class->swap_java_mirror_handle(_scratch_mirror);\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -523,2 +523,7 @@\n-        case T_BYTE:\n-        case T_SHORT:\n+        case T_SHORT: return Op_ReverseBytesS;\n+        \/\/ Superword requires type consistency between the ReverseBytes*\n+        \/\/ node and the data. But there's no ReverseBytesB node because\n+        \/\/ no reverseBytes() method in Java Byte class. T_BYTE can only\n+        \/\/ appear in VectorAPI calls. We reuse Op_ReverseBytesI for this\n+        \/\/ to ensure vector intrinsification succeeds.\n+        case T_BYTE:  \/\/ Intentionally fall-through\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-#include \"prims\/vmstorage.inline.hpp\"\n+#include \"prims\/vmstorage.hpp\"\n","filename":"src\/hotspot\/share\/prims\/vmstorage.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,4 +24,2 @@\n-#ifndef SHARE_PRIMS_VMSTORAGEBASE_INLINE_HPP\n-#define SHARE_PRIMS_VMSTORAGEBASE_INLINE_HPP\n-\n-\/\/ DO NOT INCLUDE THIS FILE. INCLUDE vmstorage.inline.hpp INSTEAD\n+#ifndef SHARE_PRIMS_VMSTORAGE_HPP\n+#define SHARE_PRIMS_VMSTORAGE_HPP\n@@ -100,1 +98,3 @@\n-#endif \/\/ SHARE_PRIMS_VMSTORAGEBASE_INLINE_HPP\n+#include CPU_HEADER(vmstorage)\n+\n+#endif \/\/ SHARE_PRIMS_VMSTORAGE_HPP\n","filename":"src\/hotspot\/share\/prims\/vmstorage.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"src\/hotspot\/share\/prims\/vmstorageBase.inline.hpp","status":"renamed"},{"patch":"@@ -1,31 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifndef SHARE_PRIMS_VMSTORAGE_INLINE_HPP\n-#define SHARE_PRIMS_VMSTORAGE_INLINE_HPP\n-\n-#include \"utilities\/macros.hpp\"\n-\n-#include CPU_HEADER_INLINE(vmstorage)\n-\n-#endif \/\/ SHARE_PRIMS_VMSTORAGE_INLINE_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/prims\/vmstorage.inline.hpp","additions":0,"deletions":31,"binary":false,"changes":31,"status":"deleted"},{"patch":"@@ -164,7 +164,0 @@\n-\/\/ NOTE: do *not* use stringStream. this function is called by\n-\/\/       fatal error handlers. if the crash is in native thread,\n-\/\/       stringStream cannot get resource allocated and will SEGV.\n-const char* Abstract_VM_Version::jre_release_version() {\n-  return VERSION_STRING;\n-}\n-\n@@ -284,4 +277,0 @@\n-const char *Abstract_VM_Version::vm_build_user() {\n-  return HOTSPOT_BUILD_USER;\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -105,1 +105,0 @@\n-  static const char* vm_build_user();\n@@ -118,1 +117,0 @@\n-  static const char* jre_release_version();\n@@ -169,6 +167,0 @@\n-  \/\/ Number of page sizes efficiently supported by the hardware.  Most chips now\n-  \/\/ support two sizes, thus this default implementation.  Processor-specific\n-  \/\/ subclasses should define new versions to hide this one as needed.  Note\n-  \/\/ that the O\/S may support more sizes, but at most this many are used.\n-  static uint page_size_count() { return 2; }\n-\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1957,2 +1957,4 @@\n-    if (!create_numbered_module_property(\"jdk.module.addmods\", \"jdk.internal.vm.ci\", addmods_count++)) {\n-      return false;\n+    if (ClassLoader::is_module_observable(\"jdk.internal.vm.ci\")) {\n+      if (!create_numbered_module_property(\"jdk.module.addmods\", \"jdk.internal.vm.ci\", addmods_count++)) {\n+        return false;\n+      }\n@@ -4166,32 +4168,0 @@\n-const char* Arguments::PropertyList_get_key_at(SystemProperty *pl, int index) {\n-  int count = 0;\n-  const char* ret_val = NULL;\n-\n-  while(pl != NULL) {\n-    if(count >= index) {\n-      ret_val = pl->key();\n-      break;\n-    }\n-    count++;\n-    pl = pl->next();\n-  }\n-\n-  return ret_val;\n-}\n-\n-char* Arguments::PropertyList_get_value_at(SystemProperty* pl, int index) {\n-  int count = 0;\n-  char* ret_val = NULL;\n-\n-  while(pl != NULL) {\n-    if(count >= index) {\n-      ret_val = pl->value();\n-      break;\n-    }\n-    count++;\n-    pl = pl->next();\n-  }\n-\n-  return ret_val;\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":4,"deletions":34,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -89,1 +89,0 @@\n-  inline void set_path(const char* path) { _path->set_value(path); }\n@@ -177,1 +176,0 @@\n-  void set_invalid()                        { _state = agent_invalid; }\n@@ -595,2 +593,0 @@\n-  static const char* PropertyList_get_key_at(SystemProperty* pl,int index);\n-  static char* PropertyList_get_value_at(SystemProperty* pl,int index);\n@@ -621,1 +617,0 @@\n-  static char* get_jdk_boot_class_path_append() { return _jdk_boot_class_path_append->value(); }\n@@ -626,1 +621,0 @@\n-  static char* get_ext_dirs()     { return _ext_dirs;  }\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -106,2 +106,0 @@\n-  static CompiledMethod* enter_special() { return _enter_special; }\n-\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -391,1 +391,0 @@\n-  void freeze_fast_init_cont_data(intptr_t* frame_sp);\n@@ -1724,1 +1723,0 @@\n-  void patch_chunk_pd(intptr_t* sp); \/\/ TODO remove\n@@ -1806,2 +1804,0 @@\n-  int thaw_size() const { return _thaw_size; }\n-  int argsize() const { return _argsize; }\n@@ -1868,1 +1864,0 @@\n-  \/\/ patch_chunk_pd(sp); -- TODO: If not needed - remove method; it's not used elsewhere\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -78,4 +78,0 @@\n-\n-  static char* method_name(Method* m) { return m != nullptr ? m->name_and_sig_as_C_string() : nullptr; }\n-  static Method* top_java_frame_method(const frame& f);\n-  static Method* bottom_java_frame_method(const frame& f)  { return frame_method(f); }\n@@ -100,1 +96,0 @@\n-  static int size(const frame& f, InterpreterOopMap* mask);\n@@ -121,1 +116,0 @@\n-  static inline int num_oops(const frame& f);\n@@ -131,2 +125,0 @@\n-  static inline int num_oops(const frame& f);\n-\n","filename":"src\/hotspot\/share\/runtime\/continuationHelper.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -64,15 +64,0 @@\n-inline Method* ContinuationHelper::Frame::top_java_frame_method(const frame& f) {\n-  Method* m = nullptr;\n-  if (f.is_interpreted_frame()) {\n-    m = f.interpreter_frame_method();\n-  } else if (f.is_compiled_frame()) {\n-    CompiledMethod* cm = f.cb()->as_compiled_method();\n-    ScopeDesc* scope = cm->scope_desc_at(f.pc());\n-    m = scope->method();\n-  } else if (f.is_native_frame()) {\n-    m = f.cb()->as_nmethod()->method();\n-  }\n-\n-  return m;\n-}\n-\n@@ -134,4 +119,0 @@\n-inline int ContinuationHelper::InterpretedFrame::size(const frame&f, InterpreterOopMap* mask) {\n-  return InterpretedFrame::frame_bottom(f) - InterpretedFrame::frame_top(f, mask);\n-}\n-\n@@ -159,5 +140,0 @@\n-inline int ContinuationHelper::NonInterpretedFrame::num_oops(const frame& f) {\n-  assert(!f.is_interpreted_frame(), \"\");\n-  return f.num_oops();\n-}\n-\n@@ -168,5 +144,0 @@\n-inline int ContinuationHelper::CompiledFrame::num_oops(const frame& f) {\n-  assert(CompiledFrame::is_instance(f), \"Not a compiled frame\");\n-  return f.num_oops() + 1;\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/continuationHelper.inline.hpp","additions":0,"deletions":29,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -44,2 +44,0 @@\n-\n-  static inline oop name(oop ref);\n@@ -66,1 +64,0 @@\n-  static inline oop target(oop continuation);\n@@ -68,2 +65,0 @@\n-  static inline oop yieldInfo(oop continuation);\n-  static inline void set_yieldInfo(oop continuation, oop value);\n@@ -72,1 +67,0 @@\n-  static inline bool on_local_stack(oop continuation, address adr);\n@@ -133,6 +127,6 @@\n-   static inline oop cont(oop chunk);\n-   static inline void set_cont(oop chunk, oop value);\n-   template<typename P>\n-   static inline void set_cont_raw(oop chunk, oop value);\n-   template<DecoratorSet decorators>\n-   static inline void set_cont_access(oop chunk, oop value);\n+  static inline oop cont(oop chunk);\n+  static inline void set_cont(oop chunk, oop value);\n+  template<typename P>\n+  static inline void set_cont_raw(oop chunk, oop value);\n+  template<DecoratorSet decorators>\n+  static inline void set_cont_access(oop chunk, oop value);\n","filename":"src\/hotspot\/share\/runtime\/continuationJavaClasses.hpp","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -36,4 +36,0 @@\n-inline oop jdk_internal_vm_ContinuationScope::name(oop ref) {\n-  return ref->obj_field(_name_offset);\n-}\n-\n@@ -44,4 +40,0 @@\n-inline oop jdk_internal_vm_Continuation::target(oop continuation) {\n-  return continuation->obj_field(_target_offset);\n-}\n-\n@@ -52,8 +44,0 @@\n-inline oop jdk_internal_vm_Continuation::yieldInfo(oop continuation) {\n-  return continuation->obj_field(_yieldInfo_offset);\n-}\n-\n-inline void jdk_internal_vm_Continuation::set_yieldInfo(oop continuation, oop value) {\n-  continuation->obj_field_put(_yieldInfo_offset, value);\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/continuationJavaClasses.inline.hpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -114,1 +114,0 @@\n-  inline oop parent();\n@@ -116,1 +115,0 @@\n-  inline void set_preempted(bool value);\n@@ -165,4 +163,0 @@\n-inline oop ContinuationWrapper::parent() {\n-  return jdk_internal_vm_Continuation::parent(_continuation);\n-}\n-\n@@ -173,4 +167,0 @@\n-inline void ContinuationWrapper::set_preempted(bool value) {\n-  jdk_internal_vm_Continuation::set_preempted(_continuation, value);\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/continuationWrapper.inline.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -101,2 +101,0 @@\n-bool DeoptimizationMarker::_is_active = false;\n-\n@@ -129,1 +127,0 @@\n-\n@@ -136,8 +133,0 @@\n-\n-intptr_t* Deoptimization::UnrollBlock::value_addr_at(int register_number) const {\n-  assert(register_number < RegisterMap::reg_count, \"checking register number\");\n-  return &_register_block[register_number * 2];\n-}\n-\n-\n-\n@@ -153,1 +142,0 @@\n-\n@@ -167,1 +155,0 @@\n-\n@@ -457,5 +444,2 @@\n-    \/\/ FIXME: This very crudely destroys all ExtentLocal bindings. This\n-    \/\/ is better than a bound value escaping, but far from ideal.\n-    oop java_thread = current->threadObj();\n-    current->set_extentLocalCache(NULL);\n-    java_lang_Thread::clear_extentLocalBindings(java_thread);\n+    \/\/ This destroys all ScopedValue bindings.\n+    current->clear_scopedValueBindings();\n@@ -936,1 +920,0 @@\n-  DeoptimizationMarker dm;\n@@ -1658,1 +1641,0 @@\n-  DeoptimizationMarker dm;\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":2,"deletions":20,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -230,3 +230,0 @@\n-    \/\/ Returns where a register is located.\n-    intptr_t* value_addr_at(int register_number) const;\n-\n@@ -236,2 +233,0 @@\n-    address*  frame_pcs()   const { return _frame_pcs ; }\n-    int  unpack_kind()   const { return _unpack_kind; }\n@@ -253,2 +248,0 @@\n-    static int register_block_offset_in_bytes()            { return offset_of(UnrollBlock, _register_block);            }\n-    static int return_type_offset_in_bytes()               { return offset_of(UnrollBlock, _return_type);               }\n@@ -476,9 +469,0 @@\n-\n-class DeoptimizationMarker : StackObj {  \/\/ for profiling\n-  static bool _is_active;\n-public:\n-  DeoptimizationMarker()  { _is_active = true; }\n-  ~DeoptimizationMarker() { _is_active = false; }\n-  static bool is_active() { return _is_active; }\n-};\n-\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -123,2 +123,0 @@\n-  static bool deoptimizing_objects_for_all_threads() { return _deoptimizing_objects_for_all_threads; }\n-\n","filename":"src\/hotspot\/share\/runtime\/escapeBarrier.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,5 +38,0 @@\n-\n-oop fieldDescriptor::loader() const {\n-  return _cp->pool_holder()->class_loader();\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -64,1 +64,0 @@\n-  oop loader()                    const;\n@@ -86,1 +85,0 @@\n-  bool is_public()                const    { return access_flags().is_public(); }\n@@ -89,1 +87,0 @@\n-  bool is_package_private()       const    { return !is_public() && !is_private() && !is_protected(); }\n@@ -94,2 +91,0 @@\n-  bool is_volatile()              const    { return access_flags().is_volatile(); }\n-  bool is_transient()             const    { return access_flags().is_transient(); }\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -95,12 +95,0 @@\n-JVMFlag::Error ExtentLocalCacheSizeConstraintFunc(intx value, bool verbose) {\n-  if (!is_power_of_2(value)) {\n-    JVMFlag::printError(verbose,\n-                        \"ExtentLocalCacheSize (\" INTX_FORMAT \") must be \"\n-                        \"power of 2\\n\",\n-                        value);\n-    return JVMFlag::VIOLATES_CONSTRAINT;\n-  }\n-\n-  return JVMFlag::SUCCESS;\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-  f(intx,   ExtentLocalCacheSizeConstraintFunc)        \\\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -776,2 +776,0 @@\n-\n-  int max_locals()  { return _max_locals; }\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -213,3 +213,0 @@\n-  \/\/ the number of oops in the frame for non-interpreted frames\n-  inline int num_oops() const;\n-\n@@ -238,1 +235,0 @@\n-  frame sender_for_native_frame(RegisterMap* map) const;\n@@ -258,14 +254,0 @@\n-  \/\/ accessors for locals\n-  oop obj_at(int offset) const                   { return *obj_at_addr(offset);  }\n-  void obj_at_put(int offset, oop value)         { *obj_at_addr(offset) = value; }\n-\n-  jint int_at(int offset) const                  { return *int_at_addr(offset);  }\n-  void int_at_put(int offset, jint value)        { *int_at_addr(offset) = value; }\n-\n-  oop*      obj_at_addr(int offset) const        { return (oop*)     addr_at(offset); }\n-\n-  oop*      adjusted_obj_at_addr(Method* method, int index) { return obj_at_addr(adjust_offset(method, index)); }\n-\n- private:\n-  jint*    int_at_addr(int offset) const         { return (jint*)    addr_at(offset); }\n-\n@@ -468,1 +450,0 @@\n-  int adjust_offset(Method* method, int index); \/\/ helper for above fn\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -107,7 +107,0 @@\n-inline int frame::num_oops() const {\n-  assert(!is_interpreted_frame(), \"interpreted\");\n-  assert(oop_map() != NULL, \"\");\n-  return oop_map()->num_oops() ;\n-}\n-\n-\n","filename":"src\/hotspot\/share\/runtime\/frame.inline.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -458,4 +458,0 @@\n-  develop(bool, UseMallocOnly, false,                                       \\\n-          \"Use only malloc\/free for allocation (no resource area\/arena). \"  \\\n-          \"Used to help diagnose memory stomping bugs.\")                    \\\n-                                                                            \\\n@@ -520,0 +516,3 @@\n+  product(bool, ErrorLogSecondaryErrorDetails, false, DIAGNOSTIC,           \\\n+          \"If enabled, show details on secondary crashes in the error log\") \\\n+                                                                            \\\n@@ -1951,5 +1950,0 @@\n-  product(intx, ExtentLocalCacheSize, 16,                                   \\\n-          \"Size of the cache for scoped values\")                            \\\n-           range(0, max_intx)                                               \\\n-           constraint(ExtentLocalCacheSizeConstraintFunc, AtParse)          \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -199,1 +199,0 @@\n-    \/\/ Ignore UseMallocOnly by allocating only in arena.\n@@ -216,3 +215,0 @@\n-  \/\/ Number of handles in use\n-  size_t used() const     { return Arena::used() \/ oopSize; }\n-\n","filename":"src\/hotspot\/share\/runtime\/handles.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -129,9 +129,0 @@\n-  \/**\n-   * Performs comparison using only the major version, returning negative\n-   * if the major version of 'this' is less than the parameter, 0 if it is\n-   * equal, and a positive value if it is greater.\n-   *\/\n-  int compare_major(int version) const {\n-      return major_version() - version;\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/java.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-  JavaThread*      thread() const           { return _thread; }\n@@ -68,1 +67,0 @@\n-  oop              receiver()               { return _receiver; }\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -160,1 +160,1 @@\n-  _extentLocalCache = OopHandle(_thread_oop_storage, NULL);\n+  _scopedValueCache = OopHandle(_thread_oop_storage, NULL);\n@@ -189,2 +189,2 @@\n-oop JavaThread::extentLocalCache() const {\n-  return _extentLocalCache.resolve();\n+oop JavaThread::scopedValueCache() const {\n+  return _scopedValueCache.resolve();\n@@ -193,3 +193,16 @@\n-void JavaThread::set_extentLocalCache(oop p) {\n-  assert(_thread_oop_storage != NULL, \"not yet initialized\");\n-  _extentLocalCache.replace(p);\n+void JavaThread::set_scopedValueCache(oop p) {\n+  if (_scopedValueCache.ptr_raw() != NULL) { \/\/ i.e. if the OopHandle has been allocated\n+    _scopedValueCache.replace(p);\n+  } else {\n+    assert(p == NULL, \"not yet initialized\");\n+  }\n+}\n+\n+void JavaThread::clear_scopedValueBindings() {\n+  set_scopedValueCache(NULL);\n+  oop vthread_oop = vthread();\n+  \/\/ vthread may be null here if we get a VM error during startup,\n+  \/\/ before the java.lang.Thread instance has been created.\n+  if (vthread_oop != NULL) {\n+    java_lang_Thread::clear_scopedValueBindings(vthread_oop);\n+  }\n@@ -386,1 +399,0 @@\n-  _in_asgct(false),\n@@ -984,24 +996,0 @@\n-bool JavaThread::is_lock_owned_current(address adr) const {\n-  address stack_end = _stack_base - _stack_size;\n-  const ContinuationEntry* ce = vthread_continuation();\n-  address stack_base = ce != nullptr ? (address)ce->entry_sp() : _stack_base;\n-  if (stack_base > adr && adr >= stack_end) {\n-    return true;\n-  }\n-\n-  for (MonitorChunk* chunk = monitor_chunks(); chunk != NULL; chunk = chunk->next()) {\n-    if (chunk->contains(adr)) {\n-      return true;\n-    }\n-  }\n-\n-  return false;\n-}\n-\n-bool JavaThread::is_lock_owned_carrier(address adr) const {\n-  assert(is_vthread_mounted(), \"\");\n-  address stack_end = _stack_base - _stack_size;\n-  address stack_base = (address)vthread_continuation()->entry_sp();\n-  return stack_base > adr && adr >= stack_end;\n-}\n-\n@@ -1068,5 +1056,1 @@\n-  \/\/ Clear any extent-local bindings\n-  set_extentLocalCache(NULL);\n-  oop threadOop = threadObj();\n-  assert(threadOop != NULL, \"must be\");\n-  java_lang_Thread::clear_extentLocalBindings(threadOop);\n+  clear_scopedValueBindings();\n@@ -1474,4 +1458,0 @@\n-const char* JavaThread::thread_state_name() const {\n-  return _get_thread_state_name(_thread_state);\n-}\n-\n@@ -1912,5 +1892,0 @@\n-oop JavaThread::get_continuation() const {\n-  assert(threadObj() != nullptr, \"must be set\");\n-  return java_lang_Thread::continuation(threadObj());\n-}\n-\n@@ -2134,1 +2109,1 @@\n-  new_head->add(_extentLocalCache);\n+  new_head->add(_scopedValueCache);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":21,"deletions":46,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -87,1 +87,0 @@\n-  bool           _in_asgct;                      \/\/ Is set when this JavaThread is handling ASGCT call\n@@ -96,1 +95,1 @@\n-  OopHandle      _extentLocalCache;\n+  OopHandle      _scopedValueCache;\n@@ -472,5 +471,0 @@\n- public:\n-  jlong _extentLocal_hash_table_shift;\n-\n-  void allocate_extentLocal_hash_table(int count);\n-\n@@ -529,2 +523,3 @@\n-  oop extentLocalCache() const;\n-  void set_extentLocalCache(oop p);\n+  oop scopedValueCache() const;\n+  void set_scopedValueCache(oop p);\n+  void clear_scopedValueBindings();\n@@ -598,1 +593,0 @@\n-  oop get_continuation() const;\n@@ -673,2 +667,0 @@\n-  bool is_lock_owned_current(address adr) const; \/\/ virtual if mounted, otherwise whole thread\n-  bool is_lock_owned_carrier(address adr) const;\n@@ -700,1 +692,1 @@\n-  void set_callee_target  (Method* x)          { _callee_target   = x; }\n+  void set_callee_target  (Method* x)            { _callee_target   = x; }\n@@ -706,2 +698,1 @@\n-  Metadata*    vm_result_2() const               { return _vm_result_2; }\n-  void set_vm_result_2  (Metadata* x)          { _vm_result_2   = x; }\n+  void set_vm_result_2  (Metadata* x)            { _vm_result_2   = x; }\n@@ -713,1 +704,0 @@\n-  int  pending_deoptimization() const             { return _pending_deoptimization; }\n@@ -715,1 +705,0 @@\n-  bool has_pending_monitorenter() const           { return _pending_monitorenter; }\n@@ -736,2 +725,0 @@\n-  address  exception_handler_pc() const          { return _exception_handler_pc; }\n-  bool     is_method_handle_return() const       { return _is_method_handle_return == 1; }\n@@ -761,1 +748,1 @@\n-  static ByteSize extentLocalCache_offset()       { return byte_offset_of(JavaThread, _extentLocalCache); }\n+  static ByteSize scopedValueCache_offset()       { return byte_offset_of(JavaThread, _scopedValueCache); }\n@@ -790,1 +777,0 @@\n-  static ByteSize pending_failed_speculation_offset() { return byte_offset_of(JavaThread, _pending_failed_speculation); }\n@@ -926,1 +912,0 @@\n-  const char* thread_state_name() const;\n@@ -1047,1 +1032,0 @@\n-  void clear_popframe_forcing_deopt_reexecution()     { _popframe_condition &= ~popframe_force_deopt_reexecution_bit; }\n@@ -1099,1 +1083,0 @@\n-  int   should_post_on_exceptions_flag()  { return _should_post_on_exceptions_flag; }\n@@ -1174,4 +1157,0 @@\n-  \/\/ AsyncGetCallTrace support\n-  inline bool in_asgct(void) {return _in_asgct;}\n-  inline void set_in_asgct(bool value) {_in_asgct = value;}\n-\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":7,"deletions":28,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -255,9 +255,0 @@\n-size_t JNIHandles::global_handle_memory_usage() {\n-  return global_handles()->total_memory_usage();\n-}\n-\n-size_t JNIHandles::weak_global_handle_memory_usage() {\n-  return weak_global_handles()->total_memory_usage();\n-}\n-\n-\n@@ -542,15 +533,0 @@\n-\n-\n-size_t JNIHandleBlock::length() const {\n-  size_t result = 1;\n-  for (JNIHandleBlock* current = _next; current != NULL; current = current->_next) {\n-    result++;\n-  }\n-  return result;\n-}\n-\n-\/\/ This method is not thread-safe, i.e., must be called while holding a lock on the\n-\/\/ structure.\n-size_t JNIHandleBlock::memory_usage() const {\n-  return length() * sizeof(JNIHandleBlock);\n-}\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.cpp","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -111,2 +111,0 @@\n-  static size_t global_handle_memory_usage();\n-  static size_t weak_global_handle_memory_usage();\n@@ -183,2 +181,0 @@\n-  size_t length() const;                        \/\/ Length of chain starting with this block\n-  size_t memory_usage() const;\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,2 +37,0 @@\n-     static void engage();\n-     static void disengage();\n@@ -41,1 +39,0 @@\n-\n@@ -59,19 +56,0 @@\n-\n-\n-\/*\n- * the disengage() method is responsible for deactivating the periodic\n- * task. This  method is called from before_exit() in java.cpp and is only called\n- * after the WatcherThread has been stopped.\n- *\/\n-void JniPeriodicChecker::disengage() {\n-  if (CheckJNICalls && is_active()) {\n-    \/\/ remove JniPeriodicChecker\n-    _task->disenroll();\n-    delete _task;\n-    _task = NULL;\n-  }\n-}\n-\n-void jniPeriodicChecker_exit() {\n-  if (!CheckJNICalls) return;\n-}\n","filename":"src\/hotspot\/share\/runtime\/jniPeriodicChecker.cpp","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -47,2 +47,0 @@\n-    static void disengage();\n-\n@@ -50,3 +48,0 @@\n-\n-    static void initialize();\n-    static void destroy();\n@@ -55,2 +50,0 @@\n-void jniPeriodicChecker_exit();\n-\n","filename":"src\/hotspot\/share\/runtime\/jniPeriodicChecker.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -61,16 +61,0 @@\n-\n-#ifdef ASSERT\n-bool KeepStackGCProcessedMark::stack_is_kept_gc_processed(JavaThread* jt) {\n-  if (!Thread::current()->is_Java_thread()) {\n-    assert(SafepointSynchronize::is_at_safepoint() && Thread::current()->is_VM_thread(),\n-           \"must be either Java thread or VM thread in a safepoint\");\n-    return true;\n-  }\n-  StackWatermark* our_watermark = StackWatermarkSet::get(JavaThread::current(), StackWatermarkKind::gc);\n-  if (our_watermark == nullptr) {\n-    return true;\n-  }\n-  StackWatermark* their_watermark = StackWatermarkSet::get(jt, StackWatermarkKind::gc);\n-  return our_watermark->linked_watermark() == their_watermark;\n-}\n-#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/runtime\/keepStackGCProcessed.cpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -46,2 +46,0 @@\n-\n-  static bool stack_is_kept_gc_processed(JavaThread* jt) NOT_DEBUG({ return true; }) ;\n","filename":"src\/hotspot\/share\/runtime\/keepStackGCProcessed.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,3 +51,0 @@\n-  \/\/ Tells whether the monitor chunk is linked into the JavaThread\n-  bool is_linked() const                    { return next() != NULL; }\n-\n","filename":"src\/hotspot\/share\/runtime\/monitorChunk.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-  bool is_monitor_deflation_thread() const { return true; }\n","filename":"src\/hotspot\/share\/runtime\/monitorDeflationThread.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -122,1 +122,0 @@\n-  void   set_next(Mutex *next) { _next = next; }\n","filename":"src\/hotspot\/share\/runtime\/mutex.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -196,5 +196,0 @@\n-\n-void assert_locked_or_safepoint_or_handshake(const Mutex* lock, const JavaThread* thread) {\n-  if (thread->is_handshake_safe_for(Thread::current())) return;\n-  assert_locked_or_safepoint(lock);\n-}\n@@ -377,1 +372,1 @@\n-  defl(JNICritical_lock            , PaddedMonitor, MultiArray_lock); \/\/ used for JNI critical regions\n+  defl(JNICritical_lock            , PaddedMonitor, AdapterHandlerLibrary_lock); \/\/ used for JNI critical regions\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -179,2 +179,0 @@\n-char *lock_name(Mutex *mutex);\n-\n@@ -186,1 +184,0 @@\n-void assert_locked_or_safepoint_or_handshake(const Mutex* lock, const JavaThread* thread);\n@@ -191,1 +188,0 @@\n-#define assert_locked_or_safepoint_or_handshake(lock, thread)\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -207,2 +207,0 @@\n-  static int header_offset_in_bytes()      { return offset_of(ObjectMonitor, _header); }\n-  static int object_offset_in_bytes()      { return offset_of(ObjectMonitor, _object); }\n@@ -270,2 +268,0 @@\n-  \/\/ Get _next_om field with acquire semantics.\n-  ObjectMonitor* next_om_acquire() const;\n@@ -274,6 +270,0 @@\n-  \/\/ Set _next_om field to new_value with release semantics.\n-  void release_set_next_om(ObjectMonitor* new_value);\n-  \/\/ Try to set _next_om field to new_value if the current value matches\n-  \/\/ old_value, using Atomic::cmpxchg(). Otherwise, does not change the\n-  \/\/ _next_om field. Returns the prior value of the _next_om field.\n-  ObjectMonitor* try_set_next_om(ObjectMonitor* old_value, ObjectMonitor* new_value);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -163,5 +163,0 @@\n-\/\/ Get _next_om field with acquire semantics.\n-inline ObjectMonitor* ObjectMonitor::next_om_acquire() const {\n-  return Atomic::load_acquire(&_next_om);\n-}\n-\n@@ -173,12 +168,0 @@\n-\/\/ Set _next_om field to new_value with release semantics.\n-inline void ObjectMonitor::release_set_next_om(ObjectMonitor* new_value) {\n-  Atomic::release_store(&_next_om, new_value);\n-}\n-\n-\/\/ Try to set _next_om field to new_value if the current value matches\n-\/\/ old_value. Otherwise, does not change the _next_om field. Returns\n-\/\/ the prior value of the _next_om field.\n-inline ObjectMonitor* ObjectMonitor::try_set_next_om(ObjectMonitor* old_value, ObjectMonitor* new_value) {\n-  return Atomic::cmpxchg(&_next_om, old_value, new_value);\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.inline.hpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+#include \"services\/mallocHeader.inline.hpp\"\n@@ -717,6 +718,6 @@\n-    const size_t old_size = MallocTracker::malloc_header(memblock)->size();\n-\n-    \/\/ De-account the old block from NMT *before* calling the real realloc(3) since it\n-    \/\/ may invalidate old block including its header. This will also perform integrity checks\n-    \/\/ on the old block (e.g. overwriters) and mark the old header as dead.\n-    void* const old_outer_ptr = MemTracker::record_free(memblock);\n+    \/\/ Perform integrity checks on and mark the old block as dead *before* calling the real realloc(3) since it\n+    \/\/ may invalidate the old block, including its header.\n+    MallocHeader* header = MallocTracker::malloc_header(memblock);\n+    header->assert_block_integrity(); \/\/ Assert block hasn't been tampered with.\n+    const MallocHeader::FreeInfo free_info = header->free_info();\n+    header->mark_block_as_dead();\n@@ -725,1 +726,1 @@\n-    ALLOW_C_FUNCTION(::realloc, void* const new_outer_ptr = ::realloc(old_outer_ptr, new_outer_size);)\n+    ALLOW_C_FUNCTION(::realloc, void* const new_outer_ptr = ::realloc(header, new_outer_size);)\n@@ -728,6 +729,4 @@\n-      \/\/ If realloc(3) failed, the old block still exists. We must re-instantiate the old\n-      \/\/ NMT header then, since we marked it dead already. Otherwise subsequent os::realloc()\n-      \/\/ or os::free() calls would trigger block integrity asserts.\n-      void* p = MemTracker::record_malloc(old_outer_ptr, old_size, memflags, stack);\n-      assert(p == memblock, \"sanity\");\n-      return NULL;\n+      \/\/ realloc(3) failed and the block still exists.\n+      \/\/ We have however marked it as dead, revert this change.\n+      header->revive();\n+      return nullptr;\n@@ -735,0 +734,2 @@\n+    \/\/ realloc(3) succeeded, variable header now points to invalid memory and we need to deaccount the old block.\n+    MemTracker::deaccount(free_info);\n@@ -736,2 +737,2 @@\n-    \/\/ After a successful realloc(3), we re-account the resized block with its new size\n-    \/\/ to NMT. This re-instantiates the NMT header.\n+    \/\/ After a successful realloc(3), we account the resized block with its new size\n+    \/\/ to NMT.\n@@ -741,0 +742,1 @@\n+    size_t old_size = free_info.size;\n@@ -777,1 +779,1 @@\n-  \/\/ If NMT is enabled, this checks for heap overwrites, then de-accounts the old block.\n+  \/\/ When NMT is enabled this checks for heap overwrites, then deaccounts the old block.\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":18,"deletions":16,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -587,2 +587,0 @@\n-  static int pd_self_suspend_thread(Thread* thread);\n-\n@@ -1006,1 +1004,0 @@\n-  static void print_statistics();\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,23 +34,0 @@\n-class EnvironmentVariable : public CHeapObj<mtInternal> {\n- public:\n-  char* _key;\n-  char* _value;\n-\n-  EnvironmentVariable() {\n-    _key = NULL;\n-    _value = NULL;\n-  }\n-\n-  ~EnvironmentVariable() {\n-    FREE_C_HEAP_ARRAY(char, _key);\n-    FREE_C_HEAP_ARRAY(char, _value);\n-  }\n-\n-  EnvironmentVariable(char* key, char* value) {\n-    _key = key;\n-    _value = value;\n-  }\n-\n-};\n-\n-\n@@ -66,7 +43,6 @@\n-  CPUInformation() {\n-    _no_of_sockets = 0;\n-    _no_of_cores = 0;\n-    _no_of_hw_threads = 0;\n-    _description = NULL;\n-    _name = NULL;\n-  }\n+  CPUInformation() :\n+    _no_of_sockets(0),\n+    _no_of_cores(0),\n+    _no_of_hw_threads(0),\n+    _description(nullptr),\n+    _name(nullptr) {}\n@@ -124,15 +100,13 @@\n-  SystemProcess() {\n-    _pid  = 0;\n-    _name = NULL;\n-    _path = NULL;\n-    _command_line = NULL;\n-    _next = NULL;\n-  }\n-\n-  SystemProcess(int pid, char* name, char* path, char* command_line, SystemProcess* next) {\n-    _pid = pid;\n-    _name = name;\n-    _path = path;\n-    _command_line = command_line;\n-    _next = next;\n-  }\n+  SystemProcess() :\n+    _pid (0),\n+    _name(nullptr),\n+    _path(nullptr),\n+    _command_line(nullptr),\n+    _next(nullptr) {}\n+\n+  SystemProcess(int pid, char* name, char* path, char* command_line, SystemProcess* next) :\n+    _pid(pid),\n+    _name(name),\n+    _path(path),\n+    _command_line(command_line),\n+    _next(next) {}\n@@ -198,1 +172,1 @@\n-  _name(NULL),\n+  _name(nullptr),\n@@ -202,1 +176,1 @@\n-    assert(name != NULL, \"invariant\");\n+    assert(name != nullptr, \"invariant\");\n","filename":"src\/hotspot\/share\/runtime\/os_perf.hpp","additions":22,"deletions":48,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -193,4 +193,0 @@\n-int PerfLong::format(char* buffer, int length) {\n-  return jio_snprintf(buffer, length, JLONG_FORMAT, *(jlong*)_valuep);\n-}\n-\n@@ -236,4 +232,0 @@\n-int PerfString::format(char* buffer, int length) {\n-  return jio_snprintf(buffer, length, \"%s\", (char*)_valuep);\n-}\n-\n@@ -328,11 +320,0 @@\n-PerfDataList* PerfDataManager::all() {\n-\n-  MutexLocker ml(PerfDataManager_lock);\n-\n-  if (_all == NULL)\n-    return NULL;\n-\n-  PerfDataList* clone = _all->clone();\n-  return clone;\n-}\n-\n@@ -350,11 +331,0 @@\n-PerfDataList* PerfDataManager::constants() {\n-\n-  MutexLocker ml(PerfDataManager_lock);\n-\n-  if (_constants == NULL)\n-    return NULL;\n-\n-  PerfDataList* clone = _constants->clone();\n-  return clone;\n-}\n-\n@@ -461,21 +431,0 @@\n-PerfLongVariable* PerfDataManager::create_long_variable(CounterNS ns,\n-                                                        const char* name,\n-                                                        PerfData::Units u,\n-                                                        jlong* sp, TRAPS) {\n-\n-  \/\/ Sampled counters not supported if UsePerfData is false\n-  if (!UsePerfData) return NULL;\n-\n-  PerfLongVariable* p = new PerfLongVariable(ns, name, u, sp);\n-\n-  if (!p->is_valid()) {\n-    \/\/ allocation of native resources failed.\n-    delete p;\n-    THROW_0(vmSymbols::java_lang_OutOfMemoryError());\n-  }\n-\n-  add_item(p, true);\n-\n-  return p;\n-}\n-\n@@ -522,21 +471,0 @@\n-PerfLongCounter* PerfDataManager::create_long_counter(CounterNS ns,\n-                                                      const char* name,\n-                                                      PerfData::Units u,\n-                                                      jlong* sp, TRAPS) {\n-\n-  \/\/ Sampled counters not supported if UsePerfData is false\n-  if (!UsePerfData) return NULL;\n-\n-  PerfLongCounter* p = new PerfLongCounter(ns, name, u, sp);\n-\n-  if (!p->is_valid()) {\n-    \/\/ allocation of native resources failed.\n-    delete p;\n-    THROW_0(vmSymbols::java_lang_OutOfMemoryError());\n-  }\n-\n-  add_item(p, true);\n-\n-  return p;\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/perfData.cpp","additions":0,"deletions":72,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -336,4 +336,0 @@\n-\n-    \/\/ returns the value of the data portion of the item in the\n-    \/\/ PerfData memory region formatted as a string.\n-    virtual int format(char* cp, int length) = 0;\n@@ -365,2 +361,0 @@\n-    int format(char* buffer, int length);\n-\n@@ -426,1 +420,0 @@\n-    inline void add(jlong val) { (*(jlong*)_valuep) += val; }\n@@ -513,3 +506,0 @@\n-  public:\n-\n-    int format(char* buffer, int length);\n@@ -630,8 +620,0 @@\n-    \/\/ remove the given PerfData item from this list. When called\n-    \/\/ while iterating over the list, this method will result in a\n-    \/\/ change in the length of the container. The at(int index)\n-    \/\/ method is also impacted by this method as elements with an\n-    \/\/ index greater than the index of the element removed by this\n-    \/\/ method will be shifted down by one.\n-    inline void remove(PerfData *p);\n-\n@@ -671,3 +653,0 @@\n-    \/\/ return the list of all known PerfData items\n-    static PerfDataList* all();\n-    static inline int count();\n@@ -679,4 +658,0 @@\n-    \/\/ return the list of all known PerfData items that have a\n-    \/\/ variability classification of type Constant\n-    static PerfDataList* constants();\n-\n@@ -757,6 +732,0 @@\n-    static PerfStringVariable* create_string_variable(CounterNS ns,\n-                                                      const char* name,\n-                                                      const char *s, TRAPS) {\n-      return create_string_variable(ns, name, 0, s, THREAD);\n-    };\n-\n@@ -774,4 +743,0 @@\n-    static PerfLongVariable* create_long_variable(CounterNS, const char* name,\n-                                                  PerfData::Units u,\n-                                                  jlong* sp, TRAPS);\n-\n@@ -790,9 +755,0 @@\n-    static PerfLongCounter* create_long_counter(CounterNS ns, const char* name,\n-                                                PerfData::Units u, TRAPS) {\n-      return create_long_counter(ns, name, u, (jlong)0, THREAD);\n-    };\n-\n-    static PerfLongCounter* create_long_counter(CounterNS ns, const char* name,\n-                                                PerfData::Units u, jlong* sp,\n-                                                TRAPS);\n-\n@@ -823,5 +779,0 @@\n-    static PerfVariable* create_variable(CounterNS ns, const char* name,\n-                                         PerfData::Units u, jlong* sp, TRAPS) {\n-      return create_long_variable(ns, name, u, sp, THREAD);\n-    }\n-\n@@ -834,5 +785,0 @@\n-    static PerfCounter* create_counter(CounterNS ns, const char* name,\n-                                       PerfData::Units u, jlong ival, TRAPS) {\n-      return create_long_counter(ns, name, u, ival, THREAD);\n-    }\n-\n@@ -844,5 +790,0 @@\n-    static PerfCounter* create_counter(CounterNS ns, const char* name,\n-                                       PerfData::Units u, jlong* sp, TRAPS) {\n-      return create_long_counter(ns, name, u, sp, THREAD);\n-    }\n-\n@@ -903,3 +844,0 @@\n-    inline void suspend() { if (!UsePerfData) return; _t.stop(); }\n-    inline void resume() { if (!UsePerfData) return; _t.start(); }\n-\n","filename":"src\/hotspot\/share\/runtime\/perfData.hpp","additions":0,"deletions":62,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -41,4 +41,0 @@\n-inline void PerfDataList::remove(PerfData *p) {\n-  _set->remove(p);\n-}\n-\n@@ -49,4 +45,0 @@\n-inline int PerfDataManager::count() {\n-  return _all->length();\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/perfData.inline.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -73,1 +73,0 @@\n-  InstanceKlass* klass() const      { return _klass; }\n","filename":"src\/hotspot\/share\/runtime\/reflectionUtils.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -123,10 +123,0 @@\n-  address trusted_location(VMReg reg) const {\n-    return (address) _location[reg->value()];\n-  }\n-\n-  void verify(RegisterMap& other) {\n-    for (int i = 0; i < reg_count; ++i) {\n-      assert(_location[i] == other._location[i], \"\");\n-    }\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/registerMap.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -50,2 +50,0 @@\n-   virtual bool is_widen()      { return false; }\n-   virtual bool is_jump_widen() { return false; }\n@@ -76,2 +74,0 @@\n-  bool is_widen()              { return true; }\n-\n@@ -89,2 +85,0 @@\n-  bool is_jump_widen()         { return true; }\n-\n","filename":"src\/hotspot\/share\/runtime\/relocator.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-  RelocatorListener() {};\n","filename":"src\/hotspot\/share\/runtime\/relocator.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -100,2 +100,0 @@\n-  uintx* abort_count_addr()               { return &_abort_count; }\n-  uintx* abortX_count_addr()              { return &_abortX_count[0]; }\n","filename":"src\/hotspot\/share\/runtime\/rtmLocking.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -168,3 +168,0 @@\n-  \/\/ Assembly support\n-  static address address_of_state()             { return (address)&_state; }\n-\n","filename":"src\/hotspot\/share\/runtime\/safepoint.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -76,1 +76,0 @@\n-    inline uintptr_t get_polling_page();\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,6 +40,0 @@\n-\/\/ The acquire makes sure reading of polling page is done before\n-\/\/ the reading the handshake operation or the global state\n-inline uintptr_t SafepointMechanism::ThreadData::get_polling_page() {\n-  return Atomic::load_acquire(&_polling_page);\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.inline.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -146,1 +146,0 @@\n-int64_t SharedRuntime::_nof_optimized_calls = 0;\n@@ -152,1 +151,0 @@\n-int64_t SharedRuntime::_nof_optimized_interface_calls = 0;\n@@ -154,1 +152,0 @@\n-int64_t SharedRuntime::_nof_megamorphic_interface_calls = 0;\n@@ -683,11 +680,0 @@\n-\n-oop SharedRuntime::retrieve_receiver( Symbol* sig, frame caller ) {\n-  assert(caller.is_interpreted_frame(), \"\");\n-  int args_size = ArgumentSizeComputer(sig).size() + 1;\n-  assert(args_size <= caller.interpreter_frame_expression_stack_size(), \"receiver must be on interpreter stack\");\n-  oop result = cast_to_oop(*caller.interpreter_frame_tos_at(args_size - 1));\n-  assert(Universe::heap()->is_in(result) && oopDesc::is_oop(result), \"receiver must be an oop\");\n-  return result;\n-}\n-\n-\n@@ -901,3 +887,4 @@\n-  \/\/ Remove the ExtentLocal cache in case we got a StackOverflowError\n-  \/\/ while we were trying to remove ExtentLocal bindings.\n-  current->set_extentLocalCache(NULL);\n+  \/\/ Remove the ScopedValue bindings in case we got a\n+  \/\/ StackOverflowError while we were trying to remove ScopedValue\n+  \/\/ bindings.\n+  current->clear_scopedValueBindings();\n@@ -2382,4 +2369,0 @@\n-inline double percent(int x, int y) {\n-  return 100.0 * x \/ MAX2(y, 1);\n-}\n-\n@@ -2473,2 +2456,2 @@\n-  int64_t mono_c = _nof_normal_calls - _nof_optimized_calls - _nof_megamorphic_calls;\n-  int64_t mono_i = _nof_interface_calls - _nof_optimized_interface_calls - _nof_megamorphic_interface_calls;\n+  int64_t mono_c = _nof_normal_calls - _nof_megamorphic_calls;\n+  int64_t mono_i = _nof_interface_calls;\n@@ -2478,1 +2461,0 @@\n-  tty->print_cr(\"\\t\" INT64_FORMAT_W(12) \" (%4.0f%%) |  |- optimized        \", _nof_optimized_calls, percent(_nof_optimized_calls, _nof_normal_calls));\n@@ -2483,1 +2465,0 @@\n-  tty->print_cr(\"\\t\" INT64_FORMAT_W(12) \" (%4.0f%%) |  |- optimized        \", _nof_optimized_interface_calls, percent(_nof_optimized_interface_calls, _nof_interface_calls));\n@@ -2485,1 +2466,0 @@\n-  tty->print_cr(\"\\t\" INT64_FORMAT_W(12) \" (%4.0f%%) |  |- megamorphic      \", _nof_megamorphic_interface_calls, percent(_nof_megamorphic_interface_calls, _nof_interface_calls));\n@@ -2753,4 +2733,0 @@\n-extern \"C\" void unexpected_adapter_call() {\n-  ShouldNotCallThis();\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":6,"deletions":30,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -275,2 +275,0 @@\n-  static oop retrieve_receiver(Symbol* sig, frame caller);\n-\n@@ -559,1 +557,0 @@\n-  static int64_t _nof_optimized_calls;            \/\/ total # of statically-bound calls\n@@ -565,1 +562,0 @@\n-  static int64_t _nof_optimized_interface_calls;  \/\/ total # of statically-bound interface calls\n@@ -567,1 +563,0 @@\n-  static int64_t _nof_megamorphic_interface_calls;\/\/ total # of megamorphic interface calls\n@@ -571,1 +566,0 @@\n-  static address nof_optimized_calls_addr()             { return (address)&_nof_optimized_calls; }\n@@ -576,1 +570,0 @@\n-  static address nof_optimized_interface_calls_addr()   { return (address)&_nof_optimized_interface_calls; }\n@@ -578,1 +571,0 @@\n-  static address nof_megamorphic_interface_calls_addr() { return (address)&_nof_megamorphic_interface_calls; }\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -572,6 +572,0 @@\n-ResolvingSignatureStream::ResolvingSignatureStream(fieldDescriptor& field)\n-  : SignatureStream(field.signature(), false)\n-{\n-  initialize_load_origin(field.field_holder());\n-}\n-\n@@ -585,11 +579,0 @@\n-Klass* ResolvingSignatureStream::as_klass_if_loaded(TRAPS) {\n-  Klass* klass = as_klass(CachedOrNull, THREAD);\n-  \/\/ SD::find does not trigger loading, so there should be no throws\n-  \/\/ Still, bad things can happen, so we CHECK_NULL and ask callers\n-  \/\/ to do likewise.\n-  if (HAS_PENDING_EXCEPTION) {\n-    CLEAR_PENDING_EXCEPTION;\n-  }\n-  return klass;\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/signature.cpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -100,8 +100,0 @@\n-  \/\/ Assuming it is either a class name or signature,\n-  \/\/ determine if it in fact cannot be a class name.\n-  \/\/ This means it either starts with '[' or ends with ';'\n-  static bool not_class_name(const Symbol* signature) {\n-    return (signature->starts_with(JVM_SIGNATURE_ARRAY) ||\n-            signature->ends_with(JVM_SIGNATURE_ENDCLASS));\n-  }\n-\n@@ -233,4 +225,0 @@\n-  static bool fp_is_static(fingerprint_t fingerprint) {\n-    assert(fp_is_valid(fingerprint), \"invalid fingerprint\");\n-    return fingerprint & fp_is_static_bit;\n-  }\n@@ -512,1 +500,0 @@\n-  bool is_primitive() const { return is_java_primitive(_type); }\n@@ -605,5 +592,0 @@\n-  ResolvingSignatureStream(fieldDescriptor& field);\n-\n-  Klass* load_origin()       { return _load_origin; }\n-  Handle class_loader()      { need_handles(); return _class_loader; }\n-  Handle protection_domain() { need_handles(); return _protection_domain; }\n@@ -611,1 +593,0 @@\n-  Klass* as_klass_if_loaded(TRAPS);\n","filename":"src\/hotspot\/share\/runtime\/signature.hpp","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -66,4 +66,0 @@\n-  bool is_last() const { return next_sp() >= _end; }\n-\n-  intptr_t* end() { return _end; }\n-  void set_end(intptr_t* end) { _end = end; }\n@@ -72,2 +68,0 @@\n-  intptr_t* end() const { return _end; }\n-\n@@ -78,1 +72,0 @@\n-  NOT_PRODUCT(int index() { return _index; })\n@@ -97,2 +90,0 @@\n-  inline int to_offset(stackChunkOop chunk) const;\n-\n@@ -103,1 +94,0 @@\n-  bool is_deoptimized() const;\n@@ -113,1 +103,0 @@\n-  inline intptr_t* next_sp() const;\n@@ -118,1 +107,0 @@\n-  inline intptr_t* next_sp_for_interpreter_frame() const;\n","filename":"src\/hotspot\/share\/runtime\/stackChunkFrameStream.hpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -239,5 +239,0 @@\n-template <ChunkFrames frame_kind>\n-inline intptr_t* StackChunkFrameStream<frame_kind>::next_sp() const {\n-  return is_interpreted() ? next_sp_for_interpreter_frame() : unextended_sp() + cb()->frame_size();\n-}\n-\n@@ -337,14 +332,0 @@\n-template <ChunkFrames frame_kind>\n-inline int StackChunkFrameStream<frame_kind>::to_offset(stackChunkOop chunk) const {\n-  assert(!is_done(), \"\");\n-  return _sp - chunk->start_address();\n-}\n-\n-#ifdef ASSERT\n-template <ChunkFrames frame_kind>\n-bool StackChunkFrameStream<frame_kind>::is_deoptimized() const {\n-  address pc1 = pc();\n-  return is_compiled() && CodeCache::find_oopmap_slot_fast(pc1) < 0 && cb()->as_compiled_method()->is_deopt_pc(pc1);\n-}\n-#endif\n-\n","filename":"src\/hotspot\/share\/runtime\/stackChunkFrameStream.inline.hpp","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -217,14 +217,0 @@\n-void StackOverflow::enable_stack_red_zone() {\n-  \/\/ The base notation is from the stacks point of view, growing downward.\n-  \/\/ We need to adjust it to work correctly with guard_memory()\n-  assert(_stack_guard_state != stack_guard_unused, \"must be using guard pages.\");\n-  address base = stack_red_zone_base() - stack_red_zone_size();\n-\n-  guarantee(base < stack_base(), \"Error calculating stack red zone\");\n-  guarantee(base < os::current_stack_pointer(), \"Error calculating stack red zone\");\n-\n-  if (!os::guard_memory((char *) base, stack_red_zone_size())) {\n-    warning(\"Attempt to guard stack red zone failed.\");\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/stackOverflow.cpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -303,1 +303,0 @@\n-  void enable_stack_red_zone();\n","filename":"src\/hotspot\/share\/runtime\/stackOverflow.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-  StackValueCollection()            { _values = new GrowableArray<StackValue*>(); }\n","filename":"src\/hotspot\/share\/runtime\/stackValueCollection.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -133,1 +133,0 @@\n-  DEBUG_ONLY(StackWatermark* linked_watermark() const { return _linked_watermark; })\n","filename":"src\/hotspot\/share\/runtime\/stackWatermark.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,6 +49,0 @@\n-const char* StubCodeDesc::name_for(address pc) {\n-  StubCodeDesc* p = desc_for(pc);\n-  return p == NULL ? NULL : p->name();\n-}\n-\n-\n","filename":"src\/hotspot\/share\/runtime\/stubCodeGenerator.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -72,1 +72,0 @@\n-  static const char*   name_for(address pc);     \/\/ returns the name of the code containing pc or NULL\n","filename":"src\/hotspot\/share\/runtime\/stubCodeGenerator.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -70,2 +70,0 @@\n-address StubRoutines::_atomic_xchg_long_entry                   = NULL;\n-address StubRoutines::_atomic_store_entry                       = NULL;\n@@ -73,1 +71,0 @@\n-address StubRoutines::_atomic_cmpxchg_byte_entry                = NULL;\n@@ -76,1 +73,0 @@\n-address StubRoutines::_atomic_add_long_entry                    = NULL;\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -146,2 +146,0 @@\n-  static address _atomic_xchg_long_entry;\n-  static address _atomic_store_entry;\n@@ -149,1 +147,0 @@\n-  static address _atomic_cmpxchg_byte_entry;\n@@ -152,1 +149,0 @@\n-  static address _atomic_add_long_entry;\n@@ -317,2 +313,0 @@\n-  static address atomic_xchg_long_entry()                  { return _atomic_xchg_long_entry; }\n-  static address atomic_store_entry()                      { return _atomic_store_entry; }\n@@ -320,1 +314,0 @@\n-  static address atomic_cmpxchg_byte_entry()               { return _atomic_cmpxchg_byte_entry; }\n@@ -323,1 +316,0 @@\n-  static address atomic_add_long_entry()                   { return _atomic_add_long_entry; }\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-  bool is_done() { return _done; }\n","filename":"src\/hotspot\/share\/runtime\/suspendedThreadTask.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -697,10 +697,0 @@\n-\/\/ No exception are possible in this case as we only use this internally when locking is\n-\/\/ correct and we have to wait until notified - so no interrupts or timeouts.\n-void ObjectSynchronizer::wait_uninterruptibly(Handle obj, JavaThread* current) {\n-  \/\/ The ObjectMonitor* can't be async deflated because the _waiters\n-  \/\/ field is incremented before ownership is dropped and decremented\n-  \/\/ after ownership is regained.\n-  ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_wait);\n-  monitor->wait(0 \/* wait-forever *\/, false \/* not interruptible *\/, current);\n-}\n-\n@@ -1500,0 +1490,2 @@\n+  size_t unlinked_count = 0;\n+  size_t deleted_count = 0;\n@@ -1509,2 +1501,1 @@\n-    size_t unlinked_count = _in_use_list.unlink_deflated(current, ls, &timer,\n-                                                         &delete_list);\n+    unlinked_count = _in_use_list.unlink_deflated(current, ls, &timer, &delete_list);\n@@ -1536,1 +1527,0 @@\n-    size_t deleted_count = 0;\n@@ -1547,0 +1537,1 @@\n+    assert(unlinked_count == deleted_count, \"must be\");\n@@ -1551,3 +1542,3 @@\n-    if (deflated_count != 0 || log_is_enabled(Debug, monitorinflation)) {\n-      ls->print_cr(\"deflated \" SIZE_FORMAT \" monitors in %3.7f secs\",\n-                   deflated_count, timer.seconds());\n+    if (deflated_count != 0 || unlinked_count != 0 || log_is_enabled(Debug, monitorinflation)) {\n+      ls->print_cr(\"deflated_count=\" SIZE_FORMAT \", {unlinked,deleted}_count=\" SIZE_FORMAT \" monitors in %3.7f secs\",\n+                   deflated_count, unlinked_count, timer.seconds());\n@@ -1662,0 +1653,1 @@\n+  log_info(monitorinflation)(\"Starting the final audit.\");\n@@ -1664,1 +1656,1 @@\n-    \/\/ Do a deflation in order to reduce the in-use monitor population\n+    \/\/ Do deflations in order to reduce the in-use monitor population\n@@ -1667,1 +1659,1 @@\n-    while (ObjectSynchronizer::deflate_idle_monitors(\/* ObjectMonitorsHashtable is not needed here *\/ nullptr) >= (size_t)MonitorDeflationMax) {\n+    while (deflate_idle_monitors(\/* ObjectMonitorsHashtable is not needed here *\/ nullptr) > 0) {\n@@ -1672,1 +1664,1 @@\n-    ObjectSynchronizer::audit_and_print_stats(true \/* on_exit *\/);\n+    audit_and_print_stats(true \/* on_exit *\/);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":11,"deletions":19,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -82,5 +82,0 @@\n-  bool has_entry(void* key) {\n-    PtrList** listpp = _ptrs->get(key);\n-    return listpp != nullptr && *listpp != nullptr;\n-  }\n-\n@@ -162,5 +157,0 @@\n-  \/\/ Special internal-use-only method for use by JVM infrastructure\n-  \/\/ that needs to wait() on a java-level object but must not respond\n-  \/\/ to interrupt requests and doesn't timeout.\n-  static void wait_uninterruptibly(Handle obj, JavaThread* current);\n-\n@@ -269,1 +259,0 @@\n-  void wait_uninterruptibly(JavaThread* current) { ObjectSynchronizer::wait_uninterruptibly(_obj, current); }\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -371,8 +371,0 @@\n-ThreadPriority Thread::get_priority(const Thread* const thread) {\n-  ThreadPriority priority;\n-  \/\/ Can return an error!\n-  (void)os::get_priority(thread, priority);\n-  assert(MinPriority <= priority && priority <= MaxPriority, \"non-Java priority found\");\n-  return priority;\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -122,4 +122,0 @@\n-  int nmethod_disarm_value() {\n-    return (int)(uint32_t)_nmethod_disarm_value;\n-  }\n-\n@@ -327,1 +323,0 @@\n-  virtual bool is_monitor_deflation_thread() const   { return false; }\n@@ -366,1 +361,0 @@\n-  static ThreadPriority get_priority(const Thread* const thread);\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-  void set_bytes_until_sample(size_t bytes)      { _bytes_until_sample = bytes;  }\n","filename":"src\/hotspot\/share\/runtime\/threadHeapSampler.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -125,2 +125,0 @@\n-  static ThreadsList *acquire_stable_list_fast_path(Thread *self);\n-  static ThreadsList *acquire_stable_list_nested_path(Thread *self);\n@@ -142,1 +140,0 @@\n-  static void verify_hazard_ptr_scanned(Thread *self, ThreadsList *threads);\n@@ -277,11 +274,0 @@\n-  \/\/ Constructor that transfers ownership of the pointer.\n-  SafeThreadsListPtr(SafeThreadsListPtr& other) :\n-    _previous(other._previous),\n-    _thread(other._thread),\n-    _list(other._list),\n-    _has_ref_count(other._has_ref_count),\n-    _needs_release(other._needs_release)\n-  {\n-    other._needs_release = false;\n-  }\n-\n@@ -335,5 +321,0 @@\n-  template <class T>\n-  void threads_do(T *cl) const {\n-    return list()->threads_do(cl);\n-  }\n-\n@@ -381,4 +362,0 @@\n-  ThreadsList *list() const {\n-    return _list;\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.hpp","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-  void     setDefineClassCount(uint64_t defineClassCount) { _define_class_count = defineClassCount; }\n","filename":"src\/hotspot\/share\/runtime\/threadStatisticalInfo.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -249,6 +249,0 @@\n-void Threads::java_threads_and_vm_thread_do(ThreadClosure* tc) {\n-  assert_locked_or_safepoint(Threads_lock);\n-  java_threads_do(tc);\n-  tc->do_thread(VMThread::vm_thread());\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -69,1 +69,0 @@\n-  static void java_threads_and_vm_thread_do(ThreadClosure* tc);\n","filename":"src\/hotspot\/share\/runtime\/threads.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-  void clear() { _counter = 0; }\n","filename":"src\/hotspot\/share\/runtime\/timer.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -70,8 +70,0 @@\n-\n-  \/\/ Accessors\n-  void set_verbose(bool verbose)  { _verbose = verbose; }\n-  bool verbose() const            { return _verbose;    }\n-\n-  \/\/ Activation\n-  void suspend()  { if (_active) _t.stop();  }\n-  void resume()   { if (_active) _t.start(); }\n","filename":"src\/hotspot\/share\/runtime\/timerTrace.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -65,19 +65,0 @@\n-vframe::vframe(const frame* fr, JavaThread* thread)\n-: _reg_map(thread,\n-           RegisterMap::UpdateMap::include,\n-           RegisterMap::ProcessFrames::include,\n-           RegisterMap::WalkContinuation::skip),\n-  _thread(thread), _chunk() {\n-  assert(fr != NULL, \"must have frame\");\n-  _fr = *fr;\n-  assert(!_reg_map.in_cont(), \"\");\n-}\n-\n-vframe* vframe::new_vframe(StackFrameStream& fst, JavaThread* thread) {\n-  if (fst.current()->is_runtime_frame()) {\n-    fst.next();\n-  }\n-  guarantee(!fst.is_done(), \"missing caller\");\n-  return new_vframe(fst.current(), fst.register_map(), thread);\n-}\n-\n@@ -129,7 +110,0 @@\n-vframe* vframe::top() const {\n-  vframe* vf = (vframe*) this;\n-  while (!vf->is_top()) vf = vf->sender();\n-  return vf;\n-}\n-\n-\n@@ -298,5 +272,0 @@\n-void interpretedVFrame::set_bcp(u_char* bcp) {\n-  assert(stack_chunk() == NULL, \"Not supported for heap frames\"); \/\/ unsupported for now because seems to be unused\n-  fr().interpreter_frame_set_bcp(bcp);\n-}\n-\n@@ -309,1 +278,0 @@\n-\n@@ -523,16 +491,0 @@\n-\/\/ top-frame will be skipped\n-vframeStream::vframeStream(JavaThread* thread, frame top_frame,\n-                          bool stop_at_java_call_stub) :\n-    vframeStreamCommon(RegisterMap(thread,\n-                                   RegisterMap::UpdateMap::include,\n-                                   RegisterMap::ProcessFrames::include,\n-                                   RegisterMap::WalkContinuation::include)) {\n-  _stop_at_java_call_stub = stop_at_java_call_stub;\n-\n-  \/\/ skip top frame, as it may not be at safepoint\n-  _frame  = top_frame.sender(&_reg_map);\n-  while (!fill_from_frame()) {\n-    _frame = _frame.sender(&_reg_map);\n-  }\n-}\n-\n@@ -770,34 +722,0 @@\n-\n-bool javaVFrame::structural_compare(javaVFrame* other) {\n-  \/\/ Check static part\n-  if (method() != other->method()) return false;\n-  if (bci()    != other->bci())    return false;\n-\n-  \/\/ Check locals\n-  StackValueCollection *locs = locals();\n-  StackValueCollection *other_locs = other->locals();\n-  assert(locs->size() == other_locs->size(), \"sanity check\");\n-  int i;\n-  for(i = 0; i < locs->size(); i++) {\n-    \/\/ it might happen the compiler reports a conflict and\n-    \/\/ the interpreter reports a bogus int.\n-    if (       is_compiled_frame() &&       locs->at(i)->type() == T_CONFLICT) continue;\n-    if (other->is_compiled_frame() && other_locs->at(i)->type() == T_CONFLICT) continue;\n-\n-    if (!locs->at(i)->equal(other_locs->at(i)))\n-      return false;\n-  }\n-\n-  \/\/ Check expressions\n-  StackValueCollection* exprs = expressions();\n-  StackValueCollection* other_exprs = other->expressions();\n-  assert(exprs->size() == other_exprs->size(), \"sanity check\");\n-  for(i = 0; i < exprs->size(); i++) {\n-    if (!exprs->at(i)->equal(other_exprs->at(i)))\n-      return false;\n-  }\n-\n-  return true;\n-}\n-\n-\n@@ -816,9 +734,0 @@\n-\n-void javaVFrame::verify() const {\n-}\n-\n-\n-void interpretedVFrame::verify() const {\n-}\n-\n-\n@@ -831,1 +740,0 @@\n-\n","filename":"src\/hotspot\/share\/runtime\/vframe.cpp","additions":0,"deletions":92,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-  vframe(const frame* fr, JavaThread* thread);\n@@ -71,1 +70,0 @@\n-  static vframe* new_vframe(StackFrameStream& fst, JavaThread* thread);\n@@ -76,4 +74,0 @@\n-  CompiledMethod*   nm() const {\n-      assert( cb() != NULL && cb()->is_compiled(), \"usage\");\n-      return (CompiledMethod*) cb();\n-  }\n@@ -100,3 +94,0 @@\n-  \/\/ Returns top vframe within same frame (see is_top())\n-  virtual vframe* top() const;\n-\n@@ -138,1 +129,0 @@\n-  javaVFrame(const frame* fr, JavaThread* thread) : vframe(fr, thread) {}\n@@ -161,6 +151,0 @@\n-\n-  \/\/ verify operations\n-  virtual void verify() const;\n-\n-  \/\/ Structural compare\n-  bool structural_compare(javaVFrame* other);\n@@ -191,1 +175,0 @@\n-  void set_bcp(u_char* bcp);\n@@ -203,2 +186,0 @@\n-  \/\/ returns where the parameters starts relative to the frame pointer\n-  int start_of_parameters() const;\n@@ -206,5 +187,0 @@\n-#ifndef PRODUCT\n- public:\n-  \/\/ verify operations\n-  void verify() const;\n-#endif\n@@ -235,7 +211,0 @@\n- public:\n-  \/\/ casting\n-  static entryVFrame* cast(vframe* vf) {\n-    assert(vf == NULL || vf->is_entry_frame(), \"must be entry frame\");\n-    return (entryVFrame*) vf;\n-  }\n-\n@@ -333,1 +302,0 @@\n-  void dont_walk_cont() { _reg_map.set_walk_cont(false); }\n@@ -339,1 +307,0 @@\n-  inline bool is_entry_frame() const;\n@@ -359,3 +326,0 @@\n-  \/\/ top_frame may not be at safepoint, start with sender\n-  vframeStream(JavaThread* thread, frame top_frame, bool stop_at_java_call_stub = false);\n-\n","filename":"src\/hotspot\/share\/runtime\/vframe.hpp","additions":0,"deletions":36,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -73,2 +73,0 @@\n-inline bool vframeStreamCommon::is_entry_frame() const       { return _frame.is_entry_frame(); }\n-\n","filename":"src\/hotspot\/share\/runtime\/vframe.inline.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -550,4 +550,1 @@\n-      if (src == NULL) {\n-        set_location_valid(i, false);\n-      } else {\n-        set_location_valid(i, true);\n+      if (src != NULL) {\n","filename":"src\/hotspot\/share\/runtime\/vframeArray.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -144,1 +144,0 @@\n-  vframeArray*                 _next;\n@@ -155,1 +154,0 @@\n-  unsigned char                _valid[RegisterMap::reg_count];\n@@ -159,5 +157,0 @@\n-  void fill_in_element(int index, compiledVFrame* vf);\n-\n-  bool is_location_valid(int i) const        { return _valid[i] != 0; }\n-  void set_location_valid(int i, bool valid) { _valid[i] = valid; }\n-\n@@ -186,4 +179,0 @@\n-  \/\/ Accessors for next\n-  vframeArray* next() const                  { return _next; }\n-  void set_next(vframeArray* value)          { _next = value; }\n-\n@@ -195,2 +184,0 @@\n-  address original_pc() const                { return _original.pc(); }\n-\n@@ -199,2 +186,0 @@\n-  frame caller() const                       { return _caller; }\n-\n","filename":"src\/hotspot\/share\/runtime\/vframeArray.hpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -148,1 +148,1 @@\n-  GrowableArray<ScopeValue*>* extentLocals = scope()->locals();\n+  GrowableArray<ScopeValue*>* scopedValues = scope()->locals();\n@@ -153,1 +153,1 @@\n-      if (var->type() == T_OBJECT && extentLocals->at(i2)->is_object()) {\n+      if (var->type() == T_OBJECT && scopedValues->at(i2)->is_object()) {\n@@ -538,7 +538,0 @@\n-\n-\n-#ifndef PRODUCT\n-void compiledVFrame::verify() const {\n-  Unimplemented();\n-}\n-#endif \/\/ PRODUCT\n","filename":"src\/hotspot\/share\/runtime\/vframe_hp.cpp","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -101,5 +101,0 @@\n-\n-#ifndef PRODUCT\n- public:\n-  void verify() const;\n-#endif\n","filename":"src\/hotspot\/share\/runtime\/vframe_hp.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -120,1 +120,0 @@\n-  DeoptimizationMarker dm;\n@@ -290,1 +289,1 @@\n-    while (ObjectSynchronizer::deflate_idle_monitors(tablep) >= (size_t)MonitorDeflationMax) {\n+    while (ObjectSynchronizer::deflate_idle_monitors(tablep) > 0) {\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -713,1 +713,1 @@\n-  nonstatic_field(JavaThread,                  _extentLocalCache,                              OopHandle)                             \\\n+  nonstatic_field(JavaThread,                  _scopedValueCache,                              OopHandle)                             \\\n@@ -1074,1 +1074,0 @@\n-  nonstatic_field(vframeArray,                 _next,                                         vframeArray*)                          \\\n@@ -1569,1 +1568,1 @@\n-  declare_c2_type(BlackholeNode, MemBarNode)                              \\\n+  declare_c2_type(BlackholeNode, MultiNode)                               \\\n@@ -1573,1 +1572,0 @@\n-  declare_c2_type(Opaque2Node, Node)                                      \\\n@@ -1880,1 +1878,1 @@\n-  declare_c2_type(VectorTestNode, Node)                                   \\\n+  declare_c2_type(VectorTestNode, CmpNode)                                \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -326,1 +326,1 @@\n-  long interval_ms = SafepointTracing::time_since_last_safepoint_ms();\n+  jlong interval_ms = SafepointTracing::time_since_last_safepoint_ms();\n","filename":"src\/hotspot\/share\/runtime\/vmThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-\n+  NONCOPYABLE(MallocHeader);\n@@ -118,0 +118,6 @@\n+  \/\/ Contains all of the necessary data to to deaccount block with NMT.\n+  struct FreeInfo {\n+    const size_t size;\n+    const MEMFLAGS flags;\n+    const uint32_t mst_marker;\n+  };\n@@ -126,0 +132,4 @@\n+  \/\/ Return the necessary data to deaccount the block with NMT.\n+  FreeInfo free_info() {\n+    return FreeInfo{this->size(), this->flags(), this->mst_marker()};\n+  }\n@@ -127,0 +137,1 @@\n+  inline void revive();\n","filename":"src\/hotspot\/share\/services\/mallocHeader.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -48,0 +48,10 @@\n+inline void MallocHeader::revive() {\n+  assert(_canary == _header_canary_dead_mark, \"must be dead\");\n+  assert(get_footer() == _footer_canary_dead_mark, \"must be dead\");\n+  NOT_LP64(assert(_alt_canary == _header_alt_canary_dead_mark, \"must be dead\"));\n+  _canary = _header_canary_life_mark;\n+  NOT_LP64(_alt_canary = _header_alt_canary_life_mark);\n+  set_footer(_footer_canary_life_mark);\n+}\n+\n+\/\/ The effects of this method must be reversible with MallocHeader::revive()\n@@ -58,3 +68,1 @@\n-    if (corruption != NULL) {\n-      print_block_on_error(tty, (address)this);\n-    }\n+    print_block_on_error(tty, corruption != NULL ? corruption : (address)this);\n","filename":"src\/hotspot\/share\/services\/mallocHeader.inline.hpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -49,0 +49,2 @@\n+  \/\/ Peak memory ever allocated from this code path\n+  size_t peak_size()  const { return _c.peak_size(); }\n@@ -51,0 +53,2 @@\n+\n+  const MemoryCounter* counter() const { return &_c; }\n","filename":"src\/hotspot\/share\/services\/mallocSiteTable.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -45,11 +46,1 @@\n-void MemoryCounter::update_peak_count(size_t count) {\n-  size_t peak_cnt = peak_count();\n-  while (peak_cnt < count) {\n-    size_t old_cnt = Atomic::cmpxchg(&_peak_count, peak_cnt, count, memory_order_relaxed);\n-    if (old_cnt != peak_cnt) {\n-      peak_cnt = old_cnt;\n-    }\n-  }\n-}\n-\n-void MemoryCounter::update_peak_size(size_t sz) {\n+void MemoryCounter::update_peak(size_t size, size_t cnt) {\n@@ -57,3 +48,7 @@\n-  while (peak_sz < sz) {\n-    size_t old_sz = Atomic::cmpxchg(&_peak_size, peak_sz, sz, memory_order_relaxed);\n-    if (old_sz != peak_sz) {\n+  while (peak_sz < size) {\n+    size_t old_sz = Atomic::cmpxchg(&_peak_size, peak_sz, size, memory_order_relaxed);\n+    if (old_sz == peak_sz) {\n+      \/\/ I won\n+      _peak_count = cnt;\n+      break;\n+    } else {\n@@ -64,9 +59,1 @@\n-\n-size_t MemoryCounter::peak_count() const {\n-  return Atomic::load(&_peak_count);\n-}\n-\n-size_t MemoryCounter::peak_size() const {\n-  return Atomic::load(&_peak_size);\n-}\n-#endif\n+#endif \/\/ ASSERT\n@@ -196,1 +183,1 @@\n-void* MallocTracker::record_free(void* memblock) {\n+void* MallocTracker::record_free_block(void* memblock) {\n@@ -203,4 +190,1 @@\n-  MallocMemorySummary::record_free(header->size(), header->flags());\n-  if (MemTracker::tracking_level() == NMT_detail) {\n-    MallocSiteTable::deallocation_at(header->size(), header->mst_marker());\n-  }\n+  deaccount(header->free_info());\n@@ -213,0 +197,7 @@\n+void MallocTracker::deaccount(MallocHeader::FreeInfo free_info) {\n+  MallocMemorySummary::record_free(free_info.size, free_info.flags);\n+  if (MemTracker::tracking_level() == NMT_detail) {\n+    MallocSiteTable::deallocation_at(free_info.size, free_info.mst_marker);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/services\/mallocTracker.cpp","additions":19,"deletions":28,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -48,2 +48,7 @@\n-  DEBUG_ONLY(volatile size_t   _peak_count;)\n-  DEBUG_ONLY(volatile size_t   _peak_size; )\n+#ifdef ASSERT\n+  \/\/ Peak size and count. Note: Peak count is the count at the point\n+  \/\/ peak size was reached, not the absolute highest peak count.\n+  volatile size_t _peak_count;\n+  volatile size_t _peak_size;\n+  void update_peak(size_t size, size_t cnt);\n+#endif \/\/ ASSERT\n@@ -61,1 +66,1 @@\n-      DEBUG_ONLY(update_peak_size(sum);)\n+      DEBUG_ONLY(update_peak(sum, cnt);)\n@@ -63,1 +68,0 @@\n-    DEBUG_ONLY(update_peak_count(cnt);)\n@@ -79,1 +83,1 @@\n-      DEBUG_ONLY(update_peak_size(sum);)\n+      DEBUG_ONLY(update_peak(sum, _count);)\n@@ -86,6 +90,7 @@\n-#ifdef ASSERT\n-  void update_peak_count(size_t cnt);\n-  void update_peak_size(size_t sz);\n-  size_t peak_count() const;\n-  size_t peak_size()  const;\n-#endif \/\/ ASSERT\n+  inline size_t peak_count() const {\n+    return DEBUG_ONLY(Atomic::load(&_peak_count)) NOT_DEBUG(0);\n+  }\n+\n+  inline size_t peak_size() const {\n+    return DEBUG_ONLY(Atomic::load(&_peak_size)) NOT_DEBUG(0);\n+  }\n@@ -128,0 +133,1 @@\n+  inline size_t malloc_peak_size()  const { return _malloc.peak_size(); }\n@@ -130,0 +136,1 @@\n+  inline size_t arena_peak_size()  const { return _arena.peak_size(); }\n@@ -132,2 +139,2 @@\n-  DEBUG_ONLY(inline const MemoryCounter& malloc_counter() const { return _malloc; })\n-  DEBUG_ONLY(inline const MemoryCounter& arena_counter()  const { return _arena;  })\n+  const MemoryCounter* malloc_counter() const { return &_malloc; }\n+  const MemoryCounter* arena_counter()  const { return &_arena;  }\n@@ -149,1 +156,6 @@\n-  inline MallocMemory*  by_type(MEMFLAGS flags) {\n+  inline MallocMemory* by_type(MEMFLAGS flags) {\n+    int index = NMTUtil::flag_to_index(flags);\n+    return &_malloc[index];\n+  }\n+\n+  inline const MallocMemory* by_type(MEMFLAGS flags) const {\n@@ -294,2 +306,5 @@\n-  \/\/ Record free on specified memory block\n-  static void* record_free(void* memblock);\n+  \/\/ Given a block returned by os::malloc() or os::realloc():\n+  \/\/ deaccount block from NMT, mark its header as dead and return pointer to header.\n+  static void* record_free_block(void* memblock);\n+  \/\/ Given the free info from a block, de-account block from NMT.\n+  static void deaccount(MallocHeader::FreeInfo free_info);\n","filename":"src\/hotspot\/share\/services\/mallocTracker.hpp","additions":31,"deletions":16,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"jfr\/jfrEvents.hpp\"\n+#include \"services\/memJfrReporter.hpp\"\n+#include \"services\/memTracker.hpp\"\n+#include \"services\/nmtUsage.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ticks.hpp\"\n+\n+\/\/ Helper class to avoid refreshing the NMTUsage to often and allow\n+\/\/ the two JFR events to use the same data.\n+class MemJFRCurrentUsage : public AllStatic {\n+private:\n+  \/\/ The age threshold in milliseconds. If older than this refresh the usage.\n+  static const uint64_t AgeThreshold = 50;\n+\n+  static Ticks _timestamp;\n+  static NMTUsage* _usage;\n+\n+public:\n+  static NMTUsage* get_usage();\n+  static Ticks get_timestamp();\n+};\n+\n+Ticks MemJFRCurrentUsage::_timestamp;\n+NMTUsage* MemJFRCurrentUsage::_usage = nullptr;\n+\n+NMTUsage* MemJFRCurrentUsage::get_usage() {\n+  Tickspan since_baselined = Ticks::now() - _timestamp;\n+\n+  if (_usage == nullptr) {\n+    \/\/ First time, create a new NMTUsage.\n+    _usage = new NMTUsage(NMTUsage::OptionsNoTS);\n+  } else if (since_baselined.milliseconds() < AgeThreshold) {\n+    \/\/ There is recent enough usage information, return it.\n+    return _usage;\n+  }\n+\n+  \/\/ Refresh the usage information.\n+  _usage->refresh();\n+  _timestamp.stamp();\n+\n+  return _usage;\n+}\n+\n+Ticks MemJFRCurrentUsage::get_timestamp() {\n+  return _timestamp;\n+}\n+\n+void MemJFRReporter::send_total_event() {\n+  if (!MemTracker::enabled()) {\n+    return;\n+  }\n+\n+  NMTUsage* usage = MemJFRCurrentUsage::get_usage();\n+  Ticks timestamp = MemJFRCurrentUsage::get_timestamp();\n+\n+  EventNativeMemoryUsageTotal event(UNTIMED);\n+  event.set_starttime(timestamp);\n+  event.set_reserved(usage->total_reserved());\n+  event.set_committed(usage->total_committed());\n+  event.commit();\n+}\n+\n+void MemJFRReporter::send_type_event(const Ticks& starttime, const char* type, size_t reserved, size_t committed) {\n+  EventNativeMemoryUsage event(UNTIMED);\n+  event.set_starttime(starttime);\n+  event.set_type(type);\n+  event.set_reserved(reserved);\n+  event.set_committed(committed);\n+  event.commit();\n+}\n+\n+void MemJFRReporter::send_type_events() {\n+  if (!MemTracker::enabled()) {\n+    return;\n+  }\n+\n+  NMTUsage* usage = MemJFRCurrentUsage::get_usage();\n+  Ticks timestamp = MemJFRCurrentUsage::get_timestamp();\n+\n+  for (int index = 0; index < mt_number_of_types; index ++) {\n+    MEMFLAGS flag = NMTUtil::index_to_flag(index);\n+    if (flag == mtNone) {\n+      \/\/ Skip mtNone since it is not really used.\n+      continue;\n+    }\n+    send_type_event(timestamp, NMTUtil::flag_to_name(flag), usage->reserved(flag), usage->committed(flag));\n+  }\n+}\n","filename":"src\/hotspot\/share\/services\/memJfrReporter.cpp","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_SERVICES_MEMJFRREPORTER_HPP\n+#define SHARE_SERVICES_MEMJFRREPORTER_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"services\/nmtUsage.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ticks.hpp\"\n+\n+\/\/ MemJFRReporter is only used by threads sending periodic JFR\n+\/\/ events. These threads are synchronized at a higher level,\n+\/\/ so no more synchronization is needed.\n+class MemJFRReporter : public AllStatic {\n+private:\n+  static void send_type_event(const Ticks& starttime, const char* tag, size_t reserved, size_t committed);\n+ public:\n+  static void send_total_event();\n+  static void send_type_events();\n+};\n+\n+#endif \/\/SHARE_SERVICES_MEMJFRREPORTER_HPP\n","filename":"src\/hotspot\/share\/services\/memJfrReporter.hpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -34,1 +34,1 @@\n-size_t MemReporterBase::reserved_total(const MallocMemory* malloc, const VirtualMemory* vm) const {\n+size_t MemReporterBase::reserved_total(const MallocMemory* malloc, const VirtualMemory* vm) {\n@@ -38,1 +38,1 @@\n-size_t MemReporterBase::committed_total(const MallocMemory* malloc, const VirtualMemory* vm) const {\n+size_t MemReporterBase::committed_total(const MallocMemory* malloc, const VirtualMemory* vm) {\n@@ -48,1 +48,1 @@\n-void MemReporterBase::print_malloc(size_t amount, size_t count, MEMFLAGS flag) const {\n+void MemReporterBase::print_malloc(const MemoryCounter* c, MEMFLAGS flag) const {\n@@ -53,0 +53,3 @@\n+  const size_t amount = c->size();\n+  const size_t count = c->count();\n+\n@@ -61,0 +64,1 @@\n+  \/\/ blends out mtChunk count number\n@@ -66,0 +70,9 @@\n+\n+  size_t pk_amount = c->peak_size();\n+  if (pk_amount == amount) {\n+    out->print_raw(\" (at peak)\");\n+  } else if (pk_amount > amount) {\n+    size_t pk_count = c->peak_count();\n+    out->print(\" (peak=\" SIZE_FORMAT \"%s #\" SIZE_FORMAT \")\",\n+        amount_in_current_scale(pk_amount), scale, pk_count);\n+  }\n@@ -74,1 +87,1 @@\n-void MemReporterBase::print_malloc_line(size_t amount, size_t count) const {\n+void MemReporterBase::print_malloc_line(const MemoryCounter* c) const {\n@@ -76,1 +89,1 @@\n-  print_malloc(amount, count);\n+  print_malloc(c);\n@@ -86,1 +99,1 @@\n-void MemReporterBase::print_arena_line(size_t amount, size_t count) const {\n+void MemReporterBase::print_arena_line(const MemoryCounter* c) const {\n@@ -88,1 +101,6 @@\n-  output()->print_cr(\"%27s (arena=\" SIZE_FORMAT \"%s #\" SIZE_FORMAT \")\", \" \",\n+  outputStream* out = output();\n+\n+  const size_t amount = c->size();\n+  const size_t count = c->count();\n+\n+  out->print(\"%27s (arena=\" SIZE_FORMAT \"%s #\" SIZE_FORMAT \")\", \"\",\n@@ -90,0 +108,11 @@\n+\n+  size_t pk_amount = c->peak_size();\n+  if (pk_amount == amount) {\n+    out->print_raw(\" (at peak)\");\n+  } else if (pk_amount > amount) {\n+    size_t pk_count = c->peak_count();\n+    out->print(\" (peak=\" SIZE_FORMAT \"%s #\" SIZE_FORMAT \")\",\n+        amount_in_current_scale(pk_amount), scale, pk_count);\n+  }\n+\n+  out->cr();\n@@ -198,4 +227,3 @@\n-    if (amount_in_current_scale(malloc_memory->malloc_size()) > 0) {\n-      \/\/ We don't know how many arena chunks are in used, so don't report the count\n-      size_t count = (flag == mtChunk) ? 0 : malloc_memory->malloc_count();\n-      print_malloc_line(malloc_memory->malloc_size(), count);\n+    if (amount_in_current_scale(malloc_memory->malloc_size()) > 0\n+        DEBUG_ONLY(|| amount_in_current_scale(malloc_memory->malloc_peak_size()) > 0)) {\n+      print_malloc_line(malloc_memory->malloc_counter());\n@@ -208,2 +236,3 @@\n-    if (amount_in_current_scale(malloc_memory->arena_size()) > 0) {\n-      print_arena_line(malloc_memory->arena_size(), malloc_memory->arena_count());\n+    if (amount_in_current_scale(malloc_memory->arena_size()) > 0\n+        DEBUG_ONLY(|| amount_in_current_scale(malloc_memory->arena_peak_size()) > 0)) {\n+      print_arena_line(malloc_memory->arena_counter());\n@@ -274,6 +303,3 @@\n-    \/\/ Don't report free sites; does not count toward omitted count.\n-    if (malloc_site->size() == 0) {\n-      continue;\n-    }\n-    \/\/ Don't report if site has allocated less than one unit of whatever our scale is\n-    if (scale() > 1 && amount_in_current_scale(malloc_site->size()) == 0) {\n+    \/\/ Don't report if site has never allocated less than one unit of whatever our scale is\n+    if (scale() > 1 && amount_in_current_scale(malloc_site->size()) == 0\n+                       DEBUG_ONLY(&& amount_in_current_scale(malloc_site->peak_size()) == 0)) {\n@@ -289,1 +315,1 @@\n-    print_malloc(malloc_site->size(), malloc_site->count(),flag);\n+    print_malloc(malloc_site->counter(), flag);\n","filename":"src\/hotspot\/share\/services\/memReporter.cpp","additions":46,"deletions":20,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -52,0 +52,5 @@\n+  \/\/ Helper functions\n+  \/\/ Calculate total reserved and committed amount\n+  static size_t reserved_total(const MallocMemory* malloc, const VirtualMemory* vm);\n+  static size_t committed_total(const MallocMemory* malloc, const VirtualMemory* vm);\n+\n@@ -76,5 +81,0 @@\n-  \/\/ Helper functions\n-  \/\/ Calculate total reserved and committed amount\n-  size_t reserved_total(const MallocMemory* malloc, const VirtualMemory* vm) const;\n-  size_t committed_total(const MallocMemory* malloc, const VirtualMemory* vm) const;\n-\n@@ -83,1 +83,1 @@\n-  void print_malloc(size_t amount, size_t count, MEMFLAGS flag = mtNone) const;\n+  void print_malloc(const MemoryCounter* c, MEMFLAGS flag = mtNone) const;\n@@ -86,1 +86,1 @@\n-  void print_malloc_line(size_t amount, size_t count) const;\n+  void print_malloc_line(const MemoryCounter* c) const;\n@@ -88,1 +88,1 @@\n-  void print_arena_line(size_t amount, size_t count) const;\n+  void print_arena_line(const MemoryCounter* c) const;\n","filename":"src\/hotspot\/share\/services\/memReporter.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -112,1 +112,5 @@\n-    return MallocTracker::record_free(memblock);\n+    return MallocTracker::record_free_block(memblock);\n+  }\n+  static inline void deaccount(MallocHeader::FreeInfo free_info) {\n+    assert(enabled(), \"NMT must be enabled\");\n+    MallocTracker::deaccount(free_info);\n","filename":"src\/hotspot\/share\/services\/memTracker.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/threadCritical.hpp\"\n+#include \"services\/nmtCommon.hpp\"\n+#include \"services\/nmtUsage.hpp\"\n+#include \"services\/mallocTracker.hpp\"\n+#include \"services\/threadStackTracker.hpp\"\n+#include \"services\/virtualMemoryTracker.hpp\"\n+\n+\/\/ Enabled all options for snapshot.\n+const NMTUsageOptions NMTUsage::OptionsAll = { true, true, true };\n+\/\/ Skip expensive thread stacks when refreshing usage.\n+const NMTUsageOptions NMTUsage::OptionsNoTS = { false, true, true };\n+\n+NMTUsage::NMTUsage(NMTUsageOptions options) :\n+    _malloc_by_type(),\n+    _malloc_total(),\n+    _vm_by_type(),\n+    _vm_total(),\n+    _usage_options(options) { }\n+\n+void NMTUsage::walk_thread_stacks() {\n+  \/\/ If backed by virtual memory, snapping the thread stacks involves walking\n+  \/\/ them to to figure out how much memory is committed if they are backed by\n+  \/\/ virtual memory. This needs ot happen before we take the snapshot of the\n+  \/\/ virtual memory since it will update this information.\n+  if (ThreadStackTracker::track_as_vm()) {\n+    VirtualMemoryTracker::snapshot_thread_stacks();\n+  }\n+}\n+\n+void NMTUsage::update_malloc_usage() {\n+  \/\/ Thread critical needed keep values in sync, total area size\n+  \/\/ is deducted from mtChunk in the end to give correct values.\n+  ThreadCritical tc;\n+  const MallocMemorySnapshot* ms = MallocMemorySummary::as_snapshot();\n+\n+  size_t total_arena_size = 0;\n+  for (int i = 0; i < mt_number_of_types; i++) {\n+    MEMFLAGS flag = NMTUtil::index_to_flag(i);\n+    const MallocMemory* mm = ms->by_type(flag);\n+    _malloc_by_type[i] = mm->malloc_size() + mm->arena_size();\n+    total_arena_size +=  mm->arena_size();\n+  }\n+\n+  \/\/ Total malloc size.\n+  _malloc_total = ms->total();\n+\n+  \/\/ Adjustment due to mtChunk double counting.\n+  _malloc_by_type[NMTUtil::flag_to_index(mtChunk)] -= total_arena_size;\n+  _malloc_total -= total_arena_size;\n+\n+  \/\/ Adjust mtNMT to include malloc overhead.\n+  _malloc_by_type[NMTUtil::flag_to_index(mtNMT)] += ms->malloc_overhead();\n+}\n+\n+void NMTUsage::update_vm_usage() {\n+  const VirtualMemorySnapshot* vms = VirtualMemorySummary::as_snapshot();\n+\n+  \/\/ Reset total to allow recalculation.\n+  _vm_total.committed = 0;\n+  _vm_total.reserved = 0;\n+  for (int i = 0; i < mt_number_of_types; i++) {\n+    MEMFLAGS flag = NMTUtil::index_to_flag(i);\n+    const VirtualMemory* vm = vms->by_type(flag);\n+\n+    _vm_by_type[i].reserved = vm->reserved();\n+    _vm_by_type[i].committed = vm->committed();\n+    _vm_total.reserved += vm->reserved();\n+    _vm_total.committed += vm->committed();\n+  }\n+}\n+\n+void NMTUsage::refresh() {\n+  if (_usage_options.include_malloc) {\n+    update_malloc_usage();\n+  }\n+\n+  if (_usage_options.include_vm) {\n+    \/\/ Thread stacks only makes sense if virtual memory\n+    \/\/ is also included. It must be executed before the\n+    \/\/ over all usage is calculated.\n+    if (_usage_options.update_thread_stacks) {\n+      walk_thread_stacks();\n+    }\n+    update_vm_usage();\n+  }\n+}\n+\n+size_t NMTUsage::total_reserved() const {\n+  return _malloc_total + _vm_total.reserved;\n+}\n+\n+size_t NMTUsage::total_committed() const {\n+  return _malloc_total + _vm_total.reserved;\n+}\n+\n+size_t NMTUsage::reserved(MEMFLAGS flag) const {\n+  int index = NMTUtil::flag_to_index(flag);\n+  return _malloc_by_type[index] + _vm_by_type[index].reserved;\n+}\n+\n+size_t NMTUsage::committed(MEMFLAGS flag) const {\n+  int index = NMTUtil::flag_to_index(flag);\n+  return _malloc_by_type[index] + _vm_by_type[index].committed;\n+}\n","filename":"src\/hotspot\/share\/services\/nmtUsage.cpp","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_SERVICES_NMTUSAGE_HPP\n+#define SHARE_SERVICES_NMTUSAGE_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+struct NMTUsagePair {\n+  size_t reserved;\n+  size_t committed;\n+};\n+\n+struct NMTUsageOptions {\n+  bool update_thread_stacks;\n+  bool include_malloc;\n+  bool include_vm;\n+};\n+\n+class NMTUsage : public CHeapObj<mtNMT> {\n+private:\n+  size_t _malloc_by_type[mt_number_of_types];\n+  size_t _malloc_total;\n+  NMTUsagePair _vm_by_type[mt_number_of_types];\n+  NMTUsagePair _vm_total;\n+\n+  NMTUsageOptions _usage_options;\n+\n+  void walk_thread_stacks();\n+  void update_malloc_usage();\n+  void update_vm_usage();\n+\n+public:\n+  static const NMTUsageOptions OptionsAll;\n+  static const NMTUsageOptions OptionsNoTS;\n+\n+  NMTUsage(NMTUsageOptions options = OptionsAll);\n+  void refresh();\n+\n+  size_t total_reserved() const;\n+  size_t total_committed() const;\n+  size_t reserved(MEMFLAGS flag) const;\n+  size_t committed(MEMFLAGS flag) const;\n+};\n+\n+#endif \/\/ SHARE_SERVICES_NMTUSAGE_HPP\n","filename":"src\/hotspot\/share\/services\/nmtUsage.hpp","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -100,0 +100,5 @@\n+  inline const VirtualMemory* by_type(MEMFLAGS flag) const {\n+    int index = NMTUtil::flag_to_index(flag);\n+    return &_virtual_memory[index];\n+  }\n+\n","filename":"src\/hotspot\/share\/services\/virtualMemoryTracker.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -748,1 +748,1 @@\n-  VMError::print_native_stack(tty, fr, t, false, buf, sizeof(buf));\n+  VMError::print_native_stack(tty, fr, t, false, -1, buf, sizeof(buf));\n@@ -768,1 +768,1 @@\n-    VMError::print_native_stack(tty, fr, t, false, buf, sizeof(buf));\n+    VMError::print_native_stack(tty, fr, t, false, -1, buf, sizeof(buf));\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -163,2 +163,8 @@\n-  if (h_exception->is_a(vmClasses::OutOfMemoryError_klass())) {\n-    count_out_of_memory_exceptions(h_exception);\n+  if (h_exception->is_a(vmClasses::VirtualMachineError_klass())) {\n+    \/\/ Remove the ScopedValue bindings in case we got a virtual machine\n+    \/\/ Error while we were trying to manipulate ScopedValue bindings.\n+    thread->clear_scopedValueBindings();\n+\n+    if (h_exception->is_a(vmClasses::OutOfMemoryError_klass())) {\n+      count_out_of_memory_exceptions(h_exception);\n+    }\n","filename":"src\/hotspot\/share\/utilities\/exceptions.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -234,0 +234,1 @@\n+  friend class JfrPeriodicEventSet;\n","filename":"src\/hotspot\/share\/utilities\/ticks.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -350,1 +350,1 @@\n-void VMError::print_native_stack(outputStream* st, frame fr, Thread* t, bool print_source_info, char* buf, int buf_size) {\n+void VMError::print_native_stack(outputStream* st, frame fr, Thread* t, bool print_source_info, int max_frames, char* buf, int buf_size) {\n@@ -355,1 +355,1 @@\n-\n+    const int limit = max_frames == -1 ? StackPrintLimit : MIN2(max_frames, (int)StackPrintLimit);\n@@ -357,1 +357,1 @@\n-    while (count++ < StackPrintLimit) {\n+    while (count++ < limit) {\n@@ -377,1 +377,1 @@\n-    if (count > StackPrintLimit) {\n+    if (count > limit) {\n@@ -381,1 +381,0 @@\n-    st->cr();\n@@ -821,1 +820,1 @@\n-      print_native_stack(st, fr, _thread, true, buf, sizeof(buf));\n+      print_native_stack(st, fr, _thread, true, -1, buf, sizeof(buf));\n@@ -830,1 +829,1 @@\n-    print_native_stack(st, fr, _thread, false, buf, sizeof(buf));\n+    print_native_stack(st, fr, _thread, false, -1, buf, sizeof(buf));\n@@ -1504,2 +1503,5 @@\n-        \/\/ Crash or assert during error reporting. Lets continue reporting with the next step.\n-        stringStream ss(buffer, sizeof(buffer));\n+        \/\/ A secondary error happened. Print brief information, but take care, since crashing\n+        \/\/ here would just recurse endlessly.\n+        \/\/ Any information (signal, context, siginfo etc) printed here should use the function\n+        \/\/ arguments, not the information stored in *this, since those describe the primary crash.\n+        static char tmp[256]; \/\/ cannot use global scratch buffer\n@@ -1508,1 +1510,1 @@\n-        ss.print(\"[error occurred during error reporting (%s), id 0x%x\",\n+        st->print(\"[error occurred during error reporting (%s), id 0x%x\",\n@@ -1510,3 +1512,2 @@\n-        char signal_name[64];\n-        if (os::exception_name(id, signal_name, sizeof(signal_name))) {\n-          ss.print(\", %s (0x%x) at pc=\" PTR_FORMAT, signal_name, id, p2i(pc));\n+        if (os::exception_name(id, tmp, sizeof(tmp))) {\n+          st->print(\", %s (0x%x) at pc=\" PTR_FORMAT, tmp, id, p2i(pc));\n@@ -1515,1 +1516,1 @@\n-            ss.print(\", Internal Error (%s:%d)\",\n+            st->print(\", Internal Error (%s:%d)\",\n@@ -1518,1 +1519,1 @@\n-            ss.print(\", Out of Memory Error (%s:%d)\",\n+            st->print(\", Out of Memory Error (%s:%d)\",\n@@ -1522,3 +1523,23 @@\n-        ss.print(\"]\");\n-        st->print_raw_cr(buffer);\n-        st->cr();\n+        st->print_cr(\"]\");\n+        if (ErrorLogSecondaryErrorDetails) {\n+          static bool recursed = false;\n+          if (!recursed) {\n+            recursed = true;\n+            \/\/ Print even more information for secondary errors. This may generate a lot of output\n+            \/\/ and possibly disturb error reporting, therefore its optional and only available in debug builds.\n+            if (siginfo != nullptr) {\n+              st->print(\"[\");\n+              os::print_siginfo(st, siginfo);\n+              st->print_cr(\"]\");\n+            }\n+            st->print(\"[stack: \");\n+            frame fr = context ? os::fetch_frame_from_context(context) : os::current_frame();\n+            \/\/ Subsequent secondary errors build up stack; to avoid flooding the hs-err file with irrelevant\n+            \/\/ call stacks, limit the stack we print here (we are only interested in what happened before the\n+            \/\/ last assert\/fault).\n+            const int max_stack_size = 15;\n+            print_native_stack(st, fr, _thread, true, max_stack_size, tmp, sizeof(tmp));\n+            st->print_cr(\"]\");\n+          } \/\/ !recursed\n+          recursed = false; \/\/ Note: reset outside !recursed\n+        }\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":39,"deletions":18,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -108,0 +108,3 @@\n+  \/\/ print_source_info: if true, we try to resolve the source information on platforms that support it\n+  \/\/  (useful but may slow down, timeout or misfunction in error situations)\n+  \/\/ max_frames: if not -1, overrides StackPrintLimit\n@@ -109,1 +112,1 @@\n-                                 char* buf, int buf_size);\n+                                 int max_frames, char* buf, int buf_size);\n","filename":"src\/hotspot\/share\/utilities\/vmError.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -95,0 +97,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -575,3 +579,9 @@\n-    \/\/ Wrapper function around AES-GCM interleaved intrinsic that splits\n-    \/\/ large chunks of data into 1MB sized chunks. This is to place\n-    \/\/ an upper limit on the number of blocks encrypted in the intrinsic.\n+    \/**\n+     * Wrapper function around Combined AES-GCM intrinsic method that splits\n+     * large chunks of data into 1MB sized chunks. This is to place\n+     * an upper limit on the number of blocks encrypted in the intrinsic.\n+     *\n+     * The combined intrinsic is not used when decrypting in-place heap\n+     * bytebuffers because 'ct' will be the same as 'in' and overwritten by\n+     * GCTR before GHASH calculates the encrypted tag.\n+     *\/\n@@ -583,1 +593,3 @@\n-        if (inLen > SPLIT_LEN) {\n+        \/\/ Loop if input length is greater than the SPLIT_LEN\n+        if (inLen > SPLIT_LEN && ct != null) {\n+            int partlen;\n@@ -585,1 +597,1 @@\n-                int partlen = implGCMCrypt0(in, inOfs + len, SPLIT_LEN, ct,\n+                partlen = implGCMCrypt0(in, inOfs + len, SPLIT_LEN, ct,\n@@ -591,0 +603,2 @@\n+\n+        \/\/ Finish any remaining data\n@@ -592,2 +606,7 @@\n-            len += implGCMCrypt0(in, inOfs + len, inLen, ct,\n-                   ctOfs + len, out, outOfs + len, gctr, ghash);\n+            if (ct == null) {\n+                ghash.update(in, inOfs + len, inLen);\n+                len += gctr.update(in, inOfs + len, inLen, out, outOfs);\n+            } else {\n+                len += implGCMCrypt0(in, inOfs + len, inLen, ct,\n+                    ctOfs + len, out, outOfs + len, gctr, ghash);\n+            }\n@@ -597,0 +616,1 @@\n+\n@@ -598,3 +618,2 @@\n-     * Intrinsic for Vector AES Galois Counter Mode implementation.\n-     * AES and GHASH operations are interleaved in the intrinsic implementation.\n-     * return - number of processed bytes\n+     * Intrinsic for the combined AES Galois Counter Mode implementation.\n+     * AES and GHASH operations are combined in the intrinsic implementation.\n@@ -605,0 +624,7 @@\n+     *\n+     * Note:\n+     * Only Intel processors with AVX512 that support vaes, vpclmulqdq,\n+     * avx512dq, and avx512vl trigger this intrinsic.\n+     * Other processors will always use GHASH and GCTR which may have their own\n+     * intrinsic support\n+     *\n@@ -613,1 +639,1 @@\n-     * @param ghash object for the ghash operation\n+     * @param ghash object for the GHASH operation\n@@ -669,0 +695,5 @@\n+        \/\/ True if ops is an in-place array decryption with the offset between\n+        \/\/ input & output the same or the input greater.  This is to\n+        \/\/ avoid the AVX512 intrinsic.\n+        boolean inPlaceArray = false;\n+\n@@ -735,1 +766,2 @@\n-                    ct.array(), ct.arrayOffset() + ct.position(),\n+                    inPlaceArray ? null : ct.array(),\n+                    ct.arrayOffset() + ct.position(),\n@@ -912,0 +944,2 @@\n+                \/\/ The use of DirectBuffer::address below need not be guarded as\n+                \/\/ no access is made to actual memory.\n@@ -945,0 +979,2 @@\n+                \/\/ NOTE: inPlaceArray does not apply here as direct buffers run\n+                \/\/ through a byte[] to get to the combined intrinsic\n@@ -962,3 +998,4 @@\n-                    \/\/ used.  But during decryption always create a new\n-                    \/\/ buffer in case of a bad auth tag.\n-                    if (encryption && src.position() + src.arrayOffset() >=\n+                    \/\/ used.\n+                    \/\/ Set 'inPlaceArray' true for decryption operations to\n+                    \/\/ avoid the AVX512 combined intrinsic\n+                    if (src.position() + src.arrayOffset() >=\n@@ -966,0 +1003,1 @@\n+                        inPlaceArray = (!encryption);\n@@ -987,1 +1025,1 @@\n-         * This is used for both overlap detection for the data or  decryption\n+         * This is used for both overlap detection for the data or decryption\n@@ -995,4 +1033,7 @@\n-            if (in == out && (!encryption || inOfs < outOfs)) {\n-                originalOut = out;\n-                originalOutOfs = outOfs;\n-                return new byte[out.length];\n+            if (in == out) {\n+                if (inOfs < outOfs) {\n+                    originalOut = out;\n+                    originalOutOfs = outOfs;\n+                    return new byte[out.length];\n+                }\n+                inPlaceArray = (!encryption);\n@@ -1499,2 +1540,5 @@\n-                \/\/ Clear output data\n-                Arrays.fill(out, outOfs, outOfs + len, (byte) 0);\n+                \/\/ If this is an in-place array, don't zero the input\n+                if (!inPlaceArray) {\n+                    \/\/ Clear output data\n+                    Arrays.fill(out, outOfs, outOfs + len, (byte) 0);\n+                }\n@@ -1584,6 +1628,16 @@\n-                if (dst.hasArray()) {\n-                    int ofs = dst.arrayOffset() + dst.position();\n-                    Arrays.fill(dst.array(), ofs , ofs + len, (byte)0);\n-                } else {\n-                    Unsafe.getUnsafe().setMemory(((DirectBuffer)dst).address(),\n-                        len + dst.position(), (byte)0);\n+                \/\/ If this is an in-place array, don't zero the src\n+                if (!inPlaceArray) {\n+                    if (dst.hasArray()) {\n+                        int ofs = dst.arrayOffset() + dst.position();\n+                        Arrays.fill(dst.array(), ofs, ofs + len,\n+                            (byte) 0);\n+                    } else {\n+                        NIO_ACCESS.acquireSession(dst);\n+                        try {\n+                            Unsafe.getUnsafe().setMemory(\n+                                ((DirectBuffer)dst).address(),\n+                                len + dst.position(), (byte) 0);\n+                        } finally {\n+                            NIO_ACCESS.releaseSession(dst);\n+                        }\n+                    }\n@@ -1800,2 +1854,5 @@\n-                len += implGCMCrypt(in, inOfs, inLen, in, inOfs, out, outOfs,\n-                    gctr, ghash);\n+                \/\/ Since GCMDecrypt.inPlaceArray cannot be accessed, check that\n+                \/\/ 'in' and 'out' are the same.  All other in-place situations\n+                \/\/ have been resolved by overlapDetection()\n+                len += implGCMCrypt(in, inOfs, inLen, (in == out ? null : in),\n+                    inOfs, out, outOfs, gctr, ghash);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GaloisCounterMode.java","additions":87,"deletions":30,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -127,4 +127,4 @@\n-                \/\/ If bytes to write == BLOCK_LENGTH, then we have no\n-                \/\/ left-over data from previous updates and we can create\n-                \/\/ the IntegerModuloP directly from the input buffer.\n-                processBlock(buf, bytesToWrite);\n+                \/\/ Have at least one full block in the buf, process all full blocks\n+                int blockMultipleLength = remaining & (~(BLOCK_LENGTH-1));\n+                processMultipleBlocks(buf, blockMultipleLength);\n+                remaining -= blockMultipleLength;\n@@ -141,0 +141,1 @@\n+                remaining -= bytesToWrite;\n@@ -142,2 +143,0 @@\n-\n-            remaining -= bytesToWrite;\n@@ -258,0 +257,18 @@\n+    private void processMultipleBlocks(ByteBuffer buf, int blockMultipleLength) {\n+        if (buf.hasArray()) {\n+            byte[] input = buf.array();\n+            int offset = buf.arrayOffset() + buf.position();\n+            long[] aLimbs = a.getLimbs();\n+            long[] rLimbs = r.getLimbs();\n+\n+            processMultipleBlocksCheck(input, offset, blockMultipleLength, aLimbs, rLimbs);\n+            processMultipleBlocks(input, offset, blockMultipleLength, aLimbs, rLimbs);\n+            buf.position(offset + blockMultipleLength);\n+        } else {\n+            while (blockMultipleLength >= BLOCK_LENGTH) {\n+                processBlock(buf, BLOCK_LENGTH);\n+                blockMultipleLength -= BLOCK_LENGTH;\n+            }\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/Poly1305.java","additions":23,"deletions":6,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n@@ -32,0 +34,1 @@\n+import jdk.internal.io.JdkConsoleProvider;\n@@ -48,1 +51,1 @@\n- * example by a background job scheduler, then it will typically not\n+ * example by a background job scheduler, then it may not\n@@ -96,1 +99,1 @@\n-public final class Console implements Flushable\n+public class Console implements Flushable\n@@ -595,0 +598,2 @@\n+        cons = instantiateConsole(istty);\n+\n@@ -598,10 +603,1 @@\n-                if (istty) {\n-                    if (cons == null)\n-                        cons = new Console();\n-                    return cons;\n-                }\n-                return null;\n-            }\n-\n-            public Charset charset() {\n-                return CHARSET;\n+                return cons;\n@@ -611,1 +607,25 @@\n-    private static Console cons;\n+\n+    @SuppressWarnings(\"removal\")\n+    private static Console instantiateConsole(boolean istty) {\n+        try {\n+            \/\/ Try loading providers\n+            PrivilegedAction<Console> pa = () -> {\n+                var consModName = System.getProperty(\"jdk.console\",\n+                        JdkConsoleProvider.DEFAULT_PROVIDER_MODULE_NAME);\n+                return ServiceLoader.load(ModuleLayer.boot(), JdkConsoleProvider.class).stream()\n+                        .map(ServiceLoader.Provider::get)\n+                        .filter(jcp -> consModName.equals(jcp.getClass().getModule().getName()))\n+                        .map(jcp -> jcp.console(istty, CHARSET))\n+                        .filter(Objects::nonNull)\n+                        .findAny()\n+                        .map(jc -> (Console) new ProxyingConsole(jc))\n+                        .orElse(istty ? new Console() : null);\n+            };\n+            return AccessController.doPrivileged(pa);\n+        } catch (ServiceConfigurationError ignore) {\n+            \/\/ default to built-in Console\n+            return istty ? new Console() : null;\n+        }\n+    }\n+\n+    private static final Console cons;\n@@ -613,1 +633,2 @@\n-    private Console() {\n+\n+    Console() {\n","filename":"src\/java.base\/share\/classes\/java\/io\/Console.java","additions":35,"deletions":14,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -211,0 +211,9 @@\n+    \/* Package private constructor, using the specified lock\n+     * for synchronization.\n+     *\/\n+    PrintWriter(Writer out, Object lock) {\n+        super(lock);\n+        this.out = out;\n+        this.autoFlush = false;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/PrintWriter.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,198 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.io;\n+\n+import java.nio.charset.Charset;\n+import jdk.internal.io.JdkConsole;\n+\n+\/**\n+ * Console implementation for internal use. Custom Console delegate may be\n+ * provided with jdk.internal.io.JdkConsoleProvider.\n+ *\/\n+final class ProxyingConsole extends Console {\n+    private final JdkConsole delegate;\n+    private final Object readLock;\n+    private final Object writeLock;\n+    private final Reader reader;\n+    private final PrintWriter printWriter;\n+\n+    ProxyingConsole(JdkConsole delegate) {\n+        this.delegate = delegate;\n+        readLock = new Object();\n+        writeLock = new Object();\n+        reader = new WrappingReader(delegate.reader(), readLock);\n+        printWriter = new WrappingWriter(delegate.writer(), writeLock);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public PrintWriter writer() {\n+        return printWriter;\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public Reader reader() {\n+        return reader;\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public Console format(String fmt, Object ... args) {\n+        synchronized (writeLock) {\n+            delegate.format(fmt, args);\n+        }\n+        return this;\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public Console printf(String format, Object ... args) {\n+        synchronized (writeLock) {\n+            delegate.printf(format, args);\n+        }\n+        return this;\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public String readLine(String fmt, Object ... args) {\n+        synchronized (writeLock) {\n+            synchronized (readLock) {\n+                return delegate.readLine(fmt, args);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public String readLine() {\n+        synchronized (readLock) {\n+            return delegate.readLine();\n+        }\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public char[] readPassword(String fmt, Object ... args) {\n+        synchronized (writeLock) {\n+            synchronized (readLock) {\n+                return delegate.readPassword(fmt, args);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public char[] readPassword() {\n+        synchronized (readLock) {\n+            return delegate.readPassword();\n+        }\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public void flush() {\n+        delegate.flush();\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public Charset charset() {\n+        return delegate.charset();\n+    }\n+\n+    private static class WrappingReader extends Reader {\n+        private final Reader r;\n+        private final Object lock;\n+\n+        WrappingReader(Reader r, Object lock) {\n+            super(lock);\n+            this.r = r;\n+            this.lock = lock;\n+        }\n+\n+        @Override\n+        public int read(char[] cbuf, int off, int len) throws IOException {\n+            synchronized (lock) {\n+                return r.read(cbuf, off, len);\n+            }\n+        }\n+\n+        @Override\n+        public void close() {\n+            \/\/ no-op, per Console's spec\n+        }\n+    }\n+\n+    private static class WrappingWriter extends PrintWriter {\n+        private final PrintWriter pw;\n+        private final Object lock;\n+\n+        public WrappingWriter(PrintWriter pw, Object lock) {\n+            super(pw, lock);\n+            this.pw = pw;\n+            this.lock = lock;\n+        }\n+\n+        @Override\n+        public void write(char[] cbuf, int off, int len) {\n+            synchronized (lock) {\n+                pw.write(cbuf, off, len);\n+            }\n+        }\n+\n+        @Override\n+        public void flush() {\n+            pw.flush();\n+        }\n+\n+        @Override\n+        public void close() {\n+            \/\/ no-op, per Console's spec\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/io\/ProxyingConsole.java","additions":198,"deletions":0,"binary":false,"changes":198,"status":"added"},{"patch":"@@ -238,0 +238,15 @@\n+\n+    @Override\n+    public long transferTo(OutputStream out) throws IOException {\n+        Objects.requireNonNull(out, \"out\");\n+        if (getClass() == SequenceInputStream.class) {\n+            long c = 0;\n+            while (in != null) {\n+                c += in.transferTo(out);\n+                nextStream();\n+            }\n+            return c;\n+        } else {\n+            return super.transferTo(out);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/io\/SequenceInputStream.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-import static java.lang.constant.ConstantDescs.CD_int;\n@@ -9378,1 +9377,1 @@\n-        if (index >= limit || limit < 0 || limit > a.length) {\n+        if (index >= limit || index < 0 || limit > a.length) {\n@@ -9481,1 +9480,1 @@\n-        if (index <= start || start < 0 || start >= a.length) {\n+        if (index <= start || start < 0 || index > a.length) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Character.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -270,0 +270,2 @@\n+     * @since 20\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Module.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -323,0 +323,2 @@\n+         *\n+         * @since 20\n@@ -324,9 +326,9 @@\n-         @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n-         @CallerSensitive\n-         public Controller enableNativeAccess(Module target) {\n-             ensureInLayer(target);\n-             Reflection.ensureNativeAccess(Reflection.getCallerClass(), Module.class,\n-                 \"enableNativeAccess\");\n-             target.implAddEnableNativeAccess();\n-             return this;\n-         }\n+        @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n+        @CallerSensitive\n+        public Controller enableNativeAccess(Module target) {\n+            ensureInLayer(target);\n+            Reflection.ensureNativeAccess(Reflection.getCallerClass(), Module.class,\n+                \"enableNativeAccess\");\n+            target.implAddEnableNativeAccess();\n+            return this;\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ModuleLayer.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -89,0 +89,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -191,0 +192,3 @@\n+    \/\/ Holder for the initial value of `in`, set within `initPhase1()`.\n+    private static InputStream initialIn;\n+\n@@ -2176,1 +2180,2 @@\n-        setIn0(new BufferedInputStream(fdIn));\n+        initialIn = new BufferedInputStream(fdIn);\n+        setIn0(initialIn);\n@@ -2487,0 +2492,4 @@\n+            public InputStream initialSystemIn() {\n+                return initialIn;\n+            }\n+\n@@ -2581,2 +2590,10 @@\n-            public Object[] extentLocalCache() {\n-                return Thread.extentLocalCache();\n+            public Object[] scopedValueCache() {\n+                return Thread.scopedValueCache();\n+            }\n+\n+            public void setScopedValueCache(Object[] cache) {\n+                Thread.setScopedValueCache(cache);\n+            }\n+\n+            public Object scopedValueBindings() {\n+                return Thread.scopedValueBindings();\n@@ -2585,2 +2602,2 @@\n-            public void setExtentLocalCache(Object[] cache) {\n-                Thread.setExtentLocalCache(cache);\n+            public Object findScopedValueBindings() {\n+                return Thread.findScopedValueBindings();\n@@ -2589,2 +2606,2 @@\n-            public Object extentLocalBindings() {\n-                return Thread.extentLocalBindings();\n+            public void setScopedValueBindings(Object bindings) {\n+                Thread.setScopedValueBindings(bindings);\n@@ -2593,2 +2610,3 @@\n-            public void setExtentLocalBindings(Object bindings) {\n-                Thread.setExtentLocalBindings(bindings);\n+            @ForceInline\n+            public void ensureMaterializedForStackWalk(Object value) {\n+                Thread.ensureMaterializedForStackWalk(value);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":27,"deletions":9,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.ref.Reference;\n@@ -52,1 +53,1 @@\n-import jdk.internal.vm.ExtentLocalContainer;\n+import jdk.internal.vm.ScopedValueContainer;\n@@ -55,0 +56,2 @@\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Hidden;\n@@ -282,1 +285,1 @@\n-     * Extent locals binding are maintained by the ExtentLocal class.\n+     * Scoped value bindings are maintained by the ScopedValue class.\n@@ -284,1 +287,1 @@\n-    private Object extentLocalBindings;\n+    private Object scopedValueBindings;\n@@ -286,2 +289,6 @@\n-    static Object extentLocalBindings() {\n-        return currentThread().extentLocalBindings;\n+    \/\/ Special value to indicate this is a newly-created Thread\n+    \/\/ Note that his must match the declaration in ScopedValue.\n+    private static final Object NEW_THREAD_BINDINGS = Thread.class;\n+\n+    static Object scopedValueBindings() {\n+        return currentThread().scopedValueBindings;\n@@ -290,2 +297,2 @@\n-    static void setExtentLocalBindings(Object bindings) {\n-        currentThread().extentLocalBindings = bindings;\n+    static void setScopedValueBindings(Object bindings) {\n+        currentThread().scopedValueBindings = bindings;\n@@ -295,1 +302,7 @@\n-     * Inherit the extent-local bindings from the given container.\n+     * Search the stack for the most recent scoped-value bindings.\n+     *\/\n+    @IntrinsicCandidate\n+    static native Object findScopedValueBindings();\n+\n+    \/**\n+     * Inherit the scoped-value bindings from the given container.\n@@ -298,2 +311,2 @@\n-    void inheritExtentLocalBindings(ThreadContainer container) {\n-        ExtentLocalContainer.BindingsSnapshot snapshot;\n+    void inheritScopedValueBindings(ThreadContainer container) {\n+        ScopedValueContainer.BindingsSnapshot snapshot;\n@@ -301,1 +314,1 @@\n-                && (snapshot = container.extentLocalBindings()) != null) {\n+                && (snapshot = container.scopedValueBindings()) != null) {\n@@ -304,3 +317,3 @@\n-            Object bindings = snapshot.extentLocalBindings();\n-            if (currentThread().extentLocalBindings != bindings) {\n-                StructureViolationExceptions.throwException(\"Extent local bindings have changed\");\n+            Object bindings = snapshot.scopedValueBindings();\n+            if (currentThread().scopedValueBindings != bindings) {\n+                StructureViolationExceptions.throwException(\"Scoped value bindings have changed\");\n@@ -309,1 +322,1 @@\n-            this.extentLocalBindings = bindings;\n+            this.scopedValueBindings = bindings;\n@@ -396,1 +409,4 @@\n-    \/\/ ExtentLocal support:\n+    \/\/ ScopedValue support:\n+\n+    @IntrinsicCandidate\n+    static native Object[] scopedValueCache();\n@@ -399,1 +415,1 @@\n-    static native Object[] extentLocalCache();\n+    static native void setScopedValueCache(Object[] cache);\n@@ -402,1 +418,1 @@\n-    static native void setExtentLocalCache(Object[] cache);\n+    static native void ensureMaterializedForStackWalk(Object o);\n@@ -731,0 +747,4 @@\n+\n+        \/\/ Special value to indicate this is a newly-created Thread\n+        \/\/ Note that his must match the declaration in ScopedValue.\n+        this.scopedValueBindings = NEW_THREAD_BINDINGS;\n@@ -770,0 +790,3 @@\n+        \/\/ Special value to indicate this is a newly-created Thread\n+        this.scopedValueBindings = NEW_THREAD_BINDINGS;\n+\n@@ -1567,2 +1590,2 @@\n-                \/\/ extent locals may be inherited\n-                inheritExtentLocalBindings(container);\n+                \/\/ scoped values may be inherited\n+                inheritScopedValueBindings(container);\n@@ -1599,1 +1622,2 @@\n-            task.run();\n+            Object bindings = scopedValueBindings();\n+            runWith(bindings, task);\n@@ -1603,0 +1627,13 @@\n+    \/**\n+     * The VM recognizes this method as special, so any changes to the\n+     * name or signature require corresponding changes in\n+     * JVM_FindScopedValueBindings().\n+     *\/\n+    @Hidden\n+    @ForceInline\n+    private void runWith(Object bindings, Runnable op) {\n+        ensureMaterializedForStackWalk(bindings);\n+        op.run();\n+        Reference.reachabilityFence(bindings);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":58,"deletions":21,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -703,17 +703,0 @@\n-    \/**\n-     * Does nothing.\n-     *\n-     * @return false\n-     *\n-     * @param b ignored\n-     *\n-     * @deprecated This method was originally intended for controlling suspension\n-     *             in low memory conditions. It was never specified.\n-     *\n-     * @since   1.1\n-     *\/\n-    @Deprecated(since=\"1.2\", forRemoval=true)\n-    public boolean allowThreadSuspension(boolean b) {\n-        return false;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ThreadGroup.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.ref.Reference;\n@@ -56,0 +57,2 @@\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Hidden;\n@@ -224,2 +227,4 @@\n-     * Submits the runContinuation task to the scheduler.\n-     * @param {@code lazySubmit} to lazy submit\n+     * Submits the runContinuation task to the scheduler. For the default scheduler,\n+     * and calling it on a worker thread, the task will be pushed to the local queue,\n+     * otherwise it will be pushed to a submission queue.\n+     *\n@@ -227,1 +232,0 @@\n-     * @see ForkJoinPool#lazySubmit(ForkJoinTask)\n@@ -229,1 +233,1 @@\n-    private void submitRunContinuation(boolean lazySubmit) {\n+    private void submitRunContinuation() {\n@@ -231,5 +235,1 @@\n-            if (lazySubmit && scheduler instanceof ForkJoinPool pool) {\n-                pool.lazySubmit(ForkJoinTask.adapt(runContinuation));\n-            } else {\n-                scheduler.execute(runContinuation);\n-            }\n+            scheduler.execute(runContinuation);\n@@ -237,7 +237,1 @@\n-            \/\/ record event\n-            var event = new VirtualThreadSubmitFailedEvent();\n-            if (event.isEnabled()) {\n-                event.javaThreadId = threadId();\n-                event.exceptionMessage = ree.getMessage();\n-                event.commit();\n-            }\n+            submitFailed(ree);\n@@ -249,1 +243,1 @@\n-     * Submits the runContinuation task to the scheduler.\n+     * Submits the runContinuation task to the scheduler with a lazy submit.\n@@ -251,0 +245,1 @@\n+     * @see ForkJoinPool#lazySubmit(ForkJoinTask)\n@@ -252,2 +247,7 @@\n-    private void submitRunContinuation() {\n-        submitRunContinuation(false);\n+    private void lazySubmitRunContinuation(ForkJoinPool pool) {\n+        try {\n+            pool.lazySubmit(ForkJoinTask.adapt(runContinuation));\n+        } catch (RejectedExecutionException ree) {\n+            submitFailed(ree);\n+            throw ree;\n+        }\n@@ -257,2 +257,1 @@\n-     * Submits the runContinuation task to the scheduler and without signalling\n-     * any threads if possible.\n+     * Submits the runContinuation task to the scheduler as an external submit.\n@@ -260,0 +259,13 @@\n+     * @see ForkJoinPool#externalSubmit(ForkJoinTask)\n+     *\/\n+    private void externalSubmitRunContinuation(ForkJoinPool pool) {\n+        try {\n+            pool.externalSubmit(ForkJoinTask.adapt(runContinuation));\n+        } catch (RejectedExecutionException ree) {\n+            submitFailed(ree);\n+            throw ree;\n+        }\n+    }\n+\n+    \/**\n+     * If enabled, emits a JFR VirtualThreadSubmitFailedEvent.\n@@ -261,2 +273,7 @@\n-    private void lazySubmitRunContinuation() {\n-        submitRunContinuation(true);\n+    private void submitFailed(RejectedExecutionException ree) {\n+        var event = new VirtualThreadSubmitFailedEvent();\n+        if (event.isEnabled()) {\n+            event.javaThreadId = threadId();\n+            event.exceptionMessage = ree.getMessage();\n+            event.commit();\n+        }\n@@ -286,0 +303,1 @@\n+        Object bindings = scopedValueBindings();\n@@ -287,1 +305,1 @@\n-            task.run();\n+            runWith(bindings, task);\n@@ -292,1 +310,0 @@\n-\n@@ -314,0 +331,8 @@\n+    @Hidden\n+    @ForceInline\n+    private void runWith(Object bindings, Runnable op) {\n+        ensureMaterializedForStackWalk(bindings);\n+        op.run();\n+        Reference.reachabilityFence(bindings);\n+    }\n+\n@@ -429,1 +454,6 @@\n-                lazySubmitRunContinuation();\n+                if (currentThread() instanceof CarrierThread ct) {\n+                    lazySubmitRunContinuation(ct.getPool());\n+                } else {\n+                    submitRunContinuation();\n+                }\n+\n@@ -437,2 +467,6 @@\n-            \/\/ lazy submit to continue on the current thread as carrier if possible\n-            lazySubmitRunContinuation();\n+            \/\/ external submit if there are no tasks in the local task queue\n+            if (currentThread() instanceof CarrierThread ct && ct.getQueuedTaskCount() == 0) {\n+                externalSubmitRunContinuation(ct.getPool());\n+            } else {\n+                submitRunContinuation();\n+            }\n@@ -491,2 +525,2 @@\n-            \/\/ extent locals may be inherited\n-            inheritExtentLocalBindings(container);\n+            \/\/ scoped values may be inherited\n+            inheritScopedValueBindings(container);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":64,"deletions":30,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * An arena allocates and manages the lifecycle of native segments.\n+ * An arena controls the lifecycle of memory segments, providing both flexible allocation and timely deallocation.\n@@ -34,11 +34,14 @@\n- * An arena is a {@linkplain AutoCloseable closeable} segment allocator that is associated with a {@link #session() memory session}.\n- * This session is created with the arena, and is closed when the arena is {@linkplain #close() closed}.\n- * Furthermore, all the native segments {@linkplain #allocate(long, long) allocated} by the arena are associated\n- * with that session.\n- * <p>\n- * The <a href=\"MemorySession.html#thread-confinement\">confinement properties<\/a> of the session associated with an\n- * arena are determined by the factory used to create the arena. For instance, an arena created with {@link #openConfined()}\n- * is associated with a <em>confined<\/em> memory session. Conversely, an arena created with {@link #openShared()} is\n- * associated with a <em>shared<\/em> memory session.\n- * <p>\n- * An arena is extremely useful when interacting with foreign code, as shown below:\n+ * An arena has a {@linkplain #scope() scope}, called the arena scope. When the arena is {@linkplain #close() closed},\n+ * the arena scope is no longer {@linkplain SegmentScope#isAlive() alive}. As a result, all the\n+ * segments associated with the arena scope are invalidated, safely and atomically, their backing memory regions are\n+ * deallocated (where applicable) and can no longer be accessed after the arena is closed:\n+ *\n+ * {@snippet lang = java:\n+ * try (Arena arena = Arena.openConfined()) {\n+ *     MemorySegment segment = MemorySegment.allocateNative(100, arena.scope());\n+ *     ...\n+ * } \/\/ memory released here\n+ *}\n+ *\n+ * Furthermore, an arena is a {@link SegmentAllocator}. All the segments {@linkplain #allocate(long, long) allocated} by the\n+ * arena are associated with the arena scope. This makes arenas extremely useful when interacting with foreign code, as shown below:\n@@ -50,1 +53,1 @@\n- *     MemorySegment upcallStub = linker.upcallStub(handle, desc, arena.session());\n+ *     MemorySegment upcallStub = linker.upcallStub(handle, desc, arena.scope());\n@@ -55,0 +58,25 @@\n+ * <h2 id = \"thread-confinement\">Safety and thread-confinement<\/h2>\n+ *\n+ * Arenas provide strong temporal safety guarantees: a memory segment allocated by an arena cannot be accessed\n+ * <em>after<\/em> the arena has been closed. The cost of providing this guarantee varies based on the\n+ * number of threads that have access to the memory segments allocated by the arena. For instance, if an arena\n+ * is always created and closed by one thread, and the memory segments associated with the arena's scope are always\n+ * accessed by that same thread, then ensuring correctness is trivial.\n+ * <p>\n+ * Conversely, if an arena allocates segments that can be accessed by multiple threads, or if the arena can be closed\n+ * by a thread other than the accessing thread, then ensuring correctness is much more complex. For example, a segment\n+ * allocated with the arena might be accessed <em>while<\/em> another thread attempts, concurrently, to close the arena.\n+ * To provide the strong temporal safety guarantee without forcing every client, even simple ones, to incur a performance\n+ * impact, arenas are divided into <em>thread-confined<\/em> arenas, and <em>shared<\/em> arenas.\n+ * <p>\n+ * Confined arenas, support strong thread-confinement guarantees. Upon creation, they are assigned an\n+ * {@linkplain #isCloseableBy(Thread) owner thread}, typically the thread which initiated the creation operation.\n+ * The segments created by a confined arena can only be {@linkplain SegmentScope#isAccessibleBy(Thread) accessed}\n+ * by the owner thread. Moreover, any attempt to close the confined arena from a thread other than the owner thread will\n+ * fail with {@link WrongThreadException}.\n+ * <p>\n+ * Shared arenas, on the other hand, have no owner thread. The segments created by a shared arena\n+ * can be {@linkplain SegmentScope#isAccessibleBy(Thread) accessed} by any thread. This might be useful when\n+ * multiple threads need to access the same memory segment concurrently (e.g. in the case of parallel processing).\n+ * Moreover, a shared arena {@linkplain #isCloseableBy(Thread) can be closed} by any thread.\n+ *\n@@ -61,5 +89,5 @@\n-     * Creates a native memory segment with the given size (in bytes), alignment constraint (in bytes).\n-     * The returned segment is associated with the same memory session associated with this arena.\n-     * The {@link MemorySegment#address()} of the returned memory segment is the starting address of the\n-     * allocated off-heap memory region backing the segment. Moreover, the {@linkplain MemorySegment#address() address}\n-     * of the returned segment is aligned according the provided alignment constraint.\n+     * Returns a native memory segment with the given size (in bytes) and alignment constraint (in bytes).\n+     * The returned segment is associated with the arena scope.\n+     * The segment's {@link MemorySegment#address() address} is the starting address of the\n+     * allocated off-heap memory region backing the segment, and the address is\n+     * aligned according the provided alignment constraint.\n@@ -69,3 +97,10 @@\n-     * {@snippet lang=java :\n-     * MemorySegment.allocateNative(bytesSize, byteAlignment, session());\n-     * }\n+     * {@snippet lang = java:\n+     * MemorySegment.allocateNative(bytesSize, byteAlignment, scope());\n+     *}\n+     * More generally implementations of this method must return a native segment featuring the requested size,\n+     * and that is compatible with the provided alignment constraint. Furthermore, for any two segments\n+     * {@code S1, S2} returned by this method, the following invariant must hold:\n+     *\n+     * {@snippet lang = java:\n+     * S1.overlappingSlice(S2).isEmpty() == true\n+     *}\n@@ -78,4 +113,4 @@\n-     * @throws IllegalStateException if the session associated with this arena is not {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread\n-     * {@linkplain MemorySession#isOwnedBy(Thread) owning} the session associated with this arena.\n-     * @see MemorySegment#allocateNative(long, long, MemorySession)\n+     * @throws IllegalStateException if the arena has already been {@linkplain #close() closed}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * @see MemorySegment#allocateNative(long, long, SegmentScope)\n@@ -85,1 +120,1 @@\n-        return MemorySegment.allocateNative(byteSize, byteAlignment, session());\n+        return MemorySegment.allocateNative(byteSize, byteAlignment, scope());\n@@ -89,1 +124,1 @@\n-     * {@return the session associated with this arena}\n+     * {@return the arena scope}\n@@ -91,1 +126,1 @@\n-    MemorySession session();\n+    SegmentScope scope();\n@@ -94,6 +129,14 @@\n-     * Closes this arena. This closes the {@linkplain #session() session} associated with this arena and invalidates\n-     * all the memory segments associated with it. Any off-heap region of memory backing the segments associated with\n-     * that memory session are also released.\n-     * @throws IllegalStateException if the session associated with this arena is not {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread\n-     * {@linkplain MemorySession#isOwnedBy(Thread) owning} the session associated with this arena.\n+     * Closes this arena. If this method completes normally, the arena scope is no longer {@linkplain SegmentScope#isAlive() alive},\n+     * and all the memory segments associated with it can no longer be accessed. Furthermore, any off-heap region of memory backing the\n+     * segments associated with that scope are also released.\n+     *\n+     * @apiNote This operation is not idempotent; that is, closing an already closed arena <em>always<\/em> results in an\n+     * exception being thrown. This reflects a deliberate design choice: failure to close an arena might reveal a bug\n+     * in the underlying application logic.\n+     *\n+     * @see SegmentScope#isAlive()\n+     *\n+     * @throws IllegalStateException if the arena has already been closed.\n+     * @throws IllegalStateException if the arena scope is {@linkplain SegmentScope#whileAlive(Runnable) kept alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code isCloseableBy(T) == false}.\n@@ -105,2 +148,7 @@\n-     * Creates a new arena, associated with a new confined session.\n-     * @return a new arena, associated with a new confined session.\n+     * {@return {@code true} if the provided thread can close this arena}\n+     * @param thread the thread to be tested.\n+     *\/\n+    boolean isCloseableBy(Thread thread);\n+\n+    \/**\n+     * {@return a new confined arena, owned by the current thread}\n@@ -109,1 +157,1 @@\n-        return makeArena(MemorySessionImpl.createConfined(Thread.currentThread()));\n+        return MemorySessionImpl.createConfined(Thread.currentThread()).asArena();\n@@ -113,2 +161,1 @@\n-     * Creates a new arena, associated with a new shared session.\n-     * @return a new arena, associated with a new shared session.\n+     * {@return a new shared arena}\n@@ -117,15 +164,1 @@\n-        return makeArena(MemorySessionImpl.createShared());\n-    }\n-\n-    private static Arena makeArena(MemorySessionImpl sessionImpl) {\n-        return new Arena() {\n-            @Override\n-            public MemorySession session() {\n-                return sessionImpl;\n-            }\n-\n-            @Override\n-            public void close() {\n-                sessionImpl.close();\n-            }\n-        };\n+        return MemorySessionImpl.createShared().asArena();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Arena.java","additions":87,"deletions":54,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -37,2 +37,2 @@\n- * A function descriptor is made up of zero or more argument layouts and zero or one return layout. A function descriptor\n- * is used to model the signature of foreign functions when creating\n+ * A function descriptor models the signature of foreign functions. A function descriptor is made up of zero or more\n+ * argument layouts and zero or one return layout. A function descriptor is typically used when creating\n@@ -40,1 +40,1 @@\n- * {@linkplain Linker#upcallStub(MethodHandle, FunctionDescriptor, MemorySession) upcall stubs}.\n+ * {@linkplain Linker#upcallStub(MethodHandle, FunctionDescriptor, SegmentScope) upcall stubs}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/FunctionDescriptor.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * can be combined: if member layouts are laid out one after the other, the resulting group layout is said to be a <em>struct<\/em>\n+ * can be combined: if member layouts are laid out one after the other, the resulting group layout is said to be a <em>struct layout<\/em>\n@@ -35,1 +35,1 @@\n- * the resulting group layout is said to be a <em>union<\/em> (see {@link MemoryLayout#unionLayout(MemoryLayout...)}).\n+ * the resulting group layout is said to be a <em>union layout<\/em> (see {@link MemoryLayout#unionLayout(MemoryLayout...)}).\n@@ -56,0 +56,3 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n@@ -59,0 +62,3 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/GroupLayout.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n- * via the generation of {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, MemorySession) upcall stubs}.<\/li>\n+ * via the generation of {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, SegmentScope) upcall stubs}.<\/li>\n@@ -76,9 +76,1 @@\n- * More specifically, given each layout {@code L} in the function descriptor, a corresponding carrier {@code C} is inferred,\n- * as described below:\n- * <ul>\n- * <li>if {@code L} is a {@link ValueLayout} with carrier {@code E} then {@code C = E}; or<\/li>\n- * <li>if {@code L} is a {@link GroupLayout}, then {@code C} is set to {@code MemorySegment.class}<\/li>\n- * <\/ul>\n- * <p>\n- * The downcall method handle type, derived as above, might be decorated by additional leading parameters,\n- * in the given order if both are present:\n+ * The downcall method handle type, might then be decorated by additional leading parameters, in the given order if both are present:\n@@ -96,1 +88,1 @@\n- * {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, MemorySession) Creating an upcall stub} requires a method\n+ * {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, SegmentScope) Creating an upcall stub} requires a method\n@@ -100,8 +92,3 @@\n- * The type of the provided method handle has to {@linkplain FunctionDescriptor#toMethodType() match} the Java\n- * {@linkplain java.lang.invoke.MethodType method type} associated with the upcall stub, which is derived from the argument\n- * and return layouts in the function descriptor. More specifically, given each layout {@code L} in the function descriptor,\n- * a corresponding carrier {@code C} is inferred, as described below:\n- * <ul>\n- * <li>if {@code L} is a {@link ValueLayout} with carrier {@code E} then {@code C = E}; or<\/li>\n- * <li>if {@code L} is a {@link GroupLayout}, then {@code C} is set to {@code MemorySegment.class}<\/li>\n- * <\/ul>\n+ * The type of the provided method handle's type has to match the method type associated with the upcall stub,\n+ * which is {@linkplain FunctionDescriptor#toMethodType() derived} from the provided function descriptor.\n+ * <p>\n@@ -109,2 +96,1 @@\n- * downcall method handles and, when no longer required, they can be closed, via their associated\n- * {@linkplain MemorySession memory session}.\n+ * downcall method handles and, they are released via their associated {@linkplain SegmentScope scope}.\n@@ -122,1 +108,1 @@\n- *     <li>The memory session of {@code A} is {@linkplain MemorySession#isAlive() alive}. Otherwise, the invocation throws\n+ *     <li>The scope of {@code A} is {@linkplain SegmentScope#isAlive() alive}. Otherwise, the invocation throws\n@@ -124,3 +110,3 @@\n- *     <li>The invocation occurs in same thread as the one {@linkplain MemorySession#isOwnedBy(Thread) owning} the memory session of {@code R},\n- *     if said session is confined. Otherwise, the invocation throws {@link WrongThreadException}; and<\/li>\n- *     <li>The memory session of {@code R} is <em>kept alive<\/em> (and cannot be closed) during the invocation.<\/li>\n+ *     <li>The invocation occurs in a thread {@code T} such that {@code A.scope().isAccessibleBy(T) == true}.\n+ *     Otherwise, the invocation throws {@link WrongThreadException}; and<\/li>\n+ *     <li>The scope of {@code A} is {@linkplain SegmentScope#whileAlive(Runnable) kept alive} during the invocation.<\/li>\n@@ -130,1 +116,1 @@\n- * the {@linkplain MemorySession#global() global session}. Under normal conditions, the size of the returned segment is {@code 0}.\n+ * the {@linkplain SegmentScope#global() global scope}. Under normal conditions, the size of the returned segment is {@code 0}.\n@@ -143,1 +129,1 @@\n- * is a native segment associated with the {@linkplain MemorySession#global() global session}.\n+ * is a native segment associated with the {@linkplain SegmentScope#global() global scope}.\n@@ -176,1 +162,1 @@\n-     * {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, MemorySession) upcall stub}.\n+     * {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, SegmentScope) upcall stub}.\n@@ -255,2 +241,2 @@\n-     * Creates a stub which can be passed to other foreign functions as a function pointer, with the given\n-     * memory session. Calling such a function pointer from foreign code will result in the execution of the provided\n+     * Creates a stub which can be passed to other foreign functions as a function pointer, associated with the given\n+     * scope. Calling such a function pointer from foreign code will result in the execution of the provided\n@@ -260,1 +246,2 @@\n-     * the provided memory session. When such session is closed, the corresponding upcall stub will be deallocated.\n+     * the provided scope. As such, the corresponding upcall stub will be deallocated\n+     * when the scope becomes not {@linkplain SegmentScope#isAlive() alive}.\n@@ -270,1 +257,1 @@\n-     * @param session the upcall stub memory session.\n+     * @param scope the scope associated with the returned upcall stub segment.\n@@ -275,3 +262,3 @@\n-     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread\n-     * {@linkplain MemorySession#isOwnedBy(Thread) owning} {@code session}.\n+     * @throws IllegalStateException if {@code scope} is not {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope.isAccessibleBy(T) == false}.\n@@ -279,1 +266,1 @@\n-    MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, MemorySession session);\n+    MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, SegmentScope scope);\n@@ -297,1 +284,1 @@\n-     * A linker option that can be used to indicate additional linking requirements to the linker,\n+     * A linker option is used to indicate additional linking requirements to the linker,\n@@ -299,0 +286,1 @@\n+     * @since 20\n@@ -300,0 +288,1 @@\n+    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -305,1 +294,1 @@\n-         * {@return A linker option used to denote the index of the first variadic argument layout in a\n+         * {@return a linker option used to denote the index of the first variadic argument layout in a\n@@ -316,1 +305,1 @@\n-         *          before it can be overwritten by the runtime, or read through conventional means}\n+         *          before it can be overwritten by the Java runtime, or read through conventional means}\n@@ -337,1 +326,1 @@\n-         * State is captured by a downcall method handle on invocation, by writing it\n+         * Execution state is captured by a downcall method handle on invocation, by writing it\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":29,"deletions":40,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n- * A memory layout can be used to describe the contents of a memory segment.\n+ * A memory layout describes the contents of a memory segment.\n@@ -357,1 +357,1 @@\n-     * Creates an access var handle that can be used to access a memory segment at the layout selected by the given layout path,\n+     * Creates a var handle that can be used to access a memory segment at the layout selected by the given layout path,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n- * Native segments can be obtained by calling one of the {@link MemorySegment#allocateNative(long, long, MemorySession)}\n+ * Native segments can be obtained by calling one of the {@link MemorySegment#allocateNative(long, long, SegmentScope)}\n@@ -69,1 +69,1 @@\n- * {@link FileChannel#map(MapMode, long, long, MemorySession) mapping} a file into a new off-heap region\n+ * {@link FileChannel#map(MapMode, long, long, SegmentScope) mapping} a file into a new off-heap region\n@@ -94,2 +94,2 @@\n- * (as in {@link MemorySegment#allocateNative(long, MemorySession)}) or derived from a {@link MemoryLayout}\n- * (as in {@link MemorySegment#allocateNative(MemoryLayout, MemorySession)}). The size of a memory segment is typically\n+ * (as in {@link MemorySegment#allocateNative(long, SegmentScope)}) or derived from a {@link MemoryLayout}\n+ * (as in {@link MemorySegment#allocateNative(MemoryLayout, SegmentScope)}). The size of a memory segment is typically\n@@ -102,1 +102,1 @@\n- * Every memory segment is associated with a {@linkplain MemorySession memory session}. This ensures that access operations\n+ * Every memory segment is associated with a {@linkplain SegmentScope scope}. This ensures that access operations\n@@ -104,1 +104,1 @@\n- * (e.g. after the memory session associated with the accessed memory segment is no longer {@link MemorySession#isAlive() alive}.\n+ * (e.g., after the scope associated with the accessed memory segment is no longer {@linkplain SegmentScope#isAlive() alive}).\n@@ -107,3 +107,4 @@\n- * Finally, access operations on a memory segment are subject to the thread-confinement checks enforced by the associated memory\n- * session; that is, if the segment is associated with a shared session, it can be accessed by multiple threads; if it is\n- * associated with a confined session, it can only be accessed by the thread which owns the memory session.\n+ * Finally, access operations on a memory segment are subject to the thread-confinement checks enforced by the associated\n+ * scope; that is, if the segment is associated with the {@linkplain SegmentScope#global() global scope} or an {@linkplain SegmentScope#auto() automatic scope},\n+ * it can be accessed by multiple threads. If the segment is associated with an arena scope, then it can only be\n+ * accessed compatibly with the <a href=\"Arena.html#thread-confinement\">arena confinement characteristics<\/a>.\n@@ -130,2 +131,2 @@\n- * {@linkplain MethodHandles#memorySegmentViewVarHandle(ValueLayout) memory segment view var handle},\n- * that is, a var handle that accepts a segment and a {@code long} offset. More complex access var handles\n+ * {@linkplain MethodHandles#memorySegmentViewVarHandle(ValueLayout) var handle}\n+ * that accepts a segment and a {@code long} offset. More complex var handles\n@@ -146,1 +147,1 @@\n- * Alternatively, complex access var handles can can be obtained\n+ * Alternatively, complex var handles can can be obtained\n@@ -164,2 +165,2 @@\n- * MemorySession session = ...\n- * MemorySegment segment = MemorySegment.allocateNative(100, session);\n+ * Arena arena = ...\n+ * MemorySegment segment = arena.allocate(100);\n@@ -168,1 +169,1 @@\n- * session.close();\n+ * arena.close();\n@@ -174,3 +175,3 @@\n- * {@code slice} segment will result in an exception. The {@linkplain MemorySession temporal bounds} of the original segment\n- * are inherited by its slices; that is, when the memory session associated with {@code segment} is closed, {@code slice}\n- * will also be become inaccessible.\n+ * {@code slice} segment will result in an exception. The {@linkplain SegmentScope temporal bounds} of the original segment\n+ * is inherited by its slices; that is, when the scope associated with {@code segment} is no longer {@linkplain SegmentScope#isAlive() alive},\n+ * {@code slice} will also be become inaccessible.\n@@ -180,2 +181,2 @@\n- * (to do this, the segment has to be associated with a shared memory session). The following code can be used to sum all int\n- * values in a memory segment in parallel:\n+ * (to do this, the segment has to be associated with a scope that allows {@linkplain SegmentScope#isAccessibleBy(Thread) access}\n+ * from multiple threads). The following code can be used to sum all int values in a memory segment in parallel:\n@@ -243,2 +244,2 @@\n- * the segment should be allocated by specifying a 8-byte alignment constraint, either via {@link #allocateNative(long, long, MemorySession)}\n- * or {@link #allocateNative(MemoryLayout, MemorySession)}. These factories ensure that the off-heap region of memory backing\n+ * the segment should be allocated by specifying a 8-byte alignment constraint, either via {@link #allocateNative(long, long, SegmentScope)}\n+ * or {@link #allocateNative(MemoryLayout, SegmentScope)}. These factories ensure that the off-heap region of memory backing\n@@ -312,1 +313,1 @@\n- * Heap segment can only be accessed using a layout whose alignment is smaller or equal to the\n+ * Heap segments can only be accessed using a layout whose alignment is smaller or equal to the\n@@ -330,2 +331,2 @@\n- * Alternatively, they can invoke the access operation with a layout whose alignment is smaller:\n- *\n+ * Alternatively, they can invoke the access operation with an <em>unaligned layout<\/em>.\n+ * All unaligned layout constants (e.g. {@link ValueLayout#JAVA_INT_UNALIGNED}) have their alignment constraint set to 1:\n@@ -334,1 +335,1 @@\n- * byteSegment.get(ValueLayout.JAVA_INT.withBitAlignment(8), 0); \/\/ ok: layout alignment is 1, segment max alignment is 1\n+ * byteSegment.get(ValueLayout.JAVA_INT_UNALIGNED, 0); \/\/ ok: layout alignment is 1, segment max alignment is 1\n@@ -357,1 +358,1 @@\n- * {@link MemorySession#global() global} memory session. This is because the Java runtime, in addition to having no insight\n+ * {@link SegmentScope#global() global scope}. This is because the Java runtime, in addition to having no insight\n@@ -359,2 +360,2 @@\n- * into the lifetime intended for said region of memory by the foreign function that allocated it. The global memory\n- * session ensures that the obtained segment can be passed, opaquely, to other pointer-accepting foreign functions.\n+ * into the lifetime intended for said region of memory by the foreign function that allocated it. The global scope\n+ * ensures that the obtained segment can be passed, opaquely, to other pointer-accepting foreign functions.\n@@ -363,1 +364,1 @@\n- * can {@linkplain java.lang.foreign.MemorySegment#ofAddress(long, long, MemorySession) obtain}\n+ * can {@linkplain java.lang.foreign.MemorySegment#ofAddress(long, long, SegmentScope) obtain}\n@@ -367,1 +368,1 @@\n- * MemorySession session = ... \/\/ initialize a memory session\n+ * SegmentScope scope = ... \/\/ obtains a scope\n@@ -369,1 +370,1 @@\n- * MemorySegment segment = MemorySegment.ofAddress(foreign.address(), 4, session); \/\/ create new segment (size = 4)\n+ * MemorySegment segment = MemorySegment.ofAddress(foreign.address(), 4, scope); \/\/ create new segment (size = 4)\n@@ -383,1 +384,1 @@\n- * Both {@link #ofAddress(long, long, MemorySession)} and {@link ValueLayout.OfAddress#asUnbounded()} are\n+ * Both {@link #ofAddress(long, long, SegmentScope)} and {@link ValueLayout.OfAddress#asUnbounded()} are\n@@ -420,1 +421,1 @@\n-     * are associated with the same memory session as this segment.\n+     * are associated with the same scope as that associated with this segment.\n@@ -451,1 +452,1 @@\n-     * {@return the memory session associated with this memory segment}\n+     * {@return the scope associated with this memory segment}\n@@ -453,1 +454,1 @@\n-    MemorySession session();\n+    SegmentScope scope();\n@@ -508,1 +509,1 @@\n-     * created e.g. using the {@link #allocateNative(long, MemorySession)} (and related) factory, or by\n+     * created e.g. using the {@link #allocateNative(long, SegmentScope)} (and related) factory, or by\n@@ -516,1 +517,1 @@\n-     * {@link FileChannel#map(FileChannel.MapMode, long, long, MemorySession)} factory, or by\n+     * {@link FileChannel#map(FileChannel.MapMode, long, long, SegmentScope)} factory, or by\n@@ -582,4 +583,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -601,8 +602,8 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code src} is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with {@code src}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with {@code src} is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code src.scope().isAccessibleBy(T) == false}.\n@@ -635,10 +636,13 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code other} is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with {@code other}.\n-     *\/\n-    long mismatch(MemorySegment other);\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with {@code other} is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code other.scope().isAccessibleBy(T) == false}.\n+     *\/\n+    default long mismatch(MemorySegment other) {\n+        Objects.requireNonNull(other);\n+        return MemorySegment.mismatch(this, 0, byteSize(), other, 0, other.byteSize());\n+    }\n@@ -664,4 +668,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -681,4 +685,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -698,4 +702,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -727,4 +731,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -750,4 +754,3 @@\n-     * after the memory session associated with this segment is no longer {@linkplain MemorySession#isAlive() alive}, will\n-     * throw an {@link IllegalStateException}. Similarly, accessing the returned buffer from a thread other than\n-     * the thread {@linkplain MemorySession#isOwnedBy(Thread) owning} this segment's memory session will throw\n-     * a {@link WrongThreadException}.\n+     * after the scope associated with this segment is no longer {@linkplain SegmentScope#isAlive() alive}, will\n+     * throw an {@link IllegalStateException}. Similarly, accessing the returned buffer from a thread {@code T}\n+     * such that {@code scope().isAccessible(T) == false} will throw a {@link WrongThreadException}.\n@@ -755,2 +758,2 @@\n-     * If this segment is associated with a confined memory session, calling read\/write I\/O operations on the resulting buffer\n-     * might result in an unspecified exception being thrown. Examples of such problematic operations are\n+     * If this segment is associated with a scope that can only be accessed from a single thread, calling read\/write I\/O\n+     * operations on the resulting buffer might result in an unspecified exception being thrown. Examples of such problematic operations are\n@@ -775,4 +778,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -789,4 +792,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -803,4 +806,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -817,4 +820,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -831,4 +834,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -845,4 +848,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -859,4 +862,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -881,4 +884,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -906,4 +909,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -924,2 +927,1 @@\n-     * The memory session {@code S} associated with the returned segment is\n-     * computed as follows:\n+     * The scope {@code S} associated with the returned segment is computed as follows:\n@@ -927,1 +929,1 @@\n-     *     <li>if the buffer has been obtained by calling {@link #asByteBuffer()} on a memory segment whose session\n+     *     <li>if the buffer has been obtained by calling {@link #asByteBuffer()} on a memory segment whose scope\n@@ -929,3 +931,2 @@\n-     *     <li>if the buffer is a heap buffer, then {@code S} is the {@linkplain MemorySession#global() global session}; or\n-     *     <li>if the buffer is a direct buffer, then {@code S} is an\n-     *     {@linkplain MemorySession#implicit() implicit session} that keeps the buffer reachable.\n+     *     <li>if the buffer is a heap buffer, then {@code S} is the {@linkplain SegmentScope#global() global scope}; or\n+     *     <li>if the buffer is a direct buffer, then {@code S} is a scope that is always alive and which keeps the buffer reachable.\n@@ -949,1 +950,1 @@\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session, and\n+     * The returned segment is associated with the {@linkplain SegmentScope#global() global scope}, and\n@@ -961,1 +962,1 @@\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session, and\n+     * The returned segment is associated with the {@linkplain SegmentScope#global() global scope}, and\n@@ -973,1 +974,1 @@\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session, and\n+     * The returned segment is associated with the {@linkplain SegmentScope#global() global scope}, and\n@@ -985,1 +986,1 @@\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session, and\n+     * The returned segment is associated with the {@linkplain SegmentScope#global() global scope}, and\n@@ -997,1 +998,1 @@\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session, and\n+     * The returned segment is associated with the {@linkplain SegmentScope#global() global scope}, and\n@@ -1009,1 +1010,1 @@\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session, and\n+     * The returned segment is associated with the {@linkplain SegmentScope#global() global scope}, and\n@@ -1021,1 +1022,1 @@\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session, and\n+     * The returned segment is associated with the {@linkplain SegmentScope#global() global scope}, and\n@@ -1038,1 +1039,1 @@\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n+     * The returned segment is associated with the {@linkplain SegmentScope#global() global scope}.\n@@ -1053,1 +1054,1 @@\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n+     * The returned segment is associated with the {@linkplain SegmentScope#global() global scope}.\n@@ -1057,1 +1058,1 @@\n-     * ofAddress(address, byteSize, MemorySession.global());\n+     * ofAddress(address, byteSize, SegmentScope.global());\n@@ -1074,1 +1075,1 @@\n-        return MemorySegment.ofAddress(address, byteSize, MemorySession.global());\n+        return MemorySegment.ofAddress(address, byteSize, SegmentScope.global());\n@@ -1078,1 +1079,1 @@\n-     * Creates a native segment with the given size, address, and memory session.\n+     * Creates a native segment with the given size, address, and scope.\n@@ -1084,1 +1085,1 @@\n-     * provided memory session.\n+     * provided scope.\n@@ -1088,1 +1089,1 @@\n-     * ofAddress(address, byteSize, session, null);\n+     * ofAddress(address, byteSize, scope, null);\n@@ -1093,2 +1094,2 @@\n-     * @param session the native segment memory session.\n-     * @return a native segment with the given address, size and memory session.\n+     * @param scope the scope associated with the returned native segment.\n+     * @return a native segment with the given address, size and scope.\n@@ -1096,3 +1097,3 @@\n-     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread\n-     * {@linkplain MemorySession#isOwnedBy(Thread) owning} {@code session}.\n+     * @throws IllegalStateException if {@code scope} is not {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope.isAccessibleBy(T) == false}.\n@@ -1105,1 +1106,1 @@\n-    static MemorySegment ofAddress(long address, long byteSize, MemorySession session) {\n+    static MemorySegment ofAddress(long address, long byteSize, SegmentScope scope) {\n@@ -1107,1 +1108,1 @@\n-        Objects.requireNonNull(session);\n+        Objects.requireNonNull(scope);\n@@ -1109,1 +1110,1 @@\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address, byteSize, session, null);\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address, byteSize, scope, null);\n@@ -1113,1 +1114,1 @@\n-     * Creates a native segment with the given size, address, and memory session.\n+     * Creates a native segment with the given size, address, and scope.\n@@ -1119,1 +1120,1 @@\n-     * provided memory session.\n+     * provided scope.\n@@ -1121,1 +1122,1 @@\n-     * The provided cleanup action (if any) will be invoked <em>after<\/em> the provided session is closed.\n+     * The provided cleanup action (if any) will be invoked when the scope becomes not {@linkplain SegmentScope#isAlive() alive}.\n@@ -1135,1 +1136,1 @@\n-     * @param session the native segment memory session.\n+     * @param scope the scope associated with the returned native segment.\n@@ -1137,1 +1138,1 @@\n-     * @return a native segment with the given address, size and memory session.\n+     * @return a native segment with the given address, size and scope.\n@@ -1139,3 +1140,3 @@\n-     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread\n-     * {@linkplain MemorySession#isOwnedBy(Thread) owning} {@code session}.\n+     * @throws IllegalStateException if {@code scope} is not {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope.isAccessibleBy(T) == false}.\n@@ -1147,1 +1148,1 @@\n-    static MemorySegment ofAddress(long address, long byteSize, MemorySession session, Runnable cleanupAction) {\n+    static MemorySegment ofAddress(long address, long byteSize, SegmentScope scope, Runnable cleanupAction) {\n@@ -1149,1 +1150,1 @@\n-        Objects.requireNonNull(session);\n+        Objects.requireNonNull(scope);\n@@ -1151,1 +1152,1 @@\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address, byteSize, session, cleanupAction);\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address, byteSize, scope, cleanupAction);\n@@ -1155,1 +1156,1 @@\n-     * Creates a native segment with the given layout and memory session.\n+     * Creates a native segment with the given layout and scope.\n@@ -1157,4 +1158,7 @@\n-     * Clients are responsible for ensuring that the memory session associated with the returned segment is\n-     * closed when segments are no longer in use. Failure to do so will result in off-heap memory leaks. As an\n-     * alternative, an {@linkplain MemorySession#implicit() implicitly closed} session can be used, allowing\n-     * the returned segment to be automatically released some unspecified time after the session is no longer referenced.\n+     * The lifetime off-heap region of memory associated with the returned native segment is determined by the\n+     * provided scope. The off-heap memory region is deallocated when the scope becomes not\n+     * {@linkplain SegmentScope#isAlive() alive}. If the scope has been obtained using an {@link Arena},\n+     * clients are responsible for ensuring that the arena is closed when the returned segment is no longer in use\n+     * Failure to do so will result in off-heap memory leaks. As an alternative, an {@linkplain SegmentScope#auto() automatic scope}\n+     * can be used, allowing the off-heap memory region associated with the returned native segment to be\n+     * automatically released some unspecified time after the scope is no longer referenced.\n@@ -1168,1 +1172,1 @@\n-     * allocateNative(layout.bytesSize(), layout.bytesAlignment(), session);\n+     * allocateNative(layout.bytesSize(), layout.bytesAlignment(), scope);\n@@ -1174,1 +1178,1 @@\n-     * @param session the session to which the returned segment is associated.\n+     * @param scope the scope associated with the returned native segment.\n@@ -1176,3 +1180,3 @@\n-     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread\n-     * {@linkplain MemorySession#isOwnedBy(Thread) owning} {@code session}.\n+     * @throws IllegalStateException if {@code scope} is not {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope.isAccessibleBy(T) == false}.\n@@ -1180,1 +1184,1 @@\n-    static MemorySegment allocateNative(MemoryLayout layout, MemorySession session) {\n+    static MemorySegment allocateNative(MemoryLayout layout, SegmentScope scope) {\n@@ -1182,2 +1186,2 @@\n-        Objects.requireNonNull(session);\n-        return allocateNative(layout.byteSize(), layout.byteAlignment(), session);\n+        Objects.requireNonNull(scope);\n+        return allocateNative(layout.byteSize(), layout.byteAlignment(), scope);\n@@ -1187,1 +1191,1 @@\n-     * Creates a native segment with the given size (in bytes) and memory session.\n+     * Creates a native segment with the given size (in bytes) and scope.\n@@ -1189,4 +1193,7 @@\n-     * Clients are responsible for ensuring that the memory session associated with the returned segment is\n-     * closed when segments are no longer in use. Failure to do so will result in off-heap memory leaks. As an\n-     * alternative, an {@linkplain MemorySession#implicit() implicitly closed} session can be used, allowing\n-     * the returned segment to be automatically released some unspecified time after the session is no longer referenced.\n+     * The lifetime off-heap region of memory associated with the returned native segment is determined by the\n+     * provided scope. The off-heap memory region is deallocated when the scope becomes not\n+     * {@linkplain SegmentScope#isAlive() alive}. If the scope has been obtained using an {@link Arena},\n+     * clients are responsible for ensuring that the arena is closed when the returned segment is no longer in use\n+     * Failure to do so will result in off-heap memory leaks. As an alternative, an {@linkplain SegmentScope#auto() automatic scope}\n+     * can be used, allowing the off-heap memory region associated with the returned native segment to be\n+     * automatically released some unspecified time after the scope is no longer referenced.\n@@ -1200,1 +1207,1 @@\n-     * allocateNative(bytesSize, 1, session);\n+     * allocateNative(bytesSize, 1, scope);\n@@ -1206,1 +1213,1 @@\n-     * @param session the session to which the returned segment is associated.\n+     * @param scope the scope associated with the returned native segment.\n@@ -1209,3 +1216,3 @@\n-     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread\n-     * {@linkplain MemorySession#isOwnedBy(Thread) owning} {@code session}.\n+     * @throws IllegalStateException if {@code scope} is not {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope.isAccessibleBy(T) == false}.\n@@ -1213,2 +1220,2 @@\n-    static MemorySegment allocateNative(long byteSize, MemorySession session) {\n-        return allocateNative(byteSize, 1, session);\n+    static MemorySegment allocateNative(long byteSize, SegmentScope scope) {\n+        return allocateNative(byteSize, 1, scope);\n@@ -1218,1 +1225,1 @@\n-     * Creates a native segment with the given size (in bytes), alignment (in bytes) and session.\n+     * Creates a native segment with the given size (in bytes), alignment (in bytes) and scope.\n@@ -1220,4 +1227,7 @@\n-     * Clients are responsible for ensuring that the memory session associated with the returned segment is\n-     * closed when segments are no longer in use. Failure to do so will result in off-heap memory leaks. As an\n-     * alternative, an {@linkplain MemorySession#implicit() implicitly closed} session can be used, allowing\n-     * the returned segment to be automatically released some unspecified time after the session is no longer referenced.\n+     * The lifetime off-heap region of memory associated with the returned native segment is determined by the\n+     * provided scope. The off-heap memory region is deallocated when the scope becomes not\n+     * {@linkplain SegmentScope#isAlive() alive}. If the scope has been obtained using an {@link Arena},\n+     * clients are responsible for ensuring that the arena is closed when the returned segment is no longer in use\n+     * Failure to do so will result in off-heap memory leaks. As an alternative, an {@linkplain SegmentScope#auto() automatic scope}\n+     * can be used, allowing the off-heap memory region associated with the returned native segment to be\n+     * automatically released some unspecified time after the scope is no longer referenced.\n@@ -1233,1 +1243,1 @@\n-     * @param session the scope to which the returned segment is associated.\n+     * @param scope the scope associated with the returned native segment.\n@@ -1237,3 +1247,3 @@\n-     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread\n-     * {@linkplain MemorySession#isOwnedBy(Thread) owning} {@code session}.\n+     * @throws IllegalStateException if {@code scope} is not {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope.isAccessibleBy(T) == false}.\n@@ -1241,2 +1251,2 @@\n-    static MemorySegment allocateNative(long byteSize, long byteAlignment, MemorySession session) {\n-        Objects.requireNonNull(session);\n+    static MemorySegment allocateNative(long byteSize, long byteAlignment, SegmentScope scope) {\n+        Objects.requireNonNull(scope);\n@@ -1244,1 +1254,1 @@\n-        return NativeMemorySegmentImpl.makeNativeSegment(byteSize, byteAlignment, session);\n+        return NativeMemorySegmentImpl.makeNativeSegment(byteSize, byteAlignment, scope);\n@@ -1270,8 +1280,8 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code srcSegment} is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with {@code srcSegment}.\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code dstSegment} is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with {@code dstSegment}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with {@code srcSegment} is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code srcSegment.scope().isAccessibleBy(T) == false}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with {@code dstSegment} is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code dstSegment.scope().isAccessibleBy(T) == false}.\n@@ -1317,8 +1327,8 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code srcSegment} is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this {@code srcSegment}.\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code dstSegment} is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with {@code dstSegment}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with {@code srcSegment} is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code srcSegment().scope().isAccessibleBy(T) == false}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with {@code dstSegment} is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code dstSegment().scope().isAccessibleBy(T) == false}.\n@@ -1370,4 +1380,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1390,4 +1400,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1411,4 +1421,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1431,4 +1441,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1452,4 +1462,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1472,4 +1482,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1493,4 +1503,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1513,4 +1523,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1534,4 +1544,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1554,4 +1564,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1575,4 +1585,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1595,4 +1605,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1616,4 +1626,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1636,4 +1646,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1657,4 +1667,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1677,4 +1687,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1694,1 +1704,1 @@\n-     * a native segment, associated with the {@linkplain MemorySession#global() global} memory session. Under normal conditions,\n+     * a native segment, associated with the {@linkplain SegmentScope#global() global scope}. Under normal conditions,\n@@ -1701,4 +1711,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1721,4 +1731,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1743,4 +1753,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1767,4 +1777,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1792,4 +1802,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1816,4 +1826,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1841,4 +1851,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1865,4 +1875,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1890,4 +1900,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1914,4 +1924,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1939,4 +1949,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1963,4 +1973,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -1988,4 +1998,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -2012,4 +2022,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -2032,1 +2042,1 @@\n-     * a native segment, associated with the {@linkplain MemorySession#global() global} memory session. Under normal conditions,\n+     * a native segment, associated with the {@linkplain SegmentScope#global() global scope}. Under normal conditions,\n@@ -2041,4 +2051,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -2065,4 +2075,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope().isAccessibleBy(T) == false}.\n@@ -2126,4 +2136,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code srcSegment} is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with {@code srcSegment}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with {@code srcSegment} is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code srcSegment().isAccessibleBy(T) == false}.\n@@ -2160,4 +2170,4 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code dstSegment} is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with {@code dstSegment}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with {@code dstSegment} is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code dstSegment().isAccessibleBy(T) == false}.\n@@ -2202,8 +2212,8 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code srcSegment} is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with {@code srcSegment}.\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code dstSegment} is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with {@code dstSegment}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with {@code srcSegment} is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code srcSegment.scope().isAccessibleBy(T) == false}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with {@code dstSegment} is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code dstSegment.scope().isAccessibleBy(T) == false}.\n@@ -2223,0 +2233,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":367,"deletions":356,"binary":false,"changes":723,"status":"modified"},{"patch":"@@ -1,136 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.foreign;\n-\n-import jdk.internal.foreign.MemorySessionImpl;\n-import jdk.internal.javac.PreviewFeature;\n-import jdk.internal.ref.CleanerFactory;\n-\n-\/**\n- * A memory session manages the lifecycle of memory segments.\n- * <p>\n- * Segments associated with a memory session can only be accessed while the session is {@linkplain #isAlive() alive},\n- * and by the {@linkplain #isOwnedBy(Thread) thread} associated with the session (if any).\n- * <p>\n- * Memory sessions can be closed, either explicitly (i.e. using an {@linkplain Arena arena}) or implicitly, by the garbage\n- * collector. When a memory session is closed, it is no longer {@linkplain #isAlive() alive}, and subsequent operations\n- * on the segments associated with that session (e.g. {@link MemorySegment#get(ValueLayout.OfInt, long)})\n- * will fail with {@link IllegalStateException}.\n- *\n- * <h2 id = \"thread-confinement\">Safety and thread-confinement<\/h2>\n- *\n- * Memory sessions provide strong temporal safety guarantees: a memory segment associated with a session cannot be accessed\n- * <em>after<\/em> the session has been closed. The costs associated with maintaining this safety invariant can vary greatly,\n- * depending on how many threads have access to the memory segment associated to a memory session. For instance,\n- * if a memory session is created and closed by one thread, and the segments associated with it are only ever accessed by that very same\n- * thread, it is easy to show that there cannot be situations where a memory segment is accessed <em>while<\/em> its\n- * associated session is being closed.\n- * <p>\n- * Conversely, if a session is associated with segments that can be accessed by multiple threads, or if the session can be\n- * closed by a thread other than the accessing thread, the situation is much more complex. For instance, it would\n- * be possible for a segment to be accessed while its associated session is being closed, concurrently,\n- * by another thread. Even in this case, memory sessions provide strong temporal safety guarantees, but doing\n- * so can incur in a higher performance impact: when closing a memory session the Java runtime has to determine\n- * that no segment associated with that session is being accessed.\n- * <p>\n- * For this reason, memory sessions can be divided into two categories: <em>thread-confined<\/em> memory sessions, and <em>shared<\/em>\n- * memory sessions.\n- * <p>\n- * Confined memory sessions, support strong thread-confinement guarantees. Upon creation,\n- * they are assigned an {@linkplain #isOwnedBy(Thread) owner thread}, typically the thread which initiated the creation operation.\n- * After creating a confined memory session, only the owner thread will be allowed to directly manipulate the resources\n- * associated with this memory session. Any attempt to perform resource access from a thread other than the\n- * owner thread will fail with {@link WrongThreadException}.\n- * <p>\n- * Shared memory sessions, on the other hand, have no owner thread; as such, resources associated with shared memory sessions\n- * can be accessed by multiple threads. This might be useful when multiple threads need to access the same resource concurrently\n- * (e.g. in the case of parallel processing).\n- *\n- * <h2 id=\"implicit\">Implicitly closed sessions<\/h2>\n- *\n- * Memory sessions that can be closed explicitly, while powerful, must be used with caution. These sessions must be closed\n- * when no longer in use (via their associated arenas), by calling the {@link Arena#close} method. A failure to do so\n- * might result in memory leaks. To mitigate this problem, clients can use {@linkplain #implicit() sessions} that\n- * are closed implicitly, by the garbage collector. These sessions are closed at some unspecified time <em>after<\/em>\n- * they become <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>, as shown below:\n- *\n- * {@snippet lang = java:\n- * MemorySegment segment = MemorySegment.allocateNative(100, MemorySession.implicit());\n- * ...\n- * segment = null; \/\/ the segment session is unreacheable here and becomes available for implicit close\n- *}\n- *\n- * Sessions closed implicitly can be useful to manage long-lived segments, where timely deallocation is not critical,\n- * or in unstructured cases where it is not easy to determine <em>when<\/em> a session should be closed.\n- *\n- * @implSpec\n- * Implementations of this interface are thread-safe.\n- *\n- * @see Arena\n- * @see MemorySegment\n- * @see SymbolLookup\n- * @see Linker\n- * @see VaList\n- *\n- * @since 19\n- *\/\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n-public sealed interface MemorySession permits MemorySessionImpl {\n-\n-    \/**\n-     * {@return {@code true}, if this memory session is alive}\n-     *\/\n-    boolean isAlive();\n-\n-    \/**\n-     * {@return test if the provided thread is the owner thread associated with this memory session}\n-     * @param thread the thread to be compared against this session's owner thread.\n-     *\/\n-    boolean isOwnedBy(Thread thread);\n-\n-    \/**\n-     * Runs a critical action while this memory session is kept alive.\n-     * @param action the action to be run.\n-     *\/\n-    void whileAlive(Runnable action);\n-\n-    \/**\n-     * Creates a new memory session that is closed, implicitly, by the garbage collector.\n-     * The returned session can be shared across threads.\n-     *\n-     * @return a new memory session that is closed, implicitly, by the garbage collector.\n-     *\/\n-    static MemorySession implicit() {\n-        return MemorySessionImpl.createImplicit(CleanerFactory.cleaner());\n-    }\n-\n-    \/**\n-     * {@return the global memory session}\n-     *\/\n-    static MemorySession global() {\n-        return MemorySessionImpl.GLOBAL;\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySession.java","additions":0,"deletions":136,"binary":false,"changes":136,"status":"deleted"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.javac.PreviewFeature;\n@@ -36,0 +37,2 @@\n+ *\n+ * @since 20\n@@ -37,0 +40,1 @@\n+@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/PaddingLayout.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n- *     <li>{@link #nativeAllocator(MemorySession)} obtains a simple allocator which can\n+ *     <li>{@link #nativeAllocator(SegmentScope)} obtains a simple allocator which can\n@@ -392,2 +392,3 @@\n-     * Each native segment obtained by the returned allocator is associated with the provided session. As such, the\n-     * off-heap region which backs the returned segment is freed when the session is closed.\n+     * Each native segment obtained by the returned allocator is associated with the provided scope. As such,\n+     * the off-heap region which backs the returned segment is freed when the scope becomes not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -404,1 +405,1 @@\n-     *     MemorySegment.allocateNative(byteSize, byteAlignment, session);\n+     *     MemorySegment.allocateNative(byteSize, byteAlignment, scope);\n@@ -406,1 +407,1 @@\n-     * @param session the memory session associated with the segments returned by the native allocator.\n+     * @param scope the scope associated with the segments returned by the native allocator.\n@@ -409,3 +410,3 @@\n-    static SegmentAllocator nativeAllocator(MemorySession session) {\n-        Objects.requireNonNull(session);\n-        return (MemorySessionImpl)session;\n+    static SegmentAllocator nativeAllocator(SegmentScope scope) {\n+        Objects.requireNonNull(scope);\n+        return (MemorySessionImpl)scope;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package java.lang.foreign;\n+\n+import jdk.internal.foreign.MemorySessionImpl;\n+import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.ref.CleanerFactory;\n+\n+\/**\n+ * A segment scope controls access to memory segments.\n+ * <p>\n+ * A memory segment can only be accessed while its scope is {@linkplain #isAlive() alive}. Moreover,\n+ * depending on how the segment scope has been obtained, access might additionally be\n+ * <a href=\"Arena.html#thread-confinement\">restricted to specific threads<\/a>.\n+ * <p>\n+ * The simplest segment scope is the {@linkplain SegmentScope#global() global scope}. The global scope\n+ * is always alive. As a result, segments associated with the global scope are always accessible and their backing\n+ * regions of memory are never deallocated. Moreover, memory segments associated with the global scope\n+ * can be {@linkplain #isAccessibleBy(Thread) accessed} from any thread.\n+ * {@snippet lang = java:\n+ * MemorySegment segment = MemorySegment.allocateNative(100, SegmentScope.global());\n+ * ...\n+ * \/\/ segment is never deallocated!\n+ *}\n+ * <p>\n+ * Alternatively, clients can obtain an {@linkplain SegmentScope#auto() automatic scope}, that is a segment\n+ * scope that is managed, automatically, by the garbage collector. The regions of memory backing memory segments associated\n+ * with an automatic scope are deallocated at some unspecified time <em>after<\/em> they become\n+ * <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>, as shown below:\n+ *\n+ * {@snippet lang = java:\n+ * MemorySegment segment = MemorySegment.allocateNative(100, SegmentScope.auto());\n+ * ...\n+ * segment = null; \/\/ the segment region becomes available for deallocation after this point\n+ *}\n+ * Memory segments associated with an automatic scope can also be {@linkplain #isAccessibleBy(Thread) accessed} from any thread.\n+ * <p>\n+ * Finally, clients can obtain a segment scope from an existing {@linkplain Arena arena}, the arena scope. The regions of memory\n+ * backing memory segments associated with an arena scope are deallocated when the arena is {@linkplain Arena#close() closed}.\n+ * When this happens, the arena scope becomes not {@linkplain #isAlive() alive} and subsequent access operations on segments\n+ * associated with the arena scope will fail {@link IllegalStateException}.\n+ *\n+ * {@snippet lang = java:\n+ * MemorySegment segment = null;\n+ * try (Arena arena = Arena.openConfined()) {\n+ *     segment = MemorySegment.allocateNative(100, arena.scope());\n+ *     ...\n+ * } \/\/ segment region deallocated here\n+ * segment.get(ValueLayout.JAVA_BYTE, 0); \/\/ throws IllegalStateException\n+ * }\n+ *\n+ * Which threads can {@link #isAccessibleBy(Thread) access} memory segments associated with an arena scope depends\n+ * on the arena kind. For instance, segments associated with the scope of a {@linkplain Arena#openConfined() confined arena}\n+ * can only be accessed by the thread that created the arena. Conversely, segments associated with the scope of\n+ * {@linkplain Arena#openConfined() shared arena} can be accessed by any thread.\n+ *\n+ * @implSpec\n+ * Implementations of this interface are thread-safe.\n+ *\n+ * @see Arena\n+ * @see MemorySegment\n+ *\n+ * @since 20\n+ *\/\n+@PreviewFeature(feature =PreviewFeature.Feature.FOREIGN)\n+sealed public interface SegmentScope permits MemorySessionImpl {\n+\n+    \/**\n+     * Creates a new scope that is managed, automatically, by the garbage collector.\n+     * Segments associated with the returned scope can be\n+     * {@linkplain SegmentScope#isAccessibleBy(Thread) accessed} by any thread.\n+     *\n+     * @return a new scope that is managed, automatically, by the garbage collector.\n+     *\/\n+    static SegmentScope auto() {\n+        return MemorySessionImpl.createImplicit(CleanerFactory.cleaner());\n+    }\n+\n+    \/**\n+     * Obtains the global scope. Segments associated with the global scope can be\n+     * {@linkplain SegmentScope#isAccessibleBy(Thread) accessed} by any thread.\n+     *\n+     * @return the global scope.\n+     *\/\n+    static SegmentScope global() {\n+        return MemorySessionImpl.GLOBAL;\n+    }\n+\n+    \/**\n+     * {@return {@code true}, if this scope is alive}\n+     *\/\n+    boolean isAlive();\n+\n+    \/**\n+     * {@return {@code true} if the provided thread can access and\/or associate segments with this scope}\n+     * @param thread the thread to be tested.\n+     *\/\n+    boolean isAccessibleBy(Thread thread);\n+\n+    \/**\n+     * Runs a critical action while this scope is kept alive.\n+     * @param action the action to be run.\n+     * @throws IllegalStateException if this scope is not {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code isAccessibleBy(T) == false}.\n+     *\/\n+    void whileAlive(Runnable action);\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentScope.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -32,1 +32,1 @@\n- * A <em>struct<\/em> layout where member layouts are laid out one after the other (see {@link MemoryLayout#structLayout(MemoryLayout...)}).\n+ * A group layout whose member layouts are laid out one after the other.\n@@ -37,1 +37,1 @@\n- * @since 19\n+ * @since 20\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/StructLayout.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- * A <em>symbol lookup<\/em> is an object that may be used to retrieve the address of a symbol in one or more libraries.\n+ * A <em>symbol lookup<\/em> retrieves the address of a symbol in one or more libraries.\n@@ -57,1 +57,1 @@\n- *     {@link MemorySegment#ofAddress(long, long, MemorySession) resizing} the segment first).<\/li>\n+ *     {@link MemorySegment#ofAddress(long, long, SegmentScope) resizing} the segment first).<\/li>\n@@ -62,1 +62,1 @@\n- * The factory methods {@link #libraryLookup(String, MemorySession)} and {@link #libraryLookup(Path, MemorySession)}\n+ * The factory methods {@link #libraryLookup(String, SegmentScope)} and {@link #libraryLookup(Path, SegmentScope)}\n@@ -65,1 +65,1 @@\n- * with a {@linkplain  MemorySession memory session}; when the session is closed, the library is unloaded:\n+ * with a {@linkplain  SegmentScope scope}; when the scope becomes not {@link SegmentScope#isAlive()}, the library is unloaded:\n@@ -69,1 +69,1 @@\n- *     SymbolLookup libGL = SymbolLookup.libraryLookup(\"libGL.so\", arena.session()); \/\/ libGL.so loaded here\n+ *     SymbolLookup libGL = SymbolLookup.libraryLookup(\"libGL.so\", arena.scope()); \/\/ libGL.so loaded here\n@@ -95,1 +95,1 @@\n- * libraryLookup(\"libGL.so\", session).find(\"glGetString\").isPresent(); \/\/ true\n+ * libraryLookup(\"libGL.so\", scope).find(\"glGetString\").isPresent(); \/\/ true\n@@ -104,1 +104,1 @@\n- * libraryLookup(\"libGL.so\", session).find(\"glGetString\").isPresent(); \/\/ true\n+ * libraryLookup(\"libGL.so\", scope).find(\"glGetString\").isPresent(); \/\/ true\n@@ -142,1 +142,1 @@\n-     * returned by this method is backed by a shared memory session that is always alive and which keeps the caller's\n+     * returned by this method is backed by a scope that is always alive and which keeps the caller's\n@@ -161,2 +161,2 @@\n-        MemorySession loaderSession = (loader == null || loader instanceof BuiltinClassLoader) ?\n-                MemorySession.global() : \/\/ builtin loaders never go away\n+        SegmentScope loaderScope = (loader == null || loader instanceof BuiltinClassLoader) ?\n+                SegmentScope.global() : \/\/ builtin loaders never go away\n@@ -171,1 +171,1 @@\n-                    Optional.of(MemorySegment.ofAddress(addr, 0L, loaderSession));\n+                    Optional.of(MemorySegment.ofAddress(addr, 0L, loaderScope));\n@@ -177,1 +177,2 @@\n-     * The library will be unloaded when the provided memory session is closed, if no other library lookup is still using it.\n+     * The library will be unloaded when the provided scope becomes\n+     * not {@linkplain SegmentScope#isAlive() alive}, if no other library lookup is still using it.\n@@ -188,1 +189,1 @@\n-     * @param session the memory session which controls the library lifecycle.\n+     * @param scope the scope associated with symbols obtained from the returned lookup.\n@@ -196,1 +197,1 @@\n-    static SymbolLookup libraryLookup(String name, MemorySession session) {\n+    static SymbolLookup libraryLookup(String name, SegmentScope scope) {\n@@ -198,1 +199,1 @@\n-        return libraryLookup(name, RawNativeLibraries::load, session);\n+        return libraryLookup(name, RawNativeLibraries::load, scope);\n@@ -203,2 +204,2 @@\n-     * in that library. The library will be unloaded when the provided memory session is closed,\n-     * if no other library lookup is still using it.\n+     * in that library. The library will be unloaded when the provided scope becomes\n+     * not {@linkplain SegmentScope#isAlive() alive}, if no other library lookup is still using it.\n@@ -214,1 +215,1 @@\n-     * @param session the memory session which controls the library lifecycle.\n+     * @param scope the scope associated with symbols obtained from the returned lookup.\n@@ -222,1 +223,1 @@\n-    static SymbolLookup libraryLookup(Path path, MemorySession session) {\n+    static SymbolLookup libraryLookup(Path path, SegmentScope scope) {\n@@ -224,1 +225,1 @@\n-        return libraryLookup(path, RawNativeLibraries::load, session);\n+        return libraryLookup(path, RawNativeLibraries::load, scope);\n@@ -227,1 +228,1 @@\n-    private static <Z> SymbolLookup libraryLookup(Z libDesc, BiFunction<RawNativeLibraries, Z, NativeLibrary> loadLibraryFunc, MemorySession session) {\n+    private static <Z> SymbolLookup libraryLookup(Z libDesc, BiFunction<RawNativeLibraries, Z, NativeLibrary> loadLibraryFunc, SegmentScope libScope) {\n@@ -229,1 +230,1 @@\n-        Objects.requireNonNull(session);\n+        Objects.requireNonNull(libScope);\n@@ -236,2 +237,2 @@\n-        \/\/ register hook to unload library when session is closed\n-        MemorySessionImpl.toSessionImpl(session).addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n+        \/\/ register hook to unload library when 'libScope' becomes not alive\n+        ((MemorySessionImpl) libScope).addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n@@ -248,1 +249,1 @@\n-                    Optional.of(MemorySegment.ofAddress(addr, 0, session));\n+                    Optional.of(MemorySegment.ofAddress(addr, 0, libScope));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":26,"deletions":25,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * A <em>union<\/em> layout where member layouts are laid out at the same starting offset (see {@link MemoryLayout#unionLayout(MemoryLayout...)}).\n+ * A group layout whose member layouts are laid out at the same starting offset.\n@@ -37,1 +37,1 @@\n- * @since 19\n+ * @since 20\n@@ -42,0 +42,3 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n@@ -45,0 +48,3 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/UnionLayout.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n- * A variable argument list segment can be created using the {@link #make(Consumer, MemorySession)} factory, as follows:\n+ * A variable argument list can be created using the {@link #make(Consumer, SegmentScope)} factory, as follows:\n@@ -50,1 +50,1 @@\n- * Once created, clients can obtain the platform-dependent {@linkplain #segment() memory segment} associated a variable\n+ * Once created, clients can obtain the platform-dependent {@linkplain #segment() memory segment} associated with a variable\n@@ -59,1 +59,1 @@\n- *        VaList vaList = VaList.ofAddress(vaListSegment.address(), arena.session());\n+ *        VaList vaList = VaList.ofAddress(vaListSegment.address(), arena.scope());\n@@ -85,0 +85,7 @@\n+ * Accessing a value through a variable argument list using the wrong memory layout will result in undefined behavior.\n+ * For instance, if a variable argument list currently points at a C {@code int} value, then accessing it using\n+ * {@link #nextVarg(ValueLayout.OfLong)} is illegal. Similarly, accessing the variable argument list with\n+ * {@link #skip(MemoryLayout...)}, and providing a layout other than {@link ValueLayout.OfInt} is illegal.\n+ * Any such illegal accesses might not be detected by the implementation, and can corrupt the variable argument list,\n+ * so that the behavior of subsequent accesses is also undefined.\n+ * <p>\n@@ -90,2 +97,2 @@\n- *     <li>Variable argument lists created <em>safely<\/em>, using {@link #make(Consumer, MemorySession)} are capable of detecting out-of-bounds reads;<\/li>\n- *     <li>Variable argument lists created <em>unsafely<\/em>, using {@link #ofAddress(long, MemorySession)} are not capable of detecting out-of-bounds reads<\/li>\n+ *     <li>Variable argument lists created <em>safely<\/em>, using {@link #make(Consumer, SegmentScope)} are capable of detecting out-of-bounds reads;<\/li>\n+ *     <li>Variable argument lists created <em>unsafely<\/em>, using {@link #ofAddress(long, SegmentScope)} are not capable of detecting out-of-bounds reads<\/li>\n@@ -95,1 +102,1 @@\n- * (regardless of the session associated with the variable arity list).\n+ * (regardless of the scope used to obtain the variable arity list).\n@@ -108,4 +115,4 @@\n-     * @throws IllegalStateException if the session associated with this variable argument list is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the session associated with this variable argument list.\n+     * @throws IllegalStateException if the scope associated with this variable argument list is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code segment().scope().isAccessibleBy(T) == false}.\n@@ -122,4 +129,4 @@\n-     * @throws IllegalStateException if the session associated with this variable argument list is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the session associated with this variable argument list.\n+     * @throws IllegalStateException if the scope associated with this variable argument list is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code segment().scope().isAccessibleBy(T) == false}.\n@@ -136,4 +143,4 @@\n-     * @throws IllegalStateException if the session associated with this variable argument list is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the session associated with this variable argument list.\n+     * @throws IllegalStateException if the scope associated with this variable argument list is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code segment().scope().isAccessibleBy(T) == false}.\n@@ -148,1 +155,1 @@\n-     * is associated with the {@linkplain MemorySession#global() global} memory session. Under normal conditions, the size of the returned\n+     * is associated with the {@linkplain SegmentScope#global() global scope}. Under normal conditions, the size of the returned\n@@ -155,4 +162,4 @@\n-     * @throws IllegalStateException if the session associated with this variable argument list is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the session associated with this variable argument list.\n+     * @throws IllegalStateException if the scope associated with this variable argument list is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code segment().scope().isAccessibleBy(T) == false}.\n@@ -178,4 +185,4 @@\n-     * @throws IllegalStateException if the session associated with this variable argument list is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the session associated with this variable argument list.\n+     * @throws IllegalStateException if the scope associated with this variable argument list is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code segment().scope().isAccessibleBy(T) == false}.\n@@ -190,4 +197,4 @@\n-     * @throws IllegalStateException if the session associated with this variable argument list is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the session associated with this variable argument list.\n+     * @throws IllegalStateException if the scope associated with this variable argument list is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code segment().scope().isAccessibleBy(T) == false}.\n@@ -200,1 +207,1 @@\n-     * with the same memory session as this variable argument list. The behavior of this method is equivalent to the C\n+     * with the same scope as this variable argument list. The behavior of this method is equivalent to the C\n@@ -208,4 +215,4 @@\n-     * @throws IllegalStateException if the session associated with this variable argument list is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the session associated with this variable argument list.\n+     * @throws IllegalStateException if the scope associated with this variable argument list is not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code segment().scope().isAccessibleBy(T) == false}.\n@@ -219,2 +226,1 @@\n-     * platform-dependent. The returned segment's memory session is the session which manages the lifecycle of this\n-     * variable argument list.\n+     * platform-dependent.\n@@ -226,4 +232,5 @@\n-     * Creates a variable argument list from the give address value and memory session. The address is typically obtained\n-     * by calling {@link MemorySegment#address()} on a foreign memory segment instance. The provided session determines\n-     * the lifecycle of the returned variable argument list: when the session is closed,\n-     * the returned variable argument list will no longer be accessible.\n+     * Creates a variable argument list from the give address value and scope. The address is typically obtained\n+     * by calling {@link MemorySegment#address()} on a foreign memory segment instance. The provided scope determines\n+     * the lifecycle of the returned variable argument list: the returned variable argument list will no longer be accessible,\n+     * and its associated off-heap memory region will be deallocated when the scope becomes not\n+     * {@linkplain SegmentScope#isAlive() alive}.\n@@ -237,1 +244,1 @@\n-     * @param session the memory session to be associated with the returned variable argument list.\n+     * @param scope the scope associated with the returned variable argument list.\n@@ -239,3 +246,3 @@\n-     * @throws IllegalStateException         if {@code session} is not {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException          if this method is called from a thread other than the thread\n-     *                                       {@linkplain MemorySession#isOwnedBy(Thread) owning} {@code session}.\n+     * @throws IllegalStateException         if {@code scope} is not {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException          if this method is called from a thread {@code T},\n+     *                                       such that {@code scope.isAccessibleBy(T) == false}.\n@@ -248,1 +255,1 @@\n-    static VaList ofAddress(long address, MemorySession session) {\n+    static VaList ofAddress(long address, SegmentScope scope) {\n@@ -250,2 +257,2 @@\n-        Objects.requireNonNull(session);\n-        return SharedUtils.newVaListOfAddress(address, session);\n+        Objects.requireNonNull(scope);\n+        return SharedUtils.newVaListOfAddress(address, scope);\n@@ -256,4 +263,3 @@\n-     * memory session.\n-     * <p>\n-     * If this method needs to allocate memory, such memory will be managed by the given\n-     * session, and will be released when the session is closed.\n+     * scope. The provided scope determines the lifecycle of the returned variable argument list: the\n+     * returned variable argument list will no longer be accessible, and its associated off-heap memory region will be\n+     * deallocated when the scope becomes not {@linkplain SegmentScope#isAlive() alive}.\n@@ -268,1 +274,1 @@\n-     * @param session the memory session to be associated with the new variable arity list.\n+     * @param scope the scope to be associated with the new variable arity list.\n@@ -271,3 +277,3 @@\n-     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread\n-     * {@linkplain MemorySession#isOwnedBy(Thread) owning} {@code session}.\n+     * @throws IllegalStateException if {@code scope} is not {@linkplain SegmentScope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code scope.isAccessibleBy(T) == false}.\n@@ -275,1 +281,1 @@\n-    static VaList make(Consumer<Builder> actions, MemorySession session) {\n+    static VaList make(Consumer<Builder> actions, SegmentScope scope) {\n@@ -277,2 +283,2 @@\n-        Objects.requireNonNull(session);\n-        return SharedUtils.newVaList(actions, session);\n+        Objects.requireNonNull(scope);\n+        return SharedUtils.newVaList(actions, scope);\n@@ -282,2 +288,2 @@\n-     * Returns an empty variable argument list, associated with the {@linkplain MemorySession#global() global}\n-     * memory session. The resulting variable argument list does not contain any argument, and throws {@link UnsupportedOperationException}\n+     * Returns an empty variable argument list, associated with the {@linkplain SegmentScope#global() global scope}.\n+     * The resulting variable argument list does not contain any argument, and throws {@link UnsupportedOperationException}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/VaList.java","additions":68,"deletions":62,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -37,2 +37,5 @@\n- * A value layout. A value layout is used to model the memory layout associated with values of basic data types, such as <em>integral<\/em> types\n- * (either signed or unsigned) and <em>floating-point<\/em> types. Each value layout has a size, an alignment (in bits),\n+ * A layout that models values of basic data types. Examples of values modelled by a value layout are\n+ * <em>integral<\/em> values (either signed or unsigned), <em>floating-point<\/em> values and\n+ * <em>address<\/em> values.\n+ * <p>\n+ * Each value layout has a size, an alignment (in bits),\n@@ -69,1 +72,1 @@\n-     * Creates a <em>strided<\/em> access var handle that can be used to access a memory segment as multi-dimensional\n+     * Creates a <em>strided<\/em> var handle that can be used to access a memory segment as multi-dimensional\n@@ -133,0 +136,3 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n@@ -136,0 +142,3 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n@@ -142,2 +151,0 @@\n-     * <p>\n-     * New instances of this type can be created using {@link #JAVA_BOOLEAN}.\n@@ -145,0 +152,1 @@\n+     * @see #JAVA_BOOLEAN\n@@ -150,0 +158,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -153,0 +164,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -156,0 +170,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -163,2 +180,0 @@\n-     * <p>\n-     * New instances of this type can be created using {@link #JAVA_BYTE}.\n@@ -166,0 +181,1 @@\n+     * @see #JAVA_BYTE\n@@ -171,0 +187,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -174,0 +193,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -177,0 +199,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -184,2 +209,0 @@\n-     * <p>\n-     * New instances of this type can be created using {@link #JAVA_CHAR}.\n@@ -187,0 +210,2 @@\n+     * @see #JAVA_CHAR\n+     * @see #JAVA_CHAR_UNALIGNED\n@@ -192,0 +217,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -195,0 +223,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -198,0 +229,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -205,2 +239,0 @@\n-     * <p>\n-     * New instances of this type can be created using {@link #JAVA_SHORT}.\n@@ -208,0 +240,2 @@\n+     * @see #JAVA_SHORT\n+     * @see #JAVA_SHORT_UNALIGNED\n@@ -213,0 +247,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -216,0 +253,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -219,0 +259,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -226,2 +269,0 @@\n-     * <p>\n-     * New instances of this type can be created using {@link #JAVA_INT}.\n@@ -229,0 +270,2 @@\n+     * @see #JAVA_INT\n+     * @see #JAVA_INT_UNALIGNED\n@@ -234,0 +277,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -237,0 +283,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -240,0 +289,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -247,2 +299,0 @@\n-     * <p>\n-     * New instances of this type can be created using {@link #JAVA_FLOAT}.\n@@ -250,0 +300,2 @@\n+     * @see #JAVA_FLOAT\n+     * @see #JAVA_FLOAT_UNALIGNED\n@@ -255,0 +307,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -258,0 +313,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -261,0 +319,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -268,2 +329,0 @@\n-     * <p>\n-     * New instances of this type can be created using {@link #JAVA_LONG}.\n@@ -271,0 +330,2 @@\n+     * @see #JAVA_LONG\n+     * @see #JAVA_LONG_UNALIGNED\n@@ -276,0 +337,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -279,0 +343,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -282,0 +349,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -289,2 +359,0 @@\n-     * <p>\n-     * New instances of this type can be created using {@link #JAVA_LONG}.\n@@ -292,0 +360,2 @@\n+     * @see #JAVA_DOUBLE\n+     * @see #JAVA_DOUBLE_UNALIGNED\n@@ -297,0 +367,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -300,0 +373,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -303,0 +379,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -310,2 +389,0 @@\n-     * <p>\n-     * New instances of this type can be created using {@link #ADDRESS}.\n@@ -313,0 +390,2 @@\n+     * @see #ADDRESS\n+     * @see #ADDRESS_UNALIGNED\n@@ -318,0 +397,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -321,0 +403,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -324,0 +409,3 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n@@ -329,1 +417,1 @@\n-         * but with the specified pointee layout. An unbounded address layouts allow raw addresses to be accessed\n+         * but with the specified pointee layout. An unbounded address layout allow raw addresses to be accessed\n@@ -356,2 +444,1 @@\n-     * ADDRESS.of(ByteOrder.nativeOrder())\n-     *             .withBitAlignment(<address size>);\n+     * MemoryLayout.valueLayout(MemorySegment.class, ByteOrder.nativeOrder());\n@@ -367,1 +454,1 @@\n-     * JAVA_BYTE.of(ByteOrder.nativeOrder()).withBitAlignment(8);\n+     * MemoryLayout.valueLayout(byte.class, ByteOrder.nativeOrder());\n@@ -377,1 +464,1 @@\n-     * JAVA_BOOLEAN.of(ByteOrder.nativeOrder()).withBitAlignment(8);\n+     * MemoryLayout.valueLayout(boolean.class, ByteOrder.nativeOrder());\n@@ -387,1 +474,1 @@\n-     * JAVA_CHAR.of(ByteOrder.nativeOrder()).withBitAlignment(16);\n+     * MemoryLayout.valueLayout(char.class, ByteOrder.nativeOrder());\n@@ -397,1 +484,1 @@\n-     * JAVA_SHORT.of(ByteOrder.nativeOrder()).withBitAlignment(16);\n+     * MemoryLayout.valueLayout(short.class, ByteOrder.nativeOrder());\n@@ -407,1 +494,1 @@\n-     * JAVA_INT.of(ByteOrder.nativeOrder()).withBitAlignment(32);\n+     * MemoryLayout.valueLayout(int.class, ByteOrder.nativeOrder());\n@@ -417,1 +504,1 @@\n-     * JAVA_LONG.of(ByteOrder.nativeOrder()).withBitAlignment(64);\n+     * MemoryLayout.valueLayout(long.class, ByteOrder.nativeOrder());\n@@ -427,1 +514,1 @@\n-     * JAVA_FLOAT.of(ByteOrder.nativeOrder()).withBitAlignment(32);\n+     * MemoryLayout.valueLayout(float.class, ByteOrder.nativeOrder()).withBitAlignment(32);\n@@ -437,1 +524,1 @@\n-     * JAVA_DOUBLE.of(ByteOrder.nativeOrder()).withBitAlignment(64);\n+     * MemoryLayout.valueLayout(double.class, ByteOrder.nativeOrder());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":119,"deletions":32,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * using {@linkplain java.lang.foreign.MemoryLayout#varHandle(java.lang.foreign.MemoryLayout.PathElement...) access var handles},\n+ * using {@linkplain java.lang.foreign.MemoryLayout#varHandle(java.lang.foreign.MemoryLayout.PathElement...) var handles},\n@@ -45,1 +45,1 @@\n- * MemorySegment segment = MemorySegment.allocateNative(10 * 4, MemorySession.implicit());\n+ * MemorySegment segment = MemorySegment.allocateNative(10 * 4, SegmentScope.auto());\n@@ -53,2 +53,3 @@\n- * The segment is associated with a memory session that is {@linkplain java.lang.foreign.MemorySession#implicit() implicitly} closed,\n- * by the garbage collector. As such, the off-heap memory backing the native segment will be released at some unspecified\n+ * The segment is associated with an {@linkplain java.lang.foreign.SegmentScope#auto() automatic scope}. This\n+ * means that the off-heap region of memory backing the segment is managed, automatically, by the garbage collector.\n+ * As such, the off-heap memory backing the native segment will be released at some unspecified\n@@ -87,1 +88,1 @@\n- * allocated by the arena will be associated with the same {@linkplain java.lang.foreign.MemorySession memory session}.\n+ * allocated by the arena will be associated with the same {@linkplain java.lang.foreign.SegmentScope scope}.\n@@ -100,2 +101,2 @@\n- * Since memory segments can be closed (see above), segments are also validated (upon access) to make sure that\n- * the memory session associated with the segment being accessed has not been closed prematurely.\n+ * Since memory segments created with an arena can become invalid (see above), segments are also validated (upon access) to make sure that\n+ * the scope associated with the segment being accessed is still alive.\n@@ -103,1 +104,1 @@\n- * operation either succeeds - and accesses a valid location of the region of memory backing the memory segment - or fails.\n+ * operation either succeeds - and accesses a valid location within the region of memory backing the memory segment - or fails.\n@@ -169,1 +170,1 @@\n- *                                                 Linker.upcallType(comparFunction));\n+ *                                                 intCompareDescriptor.toMethodType());\n@@ -181,1 +182,1 @@\n- * MemorySession session = ...\n+ * SegmentScope scope = ...\n@@ -183,1 +184,1 @@\n- *     intCompareHandle, intCompareDescriptor, session);\n+ *     intCompareHandle, intCompareDescriptor, scope);\n@@ -188,1 +189,1 @@\n- * {@linkplain java.lang.foreign.Linker#upcallStub(java.lang.invoke.MethodHandle, FunctionDescriptor, MemorySession) create}\n+ * {@linkplain java.lang.foreign.Linker#upcallStub(java.lang.invoke.MethodHandle, FunctionDescriptor, SegmentScope) create}\n@@ -192,2 +193,2 @@\n- * The lifecycle of the upcall stub is tied to the {@linkplain java.lang.foreign.MemorySession memory session}\n- * provided when the upcall stub is created. This same session is made available by the {@link java.lang.foreign.MemorySegment}\n+ * The lifecycle of the upcall stub is tied to the {@linkplain java.lang.foreign.SegmentScope scope}\n+ * provided when the upcall stub is created. This same scope is made available by the {@link java.lang.foreign.MemorySegment}\n@@ -199,1 +200,1 @@\n- * the restricted method {@link java.lang.foreign.MemorySegment#ofAddress(long, long, MemorySession)}\n+ * the restricted method {@link java.lang.foreign.MemorySegment#ofAddress(long, long, SegmentScope)}\n@@ -202,3 +203,4 @@\n- * Binding foreign data and\/or functions is generally unsafe and, if done incorrectly, can result in VM crashes, or memory corruption when the bound Java API element is accessed.\n- * For instance, in the case of {@link java.lang.foreign.MemorySegment#ofAddress(long, long, MemorySession)},\n- * if the provided spatial bounds are incorrect, a client of the segment returned by that method might crash the VM, or corrupt\n+ * Binding foreign data and\/or functions is generally unsafe and, if done incorrectly, can result in VM crashes,\n+ * or memory corruption when the bound Java API element is accessed. For instance, in the case of\n+ * {@link java.lang.foreign.MemorySegment#ofAddress(long, long, SegmentScope)}, if the provided spatial bounds are\n+ * incorrect, a client of the segment returned by that method might crash the VM, or corrupt\n@@ -208,5 +210,4 @@\n- * Access to restricted methods can be controlled using the command line option {@code --enable-native-access=M1,M2, ... Mn},\n- * where {@code M1}, {@code M2}, {@code ... Mn} are module names (for the unnamed module, the special value {@code ALL-UNNAMED}\n- * can be used). If this option is specified, access to restricted methods is only granted to the modules listed by that\n- * option. If this option is not specified, access to restricted methods is enabled for all modules, but\n- * access to restricted methods will result in runtime warnings.\n+ * Given the potential danger of restricted methods, the Java runtime issues a warning on the standard error stream\n+ * every time a restricted method is invoked. Such warnings can be disabled by granting access to restricted methods\n+ * to selected modules. This can be done either via implementation-specific command line options, or programmatically, e.g. by calling\n+ * {@link java.lang.ModuleLayer.Controller#enableNativeAccess(java.lang.Module)}.\n@@ -217,0 +218,11 @@\n+ *\n+ * @apiNote Usual memory model guarantees, for example stated in {@jls 6.6} and {@jls 10.4}, do not apply\n+ * when accessing native memory segments as these segments are backed by off-heap regions of memory.\n+ *\n+ * @implNote\n+ * In the reference implementation, access to restricted methods can be granted to specific modules using the command line option\n+ * {@code --enable-native-access=M1,M2, ... Mn}, where {@code M1}, {@code M2}, {@code ... Mn} are module names\n+ * (for the unnamed module, the special value {@code ALL-UNNAMED} can be used). If this option is specified, access to\n+ * restricted methods is only granted to the modules listed by that option. If this option is not specified,\n+ * access to restricted methods is enabled for all modules, but access to restricted methods will result in runtime warnings.\n+ *\n@@ -219,0 +231,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":36,"deletions":23,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import sun.invoke.util.ValueConversions;\n@@ -36,3 +35,0 @@\n-import static java.lang.invoke.LambdaForm.BasicType.V_TYPE_NUM;\n-import static java.lang.invoke.LambdaForm.BasicType.V_TYPE_NUM;\n-import static java.lang.invoke.LambdaForm.BasicType.V_TYPE_NUM;\n@@ -64,16 +60,0 @@\n-    static BoundMethodHandle bindSingle(MethodType type, LambdaForm form, BasicType xtype, Object x) {\n-        \/\/ for some type signatures, there exist pre-defined concrete BMH classes\n-        try {\n-            return switch (xtype) {\n-                case L_TYPE -> bindSingle(type, form, x);  \/\/ Use known fast path.\n-                case I_TYPE -> (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(I_TYPE_NUM).factory().invokeBasic(type, form, ValueConversions.widenSubword(x));\n-                case J_TYPE -> (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(J_TYPE_NUM).factory().invokeBasic(type, form, (long) x);\n-                case F_TYPE -> (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(F_TYPE_NUM).factory().invokeBasic(type, form, (float) x);\n-                case D_TYPE -> (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(D_TYPE_NUM).factory().invokeBasic(type, form, (double) x);\n-                default -> throw newInternalError(\"unexpected xtype: \" + xtype);\n-            };\n-        } catch (Throwable t) {\n-            throw uncaughtException(t);\n-        }\n-    }\n-\n@@ -359,1 +339,2 @@\n-            assert(args.size() == transform.getMethodType().parameterCount());\n+            MethodType tType = transform.getMethodType();\n+            assert(args.size() == tType.parameterCount());\n@@ -363,1 +344,1 @@\n-                assert(transform.getMethodType().parameterCount() == MH_AND_LF);\n+                assert(tType.parameterCount() == MH_AND_LF);\n@@ -365,1 +346,1 @@\n-                assert(transform.getMethodType().parameterCount() == MH_AND_LF+1);\n+                assert(tType.parameterCount() == MH_AND_LF+1);\n@@ -367,1 +348,1 @@\n-                assert(transform.getParameterTypes()[MH_AND_LF] == type.basicTypeClass());\n+                assert(tType.parameterType(MH_AND_LF) == type.basicTypeClass());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/BoundMethodHandle.java","additions":5,"deletions":24,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -331,0 +331,1 @@\n+            MethodType tmt = tm.getMethodType();\n@@ -333,1 +334,1 @@\n-            Collections.addAll(args, tm.getParameterTypes());\n+            Collections.addAll(args, tmt.ptypes());\n@@ -336,1 +337,1 @@\n-            return MethodType.methodType(tm.getReturnType(), helperArgs);\n+            return MethodType.methodType(tmt.returnType(), helperArgs);\n@@ -435,1 +436,1 @@\n-                    final Constructor<T> con = reflectConstructor(topc, baseConstructorType().parameterArray());\n+                    final Constructor<T> con = reflectConstructor(topc, baseConstructorType().ptypes());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ClassSpecializer.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -603,1 +603,1 @@\n-        return member.getReturnType().cast(obj);\n+        return member.getMethodType().returnType().cast(obj);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1046,1 +1046,1 @@\n-        for (Class<?> ptype : mtype.parameterArray())\n+        for (Class<?> ptype : mtype.ptypes())\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -367,10 +367,0 @@\n-    private static Name[] buildNames(Name[] formals, Name[] temps, Name result) {\n-        int arity = formals.length;\n-        int length = arity + temps.length + (result == null ? 0 : 1);\n-        Name[] names = Arrays.copyOf(formals, length);\n-        System.arraycopy(temps, 0, names, arity, temps.length);\n-        if (result != null)\n-            names[length - 1] = result;\n-        return names;\n-    }\n-\n@@ -1341,0 +1331,2 @@\n+        private static final Object[] EMPTY_ARGS = new Object[0];\n+\n@@ -1347,1 +1339,1 @@\n-            assert(this.index == index);\n+            assert(this.index == index && typesMatch(function, this.arguments));\n@@ -1368,0 +1360,9 @@\n+        Name(NamedFunction function) {\n+            this(-1, function.returnType(), function, EMPTY_ARGS);\n+        }\n+        Name(NamedFunction function, Object arg) {\n+            this(-1, function.returnType(), function, new Object[] { arg });\n+        }\n+        Name(NamedFunction function, Object arg0, Object arg1) {\n+            this(-1, function.returnType(), function, new Object[] { arg0, arg1 });\n+        }\n@@ -1369,2 +1370,1 @@\n-            this(-1, function.returnType(), function, arguments = Arrays.copyOf(arguments, arguments.length, Object[].class));\n-            assert(typesMatch(function, arguments));\n+            this(-1, function.returnType(), function, Arrays.copyOf(arguments, arguments.length, Object[].class));\n@@ -1537,0 +1537,4 @@\n+            if (arguments == null) {\n+                assert(function == null);\n+                return true;\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import sun.invoke.util.BytecodeDescriptor;\n@@ -36,4 +35,0 @@\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Iterator;\n-import java.util.List;\n@@ -77,1 +72,1 @@\n-};\n+}\n@@ -201,10 +196,0 @@\n-    \/** Utility method producing the parameter types of the method type. *\/\n-    public Class<?>[] getParameterTypes() {\n-        return getMethodType().parameterArray();\n-    }\n-\n-    \/** Utility method producing the return type of the method type. *\/\n-    public Class<?> getReturnType() {\n-        return getMethodType().returnType();\n-    }\n-\n@@ -252,16 +237,0 @@\n-    \/** Utility method to produce the signature of this member,\n-     *  used within the class file format to describe its type.\n-     *\/\n-    public String getSignature() {\n-        if (type == null) {\n-            expandFromVM();\n-            if (type == null) {\n-                return null;\n-            }\n-        }\n-        if (isInvocable())\n-            return BytecodeDescriptor.unparse(getMethodType());\n-        else\n-            return BytecodeDescriptor.unparse(getFieldType());\n-    }\n-\n@@ -359,2 +328,1 @@\n-        assert(getReferenceKind() == oldKind);\n-        assert(MethodHandleNatives.refKindIsValid(refKind));\n+        assert(getReferenceKind() == oldKind && MethodHandleNatives.refKindIsValid(refKind));\n@@ -365,2 +333,2 @@\n-    private boolean testFlags(int mask, int value) {\n-        return (flags & mask) == value;\n+    private boolean matchingFlagsSet(int mask, int flags) {\n+        return (this.flags & mask) == flags;\n@@ -368,2 +336,2 @@\n-    private boolean testAllFlags(int mask) {\n-        return testFlags(mask, mask);\n+    private boolean allFlagsSet(int flags) {\n+        return (this.flags & flags) == flags;\n@@ -371,2 +339,2 @@\n-    private boolean testAnyFlags(int mask) {\n-        return !testFlags(mask, 0);\n+    private boolean anyFlagSet(int flags) {\n+        return (this.flags & flags) != 0;\n@@ -380,2 +348,1 @@\n-        if (testFlags(bits | negs, bits) &&\n-            clazz == MethodHandle.class) {\n+        if (matchingFlagsSet(bits | negs, bits) && clazz == MethodHandle.class) {\n@@ -387,7 +354,4 @@\n-        switch (name) {\n-        case \"invoke\":\n-        case \"invokeExact\":\n-            return true;\n-        default:\n-            return false;\n-        }\n+        return switch (name) {\n+            case \"invoke\", \"invokeExact\" -> true;\n+            default -> false;\n+        };\n@@ -398,2 +362,1 @@\n-        if (testFlags(bits | negs, bits) &&\n-            clazz == VarHandle.class) {\n+        if (matchingFlagsSet(bits | negs, bits) && clazz == VarHandle.class) {\n@@ -460,1 +423,1 @@\n-        return testAllFlags(IS_METHOD | BRIDGE);\n+        return allFlagsSet(IS_METHOD | BRIDGE);\n@@ -464,1 +427,1 @@\n-        return testAllFlags(VARARGS) && isInvocable();\n+        return allFlagsSet(VARARGS) && isInvocable();\n@@ -468,1 +431,1 @@\n-        return testAllFlags(SYNTHETIC);\n+        return allFlagsSet(SYNTHETIC);\n@@ -488,2 +451,0 @@\n-    static final int IS_FIELD_OR_METHOD = IS_METHOD | IS_FIELD;\n-    static final int SEARCH_ALL_SUPERS = MN_SEARCH_SUPERCLASSES | MN_SEARCH_INTERFACES;\n@@ -493,5 +454,1 @@\n-        return testAnyFlags(IS_INVOCABLE);\n-    }\n-    \/** Utility method to query whether this member is a method, constructor, or field. *\/\n-    public boolean isFieldOrMethod() {\n-        return testAnyFlags(IS_FIELD_OR_METHOD);\n+        return anyFlagSet(IS_INVOCABLE);\n@@ -501,1 +458,1 @@\n-        return testAllFlags(IS_METHOD);\n+        return allFlagsSet(IS_METHOD);\n@@ -505,1 +462,1 @@\n-        return testAllFlags(IS_CONSTRUCTOR);\n+        return allFlagsSet(IS_CONSTRUCTOR);\n@@ -509,1 +466,1 @@\n-        return testAllFlags(IS_FIELD);\n+        return allFlagsSet(IS_FIELD);\n@@ -513,1 +470,1 @@\n-        return testAllFlags(IS_TYPE);\n+        return allFlagsSet(IS_TYPE);\n@@ -517,1 +474,1 @@\n-        return !testAnyFlags(ALL_ACCESS);\n+        return !anyFlagSet(ALL_ACCESS);\n@@ -521,1 +478,1 @@\n-        return testAllFlags(CALLER_SENSITIVE);\n+        return allFlagsSet(CALLER_SENSITIVE);\n@@ -524,7 +481,2 @@\n-    public boolean isTrustedFinalField() { return testAllFlags(TRUSTED_FINAL|IS_FIELD); }\n-\n-    \/** Utility method to query whether this member is accessible from a given lookup class. *\/\n-    public boolean isAccessibleFrom(Class<?> lookupClass) {\n-        int mode = (ALL_ACCESS|MethodHandles.Lookup.PACKAGE|MethodHandles.Lookup.MODULE);\n-        return VerifyAccess.isMemberAccessible(this.getDeclaringClass(), this.getDeclaringClass(), flags,\n-                                               lookupClass, null, mode);\n+    public boolean isTrustedFinalField() {\n+        return allFlagsSet(TRUSTED_FINAL | IS_FIELD);\n@@ -550,2 +502,1 @@\n-        assert(testAnyFlags(ALL_KINDS));\n-        assert(this.resolution == null);  \/\/ nobody should have touched this yet\n+        assert(anyFlagSet(ALL_KINDS) && this.resolution == null);  \/\/ nobody should have touched this yet\n@@ -571,3 +522,3 @@\n-        assert((flags & RECOGNIZED_MODIFIERS) == 0);\n-        assert((mods & ~RECOGNIZED_MODIFIERS) == 0);\n-        assert((refKind & ~MN_REFERENCE_KIND_MASK) == 0);\n+        assert((flags & RECOGNIZED_MODIFIERS) == 0\n+                && (mods & ~RECOGNIZED_MODIFIERS) == 0\n+                && (refKind & ~MN_REFERENCE_KIND_MASK) == 0);\n@@ -610,1 +561,1 @@\n-        assert(isResolved() && this.clazz != null);\n+        assert(isResolved());\n@@ -652,1 +603,0 @@\n-        byte normalVirtual = clazz.isInterface() ? REF_invokeInterface : REF_invokeVirtual;\n@@ -654,9 +604,6 @@\n-        byte newRefKind = refKind;\n-        MemberName result = this;\n-        switch (refKind) {\n-        case REF_invokeInterface:\n-        case REF_invokeVirtual:\n-        case REF_invokeSpecial:\n-            newRefKind = normalVirtual;\n-            break;\n-        }\n+        byte newRefKind = switch (refKind) {\n+            case REF_invokeInterface,\n+                 REF_invokeVirtual,\n+                 REF_invokeSpecial -> clazz.isInterface() ? REF_invokeInterface : REF_invokeVirtual;\n+            default -> refKind;\n+        };\n@@ -665,1 +612,1 @@\n-        result = clone().changeReferenceKind(newRefKind, refKind);\n+        MemberName result = clone().changeReferenceKind(newRefKind, refKind);\n@@ -685,0 +632,4 @@\n+    static {\n+        \/\/ the following MemberName constructor relies on these ranges matching up\n+        assert((REF_putStatic - REF_getStatic) == (REF_putField - REF_getField));\n+    }\n@@ -693,1 +644,0 @@\n-        assert((REF_putStatic - REF_getStatic) == (REF_putField - REF_getField));\n@@ -706,7 +656,1 @@\n-    public MemberName asSetter() {\n-        byte refKind = getReferenceKind();\n-        assert(MethodHandleNatives.refKindIsGetter(refKind));\n-        assert((REF_putStatic - REF_getStatic) == (REF_putField - REF_getField));\n-        byte setterRefKind = (byte)(refKind + (REF_putField - REF_getField));\n-        return clone().changeReferenceKind(setterRefKind, refKind);\n-    }\n+\n@@ -847,5 +791,0 @@\n-    \/** Query whether this member name is resolved to a non-static, non-final method.\n-     *\/\n-    public boolean hasReceiverTypeDispatch() {\n-        return MethodHandleNatives.refKindDoesDispatch(getReferenceKind());\n-    }\n@@ -933,1 +872,1 @@\n-        message = message + \": \"+ toString();\n+        message = message + \": \" + this;\n@@ -968,1 +907,1 @@\n-        String message = message() + \": \"+ toString();\n+        String message = message() + \": \" + this;\n@@ -995,3 +934,1 @@\n-        static Factory INSTANCE = new Factory();\n-\n-        private static int ALLOWED_FLAGS = ALL_KINDS;\n+        static final Factory INSTANCE = new Factory();\n@@ -999,60 +936,0 @@\n-        \/\/\/ Queries\n-        List<MemberName> getMembers(Class<?> defc,\n-                String matchName, Object matchType,\n-                int matchFlags, Class<?> lookupClass) {\n-            matchFlags &= ALLOWED_FLAGS;\n-            String matchSig = null;\n-            if (matchType != null) {\n-                matchSig = BytecodeDescriptor.unparse(matchType);\n-                if (matchSig.startsWith(\"(\"))\n-                    matchFlags &= ~(ALL_KINDS & ~IS_INVOCABLE);\n-                else\n-                    matchFlags &= ~(ALL_KINDS & ~IS_FIELD);\n-            }\n-            final int BUF_MAX = 0x2000;\n-            int len1 = matchName == null ? 10 : matchType == null ? 4 : 1;\n-            MemberName[] buf = newMemberBuffer(len1);\n-            int totalCount = 0;\n-            ArrayList<MemberName[]> bufs = null;\n-            int bufCount = 0;\n-            for (;;) {\n-                bufCount = MethodHandleNatives.getMembers(defc,\n-                        matchName, matchSig, matchFlags,\n-                        lookupClass,\n-                        totalCount, buf);\n-                if (bufCount <= buf.length) {\n-                    if (bufCount < 0)  bufCount = 0;\n-                    totalCount += bufCount;\n-                    break;\n-                }\n-                \/\/ JVM returned to us with an intentional overflow!\n-                totalCount += buf.length;\n-                int excess = bufCount - buf.length;\n-                if (bufs == null)  bufs = new ArrayList<>(1);\n-                bufs.add(buf);\n-                int len2 = buf.length;\n-                len2 = Math.max(len2, excess);\n-                len2 = Math.max(len2, totalCount \/ 4);\n-                buf = newMemberBuffer(Math.min(BUF_MAX, len2));\n-            }\n-            ArrayList<MemberName> result = new ArrayList<>(totalCount);\n-            if (bufs != null) {\n-                for (MemberName[] buf0 : bufs) {\n-                    Collections.addAll(result, buf0);\n-                }\n-            }\n-            for (int i = 0; i < bufCount; i++) {\n-                result.add(buf[i]);\n-            }\n-            \/\/ Signature matching is not the same as type matching, since\n-            \/\/ one signature might correspond to several types.\n-            \/\/ So if matchType is a Class or MethodType, refilter the results.\n-            if (matchType != null && matchType != matchSig) {\n-                for (Iterator<MemberName> it = result.iterator(); it.hasNext();) {\n-                    MemberName m = it.next();\n-                    if (!matchType.equals(m.getType()))\n-                        it.remove();\n-                }\n-            }\n-            return result;\n-        }\n@@ -1134,64 +1011,0 @@\n-        \/** Return a list of all methods defined by the given class.\n-         *  Super types are searched (for inherited members) if {@code searchSupers} is true.\n-         *  Access checking is performed on behalf of the given {@code lookupClass}.\n-         *  Inaccessible members are not added to the last.\n-         *\/\n-        public List<MemberName> getMethods(Class<?> defc, boolean searchSupers,\n-                Class<?> lookupClass) {\n-            return getMethods(defc, searchSupers, null, null, lookupClass);\n-        }\n-        \/** Return a list of matching methods defined by the given class.\n-         *  Super types are searched (for inherited members) if {@code searchSupers} is true.\n-         *  Returned methods will match the name (if not null) and the type (if not null).\n-         *  Access checking is performed on behalf of the given {@code lookupClass}.\n-         *  Inaccessible members are not added to the last.\n-         *\/\n-        public List<MemberName> getMethods(Class<?> defc, boolean searchSupers,\n-                String name, MethodType type, Class<?> lookupClass) {\n-            int matchFlags = IS_METHOD | (searchSupers ? SEARCH_ALL_SUPERS : 0);\n-            return getMembers(defc, name, type, matchFlags, lookupClass);\n-        }\n-        \/** Return a list of all constructors defined by the given class.\n-         *  Access checking is performed on behalf of the given {@code lookupClass}.\n-         *  Inaccessible members are not added to the last.\n-         *\/\n-        public List<MemberName> getConstructors(Class<?> defc, Class<?> lookupClass) {\n-            return getMembers(defc, null, null, IS_CONSTRUCTOR, lookupClass);\n-        }\n-        \/** Return a list of all fields defined by the given class.\n-         *  Super types are searched (for inherited members) if {@code searchSupers} is true.\n-         *  Access checking is performed on behalf of the given {@code lookupClass}.\n-         *  Inaccessible members are not added to the last.\n-         *\/\n-        public List<MemberName> getFields(Class<?> defc, boolean searchSupers,\n-                Class<?> lookupClass) {\n-            return getFields(defc, searchSupers, null, null, lookupClass);\n-        }\n-        \/** Return a list of all fields defined by the given class.\n-         *  Super types are searched (for inherited members) if {@code searchSupers} is true.\n-         *  Returned fields will match the name (if not null) and the type (if not null).\n-         *  Access checking is performed on behalf of the given {@code lookupClass}.\n-         *  Inaccessible members are not added to the last.\n-         *\/\n-        public List<MemberName> getFields(Class<?> defc, boolean searchSupers,\n-                String name, Class<?> type, Class<?> lookupClass) {\n-            int matchFlags = IS_FIELD | (searchSupers ? SEARCH_ALL_SUPERS : 0);\n-            return getMembers(defc, name, type, matchFlags, lookupClass);\n-        }\n-        \/** Return a list of all nested types defined by the given class.\n-         *  Super types are searched (for inherited members) if {@code searchSupers} is true.\n-         *  Access checking is performed on behalf of the given {@code lookupClass}.\n-         *  Inaccessible members are not added to the last.\n-         *\/\n-        public List<MemberName> getNestedTypes(Class<?> defc, boolean searchSupers,\n-                Class<?> lookupClass) {\n-            int matchFlags = IS_TYPE | (searchSupers ? SEARCH_ALL_SUPERS : 0);\n-            return getMembers(defc, null, null, matchFlags, lookupClass);\n-        }\n-        private static MemberName[] newMemberBuffer(int length) {\n-            MemberName[] buf = new MemberName[length];\n-            \/\/ fill the buffer with dummy structs for the JVM to fill in\n-            for (int i = 0; i < length; i++)\n-                buf[i] = new MemberName();\n-            return buf;\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemberName.java","additions":46,"deletions":233,"binary":false,"changes":279,"status":"modified"},{"patch":"@@ -1008,1 +1008,2 @@\n-        MethodType type = MethodType.methodType(method.getReturnType(), UnsupportedOperationException.class,\n+        MethodType type = MethodType.methodType(method.getMethodType().returnType(),\n+                                                UnsupportedOperationException.class,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        for (Class<?> pType : type.parameterArray()) {\n+        for (Class<?> pType : type.ptypes()) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/NativeMethodHandle.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.lang.foreign.MemorySession;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleByteArrayView.java.template","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -265,1 +265,11 @@\n-    RELEASE_20(64);\n+    RELEASE_20(64),\n+\n+    \/**\n+     * The version recognized by the Java Platform, Standard Edition\n+     * 21.\n+     *\n+     * @see <a\n+     * href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se21\/html\/index.html\">\n+     * <cite>The Java Virtual Machine Specification, Java SE 21 Edition<\/cite><\/a>\n+     *\/\n+    RELEASE_21(65);\n@@ -280,1 +290,1 @@\n-        return RELEASE_20;\n+        return RELEASE_21;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ClassFileFormatVersion.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-    private Throwable target;\n+    private final Throwable target;\n@@ -59,0 +59,1 @@\n+        this.target = null;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/InvocationTargetException.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3242,0 +3242,1 @@\n+            int qreg = p;\n@@ -3253,1 +3254,1 @@\n-            regChars = (scan(p, n, L_REG_NAME, H_REG_NAME) == n);\n+            regChars = ((qreg = scan(p, n, L_REG_NAME, H_REG_NAME)) == n);\n@@ -3297,1 +3298,1 @@\n-                    fail(\"Illegal character in authority\", q);\n+                    fail(\"Illegal character in authority\", serverChars ? q : qreg);\n","filename":"src\/java.base\/share\/classes\/java\/net\/URI.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.lang.ref.Reference;\n@@ -782,0 +783,1 @@\n+\n@@ -827,4 +829,4 @@\n-                public Runnable acquireSession(Buffer buffer, boolean async) {\n-                    var session = buffer.session();\n-                    if (session == null) {\n-                        return null;\n+                public void acquireSession(Buffer buffer) {\n+                    var scope = buffer.session();\n+                    if (scope != null) {\n+                        scope.acquire0();\n@@ -832,2 +834,11 @@\n-                    if (async && session.ownerThread() != null) {\n-                        throw new IllegalStateException(\"Confined session not supported\");\n+                }\n+\n+                @Override\n+                public void releaseSession(Buffer buffer) {\n+                    try {\n+                        var scope = buffer.session();\n+                        if (scope != null) {\n+                            scope.release0();\n+                        }\n+                    } finally {\n+                        Reference.reachabilityFence(buffer);\n@@ -835,2 +846,11 @@\n-                    session.acquire0();\n-                    return session::release0;\n+                }\n+\n+                @Override\n+                public boolean isThreadConfined(Buffer buffer) {\n+                    var scope = buffer.session();\n+                    return scope != null && scope.ownerThread() != null;\n+                }\n+\n+                @Override\n+                public boolean hasSession(Buffer buffer) {\n+                    return buffer.session() != null;\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Buffer.java","additions":28,"deletions":8,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.foreign.MemorySession;\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Direct-X-Buffer.java.template","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -1002,3 +1002,5 @@\n-     * Maps a region of this channel's file into a new mapped memory segment, with the given offset,\n-     * size and memory session. The {@linkplain MemorySegment#address() address} of the returned memory segment\n-     * is the starting address of the mapped off-heap region backing the segment.\n+     * Maps a region of this channel's file into a new mapped memory segment,\n+     * with the given offset, size and memory session.\n+     * The {@linkplain MemorySegment#address() address} of the returned memory\n+     * segment is the starting address of the mapped off-heap region backing\n+     * the segment.\n@@ -1057,1 +1059,1 @@\n-     *          {@linkplain MemorySession#isAlive() alive}.\n+     *          {@linkplain SegmentScope#isAlive() alive}.\n@@ -1061,1 +1063,1 @@\n-     *          {@linkplain MemorySession#isOwnedBy(Thread) owning} the\n+     *          {@linkplain SegmentScope#isAccessibleBy(Thread) owning} the\n@@ -1084,1 +1086,1 @@\n-    public MemorySegment map(MapMode mode, long offset, long size, MemorySession session)\n+    public MemorySegment map(MapMode mode, long offset, long size, SegmentScope session)\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/FileChannel.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n- * elements, and {@link #getExtension() getExtension} to obtain its extension.\n+ * elements.\n@@ -252,57 +252,0 @@\n-    \/**\n-     * Returns the file extension of this path's file name as a {@code String}.\n-     * The extension is derived from this {@code Path} by obtaining the\n-     * {@linkplain #getFileName file name element}, deriving its {@linkplain\n-     * #toString string representation}, and then extracting a substring\n-     * determined by the position of a period character ('.', U+002E FULL STOP)\n-     * within the file name string. If the file name element is {@code null},\n-     * or if the file name string does not contain a period character, or if\n-     * the only period in the file name string is its first character, then\n-     * the extension is {@code null}. Otherwise, the extension is the substring\n-     * after the last period in the file name string. If this last period is\n-     * also the last character in the file name string, then the  extension is\n-     * {@linkplain String#isEmpty empty}.\n-     *\n-     * @implSpec\n-     * The default implementation is equivalent for this path to:\n-     * <pre>{@code\n-     * int lastPeriod = fileName.lastIndexOf('.');\n-     * if (lastPeriod <= 0)\n-     *     return null;\n-     * return (lastPeriod == fileName.length() - 1)\n-     *     ? \"\"\n-     *     : fileName.substring(lastPeriod + 1);\n-     * }<\/pre>\n-     *\n-     * @return  the file name extension of this path, which might be the\n-     *          empty string, or {@code null} if no extension is found\n-     *\n-     * @since 20\n-     *\/\n-    default String getExtension() {\n-        Path fileName = getFileName();\n-        if (fileName == null)\n-            return null;\n-\n-        String fileNameString = fileName.toString();\n-        int length = fileNameString.length();\n-\n-        \/\/ An empty or unity length file name string has a null extension\n-        if (length > 1) {\n-            int lastPeriodIndex = fileNameString.lastIndexOf('.');\n-\n-            \/\/ Indeterminate if there is no period character or\n-            \/\/ only the first character is a period character\n-            if (lastPeriodIndex > 0) {\n-                if (lastPeriodIndex == length - 1) {\n-                    \/\/ empty string\n-                    return \"\";\n-                } else {\n-                    return fileNameString.substring(lastPeriodIndex + 1);\n-                }\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/Path.java","additions":1,"deletions":58,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2855,0 +2855,4 @@\n+     * @implSpec\n+     * This method is equivalent to {@link #externalSubmit(ForkJoinTask)}\n+     * when called from a thread that is not in this pool.\n+     *\n@@ -2901,0 +2905,25 @@\n+    \/**\n+     * Submits the given task as if submitted from a non-{@code ForkJoinTask}\n+     * client. The task is added to a scheduling queue for submissions to the\n+     * pool even when called from a thread in the pool.\n+     *\n+     * @implSpec\n+     * This method is equivalent to {@link #submit(ForkJoinTask)} when called\n+     * from a thread that is not in this pool.\n+     *\n+     * @return the task\n+     * @param task the task to submit\n+     * @param <T> the type of the task's result\n+     * @throws NullPointerException if the task is null\n+     * @throws RejectedExecutionException if the task cannot be\n+     *         scheduled for execution\n+     * @since 20\n+     *\/\n+    public <T> ForkJoinTask<T> externalSubmit(ForkJoinTask<T> task) {\n+        U.storeStoreFence();  \/\/ ensure safely publishable\n+        task.markPoolSubmission();\n+        WorkQueue q = submissionQueue(true);\n+        q.push(task, this, true);\n+        return task;\n+    }\n+\n@@ -2912,0 +2941,3 @@\n+     * @throws NullPointerException if the task is null\n+     * @throws RejectedExecutionException if the task cannot be\n+     *         scheduled for execution\n@@ -3270,0 +3302,1 @@\n+     * @see ForkJoinWorkerThread#getQueuedTaskCount()\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -141,0 +141,11 @@\n+    \/**\n+     * {@return a (non-negative) estimate of the number of tasks in the\n+     * thread's queue}\n+     *\n+     * @since 20\n+     * @see ForkJoinPool#getQueuedTaskCount()\n+     *\/\n+    public int getQueuedTaskCount() {\n+        return workQueue.queueSize();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinWorkerThread.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -404,1 +404,1 @@\n-    \/\/ used by ExtentLocal\n+    \/\/ used by ScopedValue\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ThreadLocalRandom.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.ref.Reference;\n@@ -30,1 +29,1 @@\n-import sun.nio.ch.DirectBuffer;\n+\n@@ -33,0 +32,3 @@\n+import sun.nio.ch.DirectBuffer;\n+\n+import static java.util.zip.ZipUtils.NIO_ACCESS;\n@@ -99,0 +101,1 @@\n+            NIO_ACCESS.acquireSession(buffer);\n@@ -102,1 +105,1 @@\n-                Reference.reachabilityFence(buffer);\n+                NIO_ACCESS.releaseSession(buffer);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Adler32.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.ref.Reference;\n@@ -36,0 +35,2 @@\n+import static java.util.zip.ZipUtils.NIO_ACCESS;\n+\n@@ -99,0 +100,1 @@\n+            NIO_ACCESS.acquireSession(buffer);\n@@ -102,1 +104,1 @@\n-                Reference.reachabilityFence(buffer);\n+                NIO_ACCESS.releaseSession(buffer);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/CRC32.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.lang.ref.Reference;\n@@ -36,0 +35,2 @@\n+import static java.util.zip.ZipUtils.NIO_ACCESS;\n+\n@@ -174,0 +175,1 @@\n+            NIO_ACCESS.acquireSession(buffer);\n@@ -175,1 +177,1 @@\n-                crc = updateDirectByteBuffer(crc, ((DirectBuffer) buffer).address(),\n+                crc = updateDirectByteBuffer(crc, ((DirectBuffer)buffer).address(),\n@@ -178,1 +180,1 @@\n-                Reference.reachabilityFence(buffer);\n+                NIO_ACCESS.releaseSession(buffer);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/CRC32C.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.ref.Reference;\n@@ -38,0 +37,2 @@\n+import static java.util.zip.ZipUtils.NIO_ACCESS;\n+\n@@ -340,1 +341,1 @@\n-                long address = ((DirectBuffer) dictionary).address();\n+                NIO_ACCESS.acquireSession(dictionary);\n@@ -342,0 +343,1 @@\n+                    long address = ((DirectBuffer) dictionary).address();\n@@ -344,1 +346,1 @@\n-                    Reference.reachabilityFence(dictionary);\n+                    NIO_ACCESS.releaseSession(dictionary);\n@@ -590,0 +592,1 @@\n+                    NIO_ACCESS.acquireSession(input);\n@@ -597,1 +600,1 @@\n-                        Reference.reachabilityFence(input);\n+                        NIO_ACCESS.releaseSession(input);\n@@ -712,1 +715,1 @@\n-                    long outputAddress = ((DirectBuffer) output).address();\n+                    NIO_ACCESS.acquireSession(output);\n@@ -714,0 +717,1 @@\n+                        long outputAddress = ((DirectBuffer) output).address();\n@@ -719,1 +723,1 @@\n-                        Reference.reachabilityFence(output);\n+                        NIO_ACCESS.releaseSession(output);\n@@ -733,1 +737,1 @@\n-                    long inputAddress = ((DirectBuffer) input).address();\n+                    NIO_ACCESS.acquireSession(input);\n@@ -735,0 +739,1 @@\n+                        long inputAddress = ((DirectBuffer) input).address();\n@@ -736,1 +741,1 @@\n-                            long outputAddress = outputPos + ((DirectBuffer) output).address();\n+                            NIO_ACCESS.acquireSession(output);\n@@ -738,0 +743,1 @@\n+                                long outputAddress = outputPos + ((DirectBuffer) output).address();\n@@ -743,1 +749,1 @@\n-                                Reference.reachabilityFence(output);\n+                                NIO_ACCESS.releaseSession(output);\n@@ -754,1 +760,1 @@\n-                        Reference.reachabilityFence(input);\n+                        NIO_ACCESS.releaseSession(input);\n@@ -760,1 +766,1 @@\n-                        long outputAddress = ((DirectBuffer) output).address();\n+                        NIO_ACCESS.acquireSession(output);\n@@ -762,0 +768,1 @@\n+                            long outputAddress = ((DirectBuffer) output).address();\n@@ -767,1 +774,1 @@\n-                            Reference.reachabilityFence(output);\n+                            NIO_ACCESS.releaseSession(output);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Deflater.java","additions":19,"deletions":12,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.ref.Reference;\n@@ -38,0 +37,2 @@\n+import static java.util.zip.ZipUtils.NIO_ACCESS;\n+\n@@ -262,1 +263,1 @@\n-                long address = ((DirectBuffer) dictionary).address();\n+                NIO_ACCESS.acquireSession(dictionary);\n@@ -264,0 +265,1 @@\n+                    long address = ((DirectBuffer) dictionary).address();\n@@ -266,1 +268,1 @@\n-                    Reference.reachabilityFence(dictionary);\n+                    NIO_ACCESS.releaseSession(dictionary);\n@@ -386,0 +388,1 @@\n+                            NIO_ACCESS.acquireSession(input);\n@@ -392,1 +395,1 @@\n-                                Reference.reachabilityFence(input);\n+                                NIO_ACCESS.releaseSession(input);\n@@ -520,1 +523,1 @@\n-                            long outputAddress = ((DirectBuffer) output).address();\n+                            NIO_ACCESS.acquireSession(output);\n@@ -522,0 +525,1 @@\n+                                long outputAddress = ((DirectBuffer) output).address();\n@@ -526,1 +530,1 @@\n-                                Reference.reachabilityFence(output);\n+                                NIO_ACCESS.releaseSession(output);\n@@ -544,1 +548,1 @@\n-                            long inputAddress = ((DirectBuffer) input).address();\n+                            NIO_ACCESS.acquireSession(input);\n@@ -546,0 +550,1 @@\n+                                long inputAddress = ((DirectBuffer) input).address();\n@@ -547,1 +552,1 @@\n-                                    long outputAddress = ((DirectBuffer) output).address();\n+                                    NIO_ACCESS.acquireSession(output);\n@@ -549,0 +554,1 @@\n+                                        long outputAddress = ((DirectBuffer) output).address();\n@@ -553,1 +559,1 @@\n-                                        Reference.reachabilityFence(output);\n+                                        NIO_ACCESS.releaseSession(output);\n@@ -563,1 +569,1 @@\n-                                Reference.reachabilityFence(input);\n+                                NIO_ACCESS.releaseSession(input);\n@@ -569,1 +575,1 @@\n-                                long outputAddress = ((DirectBuffer) output).address();\n+                                NIO_ACCESS.acquireSession(output);\n@@ -571,0 +577,1 @@\n+                                    long outputAddress = ((DirectBuffer) output).address();\n@@ -575,1 +582,1 @@\n-                                    Reference.reachabilityFence(output);\n+                                    NIO_ACCESS.releaseSession(output);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Inflater.java","additions":19,"deletions":12,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -43,0 +45,2 @@\n+    static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipUtils.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,2 +37,2 @@\n- * schemes and whether SSL\/TLS\/DTLS servers should request or require client\n- * authentication, etc.\n+ * schemes, the key exchange named groups and whether SSL\/TLS\/DTLS servers\n+ * should request or require client authentication, etc.\n@@ -88,0 +88,1 @@\n+    private String[] namedGroups = null;\n@@ -813,0 +814,126 @@\n+\n+    \/**\n+     * Returns a prioritized array of key exchange named groups names that\n+     * can be used over the SSL\/TLS\/DTLS protocols.\n+     * <p>\n+     * Note that the standard list of key exchange named groups are defined\n+     * in the <a href=\n+     * \"{@docRoot}\/..\/specs\/security\/standard-names.html#named-groups\">\n+     * Named Groups<\/a> section of the Java Security Standard Algorithm\n+     * Names Specification.  Providers may support named groups not defined\n+     * in this list or may not use the recommended name for a certain named\n+     * group.\n+     * <p>\n+     * The set of named groups that will be used over the SSL\/TLS\/DTLS\n+     * connections is determined by the returned array of this method and the\n+     * underlying provider-specific default named groups.\n+     * <p>\n+     * If the returned array is {@code null}, then the underlying\n+     * provider-specific default named groups will be used over the\n+     * SSL\/TLS\/DTLS connections.\n+     * <p>\n+     * If the returned array is empty (zero-length), then the named group\n+     * negotiation mechanism is turned off for SSL\/TLS\/DTLS protocols, and\n+     * the connections may not be able to be established if the negotiation\n+     * mechanism is required by a certain SSL\/TLS\/DTLS protocol.  This\n+     * parameter will override the underlying provider-specific default\n+     * name groups.\n+     * <p>\n+     * If the returned array is not {@code null} or empty (zero-length),\n+     * then the named groups in the returned array will be used over\n+     * the SSL\/TLS\/DTLS connections.  This parameter will override the\n+     * underlying provider-specific default named groups.\n+     * <p>\n+     * This method returns the most recent value passed to\n+     * {@link #setNamedGroups} if that method has been called and otherwise\n+     * returns the default named groups for connection populated objects,\n+     * or {@code null} for pre-populated objects.\n+     *\n+     * @apiNote\n+     * Note that a provider may not have been updated to support this method\n+     * and in that case may return {@code null} instead of the default\n+     * named groups for connection populated objects.\n+     *\n+     * @implNote\n+     * The SunJSSE provider supports this method.\n+     *\n+     * @implNote\n+     * Note that applications may use the\n+     * {@systemProperty jdk.tls.namedGroups} system property with the SunJSSE\n+     * provider to override the provider-specific default named groups.\n+     *\n+     * @return an array of key exchange named group names {@code Strings} or\n+     *         {@code null} if none have been set.  For non-null returns, this\n+     *         method will return a new array each time it is invoked.  The\n+     *         array is ordered based on named group preference, with the first\n+     *         entry being the most preferred.  Providers should ignore unknown\n+     *         named group names while establishing the SSL\/TLS\/DTLS\n+     *         connections.\n+     * @see #setNamedGroups\n+     *\n+     * @since 20\n+     *\/\n+    public String[] getNamedGroups() {\n+        return clone(namedGroups);\n+    }\n+\n+    \/**\n+     * Sets the prioritized array of key exchange named groups names that\n+     * can be used over the SSL\/TLS\/DTLS protocols.\n+     * <p>\n+     * Note that the standard list of key exchange named groups are defined in\n+     * the <a href=\n+     * \"{@docRoot}\/..\/specs\/security\/standard-names.html#named-groups\">\n+     * Named Groups<\/a> section of the Java Security Standard Algorithm\n+     * Names Specification.  Providers may support named groups not defined\n+     * in this list or may not use the recommended name for a certain named\n+     * group.\n+     * <p>\n+     * The set of named groups that will be used over the SSL\/TLS\/DTLS\n+     * connections is determined by the input parameter {@code namedGroups}\n+     * array and the underlying provider-specific default named groups.\n+     * See {@link #getNamedGroups} for specific details on how the\n+     * parameters are used in SSL\/TLS\/DTLS connections.\n+     *\n+     * @apiNote\n+     * Note that a provider may not have been updated to support this method\n+     * and in that case may ignore the named groups that are set.\n+     *\n+     * @implNote\n+     * The SunJSSE provider supports this method.\n+     *\n+     * @param namedGroups an ordered array of key exchange named group names\n+     *        with the first entry being the most preferred, or {@code null}.\n+     *        This method will make a copy of this array. Providers should\n+     *        ignore unknown named group scheme names while establishing the\n+     *        SSL\/TLS\/DTLS connections.\n+     * @throws IllegalArgumentException if any element in the\n+     *        {@code namedGroups} array is a duplicate, {@code null} or\n+     *        {@linkplain String#isBlank() blank}.\n+     *\n+     * @see #getNamedGroups\n+     *\n+     * @since 20\n+     *\/\n+    public void setNamedGroups(String[] namedGroups) {\n+        String[] tempGroups = null;\n+\n+        if (namedGroups != null) {\n+            tempGroups = namedGroups.clone();\n+            Set<String> groupsSet = new HashSet<>();\n+            for (String namedGroup : tempGroups) {\n+                if (namedGroup == null || namedGroup.isBlank()) {\n+                    throw new IllegalArgumentException(\n+                        \"An element of namedGroups is null or blank\");\n+                }\n+\n+                if (groupsSet.contains(namedGroup)) {\n+                    throw new IllegalArgumentException(\n+                        \"Duplicate element of namedGroups: \" + namedGroup);\n+                }\n+                groupsSet.add(namedGroup);\n+            }\n+        }\n+\n+        this.namedGroups = tempGroups;\n+    }\n","filename":"src\/java.base\/share\/classes\/javax\/net\/ssl\/SSLParameters.java","additions":129,"deletions":2,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.nio.charset.Charset;\n@@ -33,1 +32,0 @@\n-    Charset charset();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaIOAccess.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.io.InputStream;\n@@ -366,0 +367,6 @@\n+    \/**\n+     * Returns the initial `System.in` to determine if it is replaced\n+     * with `System.setIn(newIn)` method\n+     *\/\n+    InputStream initialSystemIn();\n+\n@@ -479,1 +486,1 @@\n-     * Returns the current thread's extent locals cache\n+     * Returns the current thread's scoped values cache\n@@ -481,1 +488,1 @@\n-    Object[] extentLocalCache();\n+    Object[] scopedValueCache();\n@@ -484,1 +491,1 @@\n-     * Sets the current thread's extent locals cache\n+     * Sets the current thread's scoped values cache\n@@ -486,1 +493,1 @@\n-    void setExtentLocalCache(Object[] cache);\n+    void setScopedValueCache(Object[] cache);\n@@ -489,1 +496,1 @@\n-     * Return the current thread's extent local bindings.\n+     * Return the current thread's scoped value bindings.\n@@ -491,1 +498,1 @@\n-    Object extentLocalBindings();\n+    Object scopedValueBindings();\n@@ -494,1 +501,1 @@\n-     * Set the current thread's extent local bindings.\n+     * Set the current thread's scoped value bindings.\n@@ -496,1 +503,5 @@\n-    void setExtentLocalBindings(Object bindings);\n+    void setScopedValueBindings(Object bindings);\n+\n+    Object findScopedValueBindings();\n+\n+    void ensureMaterializedForStackWalk(Object value);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":19,"deletions":8,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -89,4 +89,12 @@\n-     * Used by I\/O operations to make a buffer's session non-closeable\n-     * (for the duration of the I\/O operation) by acquiring the session.\n-     * Null is returned if the buffer has no scope, or acquiring is not\n-     * required to guarantee safety.\n+     * Used by operations to make a buffer's session non-closeable\n+     * (for the duration of the operation) by acquiring the session.\n+     * {@snippet lang = java:\n+     * acquireSession(buffer);\n+     * try {\n+     *     performOperation(buffer);\n+     * } finally {\n+     *     releaseSession(buffer);\n+     * }\n+     *}\n+     *\n+     * @see #releaseSession(Buffer)\n@@ -94,1 +102,7 @@\n-    Runnable acquireSession(Buffer buffer, boolean async);\n+    void acquireSession(Buffer buffer);\n+\n+    void releaseSession(Buffer buffer);\n+\n+    boolean isThreadConfined(Buffer buffer);\n+\n+    boolean hasSession(Buffer buffer);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaNioAccess.java","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -32,0 +31,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -71,1 +71,1 @@\n-        implements MemorySegment, SegmentAllocator, Scoped, BiFunction<String, List<Number>, RuntimeException>\n+        implements MemorySegment, SegmentAllocator, BiFunction<String, List<Number>, RuntimeException>\n@@ -80,1 +80,1 @@\n-    final MemorySession session;\n+    final SegmentScope session;\n@@ -83,1 +83,1 @@\n-    AbstractMemorySegmentImpl(long length, boolean readOnly, MemorySession session) {\n+    AbstractMemorySegmentImpl(long length, boolean readOnly, SegmentScope session) {\n@@ -89,1 +89,1 @@\n-    abstract AbstractMemorySegmentImpl dup(long offset, long size, boolean readOnly, MemorySession session);\n+    abstract AbstractMemorySegmentImpl dup(long offset, long size, boolean readOnly, SegmentScope session);\n@@ -129,1 +129,1 @@\n-        if (!Utils.isAligned(byteSize(), elementLayout.byteSize())) {\n+        if ((byteSize() % elementLayout.byteSize()) != 0) {\n@@ -154,6 +154,0 @@\n-    @Override\n-    public long mismatch(MemorySegment other) {\n-        Objects.requireNonNull(other);\n-        return MemorySegment.mismatch(this, 0, byteSize(), other, 0, other.byteSize());\n-    }\n-\n@@ -338,0 +332,1 @@\n+        \/\/ elemSize is guaranteed to be a power of two, so we can use an alignment check\n@@ -366,1 +361,1 @@\n-    public MemorySession session() {\n+    public SegmentScope scope() {\n@@ -370,0 +365,5 @@\n+    @ForceInline\n+    public final MemorySessionImpl sessionImpl() {\n+        return (MemorySessionImpl)session;\n+    }\n+\n@@ -484,1 +484,1 @@\n-        final MemorySession bufferSession;\n+        final SegmentScope bufferSession;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    public final Optional<MemoryLayout> returnLayout() {\n+    public Optional<MemoryLayout> returnLayout() {\n@@ -64,1 +64,1 @@\n-    public final List<MemoryLayout> argumentLayouts() {\n+    public List<MemoryLayout> argumentLayouts() {\n@@ -75,1 +75,1 @@\n-    public final FunctionDescriptorImpl appendArgumentLayouts(MemoryLayout... addedLayouts) {\n+    public FunctionDescriptorImpl appendArgumentLayouts(MemoryLayout... addedLayouts) {\n@@ -144,1 +144,1 @@\n-    public final String toString() {\n+    public String toString() {\n@@ -165,1 +165,1 @@\n-    public final boolean equals(Object other) {\n+    public boolean equals(Object other) {\n@@ -175,1 +175,1 @@\n-    public final int hashCode() {\n+    public int hashCode() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/FunctionDescriptorImpl.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -49,1 +49,1 @@\n- * such as the elimination of store barriers in methods like {@link HeapMemorySegmentImpl#dup(long, long, boolean, MemorySession)}.\n+ * such as the elimination of store barriers in methods like {@link HeapMemorySegmentImpl#dup(long, long, boolean, SegmentScope)}.\n@@ -71,1 +71,1 @@\n-        super(length, readOnly, MemorySession.global());\n+        super(length, readOnly, SegmentScope.global());\n@@ -82,1 +82,1 @@\n-    abstract HeapMemorySegmentImpl dup(long offset, long size, boolean readOnly, MemorySession session);\n+    abstract HeapMemorySegmentImpl dup(long offset, long size, boolean readOnly, SegmentScope session);\n@@ -102,1 +102,1 @@\n-        OfByte dup(long offset, long size, boolean readOnly, MemorySession session) {\n+        OfByte dup(long offset, long size, boolean readOnly, SegmentScope session) {\n@@ -135,1 +135,1 @@\n-        OfChar dup(long offset, long size, boolean readOnly, MemorySession session) {\n+        OfChar dup(long offset, long size, boolean readOnly, SegmentScope session) {\n@@ -168,1 +168,1 @@\n-        OfShort dup(long offset, long size, boolean readOnly, MemorySession session) {\n+        OfShort dup(long offset, long size, boolean readOnly, SegmentScope session) {\n@@ -201,1 +201,1 @@\n-        OfInt dup(long offset, long size, boolean readOnly, MemorySession session) {\n+        OfInt dup(long offset, long size, boolean readOnly, SegmentScope session) {\n@@ -234,1 +234,1 @@\n-        OfLong dup(long offset, long size, boolean readOnly, MemorySession session) {\n+        OfLong dup(long offset, long size, boolean readOnly, SegmentScope session) {\n@@ -267,1 +267,1 @@\n-        OfFloat dup(long offset, long size, boolean readOnly, MemorySession session) {\n+        OfFloat dup(long offset, long size, boolean readOnly, SegmentScope session) {\n@@ -300,1 +300,1 @@\n-        OfDouble dup(long offset, long size, boolean readOnly, MemorySession session) {\n+        OfDouble dup(long offset, long size, boolean readOnly, SegmentScope session) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -46,1 +46,1 @@\n-    public MappedMemorySegmentImpl(long min, UnmapperProxy unmapper, long length, boolean readOnly, MemorySession session) {\n+    public MappedMemorySegmentImpl(long min, UnmapperProxy unmapper, long length, boolean readOnly, SegmentScope session) {\n@@ -58,1 +58,1 @@\n-    MappedMemorySegmentImpl dup(long offset, long size, boolean readOnly, MemorySession session) {\n+    MappedMemorySegmentImpl dup(long offset, long size, boolean readOnly, SegmentScope session) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.foreign.Arena;\n@@ -30,1 +31,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -35,1 +36,0 @@\n-import java.lang.ref.Reference;\n@@ -38,1 +38,0 @@\n-import jdk.internal.ref.CleanerFactory;\n@@ -55,1 +54,1 @@\n-        implements MemorySession, SegmentAllocator\n+        implements SegmentScope, SegmentAllocator\n@@ -76,1 +75,1 @@\n-        } catch (Throwable ex) {\n+        } catch (Exception ex) {\n@@ -81,0 +80,21 @@\n+    public Arena asArena() {\n+        return new Arena() {\n+            @Override\n+            public SegmentScope scope() {\n+                return MemorySessionImpl.this;\n+            }\n+\n+            @Override\n+            public void close() {\n+                MemorySessionImpl.this.close();\n+            }\n+\n+            @Override\n+            public boolean isCloseableBy(Thread thread) {\n+                Objects.requireNonNull(thread);\n+                return ownerThread() == null || \/\/ shared\n+                        ownerThread() == thread;\n+            }\n+        };\n+    }\n+\n@@ -158,3 +178,3 @@\n-    public static boolean sameOwnerThread(MemorySession session1, MemorySession session2) {\n-        return MemorySessionImpl.toSessionImpl(session1).ownerThread() ==\n-                MemorySessionImpl.toSessionImpl(session2).ownerThread();\n+    public static boolean sameOwnerThread(SegmentScope session1, SegmentScope session2) {\n+        return ((MemorySessionImpl) session1).ownerThread() ==\n+                ((MemorySessionImpl) session2).ownerThread();\n@@ -164,1 +184,1 @@\n-    public final boolean isOwnedBy(Thread thread) {\n+    public final boolean isAccessibleBy(Thread thread) {\n@@ -177,5 +197,0 @@\n-    @ForceInline\n-    public static MemorySessionImpl toSessionImpl(MemorySession session) {\n-        return (MemorySessionImpl)session;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":29,"deletions":14,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -31,0 +30,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -55,1 +55,1 @@\n-    NativeMemorySegmentImpl(long min, long length, boolean readOnly, MemorySession session) {\n+    NativeMemorySegmentImpl(long min, long length, boolean readOnly, SegmentScope session) {\n@@ -72,1 +72,1 @@\n-    NativeMemorySegmentImpl dup(long offset, long size, boolean readOnly, MemorySession session) {\n+    NativeMemorySegmentImpl dup(long offset, long size, boolean readOnly, SegmentScope session) {\n@@ -104,2 +104,2 @@\n-    public static MemorySegment makeNativeSegment(long byteSize, long byteAlignment, MemorySession session) {\n-        MemorySessionImpl sessionImpl = MemorySessionImpl.toSessionImpl(session);\n+    public static MemorySegment makeNativeSegment(long byteSize, long byteAlignment, SegmentScope session) {\n+        MemorySessionImpl sessionImpl = (MemorySessionImpl) session;\n@@ -141,2 +141,2 @@\n-    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, MemorySession session, Runnable action) {\n-        MemorySessionImpl sessionImpl = MemorySessionImpl.toSessionImpl(session);\n+    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, SegmentScope session, Runnable action) {\n+        MemorySessionImpl sessionImpl = (MemorySessionImpl) session;\n@@ -152,2 +152,2 @@\n-    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, MemorySession session) {\n-        MemorySessionImpl sessionImpl = MemorySessionImpl.toSessionImpl(session);\n+    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, SegmentScope session) {\n+        MemorySessionImpl sessionImpl = (MemorySessionImpl) session;\n@@ -160,1 +160,1 @@\n-        return new NativeMemorySegmentImpl(min, byteSize, false, MemorySession.global());\n+        return new NativeMemorySegmentImpl(min, byteSize, false, SegmentScope.global());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1,38 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.foreign;\n-\n-import jdk.internal.vm.annotation.ForceInline;\n-\n-import java.lang.foreign.MemorySession;\n-\n-public interface Scoped {\n-    @ForceInline\n-    default MemorySessionImpl sessionImpl() {\n-        return MemorySessionImpl.toSessionImpl(session());\n-    }\n-    MemorySession session();\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Scoped.java","additions":0,"deletions":38,"binary":false,"changes":38,"status":"deleted"},{"patch":"@@ -33,2 +33,0 @@\n-    public static final long DEFAULT_BLOCK_SIZE = 4 * 1024;\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SlicingAllocator.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -89,1 +89,1 @@\n-                ADDRESS.byteSize() * numSymbols, MemorySession.global());\n+                ADDRESS.byteSize() * numSymbols, SegmentScope.global());\n@@ -92,1 +92,1 @@\n-                .map(symbol -> MemorySegment.ofAddress(funcs.getAtIndex(ADDRESS, symbol.ordinal()).address(), 0L, MemorySession.global()));\n+                .map(symbol -> MemorySegment.ofAddress(funcs.getAtIndex(ADDRESS, symbol.ordinal()).address(), 0L, SegmentScope.global()));\n@@ -109,1 +109,1 @@\n-                        Optional.of(MemorySegment.ofAddress(addr, 0, MemorySession.global()));\n+                        Optional.of(MemorySegment.ofAddress(addr, 0, SegmentScope.global()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -69,1 +69,1 @@\n-    public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, MemorySession scope) {\n+    public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, SegmentScope scope) {\n@@ -84,1 +84,1 @@\n-                                                   FunctionDescriptor function, MemorySession scope);\n+                                                   FunctionDescriptor function, SegmentScope scope);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/Architecture.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.foreign.Utils;\n@@ -32,1 +33,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -199,1 +200,1 @@\n-     * the allocation operation, or {@link BoxAddress} bindings, by providing the {@link MemorySession} that\n+     * the allocation operation, or {@link BoxAddress} bindings, by providing the {@link SegmentScope} that\n@@ -204,1 +205,1 @@\n-        private final MemorySession session;\n+        private final SegmentScope session;\n@@ -206,1 +207,1 @@\n-        private Context(SegmentAllocator allocator, MemorySession session) {\n+        private Context(SegmentAllocator allocator, SegmentScope session) {\n@@ -215,1 +216,1 @@\n-        public MemorySession session() {\n+        public SegmentScope session() {\n@@ -229,1 +230,1 @@\n-            return new Context(SegmentAllocator.slicingAllocator(MemorySegment.allocateNative(size, arena.session())), arena.session()) {\n+            return new Context(SegmentAllocator.slicingAllocator(MemorySegment.allocateNative(size, arena.scope())), arena.scope()) {\n@@ -244,1 +245,1 @@\n-                public MemorySession session() {\n+                public SegmentScope session() {\n@@ -256,1 +257,1 @@\n-            return new Context(null, arena.session()) {\n+            return new Context(null, arena.scope()) {\n@@ -278,1 +279,1 @@\n-            public MemorySession session() {\n+            public SegmentScope session() {\n@@ -370,1 +371,22 @@\n-        return new Cast(fromType, toType);\n+        if (fromType == int.class) {\n+            if (toType == boolean.class) {\n+                return Cast.INT_TO_BOOLEAN;\n+            } else if (toType == byte.class) {\n+                return Cast.INT_TO_BYTE;\n+            } else if (toType == short.class) {\n+                return Cast.INT_TO_SHORT;\n+            } else if (toType == char.class) {\n+                return Cast.INT_TO_CHAR;\n+            }\n+        } else if (toType == int.class) {\n+            if (fromType == boolean.class) {\n+                return Cast.BOOLEAN_TO_INT;\n+            } else if (fromType == byte.class) {\n+                return Cast.BYTE_TO_INT;\n+            } else if (fromType == short.class) {\n+                return Cast.SHORT_TO_INT;\n+            } else if (fromType == char.class) {\n+                return Cast.CHAR_TO_INT;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Unknown conversion: \" + fromType + \" -> \" + toType);\n@@ -679,2 +701,2 @@\n-            MemorySession session = needsSession ?\n-                    context.session() : MemorySession.global();\n+            SegmentScope session = needsSession ?\n+                    context.session() : SegmentScope.global();\n@@ -716,1 +738,34 @@\n-    record Cast(Class<?> fromType, Class<?> toType) implements Binding {\n+    enum Cast implements Binding {\n+        INT_TO_BOOLEAN(int.class, boolean.class) {\n+            @Override\n+            public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n+                                  BindingInterpreter.LoadFunc loadFunc, Context context) {\n+                \/\/ implement least significant byte non-zero test\n+                int arg = (int) stack.pop();\n+                boolean result = Utils.byteToBoolean((byte) arg);\n+                stack.push(result);\n+            }\n+        },\n+        INT_TO_BYTE(int.class, byte.class),\n+        INT_TO_CHAR(int.class, char.class),\n+        INT_TO_SHORT(int.class, short.class),\n+        BOOLEAN_TO_INT(boolean.class, int.class),\n+        BYTE_TO_INT(byte.class, int.class),\n+        CHAR_TO_INT(char.class, int.class),\n+        SHORT_TO_INT(short.class, int.class);\n+\n+        private final Class<?> fromType;\n+        private final Class<?> toType;\n+\n+        Cast(Class<?> fromType, Class<?> toType) {\n+            this.fromType = fromType;\n+            this.toType = toType;\n+        }\n+\n+        public Class<?> fromType() {\n+            return fromType;\n+        }\n+\n+        public Class<?> toType() {\n+            return toType;\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":68,"deletions":13,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n@@ -29,1 +30,0 @@\n-import jdk.internal.foreign.Scoped;\n@@ -50,1 +50,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -85,1 +85,1 @@\n-    private static final String SESSION_DESC = methodType(MemorySession.class).descriptorString();\n+    private static final String SESSION_DESC = methodType(SegmentScope.class).descriptorString();\n@@ -91,1 +91,1 @@\n-    private static final String OF_LONG_UNCHECKED_DESC = methodType(MemorySegment.class, long.class, long.class, MemorySession.class).descriptorString();\n+    private static final String OF_LONG_UNCHECKED_DESC = methodType(MemorySegment.class, long.class, long.class, SegmentScope.class).descriptorString();\n@@ -501,2 +501,2 @@\n-        emitCheckCast(Scoped.class);\n-        emitInvokeInterface(Scoped.class, \"sessionImpl\", SESSION_IMPL_DESC);\n+        emitCheckCast(AbstractMemorySegmentImpl.class);\n+        emitInvokeVirtual(AbstractMemorySegmentImpl.class, \"sessionImpl\", SESSION_IMPL_DESC);\n@@ -679,4 +679,3 @@\n-        if (fromType == int.class) {\n-            popType(int.class);\n-\n-            if (toType == boolean.class) {\n+        popType(fromType);\n+        switch (cast) {\n+            case INT_TO_BOOLEAN -> {\n@@ -691,7 +690,0 @@\n-            } else if (toType == byte.class) {\n-                mv.visitInsn(I2B);\n-            } else if (toType == short.class) {\n-                mv.visitInsn(I2S);\n-            } else {\n-                assert toType == char.class;\n-                mv.visitInsn(I2C);\n@@ -699,13 +691,7 @@\n-\n-            pushType(toType);\n-        } else {\n-            popType(fromType);\n-\n-            assert fromType == boolean.class\n-                    || fromType == byte.class\n-                    || fromType == short.class\n-                    || fromType == char.class;\n-            \/\/ no-op in bytecode\n-\n-            assert toType == int.class;\n-            pushType(int.class);\n+            case INT_TO_BYTE -> mv.visitInsn(I2B);\n+            case INT_TO_CHAR -> mv.visitInsn(I2C);\n+            case INT_TO_SHORT -> mv.visitInsn(I2S);\n+            case BOOLEAN_TO_INT, BYTE_TO_INT, CHAR_TO_INT, SHORT_TO_INT -> {\n+                \/\/ no-op in bytecode\n+            }\n+            default -> throw new IllegalStateException(\"Unknown cast: \" + cast);\n@@ -713,0 +699,1 @@\n+        pushType(toType);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":17,"deletions":30,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-            throw new IllegalArgumentException(\"Multiple register return, but needsReturnBuffer was false\");\n+            throw new AssertionError(\"Multiple register return, but needsReturnBuffer was false\");\n@@ -78,1 +78,1 @@\n-            throw new IllegalArgumentException(\"Address expected as first param: \" + methodType);\n+            throw new AssertionError(\"Address expected as first param: \" + methodType);\n@@ -83,1 +83,1 @@\n-            throw new IllegalArgumentException(\"return buffer and\/or preserved value address expected: \" + methodType);\n+            throw new AssertionError(\"return buffer and\/or preserved value address expected: \" + methodType);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/NativeEntryPoint.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,2 +42,1 @@\n-import java.lang.foreign.MemorySession;\n-import java.lang.foreign.PaddingLayout;\n+import java.lang.foreign.SegmentScope;\n@@ -45,1 +44,0 @@\n-import java.lang.foreign.SequenceLayout;\n@@ -293,1 +291,1 @@\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, MemorySession session) {\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, SegmentScope session) {\n@@ -302,1 +300,1 @@\n-    public static VaList newVaListOfAddress(long address, MemorySession session) {\n+    public static VaList newVaListOfAddress(long address, SegmentScope session) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-    CAPTURED_STATE_MASK;\n+    CAPTURED_STATE_BUFFER;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/StubLocations.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -64,1 +64,1 @@\n-    public static MemorySegment make(ABIDescriptor abi, MethodHandle target, CallingSequence callingSequence, MemorySession session) {\n+    public static MemorySegment make(ABIDescriptor abi, MethodHandle target, CallingSequence callingSequence, SegmentScope session) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallLinker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -53,2 +53,2 @@\n-    static MemorySegment makeUpcall(long entry, MemorySession session) {\n-        MemorySessionImpl.toSessionImpl(session).addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n+    static MemorySegment makeUpcall(long entry, SegmentScope session) {\n+        ((MemorySessionImpl) session).addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallStubs.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -172,1 +172,1 @@\n-            StubLocations.CAPTURED_STATE_MASK.storage(StorageType.PLACEHOLDER));\n+            StubLocations.CAPTURED_STATE_BUFFER.storage(StorageType.PLACEHOLDER));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64Architecture.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -161,1 +161,1 @@\n-    public MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, MemorySession session) {\n+    public MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, SegmentScope session) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -64,1 +64,1 @@\n-    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, MemorySession scope) {\n+    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, SegmentScope scope) {\n@@ -68,1 +68,1 @@\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, MemorySession session) {\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, SegmentScope session) {\n@@ -74,1 +74,1 @@\n-    public static VaList newVaListOfAddress(long address, MemorySession session) {\n+    public static VaList newVaListOfAddress(long address, SegmentScope session) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -39,1 +39,0 @@\n-import jdk.internal.misc.Unsafe;\n@@ -58,1 +57,0 @@\n-    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n@@ -125,1 +123,1 @@\n-    private static LinuxAArch64VaList readFromAddress(long address, MemorySession session) {\n+    private static LinuxAArch64VaList readFromAddress(long address, SegmentScope session) {\n@@ -134,3 +132,1 @@\n-        long ptr = UNSAFE.allocateMemory(LAYOUT.byteSize());\n-        MemorySegment ms = MemorySegment.ofAddress(ptr, LAYOUT.byteSize(),\n-                MemorySession.implicit(), () -> UNSAFE.freeMemory(ptr));\n+        MemorySegment ms = MemorySegment.allocateNative(LAYOUT, SegmentScope.auto());\n@@ -142,1 +138,1 @@\n-        return ms;\n+        return ms.asSlice(0, 0);\n@@ -324,1 +320,1 @@\n-                    MemorySegment slice = MemorySegment.ofAddress(ptr.address(), layout.byteSize(), segment.session());\n+                    MemorySegment slice = MemorySegment.ofAddress(ptr.address(), layout.byteSize(), segment.scope());\n@@ -368,1 +364,1 @@\n-        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n+        ((MemorySessionImpl) segment.scope()).checkValidState();\n@@ -391,1 +387,1 @@\n-    static LinuxAArch64VaList.Builder builder(MemorySession session) {\n+    static LinuxAArch64VaList.Builder builder(SegmentScope session) {\n@@ -395,1 +391,1 @@\n-    public static VaList ofAddress(long address, MemorySession session) {\n+    public static VaList ofAddress(long address, SegmentScope session) {\n@@ -401,1 +397,1 @@\n-        MemorySegment copy = MemorySegment.allocateNative(LAYOUT, segment.session());\n+        MemorySegment copy = MemorySegment.allocateNative(LAYOUT, segment.scope());\n@@ -408,0 +404,1 @@\n+        \/\/ make sure that returned segment cannot be accessed\n@@ -438,1 +435,1 @@\n-        private final MemorySession session;\n+        private final SegmentScope session;\n@@ -446,1 +443,1 @@\n-        Builder(MemorySession session) {\n+        Builder(SegmentScope session) {\n@@ -566,2 +563,2 @@\n-            assert MemorySessionImpl.sameOwnerThread(gpRegs.session(), vaListSegment.session());\n-            assert MemorySessionImpl.sameOwnerThread(fpRegs.session(), vaListSegment.session());\n+            assert MemorySessionImpl.sameOwnerThread(gpRegs.scope(), vaListSegment.scope());\n+            assert MemorySessionImpl.sameOwnerThread(fpRegs.scope(), vaListSegment.scope());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64VaList.java","additions":14,"deletions":17,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -64,1 +64,1 @@\n-    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, MemorySession scope) {\n+    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, SegmentScope scope) {\n@@ -68,1 +68,1 @@\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, MemorySession session) {\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, SegmentScope session) {\n@@ -74,1 +74,1 @@\n-    public static VaList newVaListOfAddress(long address, MemorySession session) {\n+    public static VaList newVaListOfAddress(long address, SegmentScope session) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -108,1 +108,1 @@\n-                    MemorySegment struct = MemorySegment.ofAddress(structAddr.address(), layout.byteSize(), segment.session());\n+                    MemorySegment struct = MemorySegment.ofAddress(structAddr.address(), layout.byteSize(), segment.scope());\n@@ -143,1 +143,1 @@\n-        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n+        ((MemorySessionImpl) segment.scope()).checkValidState();\n@@ -159,1 +159,1 @@\n-    static MacOsAArch64VaList ofAddress(long address, MemorySession session) {\n+    static MacOsAArch64VaList ofAddress(long address, SegmentScope session) {\n@@ -164,1 +164,1 @@\n-    static Builder builder(MemorySession session) {\n+    static Builder builder(SegmentScope session) {\n@@ -170,1 +170,1 @@\n-        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n+        ((MemorySessionImpl) segment.scope()).checkValidState();\n@@ -176,0 +176,1 @@\n+        \/\/ make sure that returned segment cannot be accessed\n@@ -181,1 +182,1 @@\n-        private final MemorySession session;\n+        private final SegmentScope session;\n@@ -184,2 +185,2 @@\n-        public Builder(MemorySession session) {\n-            MemorySessionImpl.toSessionImpl(session).checkValidState();\n+        public Builder(SegmentScope session) {\n+            ((MemorySessionImpl) session).checkValidState();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64VaList.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -159,2 +159,2 @@\n-                        .mapToObj(X86_64Architecture::x87Storage)\n-                        .toArray(VMStorage[]::new)\n+                         .mapToObj(X86_64Architecture::x87Storage)\n+                         .toArray(VMStorage[]::new)\n@@ -171,1 +171,1 @@\n-            StubLocations.CAPTURED_STATE_MASK.storage(StorageType.PLACEHOLDER));\n+            StubLocations.CAPTURED_STATE_BUFFER.storage(StorageType.PLACEHOLDER));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/X86_64Architecture.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -135,1 +135,1 @@\n-    public static MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, MemorySession session) {\n+    public static MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, SegmentScope session) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -39,1 +39,0 @@\n-import jdk.internal.misc.Unsafe;\n@@ -54,1 +53,0 @@\n-    private static final Unsafe U = Unsafe.getUnsafe();\n@@ -135,1 +133,1 @@\n-    private static SysVVaList readFromAddress(long address, MemorySession session) {\n+    private static SysVVaList readFromAddress(long address, SegmentScope session) {\n@@ -143,3 +141,1 @@\n-        long ptr = U.allocateMemory(LAYOUT.byteSize());\n-        MemorySegment base = MemorySegment.ofAddress(ptr, LAYOUT.byteSize(),\n-                MemorySession.implicit(), () -> U.freeMemory(ptr));\n+        MemorySegment base = MemorySegment.allocateNative(LAYOUT, SegmentScope.auto());\n@@ -150,1 +146,1 @@\n-        return base;\n+        return base.asSlice(0, 0);\n@@ -313,1 +309,1 @@\n-        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n+        ((MemorySessionImpl) segment.scope()).checkValidState();\n@@ -329,1 +325,1 @@\n-    static SysVVaList.Builder builder(MemorySession session) {\n+    static SysVVaList.Builder builder(SegmentScope session) {\n@@ -333,1 +329,1 @@\n-    public static VaList ofAddress(long address, MemorySession session) {\n+    public static VaList ofAddress(long address, SegmentScope session) {\n@@ -339,1 +335,1 @@\n-        MemorySegment copy = MemorySegment.allocateNative(LAYOUT, segment.session());\n+        MemorySegment copy = MemorySegment.allocateNative(LAYOUT, segment.scope());\n@@ -346,0 +342,1 @@\n+        \/\/ make sure that returned segment cannot be accessed\n@@ -365,1 +362,1 @@\n-        private final MemorySession session;\n+        private final SegmentScope session;\n@@ -371,1 +368,1 @@\n-        public Builder(MemorySession session) {\n+        public Builder(SegmentScope session) {\n@@ -478,1 +475,1 @@\n-            assert MemorySessionImpl.sameOwnerThread(reg_save_area.session(), vaListSegment.session());\n+            assert MemorySessionImpl.sameOwnerThread(reg_save_area.scope(), vaListSegment.scope());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":12,"deletions":15,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -55,0 +55,1 @@\n+\n@@ -61,1 +62,1 @@\n-    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, MemorySession scope) {\n+    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, SegmentScope scope) {\n@@ -65,1 +66,1 @@\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, MemorySession scope) {\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, SegmentScope scope) {\n@@ -71,1 +72,1 @@\n-    public static VaList newVaListOfAddress(long address, MemorySession session) {\n+    public static VaList newVaListOfAddress(long address, SegmentScope session) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -178,4 +178,4 @@\n-            if (type instanceof ValueLayout) {\n-                return ofValue((ValueLayout)type);\n-            } else if (type instanceof GroupLayout) {\n-                return ofStruct((GroupLayout)type);\n+            if (type instanceof ValueLayout valueLayout) {\n+                return ofValue(valueLayout);\n+            } else if (type instanceof GroupLayout groupLayout) {\n+                return ofStruct(groupLayout);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/TypeClass.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -134,1 +134,1 @@\n-    public static MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, MemorySession session) {\n+    public static MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, SegmentScope session) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -118,1 +118,1 @@\n-                    MemorySegment struct = MemorySegment.ofAddress(structAddr.address(), layout.byteSize(), segment.session());\n+                    MemorySegment struct = MemorySegment.ofAddress(structAddr.address(), layout.byteSize(), segment.scope());\n@@ -144,1 +144,1 @@\n-        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n+        ((MemorySessionImpl) segment.scope()).checkValidState();\n@@ -152,1 +152,1 @@\n-    static WinVaList ofAddress(long address, MemorySession session) {\n+    static WinVaList ofAddress(long address, SegmentScope session) {\n@@ -156,1 +156,1 @@\n-    static Builder builder(MemorySession session) {\n+    static Builder builder(SegmentScope session) {\n@@ -162,1 +162,1 @@\n-        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n+        ((MemorySessionImpl) segment.scope()).checkValidState();\n@@ -168,0 +168,1 @@\n+        \/\/ make sure that returned segment cannot be accessed\n@@ -173,1 +174,1 @@\n-        private final MemorySession session;\n+        private final SegmentScope session;\n@@ -176,2 +177,2 @@\n-        public Builder(MemorySession session) {\n-            MemorySessionImpl.toSessionImpl(session).checkValidState();\n+        public Builder(SegmentScope session) {\n+            ((MemorySessionImpl) session).checkValidState();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -61,1 +61,1 @@\n-    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, MemorySession scope) {\n+    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, SegmentScope scope) {\n@@ -65,1 +65,1 @@\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, MemorySession scope) {\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, SegmentScope scope) {\n@@ -71,1 +71,1 @@\n-    public static VaList newVaListOfAddress(long address, MemorySession session) {\n+    public static VaList newVaListOfAddress(long address, SegmentScope session) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.io;\n+\n+import java.io.PrintWriter;\n+import java.io.Reader;\n+import java.nio.charset.Charset;\n+\n+\/**\n+ * Delegate interface for custom Console implementations.\n+ * Methods defined here duplicates the ones in Console class.\n+ * Providers should implement jdk.internal.io.JdkConsoleProvider\n+ * to instantiate an implementation of this interface.\n+ *\/\n+public interface JdkConsole {\n+    PrintWriter writer();\n+    Reader reader();\n+    JdkConsole format(String fmt, Object ... args);\n+    JdkConsole printf(String format, Object ... args);\n+    String readLine(String fmt, Object ... args);\n+    String readLine();\n+    char[] readPassword(String fmt, Object ... args);\n+    char[] readPassword();\n+    void flush();\n+    Charset charset();\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/io\/JdkConsole.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.io;\n+\n+import java.nio.charset.Charset;\n+\n+\/**\n+ * Service provider interface for JdkConsole implementations.\n+ * The provider used for instantiating JdkConsole instance can be\n+ * specified with the system property \"jdk.console\", whose value\n+ * designates the module name of the implementation, and which defaults\n+ * to \"jdk.internal.le\" (jline). If no providers is available,\n+ * or instantiation failed, java.base built-in Console implementation\n+ * is used.\n+ *\/\n+public interface JdkConsoleProvider {\n+    \/**\n+     * The module name of the JdkConsole default provider.\n+     *\/\n+    String DEFAULT_PROVIDER_MODULE_NAME = \"jdk.internal.le\";\n+\n+    \/**\n+     * {@return the Console instance, or {@code null} if not available}\n+     * @param isTTY indicates if the jvm is attached to a terminal\n+     * @param charset charset of the platform console\n+     *\/\n+    JdkConsole console(boolean isTTY, Charset charset);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/io\/JdkConsoleProvider.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -71,1 +71,1 @@\n-        @JEP(number=425, title=\"Virtual Threads\")\n+        @JEP(number=436, title=\"Virtual Threads\", status=\"Second Preview\")\n@@ -73,1 +73,1 @@\n-        @JEP(number=424, title=\"Foreign Function & Memory API\")\n+        @JEP(number=434, title=\"Foreign Function & Memory API\", status=\"Second Preview\")\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-import jdk.internal.vm.ExtentLocalContainer;\n+import jdk.internal.vm.ScopedValueContainer;\n@@ -102,1 +102,1 @@\n-    private final ExtentLocalContainer.BindingsSnapshot extentLocalBindings;\n+    private final ScopedValueContainer.BindingsSnapshot scopedValueBindings;\n@@ -114,1 +114,1 @@\n-        this.extentLocalBindings = ExtentLocalContainer.captureBindings();\n+        this.scopedValueBindings = ScopedValueContainer.captureBindings();\n@@ -122,2 +122,2 @@\n-    private ExtentLocalContainer.BindingsSnapshot extentLocalBindings() {\n-        return extentLocalBindings;\n+    private ScopedValueContainer.BindingsSnapshot scopedValueBindings() {\n+        return scopedValueBindings;\n@@ -213,1 +213,1 @@\n-     * <p> This method captures the current thread's {@linkplain ExtentLocal extent-local}\n+     * <p> This method captures the current thread's {@linkplain ScopedValue scoped value}\n@@ -253,1 +253,1 @@\n-     * <p> The thread is started with the extent-local bindings that were captured\n+     * <p> The thread is started with the scoped value bindings that were captured\n@@ -266,1 +266,1 @@\n-     * extent-local bindings are not the same as when the flock was created\n+     * scoped value bindings are not the same as when the flock was created\n@@ -401,6 +401,5 @@\n-     * closes this flock, and then throws {@link\n-     * jdk.incubator.concurrent.StructureViolationException}.\n-     * Similarly, if called to close a flock that <em>encloses<\/em> {@linkplain\n-     * jdk.incubator.concurrent.ExtentLocal.Carrier#run(Runnable) operations} with\n-     * extent-local bindings then it also throws {@code StructureViolationException}\n-     * after closing the flock.\n+     * closes this flock, and then throws {@code StructureViolationException}.\n+     * Similarly, if this method is called to close a thread flock while executing with\n+     * scoped value bindings, and the thread flock was created before the scoped values\n+     * were bound, then {@code StructureViolationException} is thrown after closing the\n+     * thread flock.\n@@ -588,2 +587,2 @@\n-        public ExtentLocalContainer.BindingsSnapshot extentLocalBindings() {\n-            return flock.extentLocalBindings();\n+        public ScopedValueContainer.BindingsSnapshot scopedValueBindings() {\n+            return flock.scopedValueBindings();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/ThreadFlock.java","additions":15,"deletions":16,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -229,1 +229,1 @@\n-        if (checkClassVersion && readShort(classFileOffset + 6) > Opcodes.V20) {\n+        if (checkClassVersion && readShort(classFileOffset + 6) > Opcodes.V21) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/ClassReader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -313,0 +313,1 @@\n+    int V21 = 0 << 16 | 65;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Opcodes.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-    private static final boolean PRESERVE_EXTENT_LOCAL_CACHE;\n+    private static final boolean PRESERVE_SCOPED_VALUE_CACHE;\n@@ -57,2 +57,2 @@\n-        String value = GetPropertyAction.privilegedGetProperty(\"jdk.preserveExtentLocalCache\");\n-        PRESERVE_EXTENT_LOCAL_CACHE = (value == null) || Boolean.parseBoolean(value);\n+        String value = GetPropertyAction.privilegedGetProperty(\"jdk.preserveScopedValueCache\");\n+        PRESERVE_SCOPED_VALUE_CACHE = (value == null) || Boolean.parseBoolean(value);\n@@ -132,1 +132,1 @@\n-    private Object[] extentLocalCache;\n+    private Object[] scopedValueCache;\n@@ -241,1 +241,1 @@\n-            JLA.setExtentLocalCache(extentLocalCache);\n+            JLA.setScopedValueCache(scopedValueCache);\n@@ -273,2 +273,2 @@\n-                    if (PRESERVE_EXTENT_LOCAL_CACHE) {\n-                        extentLocalCache = JLA.extentLocalCache();\n+                    if (PRESERVE_SCOPED_VALUE_CACHE) {\n+                        scopedValueCache = JLA.scopedValueCache();\n@@ -276,1 +276,1 @@\n-                        extentLocalCache = null;\n+                        scopedValueCache = null;\n@@ -278,1 +278,1 @@\n-                    JLA.setExtentLocalCache(null);\n+                    JLA.setScopedValueCache(null);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/Continuation.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1,216 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.vm;\n-\n-import java.util.concurrent.Callable;\n-import jdk.internal.access.JavaLangAccess;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.misc.StructureViolationExceptions;\n-import jdk.internal.misc.Unsafe;\n-import jdk.internal.vm.annotation.DontInline;\n-import jdk.internal.vm.annotation.ReservedStackAccess;\n-\n-\/**\n- * A StackableScope to represent extent-local bindings.\n- *\n- * This class defines static methods to run an operation with a ExtentLocalContainer\n- * on the scope stack. It also defines a method to get the latest ExtentLocalContainer\n- * and a method to return a snapshot of the extent local bindings.\n- *\/\n-public class ExtentLocalContainer extends StackableScope {\n-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n-    static {\n-        Unsafe.getUnsafe().ensureClassInitialized(StructureViolationExceptions.class);\n-    }\n-\n-    private ExtentLocalContainer() {\n-    }\n-\n-    \/**\n-     * Returns the \"latest\" ExtentLocalContainer for the current Thread. This may be on\n-     * the current thread's scope task or ma require walking up the tree to find it.\n-     *\/\n-    public static <T extends ExtentLocalContainer> T latest(Class<T> containerClass) {\n-        StackableScope scope = head();\n-        if (scope == null) {\n-            scope = JLA.threadContainer(Thread.currentThread());\n-            if (scope == null || scope.owner() == null)\n-                return null;\n-        }\n-        if (containerClass.isInstance(scope)) {\n-            @SuppressWarnings(\"unchecked\")\n-            T tmp = (T) scope;\n-            return tmp;\n-        } else {\n-            return scope.enclosingScope(containerClass);\n-        }\n-    }\n-\n-    \/**\n-     * Returns the \"latest\" ExtentLocalContainer for the current Thread. This\n-     * may be on the current thread's scope task or may require walking up the\n-     * tree to find it.\n-     *\/\n-    public static ExtentLocalContainer latest() {\n-        return latest(ExtentLocalContainer.class);\n-    }\n-\n-    \/**\n-     * A snapshot of the extent local bindings. The snapshot includes the bindings\n-     * established for the current thread and extent local container.\n-     *\/\n-    public record BindingsSnapshot(Object extentLocalBindings,\n-                                   ExtentLocalContainer container) { }\n-\n-    \/**\n-     * Returns the extent local bindings for the current thread.\n-     *\/\n-    public static BindingsSnapshot captureBindings() {\n-        return new BindingsSnapshot(JLA.extentLocalBindings(), latest());\n-    }\n-\n-    \/**\n-     * For use by ExtentLocal to run an operation in a structured context.\n-     *\/\n-    public static void run(Runnable op) {\n-        if (head() == null) {\n-            \/\/ no need to push scope when stack is empty\n-            runWithoutScope(op);\n-        } else {\n-            new ExtentLocalContainer().doRun(op);\n-        }\n-    }\n-\n-    \/**\n-     * Run an operation without a scope on the stack.\n-     *\/\n-    private static void runWithoutScope(Runnable op) {\n-        assert head() == null;\n-        Throwable ex;\n-        boolean atTop;\n-        try {\n-            op.run();\n-            ex = null;\n-        } catch (Throwable e) {\n-            ex = e;\n-        } finally {\n-            atTop = (head() == null);\n-            if (!atTop) popAll();   \/\/ may block\n-        }\n-        throwIfFailed(ex, atTop);\n-    }\n-\n-    \/**\n-     * Run an operation with this scope on the stack.\n-     *\/\n-    private void doRun(Runnable op) {\n-        Throwable ex;\n-        boolean atTop;\n-        push();\n-        try {\n-            op.run();\n-            ex = null;\n-        } catch (Throwable e) {\n-            ex = e;\n-        } finally {\n-            atTop = popForcefully();  \/\/ may block\n-        }\n-        throwIfFailed(ex, atTop);\n-    }\n-\n-    \/**\n-     * For use by ExtentLocal to call a value returning operation in a structured context.\n-     *\/\n-    public static <V> V call(Callable<V> op) throws Exception {\n-        if (head() == null) {\n-            \/\/ no need to push scope when stack is empty\n-            return callWithoutScope(op);\n-        } else {\n-            return new ExtentLocalContainer().doCall(op);\n-        }\n-    }\n-\n-    \/**\n-     * Call an operation without a scope on the stack.\n-     *\/\n-    private static <V> V callWithoutScope(Callable<V> op) {\n-        assert head() == null;\n-        Throwable ex;\n-        boolean atTop;\n-        V result;\n-        try {\n-            result = op.call();\n-            ex = null;\n-        } catch (Throwable e) {\n-            result = null;\n-            ex = e;\n-        } finally {\n-            atTop = (head() == null);\n-            if (!atTop) popAll();  \/\/ may block\n-        }\n-        throwIfFailed(ex, atTop);\n-        return result;\n-    }\n-\n-    \/**\n-     * Call an operation with this scope on the stack.\n-     *\/\n-    private <V> V doCall(Callable<V> op) {\n-        Throwable ex;\n-        boolean atTop;\n-        V result;\n-        push();\n-        try {\n-            result = op.call();\n-            ex = null;\n-        } catch (Throwable e) {\n-            result = null;\n-            ex = e;\n-        } finally {\n-            atTop = popForcefully();  \/\/ may block\n-        }\n-        throwIfFailed(ex, atTop);\n-        return result;\n-    }\n-\n-    \/**\n-     * Throws {@code ex} if not null. StructureViolationException is thrown or added\n-     * as a suppressed exception when {@code atTop} is false.\n-     *\/\n-    @DontInline @ReservedStackAccess\n-    private static void throwIfFailed(Throwable ex, boolean atTop) {\n-        if (ex != null || !atTop) {\n-            if (!atTop) {\n-                var sve = StructureViolationExceptions.newException();\n-                if (ex == null) {\n-                    ex = sve;\n-                } else {\n-                    ex.addSuppressed(sve);\n-                }\n-            }\n-            Unsafe.getUnsafe().throwException(ex);\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ExtentLocalContainer.java","additions":0,"deletions":216,"binary":false,"changes":216,"status":"deleted"},{"patch":"@@ -0,0 +1,215 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.vm;\n+\n+import java.util.concurrent.Callable;\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.misc.StructureViolationExceptions;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.DontInline;\n+import jdk.internal.vm.annotation.ReservedStackAccess;\n+\n+\/**\n+ * A StackableScope to represent scoped-value bindings.\n+ *\n+ * This class defines static methods to run an operation with a ScopedValueContainer\n+ * on the scope stack. It also defines a method to get the latest ScopedValueContainer\n+ * and a method to return a snapshot of the scoped value bindings.\n+ *\/\n+public class ScopedValueContainer extends StackableScope {\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+    static {\n+        Unsafe.getUnsafe().ensureClassInitialized(StructureViolationExceptions.class);\n+    }\n+\n+    private ScopedValueContainer() {\n+    }\n+\n+    \/**\n+     * Returns the \"latest\" ScopedValueContainer for the current Thread. This may be on\n+     * the current thread's scope task or may require walking up the tree to find it.\n+     *\/\n+    public static <T extends ScopedValueContainer> T latest(Class<T> containerClass) {\n+        StackableScope scope = head();\n+        if (scope == null) {\n+            scope = JLA.threadContainer(Thread.currentThread());\n+            if (scope == null || scope.owner() == null)\n+                return null;\n+        }\n+        if (containerClass.isInstance(scope)) {\n+            @SuppressWarnings(\"unchecked\")\n+            T tmp = (T) scope;\n+            return tmp;\n+        } else {\n+            return scope.enclosingScope(containerClass);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the \"latest\" ScopedValueContainer for the current Thread. This\n+     * may be on the current thread's scope task or may require walking up the\n+     * tree to find it.\n+     *\/\n+    public static ScopedValueContainer latest() {\n+        return latest(ScopedValueContainer.class);\n+    }\n+\n+    \/**\n+     * A snapshot of the scoped value bindings. The snapshot includes the bindings\n+     * established for the current thread and scoped value container.\n+     *\/\n+    public record BindingsSnapshot(Object scopedValueBindings,\n+                                   ScopedValueContainer container) { }\n+\n+    \/**\n+     * Returns the scoped value bindings for the current thread.\n+     *\/\n+    public static BindingsSnapshot captureBindings() {\n+        return new BindingsSnapshot(JLA.scopedValueBindings(), latest());\n+    }\n+\n+    \/**\n+     * For use by ScopedValue to run an operation in a structured context.\n+     *\/\n+    public static void run(Runnable op) {\n+        if (head() == null) {\n+            \/\/ no need to push scope when stack is empty\n+            runWithoutScope(op);\n+        } else {\n+            new ScopedValueContainer().doRun(op);\n+        }\n+    }\n+\n+    \/**\n+     * Run an operation without a scope on the stack.\n+     *\/\n+    private static void runWithoutScope(Runnable op) {\n+        assert head() == null;\n+        Throwable ex;\n+        boolean atTop;\n+        try {\n+            op.run();\n+            ex = null;\n+        } catch (Throwable e) {\n+            ex = e;\n+        } finally {\n+            atTop = (head() == null);\n+            if (!atTop) popAll();   \/\/ may block\n+        }\n+        throwIfFailed(ex, atTop);\n+    }\n+\n+    \/**\n+     * Run an operation with this scope on the stack.\n+     *\/\n+    private void doRun(Runnable op) {\n+        Throwable ex;\n+        boolean atTop;\n+        push();\n+        try {\n+            op.run();\n+            ex = null;\n+        } catch (Throwable e) {\n+            ex = e;\n+        } finally {\n+            atTop = popForcefully();  \/\/ may block\n+        }\n+        throwIfFailed(ex, atTop);\n+    }\n+\n+    \/**\n+     * For use by ScopedValue to call a value returning operation in a structured context.\n+     *\/\n+    public static <V> V call(Callable<V> op) throws Exception {\n+        if (head() == null) {\n+            \/\/ no need to push scope when stack is empty\n+            return callWithoutScope(op);\n+        } else {\n+            return new ScopedValueContainer().doCall(op);\n+        }\n+    }\n+\n+    \/**\n+     * Call an operation without a scope on the stack.\n+     *\/\n+    private static <V> V callWithoutScope(Callable<V> op) {\n+        assert head() == null;\n+        Throwable ex;\n+        boolean atTop;\n+        V result;\n+        try {\n+            result = op.call();\n+            ex = null;\n+        } catch (Throwable e) {\n+            result = null;\n+            ex = e;\n+        } finally {\n+            atTop = (head() == null);\n+            if (!atTop) popAll();  \/\/ may block\n+        }\n+        throwIfFailed(ex, atTop);\n+        return result;\n+    }\n+\n+    \/**\n+     * Call an operation with this scope on the stack.\n+     *\/\n+    private <V> V doCall(Callable<V> op) {\n+        Throwable ex;\n+        boolean atTop;\n+        V result;\n+        push();\n+        try {\n+            result = op.call();\n+            ex = null;\n+        } catch (Throwable e) {\n+            result = null;\n+            ex = e;\n+        } finally {\n+            atTop = popForcefully();  \/\/ may block\n+        }\n+        throwIfFailed(ex, atTop);\n+        return result;\n+    }\n+\n+    \/**\n+     * Throws {@code ex} if not null. StructureViolationException is thrown or added\n+     * as a suppressed exception when {@code atTop} is false.\n+     *\/\n+    private static void throwIfFailed(Throwable ex, boolean atTop) {\n+        if (ex != null || !atTop) {\n+            if (!atTop) {\n+                var sve = StructureViolationExceptions.newException();\n+                if (ex == null) {\n+                    ex = sve;\n+                } else {\n+                    ex.addSuppressed(sve);\n+                }\n+            }\n+            Unsafe.getUnsafe().throwException(ex);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ScopedValueContainer.java","additions":215,"deletions":0,"binary":false,"changes":215,"status":"added"},{"patch":"@@ -92,1 +92,1 @@\n-     * The extent locals captured when the thread container was created.\n+     * The scoped values captured when the thread container was created.\n@@ -94,1 +94,1 @@\n-    public ExtentLocalContainer.BindingsSnapshot extentLocalBindings() {\n+    public ScopedValueContainer.BindingsSnapshot scopedValueBindings() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ThreadContainer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,299 @@\n+\/*\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.vm;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.zip.GZIPInputStream;\n+import java.util.zip.GZIPOutputStream;\n+\n+\/**\n+ * Support for translating exceptions between the HotSpot heap and libjvmci heap.\n+ *\/\n+@SuppressWarnings(\"serial\")\n+final class TranslatedException extends Exception {\n+\n+    \/**\n+     * The value returned by {@link #encodeThrowable(Throwable)} when encoding\n+     * fails due to an {@link OutOfMemoryError}.\n+     *\/\n+    private static final byte[] FALLBACK_ENCODED_OUTOFMEMORYERROR_BYTES;\n+\n+    \/**\n+     * The value returned by {@link #encodeThrowable(Throwable)} when encoding\n+     * fails for any reason other than {@link OutOfMemoryError}.\n+     *\/\n+    private static final byte[] FALLBACK_ENCODED_THROWABLE_BYTES;\n+    static {\n+        try {\n+            FALLBACK_ENCODED_THROWABLE_BYTES =\n+                encodeThrowable(new TranslatedException(\"error during encoding\",\n+                                                        \"<unknown>\"), false);\n+            FALLBACK_ENCODED_OUTOFMEMORYERROR_BYTES =\n+                encodeThrowable(new OutOfMemoryError(), false);\n+        } catch (IOException e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    \/**\n+     * Class name of exception that could not be instantiated.\n+     *\/\n+    private String originalExceptionClassName;\n+\n+    private TranslatedException(String message, String originalExceptionClassName) {\n+        super(message);\n+        this.originalExceptionClassName = originalExceptionClassName;\n+    }\n+\n+    \/**\n+     * No need to record an initial stack trace since\n+     * it will be manually overwritten.\n+     *\/\n+    @SuppressWarnings(\"sync-override\")\n+    @Override\n+    public Throwable fillInStackTrace() {\n+        return this;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String s;\n+        if (originalExceptionClassName.equals(TranslatedException.class.getName())) {\n+            s = getClass().getName();\n+        } else {\n+            s = getClass().getName() + \"[\" + originalExceptionClassName + \"]\";\n+        }\n+        String message = getMessage();\n+        return (message != null) ? (s + \": \" + message) : s;\n+    }\n+\n+    \/**\n+     * Prints a stack trace for {@code throwable} if the system property\n+     * {@code \"jdk.internal.vm.TranslatedException.debug\"} is true.\n+     *\/\n+    private static void debugPrintStackTrace(Throwable throwable) {\n+        if (Boolean.getBoolean(\"jdk.internal.vm.TranslatedException.debug\")) {\n+            System.err.print(\"DEBUG: \");\n+            throwable.printStackTrace();\n+        }\n+    }\n+\n+    private static Throwable initCause(Throwable throwable, Throwable cause) {\n+        if (cause != null) {\n+            try {\n+                throwable.initCause(cause);\n+            } catch (IllegalStateException e) {\n+                \/\/ Cause could not be set or overwritten.\n+                debugPrintStackTrace(e);\n+            }\n+        }\n+        return throwable;\n+    }\n+\n+    private static Throwable create(String className, String message, Throwable cause) {\n+        \/\/ Try create with reflection first.\n+        try {\n+            Class<?> cls = Class.forName(className);\n+            if (cause != null) {\n+                \/\/ Handle known exception types whose cause must\n+                \/\/ be set in the constructor\n+                if (cls == InvocationTargetException.class) {\n+                    return new InvocationTargetException(cause, message);\n+                }\n+                if (cls == ExceptionInInitializerError.class) {\n+                    return new ExceptionInInitializerError(cause);\n+                }\n+            }\n+            if (message == null) {\n+                Constructor<?> cons = cls.getConstructor();\n+                return initCause((Throwable) cons.newInstance(), cause);\n+            }\n+            Constructor<?> cons = cls.getDeclaredConstructor(String.class);\n+            return initCause((Throwable) cons.newInstance(message), cause);\n+        } catch (Throwable translationFailure) {\n+            debugPrintStackTrace(translationFailure);\n+            return initCause(new TranslatedException(message, className), cause);\n+        }\n+    }\n+\n+    private static String emptyIfNull(String value) {\n+        return value == null ? \"\" : value;\n+    }\n+\n+    private static String emptyAsNull(String value) {\n+        return value.isEmpty() ? null : value;\n+    }\n+\n+    \/**\n+     * Encodes {@code throwable} including its stack and causes as a {@linkplain GZIPOutputStream\n+     * compressed} byte array that can be decoded by {@link #decodeThrowable}.\n+     *\/\n+    static byte[] encodeThrowable(Throwable throwable) {\n+        try {\n+            return encodeThrowable(throwable, true);\n+        } catch (OutOfMemoryError e) {\n+            return FALLBACK_ENCODED_OUTOFMEMORYERROR_BYTES;\n+        } catch (Throwable e) {\n+            return FALLBACK_ENCODED_THROWABLE_BYTES;\n+        }\n+    }\n+\n+    private static byte[] encodeThrowable(Throwable throwable,\n+                                          boolean withCauseAndStack) throws IOException {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        try (DataOutputStream dos = new DataOutputStream(new GZIPOutputStream(baos))) {\n+            List<Throwable> throwables = new ArrayList<>();\n+            for (Throwable current = throwable; current != null; current = current.getCause()) {\n+                throwables.add(current);\n+                if (!withCauseAndStack) {\n+                    break;\n+                }\n+            }\n+\n+            \/\/ Encode from inner most cause outwards\n+            Collections.reverse(throwables);\n+\n+            for (Throwable current : throwables) {\n+                dos.writeUTF(current.getClass().getName());\n+                dos.writeUTF(emptyIfNull(current.getMessage()));\n+                StackTraceElement[] stackTrace = withCauseAndStack ? current.getStackTrace() : null;\n+                if (stackTrace == null) {\n+                    stackTrace = new StackTraceElement[0];\n+                }\n+                dos.writeInt(stackTrace.length);\n+                for (int i = 0; i < stackTrace.length; i++) {\n+                    StackTraceElement frame = stackTrace[i];\n+                    if (frame != null) {\n+                        dos.writeUTF(emptyIfNull(frame.getClassLoaderName()));\n+                        dos.writeUTF(emptyIfNull(frame.getModuleName()));\n+                        dos.writeUTF(emptyIfNull(frame.getModuleVersion()));\n+                        dos.writeUTF(emptyIfNull(frame.getClassName()));\n+                        dos.writeUTF(emptyIfNull(frame.getMethodName()));\n+                        dos.writeUTF(emptyIfNull(frame.getFileName()));\n+                        dos.writeInt(frame.getLineNumber());\n+                    }\n+                }\n+            }\n+        }\n+        return baos.toByteArray();\n+    }\n+\n+    \/**\n+     * Gets the stack of the current thread as of the first native method. The chopped\n+     * frames are for the VM call to {@link VMSupport#decodeAndThrowThrowable}.\n+     *\/\n+    private static StackTraceElement[] getMyStackTrace() {\n+        Exception ex = new Exception();\n+        StackTraceElement[] stack = ex.getStackTrace();\n+        for (int i = 0; i < stack.length; i++) {\n+            StackTraceElement e = stack[i];\n+            if (e.isNativeMethod()) {\n+                return Arrays.copyOfRange(stack, i, stack.length);\n+            }\n+        }\n+        \/\/ This should never happen but since this is exception handling\n+        \/\/ code, be defensive instead raising a nested exception.\n+        return new StackTraceElement[0];\n+    }\n+\n+    \/**\n+     * Decodes {@code encodedThrowable} into a {@link TranslatedException}.\n+     *\n+     * @param encodedThrowable an encoded exception in the format specified by\n+     *            {@link #encodeThrowable}\n+     *\/\n+    static Throwable decodeThrowable(byte[] encodedThrowable) {\n+        ByteArrayInputStream bais = new ByteArrayInputStream(encodedThrowable);\n+        try (DataInputStream dis = new DataInputStream(new GZIPInputStream(bais))) {\n+            Throwable cause = null;\n+            Throwable throwable = null;\n+            StackTraceElement[] myStack = getMyStackTrace();\n+            while (dis.available() != 0) {\n+                String exceptionClassName = dis.readUTF();\n+                String exceptionMessage = emptyAsNull(dis.readUTF());\n+                throwable = create(exceptionClassName, exceptionMessage, cause);\n+                int stackTraceDepth = dis.readInt();\n+                StackTraceElement[] stackTrace = new StackTraceElement[stackTraceDepth + myStack.length];\n+                int stackTraceIndex = 0;\n+                int myStackIndex = 0;\n+                for (int j = 0; j < stackTraceDepth; j++) {\n+                    String classLoaderName = emptyAsNull(dis.readUTF());\n+                    String moduleName = emptyAsNull(dis.readUTF());\n+                    String moduleVersion = emptyAsNull(dis.readUTF());\n+                    String className = emptyAsNull(dis.readUTF());\n+                    String methodName = emptyAsNull(dis.readUTF());\n+                    String fileName = emptyAsNull(dis.readUTF());\n+                    int lineNumber = dis.readInt();\n+                    StackTraceElement ste = new StackTraceElement(classLoaderName,\n+                                                                  moduleName,\n+                                                                  moduleVersion,\n+                                                                  className,\n+                                                                  methodName,\n+                                                                  fileName,\n+                                                                  lineNumber);\n+\n+                    if (ste.isNativeMethod()) {\n+                        \/\/ Best effort attempt to weave stack traces from two heaps into\n+                        \/\/ a single stack trace using native method frames as stitching points.\n+                        \/\/ This is not 100% reliable as there's no guarantee that native method\n+                        \/\/ frames only exist for calls between HotSpot and libjvmci.\n+                        while (myStackIndex < myStack.length) {\n+                            StackTraceElement suffixSTE = myStack[myStackIndex++];\n+                            if (suffixSTE.isNativeMethod()) {\n+                                break;\n+                            }\n+                            stackTrace[stackTraceIndex++] = suffixSTE;\n+                        }\n+                    }\n+                    stackTrace[stackTraceIndex++] = ste;\n+                }\n+                while (myStackIndex < myStack.length) {\n+                    stackTrace[stackTraceIndex++] = myStack[myStackIndex++];\n+                }\n+                if (stackTraceIndex != stackTrace.length) {\n+                    \/\/ Remove null entries at end of stackTrace\n+                    stackTrace = Arrays.copyOf(stackTrace, stackTraceIndex);\n+                }\n+                throwable.setStackTrace(stackTrace);\n+                cause = throwable;\n+            }\n+            return throwable;\n+        } catch (Throwable translationFailure) {\n+            debugPrintStackTrace(translationFailure);\n+            return new TranslatedException(\"Error decoding exception: \" + encodedThrowable,\n+                                           translationFailure.getClass().getName());\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/TranslatedException.java","additions":299,"deletions":0,"binary":false,"changes":299,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,3 @@\n+import jdk.internal.misc.VM;\n+import jdk.internal.misc.Unsafe;\n+\n@@ -36,1 +39,1 @@\n- * Support class used by JVMTI and VM attach mechanism.\n+ * Support class used by JVMCI, JVMTI and VM attach mechanism.\n@@ -40,0 +43,1 @@\n+    private static final Unsafe U = Unsafe.getUnsafe();\n@@ -41,0 +45,1 @@\n+\n@@ -54,3 +59,2 @@\n-     * Write the given properties list to a byte array and return it. Properties with\n-     * a key or value that is not a String is filtered out. The stream written to the byte\n-     * array is ISO 8859-1 encoded.\n+     * Writes the given properties list to a byte array and return it. The stream written\n+     * to the byte array is ISO 8859-1 encoded.\n@@ -60,0 +64,3 @@\n+        p.store(out, null);\n+        return out.toByteArray();\n+    }\n@@ -61,0 +68,5 @@\n+    \/**\n+     * @returns a Properties object containing only the entries in {@code p}\n+     *          whose key and value are both Strings\n+     *\/\n+    private static Properties onlyStrings(Properties p) {\n@@ -69,3 +81,1 @@\n-\n-        props.store(out, null);\n-        return out.toByteArray();\n+        return props;\n@@ -75,1 +85,1 @@\n-        return serializePropertiesToByteArray(System.getProperties());\n+        return serializePropertiesToByteArray(onlyStrings(System.getProperties()));\n@@ -79,1 +89,14 @@\n-        return serializePropertiesToByteArray(getAgentProperties());\n+        return serializePropertiesToByteArray(onlyStrings(getAgentProperties()));\n+    }\n+\n+    \/**\n+     * Serializes {@link VM#getSavedProperties()} to a byte array.\n+     *\n+     * Used by JVMCI to copy properties into libjvmci.\n+     *\/\n+    public static byte[] serializeSavedPropertiesToByteArray() throws IOException {\n+        Properties props = new Properties();\n+        for (var e : VM.getSavedProperties().entrySet()) {\n+            props.put(e.getKey(), e.getValue());\n+        }\n+        return serializePropertiesToByteArray(props);\n@@ -91,0 +114,36 @@\n+\n+    \/**\n+     * Decodes the exception encoded in {@code buffer} and throws it.\n+     *\n+     * @param buffer a native byte buffer containing an exception encoded by\n+     *            {@link #encodeThrowable}\n+     *\/\n+    public static void decodeAndThrowThrowable(long buffer) throws Throwable {\n+        int encodingLength = U.getInt(buffer);\n+        byte[] encoding = new byte[encodingLength];\n+        U.copyMemory(null, buffer + 4, encoding, Unsafe.ARRAY_BYTE_BASE_OFFSET, encodingLength);\n+        throw TranslatedException.decodeThrowable(encoding);\n+    }\n+\n+    \/**\n+     * If {@code bufferSize} is large enough, encodes {@code throwable} into a byte array and writes\n+     * it to {@code buffer}. The encoding in {@code buffer} can be decoded by\n+     * {@link #decodeAndThrowThrowable}.\n+     *\n+     * @param throwable the exception to encode\n+     * @param buffer a native byte buffer\n+     * @param bufferSize the size of {@code buffer} in bytes\n+     * @return the number of bytes written into {@code buffer} if {@code bufferSize} is large\n+     *         enough, otherwise {@code -N} where {@code N} is the value {@code bufferSize} needs to\n+     *         be to fit the encoding\n+     *\/\n+    public static int encodeThrowable(Throwable throwable, long buffer, int bufferSize) {\n+        byte[] encoding = TranslatedException.encodeThrowable(throwable);\n+        int requiredSize = 4 + encoding.length;\n+        if (bufferSize < requiredSize) {\n+            return -requiredSize;\n+        }\n+        U.putInt(buffer, encoding.length);\n+        U.copyMemory(encoding, Unsafe.ARRAY_BYTE_BASE_OFFSET, null, buffer + 4, encoding.length);\n+        return requiredSize;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/VMSupport.java","additions":69,"deletions":10,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -169,1 +169,4 @@\n-        jdk.net;\n+        jdk.net,\n+        jdk.incubator.concurrent,\n+        jdk.sctp,\n+        jdk.crypto.cryptoki;\n@@ -174,0 +177,3 @@\n+    exports jdk.internal.io to\n+        jdk.internal.le,\n+        jdk.jshell;\n@@ -248,0 +254,1 @@\n+        jdk.incubator.concurrent,\n@@ -254,0 +261,1 @@\n+        jdk.incubator.concurrent,\n@@ -308,1 +316,2 @@\n-        jdk.crypto.ec;\n+        jdk.crypto.ec,\n+        jdk.incubator.concurrent;\n@@ -406,0 +415,1 @@\n+    uses jdk.internal.io.JdkConsoleProvider;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -116,4 +116,0 @@\n-    public static String unparse(MethodType type) {\n-        return unparseMethod(type.returnType(), type.parameterArray());\n-    }\n-\n@@ -124,1 +120,1 @@\n-            return unparse((MethodType) type);\n+            return ((MethodType) type).toMethodDescriptorString();\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/BytecodeDescriptor.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -345,58 +345,0 @@\n-    static void empty() {\n-    }\n-\n-    static Object zeroObject() {\n-        return null;\n-    }\n-\n-    static int zeroInteger() {\n-        return 0;\n-    }\n-\n-    static long zeroLong() {\n-        return 0;\n-    }\n-\n-    static float zeroFloat() {\n-        return 0;\n-    }\n-\n-    static double zeroDouble() {\n-        return 0;\n-    }\n-\n-    private static final WrapperCache[] CONSTANT_FUNCTIONS = newWrapperCaches(2);\n-\n-    public static MethodHandle zeroConstantFunction(Wrapper wrap) {\n-        WrapperCache cache = CONSTANT_FUNCTIONS[0];\n-        MethodHandle mh = cache.get(wrap);\n-        if (mh != null) {\n-            return mh;\n-        }\n-        \/\/ slow path\n-        MethodType type = MethodType.methodType(wrap.primitiveType());\n-        switch (wrap) {\n-            case VOID:\n-                mh = Handles.EMPTY;\n-                break;\n-            case OBJECT:\n-            case INT: case LONG: case FLOAT: case DOUBLE:\n-                try {\n-                    mh = IMPL_LOOKUP.findStatic(THIS_CLASS, \"zero\"+wrap.wrapperSimpleName(), type);\n-                } catch (ReflectiveOperationException ex) {\n-                    mh = null;\n-                }\n-                break;\n-        }\n-        if (mh != null) {\n-            return cache.put(wrap, mh);\n-        }\n-\n-        \/\/ use zeroInt and cast the result\n-        if (wrap.isSubwordOrInt() && wrap != Wrapper.INT) {\n-            mh = MethodHandles.explicitCastArguments(zeroConstantFunction(Wrapper.INT), type);\n-            return cache.put(wrap, mh);\n-        }\n-        throw new IllegalArgumentException(\"cannot find zero constant for \" + wrap);\n-    }\n-\n@@ -404,1 +346,1 @@\n-        static final MethodHandle CAST_REFERENCE, IGNORE, EMPTY;\n+        static final MethodHandle IGNORE;\n@@ -409,1 +351,0 @@\n-                CAST_REFERENCE = IMPL_LOOKUP.findVirtual(Class.class, \"cast\", idType);\n@@ -411,1 +352,0 @@\n-                EMPTY = IMPL_LOOKUP.findStatic(THIS_CLASS, \"empty\", ignoreType.dropParameterTypes(0, 1));\n@@ -422,4 +362,0 @@\n-    \/** Return a method that casts its second argument (an Object) to the given type (a Class). *\/\n-    public static MethodHandle cast() {\n-        return Handles.CAST_REFERENCE;\n-    }\n@@ -676,3 +612,0 @@\n-    private static InternalError newInternalError(Throwable cause) {\n-        return new InternalError(cause);\n-    }\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/ValueConversions.java","additions":2,"deletions":69,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -1,113 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package sun.net;\n-\n-import java.util.EventObject;\n-import java.net.URL;\n-\n-\/**\n- * ProgressEvent represents an progress event in monitering network input stream.\n- *\n- * @author Stanley Man-Kit Ho\n- *\/\n-@SuppressWarnings(\"serial\")  \/\/ never serialized\n-public class ProgressEvent extends EventObject  {\n-    \/\/ URL of the stream\n-    private URL url;\n-    \/\/ content type of the stream\n-    private String contentType;\n-    \/\/ method associated with URL\n-    private String method;\n-    \/\/ bytes read\n-    private long progress;\n-    \/\/ bytes expected\n-    private long expected;\n-    \/\/ the last thing to happen\n-    private ProgressSource.State state;\n-\n-    \/**\n-     * Construct a ProgressEvent object.\n-     *\/\n-    public ProgressEvent(ProgressSource source, URL url, String method, String contentType, ProgressSource.State state, long progress, long expected) {\n-        super(source);\n-        this.url = url;\n-        this.method = method;\n-        this.contentType = contentType;\n-        this.progress = progress;\n-        this.expected = expected;\n-        this.state = state;\n-    }\n-\n-    \/**\n-     * Return URL related to the progress.\n-     *\/\n-    public URL getURL()\n-    {\n-        return url;\n-    }\n-\n-    \/**\n-     * Return method associated with URL.\n-     *\/\n-    public String getMethod()\n-    {\n-        return method;\n-    }\n-\n-    \/**\n-     * Return content type of the URL.\n-     *\/\n-    public String getContentType()\n-    {\n-        return contentType;\n-    }\n-\n-    \/**\n-     * Return current progress value.\n-     *\/\n-    public long getProgress()\n-    {\n-        return progress;\n-    }\n-\n-    \/**\n-     * Return expected maximum progress value; -1 if expected is unknown.\n-     *\/\n-    public long getExpected() {\n-        return expected;\n-    }\n-\n-    \/**\n-     * Return state.\n-     *\/\n-    public ProgressSource.State getState() {\n-        return state;\n-    }\n-\n-    public String toString()    {\n-        return getClass().getName() + \"[url=\" + url + \", method=\" + method + \", state=\" + state\n-             + \", content-type=\" + contentType + \", progress=\" + progress + \", expected=\" + expected + \"]\";\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/net\/ProgressEvent.java","additions":0,"deletions":113,"binary":false,"changes":113,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package sun.net;\n-\n-import java.util.EventListener;\n-\n-\/**\n- * ProgressListener is an interface to be implemented by parties\n- * interested to be notified of progress in network input stream.\n- *\n- * @author Stanley Man-Kit Ho\n- *\/\n-public interface ProgressListener extends EventListener\n-{\n-    \/**\n-     * Start progress.\n-     *\/\n-    public void progressStart(ProgressEvent evt);\n-\n-    \/**\n-     * Update progress.\n-     *\/\n-    public void progressUpdate(ProgressEvent evt);\n-\n-    \/**\n-     * Finish progress.\n-     *\/\n-    public void progressFinish(ProgressEvent evt);\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/net\/ProgressListener.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package sun.net;\n-\n-import java.net.URL;\n-\n-\/**\n- * ProgressMeteringPolicy is an interface for determining progress metering policy.\n- *\n- * @author Stanley Man-Kit Ho\n- *\/\n-public interface ProgressMeteringPolicy\n-{\n-    \/**\n-     * Return true if metering should be turned on for a particular network input stream.\n-     *\/\n-    public boolean shouldMeterInput(URL url, String method);\n-\n-    \/**\n-     * Return update notification threshold.\n-     *\/\n-    public int getProgressUpdateThreshold();\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/net\/ProgressMeteringPolicy.java","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -1,246 +0,0 @@\n-\/*\n- * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.net;\n-\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.net.URL;\n-\n-\/**\n- * ProgressMonitor is a class for monitoring progress in network input stream.\n- *\n- * @author Stanley Man-Kit Ho\n- *\/\n-public class ProgressMonitor\n-{\n-    \/**\n-     * Return default ProgressMonitor.\n-     *\/\n-    public static synchronized ProgressMonitor getDefault() {\n-        return pm;\n-    }\n-\n-    \/**\n-     * Change default ProgressMonitor implementation.\n-     *\/\n-    public static synchronized void setDefault(ProgressMonitor m)   {\n-        if (m != null)\n-            pm = m;\n-    }\n-\n-    \/**\n-     * Change progress metering policy.\n-     *\/\n-    public static synchronized void setMeteringPolicy(ProgressMeteringPolicy policy)    {\n-        if (policy != null)\n-            meteringPolicy = policy;\n-    }\n-\n-\n-    \/**\n-     * Return a snapshot of the ProgressSource list\n-     *\/\n-    public ArrayList<ProgressSource> getProgressSources()    {\n-        ArrayList<ProgressSource> snapshot = new ArrayList<>();\n-\n-        try {\n-            synchronized(progressSourceList)    {\n-                for (ProgressSource pi : progressSourceList) {\n-                    \/\/ Clone ProgressSource and add to snapshot\n-                    snapshot.add((ProgressSource)pi.clone());\n-                }\n-            }\n-        }\n-        catch(CloneNotSupportedException e) {\n-            e.printStackTrace();\n-        }\n-\n-        return snapshot;\n-    }\n-\n-    \/**\n-     * Return update notification threshold\n-     *\/\n-    public synchronized int getProgressUpdateThreshold()    {\n-        return meteringPolicy.getProgressUpdateThreshold();\n-    }\n-\n-    \/**\n-     * Return true if metering should be turned on\n-     * for a particular URL input stream.\n-     *\/\n-    public boolean shouldMeterInput(URL url, String method) {\n-        return meteringPolicy.shouldMeterInput(url, method);\n-    }\n-\n-    \/**\n-     * Register progress source when progress is began.\n-     *\/\n-    public void registerSource(ProgressSource pi) {\n-\n-        synchronized(progressSourceList)    {\n-            if (progressSourceList.contains(pi))\n-                return;\n-\n-            progressSourceList.add(pi);\n-        }\n-\n-        \/\/ Notify only if there is at least one listener\n-        if (progressListenerList.size() > 0)\n-        {\n-            \/\/ Notify progress listener if there is progress change\n-            ArrayList<ProgressListener> listeners;\n-\n-            \/\/ Copy progress listeners to another list to avoid holding locks\n-            synchronized(progressListenerList) {\n-                listeners = new ArrayList<>(progressListenerList);\n-            }\n-\n-            \/\/ Fire event on each progress listener\n-            for (ProgressListener pl : listeners) {\n-                ProgressEvent pe = new ProgressEvent(pi, pi.getURL(), pi.getMethod(), pi.getContentType(), pi.getState(), pi.getProgress(), pi.getExpected());\n-                pl.progressStart(pe);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Unregister progress source when progress is finished.\n-     *\/\n-    public void unregisterSource(ProgressSource pi) {\n-\n-        synchronized(progressSourceList) {\n-            \/\/ Return if ProgressEvent does not exist\n-            if (progressSourceList.contains(pi) == false)\n-                return;\n-\n-            \/\/ Close entry and remove from map\n-            pi.close();\n-            progressSourceList.remove(pi);\n-        }\n-\n-        \/\/ Notify only if there is at least one listener\n-        if (progressListenerList.size() > 0)\n-        {\n-            \/\/ Notify progress listener if there is progress change\n-            ArrayList<ProgressListener> listeners;\n-\n-            \/\/ Copy progress listeners to another list to avoid holding locks\n-            synchronized(progressListenerList) {\n-                listeners = new ArrayList<>(progressListenerList);\n-            }\n-\n-            \/\/ Fire event on each progress listener\n-            for (ProgressListener pl : listeners) {\n-                ProgressEvent pe = new ProgressEvent(pi, pi.getURL(), pi.getMethod(), pi.getContentType(), pi.getState(), pi.getProgress(), pi.getExpected());\n-                pl.progressFinish(pe);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Progress source is updated.\n-     *\/\n-    public void updateProgress(ProgressSource pi)   {\n-\n-        synchronized (progressSourceList)   {\n-            if (progressSourceList.contains(pi) == false)\n-                return;\n-        }\n-\n-        \/\/ Notify only if there is at least one listener\n-        if (progressListenerList.size() > 0)\n-        {\n-            \/\/ Notify progress listener if there is progress change\n-            ArrayList<ProgressListener> listeners;\n-\n-            \/\/ Copy progress listeners to another list to avoid holding locks\n-            synchronized(progressListenerList)  {\n-                listeners = new ArrayList<>(progressListenerList);\n-            }\n-\n-            \/\/ Fire event on each progress listener\n-            for (ProgressListener pl : listeners) {\n-                ProgressEvent pe = new ProgressEvent(pi, pi.getURL(), pi.getMethod(), pi.getContentType(), pi.getState(), pi.getProgress(), pi.getExpected());\n-                pl.progressUpdate(pe);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Add progress listener in progress monitor.\n-     *\/\n-    public void addProgressListener(ProgressListener l) {\n-        synchronized(progressListenerList) {\n-            progressListenerList.add(l);\n-        }\n-    }\n-\n-    \/**\n-     * Remove progress listener from progress monitor.\n-     *\/\n-    public void removeProgressListener(ProgressListener l) {\n-        synchronized(progressListenerList) {\n-            progressListenerList.remove(l);\n-        }\n-    }\n-\n-    \/\/ Metering policy\n-    private static ProgressMeteringPolicy meteringPolicy = new DefaultProgressMeteringPolicy();\n-\n-    \/\/ Default implementation\n-    private static ProgressMonitor pm = new ProgressMonitor();\n-\n-    \/\/ ArrayList for outstanding progress sources\n-    private ArrayList<ProgressSource> progressSourceList = new ArrayList<ProgressSource>();\n-\n-    \/\/ ArrayList for progress listeners\n-    private ArrayList<ProgressListener> progressListenerList = new ArrayList<ProgressListener>();\n-}\n-\n-\n-\/**\n- * Default progress metering policy.\n- *\/\n-class DefaultProgressMeteringPolicy implements ProgressMeteringPolicy  {\n-    \/**\n-     * Return true if metering should be turned on for a particular network input stream.\n-     *\/\n-    public boolean shouldMeterInput(URL url, String method)\n-    {\n-        \/\/ By default, no URL input stream is metered for\n-        \/\/ performance reason.\n-        return false;\n-    }\n-\n-    \/**\n-     * Return update notification threshold.\n-     *\/\n-    public int getProgressUpdateThreshold() {\n-        \/\/ 8K - same as default I\/O buffer size\n-        return 8192;\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/net\/ProgressMonitor.java","additions":0,"deletions":246,"binary":false,"changes":246,"status":"deleted"},{"patch":"@@ -1,210 +0,0 @@\n-\/*\n- * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package sun.net;\n-\n-import java.net.URL;\n-\n-\/**\n- * ProgressSource represents the source of progress changes.\n- *\n- * @author Stanley Man-Kit Ho\n- *\/\n-public class ProgressSource\n-{\n-    public enum State { NEW, CONNECTED, UPDATE, DELETE };\n-\n-    \/\/ URL\n-    private URL url;\n-    \/\/ URL method\n-    private String method;\n-    \/\/ Content type\n-    private String contentType;\n-    \/\/ bytes read\n-    private long progress = 0;\n-    \/\/ last bytes read\n-    private long lastProgress = 0;\n-    \/\/bytes expected\n-    private long expected = -1;\n-    \/\/ the last thing to happen with this source\n-    private State state;\n-    \/\/ connect flag\n-    private boolean connected = false;\n-    \/\/ threshold for notification\n-    private int threshold = 8192;\n-    \/\/ progress monitor\n-    private ProgressMonitor progressMonitor;\n-\n-    \/**\n-     * Construct progress source object.\n-     *\/\n-    public ProgressSource(URL url, String method) {\n-        this(url, method, -1);\n-    }\n-\n-    \/**\n-     * Construct progress source object.\n-     *\/\n-    public ProgressSource(URL url, String method, long expected)  {\n-        this.url = url;\n-        this.method = method;\n-        this.contentType = \"content\/unknown\";\n-        this.progress = 0;\n-        this.lastProgress = 0;\n-        this.expected = expected;\n-        this.state = State.NEW;\n-        this.progressMonitor = ProgressMonitor.getDefault();\n-        this.threshold = progressMonitor.getProgressUpdateThreshold();\n-    }\n-\n-    public boolean connected() {\n-        if (!connected) {\n-            connected = true;\n-            state = State.CONNECTED;\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    \/**\n-     * Close progress source.\n-     *\/\n-    public void close() {\n-        state = State.DELETE;\n-    }\n-\n-    \/**\n-     * Return URL of progress source.\n-     *\/\n-    public URL getURL() {\n-        return url;\n-    }\n-\n-    \/**\n-     * Return method of URL.\n-     *\/\n-    public String getMethod()  {\n-        return method;\n-    }\n-\n-    \/**\n-     * Return content type of URL.\n-     *\/\n-    public String getContentType()  {\n-        return contentType;\n-    }\n-\n-    \/\/ Change content type\n-    public void setContentType(String ct)  {\n-        contentType = ct;\n-    }\n-\n-    \/**\n-     * Return current progress.\n-     *\/\n-    public long getProgress()  {\n-        return progress;\n-    }\n-\n-    \/**\n-     * Return expected maximum progress; -1 if expected is unknown.\n-     *\/\n-    public long getExpected() {\n-        return expected;\n-    }\n-\n-    \/**\n-     * Return state.\n-     *\/\n-    public State getState() {\n-        return state;\n-    }\n-\n-    \/**\n-     * Begin progress tracking.\n-     *\/\n-    public void beginTracking() {\n-        progressMonitor.registerSource(this);\n-    }\n-\n-    \/**\n-     * Finish progress tracking.\n-     *\/\n-    public void finishTracking() {\n-        progressMonitor.unregisterSource(this);\n-    }\n-\n-    \/**\n-     * Update progress.\n-     *\/\n-    public void updateProgress(long latestProgress, long expectedProgress) {\n-        lastProgress = progress;\n-        progress = latestProgress;\n-        expected = expectedProgress;\n-\n-        if (connected() == false)\n-            state = State.CONNECTED;\n-        else\n-            state = State.UPDATE;\n-\n-        \/\/ The threshold effectively divides the progress into\n-        \/\/ different set of ranges:\n-        \/\/\n-        \/\/      Range 0: 0..threshold-1,\n-        \/\/      Range 1: threshold .. 2*threshold-1\n-        \/\/      ....\n-        \/\/      Range n: n*threshold .. (n+1)*threshold-1\n-        \/\/\n-        \/\/ To determine which range the progress belongs to, it\n-        \/\/ would be calculated as follow:\n-        \/\/\n-        \/\/      range number = progress \/ threshold\n-        \/\/\n-        \/\/ Notification should only be triggered when the current\n-        \/\/ progress and the last progress are in different ranges,\n-        \/\/ i.e. they have different range numbers.\n-        \/\/\n-        \/\/ Using this range scheme, notification will be generated\n-        \/\/ only once when the progress reaches each range.\n-        \/\/\n-        if (lastProgress \/ threshold != progress \/ threshold)   {\n-            progressMonitor.updateProgress(this);\n-        }\n-\n-        \/\/ Detect read overrun\n-        if (expected != -1) {\n-            if (progress >= expected && progress != 0)\n-                close();\n-        }\n-    }\n-\n-    public Object clone() throws CloneNotSupportedException {\n-        return super.clone();\n-    }\n-\n-    public String toString()    {\n-        return getClass().getName() + \"[url=\" + url + \", method=\" + method + \", state=\" + state\n-            + \", content-type=\" + contentType + \", progress=\" + progress + \", expected=\" + expected + \"]\";\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/net\/ProgressSource.java","additions":0,"deletions":210,"binary":false,"changes":210,"status":"deleted"},{"patch":"@@ -30,1 +30,0 @@\n-import sun.net.ProgressSource;\n@@ -45,1 +44,0 @@\n-    protected ProgressSource pi;\n@@ -48,1 +46,1 @@\n-    public MeteredStream(InputStream is, ProgressSource pi, long expected)\n+    public MeteredStream(InputStream is, long expected)\n@@ -52,1 +50,0 @@\n-        this.pi = pi;\n@@ -54,4 +51,0 @@\n-\n-        if (pi != null) {\n-            pi.updateProgress(0, expected);\n-        }\n@@ -84,3 +77,0 @@\n-        if (pi != null)\n-            pi.updateProgress(count, expected);\n-\n@@ -173,2 +163,0 @@\n-            if (pi != null)\n-                pi.finishTracking();\n@@ -244,13 +232,0 @@\n-\n-    @SuppressWarnings(\"removal\")\n-    protected void finalize() throws Throwable {\n-        try {\n-            close();\n-            if (pi != null)\n-                pi.close();\n-        }\n-        finally {\n-            \/\/ Call super class\n-            super.finalize();\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/MeteredStream.java","additions":1,"deletions":26,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import sun.net.ProgressSource;\n@@ -744,1 +743,1 @@\n-    public boolean parseHTTP(MessageHeader responses, ProgressSource pi, HttpURLConnection httpuc)\n+    public boolean parseHTTP(MessageHeader responses, HttpURLConnection httpuc)\n@@ -761,1 +760,1 @@\n-            return (parseHTTPHeader(responses, pi, httpuc));\n+            return (parseHTTPHeader(responses, httpuc));\n@@ -788,1 +787,1 @@\n-                    return parseHTTP(responses, pi, httpuc);\n+                    return parseHTTP(responses, httpuc);\n@@ -808,1 +807,1 @@\n-    private boolean parseHTTPHeader(MessageHeader responses, ProgressSource pi, HttpURLConnection httpuc)\n+    private boolean parseHTTPHeader(MessageHeader responses, HttpURLConnection httpuc)\n@@ -954,1 +953,1 @@\n-                        return parseHTTP(responses, pi, httpuc);\n+                        return parseHTTP(responses, httpuc);\n@@ -997,1 +996,1 @@\n-            return parseHTTPHeader(responses, pi, httpuc);\n+            return parseHTTPHeader(responses, httpuc);\n@@ -1070,5 +1069,0 @@\n-            if (pi != null) {\n-                \/\/ Progress monitor is enabled\n-                pi.setContentType(responses.findValue(\"content-type\"));\n-            }\n-\n@@ -1082,1 +1076,1 @@\n-                serverInput = new KeepAliveStream(serverInput, pi, cl, this);\n+                serverInput = new KeepAliveStream(serverInput, cl, this);\n@@ -1086,1 +1080,1 @@\n-                serverInput = new MeteredStream(serverInput, pi, cl);\n+                serverInput = new MeteredStream(serverInput, cl);\n@@ -1089,26 +1083,0 @@\n-        else if (cl == -1)  {\n-            \/\/ In this case, content length is unknown - the input\n-            \/\/ stream would simply be a regular InputStream or\n-            \/\/ ChunkedInputStream.\n-\n-            if (pi != null) {\n-                \/\/ Progress monitoring is enabled.\n-\n-                pi.setContentType(responses.findValue(\"content-type\"));\n-\n-                \/\/ Wrap MeteredStream for tracking indeterministic\n-                \/\/ progress, even if the input stream is ChunkedInputStream.\n-                serverInput = new MeteredStream(serverInput, pi, cl);\n-            }\n-            else    {\n-                \/\/ Progress monitoring is disabled, and there is no\n-                \/\/ need to wrap an unknown length input stream.\n-\n-                \/\/ ** This is an no-op **\n-            }\n-        }\n-        else    {\n-            if (pi != null)\n-                pi.finishTracking();\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/http\/HttpClient.java","additions":8,"deletions":40,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import sun.net.ProgressSource;\n@@ -59,2 +58,2 @@\n-    public KeepAliveStream(InputStream is, ProgressSource pi, long expected, HttpClient hc)  {\n-        super(is, pi, expected);\n+    public KeepAliveStream(InputStream is, long expected, HttpClient hc) {\n+        super(is, expected);\n@@ -104,3 +103,0 @@\n-                if (pi != null)\n-                    pi.finishTracking();\n-\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/http\/KeepAliveStream.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-import sun.net.*;\n@@ -85,1 +84,0 @@\n-\n@@ -87,7 +85,0 @@\n-\n-                    \/\/ Check if URL should be metered\n-                    boolean meteredInput = ProgressMonitor.getDefault().shouldMeterInput(url, \"GET\");\n-                    if (meteredInput)   {\n-                        ProgressSource pi = new ProgressSource(url, \"GET\", file.length());\n-                        is = new MeteredStream(is, pi, file.length());\n-                    }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/file\/FileURLConnection.java","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -59,2 +59,0 @@\n-import sun.net.ProgressSource;\n-import sun.net.ProgressMonitor;\n@@ -469,11 +467,1 @@\n-\n-                    \/\/ Check if URL should be metered\n-                    boolean meteredInput = ProgressMonitor.getDefault().shouldMeterInput(url, \"GET\");\n-                    ProgressSource pi = null;\n-\n-                    if (meteredInput) {\n-                        pi = new ProgressSource(url, \"GET\", l);\n-                        pi.beginTracking();\n-                    }\n-\n-                    is = new MeteredStream(is, pi, l);\n+                    is = new MeteredStream(is, l);\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/ftp\/FtpURLConnection.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -70,1 +70,2 @@\n-import sun.net.*;\n+import sun.net.NetProperties;\n+import sun.net.NetworkClient;\n@@ -387,3 +388,0 @@\n-    \/* Progress source *\/\n-    protected ProgressSource pi;\n-\n@@ -1334,1 +1332,1 @@\n-                http.parseHTTP(responses, pi, this);\n+                http.parseHTTP(responses, this);\n@@ -1665,8 +1663,0 @@\n-                \/\/ Check if URL should be metered\n-                boolean meteredInput = ProgressMonitor.getDefault().shouldMeterInput(url, method);\n-\n-                if (meteredInput)   {\n-                    pi = new ProgressSource(url, method);\n-                    pi.beginTracking();\n-                }\n-\n@@ -1682,1 +1672,1 @@\n-                http.parseHTTP(responses, pi, this);\n+                http.parseHTTP(responses, this);\n@@ -1946,4 +1936,0 @@\n-                    if (pi != null) {\n-                        pi.finishTracking();\n-                        pi = null;\n-                    }\n@@ -2169,3 +2155,1 @@\n-                \/\/ There is no need to track progress in HTTP Tunneling,\n-                \/\/ so ProgressSource is null.\n-                http.parseHTTP(responses, null, this);\n+                http.parseHTTP(responses, this);\n@@ -3048,4 +3032,0 @@\n-        if (pi != null) {\n-            pi.finishTracking();\n-            pi = null;\n-        }\n@@ -3065,4 +3045,0 @@\n-        if (pi != null) {\n-            pi.finishTracking();\n-            pi = null;\n-        }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/HttpURLConnection.java","additions":5,"deletions":29,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -74,0 +74,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -90,0 +92,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -783,7 +787,12 @@\n-        int n = receive0(fd,\n-                         ((DirectBuffer)bb).address() + pos, rem,\n-                         sourceSockAddr.address(),\n-                         connected);\n-        if (n > 0)\n-            bb.position(pos + n);\n-        return n;\n+        NIO_ACCESS.acquireSession(bb);\n+        try {\n+            int n = receive0(fd,\n+                            ((DirectBuffer)bb).address() + pos, rem,\n+                            sourceSockAddr.address(),\n+                            connected);\n+            if (n > 0)\n+                bb.position(pos + n);\n+            return n;\n+        } finally {\n+            NIO_ACCESS.releaseSession(bb);\n+        }\n@@ -933,0 +942,1 @@\n+        NIO_ACCESS.acquireSession(bb);\n@@ -941,0 +951,2 @@\n+        } finally {\n+            NIO_ACCESS.releaseSession(bb);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramChannelImpl.java","additions":19,"deletions":7,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -33,0 +33,7 @@\n+    \/\/ Use of the returned address must be guarded if this DirectBuffer\n+    \/\/ is backed by a memory session that is explicitly closeable.\n+    \/\/\n+    \/\/ Failure to do this means the outcome is undefined including\n+    \/\/ silent unrelated memory mutation and JVM crashes.\n+    \/\/\n+    \/\/ See JavaNioAccess for methods to safely acquire\/release resources.\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DirectBuffer.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -1211,1 +1211,1 @@\n-                             MemorySession session)\n+                             SegmentScope session)\n@@ -1216,1 +1216,1 @@\n-        MemorySessionImpl sessionImpl = MemorySessionImpl.toSessionImpl(session);\n+        MemorySessionImpl sessionImpl = (MemorySessionImpl) session;\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.internal.foreign.MemorySessionImpl;\n@@ -39,1 +40,1 @@\n-public class IOUtil {\n+public final class IOUtil {\n@@ -131,1 +132,1 @@\n-        var handle = acquireScope(bb, async);\n+        acquireScope(bb, async);\n@@ -139,1 +140,1 @@\n-            releaseScope(handle);\n+            releaseScope(bb);\n@@ -184,3 +185,3 @@\n-                var h = acquireScope(buf, async);\n-                if (h != null) {\n-                    handleReleasers = LinkedRunnable.of(Releaser.of(h), handleReleasers);\n+                acquireScope(buf, async);\n+                if (NIO_ACCESS.hasSession(buf)) {\n+                    handleReleasers = LinkedRunnable.of(Releaser.of(buf), handleReleasers);\n@@ -334,1 +335,1 @@\n-        var handle = acquireScope(bb, async);\n+        acquireScope(bb, async);\n@@ -342,1 +343,1 @@\n-            releaseScope(handle);\n+            releaseScope(bb);\n@@ -396,3 +397,3 @@\n-                var h = acquireScope(buf, async);\n-                if (h != null) {\n-                    handleReleasers = LinkedRunnable.of(Releaser.of(h), handleReleasers);\n+                acquireScope(buf, async);\n+                if (NIO_ACCESS.hasSession(buf)) {\n+                    handleReleasers = LinkedRunnable.of(Releaser.of(buf), handleReleasers);\n@@ -477,2 +478,5 @@\n-    static Runnable acquireScope(ByteBuffer bb, boolean async) {\n-        return NIO_ACCESS.acquireSession(bb, async);\n+    static void acquireScope(ByteBuffer bb, boolean async) {\n+        if (async && NIO_ACCESS.isThreadConfined(bb)) {\n+            throw new IllegalStateException(\"Confined session not supported\");\n+        }\n+        NIO_ACCESS.acquireSession(bb);\n@@ -481,3 +485,1 @@\n-    private static void releaseScope(Runnable handle) {\n-        if (handle == null)\n-            return;\n+    private static void releaseScope(ByteBuffer bb) {\n@@ -485,1 +487,1 @@\n-            handle.run();\n+            NIO_ACCESS.releaseSession(bb);\n@@ -498,1 +500,2 @@\n-            return IOUtil.Releaser.ofNullable(IOUtil.acquireScope(buf, true));\n+            IOUtil.acquireScope(buf, true);\n+            return IOUtil.Releaser.of(buf);\n@@ -503,4 +506,2 @@\n-                var h = IOUtil.acquireScope(b, true);\n-                if (h != null) {\n-                    handleReleasers = IOUtil.LinkedRunnable.of(IOUtil.Releaser.of(h), handleReleasers);\n-                }\n+                IOUtil.acquireScope(b, true);\n+                handleReleasers = IOUtil.LinkedRunnable.of(IOUtil.Releaser.of(b), handleReleasers);\n@@ -517,3 +518,1 @@\n-    static record LinkedRunnable(Runnable node, Runnable next)\n-        implements Runnable\n-    {\n+    record LinkedRunnable(Runnable node, Runnable next) implements Runnable {\n@@ -523,0 +522,1 @@\n+\n@@ -532,0 +532,1 @@\n+\n@@ -537,8 +538,14 @@\n-    static record Releaser(Runnable handle) implements Runnable {\n-        Releaser { Objects.requireNonNull(handle) ; }\n-        @Override public void run() { releaseScope(handle); }\n-        static Runnable of(Runnable handle) { return new Releaser(handle); }\n-        static Runnable ofNullable(Runnable handle) {\n-            if (handle == null)\n-                return () -> { };\n-            return new Releaser(handle);\n+    record Releaser(ByteBuffer bb) implements Runnable {\n+        Releaser {\n+            Objects.requireNonNull(bb);\n+        }\n+\n+        @Override\n+        public void run() {\n+            releaseScope(bb);\n+        }\n+\n+        static Runnable of(ByteBuffer bb) {\n+            return NIO_ACCESS.hasSession(bb)\n+                    ? new Releaser(bb)\n+                    : () -> {};\n@@ -546,0 +553,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/IOUtil.java","additions":41,"deletions":33,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,3 +64,1 @@\n-    \/\/ Wait between polling thread creation and first poll (seconds)\n-    private static final int POLLING_INIT_DELAY = 1;\n-    \/\/ Default time between polls (seconds)\n+    \/\/ default polling interval in seconds\n@@ -255,1 +253,0 @@\n-\n@@ -314,1 +311,1 @@\n-                \/\/ create the periodic task with initialDelay set to the specified constant\n+                \/\/ create the periodic task to poll directories\n@@ -317,1 +314,1 @@\n-                    .scheduleAtFixedRate(thunk, POLLING_INIT_DELAY, period, TimeUnit.SECONDS);\n+                    .scheduleAtFixedRate(thunk, period, period, TimeUnit.SECONDS);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/fs\/PollingWatchService.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -593,0 +593,1 @@\n+                    chc.sslConfig,\n@@ -904,0 +905,1 @@\n+                    context.sslConfig,\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertificateVerify.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;\n@@ -316,6 +315,7 @@\n-                preferableNamedGroup =\n-                        SupportedGroups.getPreferredGroup(context.negotiatedProtocol,\n-                                context.algorithmConstraints,\n-                                new NamedGroupSpec [] {\n-                                    NamedGroupSpec.NAMED_GROUP_FFDHE },\n-                                context.clientRequestedNamedGroups);\n+                preferableNamedGroup = NamedGroup.getPreferredGroup(\n+                        context.sslConfig,\n+                        context.negotiatedProtocol,\n+                        context.algorithmConstraints,\n+                        new NamedGroupSpec [] {\n+                            NamedGroupSpec.NAMED_GROUP_FFDHE },\n+                        context.clientRequestedNamedGroups);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/DHKeyExchange.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -130,0 +130,1 @@\n+                                    shc.sslConfig,\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/DHServerKeyExchange.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;\n@@ -239,1 +238,2 @@\n-                preferableNamedGroup = SupportedGroups.getPreferredGroup(\n+                preferableNamedGroup = NamedGroup.getPreferredGroup(\n+                        context.sslConfig,\n@@ -247,1 +247,2 @@\n-                preferableNamedGroup = SupportedGroups.getPreferredGroup(\n+                preferableNamedGroup = NamedGroup.getPreferredGroup(\n+                        context.sslConfig,\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ECDHKeyExchange.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;\n@@ -142,0 +141,1 @@\n+                                shc.sslConfig,\n@@ -207,1 +207,1 @@\n-            if (!SupportedGroups.isSupported(namedGroup)) {\n+            if (!NamedGroup.isEnabled(chc.sslConfig, namedGroup)) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ECDHServerKeyExchange.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;\n@@ -160,2 +159,2 @@\n-        this.activeProtocols = getActiveProtocols(sslConfig.enabledProtocols,\n-                sslConfig.enabledCipherSuites, algorithmConstraints);\n+        this.activeProtocols =\n+                getActiveProtocols(sslConfig, algorithmConstraints);\n@@ -176,2 +175,2 @@\n-        this.activeCipherSuites = getActiveCipherSuites(this.activeProtocols,\n-                sslConfig.enabledCipherSuites, algorithmConstraints);\n+        this.activeCipherSuites = getActiveCipherSuites(sslConfig,\n+                this.activeProtocols, algorithmConstraints);\n@@ -259,2 +258,1 @@\n-            List<ProtocolVersion> enabledProtocols,\n-            List<CipherSuite> enabledCipherSuites,\n+            SSLConfiguration sslConfig,\n@@ -264,1 +262,1 @@\n-        for (ProtocolVersion protocol : enabledProtocols) {\n+        for (ProtocolVersion protocol : sslConfig.enabledProtocols) {\n@@ -280,1 +278,1 @@\n-            for (CipherSuite suite : enabledCipherSuites) {\n+            for (CipherSuite suite : sslConfig.enabledCipherSuites) {\n@@ -282,1 +280,1 @@\n-                    if (isActivatable(suite,\n+                    if (isActivatable(sslConfig, suite,\n@@ -312,0 +310,1 @@\n+            SSLConfiguration sslConfig,\n@@ -313,1 +312,0 @@\n-            List<CipherSuite> enabledCipherSuites,\n@@ -320,1 +318,1 @@\n-            for (CipherSuite suite : enabledCipherSuites) {\n+            for (CipherSuite suite : sslConfig.enabledCipherSuites) {\n@@ -330,1 +328,1 @@\n-                    if (isActivatable(suite,\n+                    if (isActivatable(sslConfig, suite,\n@@ -528,1 +526,3 @@\n-    private static boolean isActivatable(CipherSuite suite,\n+    private static boolean isActivatable(\n+            SSLConfiguration sslConfig,\n+            CipherSuite suite,\n@@ -546,2 +546,2 @@\n-                        groupAvailable = SupportedGroups.isActivatable(\n-                                algorithmConstraints, groupType);\n+                        groupAvailable = NamedGroup.isActivatable(\n+                                sslConfig, algorithmConstraints, groupType);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/HandshakeContext.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;\n@@ -348,1 +347,1 @@\n-                if (ng == null || !SupportedGroups.isActivatable(\n+                if (ng == null || !NamedGroup.isActivatable(shc.sslConfig,\n@@ -650,1 +649,1 @@\n-            if (ng == null || !SupportedGroups.isActivatable(\n+            if (ng == null || !NamedGroup.isActivatable(chc.sslConfig,\n@@ -803,1 +802,1 @@\n-                if (SupportedGroups.isActivatable(\n+                if (NamedGroup.isActivatable(shc.sslConfig,\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/KeyShareExtension.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.ArrayList;\n@@ -41,1 +42,1 @@\n-\n+import sun.security.action.GetPropertyAction;\n@@ -244,3 +245,3 @@\n-               NamedGroupSpec namedGroupSpec,\n-               ProtocolVersion[] supportedProtocols,\n-               AlgorithmParameterSpec keAlgParamSpec) {\n+            NamedGroupSpec namedGroupSpec,\n+            ProtocolVersion[] supportedProtocols,\n+            AlgorithmParameterSpec keAlgParamSpec) {\n@@ -372,0 +373,120 @@\n+    public static List<NamedGroup> namesOf(String[] namedGroups) {\n+        if (namedGroups == null) {\n+            return null;\n+        }\n+\n+        if (namedGroups.length == 0) {\n+            return List.of();\n+        }\n+\n+        List<NamedGroup> ngs = new ArrayList<>(namedGroups.length);\n+        for (String ss : namedGroups) {\n+            NamedGroup ng = NamedGroup.nameOf(ss);\n+            if (ng == null || !ng.isAvailable) {\n+                if (SSLLogger.isOn &&\n+                        SSLLogger.isOn(\"ssl,handshake,verbose\")) {\n+                    SSLLogger.finest(\n+                            \"Ignore the named group (\" + ss\n+                                    + \"), unsupported or unavailable\");\n+                }\n+\n+                continue;\n+            }\n+\n+            ngs.add(ng);\n+        }\n+\n+        return Collections.unmodifiableList(ngs);\n+    }\n+\n+    \/\/ Is there any supported group permitted by the constraints?\n+    static boolean isActivatable(SSLConfiguration sslConfig,\n+            AlgorithmConstraints constraints, NamedGroupSpec type) {\n+\n+        boolean hasFFDHEGroups = false;\n+        for (String ng : sslConfig.namedGroups) {\n+            NamedGroup namedGroup = NamedGroup.nameOf(ng);\n+            if (namedGroup != null &&\n+                namedGroup.isAvailable && namedGroup.spec == type) {\n+                if (namedGroup.isPermitted(constraints)) {\n+                    return true;\n+                }\n+\n+                if (!hasFFDHEGroups &&\n+                        (type == NamedGroupSpec.NAMED_GROUP_FFDHE)) {\n+                    hasFFDHEGroups = true;\n+                }\n+            }\n+        }\n+\n+        \/\/ For compatibility, if no FFDHE groups are defined, the non-FFDHE\n+        \/\/ compatible mode (using DHE cipher suite without FFDHE extension)\n+        \/\/ is allowed.\n+        \/\/\n+        \/\/ Note that the constraints checking on DHE parameters will be\n+        \/\/ performed during key exchanging in a handshake.\n+        return !hasFFDHEGroups && type == NamedGroupSpec.NAMED_GROUP_FFDHE;\n+    }\n+\n+    \/\/ Is the named group permitted by the constraints?\n+    static boolean isActivatable(\n+            SSLConfiguration sslConfig,\n+            AlgorithmConstraints constraints, NamedGroup namedGroup) {\n+        if (!namedGroup.isAvailable || !isEnabled(sslConfig, namedGroup)) {\n+            return false;\n+        }\n+\n+        return namedGroup.isPermitted(constraints);\n+    }\n+\n+    \/\/ Is the named group supported?\n+    static boolean isEnabled(SSLConfiguration sslConfig,\n+                             NamedGroup namedGroup) {\n+        for (String ng : sslConfig.namedGroups) {\n+            if (namedGroup.name.equalsIgnoreCase(ng)) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    \/\/ Get preferred named group from the configured named groups for the\n+    \/\/ negotiated protocol and named group types.\n+    static NamedGroup getPreferredGroup(\n+            SSLConfiguration sslConfig,\n+            ProtocolVersion negotiatedProtocol,\n+            AlgorithmConstraints constraints, NamedGroupSpec[] types) {\n+        for (String name : sslConfig.namedGroups) {\n+            NamedGroup ng = NamedGroup.nameOf(name);\n+            if (ng != null && ng.isAvailable &&\n+                    (NamedGroupSpec.arrayContains(types, ng.spec)) &&\n+                    ng.isAvailable(negotiatedProtocol) &&\n+                    ng.isPermitted(constraints)) {\n+                return ng;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    \/\/ Get preferred named group from the requested and configured named\n+    \/\/ groups for the negotiated protocol and named group types.\n+    static NamedGroup getPreferredGroup(\n+            SSLConfiguration sslConfig,\n+            ProtocolVersion negotiatedProtocol,\n+            AlgorithmConstraints constraints, NamedGroupSpec[] types,\n+            List<NamedGroup> requestedNamedGroups) {\n+        for (NamedGroup namedGroup : requestedNamedGroups) {\n+            if ((namedGroup.isAvailable &&\n+                    NamedGroupSpec.arrayContains(types, namedGroup.spec)) &&\n+                    namedGroup.isAvailable(negotiatedProtocol) &&\n+                    isEnabled(sslConfig, namedGroup) &&\n+                    namedGroup.isPermitted(constraints)) {\n+                return namedGroup;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n@@ -621,0 +742,82 @@\n+\n+    static final class SupportedGroups {\n+        \/\/ the supported named groups, non-null immutable list\n+        static final String[] namedGroups;\n+\n+        static {\n+            \/\/ The value of the System Property defines a list of enabled named\n+            \/\/ groups in preference order, separated with comma.  For example:\n+            \/\/\n+            \/\/      jdk.tls.namedGroups=\"secp521r1, secp256r1, ffdhe2048\"\n+            \/\/\n+            \/\/ If the System Property is not defined or the value is empty, the\n+            \/\/ default groups and preferences will be used.\n+            String property = GetPropertyAction\n+                    .privilegedGetProperty(\"jdk.tls.namedGroups\");\n+            if (property != null && !property.isEmpty()) {\n+                \/\/ remove double quote marks from beginning\/end of the property\n+                if (property.length() > 1 && property.charAt(0) == '\"' &&\n+                        property.charAt(property.length() - 1) == '\"') {\n+                    property = property.substring(1, property.length() - 1);\n+                }\n+            }\n+\n+            ArrayList<String> groupList;\n+            if (property != null && !property.isEmpty()) {\n+                String[] groups = property.split(\",\");\n+                groupList = new ArrayList<>(groups.length);\n+                for (String group : groups) {\n+                    group = group.trim();\n+                    if (!group.isEmpty()) {\n+                        NamedGroup namedGroup = nameOf(group);\n+                        if (namedGroup != null) {\n+                            if (namedGroup.isAvailable) {\n+                                groupList.add(namedGroup.name);\n+                            }\n+                        }   \/\/ ignore unknown groups\n+                    }\n+                }\n+\n+                if (groupList.isEmpty()) {\n+                    throw new IllegalArgumentException(\n+                            \"System property jdk.tls.namedGroups(\" +\n+                            property + \") contains no supported named groups\");\n+                }\n+            } else {        \/\/ default groups\n+                NamedGroup[] groups = new NamedGroup[] {\n+\n+                        \/\/ Primary XDH (RFC 7748) curves\n+                        X25519,\n+\n+                        \/\/ Primary NIST Suite B curves\n+                        SECP256_R1,\n+                        SECP384_R1,\n+                        SECP521_R1,\n+\n+                        \/\/ Secondary XDH curves\n+                        X448,\n+\n+                        \/\/ FFDHE (RFC 7919)\n+                        FFDHE_2048,\n+                        FFDHE_3072,\n+                        FFDHE_4096,\n+                        FFDHE_6144,\n+                        FFDHE_8192,\n+                    };\n+\n+                groupList = new ArrayList<>(groups.length);\n+                for (NamedGroup group : groups) {\n+                    if (group.isAvailable) {\n+                        groupList.add(group.name);\n+                    }\n+                }\n+\n+                if (groupList.isEmpty() &&\n+                        SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                    SSLLogger.warning(\"No default named groups\");\n+                }\n+            }\n+\n+            namedGroups = groupList.toArray(new String[0]);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/NamedGroup.java","additions":207,"deletions":4,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -67,0 +67,3 @@\n+    \/\/ the configured named groups for the \"supported_groups\" extensions\n+    String[]                   namedGroups;\n+\n@@ -112,0 +115,4 @@\n+    \/\/ To switch off the supported_groups extension for DHE cipher suite.\n+    static final boolean enableFFDHE =\n+            Utilities.getBooleanProperty(\"jsse.enableFFDHE\", true);\n+\n@@ -149,0 +156,1 @@\n+        this.namedGroups = NamedGroup.SupportedGroups.namedGroups;\n@@ -204,0 +212,1 @@\n+        params.setNamedGroups(this.namedGroups);\n@@ -268,0 +277,9 @@\n+        String[] ngs = params.getNamedGroups();\n+        if (ngs != null) {\n+            \/\/ Note if 'ngs' is empty, then no named groups should be\n+            \/\/ specified over the connections.\n+            this.namedGroups = ngs;\n+        } else {    \/\/ Otherwise, use the default values.\n+            this.namedGroups = NamedGroup.SupportedGroups.namedGroups;\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLConfiguration.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-\n-import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;\n@@ -564,10 +562,0 @@\n-        static final Map<NamedGroup, T13KeyAgreement>\n-                supportedKeyShares = new HashMap<>();\n-\n-        static {\n-            for (NamedGroup namedGroup :\n-                    SupportedGroups.supportedNamedGroups) {\n-                supportedKeyShares.put(\n-                        namedGroup, new T13KeyAgreement(namedGroup));\n-            }\n-        }\n@@ -580,1 +568,1 @@\n-            return supportedKeyShares.get(namedGroup);\n+            return new T13KeyAgreement(namedGroup);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLKeyExchange.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;\n@@ -469,0 +468,1 @@\n+            SSLConfiguration sslConfig,\n@@ -522,1 +522,1 @@\n-                                SupportedGroups.isSupported(keyGroup)) {\n+                                NamedGroup.isEnabled(sslConfig, keyGroup)) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SignatureScheme.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.security.AlgorithmConstraints;\n@@ -34,1 +33,1 @@\n-import sun.security.action.GetPropertyAction;\n+\n@@ -67,4 +66,0 @@\n-        private SupportedGroupsSpec(int[] namedGroupsIds) {\n-            this.namedGroupsIds = namedGroupsIds;\n-        }\n-\n@@ -153,168 +148,0 @@\n-    static class SupportedGroups {\n-        \/\/ To switch off the supported_groups extension for DHE cipher suite.\n-        static final boolean enableFFDHE =\n-                Utilities.getBooleanProperty(\"jsse.enableFFDHE\", true);\n-\n-        \/\/ the supported named groups\n-        static final NamedGroup[] supportedNamedGroups;\n-\n-        static {\n-            \/\/ The value of the System Property defines a list of enabled named\n-            \/\/ groups in preference order, separated with comma.  For example:\n-            \/\/\n-            \/\/      jdk.tls.namedGroups=\"secp521r1, secp256r1, ffdhe2048\"\n-            \/\/\n-            \/\/ If the System Property is not defined or the value is empty, the\n-            \/\/ default groups and preferences will be used.\n-            String property = GetPropertyAction\n-                    .privilegedGetProperty(\"jdk.tls.namedGroups\");\n-            if (property != null && !property.isEmpty()) {\n-                \/\/ remove double quote marks from beginning\/end of the property\n-                if (property.length() > 1 && property.charAt(0) == '\"' &&\n-                        property.charAt(property.length() - 1) == '\"') {\n-                    property = property.substring(1, property.length() - 1);\n-                }\n-            }\n-\n-            ArrayList<NamedGroup> groupList;\n-            if (property != null && !property.isEmpty()) {\n-                String[] groups = property.split(\",\");\n-                groupList = new ArrayList<>(groups.length);\n-                for (String group : groups) {\n-                    group = group.trim();\n-                    if (!group.isEmpty()) {\n-                        NamedGroup namedGroup = NamedGroup.nameOf(group);\n-                        if (namedGroup != null) {\n-                            if (namedGroup.isAvailable) {\n-                                groupList.add(namedGroup);\n-                            }\n-                        }   \/\/ ignore unknown groups\n-                    }\n-                }\n-\n-                if (groupList.isEmpty()) {\n-                    throw new IllegalArgumentException(\n-                            \"System property jdk.tls.namedGroups(\" +\n-                            property + \") contains no supported named groups\");\n-                }\n-            } else {        \/\/ default groups\n-                NamedGroup[] groups = new NamedGroup[] {\n-\n-                        \/\/ Primary XDH (RFC 7748) curves\n-                        NamedGroup.X25519,\n-\n-                        \/\/ Primary NIST Suite B curves\n-                        NamedGroup.SECP256_R1,\n-                        NamedGroup.SECP384_R1,\n-                        NamedGroup.SECP521_R1,\n-\n-                        \/\/ Secondary XDH curves\n-                        NamedGroup.X448,\n-\n-                        \/\/ FFDHE (RFC 7919)\n-                        NamedGroup.FFDHE_2048,\n-                        NamedGroup.FFDHE_3072,\n-                        NamedGroup.FFDHE_4096,\n-                        NamedGroup.FFDHE_6144,\n-                        NamedGroup.FFDHE_8192,\n-                    };\n-\n-                groupList = new ArrayList<>(groups.length);\n-                for (NamedGroup group : groups) {\n-                    if (group.isAvailable) {\n-                        groupList.add(group);\n-                    }\n-                }\n-\n-                if (groupList.isEmpty() &&\n-                        SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n-                    SSLLogger.warning(\"No default named groups\");\n-                }\n-            }\n-\n-            supportedNamedGroups = new NamedGroup[groupList.size()];\n-            int i = 0;\n-            for (NamedGroup namedGroup : groupList) {\n-                supportedNamedGroups[i++] = namedGroup;\n-            }\n-        }\n-\n-        \/\/ Is there any supported group permitted by the constraints?\n-        static boolean isActivatable(\n-                AlgorithmConstraints constraints, NamedGroupSpec type) {\n-\n-            boolean hasFFDHEGroups = false;\n-            for (NamedGroup namedGroup : supportedNamedGroups) {\n-                if (namedGroup.isAvailable && namedGroup.spec == type) {\n-                    if (namedGroup.isPermitted(constraints)) {\n-                        return true;\n-                    }\n-\n-                    if (!hasFFDHEGroups &&\n-                            (type == NamedGroupSpec.NAMED_GROUP_FFDHE)) {\n-                        hasFFDHEGroups = true;\n-                    }\n-                }\n-            }\n-\n-            \/\/ For compatibility, if no FFDHE groups are defined, the non-FFDHE\n-            \/\/ compatible mode (using DHE cipher suite without FFDHE extension)\n-            \/\/ is allowed.\n-            \/\/\n-            \/\/ Note that the constraints checking on DHE parameters will be\n-            \/\/ performed during key exchanging in a handshake.\n-            return !hasFFDHEGroups && type == NamedGroupSpec.NAMED_GROUP_FFDHE;\n-        }\n-\n-        \/\/ Is the named group permitted by the constraints?\n-        static boolean isActivatable(\n-                AlgorithmConstraints constraints, NamedGroup namedGroup) {\n-            if (!namedGroup.isAvailable || !isSupported(namedGroup)) {\n-                return false;\n-            }\n-\n-            return namedGroup.isPermitted(constraints);\n-        }\n-\n-        \/\/ Is the named group supported?\n-        static boolean isSupported(NamedGroup namedGroup) {\n-            for (NamedGroup group : supportedNamedGroups) {\n-                if (namedGroup.id == group.id) {\n-                    return true;\n-                }\n-            }\n-\n-            return false;\n-        }\n-\n-        static NamedGroup getPreferredGroup(\n-                ProtocolVersion negotiatedProtocol,\n-                AlgorithmConstraints constraints, NamedGroupSpec[] types,\n-                List<NamedGroup> requestedNamedGroups) {\n-            for (NamedGroup namedGroup : requestedNamedGroups) {\n-                if ((NamedGroupSpec.arrayContains(types, namedGroup.spec)) &&\n-                        namedGroup.isAvailable(negotiatedProtocol) &&\n-                        isSupported(namedGroup) &&\n-                        namedGroup.isPermitted(constraints)) {\n-                    return namedGroup;\n-                }\n-            }\n-\n-            return null;\n-        }\n-\n-        static NamedGroup getPreferredGroup(\n-                ProtocolVersion negotiatedProtocol,\n-                AlgorithmConstraints constraints, NamedGroupSpec[] types) {\n-            for (NamedGroup namedGroup : supportedNamedGroups) {\n-                if ((NamedGroupSpec.arrayContains(types, namedGroup.spec)) &&\n-                        namedGroup.isAvailable(negotiatedProtocol) &&\n-                        namedGroup.isPermitted(constraints)) {\n-                    return namedGroup;\n-                }\n-            }\n-\n-            return null;\n-        }\n-    }\n-\n@@ -349,3 +176,12 @@\n-                new ArrayList<>(SupportedGroups.supportedNamedGroups.length);\n-            for (NamedGroup ng : SupportedGroups.supportedNamedGroups) {\n-                if ((!SupportedGroups.enableFFDHE) &&\n+                    new ArrayList<>(chc.sslConfig.namedGroups.length);\n+            for (String name : chc.sslConfig.namedGroups) {\n+                NamedGroup ng = NamedGroup.nameOf(name);\n+                if (ng == null) {\n+                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                        SSLLogger.fine(\n+                                \"Ignore unspecified named group: \" + name);\n+                    }\n+                    continue;\n+                }\n+\n+                if ((!SSLConfiguration.enableFFDHE) &&\n@@ -498,3 +334,13 @@\n-                    SupportedGroups.supportedNamedGroups.length);\n-            for (NamedGroup ng : SupportedGroups.supportedNamedGroups) {\n-                if ((!SupportedGroups.enableFFDHE) &&\n+                    shc.sslConfig.namedGroups.length);\n+            for (String name : shc.sslConfig.namedGroups) {\n+                NamedGroup ng = NamedGroup.nameOf(name);\n+                if (ng == null) {\n+                    if (SSLLogger.isOn &&\n+                            SSLLogger.isOn(\"ssl,handshake\")) {\n+                        SSLLogger.fine(\n+                                \"Ignore unspecified named group: \" + name);\n+                    }\n+                    continue;\n+                }\n+\n+                if ((!SSLConfiguration.enableFFDHE) &&\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SupportedGroupsExtension.java","additions":26,"deletions":180,"binary":false,"changes":206,"status":"modified"},{"patch":"@@ -42,2 +42,0 @@\n-import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;\n-\n@@ -347,1 +345,1 @@\n-                        (!SupportedGroups.isSupported(namedGroup)) ||\n+                        (!NamedGroup.isEnabled(shc.sslConfig, namedGroup)) ||\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/X509Authentication.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.internal.access.SharedSecrets;\n@@ -54,1 +55,1 @@\n-            \/\/ Use the new java.io.Console class\n+            \/\/ Only use Console if `in` is the initial System.in\n@@ -56,1 +57,3 @@\n-            if (!isEchoOn && in == System.in && ((con = System.console()) != null)) {\n+            if (!isEchoOn &&\n+                    in == SharedSecrets.getJavaLangAccess().initialSystemIn() &&\n+                    ((con = System.console()) != null)) {\n@@ -58,1 +61,1 @@\n-                \/\/ readPassword returns \"\" if you just print ENTER,\n+                \/\/ readPassword returns \"\" if you just press ENTER with the built-in Console,\n@@ -60,1 +63,1 @@\n-                if (consoleEntered != null && consoleEntered.length == 0) {\n+                if (consoleEntered == null || consoleEntered.length == 0) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Password.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -404,1 +404,2 @@\n-            if (otherAddress.length == 4 && address.length == 4)\n+            if ((otherAddress.length == 4 && address.length == 4) ||\n+                    (otherAddress.length == 16 && address.length == 16)) {\n@@ -407,2 +408,2 @@\n-            else if ((otherAddress.length == 8 && address.length == 8) ||\n-                     (otherAddress.length == 32 && address.length == 32)) {\n+            } else if ((otherAddress.length == 8 && address.length == 8) ||\n+                       (otherAddress.length == 32 && address.length == 32)) {\n@@ -443,1 +444,2 @@\n-            } else if (otherAddress.length == 8 || otherAddress.length == 32) {\n+            } else if ((otherAddress.length == 8 && address.length == 4) ||\n+                       (otherAddress.length == 32 && address.length == 16)) {\n@@ -457,1 +459,2 @@\n-            } else if (address.length == 8 || address.length == 32) {\n+            } else if ((otherAddress.length == 4 && address.length == 8) ||\n+                       (otherAddress.length == 16 && address.length == 32)) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/IPAddressName.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -433,0 +433,1 @@\n+            {\"America\/Ciudad_Juarez\", MST},\n","filename":"src\/java.base\/share\/classes\/sun\/util\/resources\/TimeZoneNames.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-tzdata2022f\n+tzdata2022g\n","filename":"src\/java.base\/share\/data\/tzdata\/VERSION","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -614,0 +614,4 @@\n+\n+# Morocco\n+# See Africa\/Ceuta for Spanish Morocco.\n+\n","filename":"src\/java.base\/share\/data\/tzdata\/africa","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3611,1 +3611,1 @@\n-\t\t\t7:30\t-\t+0730\t1982 Jan  1\n+\t\t\t7:30\t-\t+0730\t1981 Dec 31 16:00u\n","filename":"src\/java.base\/share\/data\/tzdata\/asia","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -293,0 +293,1 @@\n+Link\tAmerica\/Iqaluit\t\tAmerica\/Pangnirtung\n","filename":"src\/java.base\/share\/data\/tzdata\/backward","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1129,1 +1129,24 @@\n-#\n+\n+# From Jonas Nyrup (2022-11-24):\n+# On last Saturday in October 2023 when DST ends America\/Nuuk will switch\n+# from -03\/-02 to -02\/-01\n+# https:\/\/sermitsiaq.ag\/forslagtidsforskel-danmark-mindskes-sommertid-beholdes\n+# ...\n+# https:\/\/sermitsiaq.ag\/groenland-skifte-tidszone-trods-bekymringer\n+#\n+# From Jürgen Appel (2022-11-25):\n+# https:\/\/ina.gl\/samlinger\/oversigt-over-samlinger\/samling\/dagsordener\/dagsorden.aspx?lang=da&day=24-11-2022\n+# If I understand this correctly, from the next planned switch to\n+# summer time, Greenland will permanently stay at that time, i.e. no\n+# switch back to winter time in 2023 will occur.\n+#\n+# From Paul Eggert (2022-11-28):\n+# The official document in Danish\n+# https:\/\/naalakkersuisut.gl\/-\/media\/naalakkersuisut\/filer\/kundgoerelser\/2022\/11\/2511\/31_da_inatsisartutlov-om-tidens-bestemmelse.pdf?la=da&hash=A33597D8A38CC7038465241119EF34F3\n+# says standard time for Greenland is -02, that Naalakkersuisut can lay down\n+# rules for DST and can require some areas to use a different time zone,\n+# and that this all takes effect 2023-03-25 22:00.  The abovementioned\n+# \"bekymringer\" URL says the intent is no transition March 25, that\n+# Greenland will not go back to winter time in fall 2023, and that\n+# only America\/Nuuk is affected (though further changes may occur).\n+\n@@ -1152,1 +1175,2 @@\n-\t\t\t-3:00\tEU\t-03\/-02\n+\t\t\t-3:00\tEU\t-03\/-02\t2023 Mar 25 22:00\n+\t\t\t-2:00\t-\t-02\n","filename":"src\/java.base\/share\/data\/tzdata\/europe","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-# From Paul Eggert (2015-05-02):\n+# From Paul Eggert (2022-11-18):\n@@ -35,1 +35,1 @@\n-#     ISO 3166-1 N976 (2018-11-06).  See: Updates on ISO 3166-1\n+#     ISO 3166-1 N1087 (2022-09-02).  See: Updates on ISO 3166-1\n@@ -264,1 +264,1 @@\n-TF\tFrench Southern & Antarctic Lands\n+TF\tFrench Southern Territories\n","filename":"src\/java.base\/share\/data\/tzdata\/iso3166.tab","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1995,0 +1995,31 @@\n+# From Chris Walton (2022-11-06):\n+# Whitehorse Star - Thursday April 22, 1965 - page 1\n+# title: DST Starts Monday ...\n+# https:\/\/www.newspapers.com\/image\/578587481\/\n+# The title of this first article is wrong and\/or misleading.\n+# Also, the start time shown in the  article is vague; it simply says \"after\n+# midnight\" when it probably should have stated 2:00a.m....\n+#\n+# Whitehorse Star - Monday October 25, 1965 - page 15 ...\n+# https:\/\/www.newspapers.com\/image\/578589147\/\n+# The 1965 Yukon Council minutes can be found here:\n+# http:\/\/assets.yukonarchives.ca\/PER_YG_06_1965_C20_S02_v1.pdf\n+# ... I do not currently believe that NWT touched any of its clocks in 1965....\n+#\n+# Whitehorse Star - Thursday Feb 24,1966 - page 2\n+# title: It's Time for YDT ...\n+# https:\/\/www.newspapers.com\/image\/578575979\/ ...\n+# America\/Whitehorse as a permanent change from UTC-9(YST) to\n+# UTC-8(PST) at 00:00 on Sunday February 27, 1966....\n+#\n+# Whitehorse Star - Friday April 28,1972 - page 6\n+# title: Daylight Saving Time for N.W.T....\n+# https:\/\/www.newspapers.com\/image\/578701610\/ ...\n+# Nunavut and NWT zones ... DST starting in 1972.... Start and End ...\n+# should be the same as the rest of Canada\n+#\n+#\n+# From Paul Eggert (2022-11-06):\n+# For now, assume Yukon's 1965-04-22 spring forward was 00:00 -> 02:00, as this\n+# seems likely than 02:00 -> 04:00 and matches \"after midnight\".\n+\n@@ -2109,0 +2140,7 @@\n+# From Chris Walton (2022-11-06):\n+# The 5th edition of the Atlas of Canada contains a time zone map that\n+# shows both legislated and observed time zone boundaries.\n+# All communities on Baffin Island are shown to be observing Eastern time.\n+# The date on the map is 1984.\n+# https:\/\/ftp.maps.canada.ca\/pub\/nrcan_rncan\/raster\/atlas_5_ed\/eng\/other\/referencemaps\/mcr4056.pdf\n+\n@@ -2121,34 +2159,1 @@\n-# (1999) reports that Pangnirtung operates on eastern time,\n-# and that Coral Harbour does not observe DST.  We don't know when\n-# Pangnirtung switched to eastern time; we'll guess 1995.\n-\n-# From Rives McDow (1999-11-08):\n-# On October 31, when the rest of Nunavut went to Central time,\n-# Pangnirtung wobbled.  Here is the result of their wobble:\n-#\n-# The following businesses and organizations in Pangnirtung use Central Time:\n-#\n-#\tFirst Air, Power Corp, Nunavut Construction, Health Center, RCMP,\n-#\tEastern Arctic National Parks, A & D Specialist\n-#\n-# The following businesses and organizations in Pangnirtung use Eastern Time:\n-#\n-#\tHamlet office, All other businesses, Both schools, Airport operator\n-#\n-# This has made for an interesting situation there, which warranted the news.\n-# No one there that I spoke with seems concerned, or has plans to\n-# change the local methods of keeping time, as it evidently does not\n-# really interfere with any activities or make things difficult locally.\n-# They plan to celebrate New Year's turn-over twice, one hour apart,\n-# so it appears that the situation will last at least that long.\n-# The Nunavut Intergovernmental Affairs hopes that they will \"come to\n-# their senses\", but the locals evidently don't see any problem with\n-# the current state of affairs.\n-\n-# From Michaela Rodrigue, writing in the\n-# Nunatsiaq News (1999-11-19):\n-# http:\/\/www.nunatsiaqonline.ca\/archives\/nunavut991130\/nvt91119_17.html\n-# Clyde River, Pangnirtung and Sanikiluaq now operate with two time zones,\n-# central - or Nunavut time - for government offices, and eastern time\n-# for municipal offices and schools....  Igloolik [was similar but then]\n-# made the switch to central time on Saturday, Nov. 6.\n+# (1999) reports that ... Coral Harbour does not observe DST.\n@@ -2313,4 +2318,2 @@\n-Rule\tNT_YK\t1965\tonly\t-\tApr\tlastSun\t0:00\t2:00\tDD\n-Rule\tNT_YK\t1965\tonly\t-\tOct\tlastSun\t2:00\t0\tS\n-Rule\tNT_YK\t1980\t1986\t-\tApr\tlastSun\t2:00\t1:00\tD\n-Rule\tNT_YK\t1980\t2006\t-\tOct\tlastSun\t2:00\t0\tS\n+Rule\tNT_YK\t1972\t1986\t-\tApr\tlastSun\t2:00\t1:00\tD\n+Rule\tNT_YK\t1972\t2006\t-\tOct\tlastSun\t2:00\t0\tS\n@@ -2318,0 +2321,2 @@\n+Rule\tYukon\t1965\tonly\t-\tApr\tlastSun\t0:00\t2:00\tDD\n+Rule\tYukon\t1965\tonly\t-\tOct\tlastSun\t2:00\t0\tS\n@@ -2319,6 +2324,0 @@\n-# aka Panniqtuuq\n-Zone America\/Pangnirtung 0\t-\t-00\t1921 # trading post est.\n-\t\t\t-4:00\tNT_YK\tA%sT\t1995 Apr Sun>=1  2:00\n-\t\t\t-5:00\tCanada\tE%sT\t1999 Oct 31  2:00\n-\t\t\t-6:00\tCanada\tC%sT\t2000 Oct 29  2:00\n-\t\t\t-5:00\tCanada\tE%sT\n@@ -2357,2 +2356,3 @@\n-\t\t\t-9:00\tNT_YK\tY%sT\t1967 May 28  0:00\n-\t\t\t-8:00\tNT_YK\tP%sT\t1980\n+\t\t\t-9:00\tNT_YK\tY%sT\t1965\n+\t\t\t-9:00\tYukon\tY%sT\t1966 Feb 27  0:00\n+\t\t\t-8:00\t-\tPST\t1980\n@@ -2362,2 +2362,3 @@\n-\t\t\t-9:00\tNT_YK\tY%sT\t1973 Oct 28  0:00\n-\t\t\t-8:00\tNT_YK\tP%sT\t1980\n+\t\t\t-9:00\tNT_YK\tY%sT\t1965\n+\t\t\t-9:00\tYukon\tY%sT\t1973 Oct 28  0:00\n+\t\t\t-8:00\t-\tPST\t1980\n@@ -2585,0 +2586,8 @@\n+# From Heitor David Pinto (2022-11-28):\n+# Now the northern municipalities want to have the same time zone as the\n+# respective neighboring cities in the US, for example Juárez in UTC-7 with\n+# DST, matching El Paso, and Ojinaga in UTC-6 with DST, matching Presidio....\n+# the president authorized the publication of the decree for November 29,\n+# so the time change would occur on November 30 at 0:00.\n+# http:\/\/puentelibre.mx\/noticia\/ciudad_juarez_cambio_horario_noviembre_2022\/\n+\n@@ -2616,3 +2625,3 @@\n-#   in Coahuila: Ocampo, Acuña, Zaragoza, Jiménez, Piedras Negras, Nava,\n-#     Guerrero, Hidalgo.\n-#   in Nuevo León: Anáhuac, Los Aldama.\n+#   in Coahuila: Acuña, Allende, Guerrero, Hidalgo, Jiménez, Morelos, Nava,\n+#     Ocampo, Piedras Negras, Villa Unión, Zaragoza\n+#   in Nuevo León: Anáhuac\n@@ -2621,3 +2630,1 @@\n-# See: Inicia mañana Horario de Verano en zona fronteriza, El Universal,\n-# 2016-03-12\n-# http:\/\/www.eluniversal.com.mx\/articulo\/estados\/2016\/03\/12\/inicia-manana-horario-de-verano-en-zona-fronteriza\n+# https:\/\/www.dof.gob.mx\/nota_detalle.php?codigo=5670045&fecha=28\/10\/2022\n@@ -2642,1 +2649,1 @@\n-# Chihuahua (near US border)\n+# Chihuahua (near US border - western side)\n@@ -2644,2 +2651,16 @@\n-# Práxedis G Guerrero, Coyame del Sotol, Ojinaga, and Manuel Benavides.\n-# (See the 2016-03-12 El Universal source mentioned above.)\n+# and Práxedis G Guerrero.\n+# http:\/\/gaceta.diputados.gob.mx\/PDF\/65\/2a022\/nov\/20221124-VII.pdf\n+Zone America\/Ciudad_Juarez -7:05:56 -\tLMT\t1922 Jan  1  7:00u\n+\t\t\t-7:00\t-\tMST\t1927 Jun 10 23:00\n+\t\t\t-6:00\t-\tCST\t1930 Nov 15\n+\t\t\t-7:00\tMexico\tM%sT\t1932 Apr  1\n+\t\t\t-6:00\t-\tCST\t1996\n+\t\t\t-6:00\tMexico\tC%sT\t1998\n+\t\t\t-6:00\t-\tCST\t1998 Apr Sun>=1  3:00\n+\t\t\t-7:00\tMexico\tM%sT\t2010\n+\t\t\t-7:00\tUS\tM%sT\t2022 Oct 30  2:00\n+\t\t\t-6:00\t-\tCST\t2022 Nov 30  0:00\n+\t\t\t-7:00\tUS\tM%sT\n+# Chihuahua (near US border - eastern side)\n+# The municipalities of Coyame del Sotol, Ojinaga, and Manuel Benavides.\n+# http:\/\/gaceta.diputados.gob.mx\/PDF\/65\/2a022\/nov\/20221124-VII.pdf\n@@ -2655,1 +2676,2 @@\n-\t\t\t-6:00\t-\tCST\n+\t\t\t-6:00\t-\tCST\t2022 Nov 30  0:00\n+\t\t\t-6:00\tUS\tC%sT\n@@ -2677,0 +2699,12 @@\n+# Baja California Sur, Nayarit (except Bahía de Banderas), Sinaloa\n+Zone America\/Mazatlan\t-7:05:40 -\tLMT\t1922 Jan  1  7:00u\n+\t\t\t-7:00\t-\tMST\t1927 Jun 10 23:00\n+\t\t\t-6:00\t-\tCST\t1930 Nov 15\n+\t\t\t-7:00\tMexico\tM%sT\t1932 Apr  1\n+\t\t\t-6:00\t-\tCST\t1942 Apr 24\n+\t\t\t-7:00\t-\tMST\t1949 Jan 14\n+\t\t\t-8:00\t-\tPST\t1970\n+\t\t\t-7:00\tMexico\tM%sT\n+\n+# Bahía de Banderas\n+\n@@ -2704,11 +2738,0 @@\n-# Mazatlán\n-Zone America\/Mazatlan\t-7:05:40 -\tLMT\t1922 Jan  1  7:00u\n-\t\t\t-7:00\t-\tMST\t1927 Jun 10 23:00\n-\t\t\t-6:00\t-\tCST\t1930 Nov 15\n-\t\t\t-7:00\tMexico\tM%sT\t1932 Apr  1\n-\t\t\t-6:00\t-\tCST\t1942 Apr 24\n-\t\t\t-7:00\t-\tMST\t1949 Jan 14\n-\t\t\t-8:00\t-\tPST\t1970\n-\t\t\t-7:00\tMexico\tM%sT\n-\n-# Bahía de Banderas\n","filename":"src\/java.base\/share\/data\/tzdata\/northamerica","additions":92,"deletions":69,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -1444,0 +1444,5 @@\n+# From Alois Treindl (2022-11-10):\n+# End of time change in Colombia 1993 ... should be 6 February 24h ...\n+# DECRETO 267 DE 1993\n+# https:\/\/www.suin-juriscol.gov.co\/viewDocument.asp?ruta=Decretos\/1061335\n+\n@@ -1445,2 +1450,2 @@\n-Rule\tCO\t1992\tonly\t-\tMay\t 3\t0:00\t1:00\t-\n-Rule\tCO\t1993\tonly\t-\tApr\t 4\t0:00\t0\t-\n+Rule\tCO\t1992\tonly\t-\tMay\t 3\t 0:00\t1:00\t-\n+Rule\tCO\t1993\tonly\t-\tFeb\t 6\t24:00\t0\t-\n","filename":"src\/java.base\/share\/data\/tzdata\/southamerica","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -140,2 +140,1 @@\n-CA\t+6344-06828\tAmerica\/Iqaluit\tEastern - NU (most east areas)\n-CA\t+6608-06544\tAmerica\/Pangnirtung\tEastern - NU (Pangnirtung)\n+CA\t+6344-06828\tAmerica\/Iqaluit\tEastern - NU (most areas)\n@@ -303,11 +302,12 @@\n-MX\t+1924-09909\tAmerica\/Mexico_City\tCentral Time\n-MX\t+2105-08646\tAmerica\/Cancun\tEastern Standard Time - Quintana Roo\n-MX\t+2058-08937\tAmerica\/Merida\tCentral Time - Campeche, Yucatan\n-MX\t+2540-10019\tAmerica\/Monterrey\tCentral Time - Durango; Coahuila, Nuevo Leon, Tamaulipas (most areas)\n-MX\t+2550-09730\tAmerica\/Matamoros\tCentral Time US - Coahuila, Nuevo Leon, Tamaulipas (US border)\n-MX\t+2313-10625\tAmerica\/Mazatlan\tMountain Time - Baja California Sur, Nayarit, Sinaloa\n-MX\t+2838-10605\tAmerica\/Chihuahua\tMountain Time - Chihuahua (most areas)\n-MX\t+2934-10425\tAmerica\/Ojinaga\tMountain Time US - Chihuahua (US border)\n-MX\t+2904-11058\tAmerica\/Hermosillo\tMountain Standard Time - Sonora\n-MX\t+3232-11701\tAmerica\/Tijuana\tPacific Time US - Baja California\n-MX\t+2048-10515\tAmerica\/Bahia_Banderas\tCentral Time - Bahia de Banderas\n+MX\t+1924-09909\tAmerica\/Mexico_City\tCentral Mexico\n+MX\t+2105-08646\tAmerica\/Cancun\tQuintana Roo\n+MX\t+2058-08937\tAmerica\/Merida\tCampeche, Yucatan\n+MX\t+2540-10019\tAmerica\/Monterrey\tDurango; Coahuila, Nuevo Leon, Tamaulipas (most areas)\n+MX\t+2550-09730\tAmerica\/Matamoros\tCoahuila, Nuevo Leon, Tamaulipas (US border)\n+MX\t+2838-10605\tAmerica\/Chihuahua\tChihuahua (most areas)\n+MX\t+3144-10629\tAmerica\/Ciudad_Juarez\tChihuahua (US border - west)\n+MX\t+2934-10425\tAmerica\/Ojinaga\tChihuahua (US border - east)\n+MX\t+2313-10625\tAmerica\/Mazatlan\tBaja California Sur, Nayarit (most areas), Sinaloa\n+MX\t+2048-10515\tAmerica\/Bahia_Banderas\tBahia de Banderas\n+MX\t+2904-11058\tAmerica\/Hermosillo\tSonora\n+MX\t+3232-11701\tAmerica\/Tijuana\tBaja California\n","filename":"src\/java.base\/share\/data\/tzdata\/zone.tab","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -137,0 +137,1 @@\n+    permission java.lang.RuntimePermission \"accessClassInPackage.jdk.internal.access\";\n","filename":"src\/java.base\/share\/lib\/security\/default.policy","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,3 +53,6 @@\n-    {\"extentLocalCache\",  \"()[\" OBJ,    (void *)&JVM_ExtentLocalCache},\n-    {\"setExtentLocalCache\", \"([\" OBJ \")V\",(void *)&JVM_SetExtentLocalCache},\n-    {\"getNextThreadIdOffset\", \"()J\",     (void *)&JVM_GetNextThreadIdOffset}\n+    {\"scopedValueCache\", \"()[\" OBJ,    (void *)&JVM_ScopedValueCache},\n+    {\"setScopedValueCache\", \"([\" OBJ \")V\",(void *)&JVM_SetScopedValueCache},\n+    {\"getNextThreadIdOffset\", \"()J\",   (void *)&JVM_GetNextThreadIdOffset},\n+    {\"findScopedValueBindings\", \"()\" OBJ, (void *)&JVM_FindScopedValueBindings},\n+    {\"ensureMaterializedForStackWalk\",\n+                         \"(\" OBJ \")V\", (void*)&JVM_EnsureMaterializedForStackWalk_func},\n","filename":"src\/java.base\/share\/native\/libjava\/Thread.c","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -261,2 +261,2 @@\n-    description=CSS File;\\\n-    file_extensions=.css;\n+\tdescription=CSS File;\\\n+\tfile_extensions=.css;\n@@ -270,2 +270,2 @@\n-    description=JavaScript File;\\\n-    file_extensions=.js;\n+\tdescription=JavaScript File;\\\n+\tfile_extensions=.js;\n@@ -292,2 +292,2 @@\n-    description=Markdown File;\\\n-    file_extensions=.md,.markdown\n+\tdescription=Markdown File;\\\n+\tfile_extensions=.md,.markdown\n@@ -356,1 +356,1 @@\n-    description=Microsoft Excel File;\\\n+\tdescription=Microsoft Excel File;\\\n@@ -398,0 +398,4 @@\n+\n+application\/wasm: \\\n+\tdescription=WebAssembly File;\\\n+\tfile_extensions=.wasm;\n","filename":"src\/java.base\/unix\/classes\/sun\/net\/www\/content-types.properties","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.ref.Reference;\n@@ -33,0 +32,3 @@\n+\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -46,0 +48,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -177,1 +181,2 @@\n-        if (dst instanceof sun.nio.ch.DirectBuffer buf) {\n+        if (dst instanceof sun.nio.ch.DirectBuffer ddst) {\n+            NIO_ACCESS.acquireSession(dst);\n@@ -179,1 +184,1 @@\n-                long address = buf.address() + pos;\n+                long address = ddst.address() + pos;\n@@ -184,1 +189,1 @@\n-                Reference.reachabilityFence(buf);\n+                NIO_ACCESS.releaseSession(dst);\n@@ -240,0 +245,1 @@\n+            NIO_ACCESS.acquireSession(src);\n@@ -246,1 +252,1 @@\n-                Reference.reachabilityFence(buf);\n+                NIO_ACCESS.releaseSession(src);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixUserDefinedFileAttributeView.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -262,2 +262,2 @@\n-    description=CSS File;\\\n-    file_extensions=.css;\n+\tdescription=CSS File;\\\n+\tfile_extensions=.css;\n@@ -293,2 +293,2 @@\n-    description=Markdown File;\\\n-    file_extensions=.md,.markdown\n+\tdescription=Markdown File;\\\n+\tfile_extensions=.md,.markdown\n@@ -390,1 +390,5 @@\n-    file_extensions=.jar;\n+\tfile_extensions=.jar;\n+\n+application\/wasm: \\\n+\tdescription=WebAssembly File;\\\n+\tfile_extensions=.wasm;\n","filename":"src\/java.base\/windows\/classes\/sun\/net\/www\/content-types.properties","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -72,0 +72,3 @@\n+     *  20: no changes (pattern matching for switch in fourth preview,\n+     *      record patterns in second preview)\n+     *  21: tbd\n@@ -365,0 +368,2 @@\n+     * No major changes from the prior release.\n+     *\n@@ -371,1 +376,13 @@\n-    RELEASE_20;\n+    RELEASE_20,\n+\n+    \/**\n+     * The version recognized by the Java Platform, Standard Edition\n+     * 21.\n+     *\n+     * @since 21\n+     *\n+     * @see <a\n+     * href=\"https:\/\/docs.oracle.com\/javase\/specs\/jls\/se21\/html\/index.html\">\n+     * <cite>The Java Language Specification, Java SE 21 Edition<\/cite><\/a>\n+     *\/\n+    RELEASE_21;\n@@ -380,1 +397,1 @@\n-        return RELEASE_20;\n+        return RELEASE_21;\n@@ -395,1 +412,1 @@\n-            valueOf(\"RELEASE_\" + Math.min(20, intVersion)):\n+            valueOf(\"RELEASE_\" + Math.min(21, intVersion)):\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/SourceVersion.java","additions":20,"deletions":3,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-@SupportedSourceVersion(RELEASE_20)\n+@SupportedSourceVersion(RELEASE_21)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractAnnotationValueVisitor14.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-@SupportedSourceVersion(RELEASE_20)\n+@SupportedSourceVersion(RELEASE_21)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractElementVisitor14.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-@SupportedSourceVersion(RELEASE_20)\n+@SupportedSourceVersion(RELEASE_21)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractTypeVisitor14.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-@SupportedSourceVersion(RELEASE_20)\n+@SupportedSourceVersion(RELEASE_21)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementKindVisitor14.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-@SupportedSourceVersion(RELEASE_20)\n+@SupportedSourceVersion(RELEASE_21)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementScanner14.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-@SupportedSourceVersion(RELEASE_20)\n+@SupportedSourceVersion(RELEASE_21)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleAnnotationValueVisitor14.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-@SupportedSourceVersion(RELEASE_20)\n+@SupportedSourceVersion(RELEASE_21)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleElementVisitor14.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-@SupportedSourceVersion(RELEASE_20)\n+@SupportedSourceVersion(RELEASE_21)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleTypeVisitor14.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-@SupportedSourceVersion(RELEASE_20)\n+@SupportedSourceVersion(RELEASE_21)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/TypeKindVisitor14.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -289,12 +289,0 @@\n-\n-        if ((c instanceof JCheckBox) && (state & SynthConstants.DISABLED) != 0) {\n-            if (UIManager.getColor(\"CheckBox.disabledText\") != null) {\n-                return UIManager.getColor(\"CheckBox.disabledText\");\n-            }\n-        } else if ((c instanceof JRadioButton) &&\n-                (state & SynthConstants.DISABLED) != 0) {\n-            if (UIManager.getColor(\"RadioButton.disabledText\") != null) {\n-                return UIManager.getColor(\"RadioButton.disabledText\");\n-            }\n-        }\n-\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKStyle.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,1 +126,4 @@\n-\n+            if (data.length < 3 || (data[1] & 0xFF) != 0x7E && (data[1] & 0xFF) != 0x7F ) {\n+                \/\/ Not enough data to determine SysEx type or SysEx type is not supported\n+                return;\n+            }\n@@ -131,0 +134,3 @@\n+                    if (data.length < 4) {\n+                        return;\n+                    }\n@@ -134,15 +140,21 @@\n-                    case 0x08:  \/\/ MIDI Tuning Standard\n-                        subid2 = data[4] & 0xFF;\n-                        switch (subid2) {\n-                        case 0x01:  \/\/ BULK TUNING DUMP\n-                        {\n-                            \/\/ http:\/\/www.midi.org\/about-midi\/tuning.shtml\n-                            SoftTuning tuning = synth.getTuning(new Patch(0,\n-                                    data[5] & 0xFF));\n-                            tuning.load(data);\n-                            break;\n-                        }\n-                        case 0x04:  \/\/ KEY-BASED TUNING DUMP\n-                        case 0x05:  \/\/ SCALE\/OCTAVE TUNING DUMP, 1 byte format\n-                        case 0x06:  \/\/ SCALE\/OCTAVE TUNING DUMP, 2 byte format\n-                        case 0x07:  \/\/ SINGLE NOTE TUNING CHANGE (NON REAL-TIME)\n+                        case 0x08:  \/\/ MIDI Tuning Standard\n+                            if (data.length < 5) {\n+                                break;\n+                            }\n+                            subid2 = data[4] & 0xFF;\n+                            switch (subid2) {\n+                                case 0x01:  \/\/ BULK TUNING DUMP\n+                                {\n+                                    if (data.length < 6) {\n+                                        break;\n+                                    }\n+                                    \/\/ http:\/\/www.midi.org\/about-midi\/tuning.shtml\n+                                    SoftTuning tuning = synth.getTuning(new Patch(0,\n+                                            data[5] & 0xFF));\n+                                    tuning.load(data);\n+                                    break;\n+                                }\n+                                case 0x04:  \/\/ KEY-BASED TUNING DUMP\n+                                case 0x05:  \/\/ SCALE\/OCTAVE TUNING DUMP, 1 byte format\n+                                case 0x06:  \/\/ SCALE\/OCTAVE TUNING DUMP, 2 byte format\n+                                case 0x07:  \/\/ SINGLE NOTE TUNING CHANGE (NON REAL-TIME)\n@@ -150,8 +162,11 @@\n-                        {\n-                            \/\/ http:\/\/www.midi.org\/about-midi\/tuning_extens.shtml\n-                            SoftTuning tuning = synth.getTuning(new Patch(\n-                                    data[5] & 0xFF, data[6] & 0xFF));\n-                            tuning.load(data);\n-                            break;\n-                        }\n-                        case 0x08:  \/\/ scale\/octave tuning 1-byte form (Non\n+                                {\n+                                    if (data.length < 7) {\n+                                        break;\n+                                    }\n+                                    \/\/ http:\/\/www.midi.org\/about-midi\/tuning_extens.shtml\n+                                    SoftTuning tuning = synth.getTuning(new Patch(\n+                                            data[5] & 0xFF, data[6] & 0xFF));\n+                                    tuning.load(data); \/\/ Check inside!\n+                                    break;\n+                                }\n+                                case 0x08:  \/\/ scale\/octave tuning 1-byte form (Non\n@@ -159,1 +174,1 @@\n-                        case 0x09:  \/\/ scale\/octave tuning 2-byte form (Non\n+                                case 0x09:  \/\/ scale\/octave tuning 2-byte form (Non\n@@ -161,47 +176,17 @@\n-                        {\n-                            \/\/ http:\/\/www.midi.org\/about-midi\/tuning-scale.shtml\n-                            SoftTuning tuning = new SoftTuning(data);\n-                            int channelmask = (data[5] & 0xFF) * 16384\n-                                    + (data[6] & 0xFF) * 128 + (data[7] & 0xFF);\n-                            SoftChannel[] channels = synth.channels;\n-                            for (int i = 0; i < channels.length; i++)\n-                                if ((channelmask & (1 << i)) != 0)\n-                                    channels[i].tuning = tuning;\n-                            break;\n-                        }\n-                        default:\n-                            break;\n-                        }\n-                        break;\n-                    case 0x09:  \/\/ General Midi Message\n-                        subid2 = data[4] & 0xFF;\n-                        switch (subid2) {\n-                        case 0x01:  \/\/ General Midi 1 On\n-                            synth.setGeneralMidiMode(1);\n-                            reset();\n-                            break;\n-                        case 0x02:  \/\/ General Midi Off\n-                            synth.setGeneralMidiMode(0);\n-                            reset();\n-                            break;\n-                        case 0x03:  \/\/ General MidI Level 2 On\n-                            synth.setGeneralMidiMode(2);\n-                            reset();\n-                            break;\n-                        default:\n-                            break;\n-                        }\n-                        break;\n-                    case 0x0A: \/\/ DLS Message\n-                        subid2 = data[4] & 0xFF;\n-                        switch (subid2) {\n-                        case 0x01:  \/\/ DLS On\n-                            if (synth.getGeneralMidiMode() == 0)\n-                                synth.setGeneralMidiMode(1);\n-                            synth.voice_allocation_mode = 1;\n-                            reset();\n-                            break;\n-                        case 0x02:  \/\/ DLS Off\n-                            synth.setGeneralMidiMode(0);\n-                            synth.voice_allocation_mode = 0;\n-                            reset();\n+                                {\n+                                    if (data.length < 8) {\n+                                        break;\n+                                    }\n+                                    \/\/ http:\/\/www.midi.org\/about-midi\/tuning-scale.shtml\n+                                    SoftTuning tuning = new SoftTuning(data);\n+                                    int channelmask = (data[5] & 0xFF) * 16384\n+                                            + (data[6] & 0xFF) * 128 + (data[7] & 0xFF);\n+                                    SoftChannel[] channels = synth.channels;\n+                                    for (int i = 0; i < channels.length; i++)\n+                                        if ((channelmask & (1 << i)) != 0)\n+                                            channels[i].tuning = tuning;\n+                                    break;\n+                                }\n+                                default:\n+                                    break;\n+                            }\n@@ -209,2 +194,21 @@\n-                        case 0x03:  \/\/ DLS Static Voice Allocation Off\n-                            synth.voice_allocation_mode = 0;\n+                        case 0x09:  \/\/ General Midi Message\n+                            if (data.length < 5) {\n+                                break;\n+                            }\n+                            subid2 = data[4] & 0xFF;\n+                            switch (subid2) {\n+                                case 0x01:  \/\/ General Midi 1 On\n+                                    synth.setGeneralMidiMode(1);\n+                                    reset();\n+                                    break;\n+                                case 0x02:  \/\/ General Midi Off\n+                                    synth.setGeneralMidiMode(0);\n+                                    reset();\n+                                    break;\n+                                case 0x03:  \/\/ General MidI Level 2 On\n+                                    synth.setGeneralMidiMode(2);\n+                                    reset();\n+                                    break;\n+                                default:\n+                                    break;\n+                            }\n@@ -212,2 +216,26 @@\n-                        case 0x04:  \/\/ DLS Static Voice Allocation On\n-                            synth.voice_allocation_mode = 1;\n+                        case 0x0A: \/\/ DLS Message\n+                            if (data.length < 5) {\n+                                break;\n+                            }\n+                            subid2 = data[4] & 0xFF;\n+                            switch (subid2) {\n+                                case 0x01:  \/\/ DLS On\n+                                    if (synth.getGeneralMidiMode() == 0)\n+                                        synth.setGeneralMidiMode(1);\n+                                    synth.voice_allocation_mode = 1;\n+                                    reset();\n+                                    break;\n+                                case 0x02:  \/\/ DLS Off\n+                                    synth.setGeneralMidiMode(0);\n+                                    synth.voice_allocation_mode = 0;\n+                                    reset();\n+                                    break;\n+                                case 0x03:  \/\/ DLS Static Voice Allocation Off\n+                                    synth.voice_allocation_mode = 0;\n+                                    break;\n+                                case 0x04:  \/\/ DLS Static Voice Allocation On\n+                                    synth.voice_allocation_mode = 1;\n+                                    break;\n+                                default:\n+                                    break;\n+                            }\n@@ -215,0 +243,1 @@\n+\n@@ -217,5 +246,0 @@\n-                        }\n-                        break;\n-\n-                    default:\n-                        break;\n@@ -230,0 +254,3 @@\n+                    if (data.length < 4) {\n+                        return;\n+                    }\n@@ -233,29 +260,3 @@\n-                    case 0x04: \/\/ Device Control\n-\n-                        subid2 = data[4] & 0xFF;\n-                        switch (subid2) {\n-                        case 0x01: \/\/ Master Volume\n-                        case 0x02: \/\/ Master Balane\n-                        case 0x03: \/\/ Master fine tuning\n-                        case 0x04: \/\/ Master coarse tuning\n-                            int val = (data[5] & 0x7F)\n-                                    + ((data[6] & 0x7F) * 128);\n-                            if (subid2 == 0x01)\n-                                setVolume(val);\n-                            else if (subid2 == 0x02)\n-                                setBalance(val);\n-                            else if (subid2 == 0x03)\n-                                setFineTuning(val);\n-                            else if (subid2 == 0x04)\n-                                setCoarseTuning(val);\n-                            break;\n-                        case 0x05: \/\/ Global Parameter Control\n-                            int ix = 5;\n-                            int slotPathLen = (data[ix++] & 0xFF);\n-                            int paramWidth = (data[ix++] & 0xFF);\n-                            int valueWidth = (data[ix++] & 0xFF);\n-                            int[] slotPath = new int[slotPathLen];\n-                            for (int i = 0; i < slotPathLen; i++) {\n-                                int msb = (data[ix++] & 0xFF);\n-                                int lsb = (data[ix++] & 0xFF);\n-                                slotPath[i] = msb * 128 + lsb;\n+                        case 0x04: \/\/ Device Control\n+                            if (data.length < 5) {\n+                                break;\n@@ -263,12 +264,52 @@\n-                            int paramCount = (data.length - 1 - ix)\n-                                    \/ (paramWidth + valueWidth);\n-                            long[] params = new long[paramCount];\n-                            long[] values = new long[paramCount];\n-                            for (int i = 0; i < paramCount; i++) {\n-                                values[i] = 0;\n-                                for (int j = 0; j < paramWidth; j++)\n-                                    params[i] = params[i] * 128\n-                                            + (data[ix++] & 0xFF);\n-                                for (int j = 0; j < valueWidth; j++)\n-                                    values[i] = values[i] * 128\n-                                            + (data[ix++] & 0xFF);\n+                            subid2 = data[4] & 0xFF;\n+                            switch (subid2) {\n+                                case 0x01: \/\/ Master Volume\n+                                case 0x02: \/\/ Master Balane\n+                                case 0x03: \/\/ Master fine tuning\n+                                case 0x04: \/\/ Master coarse tuning\n+                                    if (data.length < 7) {\n+                                        break;\n+                                    }\n+                                    int val = (data[5] & 0x7F)\n+                                            + ((data[6] & 0x7F) * 128);\n+                                    if (subid2 == 0x01)\n+                                        setVolume(val);\n+                                    else if (subid2 == 0x02)\n+                                        setBalance(val);\n+                                    else if (subid2 == 0x03)\n+                                        setFineTuning(val);\n+                                    else if (subid2 == 0x04)\n+                                        setCoarseTuning(val);\n+                                    break;\n+                                case 0x05: \/\/ Global Parameter Control\n+                                    if (data.length < 6) {\n+                                        break;\n+                                    }\n+                                    int ix = 5;\n+                                    int slotPathLen = (data[ix++] & 0xFF);\n+                                    if (data.length < slotPathLen * 2 + 8) {\n+                                        break;\n+                                    }\n+                                    int paramWidth = (data[ix++] & 0xFF);\n+                                    int valueWidth = (data[ix++] & 0xFF);\n+                                    int[] slotPath = new int[slotPathLen];\n+                                    for (int i = 0; i < slotPathLen; i++) {\n+                                        int msb = (data[ix++] & 0xFF);\n+                                        int lsb = (data[ix++] & 0xFF);\n+                                        slotPath[i] = msb * 128 + lsb;\n+                                    }\n+                                    int paramCount = (data.length - 1 - ix)\n+                                            \/ (paramWidth + valueWidth);\n+                                    if (paramCount < 1) {\n+                                        break;\n+                                    }\n+                                    long[] params = new long[paramCount];\n+                                    long[] values = new long[paramCount];\n+                                    for (int i = 0; i < paramCount; i++) {\n+                                        values[i] = 0;\n+                                        for (int j = 0; j < paramWidth; j++)\n+                                            params[i] = params[i] * 128\n+                                                    + (data[ix++] & 0xFF);\n+                                        for (int j = 0; j < valueWidth; j++)\n+                                            values[i] = values[i] * 128\n+                                                    + (data[ix++] & 0xFF);\n@@ -276,0 +317,5 @@\n+                                    }\n+                                    globalParameterControlChange(slotPath, params, values);\n+                                    break;\n+                                default:\n+                                    break;\n@@ -277,3 +323,0 @@\n-                            globalParameterControlChange(slotPath, params, values);\n-                            break;\n-                        default:\n@@ -281,2 +324,0 @@\n-                        }\n-                        break;\n@@ -284,17 +325,23 @@\n-                    case 0x08:  \/\/ MIDI Tuning Standard\n-                        subid2 = data[4] & 0xFF;\n-                        switch (subid2) {\n-                        case 0x02:  \/\/ SINGLE NOTE TUNING CHANGE (REAL-TIME)\n-                        {\n-                            \/\/ http:\/\/www.midi.org\/about-midi\/tuning.shtml\n-                            SoftTuning tuning = synth.getTuning(new Patch(0,\n-                                    data[5] & 0xFF));\n-                            tuning.load(data);\n-                            SoftVoice[] voices = synth.getVoices();\n-                            for (int i = 0; i < voices.length; i++)\n-                                if (voices[i].active)\n-                                    if (voices[i].tuning == tuning)\n-                                        voices[i].updateTuning(tuning);\n-                            break;\n-                        }\n-                        case 0x07:  \/\/ SINGLE NOTE TUNING CHANGE (REAL-TIME)\n+                        case 0x08:  \/\/ MIDI Tuning Standard\n+                            if (data.length < 5) {\n+                                break;\n+                            }\n+                            subid2 = data[4] & 0xFF;\n+                            switch (subid2) {\n+                                case 0x02:  \/\/ SINGLE NOTE TUNING CHANGE (REAL-TIME)\n+                                {\n+                                    \/\/ http:\/\/www.midi.org\/about-midi\/tuning.shtml\n+                                    if (data.length < 6) {\n+                                        break;\n+                                    }\n+                                    SoftTuning tuning = synth.getTuning(new Patch(0,\n+                                            data[5] & 0xFF));\n+                                    tuning.load(data);\n+                                    SoftVoice[] voices = synth.getVoices();\n+                                    for (int i = 0; i < voices.length; i++)\n+                                        if (voices[i].active)\n+                                            if (voices[i].tuning == tuning)\n+                                                voices[i].updateTuning(tuning);\n+                                    break;\n+                                }\n+                                case 0x07:  \/\/ SINGLE NOTE TUNING CHANGE (REAL-TIME)\n@@ -302,13 +349,16 @@\n-                        {\n-                            \/\/ http:\/\/www.midi.org\/about-midi\/tuning_extens.shtml\n-                            SoftTuning tuning = synth.getTuning(new Patch(\n-                                    data[5] & 0xFF, data[6] & 0xFF));\n-                            tuning.load(data);\n-                            SoftVoice[] voices = synth.getVoices();\n-                            for (int i = 0; i < voices.length; i++)\n-                                if (voices[i].active)\n-                                    if (voices[i].tuning == tuning)\n-                                        voices[i].updateTuning(tuning);\n-                            break;\n-                        }\n-                        case 0x08:  \/\/ scale\/octave tuning 1-byte form\n+                                {\n+                                    \/\/ http:\/\/www.midi.org\/about-midi\/tuning_extens.shtml\n+                                    if (data.length < 7) {\n+                                        break;\n+                                    }\n+                                    SoftTuning tuning = synth.getTuning(new Patch(\n+                                            data[5] & 0xFF, data[6] & 0xFF));\n+                                    tuning.load(data);\n+                                    SoftVoice[] voices = synth.getVoices();\n+                                    for (int i = 0; i < voices.length; i++)\n+                                        if (voices[i].active)\n+                                            if (voices[i].tuning == tuning)\n+                                                voices[i].updateTuning(tuning);\n+                                    break;\n+                                }\n+                                case 0x08:  \/\/ scale\/octave tuning 1-byte form\n@@ -316,1 +366,1 @@\n-                        case 0x09:  \/\/ scale\/octave tuning 2-byte form\n+                                case 0x09:  \/\/ scale\/octave tuning 2-byte form\n@@ -318,32 +368,21 @@\n-                        {\n-                            \/\/ http:\/\/www.midi.org\/about-midi\/tuning-scale.shtml\n-                            SoftTuning tuning = new SoftTuning(data);\n-                            int channelmask = (data[5] & 0xFF) * 16384\n-                                    + (data[6] & 0xFF) * 128 + (data[7] & 0xFF);\n-                            SoftChannel[] channels = synth.channels;\n-                            for (int i = 0; i < channels.length; i++)\n-                                if ((channelmask & (1 << i)) != 0)\n-                                    channels[i].tuning = tuning;\n-                            SoftVoice[] voices = synth.getVoices();\n-                            for (int i = 0; i < voices.length; i++)\n-                                if (voices[i].active)\n-                                    if ((channelmask & (1 << (voices[i].channel))) != 0)\n-                                        voices[i].updateTuning(tuning);\n-                            break;\n-                        }\n-                        default:\n-                            break;\n-                        }\n-                        break;\n-                    case 0x09:  \/\/ Control Destination Settings\n-                        subid2 = data[4] & 0xFF;\n-                        switch (subid2) {\n-                        case 0x01: \/\/ Channel Pressure\n-                        {\n-                            int[] destinations = new int[(data.length - 7) \/ 2];\n-                            int[] ranges = new int[(data.length - 7) \/ 2];\n-                            int ix = 0;\n-                            for (int j = 6; j < data.length - 1; j += 2) {\n-                                destinations[ix] = data[j] & 0xFF;\n-                                ranges[ix] = data[j + 1] & 0xFF;\n-                                ix++;\n+                                {\n+                                    \/\/ http:\/\/www.midi.org\/about-midi\/tuning-scale.shtml\n+                                    if (data.length < 8) {\n+                                        break;\n+                                    }\n+                                    SoftTuning tuning = new SoftTuning(data);\n+                                    int channelmask = (data[5] & 0xFF) * 16384\n+                                            + (data[6] & 0xFF) * 128 + (data[7] & 0xFF);\n+                                    SoftChannel[] channels = synth.channels;\n+                                    for (int i = 0; i < channels.length; i++)\n+                                        if ((channelmask & (1 << i)) != 0)\n+                                            channels[i].tuning = tuning;\n+                                    SoftVoice[] voices = synth.getVoices();\n+                                    for (int i = 0; i < voices.length; i++)\n+                                        if (voices[i].active)\n+                                            if ((channelmask & (1 << (voices[i].channel))) != 0)\n+                                                voices[i].updateTuning(tuning);\n+                                    break;\n+                                }\n+                                default:\n+                                    break;\n@@ -351,4 +390,0 @@\n-                            int channel = data[5] & 0xFF;\n-                            SoftChannel softchannel = synth.channels[channel];\n-                            softchannel.mapChannelPressureToDestination(\n-                                    destinations, ranges);\n@@ -356,10 +391,3 @@\n-                        }\n-                        case 0x02: \/\/ Poly Pressure\n-                        {\n-                            int[] destinations = new int[(data.length - 7) \/ 2];\n-                            int[] ranges = new int[(data.length - 7) \/ 2];\n-                            int ix = 0;\n-                            for (int j = 6; j < data.length - 1; j += 2) {\n-                                destinations[ix] = data[j] & 0xFF;\n-                                ranges[ix] = data[j + 1] & 0xFF;\n-                                ix++;\n+                        case 0x09:  \/\/ Control Destination Settings\n+                            if (data.length < 5) {\n+                                break;\n@@ -367,15 +395,62 @@\n-                            int channel = data[5] & 0xFF;\n-                            SoftChannel softchannel = synth.channels[channel];\n-                            softchannel.mapPolyPressureToDestination(\n-                                    destinations, ranges);\n-                            break;\n-                        }\n-                        case 0x03: \/\/ Control Change\n-                        {\n-                            int[] destinations = new int[(data.length - 7) \/ 2];\n-                            int[] ranges = new int[(data.length - 7) \/ 2];\n-                            int ix = 0;\n-                            for (int j = 7; j < data.length - 1; j += 2) {\n-                                destinations[ix] = data[j] & 0xFF;\n-                                ranges[ix] = data[j + 1] & 0xFF;\n-                                ix++;\n+                            subid2 = data[4] & 0xFF;\n+                            switch (subid2) {\n+                                case 0x01: \/\/ Channel Pressure\n+                                {\n+                                    if (data.length < 8) {\n+                                        break;\n+                                    }\n+                                    int[] destinations = new int[(data.length - 6) \/ 2];\n+                                    int[] ranges = new int[(data.length - 6) \/ 2];\n+                                    int ix = 0;\n+                                    for (int j = 6; j < data.length - 1; j += 2) {\n+                                        destinations[ix] = data[j] & 0xFF;\n+                                        ranges[ix] = data[j + 1] & 0xFF;\n+                                        ix++;\n+                                    }\n+                                    int channel = data[5] & 0xFF;\n+                                    SoftChannel softchannel = synth.channels[channel];\n+                                    softchannel.mapChannelPressureToDestination(\n+                                            destinations, ranges);\n+                                    break;\n+                                }\n+                                case 0x02: \/\/ Poly Pressure\n+                                {\n+                                    if (data.length < 8) {\n+                                        break;\n+                                    }\n+                                    int[] destinations = new int[(data.length - 6) \/ 2];\n+                                    int[] ranges = new int[(data.length - 6) \/ 2];\n+                                    int ix = 0;\n+                                    for (int j = 6; j < data.length - 1; j += 2) {\n+                                        destinations[ix] = data[j] & 0xFF;\n+                                        ranges[ix] = data[j + 1] & 0xFF;\n+                                        ix++;\n+                                    }\n+                                    int channel = data[5] & 0xFF;\n+                                    SoftChannel softchannel = synth.channels[channel];\n+                                    softchannel.mapPolyPressureToDestination(\n+                                            destinations, ranges);\n+                                    break;\n+                                }\n+                                case 0x03: \/\/ Control Change\n+                                {\n+                                    if (data.length < 8) {\n+                                        break;\n+                                    }\n+                                    int[] destinations = new int[(data.length - 7) \/ 2];\n+                                    int[] ranges = new int[(data.length - 7) \/ 2];\n+                                    int ix = 0;\n+                                    for (int j = 7; j < data.length - 1; j += 2) {\n+                                        destinations[ix] = data[j] & 0xFF;\n+                                        ranges[ix] = data[j + 1] & 0xFF;\n+                                        ix++;\n+                                    }\n+                                    int channel = data[5] & 0xFF;\n+                                    SoftChannel softchannel = synth.channels[channel];\n+                                    int control = data[6] & 0xFF;\n+                                    softchannel.mapControlToDestination(control,\n+                                            destinations, ranges);\n+                                    break;\n+                                }\n+                                default:\n+                                    break;\n@@ -383,8 +458,0 @@\n-                            int channel = data[5] & 0xFF;\n-                            SoftChannel softchannel = synth.channels[channel];\n-                            int control = data[6] & 0xFF;\n-                            softchannel.mapControlToDestination(control,\n-                                    destinations, ranges);\n-                            break;\n-                        }\n-                        default:\n@@ -392,2 +459,0 @@\n-                        }\n-                        break;\n@@ -395,13 +460,20 @@\n-                    case 0x0A:  \/\/ Key Based Instrument Control\n-                    {\n-                        subid2 = data[4] & 0xFF;\n-                        switch (subid2) {\n-                        case 0x01: \/\/ Basic Message\n-                            int channel = data[5] & 0xFF;\n-                            int keynumber = data[6] & 0xFF;\n-                            SoftChannel softchannel = synth.channels[channel];\n-                            for (int j = 7; j < data.length - 1; j += 2) {\n-                                int controlnumber = data[j] & 0xFF;\n-                                int controlvalue = data[j + 1] & 0xFF;\n-                                softchannel.controlChangePerNote(keynumber,\n-                                        controlnumber, controlvalue);\n+                        case 0x0A:  \/\/ Key Based Instrument Control\n+                        {\n+                            if (data.length < 8 || (data[4] & 0xFF) != 0x01) {\n+                                break;\n+                            }\n+                            subid2 = data[4] & 0xFF;\n+                            switch (subid2) {\n+                                case 0x01: \/\/ Basic Message\n+                                    int channel = data[5] & 0xFF;\n+                                    int keynumber = data[6] & 0xFF;\n+                                    SoftChannel softchannel = synth.channels[channel];\n+                                    for (int j = 7; j < data.length - 1; j += 2) {\n+                                        int controlnumber = data[j] & 0xFF;\n+                                        int controlvalue = data[j + 1] & 0xFF;\n+                                        softchannel.controlChangePerNote(keynumber,\n+                                                controlnumber, controlvalue);\n+                                    }\n+                                    break;\n+                                default:\n+                                    break;\n@@ -410,0 +482,1 @@\n+                        }\n@@ -412,5 +485,0 @@\n-                        }\n-                        break;\n-                    }\n-                    default:\n-                        break;\n@@ -420,1 +488,0 @@\n-\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/SoftMainMixer.java","additions":316,"deletions":249,"binary":false,"changes":565,"status":"modified"},{"patch":"@@ -92,0 +92,4 @@\n+        if (data.length < 2) {\n+            return;\n+        }\n+\n@@ -93,0 +97,4 @@\n+            if (data.length < 4) {\n+                return;\n+            }\n+\n@@ -96,0 +104,3 @@\n+                if (data.length < 5) {\n+                    break;\n+                }\n@@ -103,1 +114,0 @@\n-                    name = new String(data, 6, 16, US_ASCII);\n@@ -105,0 +115,4 @@\n+                    if (data.length < 128 * 3 + r) {\n+                        break;\n+                    }\n+                    name = new String(data, 6, 16, US_ASCII);\n@@ -118,0 +132,3 @@\n+                    if (data.length < 7) {\n+                        break;\n+                    }\n@@ -120,0 +137,3 @@\n+                    if (data.length < ll * 4 + r) {\n+                        break;\n+                    }\n@@ -135,0 +155,3 @@\n+                    if (data.length < 407) {\n+                        break;\n+                    }\n@@ -152,0 +175,3 @@\n+                    if (data.length < 35) {\n+                        break;\n+                    }\n@@ -166,0 +192,3 @@\n+                    if (data.length < 47) {\n+                        break;\n+                    }\n@@ -180,0 +209,3 @@\n+                    if (data.length < 8) {\n+                        break;\n+                    }\n@@ -181,0 +213,3 @@\n+                    if (data.length < ll * 4 + 8) {\n+                        break;\n+                    }\n@@ -196,0 +231,3 @@\n+                    if (data.length < 20) {\n+                        break;\n+                    }\n@@ -207,0 +245,3 @@\n+                    if (data.length < 32) {\n+                        break;\n+                    }\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/SoftTuning.java","additions":42,"deletions":1,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -468,3 +468,2 @@\n-     * @throws ArrayIndexOutOfBoundsException if {@code componentIdx}\n-     *         is greater than the number of components or\n-     *         less than zero\n+     * @throws ArrayIndexOutOfBoundsException if {@code componentIdx} is greater\n+     *         than or equal to the number of components or less than zero\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/image\/ColorModel.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -356,1 +356,1 @@\n-    \/** Return value form class method if OK is chosen. *\/\n+    \/** Return value from class method if OK is chosen. *\/\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JOptionPane.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1411,1 +1411,1 @@\n-        if (dir != null && FilePane.usesShellFolder(fc)) {\n+        if (dir != null) {\n@@ -1413,11 +1413,7 @@\n-                ShellFolder shellFolder = ShellFolder.getShellFolder(dir);\n-\n-                if (shellFolder.isLink()) {\n-                    File linkedTo = shellFolder.getLinkLocation();\n-\n-                    \/\/ If linkedTo is null we try to use dir\n-                    if (linkedTo != null) {\n-                        if (fc.isTraversable(linkedTo)) {\n-                            dir = linkedTo;\n-                        } else {\n-                            return;\n+                File linkedTo = null;\n+                if (FilePane.usesShellFolder(fc)) {\n+                    ShellFolder shellFolder = ShellFolder.getShellFolder(dir);\n+                    if (shellFolder.isLink()) {\n+                        linkedTo = shellFolder.getLinkLocation();\n+                        if (linkedTo == null) {\n+                            dir = shellFolder;\n@@ -1425,0 +1421,7 @@\n+                    }\n+                } else if ( fc.getFileSystemView().isLink(dir)){\n+                    linkedTo = fc.getFileSystemView().getLinkLocation(dir);\n+                }\n+                if (linkedTo != null) {\n+                    if (fc.isTraversable(linkedTo)) {\n+                        dir = linkedTo;\n@@ -1426,1 +1429,1 @@\n-                        dir = shellFolder;\n+                        return;\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicFileChooserUI.java","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -782,8 +782,0 @@\n-            } else if (c instanceof JCheckBox) {\n-                if (UIManager.getColor(\"CheckBox.disabledText\") != null) {\n-                    return UIManager.getColor(\"CheckBox.disabledText\");\n-                }\n-            } else if (c instanceof JRadioButton) {\n-                if (UIManager.getColor(\"RadioButton.disabledText\") != null) {\n-                    return UIManager.getColor(\"RadioButton.disabledText\");\n-                }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/SynthStyle.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -849,0 +849,17 @@\n+    @SuppressWarnings(\"unchecked\")\n+    public static float getTracking(Map<?, ?> map) {\n+        if (map != null) {\n+            AttributeValues av = null;\n+            if (map instanceof AttributeMap &&\n+                    ((AttributeMap) map).getValues() != null) {\n+                av = ((AttributeMap)map).getValues();\n+            } else if (map.get(TextAttribute.TRACKING) != null) {\n+                av = AttributeValues.fromMap((Map<Attribute, ?>)map);\n+            }\n+            if (av != null) {\n+                return av.tracking;\n+            }\n+        }\n+        return 0;\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/AttributeValues.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -74,0 +74,2 @@\n+  float advTracking;\n+\n@@ -113,0 +115,2 @@\n+\n+    advTracking = font.getSize() * AttributeValues.getTracking(atts);\n@@ -381,1 +385,1 @@\n-    if (charinfo == null || idx >= charinfo.length) {\n+    if (charinfo == null || idx >= charinfo.length || charinfo[idx] == 0) {\n@@ -384,1 +388,1 @@\n-        return charinfo[idx];\n+        return charinfo[idx] + advTracking;\n@@ -480,0 +484,2 @@\n+    final float epsilon = 0.005f;\n+\n@@ -482,0 +488,5 @@\n+\n+    if (advTracking > 0) {\n+      width += advTracking;\n+    }\n+\n@@ -483,1 +494,1 @@\n-    while (width >= 0 && ++start < length) {\n+    while (width >= -epsilon && ++start < length) {\n@@ -489,1 +500,3 @@\n-      width -= adv;\n+      if (adv != 0) {\n+          width -= adv + advTracking;\n+      }\n@@ -505,1 +518,4 @@\n-      a += charinfo[cidx];\n+      float adv = charinfo[cidx];\n+      if (adv != 0) {\n+          a += adv + advTracking;\n+      }\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/ExtendedTextSourceLabel.java","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -200,2 +200,0 @@\n-            Font2D f2d = FontUtilities.getFont2D(font);\n-            FontStrike strike = f2d.getStrike(font, frc);\n@@ -206,0 +204,1 @@\n+                float prevPos = 0;\n@@ -208,2 +207,3 @@\n-                    for (int i = j, n = 0; n < glyphs.length; i += 2) {\n-                        if (strike.getGlyphAdvance(glyphs[n++]) != 0) { \/\/ might be an inadequate test\n+                    for (int i = j; i < positions.length; i += 2) {\n+                        if (i == j || prevPos != positions[i]) {\n+                            prevPos = positions[i];\n@@ -212,0 +212,2 @@\n+                        } else if (prevPos == positions[i]) {\n+                            positions[i] = positions[i - 2];\n@@ -214,1 +216,0 @@\n-                    positions[positions.length-2+j] += delta;\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/StandardGlyphVector.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -165,0 +165,4 @@\n+ * @deprecated This API is part of Management Applets (m-lets), which is a legacy feature that allows loading\n+ * of remote MBeans. This feature is not usable without a Security Manager, which is deprecated and subject to\n+ * removal in a future release. Consequently, this API is also deprecated and subject to removal. There is no replacement.\n+ *\n@@ -167,0 +171,2 @@\n+@Deprecated(since=\"20\", forRemoval=true)\n+@SuppressWarnings(\"removal\")\n","filename":"src\/java.management\/share\/classes\/javax\/management\/loading\/MLet.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,0 +42,4 @@\n+ * @deprecated This API is part of Management Applets (m-lets), which is a legacy feature that allows loading\n+ * of remote MBeans. This feature is not usable without a Security Manager, which is deprecated and subject to\n+ * removal in a future release. Consequently, this API is also deprecated and subject to removal. There is no replacement.\n+ *\n@@ -44,0 +48,1 @@\n+@Deprecated(since=\"20\", forRemoval=true)\n@@ -46,1 +51,0 @@\n-\n","filename":"src\/java.management\/share\/classes\/javax\/management\/loading\/MLetContent.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2006, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,4 @@\n+ * @deprecated This API is part of Management Applets (m-lets), which is a legacy feature that allows loading\n+ * of remote MBeans. This feature is not usable without a Security Manager, which is deprecated and subject to\n+ * removal in a future release. Consequently, this API is also deprecated and subject to removal. There is no replacement.\n+ *\n@@ -44,0 +48,1 @@\n+@Deprecated(since=\"20\", forRemoval=true)\n@@ -46,1 +51,0 @@\n-\n","filename":"src\/java.management\/share\/classes\/javax\/management\/loading\/MLetMBean.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+@Deprecated(since=\"20\", forRemoval=true)\n@@ -43,0 +44,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -48,0 +50,1 @@\n+    @SuppressWarnings(\"removal\")\n","filename":"src\/java.management\/share\/classes\/javax\/management\/loading\/MLetObjectInputStream.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+@Deprecated(since=\"20\", forRemoval=true)\n@@ -156,0 +157,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -252,1 +254,1 @@\n-    @SuppressWarnings(\"deprecation\")\n+    @SuppressWarnings(\"removal\")\n","filename":"src\/java.management\/share\/classes\/javax\/management\/loading\/MLetParser.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,4 @@\n+ * @deprecated This API is part of Management Applets (m-lets), which is a legacy feature that allows loading\n+ * of remote MBeans. This feature is not usable without a Security Manager, which is deprecated and subject to\n+ * removal in a future release. Consequently, this API is also deprecated and subject to removal. There is no replacement.\n+ *\n@@ -41,1 +45,2 @@\n-@SuppressWarnings(\"serial\") \/\/ Externalizable class w\/o no-arg c'tor\n+@Deprecated(since=\"20\", forRemoval=true)\n+@SuppressWarnings({\"serial\", \"removal\"}) \/\/ Externalizable class w\/o no-arg c'tor\n","filename":"src\/java.management\/share\/classes\/javax\/management\/loading\/PrivateMLet.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1181,0 +1181,7 @@\n+         * @implNote The {@code read} method of the {@code InputStream}\n+         * returned by the default implementation of this method will\n+         * throw an {@code IOException} with the {@linkplain Thread#isInterrupted()\n+         * thread interrupt status set} if the thread is interrupted\n+         * while blocking on read. In that case, the request will also be\n+         * cancelled and the {@code InputStream} will be closed.\n+         *\n","filename":"src\/java.net.http\/share\/classes\/java\/net\/http\/HttpResponse.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -484,1 +484,6 @@\n-                    \/\/ continue\n+                    try {\n+                        close();\n+                    } catch (IOException ignored) {\n+                    }\n+                    Thread.currentThread().interrupt();\n+                    throw new IOException(ex);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ResponseSubscribers.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -137,4 +137,1 @@\n-            GSSCredentialSpi element;\n-            Enumeration<GSSCredentialSpi> values = hashtable.elements();\n-            while (values.hasMoreElements()) {\n-                element = values.nextElement();\n+            for (GSSCredentialSpi element : hashtable.values()) {\n@@ -214,1 +211,0 @@\n-        SearchKey tempKey;\n@@ -219,3 +215,1 @@\n-        for (Enumeration<SearchKey> e = hashtable.keys();\n-                                        e.hasMoreElements(); ) {\n-            tempKey = e.nextElement();\n+        for (SearchKey tempKey : hashtable.keySet()) {\n@@ -332,1 +326,0 @@\n-        SearchKey tempKey;\n@@ -336,3 +329,1 @@\n-        for (Enumeration<SearchKey> e = hashtable.keys();\n-                                        e.hasMoreElements(); ) {\n-            tempKey = e.nextElement();\n+        for (SearchKey tempKey : hashtable.keySet()) {\n@@ -409,4 +400,1 @@\n-\n-        for (Enumeration<SearchKey> e = hashtable.keys();\n-                                                e.hasMoreElements(); ) {\n-            SearchKey tempKey = e.nextElement();\n+        for (SearchKey tempKey : hashtable.keySet()) {\n@@ -618,8 +606,1 @@\n-        HashSet<GSSCredentialSpi> retVal =\n-                new HashSet<>(hashtable.size());\n-        Enumeration<GSSCredentialSpi> values = hashtable.elements();\n-        while (values.hasMoreElements()) {\n-            GSSCredentialSpi o = values.nextElement();\n-            retVal.add(o);\n-        }\n-        return retVal;\n+        return new HashSet<>(hashtable.values());\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/GSSCredentialImpl.java","additions":5,"deletions":24,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import java.util.Enumeration;\n@@ -411,3 +410,0 @@\n-        \/\/ Get all props for this provider\n-        Enumeration<Object> props = p.keys();\n-\n@@ -415,2 +411,2 @@\n-        while (props.hasMoreElements()) {\n-            prop = (String) props.nextElement();\n+        for (Object o : p.keySet()) {\n+            prop = (String) o;\n@@ -431,1 +427,1 @@\n-        } \/\/ while loop\n+        } \/\/ for loop\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/ProviderList.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-      * 16, tbd\n+      * 16, records and pattern matching for instanceof\n@@ -113,1 +113,1 @@\n-      * 17, tbd\n+      * 17, sealed classes, restoration of always-strict floating-point\n@@ -118,1 +118,1 @@\n-      * 18, tbd\n+      * 18, no major changes\n@@ -123,1 +123,1 @@\n-      * 19, tbd\n+      * 19, no major changes\n@@ -128,1 +128,1 @@\n-      * 20, tbd\n+      * 20, no major changes\n@@ -130,1 +130,6 @@\n-    JDK20(\"20\");\n+    JDK20(\"20\"),\n+\n+    \/**\n+      * 21, tbd\n+      *\/\n+    JDK21(\"21\");\n@@ -182,0 +187,1 @@\n+        case JDK21  -> Target.JDK1_21;\n@@ -315,0 +321,1 @@\n+        case JDK21  -> RELEASE_21;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1522,1 +1522,1 @@\n-        public RecordComponent createRecordComponent(RecordComponent existing, JCVariableDecl var, List<JCAnnotation> annotations) {\n+        public RecordComponent createRecordComponent(RecordComponent existing, JCVariableDecl rcDecl, VarSymbol varSym) {\n@@ -1526,1 +1526,1 @@\n-                recordComponents = recordComponents.append(rc = new RecordComponent(var.sym, existing.originalAnnos, existing.isVarargs));\n+                recordComponents = recordComponents.append(rc = new RecordComponent(varSym, existing.ast, existing.isVarargs));\n@@ -1529,1 +1529,1 @@\n-                recordComponents = recordComponents.append(rc = new RecordComponent(var.sym, annotations));\n+                recordComponents = recordComponents.append(rc = new RecordComponent(varSym, rcDecl));\n@@ -1789,3 +1789,1 @@\n-        \/* the original annotations applied to the record component\n-         *\/\n-        private final List<JCAnnotation> originalAnnos;\n+\n@@ -1799,0 +1797,2 @@\n+        private JCVariableDecl ast;\n+\n@@ -1805,1 +1805,1 @@\n-            originalAnnos = List.nil();\n+            ast = null;\n@@ -1809,2 +1809,2 @@\n-        public RecordComponent(VarSymbol field, List<JCAnnotation> annotations) {\n-            this(field, annotations, field.type.hasTag(TypeTag.ARRAY) && ((ArrayType)field.type).isVarargs());\n+        public RecordComponent(VarSymbol field, JCVariableDecl ast) {\n+            this(field, ast, field.type.hasTag(TypeTag.ARRAY) && ((ArrayType)field.type).isVarargs());\n@@ -1813,1 +1813,1 @@\n-        public RecordComponent(VarSymbol field, List<JCAnnotation> annotations, boolean isVarargs) {\n+        public RecordComponent(VarSymbol field, JCVariableDecl ast, boolean isVarargs) {\n@@ -1815,1 +1815,1 @@\n-            this.originalAnnos = annotations;\n+            this.ast = ast;\n@@ -1825,1 +1825,3 @@\n-        public List<JCAnnotation> getOriginalAnnos() { return originalAnnos; }\n+        public List<JCAnnotation> getOriginalAnnos() { return this.ast == null ? List.nil() : this.ast.mods.annotations; }\n+\n+        public JCVariableDecl declarationFor() { return this.ast; }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":14,"deletions":12,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1089,1 +1089,5 @@\n-\n+                case DECONSTRUCTION_PATTERN: {\n+                    \/\/ TODO: Treat case labels as full type contexts for complete type annotation support in Record Patterns\n+                    \/\/    https:\/\/bugs.openjdk.org\/browse\/JDK-8298154\n+                    return TypeAnnotationPosition.unknown;\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeAnnotations.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4207,1 +4207,1 @@\n-        Type site = types.removeWildcards(tree.type);\n+        Type site = types.capture(tree.type);\n@@ -4213,1 +4213,3 @@\n-                                        .map(rc -> types.memberType(site, rc)).collect(List.collector());\n+                                        .map(rc -> types.memberType(site, rc))\n+                                        .map(t -> types.upward(t, types.captures(t)).baseType())\n+                                        .collect(List.collector());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -159,1 +159,1 @@\n-                            if (!voidCompatible) {\n+                            if (!voidCompatible && lambda.body.hasTag(Tag.BLOCK)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/AttrRecover.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3009,0 +3009,10 @@\n+                    JCVariableDecl fieldAST = (JCVariableDecl) declarationTree;\n+                    for (JCAnnotation fieldAnnot : fieldAST.mods.annotations) {\n+                        for (JCAnnotation rcAnnot : rc.declarationFor().mods.annotations) {\n+                            if (rcAnnot.pos == fieldAnnot.pos) {\n+                                rcAnnot.setType(fieldAnnot.type);\n+                                break;\n+                            }\n+                        }\n+                    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import com.sun.source.tree.EnhancedForLoopTree;\n+import com.sun.source.tree.CaseTree.CaseKind;\n@@ -53,1 +53,0 @@\n-import com.sun.tools.javac.tree.JCTree.JCLabeledStatement;\n@@ -67,1 +66,0 @@\n-import com.sun.tools.javac.util.Options;\n@@ -69,1 +67,1 @@\n-import java.util.HashMap;\n+import java.util.Collections;\n@@ -72,0 +70,2 @@\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n@@ -73,0 +73,1 @@\n+import java.util.Set;\n@@ -82,0 +83,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCBlock.PatternMatchingCatch;\n@@ -85,0 +87,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCCatch;\n@@ -89,0 +92,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCExpressionStatement;\n@@ -99,0 +103,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCTry;\n@@ -101,0 +106,1 @@\n+import com.sun.tools.javac.tree.TreeScanner;\n@@ -102,1 +108,0 @@\n-import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n@@ -168,4 +173,0 @@\n-    JCLabeledStatement pendingMatchLabel = null;\n-\n-    boolean debugTransPatterns;\n-\n@@ -178,0 +179,2 @@\n+    private Set<JCMethodInvocation> deconstructorCalls;\n+    private int variableIndex = 0;\n@@ -190,1 +193,0 @@\n-        debugTransPatterns = Options.instance(context).isSet(\"debug.patterns\");\n@@ -195,2 +197,13 @@\n-        if (tree.pattern instanceof JCPattern) {\n-            \/\/E instanceof $pattern\n+        if (tree.pattern instanceof JCPattern pattern) {\n+            \/\/first, resolve any parenthesized and record patterns:\n+            pattern = TreeInfo.skipParens(pattern);\n+            JCExpression extraConditions = null;\n+            if (pattern instanceof JCRecordPattern recordPattern) {\n+                UnrolledRecordPattern unrolledRecordPattern = unrollRecordPattern(recordPattern);\n+                pattern = unrolledRecordPattern.primaryPattern();\n+                extraConditions = unrolledRecordPattern.newGuard();\n+            }\n+            \/\/$pattern is now always a binding pattern, $extraConditions are possibly additional tests\n+            \/\/implementing to the record pattern\n+            \/\/\n+            \/\/E instanceof $patternType $patternName && $extraConditions\n@@ -198,2 +211,3 @@\n-            \/\/(let T' N$temp = E; N$temp instanceof typeof($pattern) && <desugared $pattern>)\n-            \/\/note the pattern desugaring performs binding variable assignments\n+            \/\/(let $patternType N$temp = E; N$temp instanceof $patternType &&\n+            \/\/                              (let $patternName = ($patternType) N$temp; true) &&\n+            \/\/                              $extraConditions)\n@@ -215,1 +229,1 @@\n-                            names.fromString(\"patt\" + tree.pos + target.syntheticNameChar() + \"temp\"),\n+                            names.fromString(\"patt\" + variableIndex++ + target.syntheticNameChar() + \"temp\"),\n@@ -220,5 +234,12 @@\n-                Type principalType = principalType((JCPattern) tree.pattern);\n-                JCExpression resultExpression=\n-                        makeBinary(Tag.AND,\n-                                   makeTypeTest(make.Ident(currentValue), make.Type(principalType)),\n-                                   (JCExpression) this.<JCTree>translate(tree.pattern));\n+                Type principalType = types.erasure(TreeInfo.primaryPatternType((pattern)));\n+                 JCExpression resultExpression= (JCExpression) this.<JCTree>translate(pattern);\n+                if (!tree.allowNull || !types.isSubtype(currentValue.type, principalType)) {\n+                    resultExpression =\n+                            makeBinary(Tag.AND,\n+                                       makeTypeTest(make.Ident(currentValue), make.Type(principalType)),\n+                                       resultExpression);\n+                }\n+                if (extraConditions != null) {\n+                    extraConditions = translate(extraConditions);\n+                    resultExpression = makeBinary(Tag.AND, resultExpression, extraConditions);\n+                }\n@@ -245,1 +266,1 @@\n-        Type castTargetType = principalType(tree);\n+        Type castTargetType = types.erasure(TreeInfo.primaryPatternType(tree));\n@@ -268,1 +289,8 @@\n-        \/\/type test already done, finish handling of deconstruction patterns (\"T(PATT1, PATT2, ...)\")\n+        \/\/record patterns should be resolved by the constructs that use them.\n+        Assert.error();\n+    }\n+\n+    private UnrolledRecordPattern unrollRecordPattern(JCRecordPattern recordPattern) {\n+        \/\/Convert a record pattern in the basic binding pattern and additional conditions\n+        \/\/implementing the record pattern:\n+        \/\/$record($nestedPattern1, $nestedPattern2, ...) $r\n@@ -270,14 +298,16 @@\n-        \/\/<PATT1-handling> && <PATT2-handling> && ...\n-        List<? extends RecordComponent> components = tree.record.getRecordComponents();\n-        List<? extends Type> nestedFullComponentTypes = tree.fullComponentTypes;\n-        List<? extends JCPattern> nestedPatterns = tree.nested;\n-        JCExpression test = null;\n-        while (components.nonEmpty() && nestedFullComponentTypes.nonEmpty() && nestedPatterns.nonEmpty()) {\n-            \/\/PATTn for record component COMPn of type Tn;\n-            \/\/PATTn is a type test pattern or a deconstruction pattern:\n-            \/\/=>\n-            \/\/(let Tn $c$COMPn = ((T) N$temp).COMPn(); <PATTn extractor>)\n-            \/\/or\n-            \/\/(let Tn $c$COMPn = ((T) N$temp).COMPn(); $c$COMPn != null && <PATTn extractor>)\n-            \/\/or\n-            \/\/(let Tn $c$COMPn = ((T) N$temp).COMPn(); $c$COMPn instanceof T' && <PATTn extractor>)\n+        \/\/$record $r; type-test-of($nestedPattern1) && type-test-of($nestedPattern2) && ... &&\n+        \/\/            nested-conditions-of($nestedPattern1) && nested-conditions-of($nestedPattern2)\n+        Type recordType = recordPattern.record.erasure(types);\n+        BindingSymbol tempBind = new BindingSymbol(Flags.SYNTHETIC,\n+            names.fromString(target.syntheticNameChar() + \"b\" + target.syntheticNameChar() + variableIndex++), recordType,\n+                             currentMethodSym);\n+        JCVariableDecl recordBindingVar = make.VarDef(tempBind, null);\n+\n+        VarSymbol recordBinding = recordBindingVar.sym;\n+        List<? extends RecordComponent> components = recordPattern.record.getRecordComponents();\n+        List<? extends Type> nestedFullComponentTypes = recordPattern.fullComponentTypes;\n+        List<? extends JCPattern> nestedPatterns = recordPattern.nested;\n+        JCExpression firstLevelChecks = null;\n+        JCExpression secondLevelChecks = null;\n+\n+        while (components.nonEmpty()) {\n@@ -285,23 +315,13 @@\n-            JCPattern nested = nestedPatterns.head;\n-            VarSymbol nestedTemp = new VarSymbol(Flags.SYNTHETIC,\n-                names.fromString(target.syntheticNameChar() + \"c\" + target.syntheticNameChar() + component.name),\n-                                 component.erasure(types),\n-                                 currentMethodSym);\n-            Symbol accessor = getAccessor(tree.pos(), component);\n-            JCVariableDecl nestedTempVar =\n-                    make.VarDef(nestedTemp,\n-                                make.App(make.QualIdent(accessor),\n-                                         List.of(convert(make.Ident(currentValue), tree.type))));\n-            JCExpression extracted;\n-            VarSymbol prevCurrentValue = currentValue;\n-            try {\n-                currentValue = nestedTemp;\n-                extracted = (JCExpression) this.<JCTree>translate(nested);\n-            } finally {\n-                currentValue = prevCurrentValue;\n-            }\n-            JCExpression extraTest = null;\n-            if (!types.isAssignable(nestedTemp.type, nested.type)) {\n-                if (!types.isAssignable(nestedFullComponentTypes.head, nested.type)) {\n-                    extraTest = makeTypeTest(make.Ident(nestedTemp),\n-                                             make.Type(nested.type));\n+            Type componentType = types.erasure(nestedFullComponentTypes.head);\n+            JCPattern nestedPattern = TreeInfo.skipParens(nestedPatterns.head);\n+            JCBindingPattern nestedBinding;\n+            boolean allowNull;\n+            if (nestedPattern instanceof JCRecordPattern nestedRecordPattern) {\n+                UnrolledRecordPattern nestedDesugared = unrollRecordPattern(nestedRecordPattern);\n+                JCExpression newGuard = nestedDesugared.newGuard();\n+                if (newGuard != null) {\n+                    if (secondLevelChecks == null) {\n+                        secondLevelChecks = newGuard;\n+                    } else {\n+                        secondLevelChecks = mergeConditions(secondLevelChecks, newGuard);\n+                    }\n@@ -309,2 +329,5 @@\n-            } else if (nested.type.isReference() && nested.hasTag(Tag.RECORDPATTERN)) {\n-                extraTest = makeBinary(Tag.NE, make.Ident(nestedTemp), makeNull());\n+                nestedBinding = nestedDesugared.primaryPattern();\n+                allowNull = false;\n+            } else {\n+                nestedBinding = (JCBindingPattern) nestedPattern;\n+                allowNull = true;\n@@ -312,2 +335,5 @@\n-            if (extraTest != null) {\n-                extracted = makeBinary(Tag.AND, extraTest, extracted);\n+            JCMethodInvocation componentAccessor =\n+                    make.App(make.Select(convert(make.Ident(recordBinding), recordBinding.type), \/\/TODO - cast needed????\n+                             component.accessor));\n+            if (deconstructorCalls == null) {\n+                deconstructorCalls = Collections.newSetFromMap(new IdentityHashMap<>());\n@@ -315,5 +341,8 @@\n-            LetExpr getAndRun = make.LetExpr(nestedTempVar, extracted);\n-            getAndRun.needsCond = true;\n-            getAndRun.setType(syms.booleanType);\n-            if (test == null) {\n-                test = getAndRun;\n+            deconstructorCalls.add(componentAccessor);\n+            JCExpression accessedComponentValue =\n+                    convert(componentAccessor, componentType);\n+            JCInstanceOf firstLevelCheck = (JCInstanceOf) make.TypeTest(accessedComponentValue, nestedBinding).setType(syms.booleanType);\n+            \/\/TODO: verify deep\/complex nesting with nulls\n+            firstLevelCheck.allowNull = allowNull;\n+            if (firstLevelChecks == null) {\n+                firstLevelChecks = firstLevelCheck;\n@@ -321,1 +350,1 @@\n-                test = makeBinary(Tag.AND, test, getAndRun);\n+                firstLevelChecks = mergeConditions(firstLevelChecks, firstLevelCheck);\n@@ -329,2 +358,8 @@\n-        Assert.check(components.isEmpty() == nestedFullComponentTypes.isEmpty());\n-        result = test != null ? test : makeLit(syms.booleanType, 1);\n+        JCExpression guard = null;\n+        if (firstLevelChecks != null) {\n+            guard = firstLevelChecks;\n+            if (secondLevelChecks != null) {\n+                guard = mergeConditions(guard, secondLevelChecks);\n+            }\n+        }\n+        return new UnrolledRecordPattern((JCBindingPattern) make.BindingPattern(recordBindingVar).setType(recordBinding.type), guard);\n@@ -333,36 +368,1 @@\n-    private MethodSymbol getAccessor(DiagnosticPosition pos, RecordComponent component) {\n-        return component2Proxy.computeIfAbsent(component, c -> {\n-            MethodType type = new MethodType(List.of(component.owner.erasure(types)),\n-                                             types.erasure(component.type),\n-                                             List.nil(),\n-                                             syms.methodClass);\n-            MethodSymbol proxy = new MethodSymbol(Flags.PRIVATE | Flags.STATIC | Flags.SYNTHETIC,\n-                                                  names.fromString(\"$proxy$\" + component.name),\n-                                                  type,\n-                                                  currentClass);\n-            JCStatement accessorStatement =\n-                    make.Return(make.App(make.Select(make.Ident(proxy.params().head), c.accessor)));\n-            VarSymbol ctch = new VarSymbol(Flags.SYNTHETIC,\n-                    names.fromString(\"catch\" + currentClassTree.pos + target.syntheticNameChar()),\n-                    syms.throwableType,\n-                    currentMethodSym);\n-            JCNewClass newException = makeNewClass(syms.matchExceptionType,\n-                                                   List.of(makeApply(make.Ident(ctch),\n-                                                                     names.toString,\n-                                                                     List.nil()),\n-                                                           make.Ident(ctch)));\n-            JCTree.JCCatch catchClause = make.Catch(make.VarDef(ctch, null),\n-                                                    make.Block(0, List.of(make.Throw(newException))));\n-            JCStatement tryCatchAll = make.Try(make.Block(0, List.of(accessorStatement)),\n-                                               List.of(catchClause),\n-                                               null);\n-            JCMethodDecl md = make.MethodDef(proxy,\n-                                             proxy.externalType(types),\n-                                             make.Block(0, List.of(tryCatchAll)));\n-\n-            pendingMethods.append(md);\n-            currentClass.members().enter(proxy);\n-\n-            return proxy;\n-        });\n-    }\n+    record UnrolledRecordPattern(JCBindingPattern primaryPattern, JCExpression newGuard) {}\n@@ -394,1 +394,8 @@\n-            \/\/rewrite pattern matching switches:\n+            \/\/rewrite pattern matching switches, performed in several steps:\n+            \/\/1. record patterns are unrolled into a binding pattern and guards using unrollRecordPattern\n+            \/\/   (guards implement the nested pattern checks)\n+            \/\/   the switch only has constants and binding patterns as the\n+            \/\/2. the cases are processed through processCases, that will group cases with the same\n+            \/\/   binding pattern and similar guards, and will factor out the common binding pattern,\n+            \/\/   creating nested switches.\n+            \/\/3. the simplified binding-only switch with guards is then converted to an ordinary switch:\n@@ -396,4 +403,4 @@\n-            \/\/     case $constant: $stats$\n-            \/\/     case $pattern1: $stats$\n-            \/\/     case $pattern2, null: $stats$\n-            \/\/     case $pattern3: $stats$\n+            \/\/     case $constant: $stats1$\n+            \/\/     case $pattern2 when $guard2: $stats2$\n+            \/\/     case $pattern3, null: $stats3$\n+            \/\/     case $pattern4: $stats4$\n@@ -405,2 +412,1 @@\n-            \/\/         if (!(<desugared $pattern1>)) { $idx = 1; continue $RESTART; }\n-            \/\/         $stats$\n+            \/\/         $stats1$\n@@ -408,1 +414,1 @@\n-            \/\/         if (!(<desugared $pattern1>)) { $idx = 2; continue $RESTART; }\n+            \/\/         if (!(<desugared $pattern2> && $guard2)) { $idx = 2; continue $RESTART; }\n@@ -411,1 +417,1 @@\n-            \/\/         if (!(<desugared $pattern1>)) { $idx = 3; continue $RESTART; }\n+            \/\/         if (!(<desugared $pattern3>)) { $idx = 3; continue $RESTART; }\n@@ -414,1 +420,1 @@\n-            \/\/         if (!(<desugared $pattern1>)) { $idx = 4; continue $RESTART; }\n+            \/\/         if (!(<desugared $pattern4>)) { $idx = 4; continue $RESTART; }\n@@ -429,0 +435,19 @@\n+            ListBuffer<JCCase> newCases = new ListBuffer<>();\n+            for (List<JCCase> c = cases; c.nonEmpty(); c = c.tail) {\n+                c.head.labels = c.head.labels.map(l -> {\n+                    if (l instanceof JCPatternCaseLabel patternLabel) {\n+                        JCPattern pattern = TreeInfo.skipParens(patternLabel.pat);\n+                        if (pattern instanceof JCRecordPattern recordPattern) {\n+                            UnrolledRecordPattern deconstructed = unrollRecordPattern(recordPattern);\n+                            JCExpression guard = deconstructed.newGuard();\n+                            if (patternLabel.guard != null) {\n+                                guard = mergeConditions(guard, patternLabel.guard);\n+                            }\n+                            return make.PatternCaseLabel(deconstructed.primaryPattern(), guard);\n+                        }\n+                    }\n+                    return l;\n+                });\n+                newCases.add(c.head);\n+            }\n+            cases = processCases(tree, newCases.toList());\n@@ -431,1 +456,1 @@\n-                    names.fromString(\"selector\" + tree.pos + target.syntheticNameChar() + \"temp\"),\n+                    names.fromString(\"selector\" + variableIndex++ + target.syntheticNameChar() + \"temp\"),\n@@ -445,1 +470,1 @@\n-                    names.fromString(tree.pos + target.syntheticNameChar() + \"index\"),\n+                    names.fromString(\"index\" + target.syntheticNameChar() + variableIndex++),\n@@ -543,0 +568,3 @@\n+\n+                fixupContinue(tree, c, index, i);\n+\n@@ -599,0 +627,17 @@\n+    \/\/where:\n+        private void fixupContinue(JCTree switchTree, JCCase c, VarSymbol indexVariable, int currentCaseIndex) {\n+            \/\/inject 'index = currentCaseIndex + 1;` before continue which has the current switch as the target\n+            new TreeScanner() {\n+                @Override\n+                public void visitCase(JCCase c) {\n+                    if (c.stats.size() == 1 && c.stats.head instanceof JCContinue cont &&\n+                        cont.target == switchTree) {\n+                        JCExpressionStatement setIndex =\n+                                make.Exec(make.Assign(make.Ident(indexVariable),\n+                                                      makeLit(syms.intType, currentCaseIndex + 1))\n+                                              .setType(syms.intType));\n+                        c.stats = c.stats.prepend(setIndex);\n+                    }\n+                }\n+            }.scan(c.stats);\n+        }\n@@ -619,0 +664,159 @@\n+    \/**\n+     * Considering a list of cases, find consecutive cases with the same binding pattern as their label,\n+     * and type tests with binding patterns as the first element in the guard. These cases are then\n+     * merged into a single case, and a nested switch is generated from the first element of the guard.\n+     *\n+     * For example:\n+     *\n+     * OUTER:\n+     * switch (selector) {\n+     *     case Box b when b.o() instanceof String s -> {}\n+     *     case Box b when b.o() instanceof Integer i-> {}\n+     *     case Box b when b.o() instanceof Number n -> {}\n+     *     ...\n+     * }\n+     * =>\n+     * OUTER:\n+     * switch (selector) {\n+     *     case Box b ->\n+     *         switch (b.o()) {\n+     *             case String s -> {}\n+     *             case Integer i -> {}\n+     *             case Number n -> {}\n+     *             default -> continue OUTER; \/\/continue matching on next case of the outer switch\n+     *         }\n+     *     ...\n+     * }\n+     *\/\n+    private List<JCCase> processCases(JCTree currentSwitch, List<JCCase> inputCases) {\n+        interface AccummulatorResolver {\n+            public void resolve(VarSymbol commonBinding,\n+                                JCExpression commonNestedExpression,\n+                                VarSymbol commonNestedBinding);\n+        }\n+        ListBuffer<JCCase> accummulator = new ListBuffer<>();\n+        ListBuffer<JCCase> result = new ListBuffer<>();\n+        AccummulatorResolver resolveAccummulator = (commonBinding, commonNestedExpression, commonNestedBinding) -> {\n+                boolean hasUnconditional = false;\n+                if (accummulator.size() > 1) {\n+                    Assert.check(commonBinding != null &&\n+                                 commonNestedExpression != null &&\n+                                 commonNestedBinding != null,\n+                                 () -> \"commonBinding: \" + commonBinding +\n+                                       \"commonNestedExpression: \" + commonNestedExpression +\n+                                       \"commonNestedBinding: \" + commonNestedBinding);\n+                    ListBuffer<JCCase> nestedCases = new ListBuffer<>();\n+\n+                    for(List<JCCase> accList = accummulator.toList(); accList.nonEmpty(); accList = accList.tail) {\n+                        var accummulated = accList.head;\n+                        JCPatternCaseLabel accummulatedFirstLabel =\n+                                (JCPatternCaseLabel) accummulated.labels.head;\n+                        JCBindingPattern accummulatedPattern =\n+                                (JCBindingPattern) accummulatedFirstLabel.pat;\n+                        VarSymbol accummulatedBinding = accummulatedPattern.var.sym;\n+                        TreeScanner replaceNested =\n+                                new ReplaceVar(Map.of(accummulatedBinding, commonBinding));\n+\n+                        replaceNested.scan(accummulated);\n+                        JCExpression newGuard;\n+                        JCInstanceOf instanceofCheck;\n+                        if (accummulatedFirstLabel.guard instanceof JCBinary binOp) {\n+                            newGuard = binOp.rhs;\n+                            instanceofCheck = (JCInstanceOf) binOp.lhs;\n+                        } else {\n+                            newGuard = null;\n+                            instanceofCheck = (JCInstanceOf) accummulatedFirstLabel.guard;\n+                        }\n+                        JCBindingPattern binding = (JCBindingPattern) instanceofCheck.pattern;\n+                        hasUnconditional =\n+                                instanceofCheck.allowNull &&\n+                                types.isSubtype(commonNestedExpression.type,\n+                                                types.boxedTypeOrType(types.erasure(binding.type))) &&\n+                                accList.tail.isEmpty();\n+                        List<JCCaseLabel> newLabel;\n+                        if (hasUnconditional) {\n+                            newLabel = List.of(make.ConstantCaseLabel(makeNull()),\n+                                               make.DefaultCaseLabel());\n+                        } else {\n+                            newLabel = List.of(make.PatternCaseLabel(binding, newGuard));\n+                        }\n+                        nestedCases.add(make.Case(CaseKind.STATEMENT, newLabel, accummulated.stats, null));\n+                    }\n+                    if (!hasUnconditional) {\n+                        JCContinue continueSwitch = make.Continue(null);\n+                        continueSwitch.target = currentSwitch;\n+                        nestedCases.add(make.Case(CaseKind.STATEMENT,\n+                                                  List.of(make.ConstantCaseLabel(makeNull()),\n+                                                          make.DefaultCaseLabel()),\n+                                                  List.of(continueSwitch),\n+                                                  null));\n+                    }\n+                    JCSwitch newSwitch = make.Switch(commonNestedExpression, nestedCases.toList());\n+                    newSwitch.patternSwitch = true;\n+                    JCPatternCaseLabel leadingTest =\n+                            (JCPatternCaseLabel) accummulator.first().labels.head;\n+                    leadingTest.guard = null;\n+                    result.add(make.Case(CaseKind.STATEMENT,\n+                                         List.of(leadingTest),\n+                                         List.of(newSwitch),\n+                                         null));\n+                } else {\n+                    result.addAll(accummulator);\n+                }\n+                accummulator.clear();\n+        };\n+\n+        VarSymbol commonBinding = null;\n+        JCExpression commonNestedExpression = null;\n+        VarSymbol commonNestedBinding = null;\n+\n+        for (List<JCCase> c = inputCases; c.nonEmpty(); c = c.tail) {\n+            VarSymbol currentBinding = null;\n+            JCExpression currentNestedExpression = null;\n+            VarSymbol currentNestedBinding = null;\n+\n+            if (c.head.labels.size() == 1 &&\n+                c.head.labels.head instanceof JCPatternCaseLabel patternLabel) {\n+                if (patternLabel.guard instanceof JCBinary binOp &&\n+                    binOp.lhs instanceof JCInstanceOf instanceofCheck &&\n+                    instanceofCheck.pattern instanceof JCBindingPattern binding) {\n+                    currentBinding = ((JCBindingPattern) patternLabel.pat).var.sym;\n+                    currentNestedExpression = instanceofCheck.expr;\n+                    currentNestedBinding = binding.var.sym;\n+                } else if (patternLabel.guard instanceof JCInstanceOf instanceofCheck &&\n+                    instanceofCheck.pattern instanceof JCBindingPattern binding) {\n+                    currentBinding = ((JCBindingPattern) patternLabel.pat).var.sym;\n+                    currentNestedExpression = instanceofCheck.expr;\n+                    currentNestedBinding = binding.var.sym;\n+                }\n+            }\n+            if (commonBinding == null) {\n+                if (currentBinding != null) {\n+                    commonBinding = currentBinding;\n+                    commonNestedExpression = currentNestedExpression;\n+                    commonNestedBinding = currentNestedBinding;\n+                    accummulator.add(c.head);\n+                } else {\n+                    result.add(c.head);\n+                }\n+            } else if (currentBinding != null &&\n+                       commonBinding.type.tsym == currentBinding.type.tsym &&\n+                       new TreeDiffer(List.of(commonBinding), List.of(currentBinding))\n+                               .scan(commonNestedExpression, currentNestedExpression)) {\n+                accummulator.add(c.head);\n+            } else {\n+                resolveAccummulator.resolve(commonBinding, commonNestedExpression, commonNestedBinding);\n+                if (currentBinding != null) {\n+                    accummulator.add(c.head);\n+                } else {\n+                    result.add(c.head);\n+                }\n+                commonBinding = currentBinding;\n+                commonNestedExpression = currentNestedExpression;\n+                commonNestedBinding = currentNestedBinding;\n+            }\n+        }\n+        resolveAccummulator.resolve(commonBinding, commonNestedExpression, commonNestedBinding);\n+        return result.toList();\n+    }\n+\n@@ -790,0 +994,2 @@\n+        int prevVariableIndex = variableIndex;\n+        Set<JCMethodInvocation> prevDeconstructorCalls = deconstructorCalls;\n@@ -792,0 +998,2 @@\n+            variableIndex = 0;\n+            deconstructorCalls = null;\n@@ -793,0 +1001,1 @@\n+            preparePatternMatchingCatchIfNeeded(tree.body);\n@@ -794,0 +1003,1 @@\n+            variableIndex = prevVariableIndex;\n@@ -795,0 +1005,1 @@\n+            deconstructorCalls = prevDeconstructorCalls;\n@@ -836,0 +1047,1 @@\n+        int prevVariableIndex = variableIndex;\n@@ -837,9 +1049,24 @@\n-            if (currentMethodSym == null) {\n-                \/\/ Block is a static or instance initializer.\n-                currentMethodSym =\n-                    new MethodSymbol(tree.flags | Flags.BLOCK,\n-                                     names.empty, null,\n-                                     currentClass);\n-            }\n-            for (List<JCStatement> l = tree.stats; l.nonEmpty(); l = l.tail) {\n-                statements.append(translate(l.head));\n+            boolean isInit = currentMethodSym == null;\n+            Set<JCMethodInvocation> prevDeconstructorCalls = deconstructorCalls;\n+            try {\n+                if (isInit) {\n+                    \/\/ Block is a static or instance initializer.\n+                    currentMethodSym =\n+                        new MethodSymbol(tree.flags | Flags.BLOCK,\n+                                         names.empty, null,\n+                                         currentClass);\n+                    variableIndex = 0;\n+                    deconstructorCalls = null;\n+                }\n+\n+                for (List<JCStatement> l = tree.stats; l.nonEmpty(); l = l.tail) {\n+                    statements.append(translate(l.head));\n+                }\n+\n+                if (isInit) {\n+                    preparePatternMatchingCatchIfNeeded(tree);\n+                }\n+            } finally {\n+                if (isInit) {\n+                    deconstructorCalls = prevDeconstructorCalls;\n+                }\n@@ -851,0 +1078,1 @@\n+            variableIndex = prevVariableIndex;\n@@ -859,0 +1087,1 @@\n+        int prevVariableIndex = variableIndex;\n@@ -861,1 +1090,20 @@\n-            super.visitLambda(tree);\n+            variableIndex = 0;\n+            tree.params = translate(tree.params);\n+            Set<JCMethodInvocation> prevDeconstructorCalls = deconstructorCalls;\n+            try {\n+                deconstructorCalls = null;\n+                tree.body = translate(tree.body);\n+                if (deconstructorCalls != null) {\n+                    if (tree.body instanceof JCExpression value) {\n+                        tree.body = make.Block(0, List.of(make.Return(value)));\n+                    }\n+                    if (tree.body instanceof JCBlock block) {\n+                        preparePatternMatchingCatchIfNeeded(block);\n+                    } else {\n+                        throw Assert.error(\"Unexpected lambda body type: \" + tree.body.getKind());\n+                    }\n+                }\n+            } finally {\n+                deconstructorCalls = prevDeconstructorCalls;\n+            }\n+            result = tree;\n@@ -863,0 +1111,1 @@\n+            variableIndex = prevVariableIndex;\n@@ -893,0 +1142,1 @@\n+        int prevVariableIndex = variableIndex;\n@@ -902,0 +1152,1 @@\n+                variableIndex = 0;\n@@ -906,0 +1157,1 @@\n+            variableIndex = prevVariableIndex;\n@@ -910,0 +1162,37 @@\n+    @Override\n+    public void visitTry(JCTry tree) {\n+        tree.resources = translate(tree.resources);\n+        Set<JCMethodInvocation> prevDeconstructorCalls = deconstructorCalls;\n+        try {\n+            deconstructorCalls = null;\n+            tree.body = translate(tree.body);\n+            preparePatternMatchingCatchIfNeeded(tree.body);\n+        } finally {\n+            deconstructorCalls = prevDeconstructorCalls;\n+        }\n+        tree.catchers = translateCatchers(tree.catchers);\n+        tree.finalizer = translate(tree.finalizer);\n+        result = tree;\n+    }\n+\n+    private void preparePatternMatchingCatchIfNeeded(JCBlock tree) {\n+        if (deconstructorCalls != null) {\n+            VarSymbol ctch = new VarSymbol(Flags.SYNTHETIC,\n+                    names.fromString(\"catch\" + variableIndex++ + target.syntheticNameChar()),\n+                    syms.throwableType,\n+                    currentMethodSym);\n+\n+            JCCatch patternMatchingCatch =\n+                    make.Catch(make.VarDef(ctch, null),\n+                               make.Block(0,\n+                                          List.of(make.Throw(makeNewClass(syms.matchExceptionType,\n+                                                                          List.of(makeApply(make.Ident(ctch),\n+                                                                                            names.toString,\n+                                                                                            List.nil()),\n+                                                                                  make.Ident(ctch)))))));\n+            tree.patternMatchingCatch =\n+                    new PatternMatchingCatch(patternMatchingCatch, deconstructorCalls);\n+            deconstructorCalls = null;\n+        }\n+    }\n+\n@@ -959,0 +1248,4 @@\n+        if (types.isSubtype(expr.type, target)) {\n+            \/\/cast not needed\n+            return expr;\n+        }\n@@ -964,0 +1257,12 @@\n+    JCExpression mergeConditions(JCExpression left, JCExpression right) {\n+        if (left instanceof JCBinary lastBinary) {\n+            while (lastBinary.rhs instanceof JCBinary nextBinary) {\n+                lastBinary = nextBinary;\n+            }\n+            lastBinary.rhs = makeBinary(Tag.AND, lastBinary.rhs, right);\n+            return left;\n+        } else {\n+            return makeBinary(Tag.AND, left, right);\n+        }\n+    }\n+\n@@ -987,1 +1292,1 @@\n-                res = new VarSymbol(varSymbol.flags(), varSymbol.name, varSymbol.type, currentMethodSym);\n+                res = new VarSymbol(varSymbol.flags() & ~Flags.MATCH_BINDING, varSymbol.name, varSymbol.type, currentMethodSym);\n@@ -1089,0 +1394,15 @@\n+\n+    private class ReplaceVar extends TreeScanner {\n+\n+        private final Map<Symbol, Symbol> fromTo;\n+\n+        public ReplaceVar(Map<Symbol, Symbol> fromTo) {\n+            this.fromTo = fromTo;\n+        }\n+\n+        @Override\n+        public void visitIdent(JCIdent tree) {\n+            tree.sym = fromTo.getOrDefault(tree.sym, tree.sym);\n+            super.visitIdent(tree);\n+        }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":450,"deletions":130,"binary":false,"changes":580,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.tools.javac.code.Flags;\n@@ -47,0 +48,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCConstantCaseLabel;\n@@ -72,0 +74,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCPatternCaseLabel;\n@@ -300,0 +303,12 @@\n+    @Override\n+    public void visitConstantCaseLabel(JCConstantCaseLabel tree) {\n+        JCConstantCaseLabel that = (JCConstantCaseLabel) parameter;\n+        result = scan(tree.expr, that.expr);\n+    }\n+\n+    @Override\n+    public void visitPatternCaseLabel(JCPatternCaseLabel tree) {\n+        JCPatternCaseLabel that = (JCPatternCaseLabel) parameter;\n+        result = scan(tree.pat, that.pat) && scan(tree.guard, that.guard);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TreeDiffer.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -999,4 +999,2 @@\n-                    sym.createRecordComponent(rc, field,\n-                            field.mods.annotations.isEmpty() ?\n-                                    List.nil() :\n-                                    new TreeCopier<JCTree>(make.at(field.pos)).copy(field.mods.annotations));\n+                    JCVariableDecl rcDecl = new TreeCopier<JCTree>(make.at(field.pos)).copy(field);\n+                    sym.createRecordComponent(rc, rcDecl, field.sym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -124,1 +124,2 @@\n-        V64(64, 0);   \/\/ JDK 20\n+        V64(64, 0),   \/\/ JDK 20\n+        V65(65, 0);   \/\/ JDK 21\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassFile.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.Set;\n@@ -173,0 +174,2 @@\n+    Set<JCMethodInvocation> invocationsWithPatternMatchingCatch = Set.of();\n+    ListBuffer<int[]> patternMatchingInvocationRanges;\n@@ -1052,0 +1055,23 @@\n+        if (tree.patternMatchingCatch != null) {\n+            Set<JCMethodInvocation> prevInvocationsWithPatternMatchingCatch = invocationsWithPatternMatchingCatch;\n+            ListBuffer<int[]> prevRanges = patternMatchingInvocationRanges;\n+            State startState = code.state.dup();\n+            try {\n+                invocationsWithPatternMatchingCatch = tree.patternMatchingCatch.calls2Handle();\n+                patternMatchingInvocationRanges = new ListBuffer<>();\n+                doVisitBlock(tree);\n+            } finally {\n+                Chain skipCatch = code.branch(goto_);\n+                JCCatch handler = tree.patternMatchingCatch.handler();\n+                code.entryPoint(startState, handler.param.sym.type);\n+                genPatternMatchingCatch(handler, env, patternMatchingInvocationRanges.toList());\n+                code.resolve(skipCatch);\n+                invocationsWithPatternMatchingCatch = prevInvocationsWithPatternMatchingCatch;\n+                patternMatchingInvocationRanges = prevRanges;\n+            }\n+        } else {\n+            doVisitBlock(tree);\n+        }\n+    }\n+\n+    private void doVisitBlock(JCBlock tree) {\n@@ -1614,10 +1640,1 @@\n-                VarSymbol exparam = tree.param.sym;\n-                code.statBegin(tree.pos);\n-                code.markStatBegin();\n-                int limit = code.nextreg;\n-                code.newLocal(exparam);\n-                items.makeLocalItem(exparam).store();\n-                code.statBegin(TreeInfo.firstStatPos(tree.body));\n-                genStat(tree.body, env, CRT_BLOCK);\n-                code.endScopes(limit);\n-                code.statBegin(TreeInfo.endPos(tree.body));\n+                genCatchBlock(tree, env);\n@@ -1626,0 +1643,24 @@\n+        void genPatternMatchingCatch(JCCatch tree,\n+                                     Env<GenContext> env,\n+                                     List<int[]> ranges) {\n+            for (int[] range : ranges) {\n+                JCExpression subCatch = tree.param.vartype;\n+                int catchType = makeRef(tree.pos(), subCatch.type);\n+                registerCatch(tree.pos(),\n+                              range[0], range[1], code.curCP(),\n+                              catchType);\n+            }\n+            genCatchBlock(tree, env);\n+        }\n+        void genCatchBlock(JCCatch tree, Env<GenContext> env) {\n+            VarSymbol exparam = tree.param.sym;\n+            code.statBegin(tree.pos);\n+            code.markStatBegin();\n+            int limit = code.nextreg;\n+            code.newLocal(exparam);\n+            items.makeLocalItem(exparam).store();\n+            code.statBegin(TreeInfo.firstStatPos(tree.body));\n+            genStat(tree.body, env, CRT_BLOCK);\n+            code.endScopes(limit);\n+            code.statBegin(TreeInfo.endPos(tree.body));\n+        }\n@@ -1842,1 +1883,7 @@\n-        result = m.invoke();\n+        if (invocationsWithPatternMatchingCatch.contains(tree)) {\n+            int start = code.curCP();\n+            result = m.invoke();\n+            patternMatchingInvocationRanges.add(new int[] {start, code.curCP()});\n+        } else {\n+            result = m.invoke();\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":58,"deletions":11,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -97,1 +97,4 @@\n-    JDK1_20(\"20\", 64, 0);\n+    JDK1_20(\"20\", 64, 0),\n+\n+    \/** JDK 21. *\/\n+    JDK1_21(\"21\", 65, 0);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Target.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCBindingPattern;\n@@ -97,0 +98,3 @@\n+import com.sun.tools.javac.tree.JCTree.JCRecordPattern;\n+import com.sun.tools.javac.tree.JCTree.JCSwitch;\n+import com.sun.tools.javac.tree.JCTree.JCSwitchExpression;\n@@ -1468,0 +1472,1 @@\n+            protected boolean hasPatterns;\n@@ -1478,0 +1483,1 @@\n+                            boolean prevHasPatterns = hasPatterns;\n@@ -1482,4 +1488,5 @@\n-                                 * ignore any updates to hasLambdas made during\n-                                 * the nested scan, this ensures an initialized\n-                                 * LambdaToMethod is available only to those\n-                                 * classes that contain lambdas\n+                                 * ignore any updates to hasLambdas and hasPatterns\n+                                 * made during the nested scan, this ensures an\n+                                 * initialized LambdaToMethod or TransPatterns is\n+                                 * available only to those classes that contain\n+                                 * lambdas or patterns, respectivelly\n@@ -1488,0 +1495,1 @@\n+                                hasPatterns = prevHasPatterns;\n@@ -1506,0 +1514,25 @@\n+            @Override\n+            public void visitBindingPattern(JCBindingPattern tree) {\n+                hasPatterns = true;\n+                super.visitBindingPattern(tree);\n+            }\n+            @Override\n+            public void visitRecordPattern(JCRecordPattern that) {\n+                hasPatterns = true;\n+                super.visitRecordPattern(that);\n+            }\n+            @Override\n+            public void visitParenthesizedPattern(JCTree.JCParenthesizedPattern tree) {\n+                hasPatterns = true;\n+                super.visitParenthesizedPattern(tree);\n+            }\n+            @Override\n+            public void visitSwitch(JCSwitch tree) {\n+                hasPatterns |= tree.patternSwitch;\n+                super.visitSwitch(tree);\n+            }\n+            @Override\n+            public void visitSwitchExpression(JCSwitchExpression tree) {\n+                hasPatterns |= tree.patternSwitch;\n+                super.visitSwitchExpression(tree);\n+            }\n@@ -1554,1 +1587,4 @@\n-            env.tree = TransPatterns.instance(context).translateTopLevelClass(env, env.tree, localMake);\n+            if (scanner.hasPatterns) {\n+                env.tree = TransPatterns.instance(context).translateTopLevelClass(env, env.tree, localMake);\n+            }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":41,"deletions":5,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-@SupportedSourceVersion(SourceVersion.RELEASE_20)\n+@SupportedSourceVersion(SourceVersion.RELEASE_21)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/PrintingProcessor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1077,0 +1077,6 @@\n+        \/** If this block contains record pattern, it is necessary to catch\n+         *  exceptions from the deconstructors and wrap them.\n+         * The {@code patternMatchingCatch} keeps the list of the deconstructor\n+         * invocations, and the additional catch block that wraps the exceptions.\n+         *\/\n+        public PatternMatchingCatch patternMatchingCatch;\n@@ -1101,0 +1107,2 @@\n+\n+        public record PatternMatchingCatch(JCCatch handler, Set<JCMethodInvocation> calls2Handle) {}\n@@ -2221,0 +2229,3 @@\n+        \/**{@code true} if this instanceof test should have\n+         * value {@code true} when the {@code expr} is {@code null}.*\/\n+        public boolean allowNull;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import com.sun.tools.javac.code.Symbol.RecordComponent;\n@@ -49,0 +50,1 @@\n+import javax.lang.model.element.ElementKind;\n@@ -795,0 +797,6 @@\n+            if (this.sym.getKind() == ElementKind.RECORD_COMPONENT) {\n+                if (thatSym != null && thatSym.getKind() == ElementKind.FIELD && (thatSym.flags_field & RECORD) != 0) {\n+                    RecordComponent rc = thatSym.enclClass().getRecordComponent((VarSymbol)thatSym);\n+                    return checkMatch(rc.declarationFor(), rc);\n+                }\n+            }\n@@ -841,0 +849,9 @@\n+    \/** Skip parens and return the enclosed expression\n+     *\/\n+    public static JCPattern skipParens(JCPattern tree) {\n+        while (tree.hasTag(PARENTHESIZEDPATTERN)) {\n+            tree = ((JCParenthesizedPattern) tree).pattern;\n+        }\n+        return tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,1016 @@\n+#\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name java\/io\/BufferedInputStream\n+method name transferTo descriptor (Ljava\/io\/OutputStream;)J thrownTypes java\/io\/IOException flags 1\n+\n+class name java\/io\/PrintStream\n+header extends java\/io\/FilterOutputStream implements java\/lang\/Appendable,java\/io\/Closeable flags 21\n+innerclass innerClass java\/util\/Locale$Category outerClass java\/util\/Locale innerClassName Category flags 4019\n+\n+class name java\/io\/PushbackInputStream\n+method name transferTo descriptor (Ljava\/io\/OutputStream;)J thrownTypes java\/io\/IOException flags 1\n+\n+class name java\/lang\/AbstractStringBuilder\n+header extends java\/lang\/Object implements java\/lang\/Appendable,java\/lang\/CharSequence sealed true flags 420\n+innerclass innerClass java\/util\/Spliterator$OfInt outerClass java\/util\/Spliterator innerClassName OfInt flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/Character$UnicodeBlock\n+field name ARABIC_EXTENDED_C descriptor Ljava\/lang\/Character$UnicodeBlock; flags 19\n+field name DEVANAGARI_EXTENDED_A descriptor Ljava\/lang\/Character$UnicodeBlock; flags 19\n+field name KAWI descriptor Ljava\/lang\/Character$UnicodeBlock; flags 19\n+field name KAKTOVIK_NUMERALS descriptor Ljava\/lang\/Character$UnicodeBlock; flags 19\n+field name CYRILLIC_EXTENDED_D descriptor Ljava\/lang\/Character$UnicodeBlock; flags 19\n+field name NAG_MUNDARI descriptor Ljava\/lang\/Character$UnicodeBlock; flags 19\n+field name CJK_UNIFIED_IDEOGRAPHS_EXTENSION_H descriptor Ljava\/lang\/Character$UnicodeBlock; flags 19\n+\n+class name java\/lang\/Character$UnicodeScript\n+field name KAWI descriptor Ljava\/lang\/Character$UnicodeScript; flags 4019\n+field name NAG_MUNDARI descriptor Ljava\/lang\/Character$UnicodeScript; flags 4019\n+\n+class name java\/lang\/Class\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/reflect\/GenericDeclaration,java\/lang\/reflect\/Type,java\/lang\/reflect\/AnnotatedElement,java\/lang\/invoke\/TypeDescriptor$OfField,java\/lang\/constant\/Constable flags 31 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/io\/Serializable;Ljava\/lang\/reflect\/GenericDeclaration;Ljava\/lang\/reflect\/Type;Ljava\/lang\/reflect\/AnnotatedElement;Ljava\/lang\/invoke\/TypeDescriptor$OfField<Ljava\/lang\/Class<*>;>;Ljava\/lang\/constant\/Constable;\n+innerclass innerClass java\/lang\/reflect\/AccessFlag$Location outerClass java\/lang\/reflect\/AccessFlag innerClassName Location flags 4019\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/TypeDescriptor$OfField outerClass java\/lang\/invoke\/TypeDescriptor innerClassName OfField flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name accessFlags descriptor ()Ljava\/util\/Set; flags 1 signature ()Ljava\/util\/Set<Ljava\/lang\/reflect\/AccessFlag;>;\n+\n+class name java\/lang\/Compiler\n+header extends java\/lang\/Object flags 31 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name java\/lang\/Deprecated\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Documented;@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;RUNTIME;)@Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;CONSTRUCTOR;eLjava\/lang\/annotation\/ElementType;FIELD;eLjava\/lang\/annotation\/ElementType;LOCAL_VARIABLE;eLjava\/lang\/annotation\/ElementType;METHOD;eLjava\/lang\/annotation\/ElementType;PACKAGE;eLjava\/lang\/annotation\/ElementType;MODULE;eLjava\/lang\/annotation\/ElementType;PARAMETER;eLjava\/lang\/annotation\/ElementType;TYPE;})\n+\n+class name java\/lang\/Double\n+-method name isFinite descriptor (D)Z\n+method name isFinite descriptor (D)Z flags 9 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+\n+class name java\/lang\/Float\n+-method name isFinite descriptor (F)Z\n+method name isFinite descriptor (F)Z flags 9 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+method name float16ToFloat descriptor (S)F flags 9 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+method name floatToFloat16 descriptor (F)S flags 9 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+\n+class name java\/lang\/IllegalCallerException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/Integer\n+-method name compareUnsigned descriptor (II)I\n+-method name reverse descriptor (I)I\n+method name compareUnsigned descriptor (II)I flags 9 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+method name reverse descriptor (I)I flags 9 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+\n+class name java\/lang\/LayerInstantiationException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/Long\n+-method name compareUnsigned descriptor (JJ)I\n+-method name reverse descriptor (J)J\n+method name compareUnsigned descriptor (JJ)I flags 9 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+method name reverse descriptor (J)J flags 9 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+\n+class name java\/lang\/NamedPackage\n+header extends java\/lang\/Object flags 20\n+\n+class name java\/lang\/Thread$Builder\n+header extends java\/lang\/Object nestHost java\/lang\/Thread sealed true flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;VIRTUAL_THREADS;)\n+innerclass innerClass java\/lang\/Thread$Builder outerClass java\/lang\/Thread innerClassName Builder flags 609\n+innerclass innerClass java\/lang\/Thread$Builder$OfVirtual outerClass java\/lang\/Thread$Builder innerClassName OfVirtual flags 609\n+innerclass innerClass java\/lang\/Thread$Builder$OfPlatform outerClass java\/lang\/Thread$Builder innerClassName OfPlatform flags 609\n+innerclass innerClass java\/lang\/Thread$UncaughtExceptionHandler outerClass java\/lang\/Thread innerClassName UncaughtExceptionHandler flags 609\n+\n+class name java\/lang\/Thread$Builder$OfPlatform\n+header extends java\/lang\/Object implements java\/lang\/Thread$Builder nestHost java\/lang\/Thread sealed true flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;VIRTUAL_THREADS;)\n+innerclass innerClass java\/lang\/Thread$Builder outerClass java\/lang\/Thread innerClassName Builder flags 609\n+innerclass innerClass java\/lang\/Thread$Builder$OfPlatform outerClass java\/lang\/Thread$Builder innerClassName OfPlatform flags 609\n+innerclass innerClass java\/lang\/Thread$UncaughtExceptionHandler outerClass java\/lang\/Thread innerClassName UncaughtExceptionHandler flags 609\n+\n+class name java\/lang\/Thread$Builder$OfVirtual\n+header extends java\/lang\/Object implements java\/lang\/Thread$Builder nestHost java\/lang\/Thread sealed true flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;VIRTUAL_THREADS;)\n+innerclass innerClass java\/lang\/Thread$Builder outerClass java\/lang\/Thread innerClassName Builder flags 609\n+innerclass innerClass java\/lang\/Thread$Builder$OfVirtual outerClass java\/lang\/Thread$Builder innerClassName OfVirtual flags 609\n+innerclass innerClass java\/lang\/Thread$UncaughtExceptionHandler outerClass java\/lang\/Thread innerClassName UncaughtExceptionHandler flags 609\n+\n+class name java\/lang\/ThreadDeath\n+header extends java\/lang\/Error flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"20\")\n+\n+class name java\/lang\/constant\/ClassDesc\n+header extends java\/lang\/Object implements java\/lang\/constant\/ConstantDesc,java\/lang\/invoke\/TypeDescriptor$OfField sealed true flags 601 signature Ljava\/lang\/Object;Ljava\/lang\/constant\/ConstantDesc;Ljava\/lang\/invoke\/TypeDescriptor$OfField<Ljava\/lang\/constant\/ClassDesc;>;\n+innerclass innerClass java\/lang\/invoke\/TypeDescriptor$OfField outerClass java\/lang\/invoke\/TypeDescriptor innerClassName OfField flags 609\n+method name ofInternalName descriptor (Ljava\/lang\/String;)Ljava\/lang\/constant\/ClassDesc; flags 9\n+\n+class name java\/lang\/constant\/ConstantDesc\n+header extends java\/lang\/Object sealed true flags 601\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/constant\/DirectMethodHandleDesc\n+header extends java\/lang\/Object implements java\/lang\/constant\/MethodHandleDesc nestMembers java\/lang\/constant\/DirectMethodHandleDesc$Kind sealed true flags 601\n+innerclass innerClass java\/lang\/constant\/DirectMethodHandleDesc$Kind outerClass java\/lang\/constant\/DirectMethodHandleDesc innerClassName Kind flags 4019\n+\n+class name java\/lang\/constant\/MethodHandleDesc\n+header extends java\/lang\/Object implements java\/lang\/constant\/ConstantDesc sealed true flags 601\n+innerclass innerClass java\/lang\/constant\/DirectMethodHandleDesc$Kind outerClass java\/lang\/constant\/DirectMethodHandleDesc innerClassName Kind flags 4019\n+\n+class name java\/lang\/constant\/MethodTypeDesc\n+header extends java\/lang\/Object implements java\/lang\/constant\/ConstantDesc,java\/lang\/invoke\/TypeDescriptor$OfMethod sealed true flags 601 signature Ljava\/lang\/Object;Ljava\/lang\/constant\/ConstantDesc;Ljava\/lang\/invoke\/TypeDescriptor$OfMethod<Ljava\/lang\/constant\/ClassDesc;Ljava\/lang\/constant\/MethodTypeDesc;>;\n+innerclass innerClass java\/lang\/invoke\/TypeDescriptor$OfMethod outerClass java\/lang\/invoke\/TypeDescriptor innerClassName OfMethod flags 609\n+innerclass innerClass java\/lang\/invoke\/TypeDescriptor$OfField outerClass java\/lang\/invoke\/TypeDescriptor innerClassName OfField flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/foreign\/Addressable\n+header extends java\/lang\/Object sealed true flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;)\n+\n+class name java\/lang\/foreign\/FunctionDescriptor\n+header extends java\/lang\/Object sealed true flags 21 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;)\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/foreign\/Linker\n+header extends java\/lang\/Object sealed true flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;)\n+\n+class name java\/lang\/foreign\/MemoryAddress\n+header extends java\/lang\/Object implements java\/lang\/foreign\/Addressable sealed true flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;)\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfByte outerClass java\/lang\/foreign\/ValueLayout innerClassName OfByte flags 19\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfBoolean outerClass java\/lang\/foreign\/ValueLayout innerClassName OfBoolean flags 19\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfChar outerClass java\/lang\/foreign\/ValueLayout innerClassName OfChar flags 19\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfShort outerClass java\/lang\/foreign\/ValueLayout innerClassName OfShort flags 19\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfInt outerClass java\/lang\/foreign\/ValueLayout innerClassName OfInt flags 19\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfFloat outerClass java\/lang\/foreign\/ValueLayout innerClassName OfFloat flags 19\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfLong outerClass java\/lang\/foreign\/ValueLayout innerClassName OfLong flags 19\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfDouble outerClass java\/lang\/foreign\/ValueLayout innerClassName OfDouble flags 19\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfAddress outerClass java\/lang\/foreign\/ValueLayout innerClassName OfAddress flags 19\n+\n+class name java\/lang\/foreign\/MemoryLayout\n+header extends java\/lang\/Object nestMembers java\/lang\/foreign\/MemoryLayout$PathElement sealed true flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;)\n+innerclass innerClass java\/lang\/foreign\/MemoryLayout$PathElement outerClass java\/lang\/foreign\/MemoryLayout innerClassName PathElement flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfBoolean outerClass java\/lang\/foreign\/ValueLayout innerClassName OfBoolean flags 19\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfChar outerClass java\/lang\/foreign\/ValueLayout innerClassName OfChar flags 19\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfByte outerClass java\/lang\/foreign\/ValueLayout innerClassName OfByte flags 19\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfShort outerClass java\/lang\/foreign\/ValueLayout innerClassName OfShort flags 19\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfInt outerClass java\/lang\/foreign\/ValueLayout innerClassName OfInt flags 19\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfFloat outerClass java\/lang\/foreign\/ValueLayout innerClassName OfFloat flags 19\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfLong outerClass java\/lang\/foreign\/ValueLayout innerClassName OfLong flags 19\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfDouble outerClass java\/lang\/foreign\/ValueLayout innerClassName OfDouble flags 19\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfAddress outerClass java\/lang\/foreign\/ValueLayout innerClassName OfAddress flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/foreign\/MemoryLayout$PathElement\n+header extends java\/lang\/Object nestHost java\/lang\/foreign\/MemoryLayout sealed true flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;)\n+innerclass innerClass java\/lang\/foreign\/MemoryLayout$PathElement outerClass java\/lang\/foreign\/MemoryLayout innerClassName PathElement flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/foreign\/MemorySegment\n+header extends java\/lang\/Object implements java\/lang\/foreign\/Addressable sealed true flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;)\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfByte outerClass java\/lang\/foreign\/ValueLayout innerClassName OfByte flags 19\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfBoolean outerClass java\/lang\/foreign\/ValueLayout innerClassName OfBoolean flags 19\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfChar outerClass java\/lang\/foreign\/ValueLayout innerClassName OfChar flags 19\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfShort outerClass java\/lang\/foreign\/ValueLayout innerClassName OfShort flags 19\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfInt outerClass java\/lang\/foreign\/ValueLayout innerClassName OfInt flags 19\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfFloat outerClass java\/lang\/foreign\/ValueLayout innerClassName OfFloat flags 19\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfLong outerClass java\/lang\/foreign\/ValueLayout innerClassName OfLong flags 19\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfDouble outerClass java\/lang\/foreign\/ValueLayout innerClassName OfDouble flags 19\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfAddress outerClass java\/lang\/foreign\/ValueLayout innerClassName OfAddress flags 19\n+\n+class name java\/lang\/foreign\/MemorySession\n+header extends java\/lang\/Object implements java\/lang\/AutoCloseable,java\/lang\/foreign\/SegmentAllocator sealed true flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;)\n+\n+class name java\/lang\/foreign\/VaList\n+header extends java\/lang\/Object implements java\/lang\/foreign\/Addressable nestMembers java\/lang\/foreign\/VaList$Builder sealed true flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;)\n+innerclass innerClass java\/lang\/foreign\/VaList$Builder outerClass java\/lang\/foreign\/VaList innerClassName Builder flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfInt outerClass java\/lang\/foreign\/ValueLayout innerClassName OfInt flags 19\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfLong outerClass java\/lang\/foreign\/ValueLayout innerClassName OfLong flags 19\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfDouble outerClass java\/lang\/foreign\/ValueLayout innerClassName OfDouble flags 19\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfAddress outerClass java\/lang\/foreign\/ValueLayout innerClassName OfAddress flags 19\n+\n+class name java\/lang\/foreign\/VaList$Builder\n+header extends java\/lang\/Object nestHost java\/lang\/foreign\/VaList sealed true flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;)\n+innerclass innerClass java\/lang\/foreign\/VaList$Builder outerClass java\/lang\/foreign\/VaList innerClassName Builder flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfInt outerClass java\/lang\/foreign\/ValueLayout innerClassName OfInt flags 19\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfLong outerClass java\/lang\/foreign\/ValueLayout innerClassName OfLong flags 19\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfDouble outerClass java\/lang\/foreign\/ValueLayout innerClassName OfDouble flags 19\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfAddress outerClass java\/lang\/foreign\/ValueLayout innerClassName OfAddress flags 19\n+\n+class name java\/lang\/foreign\/ValueLayout\n+header extends java\/lang\/foreign\/AbstractLayout implements java\/lang\/foreign\/MemoryLayout nestMembers java\/lang\/foreign\/ValueLayout$OfAddress,java\/lang\/foreign\/ValueLayout$OfDouble,java\/lang\/foreign\/ValueLayout$OfLong,java\/lang\/foreign\/ValueLayout$OfFloat,java\/lang\/foreign\/ValueLayout$OfInt,java\/lang\/foreign\/ValueLayout$OfShort,java\/lang\/foreign\/ValueLayout$OfChar,java\/lang\/foreign\/ValueLayout$OfByte,java\/lang\/foreign\/ValueLayout$OfBoolean sealed true flags 21 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;)\n+innerclass innerClass java\/lang\/foreign\/MemoryLayout$PathElement outerClass java\/lang\/foreign\/MemoryLayout innerClassName PathElement flags 609\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfAddress outerClass java\/lang\/foreign\/ValueLayout innerClassName OfAddress flags 19\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfByte outerClass java\/lang\/foreign\/ValueLayout innerClassName OfByte flags 19\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfBoolean outerClass java\/lang\/foreign\/ValueLayout innerClassName OfBoolean flags 19\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfChar outerClass java\/lang\/foreign\/ValueLayout innerClassName OfChar flags 19\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfShort outerClass java\/lang\/foreign\/ValueLayout innerClassName OfShort flags 19\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfInt outerClass java\/lang\/foreign\/ValueLayout innerClassName OfInt flags 19\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfLong outerClass java\/lang\/foreign\/ValueLayout innerClassName OfLong flags 19\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfFloat outerClass java\/lang\/foreign\/ValueLayout innerClassName OfFloat flags 19\n+innerclass innerClass java\/lang\/foreign\/ValueLayout$OfDouble outerClass java\/lang\/foreign\/ValueLayout innerClassName OfDouble flags 19\n+\n+class name java\/lang\/invoke\/CallSite\n+header extends java\/lang\/Object sealed true flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/invoke\/LambdaMetafactory\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/invoke\/MethodHandle\n+header extends java\/lang\/Object implements java\/lang\/constant\/Constable sealed true flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+innerclass innerClass java\/lang\/constant\/DirectMethodHandleDesc$Kind outerClass java\/lang\/constant\/DirectMethodHandleDesc innerClassName Kind flags 4019\n+\n+class name java\/lang\/invoke\/MethodHandleProxies\n+header extends java\/lang\/Object flags 21 classAnnotations @Ljdk\/Profile+Annotation;(value=I1)\n+\n+class name java\/lang\/invoke\/StringConcatException\n+header extends java\/lang\/Exception flags 21\n+\n+class name java\/lang\/invoke\/VarHandle\n+header extends java\/lang\/Object implements java\/lang\/constant\/Constable nestMembers java\/lang\/invoke\/VarHandle$VarHandleDesc,java\/lang\/invoke\/VarHandle$AccessMode sealed true flags 421\n+innerclass innerClass java\/lang\/invoke\/VarHandle$AccessMode outerClass java\/lang\/invoke\/VarHandle innerClassName AccessMode flags 4019\n+innerclass innerClass java\/lang\/invoke\/VarHandle$VarHandleDesc outerClass java\/lang\/invoke\/VarHandle innerClassName VarHandleDesc flags 19\n+\n+class name java\/lang\/module\/Configuration\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/module\/FindException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/module\/InvalidModuleDescriptorException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/module\/ModuleDescriptor\n+header extends java\/lang\/Object implements java\/lang\/Comparable nestMembers java\/lang\/module\/ModuleDescriptor$Builder,java\/lang\/module\/ModuleDescriptor$Version,java\/lang\/module\/ModuleDescriptor$Provides,java\/lang\/module\/ModuleDescriptor$Opens,java\/lang\/module\/ModuleDescriptor$Opens$Modifier,java\/lang\/module\/ModuleDescriptor$Exports,java\/lang\/module\/ModuleDescriptor$Exports$Modifier,java\/lang\/module\/ModuleDescriptor$Requires,java\/lang\/module\/ModuleDescriptor$Requires$Modifier,java\/lang\/module\/ModuleDescriptor$Modifier flags 21 signature Ljava\/lang\/Object;Ljava\/lang\/Comparable<Ljava\/lang\/module\/ModuleDescriptor;>;\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Version outerClass java\/lang\/module\/ModuleDescriptor innerClassName Version flags 19\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Modifier outerClass java\/lang\/module\/ModuleDescriptor innerClassName Modifier flags 4019\n+innerclass innerClass java\/lang\/reflect\/AccessFlag$Location outerClass java\/lang\/reflect\/AccessFlag innerClassName Location flags 4019\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Builder outerClass java\/lang\/module\/ModuleDescriptor innerClassName Builder flags 19\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Provides outerClass java\/lang\/module\/ModuleDescriptor innerClassName Provides flags 19\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Opens outerClass java\/lang\/module\/ModuleDescriptor innerClassName Opens flags 19\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Exports outerClass java\/lang\/module\/ModuleDescriptor innerClassName Exports flags 19\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Requires outerClass java\/lang\/module\/ModuleDescriptor innerClassName Requires flags 19\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Opens$Modifier outerClass java\/lang\/module\/ModuleDescriptor$Opens innerClassName Modifier flags 4019\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Exports$Modifier outerClass java\/lang\/module\/ModuleDescriptor$Exports innerClassName Modifier flags 4019\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Requires$Modifier outerClass java\/lang\/module\/ModuleDescriptor$Requires innerClassName Modifier flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name accessFlags descriptor ()Ljava\/util\/Set; flags 1 signature ()Ljava\/util\/Set<Ljava\/lang\/reflect\/AccessFlag;>;\n+\n+class name java\/lang\/module\/ModuleDescriptor$Exports\n+header extends java\/lang\/Object implements java\/lang\/Comparable nestHost java\/lang\/module\/ModuleDescriptor flags 31 signature Ljava\/lang\/Object;Ljava\/lang\/Comparable<Ljava\/lang\/module\/ModuleDescriptor$Exports;>;\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Exports outerClass java\/lang\/module\/ModuleDescriptor innerClassName Exports flags 19\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Exports$Modifier outerClass java\/lang\/module\/ModuleDescriptor$Exports innerClassName Modifier flags 4019\n+innerclass innerClass java\/lang\/reflect\/AccessFlag$Location outerClass java\/lang\/reflect\/AccessFlag innerClassName Location flags 4019\n+method name accessFlags descriptor ()Ljava\/util\/Set; flags 1 signature ()Ljava\/util\/Set<Ljava\/lang\/reflect\/AccessFlag;>;\n+\n+class name java\/lang\/module\/ModuleDescriptor$Opens\n+header extends java\/lang\/Object implements java\/lang\/Comparable nestHost java\/lang\/module\/ModuleDescriptor flags 31 signature Ljava\/lang\/Object;Ljava\/lang\/Comparable<Ljava\/lang\/module\/ModuleDescriptor$Opens;>;\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Opens outerClass java\/lang\/module\/ModuleDescriptor innerClassName Opens flags 19\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Opens$Modifier outerClass java\/lang\/module\/ModuleDescriptor$Opens innerClassName Modifier flags 4019\n+innerclass innerClass java\/lang\/reflect\/AccessFlag$Location outerClass java\/lang\/reflect\/AccessFlag innerClassName Location flags 4019\n+method name accessFlags descriptor ()Ljava\/util\/Set; flags 1 signature ()Ljava\/util\/Set<Ljava\/lang\/reflect\/AccessFlag;>;\n+\n+class name java\/lang\/module\/ModuleDescriptor$Requires\n+header extends java\/lang\/Object implements java\/lang\/Comparable nestHost java\/lang\/module\/ModuleDescriptor flags 31 signature Ljava\/lang\/Object;Ljava\/lang\/Comparable<Ljava\/lang\/module\/ModuleDescriptor$Requires;>;\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Requires outerClass java\/lang\/module\/ModuleDescriptor innerClassName Requires flags 19\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Version outerClass java\/lang\/module\/ModuleDescriptor innerClassName Version flags 19\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Requires$Modifier outerClass java\/lang\/module\/ModuleDescriptor$Requires innerClassName Modifier flags 4019\n+innerclass innerClass java\/lang\/reflect\/AccessFlag$Location outerClass java\/lang\/reflect\/AccessFlag innerClassName Location flags 4019\n+method name accessFlags descriptor ()Ljava\/util\/Set; flags 1 signature ()Ljava\/util\/Set<Ljava\/lang\/reflect\/AccessFlag;>;\n+\n+class name java\/lang\/module\/ModuleReader\n+header extends java\/lang\/Object implements java\/io\/Closeable flags 601\n+\n+class name java\/lang\/module\/ModuleReference\n+header extends java\/lang\/Object flags 421\n+\n+class name java\/lang\/module\/ResolutionException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/module\/ResolvedModule\n+header extends java\/lang\/Object flags 31\n+\n+class name java\/lang\/ref\/Reference\n+header extends java\/lang\/Object sealed true flags 421 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;\n+\n+class name java\/lang\/reflect\/AccessFlag\n+header extends java\/lang\/Enum nestMembers java\/lang\/reflect\/AccessFlag$Location flags 4031 signature Ljava\/lang\/Enum<Ljava\/lang\/reflect\/AccessFlag;>;\n+innerclass innerClass java\/lang\/reflect\/AccessFlag$Location outerClass java\/lang\/reflect\/AccessFlag innerClassName Location flags 4019\n+field name PUBLIC descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name PRIVATE descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name PROTECTED descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name STATIC descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name FINAL descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name SUPER descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name OPEN descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name TRANSITIVE descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name SYNCHRONIZED descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name STATIC_PHASE descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name VOLATILE descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name BRIDGE descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name TRANSIENT descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name VARARGS descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name NATIVE descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name INTERFACE descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name ABSTRACT descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name STRICT descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name SYNTHETIC descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name ANNOTATION descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name ENUM descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name MANDATED descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+field name MODULE descriptor Ljava\/lang\/reflect\/AccessFlag; flags 4019\n+method name values descriptor ()[Ljava\/lang\/reflect\/AccessFlag; flags 9\n+method name valueOf descriptor (Ljava\/lang\/String;)Ljava\/lang\/reflect\/AccessFlag; flags 9\n+method name mask descriptor ()I flags 1\n+method name sourceModifier descriptor ()Z flags 1\n+method name locations descriptor ()Ljava\/util\/Set; flags 1 signature ()Ljava\/util\/Set<Ljava\/lang\/reflect\/AccessFlag$Location;>;\n+method name locations descriptor (Ljava\/lang\/reflect\/ClassFileFormatVersion;)Ljava\/util\/Set; flags 1 signature (Ljava\/lang\/reflect\/ClassFileFormatVersion;)Ljava\/util\/Set<Ljava\/lang\/reflect\/AccessFlag$Location;>;\n+method name maskToAccessFlags descriptor (ILjava\/lang\/reflect\/AccessFlag$Location;)Ljava\/util\/Set; flags 9 signature (ILjava\/lang\/reflect\/AccessFlag$Location;)Ljava\/util\/Set<Ljava\/lang\/reflect\/AccessFlag;>;\n+\n+class name java\/lang\/reflect\/AccessFlag$Location\n+header extends java\/lang\/Enum nestHost java\/lang\/reflect\/AccessFlag flags 4031 signature Ljava\/lang\/Enum<Ljava\/lang\/reflect\/AccessFlag$Location;>;\n+innerclass innerClass java\/lang\/reflect\/AccessFlag$Location outerClass java\/lang\/reflect\/AccessFlag innerClassName Location flags 4019\n+field name CLASS descriptor Ljava\/lang\/reflect\/AccessFlag$Location; flags 4019\n+field name FIELD descriptor Ljava\/lang\/reflect\/AccessFlag$Location; flags 4019\n+field name METHOD descriptor Ljava\/lang\/reflect\/AccessFlag$Location; flags 4019\n+field name INNER_CLASS descriptor Ljava\/lang\/reflect\/AccessFlag$Location; flags 4019\n+field name METHOD_PARAMETER descriptor Ljava\/lang\/reflect\/AccessFlag$Location; flags 4019\n+field name MODULE descriptor Ljava\/lang\/reflect\/AccessFlag$Location; flags 4019\n+field name MODULE_REQUIRES descriptor Ljava\/lang\/reflect\/AccessFlag$Location; flags 4019\n+field name MODULE_EXPORTS descriptor Ljava\/lang\/reflect\/AccessFlag$Location; flags 4019\n+field name MODULE_OPENS descriptor Ljava\/lang\/reflect\/AccessFlag$Location; flags 4019\n+method name values descriptor ()[Ljava\/lang\/reflect\/AccessFlag$Location; flags 9\n+method name valueOf descriptor (Ljava\/lang\/String;)Ljava\/lang\/reflect\/AccessFlag$Location; flags 9\n+\n+class name java\/lang\/reflect\/AccessibleObject\n+header extends java\/lang\/Object implements java\/lang\/reflect\/AnnotatedElement flags 21 classAnnotations @Ljdk\/Profile+Annotation;(value=I1)\n+\n+class name java\/lang\/reflect\/AnnotatedElement\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/reflect\/ClassFileFormatVersion\n+header extends java\/lang\/Enum flags 4031 signature Ljava\/lang\/Enum<Ljava\/lang\/reflect\/ClassFileFormatVersion;>;\n+innerclass innerClass java\/lang\/Runtime$Version outerClass java\/lang\/Runtime innerClassName Version flags 19\n+field name RELEASE_0 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+field name RELEASE_1 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+field name RELEASE_2 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+field name RELEASE_3 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+field name RELEASE_4 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+field name RELEASE_5 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+field name RELEASE_6 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+field name RELEASE_7 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+field name RELEASE_8 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+field name RELEASE_9 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+field name RELEASE_10 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+field name RELEASE_11 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+field name RELEASE_12 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+field name RELEASE_13 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+field name RELEASE_14 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+field name RELEASE_15 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+field name RELEASE_16 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+field name RELEASE_17 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+field name RELEASE_18 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+field name RELEASE_19 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+field name RELEASE_20 descriptor Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 4019\n+method name values descriptor ()[Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 9\n+method name valueOf descriptor (Ljava\/lang\/String;)Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 9\n+method name latest descriptor ()Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 9\n+method name major descriptor ()I flags 1\n+method name valueOf descriptor (Ljava\/lang\/Runtime$Version;)Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 9\n+method name runtimeVersion descriptor ()Ljava\/lang\/Runtime$Version; flags 1\n+method name fromMajor descriptor (I)Ljava\/lang\/reflect\/ClassFileFormatVersion; flags 9\n+\n+class name java\/lang\/reflect\/Executable\n+header extends java\/lang\/reflect\/AccessibleObject implements java\/lang\/reflect\/Member,java\/lang\/reflect\/GenericDeclaration sealed true flags 421\n+innerclass innerClass java\/lang\/reflect\/AccessFlag$Location outerClass java\/lang\/reflect\/AccessFlag innerClassName Location flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-method name getParameterCount descriptor ()I\n+method name accessFlags descriptor ()Ljava\/util\/Set; flags 1 signature ()Ljava\/util\/Set<Ljava\/lang\/reflect\/AccessFlag;>;\n+method name getParameterCount descriptor ()I flags 401\n+\n+class name java\/lang\/reflect\/Field\n+header extends java\/lang\/reflect\/AccessibleObject implements java\/lang\/reflect\/Member flags 31\n+innerclass innerClass java\/lang\/reflect\/AccessFlag$Location outerClass java\/lang\/reflect\/AccessFlag innerClassName Location flags 4019\n+method name accessFlags descriptor ()Ljava\/util\/Set; flags 1 signature ()Ljava\/util\/Set<Ljava\/lang\/reflect\/AccessFlag;>;\n+\n+class name java\/lang\/reflect\/InaccessibleObjectException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/reflect\/Member\n+method name accessFlags descriptor ()Ljava\/util\/Set; flags 1 signature ()Ljava\/util\/Set<Ljava\/lang\/reflect\/AccessFlag;>;\n+\n+class name java\/lang\/reflect\/Parameter\n+header extends java\/lang\/Object implements java\/lang\/reflect\/AnnotatedElement flags 31\n+innerclass innerClass java\/lang\/reflect\/AccessFlag$Location outerClass java\/lang\/reflect\/AccessFlag innerClassName Location flags 4019\n+method name accessFlags descriptor ()Ljava\/util\/Set; flags 1 signature ()Ljava\/util\/Set<Ljava\/lang\/reflect\/AccessFlag;>;\n+\n+class name java\/math\/BigDecimal\n+header extends java\/lang\/Number implements java\/lang\/Comparable flags 21 signature Ljava\/lang\/Number;Ljava\/lang\/Comparable<Ljava\/math\/BigDecimal;>;\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+\n+class name java\/net\/DatagramPacket\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/net\/DatagramSocket\n+header extends java\/lang\/Object implements java\/io\/Closeable flags 21 classAnnotations @Ljdk\/Profile+Annotation;(value=I1)\n+\n+class name java\/net\/InetAddress\n+header extends java\/lang\/Object implements java\/io\/Serializable sealed true flags 21\n+innerclass innerClass java\/net\/spi\/InetAddressResolver$LookupPolicy outerClass java\/net\/spi\/InetAddressResolver innerClassName LookupPolicy flags 19\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/net\/spi\/InetAddressResolverProvider$Configuration outerClass java\/net\/spi\/InetAddressResolverProvider innerClassName Configuration flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/net\/SocketImpl\n+header extends java\/lang\/Object implements java\/net\/SocketOptions flags 421\n+\n+class name java\/net\/URL\n+-method name <init> descriptor (Ljava\/lang\/String;Ljava\/lang\/String;ILjava\/lang\/String;)V\n+-method name <init> descriptor (Ljava\/lang\/String;Ljava\/lang\/String;Ljava\/lang\/String;)V\n+-method name <init> descriptor (Ljava\/lang\/String;Ljava\/lang\/String;ILjava\/lang\/String;Ljava\/net\/URLStreamHandler;)V\n+-method name <init> descriptor (Ljava\/lang\/String;)V\n+-method name <init> descriptor (Ljava\/net\/URL;Ljava\/lang\/String;)V\n+-method name <init> descriptor (Ljava\/net\/URL;Ljava\/lang\/String;Ljava\/net\/URLStreamHandler;)V\n+method name <init> descriptor (Ljava\/lang\/String;Ljava\/lang\/String;ILjava\/lang\/String;)V thrownTypes java\/net\/MalformedURLException flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"20\")\n+method name <init> descriptor (Ljava\/lang\/String;Ljava\/lang\/String;Ljava\/lang\/String;)V thrownTypes java\/net\/MalformedURLException flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"20\")\n+method name <init> descriptor (Ljava\/lang\/String;Ljava\/lang\/String;ILjava\/lang\/String;Ljava\/net\/URLStreamHandler;)V thrownTypes java\/net\/MalformedURLException flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"20\")\n+method name <init> descriptor (Ljava\/lang\/String;)V thrownTypes java\/net\/MalformedURLException flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"20\")\n+method name <init> descriptor (Ljava\/net\/URL;Ljava\/lang\/String;)V thrownTypes java\/net\/MalformedURLException flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"20\")\n+method name <init> descriptor (Ljava\/net\/URL;Ljava\/lang\/String;Ljava\/net\/URLStreamHandler;)V thrownTypes java\/net\/MalformedURLException flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"20\")\n+method name of descriptor (Ljava\/net\/URI;Ljava\/net\/URLStreamHandler;)Ljava\/net\/URL; thrownTypes java\/net\/MalformedURLException flags 9\n+\n+class name java\/net\/spi\/InetAddressResolverProvider$Configuration\n+header extends java\/lang\/Object nestHost java\/net\/spi\/InetAddressResolverProvider sealed true flags 601\n+innerclass innerClass java\/net\/spi\/InetAddressResolverProvider$Configuration outerClass java\/net\/spi\/InetAddressResolverProvider innerClassName Configuration flags 609\n+\n+class name java\/net\/spi\/URLStreamHandlerProvider\n+header extends java\/lang\/Object implements java\/net\/URLStreamHandlerFactory flags 421\n+\n+class name java\/nio\/Buffer\n+header extends java\/lang\/Object sealed true flags 421\n+\n+class name java\/nio\/ByteBuffer\n+header extends java\/nio\/Buffer implements java\/lang\/Comparable sealed true flags 421 signature Ljava\/nio\/Buffer;Ljava\/lang\/Comparable<Ljava\/nio\/ByteBuffer;>;\n+\n+class name java\/nio\/CharBuffer\n+header extends java\/nio\/Buffer implements java\/lang\/Comparable,java\/lang\/Appendable,java\/lang\/CharSequence,java\/lang\/Readable sealed true flags 421 signature Ljava\/nio\/Buffer;Ljava\/lang\/Comparable<Ljava\/nio\/CharBuffer;>;Ljava\/lang\/Appendable;Ljava\/lang\/CharSequence;Ljava\/lang\/Readable;\n+innerclass innerClass java\/util\/Spliterator$OfInt outerClass java\/util\/Spliterator innerClassName OfInt flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/nio\/DoubleBuffer\n+header extends java\/nio\/Buffer implements java\/lang\/Comparable sealed true flags 421 signature Ljava\/nio\/Buffer;Ljava\/lang\/Comparable<Ljava\/nio\/DoubleBuffer;>;\n+\n+class name java\/nio\/FloatBuffer\n+header extends java\/nio\/Buffer implements java\/lang\/Comparable sealed true flags 421 signature Ljava\/nio\/Buffer;Ljava\/lang\/Comparable<Ljava\/nio\/FloatBuffer;>;\n+\n+class name java\/nio\/IntBuffer\n+header extends java\/nio\/Buffer implements java\/lang\/Comparable sealed true flags 421 signature Ljava\/nio\/Buffer;Ljava\/lang\/Comparable<Ljava\/nio\/IntBuffer;>;\n+\n+class name java\/nio\/LongBuffer\n+header extends java\/nio\/Buffer implements java\/lang\/Comparable sealed true flags 421 signature Ljava\/nio\/Buffer;Ljava\/lang\/Comparable<Ljava\/nio\/LongBuffer;>;\n+\n+class name java\/nio\/MappedByteBuffer\n+header extends java\/nio\/ByteBuffer sealed true flags 421\n+\n+class name java\/nio\/ShortBuffer\n+header extends java\/nio\/Buffer implements java\/lang\/Comparable sealed true flags 421 signature Ljava\/nio\/Buffer;Ljava\/lang\/Comparable<Ljava\/nio\/ShortBuffer;>;\n+\n+class name java\/nio\/file\/Path\n+method name getExtension descriptor ()Ljava\/lang\/String; flags 1\n+\n+class name java\/nio\/file\/spi\/FileSystemProvider\n+method name exists descriptor (Ljava\/nio\/file\/Path;[Ljava\/nio\/file\/LinkOption;)Z flags 81\n+method name readAttributesIfExists descriptor (Ljava\/nio\/file\/Path;Ljava\/lang\/Class;[Ljava\/nio\/file\/LinkOption;)Ljava\/nio\/file\/attribute\/BasicFileAttributes; thrownTypes java\/io\/IOException flags 81 signature <A::Ljava\/nio\/file\/attribute\/BasicFileAttributes;>(Ljava\/nio\/file\/Path;Ljava\/lang\/Class<TA;>;[Ljava\/nio\/file\/LinkOption;)TA;\n+\n+class name java\/security\/Certificate\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"1.2\")\n+\n+class name java\/security\/Identity\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 421 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"1.2\")\n+\n+class name java\/security\/InvalidParameterException\n+method name <init> descriptor (Ljava\/lang\/String;Ljava\/lang\/Throwable;)V flags 1\n+method name <init> descriptor (Ljava\/lang\/Throwable;)V flags 1\n+\n+class name java\/security\/KeyStore\n+header extends java\/lang\/Object nestMembers java\/security\/KeyStore$Builder,java\/security\/KeyStore$TrustedCertificateEntry,java\/security\/KeyStore$SecretKeyEntry,java\/security\/KeyStore$PrivateKeyEntry,java\/security\/KeyStore$Entry,java\/security\/KeyStore$Entry$Attribute,java\/security\/KeyStore$CallbackHandlerProtection,java\/security\/KeyStore$PasswordProtection,java\/security\/KeyStore$ProtectionParameter,java\/security\/KeyStore$LoadStoreParameter flags 21\n+innerclass innerClass java\/security\/KeyStore$LoadStoreParameter outerClass java\/security\/KeyStore innerClassName LoadStoreParameter flags 609\n+innerclass innerClass java\/security\/KeyStore$ProtectionParameter outerClass java\/security\/KeyStore innerClassName ProtectionParameter flags 609\n+innerclass innerClass java\/security\/KeyStore$Entry outerClass java\/security\/KeyStore innerClassName Entry flags 609\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+innerclass innerClass java\/security\/KeyStore$Builder outerClass java\/security\/KeyStore innerClassName Builder flags 409\n+innerclass innerClass java\/security\/KeyStore$TrustedCertificateEntry outerClass java\/security\/KeyStore innerClassName TrustedCertificateEntry flags 19\n+innerclass innerClass java\/security\/KeyStore$SecretKeyEntry outerClass java\/security\/KeyStore innerClassName SecretKeyEntry flags 19\n+innerclass innerClass java\/security\/KeyStore$PrivateKeyEntry outerClass java\/security\/KeyStore innerClassName PrivateKeyEntry flags 19\n+innerclass innerClass java\/security\/KeyStore$CallbackHandlerProtection outerClass java\/security\/KeyStore innerClassName CallbackHandlerProtection flags 9\n+innerclass innerClass java\/security\/KeyStore$PasswordProtection outerClass java\/security\/KeyStore innerClassName PasswordProtection flags 9\n+innerclass innerClass java\/security\/KeyStore$Entry$Attribute outerClass java\/security\/KeyStore$Entry innerClassName Attribute flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/security\/ProtectionDomain\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/security\/Provider\n+header extends java\/util\/Properties nestMembers java\/security\/Provider$Service flags 421\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/security\/SecureRandom\n+header extends java\/util\/Random flags 21 runtimeAnnotations @Ljdk\/internal\/util\/random\/RandomSupport$RandomGeneratorProperties;(name=\"SecureRandom\",isStochastic=Ztrue)\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/security\/SecureRandomParameters\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/security\/Security\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/security\/SignedObject\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+\n+class name java\/security\/cert\/CertPathBuilder\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/security\/cert\/CertPathValidator\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/security\/cert\/CertStore\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-method name getDefaultType descriptor ()Ljava\/lang\/String;\n+method name getDefaultType descriptor ()Ljava\/lang\/String; flags 9\n+\n+class name java\/security\/cert\/CertificateRevokedException\n+header extends java\/security\/cert\/CertificateException flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+\n+class name java\/security\/cert\/URICertStoreParameters\n+header extends java\/lang\/Object implements java\/security\/cert\/CertStoreParameters flags 31\n+\n+class name java\/security\/interfaces\/DSAKeyPairGenerator\n+-method name initialize descriptor (Ljava\/security\/interfaces\/DSAParams;Ljava\/security\/SecureRandom;)V\n+-method name initialize descriptor (IZLjava\/security\/SecureRandom;)V\n+method name initialize descriptor (Ljava\/security\/interfaces\/DSAParams;Ljava\/security\/SecureRandom;)V flags 401\n+method name initialize descriptor (IZLjava\/security\/SecureRandom;)V flags 401\n+\n+class name java\/security\/interfaces\/RSAKey\n+-method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec;\n+method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec; flags 1\n+\n+class name java\/security\/spec\/EncodedKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/security\/spec\/MGF1ParameterSpec\n+-field name SHA512_224 descriptor Ljava\/security\/spec\/MGF1ParameterSpec;\n+-field name SHA512_256 descriptor Ljava\/security\/spec\/MGF1ParameterSpec;\n+field name SHA512_224 descriptor Ljava\/security\/spec\/MGF1ParameterSpec; flags 19\n+field name SHA512_256 descriptor Ljava\/security\/spec\/MGF1ParameterSpec; flags 19\n+\n+class name java\/security\/spec\/PSSParameterSpec\n+-field name TRAILER_FIELD_BC descriptor I\n+-method name toString descriptor ()Ljava\/lang\/String;\n+field name TRAILER_FIELD_BC descriptor I constantValue 1 flags 19\n+method name toString descriptor ()Ljava\/lang\/String; flags 1\n+\n+class name java\/security\/spec\/RSAKeyGenParameterSpec\n+-method name <init> descriptor (ILjava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V\n+-method name getKeyParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec;\n+method name <init> descriptor (ILjava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V flags 1\n+method name getKeyParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec; flags 1\n+\n+class name java\/security\/spec\/RSAMultiPrimePrivateCrtKeySpec\n+-method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;[Ljava\/security\/spec\/RSAOtherPrimeInfo;Ljava\/security\/spec\/AlgorithmParameterSpec;)V\n+method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;[Ljava\/security\/spec\/RSAOtherPrimeInfo;Ljava\/security\/spec\/AlgorithmParameterSpec;)V flags 1\n+\n+class name java\/security\/spec\/RSAPrivateCrtKeySpec\n+-method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V\n+method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V flags 1\n+\n+class name java\/security\/spec\/RSAPrivateKeySpec\n+-method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V\n+-method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec;\n+method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V flags 1\n+method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec; flags 1\n+\n+class name java\/security\/spec\/RSAPublicKeySpec\n+-method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V\n+-method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec;\n+method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V flags 1\n+method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec; flags 1\n+\n+class name java\/text\/DateFormatSymbols\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/util\/Locale$Category outerClass java\/util\/Locale innerClassName Category flags 4019\n+\n+class name java\/text\/RuleBasedCollator\n+header extends java\/text\/Collator flags 21\n+innerclass innerClass java\/text\/Normalizer$Form outerClass java\/text\/Normalizer innerClassName Form flags 4019\n+\n+class name java\/time\/ZoneId\n+header extends java\/lang\/Object implements java\/io\/Serializable sealed true flags 421 runtimeAnnotations @Ljdk\/internal\/ValueBased;\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+\n+class name java\/time\/ZoneOffset\n+header extends java\/time\/ZoneId implements java\/time\/temporal\/TemporalAccessor,java\/time\/temporal\/TemporalAdjuster,java\/lang\/Comparable,java\/io\/Serializable flags 31 signature Ljava\/time\/ZoneId;Ljava\/time\/temporal\/TemporalAccessor;Ljava\/time\/temporal\/TemporalAdjuster;Ljava\/lang\/Comparable<Ljava\/time\/ZoneOffset;>;Ljava\/io\/Serializable; runtimeAnnotations @Ljdk\/internal\/ValueBased;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/time\/chrono\/ChronoLocalDate\n+header extends java\/lang\/Object implements java\/time\/temporal\/Temporal,java\/time\/temporal\/TemporalAdjuster,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Ljava\/time\/temporal\/Temporal;Ljava\/time\/temporal\/TemporalAdjuster;Ljava\/lang\/Comparable<Ljava\/time\/chrono\/ChronoLocalDate;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/time\/chrono\/ChronoLocalDateTime\n+header extends java\/lang\/Object implements java\/time\/temporal\/Temporal,java\/time\/temporal\/TemporalAdjuster,java\/lang\/Comparable flags 601 signature <D::Ljava\/time\/chrono\/ChronoLocalDate;>Ljava\/lang\/Object;Ljava\/time\/temporal\/Temporal;Ljava\/time\/temporal\/TemporalAdjuster;Ljava\/lang\/Comparable<Ljava\/time\/chrono\/ChronoLocalDateTime<*>;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/time\/format\/DecimalStyle\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/util\/Locale$Category outerClass java\/util\/Locale innerClassName Category flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/time\/temporal\/TemporalAdjusters\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/Comparator\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/DoubleSummaryStatistics\n+header extends java\/lang\/Object implements java\/util\/function\/DoubleConsumer flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/EnumSet\n+header extends java\/util\/AbstractSet implements java\/lang\/Cloneable,java\/io\/Serializable sealed true flags 421 signature <E:Ljava\/lang\/Enum<TE;>;>Ljava\/util\/AbstractSet<TE;>;Ljava\/lang\/Cloneable;Ljava\/io\/Serializable;\n+\n+class name java\/util\/GregorianCalendar\n+header extends java\/util\/Calendar flags 21\n+innerclass innerClass java\/util\/Locale$Category outerClass java\/util\/Locale innerClassName Category flags 4019\n+\n+class name java\/util\/IdentityHashMap\n+method name remove descriptor (Ljava\/lang\/Object;Ljava\/lang\/Object;)Z flags 1\n+method name replace descriptor (Ljava\/lang\/Object;Ljava\/lang\/Object;Ljava\/lang\/Object;)Z flags 1 signature (TK;TV;TV;)Z\n+\n+class name java\/util\/IllegalFormatException\n+header extends java\/lang\/IllegalArgumentException sealed true flags 21\n+\n+class name java\/util\/Locale$IsoCountryCode\n+header extends java\/lang\/Enum nestHost java\/util\/Locale sealed true flags 4421 signature Ljava\/lang\/Enum<Ljava\/util\/Locale$IsoCountryCode;>;\n+innerclass innerClass java\/util\/Locale$IsoCountryCode outerClass java\/util\/Locale innerClassName IsoCountryCode flags 4409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/Observable\n+header extends java\/lang\/Object flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"9\")\n+\n+class name java\/util\/Observer\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"9\")\n+\n+class name java\/util\/TimeZone\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/util\/Locale$Category outerClass java\/util\/Locale innerClassName Category flags 4019\n+\n+class name java\/util\/TreeSet\n+header extends java\/util\/AbstractSet implements java\/util\/NavigableSet,java\/lang\/Cloneable,java\/io\/Serializable flags 21 signature <E:Ljava\/lang\/Object;>Ljava\/util\/AbstractSet<TE;>;Ljava\/util\/NavigableSet<TE;>;Ljava\/lang\/Cloneable;Ljava\/io\/Serializable;\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+\n+class name java\/util\/concurrent\/ConcurrentHashMap$CollectionView\n+header extends java\/lang\/Object implements java\/util\/Collection,java\/io\/Serializable nestHost java\/util\/concurrent\/ConcurrentHashMap sealed true flags 420 signature <K:Ljava\/lang\/Object;V:Ljava\/lang\/Object;E:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/util\/Collection<TE;>;Ljava\/io\/Serializable;\n+innerclass innerClass java\/util\/concurrent\/ConcurrentHashMap$CollectionView outerClass java\/util\/concurrent\/ConcurrentHashMap innerClassName CollectionView flags 408\n+innerclass innerClass java\/util\/concurrent\/ConcurrentHashMap$KeySetView outerClass java\/util\/concurrent\/ConcurrentHashMap innerClassName KeySetView flags 19\n+\n+class name java\/util\/concurrent\/ConcurrentMap\n+header extends java\/lang\/Object implements java\/util\/Map flags 601 signature <K:Ljava\/lang\/Object;V:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/util\/Map<TK;TV;>;\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/ConcurrentSkipListSet\n+header extends java\/util\/AbstractSet implements java\/util\/NavigableSet,java\/lang\/Cloneable,java\/io\/Serializable flags 21 signature <E:Ljava\/lang\/Object;>Ljava\/util\/AbstractSet<TE;>;Ljava\/util\/NavigableSet<TE;>;Ljava\/lang\/Cloneable;Ljava\/io\/Serializable;\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/CountedCompleter\n+header extends java\/util\/concurrent\/ForkJoinTask flags 421 signature <T:Ljava\/lang\/Object;>Ljava\/util\/concurrent\/ForkJoinTask<TT;>; classAnnotations @Ljdk\/Profile+Annotation;(value=I1)\n+\n+class name java\/util\/concurrent\/atomic\/AtomicBoolean\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/atomic\/AtomicReference\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21 signature <V:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/io\/Serializable;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/atomic\/AtomicReferenceArray\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21 signature <E:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/io\/Serializable;\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/locks\/StampedLock\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21 classAnnotations @Ljdk\/Profile+Annotation;(value=I1)\n+-method name tryWriteLock descriptor ()J\n+-method name writeLockInterruptibly descriptor ()J\n+-method name tryReadLock descriptor ()J\n+-method name tryReadLock descriptor (JLjava\/util\/concurrent\/TimeUnit;)J\n+-method name readLockInterruptibly descriptor ()J\n+-method name unlock descriptor (J)V\n+method name tryWriteLock descriptor ()J flags 1\n+method name writeLockInterruptibly descriptor ()J thrownTypes java\/lang\/InterruptedException flags 1\n+method name tryReadLock descriptor ()J flags 1\n+method name tryReadLock descriptor (JLjava\/util\/concurrent\/TimeUnit;)J thrownTypes java\/lang\/InterruptedException flags 1\n+method name readLockInterruptibly descriptor ()J thrownTypes java\/lang\/InterruptedException flags 1\n+method name unlock descriptor (J)V flags 1\n+\n+class name java\/util\/function\/BiConsumer\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;U:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/BiFunction\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;U:Ljava\/lang\/Object;R:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/BiPredicate\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;U:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/BinaryOperator\n+header extends java\/lang\/Object implements java\/util\/function\/BiFunction flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/util\/function\/BiFunction<TT;TT;TT;>; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/Consumer\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/DoubleConsumer\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/DoublePredicate\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/DoubleUnaryOperator\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/Function\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;R:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/IntConsumer\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/IntPredicate\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/IntUnaryOperator\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/LongConsumer\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/LongPredicate\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/LongUnaryOperator\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/Predicate\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/UnaryOperator\n+header extends java\/lang\/Object implements java\/util\/function\/Function flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/util\/function\/Function<TT;TT;>; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/regex\/MatchResult\n+method name start descriptor (Ljava\/lang\/String;)I flags 1\n+method name end descriptor (Ljava\/lang\/String;)I flags 1\n+method name group descriptor (Ljava\/lang\/String;)Ljava\/lang\/String; flags 1\n+method name namedGroups descriptor ()Ljava\/util\/Map; flags 1 signature ()Ljava\/util\/Map<Ljava\/lang\/String;Ljava\/lang\/Integer;>;\n+method name hasMatch descriptor ()Z flags 1\n+\n+class name java\/util\/regex\/Matcher\n+method name namedGroups descriptor ()Ljava\/util\/Map; flags 1 signature ()Ljava\/util\/Map<Ljava\/lang\/String;Ljava\/lang\/Integer;>;\n+method name hasMatch descriptor ()Z flags 1\n+\n+class name java\/util\/regex\/Pattern\n+method name namedGroups descriptor ()Ljava\/util\/Map; flags 1 signature ()Ljava\/util\/Map<Ljava\/lang\/String;Ljava\/lang\/Integer;>;\n+\n+class name java\/util\/spi\/AbstractResourceBundleProvider\n+header extends java\/lang\/Object implements java\/util\/spi\/ResourceBundleProvider flags 421\n+innerclass innerClass java\/util\/ResourceBundle$Control outerClass java\/util\/ResourceBundle innerClassName Control flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/spi\/CurrencyNameProvider\n+header extends java\/util\/spi\/LocaleServiceProvider flags 421\n+innerclass innerClass java\/util\/ResourceBundle$Control outerClass java\/util\/ResourceBundle innerClassName Control flags 9\n+\n+class name java\/util\/spi\/ResourceBundleProvider\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/util\/spi\/ToolProvider\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/zip\/CRC32C\n+header extends java\/lang\/Object implements java\/util\/zip\/Checksum flags 31\n+\n+class name java\/util\/zip\/ZipInputStream\n+method name read descriptor ()I thrownTypes java\/io\/IOException flags 1\n+method name readAllBytes descriptor ()[B thrownTypes java\/io\/IOException flags 1\n+method name readNBytes descriptor (I)[B thrownTypes java\/io\/IOException flags 1\n+method name readNBytes descriptor ([BII)I thrownTypes java\/io\/IOException flags 1\n+method name skipNBytes descriptor (J)V thrownTypes java\/io\/IOException flags 1\n+method name transferTo descriptor (Ljava\/io\/OutputStream;)J thrownTypes java\/io\/IOException flags 1\n+\n+class name javax\/crypto\/AEADBadTagException\n+header extends javax\/crypto\/BadPaddingException flags 21\n+\n+class name javax\/crypto\/BadPaddingException\n+header extends java\/security\/GeneralSecurityException flags 21\n+\n+class name javax\/crypto\/CipherInputStream\n+header extends java\/io\/FilterInputStream flags 21\n+\n+class name javax\/crypto\/CipherOutputStream\n+header extends java\/io\/FilterOutputStream flags 21\n+\n+class name javax\/crypto\/CipherSpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/EncryptedPrivateKeyInfo\n+header extends java\/lang\/Object flags 21\n+\n+class name javax\/crypto\/ExemptionMechanism\n+header extends java\/lang\/Object flags 21\n+\n+class name javax\/crypto\/ExemptionMechanismException\n+header extends java\/security\/GeneralSecurityException flags 21\n+\n+class name javax\/crypto\/ExemptionMechanismSpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/IllegalBlockSizeException\n+header extends java\/security\/GeneralSecurityException flags 21\n+\n+class name javax\/crypto\/KeyAgreement\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+\n+class name javax\/crypto\/KeyAgreementSpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/KeyGenerator\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+\n+class name javax\/crypto\/KeyGeneratorSpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/Mac\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+\n+class name javax\/crypto\/MacSpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/NoSuchPaddingException\n+header extends java\/security\/GeneralSecurityException flags 21\n+\n+class name javax\/crypto\/NullCipher\n+header extends javax\/crypto\/Cipher flags 21\n+\n+class name javax\/crypto\/SealedObject\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/crypto\/SecretKey\n+header extends java\/lang\/Object implements java\/security\/Key,javax\/security\/auth\/Destroyable flags 601\n+\n+class name javax\/crypto\/SecretKeyFactory\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+\n+class name javax\/crypto\/SecretKeyFactorySpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/ShortBufferException\n+header extends java\/security\/GeneralSecurityException flags 21\n+\n+class name javax\/crypto\/interfaces\/DHKey\n+header extends java\/lang\/Object flags 601\n+\n+class name javax\/crypto\/interfaces\/DHPrivateKey\n+header extends java\/lang\/Object implements javax\/crypto\/interfaces\/DHKey,java\/security\/PrivateKey flags 601\n+\n+class name javax\/crypto\/interfaces\/DHPublicKey\n+header extends java\/lang\/Object implements javax\/crypto\/interfaces\/DHKey,java\/security\/PublicKey flags 601\n+\n+class name javax\/crypto\/interfaces\/PBEKey\n+header extends java\/lang\/Object implements javax\/crypto\/SecretKey flags 601\n+\n+class name javax\/crypto\/spec\/DESKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec flags 21\n+\n+class name javax\/crypto\/spec\/DESedeKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec flags 21\n+\n+class name javax\/crypto\/spec\/DHGenParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/DHParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/DHPrivateKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec flags 21\n+\n+class name javax\/crypto\/spec\/DHPublicKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec flags 21\n+\n+class name javax\/crypto\/spec\/GCMParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/IvParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/OAEPParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+innerclass innerClass javax\/crypto\/spec\/PSource$PSpecified outerClass javax\/crypto\/spec\/PSource innerClassName PSpecified flags 19\n+\n+class name javax\/crypto\/spec\/PBEKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec flags 21\n+-method name clearPassword descriptor ()V\n+-method name getPassword descriptor ()[C\n+method name clearPassword descriptor ()V flags 31\n+method name getPassword descriptor ()[C flags 31\n+\n+class name javax\/crypto\/spec\/PBEParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/RC2ParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/RC5ParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name jdk\/internal\/event\/Event\n+header extends java\/lang\/Object flags 421\n+-method name <init> descriptor ()V\n+-method name begin descriptor ()V\n+-method name end descriptor ()V\n+-method name commit descriptor ()V\n+-method name isEnabled descriptor ()Z\n+-method name shouldCommit descriptor ()Z\n+-method name set descriptor (ILjava\/lang\/Object;)V\n+method name <init> descriptor ()V flags 4\n+method name begin descriptor ()V flags 1\n+method name end descriptor ()V flags 1\n+method name commit descriptor ()V flags 1\n+method name isEnabled descriptor ()Z flags 1\n+method name shouldCommit descriptor ()Z flags 1\n+method name set descriptor (ILjava\/lang\/Object;)V flags 1\n+\n+class name jdk\/internal\/vm\/vector\/VectorSupport\n+-method name indexVector descriptor (Ljava\/lang\/Class;Ljava\/lang\/Class;ILjdk\/internal\/vm\/vector\/VectorSupport$Vector;ILjdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies;Ljdk\/internal\/vm\/vector\/VectorSupport$IndexOperation;)Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\n+method name indexVector descriptor (Ljava\/lang\/Class;Ljava\/lang\/Class;ILjdk\/internal\/vm\/vector\/VectorSupport$Vector;ILjdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies;Ljdk\/internal\/vm\/vector\/VectorSupport$IndexOperation;)Ljdk\/internal\/vm\/vector\/VectorSupport$Vector; flags 9 signature <V:Ljdk\/internal\/vm\/vector\/VectorSupport$Vector<TE;>;E:Ljava\/lang\/Object;S:Ljdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies<TE;>;>(Ljava\/lang\/Class<+TV;>;Ljava\/lang\/Class<TE;>;ITV;ITS;Ljdk\/internal\/vm\/vector\/VectorSupport$IndexOperation<TV;TS;>;)TV; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.base-K.sym.txt","additions":1016,"deletions":0,"binary":false,"changes":1016,"status":"added"},{"patch":"@@ -0,0 +1,116 @@\n+#\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/annotation\/processing\/AbstractProcessor\n+header extends java\/lang\/Object implements javax\/annotation\/processing\/Processor flags 421\n+innerclass innerClass javax\/tools\/Diagnostic$Kind outerClass javax\/tools\/Diagnostic innerClassName Kind flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/annotation\/processing\/Generated\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Documented;@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;SOURCE;)@Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;PACKAGE;eLjava\/lang\/annotation\/ElementType;TYPE;eLjava\/lang\/annotation\/ElementType;METHOD;eLjava\/lang\/annotation\/ElementType;CONSTRUCTOR;eLjava\/lang\/annotation\/ElementType;FIELD;eLjava\/lang\/annotation\/ElementType;LOCAL_VARIABLE;eLjava\/lang\/annotation\/ElementType;PARAMETER;})\n+\n+class name javax\/lang\/model\/SourceVersion\n+field name RELEASE_20 descriptor Ljavax\/lang\/model\/SourceVersion; flags 4019\n+\n+class name javax\/lang\/model\/element\/Modifier\n+header extends java\/lang\/Enum sealed true flags 4021 signature Ljava\/lang\/Enum<Ljavax\/lang\/model\/element\/Modifier;>;\n+\n+class name javax\/lang\/model\/element\/UnknownAnnotationValueException\n+header extends javax\/lang\/model\/UnknownEntityException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/element\/UnknownDirectiveException\n+header extends javax\/lang\/model\/UnknownEntityException flags 21\n+innerclass innerClass javax\/lang\/model\/element\/ModuleElement$Directive outerClass javax\/lang\/model\/element\/ModuleElement innerClassName Directive flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/element\/UnknownElementException\n+header extends javax\/lang\/model\/UnknownEntityException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/type\/MirroredTypeException\n+header extends javax\/lang\/model\/type\/MirroredTypesException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/type\/MirroredTypesException\n+header extends java\/lang\/RuntimeException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/type\/UnknownTypeException\n+header extends javax\/lang\/model\/UnknownEntityException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/util\/AbstractAnnotationValueVisitor14\n+header extends javax\/lang\/model\/util\/AbstractAnnotationValueVisitor9 flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/AbstractAnnotationValueVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_20;)\n+\n+class name javax\/lang\/model\/util\/AbstractElementVisitor14\n+header extends javax\/lang\/model\/util\/AbstractElementVisitor9 flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/AbstractElementVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_20;)\n+\n+class name javax\/lang\/model\/util\/AbstractTypeVisitor14\n+header extends javax\/lang\/model\/util\/AbstractTypeVisitor9 flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/AbstractTypeVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_20;)\n+\n+class name javax\/lang\/model\/util\/AbstractTypeVisitor6\n+header extends java\/lang\/Object implements javax\/lang\/model\/type\/TypeVisitor flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljavax\/lang\/model\/type\/TypeVisitor<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_6;)\n+\n+class name javax\/lang\/model\/util\/AbstractTypeVisitor7\n+header extends javax\/lang\/model\/util\/AbstractTypeVisitor6 flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/AbstractTypeVisitor6<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_7;)\n+\n+class name javax\/lang\/model\/util\/AbstractTypeVisitor8\n+header extends javax\/lang\/model\/util\/AbstractTypeVisitor7 flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/AbstractTypeVisitor7<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_8;)\n+\n+class name javax\/lang\/model\/util\/ElementKindVisitor14\n+header extends javax\/lang\/model\/util\/ElementKindVisitor9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/ElementKindVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_20;)\n+\n+class name javax\/lang\/model\/util\/ElementScanner14\n+header extends javax\/lang\/model\/util\/ElementScanner9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/ElementScanner9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_20;)\n+\n+class name javax\/lang\/model\/util\/Elements\n+method name isCanonicalConstructor descriptor (Ljavax\/lang\/model\/element\/ExecutableElement;)Z flags 1\n+method name isCompactConstructor descriptor (Ljavax\/lang\/model\/element\/ExecutableElement;)Z flags 1\n+\n+class name javax\/lang\/model\/util\/SimpleAnnotationValueVisitor14\n+header extends javax\/lang\/model\/util\/SimpleAnnotationValueVisitor9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/SimpleAnnotationValueVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_20;)\n+\n+class name javax\/lang\/model\/util\/SimpleElementVisitor14\n+header extends javax\/lang\/model\/util\/SimpleElementVisitor9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/SimpleElementVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_20;)\n+\n+class name javax\/lang\/model\/util\/SimpleTypeVisitor14\n+header extends javax\/lang\/model\/util\/SimpleTypeVisitor9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/SimpleTypeVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_20;)\n+\n+class name javax\/lang\/model\/util\/TypeKindVisitor14\n+header extends javax\/lang\/model\/util\/TypeKindVisitor9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/TypeKindVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_20;)\n+\n+class name javax\/tools\/SimpleJavaFileObject\n+header extends java\/lang\/Object implements javax\/tools\/JavaFileObject flags 21\n+innerclass innerClass javax\/tools\/JavaFileObject$Kind outerClass javax\/tools\/JavaFileObject innerClassName Kind flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/tools\/ToolProvider\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.compiler-K.sym.txt","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.datatransfer-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/java.datatransfer-J.sym.txt","status":"copied"},{"patch":"@@ -0,0 +1,871 @@\n+#\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name java\/awt\/AWTKeyStroke\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/AttributeValue\n+header extends java\/lang\/Object flags 420\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/BorderLayout\n+header extends java\/lang\/Object implements java\/awt\/LayoutManager2,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/CheckboxGroup\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Color\n+header extends java\/lang\/Object implements java\/awt\/Paint,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/ContainerOrderFocusTraversalPolicy\n+header extends java\/awt\/FocusTraversalPolicy implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Dimension\n+header extends java\/awt\/geom\/Dimension2D implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/DisplayMode\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Event\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"9\")\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/FlowLayout\n+header extends java\/lang\/Object implements java\/awt\/LayoutManager,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/FontMetrics\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Graphics\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/GridLayout\n+header extends java\/lang\/Object implements java\/awt\/LayoutManager,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/HeadlessException\n+header extends java\/lang\/UnsupportedOperationException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Insets\n+header extends java\/lang\/Object implements java\/lang\/Cloneable,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/MenuShortcut\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/MultipleGradientPaint\n+header extends java\/lang\/Object implements java\/awt\/Paint nestMembers java\/awt\/MultipleGradientPaint$ColorSpaceType,java\/awt\/MultipleGradientPaint$CycleMethod sealed true flags 421\n+innerclass innerClass java\/awt\/MultipleGradientPaint$ColorSpaceType outerClass java\/awt\/MultipleGradientPaint innerClassName ColorSpaceType flags 4019\n+innerclass innerClass java\/awt\/MultipleGradientPaint$CycleMethod outerClass java\/awt\/MultipleGradientPaint innerClassName CycleMethod flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Point\n+header extends java\/awt\/geom\/Point2D implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Rectangle\n+header extends java\/awt\/geom\/Rectangle2D implements java\/awt\/Shape,java\/io\/Serializable flags 21\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Double outerClass java\/awt\/geom\/Rectangle2D innerClassName Double flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/SystemColor\n+header extends java\/awt\/Color implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/TextComponent\n+header extends java\/awt\/Component implements javax\/accessibility\/Accessible nestMembers java\/awt\/TextComponent$AccessibleAWTTextComponent sealed true flags 21\n+innerclass innerClass java\/awt\/TextComponent$AccessibleAWTTextComponent outerClass java\/awt\/TextComponent innerClassName AccessibleAWTTextComponent flags 4\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/TexturePaint\n+header extends java\/lang\/Object implements java\/awt\/Paint flags 21\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Double outerClass java\/awt\/geom\/Rectangle2D innerClassName Double flags 9\n+\n+class name java\/awt\/color\/ColorSpace\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/color\/ICC_ColorSpace\n+header extends java\/awt\/color\/ColorSpace flags 21 classAnnotations @Ljdk\/Profile+Annotation;(value=I4)\n+\n+class name java\/awt\/color\/ICC_Profile\n+header extends java\/lang\/Object implements java\/io\/Serializable sealed true flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/desktop\/AboutEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/AboutHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/AppEvent\n+header extends java\/util\/EventObject sealed true flags 21\n+\n+class name java\/awt\/desktop\/AppForegroundEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/AppForegroundListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/desktop\/AppHiddenEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/AppHiddenListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/desktop\/AppReopenedEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/AppReopenedListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/desktop\/FilesEvent\n+header extends java\/awt\/desktop\/AppEvent sealed true flags 21\n+\n+class name java\/awt\/desktop\/OpenFilesEvent\n+header extends java\/awt\/desktop\/FilesEvent flags 31\n+\n+class name java\/awt\/desktop\/OpenFilesHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/OpenURIEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/OpenURIHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/PreferencesEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/PreferencesHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/PrintFilesEvent\n+header extends java\/awt\/desktop\/FilesEvent flags 31\n+\n+class name java\/awt\/desktop\/PrintFilesHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/QuitEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/QuitHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/QuitResponse\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/QuitStrategy\n+header extends java\/lang\/Enum flags 4031 signature Ljava\/lang\/Enum<Ljava\/awt\/desktop\/QuitStrategy;>;\n+\n+class name java\/awt\/desktop\/ScreenSleepEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/ScreenSleepListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/desktop\/SystemEventListener\n+header extends java\/lang\/Object implements java\/util\/EventListener flags 601\n+\n+class name java\/awt\/desktop\/SystemSleepEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/SystemSleepListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/desktop\/UserSessionListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/dnd\/DragGestureEvent\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+\n+class name java\/awt\/dnd\/DragGestureRecognizer\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 421\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+\n+class name java\/awt\/dnd\/DragSource\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/dnd\/DropTargetDragEvent\n+header extends java\/awt\/dnd\/DropTargetEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/dnd\/DropTargetDropEvent\n+header extends java\/awt\/dnd\/DropTargetEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/ActionEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/AdjustmentEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/ComponentEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/ContainerEvent\n+header extends java\/awt\/event\/ComponentEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/HierarchyEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/InputEvent\n+header extends java\/awt\/event\/ComponentEvent sealed true flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/InputMethodEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/ItemEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/MouseWheelEvent\n+header extends java\/awt\/event\/MouseEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/PaintEvent\n+header extends java\/awt\/event\/ComponentEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/WindowEvent\n+header extends java\/awt\/event\/ComponentEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/font\/FontRenderContext\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/awt\/RenderingHints$Key outerClass java\/awt\/RenderingHints innerClassName Key flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/font\/GraphicAttribute\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Float outerClass java\/awt\/geom\/Rectangle2D innerClassName Float flags 9\n+\n+class name java\/awt\/font\/ImageGraphicAttribute\n+header extends java\/awt\/font\/GraphicAttribute flags 31\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Float outerClass java\/awt\/geom\/Rectangle2D innerClassName Float flags 9\n+\n+class name java\/awt\/font\/NumericShaper$Range\n+header extends java\/lang\/Enum nestHost java\/awt\/font\/NumericShaper sealed true flags 4021 signature Ljava\/lang\/Enum<Ljava\/awt\/font\/NumericShaper$Range;>;\n+innerclass innerClass java\/awt\/font\/NumericShaper$Range outerClass java\/awt\/font\/NumericShaper innerClassName Range flags 4009\n+\n+class name java\/awt\/font\/ShapeGraphicAttribute\n+header extends java\/awt\/font\/GraphicAttribute flags 31\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Float outerClass java\/awt\/geom\/Rectangle2D innerClassName Float flags 9\n+\n+class name java\/awt\/font\/TextHitInfo\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/font\/TextMeasurer\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 31\n+innerclass innerClass java\/text\/AttributedCharacterIterator$Attribute outerClass java\/text\/AttributedCharacterIterator innerClassName Attribute flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/geom\/AffineTransform\n+header extends java\/lang\/Object implements java\/lang\/Cloneable,java\/io\/Serializable flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Double outerClass java\/awt\/geom\/Point2D innerClassName Double flags 9\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+innerclass innerClass java\/awt\/geom\/Path2D$Double outerClass java\/awt\/geom\/Path2D innerClassName Double flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/geom\/Area\n+header extends java\/lang\/Object implements java\/awt\/Shape,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Double outerClass java\/awt\/geom\/Rectangle2D innerClassName Double flags 9\n+\n+class name java\/awt\/geom\/Path2D\n+header extends java\/lang\/Object implements java\/awt\/Shape,java\/lang\/Cloneable nestMembers java\/awt\/geom\/Path2D$Double,java\/awt\/geom\/Path2D$Float sealed true flags 421\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Double outerClass java\/awt\/geom\/Rectangle2D innerClassName Double flags 9\n+innerclass innerClass java\/awt\/geom\/Path2D$Double outerClass java\/awt\/geom\/Path2D innerClassName Double flags 9\n+innerclass innerClass java\/awt\/geom\/Path2D$Float outerClass java\/awt\/geom\/Path2D innerClassName Float flags 9\n+\n+class name java\/awt\/geom\/RectangularShape\n+header extends java\/lang\/Object implements java\/awt\/Shape,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Double outerClass java\/awt\/geom\/Rectangle2D innerClassName Double flags 9\n+\n+class name java\/awt\/image\/AbstractMultiResolutionImage\n+header extends java\/awt\/Image implements java\/awt\/image\/MultiResolutionImage flags 421\n+\n+class name java\/awt\/image\/BandCombineOp\n+header extends java\/lang\/Object implements java\/awt\/image\/RasterOp flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/BandedSampleModel\n+header extends java\/awt\/image\/ComponentSampleModel flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/BaseMultiResolutionImage\n+header extends java\/awt\/image\/AbstractMultiResolutionImage flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/BufferedImageFilter\n+header extends java\/awt\/image\/ImageFilter implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ByteLookupTable\n+header extends java\/awt\/image\/LookupTable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ColorConvertOp\n+header extends java\/lang\/Object implements java\/awt\/image\/BufferedImageOp,java\/awt\/image\/RasterOp flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+\n+class name java\/awt\/image\/ComponentColorModel\n+header extends java\/awt\/image\/ColorModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ComponentSampleModel\n+header extends java\/awt\/image\/SampleModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ConvolveOp\n+header extends java\/lang\/Object implements java\/awt\/image\/BufferedImageOp,java\/awt\/image\/RasterOp flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+\n+class name java\/awt\/image\/DataBufferUShort\n+header extends java\/awt\/image\/DataBuffer flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/DirectColorModel\n+header extends java\/awt\/image\/PackedColorModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ImageFilter\n+header extends java\/lang\/Object implements java\/awt\/image\/ImageConsumer,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/IndexColorModel\n+header extends java\/awt\/image\/ColorModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/Kernel\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/LookupOp\n+header extends java\/lang\/Object implements java\/awt\/image\/BufferedImageOp,java\/awt\/image\/RasterOp flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/MultiPixelPackedSampleModel\n+header extends java\/awt\/image\/SampleModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/MultiResolutionImage\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/image\/PackedColorModel\n+header extends java\/awt\/image\/ColorModel flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/Raster\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ReplicateScaleFilter\n+header extends java\/awt\/image\/ImageFilter flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/RescaleOp\n+header extends java\/lang\/Object implements java\/awt\/image\/BufferedImageOp,java\/awt\/image\/RasterOp flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/SampleModel\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ShortLookupTable\n+header extends java\/awt\/image\/LookupTable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/SinglePixelPackedSampleModel\n+header extends java\/awt\/image\/SampleModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/print\/Paper\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Double outerClass java\/awt\/geom\/Rectangle2D innerClassName Double flags 9\n+\n+class name java\/beans\/BeanProperty\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Documented;@Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;METHOD;})@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;RUNTIME;)\n+\n+class name java\/beans\/Beans\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/DefaultPersistenceDelegate\n+header extends java\/beans\/PersistenceDelegate flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/Encoder\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/EventSetDescriptor\n+header extends java\/beans\/FeatureDescriptor flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/Expression\n+header extends java\/beans\/Statement flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/FeatureDescriptor\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+\n+class name java\/beans\/IndexedPropertyDescriptor\n+header extends java\/beans\/PropertyDescriptor flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/JavaBean\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Documented;@Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;TYPE;})@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;RUNTIME;)\n+\n+class name java\/beans\/PropertyDescriptor\n+header extends java\/beans\/FeatureDescriptor flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/SimpleBeanInfo\n+header extends java\/lang\/Object implements java\/beans\/BeanInfo flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/accessibility\/AccessibilityProvider\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/accessibility\/AccessibleBundle\n+header extends java\/lang\/Object flags 421 classAnnotations @Ljdk\/Profile+Annotation;(value=I4)\n+\n+class name javax\/accessibility\/AccessibleRelationSet\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/accessibility\/AccessibleStateSet\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/metadata\/IIOMetadata\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/plugins\/jpeg\/JPEGHuffmanTable\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/plugins\/jpeg\/JPEGQTable\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/plugins\/tiff\/TIFFDirectory\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 21\n+\n+class name javax\/imageio\/plugins\/tiff\/TIFFField\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/plugins\/tiff\/TIFFImageReadParam\n+header extends javax\/imageio\/ImageReadParam flags 31\n+\n+class name javax\/imageio\/plugins\/tiff\/TIFFTag\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/plugins\/tiff\/TIFFTagSet\n+header extends java\/lang\/Object flags 21\n+\n+class name javax\/imageio\/spi\/ImageReaderWriterSpi\n+header extends javax\/imageio\/spi\/IIOServiceProvider flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/print\/attribute\/DateTimeSyntax\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/print\/attribute\/EnumSyntax\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/print\/attribute\/IntegerSyntax\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/print\/attribute\/standard\/MediaPrintableArea\n+header extends java\/lang\/Object implements javax\/print\/attribute\/DocAttribute,javax\/print\/attribute\/PrintRequestAttribute,javax\/print\/attribute\/PrintJobAttribute flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/print\/event\/PrintEvent\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/midi\/MetaMessage\n+header extends javax\/sound\/midi\/MidiMessage flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/midi\/MidiMessage\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/midi\/Sequence\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/midi\/ShortMessage\n+header extends javax\/sound\/midi\/MidiMessage flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/midi\/SysexMessage\n+header extends javax\/sound\/midi\/MidiMessage flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/sampled\/ReverbType\n+header extends java\/lang\/Object flags 21 classAnnotations @Ljdk\/Profile+Annotation;(value=I4)\n+\n+class name javax\/sound\/sampled\/spi\/FormatConversionProvider\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass javax\/sound\/sampled\/AudioFormat$Encoding outerClass javax\/sound\/sampled\/AudioFormat innerClassName Encoding flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/BoxLayout\n+header extends java\/lang\/Object implements java\/awt\/LayoutManager2,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/DebugGraphics\n+header extends java\/awt\/Graphics flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/DefaultBoundedRangeModel\n+header extends java\/lang\/Object implements javax\/swing\/BoundedRangeModel,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/DefaultListSelectionModel\n+header extends java\/lang\/Object implements javax\/swing\/ListSelectionModel,java\/lang\/Cloneable,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/GrayFilter\n+header extends java\/awt\/image\/RGBImageFilter flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/GroupLayout$Group\n+header extends javax\/swing\/GroupLayout$Spring nestHost javax\/swing\/GroupLayout sealed true flags 421\n+innerclass innerClass javax\/swing\/GroupLayout$Group outerClass javax\/swing\/GroupLayout innerClassName Group flags 401\n+innerclass innerClass javax\/swing\/GroupLayout$Spring outerClass javax\/swing\/GroupLayout innerClassName Spring flags 40a\n+innerclass innerClass javax\/swing\/GroupLayout$ParallelGroup outerClass javax\/swing\/GroupLayout innerClassName ParallelGroup flags 1\n+innerclass innerClass javax\/swing\/GroupLayout$SequentialGroup outerClass javax\/swing\/GroupLayout innerClassName SequentialGroup flags 11\n+\n+class name javax\/swing\/GroupLayout$ParallelGroup\n+header extends javax\/swing\/GroupLayout$Group nestHost javax\/swing\/GroupLayout sealed true flags 21\n+innerclass innerClass javax\/swing\/GroupLayout$ParallelGroup outerClass javax\/swing\/GroupLayout innerClassName ParallelGroup flags 1\n+innerclass innerClass javax\/swing\/GroupLayout$Group outerClass javax\/swing\/GroupLayout innerClassName Group flags 401\n+innerclass innerClass javax\/swing\/GroupLayout$Alignment outerClass javax\/swing\/GroupLayout innerClassName Alignment flags 4019\n+innerclass innerClass javax\/swing\/GroupLayout$Spring outerClass javax\/swing\/GroupLayout innerClassName Spring flags 40a\n+\n+class name javax\/swing\/JList\n+-method name setLayoutOrientation descriptor (I)V\n+method name setLayoutOrientation descriptor (I)V flags 1 runtimeAnnotations @Ljava\/beans\/BeanProperty;(visualUpdate=Ztrue,enumerationValues={\"JList.VERTICAL\"\"JList.HORIZONTAL_WRAP\"\"JList.VERTICAL_WRAP\"},description=\"Defines\\u005C;u0020;the\\u005C;u0020;way\\u005C;u0020;list\\u005C;u0020;cells\\u005C;u0020;are\\u005C;u0020;laid\\u005C;u0020;out.\")\n+\n+class name javax\/swing\/JList$AccessibleJList$AccessibleJListChild\n+-method name getAccessibleAction descriptor ()Ljavax\/accessibility\/AccessibleAction;\n+method name getAccessibleAction descriptor ()Ljavax\/accessibility\/AccessibleAction; flags 1\n+\n+class name javax\/swing\/JTextPane\n+header extends javax\/swing\/JEditorPane flags 21 runtimeAnnotations @Ljava\/beans\/JavaBean;(description=\"A\\u005C;u0020;text\\u005C;u0020;component\\u005C;u0020;that\\u005C;u0020;can\\u005C;u0020;be\\u005C;u0020;marked\\u005C;u0020;up\\u005C;u0020;with\\u005C;u0020;attributes\\u005C;u0020;that\\u005C;u0020;are\\u005C;u0020;graphically\\u005C;u0020;represented.\")@Ljavax\/swing\/SwingContainer;\n+\n+class name javax\/swing\/LookAndFeel\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass javax\/swing\/text\/JTextComponent$KeyBinding outerClass javax\/swing\/text\/JTextComponent innerClassName KeyBinding flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/MenuSelectionManager\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/SizeRequirements\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/SortingFocusTraversalPolicy\n+header extends javax\/swing\/InternalFrameFocusTraversalPolicy flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/SwingContainer\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;TYPE;})@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;RUNTIME;)\n+\n+class name javax\/swing\/UIClientPropertyKey\n+header extends java\/lang\/Object flags 601\n+\n+class name javax\/swing\/border\/LineBorder\n+header extends javax\/swing\/border\/AbstractBorder flags 21\n+innerclass innerClass java\/awt\/geom\/RoundRectangle2D$Float outerClass java\/awt\/geom\/RoundRectangle2D innerClassName Float flags 9\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Float outerClass java\/awt\/geom\/Rectangle2D innerClassName Float flags 9\n+innerclass innerClass java\/awt\/geom\/Path2D$Float outerClass java\/awt\/geom\/Path2D innerClassName Float flags 9\n+\n+class name javax\/swing\/event\/EventListenerList\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/event\/ListDataEvent\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/event\/ListSelectionEvent\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/event\/TreeModelEvent\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/filechooser\/FileNameExtensionFilter\n+header extends javax\/swing\/filechooser\/FileFilter flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/basic\/BasicArrowButton\n+header extends javax\/swing\/JButton implements javax\/swing\/SwingConstants flags 21\n+innerclass innerClass java\/awt\/geom\/Path2D$Double outerClass java\/awt\/geom\/Path2D innerClassName Double flags 9\n+\n+class name javax\/swing\/plaf\/basic\/BasicButtonUI\n+header extends javax\/swing\/plaf\/ButtonUI flags 21\n+innerclass innerClass java\/awt\/Component$BaselineResizeBehavior outerClass java\/awt\/Component innerClassName BaselineResizeBehavior flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/basic\/BasicPasswordFieldUI\n+header extends javax\/swing\/plaf\/basic\/BasicTextFieldUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/basic\/BasicSplitPaneUI$BasicHorizontalLayoutManager\n+header extends java\/lang\/Object implements java\/awt\/LayoutManager2 nestHost javax\/swing\/plaf\/basic\/BasicSplitPaneUI sealed true flags 21\n+innerclass innerClass javax\/swing\/plaf\/basic\/BasicSplitPaneUI$BasicHorizontalLayoutManager outerClass javax\/swing\/plaf\/basic\/BasicSplitPaneUI innerClassName BasicHorizontalLayoutManager flags 1\n+innerclass innerClass javax\/swing\/plaf\/basic\/BasicSplitPaneUI$BasicVerticalLayoutManager outerClass javax\/swing\/plaf\/basic\/BasicSplitPaneUI innerClassName BasicVerticalLayoutManager flags 1\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/basic\/BasicToolBarSeparatorUI\n+header extends javax\/swing\/plaf\/basic\/BasicSeparatorUI flags 21\n+innerclass innerClass javax\/swing\/JToolBar$Separator outerClass javax\/swing\/JToolBar innerClassName Separator flags 9\n+\n+class name javax\/swing\/plaf\/metal\/MetalButtonUI\n+header extends javax\/swing\/plaf\/basic\/BasicButtonUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/metal\/MetalCheckBoxUI\n+header extends javax\/swing\/plaf\/metal\/MetalRadioButtonUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/metal\/MetalRadioButtonUI\n+header extends javax\/swing\/plaf\/basic\/BasicRadioButtonUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/metal\/MetalToggleButtonUI\n+header extends javax\/swing\/plaf\/basic\/BasicToggleButtonUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/metal\/MetalToolTipUI\n+header extends javax\/swing\/plaf\/basic\/BasicToolTipUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/multi\/MultiLookAndFeel\n+header extends javax\/swing\/LookAndFeel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/synth\/SynthButtonUI\n+header extends javax\/swing\/plaf\/basic\/BasicButtonUI implements java\/beans\/PropertyChangeListener,javax\/swing\/plaf\/synth\/SynthUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/synth\/SynthIcon\n+header extends java\/lang\/Object implements javax\/swing\/Icon flags 601\n+\n+class name javax\/swing\/plaf\/synth\/SynthMenuItemUI\n+header extends javax\/swing\/plaf\/basic\/BasicMenuItemUI implements java\/beans\/PropertyChangeListener,javax\/swing\/plaf\/synth\/SynthUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/synth\/SynthMenuUI\n+header extends javax\/swing\/plaf\/basic\/BasicMenuUI implements java\/beans\/PropertyChangeListener,javax\/swing\/plaf\/synth\/SynthUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/synth\/SynthPasswordFieldUI\n+header extends javax\/swing\/plaf\/synth\/SynthTextFieldUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name installDefaults descriptor ()V flags 4\n+\n+class name javax\/swing\/plaf\/synth\/SynthSeparatorUI\n+header extends javax\/swing\/plaf\/SeparatorUI implements java\/beans\/PropertyChangeListener,javax\/swing\/plaf\/synth\/SynthUI flags 21\n+innerclass innerClass javax\/swing\/JToolBar$Separator outerClass javax\/swing\/JToolBar innerClassName Separator flags 9\n+\n+class name javax\/swing\/plaf\/synth\/SynthStyle\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass javax\/swing\/UIDefaults$LazyInputMap outerClass javax\/swing\/UIDefaults innerClassName LazyInputMap flags 9\n+innerclass innerClass javax\/swing\/UIDefaults$LazyValue outerClass javax\/swing\/UIDefaults innerClassName LazyValue flags 609\n+\n+class name javax\/swing\/table\/AbstractTableModel\n+header extends java\/lang\/Object implements javax\/swing\/table\/TableModel,java\/io\/Serializable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/AbstractWriter\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/BoxView\n+header extends javax\/swing\/text\/CompositeView flags 21\n+innerclass innerClass javax\/swing\/event\/DocumentEvent$ElementChange outerClass javax\/swing\/event\/DocumentEvent innerClassName ElementChange flags 609\n+innerclass innerClass javax\/swing\/text\/Position$Bias outerClass javax\/swing\/text\/Position innerClassName Bias flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/CompositeView\n+header extends javax\/swing\/text\/View flags 421\n+innerclass innerClass javax\/swing\/text\/Position$Bias outerClass javax\/swing\/text\/Position innerClassName Bias flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/DateFormatter\n+header extends javax\/swing\/text\/InternationalFormatter flags 21\n+innerclass innerClass java\/text\/DateFormat$Field outerClass java\/text\/DateFormat innerClassName Field flags 9\n+\n+class name javax\/swing\/text\/DefaultEditorKit\n+field name beginLineUpAction descriptor Ljava\/lang\/String; constantValue caret-begin-line-and-up flags 19\n+field name endLineDownAction descriptor Ljava\/lang\/String; constantValue caret-end-line-and-down flags 19\n+\n+class name javax\/swing\/text\/IconView\n+header extends javax\/swing\/text\/View flags 21\n+innerclass innerClass javax\/swing\/text\/Position$Bias outerClass javax\/swing\/text\/Position innerClassName Bias flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/LayoutQueue\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/NumberFormatter\n+header extends javax\/swing\/text\/InternationalFormatter flags 21\n+innerclass innerClass java\/text\/NumberFormat$Field outerClass java\/text\/NumberFormat innerClassName Field flags 9\n+innerclass innerClass javax\/swing\/text\/DocumentFilter$FilterBypass outerClass javax\/swing\/text\/DocumentFilter innerClassName FilterBypass flags 409\n+innerclass innerClass java\/text\/AttributedCharacterIterator$Attribute outerClass java\/text\/AttributedCharacterIterator innerClassName Attribute flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/Segment\n+header extends java\/lang\/Object implements java\/lang\/Cloneable,java\/text\/CharacterIterator,java\/lang\/CharSequence flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/StyleConstants\n+header extends java\/lang\/Object nestMembers javax\/swing\/text\/StyleConstants$FontConstants,javax\/swing\/text\/StyleConstants$ColorConstants,javax\/swing\/text\/StyleConstants$CharacterConstants,javax\/swing\/text\/StyleConstants$ParagraphConstants sealed true flags 21\n+innerclass innerClass javax\/swing\/text\/StyleConstants$CharacterConstants outerClass javax\/swing\/text\/StyleConstants innerClassName CharacterConstants flags 19\n+innerclass innerClass javax\/swing\/text\/StyleConstants$FontConstants outerClass javax\/swing\/text\/StyleConstants innerClassName FontConstants flags 19\n+innerclass innerClass javax\/swing\/text\/StyleConstants$ColorConstants outerClass javax\/swing\/text\/StyleConstants innerClassName ColorConstants flags 19\n+innerclass innerClass javax\/swing\/text\/StyleConstants$ParagraphConstants outerClass javax\/swing\/text\/StyleConstants innerClassName ParagraphConstants flags 19\n+\n+class name javax\/swing\/text\/TabSet\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/TabStop\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/View\n+header extends java\/lang\/Object implements javax\/swing\/SwingConstants flags 421\n+innerclass innerClass javax\/swing\/text\/Position$Bias outerClass javax\/swing\/text\/Position innerClassName Bias flags 19\n+innerclass innerClass javax\/swing\/event\/DocumentEvent$ElementChange outerClass javax\/swing\/event\/DocumentEvent innerClassName ElementChange flags 609\n+innerclass innerClass javax\/swing\/event\/DocumentEvent$EventType outerClass javax\/swing\/event\/DocumentEvent innerClassName EventType flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/html\/InlineView\n+header extends javax\/swing\/text\/LabelView flags 21\n+innerclass innerClass javax\/swing\/text\/html\/CSS$Attribute outerClass javax\/swing\/text\/html\/CSS innerClassName Attribute flags 19\n+\n+class name javax\/swing\/text\/html\/ObjectView\n+header extends javax\/swing\/text\/ComponentView flags 21\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Attribute outerClass javax\/swing\/text\/html\/HTML innerClassName Attribute flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/html\/Option\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Attribute outerClass javax\/swing\/text\/html\/HTML innerClassName Attribute flags 19\n+\n+class name javax\/swing\/text\/html\/parser\/ContentModel\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/html\/parser\/DocumentParser\n+header extends javax\/swing\/text\/html\/parser\/Parser flags 21\n+innerclass innerClass javax\/swing\/text\/html\/HTMLEditorKit$ParserCallback outerClass javax\/swing\/text\/html\/HTMLEditorKit innerClassName ParserCallback flags 9\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Tag outerClass javax\/swing\/text\/html\/HTML innerClassName Tag flags 9\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Attribute outerClass javax\/swing\/text\/html\/HTML innerClassName Attribute flags 19\n+\n+class name javax\/swing\/text\/html\/parser\/Parser\n+header extends java\/lang\/Object implements javax\/swing\/text\/html\/parser\/DTDConstants flags 21\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Attribute outerClass javax\/swing\/text\/html\/HTML innerClassName Attribute flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/html\/parser\/TagElement\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Tag outerClass javax\/swing\/text\/html\/HTML innerClassName Tag flags 9\n+innerclass innerClass javax\/swing\/text\/html\/HTML$UnknownTag outerClass javax\/swing\/text\/html\/HTML innerClassName UnknownTag flags 9\n+\n+class name javax\/swing\/tree\/DefaultTreeModel\n+header extends java\/lang\/Object implements java\/io\/Serializable,javax\/swing\/tree\/TreeModel flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+\n+class name javax\/swing\/tree\/DefaultTreeSelectionModel\n+header extends java\/lang\/Object implements java\/lang\/Cloneable,java\/io\/Serializable,javax\/swing\/tree\/TreeSelectionModel flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/tree\/TreePath\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/undo\/AbstractUndoableEdit\n+header extends java\/lang\/Object implements javax\/swing\/undo\/UndoableEdit,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/undo\/CompoundEdit\n+header extends javax\/swing\/undo\/AbstractUndoableEdit flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/undo\/UndoableEditSupport\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.desktop-K.sym.txt","additions":871,"deletions":0,"binary":false,"changes":871,"status":"added"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.instrument-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/java.instrument-J.sym.txt","status":"copied"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.logging-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/java.logging-J.sym.txt","status":"copied"},{"patch":"@@ -0,0 +1,268 @@\n+#\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+module name java.management\n+header exports java\/lang\/management,javax\/management,javax\/management\/loading,javax\/management\/modelmbean,javax\/management\/monitor,javax\/management\/openmbean,javax\/management\/relation,javax\/management\/remote,javax\/management\/timer requires name\\u0020;java.base\\u0020;flags\\u0020;8000 uses javax\/management\/remote\/JMXConnectorProvider,javax\/management\/remote\/JMXConnectorServerProvider,sun\/management\/spi\/PlatformMBeanProvider provides interface\\u0020;javax\/security\/auth\/spi\/LoginModule\\u0020;impls\\u0020;com\/sun\/jmx\/remote\/security\/FileLoginModule target linux-amd64 flags 8000 classAnnotations @Ljdk\/internal\/javac\/ParticipatesInPreview;\n+\n+class name java\/lang\/management\/LockInfo\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/management\/ManagementPermission\n+header extends java\/security\/BasicPermission flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/management\/MemoryUsage\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/management\/MonitorInfo\n+header extends java\/lang\/management\/LockInfo flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/management\/RuntimeMXBean\n+header extends java\/lang\/Object implements java\/lang\/management\/PlatformManagedObject flags 601\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/Attribute\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/AttributeList\n+header extends java\/util\/ArrayList flags 21 signature Ljava\/util\/ArrayList<Ljava\/lang\/Object;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/BadAttributeValueExpException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/BadBinaryOpValueExpException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/BadStringOperationException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/ConstructorParameters\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Documented;@Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;CONSTRUCTOR;})@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;RUNTIME;)\n+\n+class name javax\/management\/ImmutableDescriptor\n+header extends java\/lang\/Object implements javax\/management\/Descriptor flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanAttributeInfo\n+header extends javax\/management\/MBeanFeatureInfo implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanConstructorInfo\n+header extends javax\/management\/MBeanFeatureInfo implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanNotificationInfo\n+header extends javax\/management\/MBeanFeatureInfo implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanOperationInfo\n+header extends javax\/management\/MBeanFeatureInfo implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanParameterInfo\n+header extends javax\/management\/MBeanFeatureInfo implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanPermission\n+header extends java\/security\/Permission flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanServerDelegate\n+header extends java\/lang\/Object implements javax\/management\/MBeanServerDelegateMBean,javax\/management\/NotificationEmitter flags 21\n+innerclass innerClass java\/lang\/System$Logger outerClass java\/lang\/System innerClassName Logger flags 609\n+innerclass innerClass java\/lang\/System$Logger$Level outerClass java\/lang\/System$Logger innerClassName Level flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanServerFactory\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/System$Logger outerClass java\/lang\/System innerClassName Logger flags 609\n+innerclass innerClass java\/lang\/System$Logger$Level outerClass java\/lang\/System$Logger innerClassName Level flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanServerInvocationHandler\n+header extends java\/lang\/Object implements java\/lang\/reflect\/InvocationHandler flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanServerNotification\n+header extends javax\/management\/Notification flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanServerPermission\n+header extends java\/security\/BasicPermission flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanTrustPermission\n+header extends java\/security\/BasicPermission flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/Notification\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/ObjectInstance\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/Query\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/StandardEmitterMBean\n+header extends javax\/management\/StandardMBean implements javax\/management\/NotificationEmitter flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/StringValueExp\n+header extends java\/lang\/Object implements javax\/management\/ValueExp flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/loading\/DefaultLoaderRepository\n+header extends java\/lang\/Object flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;\n+innerclass innerClass java\/lang\/System$Logger outerClass java\/lang\/System innerClassName Logger flags 609\n+innerclass innerClass java\/lang\/System$Logger$Level outerClass java\/lang\/System$Logger innerClassName Level flags 4019\n+\n+class name javax\/management\/loading\/MLetContent\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/modelmbean\/InvalidTargetObjectTypeException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/modelmbean\/XMLParseException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/ArrayType\n+header extends javax\/management\/openmbean\/OpenType flags 21 signature <T:Ljava\/lang\/Object;>Ljavax\/management\/openmbean\/OpenType<TT;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/CompositeDataInvocationHandler\n+header extends java\/lang\/Object implements java\/lang\/reflect\/InvocationHandler flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/CompositeDataSupport\n+header extends java\/lang\/Object implements javax\/management\/openmbean\/CompositeData,java\/io\/Serializable flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/CompositeType\n+header extends javax\/management\/openmbean\/OpenType flags 21 signature Ljavax\/management\/openmbean\/OpenType<Ljavax\/management\/openmbean\/CompositeData;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/OpenMBeanAttributeInfoSupport\n+header extends javax\/management\/MBeanAttributeInfo implements javax\/management\/openmbean\/OpenMBeanAttributeInfo flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/OpenMBeanOperationInfoSupport\n+header extends javax\/management\/MBeanOperationInfo implements javax\/management\/openmbean\/OpenMBeanOperationInfo flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/SimpleType\n+header extends javax\/management\/openmbean\/OpenType flags 31 signature <T:Ljava\/lang\/Object;>Ljavax\/management\/openmbean\/OpenType<TT;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/TabularDataSupport\n+header extends java\/lang\/Object implements javax\/management\/openmbean\/TabularData,java\/util\/Map,java\/lang\/Cloneable,java\/io\/Serializable flags 21 signature Ljava\/lang\/Object;Ljavax\/management\/openmbean\/TabularData;Ljava\/util\/Map<Ljava\/lang\/Object;Ljava\/lang\/Object;>;Ljava\/lang\/Cloneable;Ljava\/io\/Serializable;\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/TabularType\n+header extends javax\/management\/openmbean\/OpenType flags 21 signature Ljavax\/management\/openmbean\/OpenType<Ljavax\/management\/openmbean\/TabularData;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/relation\/RelationNotification\n+header extends javax\/management\/Notification flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+\n+class name javax\/management\/relation\/RelationSupport\n+header extends java\/lang\/Object implements javax\/management\/relation\/RelationSupportMBean,javax\/management\/MBeanRegistration flags 21\n+innerclass innerClass java\/lang\/System$Logger outerClass java\/lang\/System innerClassName Logger flags 609\n+innerclass innerClass java\/lang\/System$Logger$Level outerClass java\/lang\/System$Logger innerClassName Level flags 4019\n+\n+class name javax\/management\/relation\/Role\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/relation\/RoleInfo\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/relation\/RoleResult\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+\n+class name javax\/management\/relation\/RoleUnresolved\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/remote\/JMXConnectorServerFactory\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/util\/ServiceLoader$Provider outerClass java\/util\/ServiceLoader innerClassName Provider flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/remote\/JMXPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/remote\/JMXServiceURL\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/remote\/NotificationResult\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/remote\/TargetedNotification\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.management-K.sym.txt","additions":268,"deletions":0,"binary":false,"changes":268,"status":"added"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.management.rmi-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/java.management.rmi-J.sym.txt","status":"copied"},{"patch":"@@ -0,0 +1,85 @@\n+#\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/naming\/BinaryRefAddr\n+header extends javax\/naming\/RefAddr flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/Binding\n+header extends javax\/naming\/NameClassPair flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/CompositeName\n+header extends java\/lang\/Object implements javax\/naming\/Name flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/CompoundName\n+header extends java\/lang\/Object implements javax\/naming\/Name flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/LinkException\n+header extends javax\/naming\/NamingException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/NameClassPair\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/NamingException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/RefAddr\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/Reference\n+header extends java\/lang\/Object implements java\/lang\/Cloneable,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/directory\/AttributeModificationException\n+header extends javax\/naming\/NamingException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/directory\/ModificationItem\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/directory\/SearchResult\n+header extends javax\/naming\/Binding flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/spi\/DirectoryManager\n+header extends javax\/naming\/spi\/NamingManager flags 21\n+innerclass innerClass javax\/naming\/spi\/DirStateFactory$Result outerClass javax\/naming\/spi\/DirStateFactory innerClassName Result flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/spi\/NamingManager\n+-method name setObjectFactoryBuilder descriptor (Ljavax\/naming\/spi\/ObjectFactoryBuilder;)V\n+method name setObjectFactoryBuilder descriptor (Ljavax\/naming\/spi\/ObjectFactoryBuilder;)V thrownTypes javax\/naming\/NamingException flags 9\n+\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.naming-K.sym.txt","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.rmi-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/java.rmi-J.sym.txt","status":"copied"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.scripting-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/java.scripting-J.sym.txt","status":"copied"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.security.jgss-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/java.security.jgss-J.sym.txt","status":"copied"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.security.sasl-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/java.security.sasl-J.sym.txt","status":"copied"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.smartcardio-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/java.smartcardio-J.sym.txt","status":"copied"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.sql-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/java.sql-J.sym.txt","status":"copied"},{"patch":"@@ -0,0 +1,73 @@\n+#\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/sql\/rowset\/BaseRowSet\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sql\/rowset\/serial\/SQLOutputImpl\n+header extends java\/lang\/Object implements java\/sql\/SQLOutput flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sql\/rowset\/serial\/SerialArray\n+header extends java\/lang\/Object implements java\/sql\/Array,java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+\n+class name javax\/sql\/rowset\/serial\/SerialBlob\n+header extends java\/lang\/Object implements java\/sql\/Blob,java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+\n+class name javax\/sql\/rowset\/serial\/SerialClob\n+header extends java\/lang\/Object implements java\/sql\/Clob,java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sql\/rowset\/serial\/SerialDatalink\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sql\/rowset\/serial\/SerialJavaObject\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+\n+class name javax\/sql\/rowset\/serial\/SerialRef\n+header extends java\/lang\/Object implements java\/sql\/Ref,java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sql\/rowset\/serial\/SerialStruct\n+header extends java\/lang\/Object implements java\/sql\/Struct,java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.sql.rowset-K.sym.txt","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.xml-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/java.xml-J.sym.txt","status":"copied"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.xml.crypto-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/java.xml.crypto-J.sym.txt","status":"copied"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.accessibility-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.accessibility-J.sym.txt","status":"copied"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.attach-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.attach-J.sym.txt","status":"copied"},{"patch":"@@ -0,0 +1,381 @@\n+#\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/source\/doctree\/AuthorTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/BlockTagTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/CommentTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/DeprecatedTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/DocCommentTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/DocRootTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/DocTree$Kind\n+field name SPEC descriptor Lcom\/sun\/source\/doctree\/DocTree$Kind; flags 4019\n+\n+class name com\/sun\/source\/doctree\/DocTreeVisitor\n+header extends java\/lang\/Object flags 601 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;\n+method name visitSpec descriptor (Lcom\/sun\/source\/doctree\/SpecTree;Ljava\/lang\/Object;)Ljava\/lang\/Object; flags 1 signature (Lcom\/sun\/source\/doctree\/SpecTree;TP;)TR;\n+\n+class name com\/sun\/source\/doctree\/DocTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/EndElementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/EntityTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ErroneousTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/TextTree flags 601\n+\n+class name com\/sun\/source\/doctree\/HiddenTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/IdentifierTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/IndexTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/InheritDocTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/InlineTagTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/LinkTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/LiteralTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ParamTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ProvidesTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ReferenceTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SeeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SerialDataTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SerialFieldTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SerialTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SinceTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SpecTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+method name getURL descriptor ()Lcom\/sun\/source\/doctree\/TextTree; flags 401\n+method name getTitle descriptor ()Ljava\/util\/List; flags 401 signature ()Ljava\/util\/List<+Lcom\/sun\/source\/doctree\/DocTree;>;\n+\n+class name com\/sun\/source\/doctree\/StartElementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SummaryTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/TextTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ThrowsTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/UnknownBlockTagTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/UnknownInlineTagTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/UsesTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ValueTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+method name getFormat descriptor ()Lcom\/sun\/source\/doctree\/TextTree; flags 1\n+\n+class name com\/sun\/source\/doctree\/VersionTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/tree\/AnnotatedTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/AnnotationTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/ArrayAccessTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/ArrayTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/AssertTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/AssignmentTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/BinaryTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/BlockTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/BreakTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/CatchTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/ClassTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/CompilationUnitTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/CompoundAssignmentTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/ConditionalExpressionTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/ContinueTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/DirectiveTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/DoWhileLoopTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/EmptyStatementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/EnhancedForLoopTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/ErroneousTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/ExportsTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/DirectiveTree flags 601\n+\n+class name com\/sun\/source\/tree\/ExpressionStatementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/ExpressionTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/ForLoopTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/IdentifierTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/IfTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/ImportTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/InstanceOfTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/IntersectionTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/LabeledStatementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/LineMap\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/source\/tree\/LiteralTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/MemberSelectTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/MethodInvocationTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/MethodTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/ModifiersTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/NewArrayTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/NewClassTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/OpensTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/DirectiveTree flags 601\n+\n+class name com\/sun\/source\/tree\/PackageTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/ParameterizedTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/ParenthesizedTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/PatternTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/PrimitiveTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/ProvidesTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/DirectiveTree flags 601\n+\n+class name com\/sun\/source\/tree\/RequiresTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/DirectiveTree flags 601\n+\n+class name com\/sun\/source\/tree\/ReturnTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/Scope\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/source\/tree\/StatementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/SwitchTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/SynchronizedTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/ThrowTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/TreeVisitor\n+header extends java\/lang\/Object flags 601 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;\n+\n+class name com\/sun\/source\/tree\/TryTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/TypeCastTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/TypeParameterTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/UnaryTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/UnionTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/UsesTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/DirectiveTree flags 601\n+\n+class name com\/sun\/source\/tree\/VariableTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/WhileLoopTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/WildcardTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/util\/DocSourcePositions\n+header extends java\/lang\/Object implements com\/sun\/source\/util\/SourcePositions flags 601\n+\n+class name com\/sun\/source\/util\/DocTreeFactory\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass com\/sun\/source\/doctree\/AttributeTree$ValueKind outerClass com\/sun\/source\/doctree\/AttributeTree innerClassName ValueKind flags 4019\n+method name newSpecTree descriptor (Lcom\/sun\/source\/doctree\/TextTree;Ljava\/util\/List;)Lcom\/sun\/source\/doctree\/SpecTree; flags 401 signature (Lcom\/sun\/source\/doctree\/TextTree;Ljava\/util\/List<+Lcom\/sun\/source\/doctree\/DocTree;>;)Lcom\/sun\/source\/doctree\/SpecTree;\n+method name newValueTree descriptor (Lcom\/sun\/source\/doctree\/TextTree;Lcom\/sun\/source\/doctree\/ReferenceTree;)Lcom\/sun\/source\/doctree\/ValueTree; flags 1\n+\n+class name com\/sun\/source\/util\/DocTreePathScanner\n+header extends com\/sun\/source\/util\/DocTreeScanner flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Lcom\/sun\/source\/util\/DocTreeScanner<TR;TP;>;\n+\n+class name com\/sun\/source\/util\/DocTreeScanner\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTreeVisitor flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;Lcom\/sun\/source\/doctree\/DocTreeVisitor<TR;TP;>;\n+method name visitSpec descriptor (Lcom\/sun\/source\/doctree\/SpecTree;Ljava\/lang\/Object;)Ljava\/lang\/Object; flags 1 signature (Lcom\/sun\/source\/doctree\/SpecTree;TP;)TR;\n+\n+class name com\/sun\/source\/util\/DocTrees\n+header extends com\/sun\/source\/util\/Trees flags 421\n+innerclass innerClass javax\/tools\/JavaCompiler$CompilationTask outerClass javax\/tools\/JavaCompiler innerClassName CompilationTask flags 609\n+innerclass innerClass javax\/tools\/Diagnostic$Kind outerClass javax\/tools\/Diagnostic innerClassName Kind flags 4019\n+\n+class name com\/sun\/source\/util\/JavacTask\n+header extends java\/lang\/Object implements javax\/tools\/JavaCompiler$CompilationTask flags 421\n+innerclass innerClass javax\/tools\/JavaCompiler$CompilationTask outerClass javax\/tools\/JavaCompiler innerClassName CompilationTask flags 609\n+\n+class name com\/sun\/source\/util\/Plugin\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/source\/util\/SimpleDocTreeVisitor\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTreeVisitor flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;Lcom\/sun\/source\/doctree\/DocTreeVisitor<TR;TP;>;\n+method name visitSpec descriptor (Lcom\/sun\/source\/doctree\/SpecTree;Ljava\/lang\/Object;)Ljava\/lang\/Object; flags 1 signature (Lcom\/sun\/source\/doctree\/SpecTree;TP;)TR;\n+\n+class name com\/sun\/source\/util\/SimpleTreeVisitor\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/TreeVisitor flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;Lcom\/sun\/source\/tree\/TreeVisitor<TR;TP;>;\n+\n+class name com\/sun\/source\/util\/SourcePositions\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/source\/util\/TaskListener\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/source\/util\/TreePathScanner\n+header extends com\/sun\/source\/util\/TreeScanner flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Lcom\/sun\/source\/util\/TreeScanner<TR;TP;>;\n+\n+class name com\/sun\/source\/util\/Trees\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass javax\/tools\/JavaCompiler$CompilationTask outerClass javax\/tools\/JavaCompiler innerClassName CompilationTask flags 609\n+innerclass innerClass javax\/tools\/Diagnostic$Kind outerClass javax\/tools\/Diagnostic innerClassName Kind flags 4019\n+\n+class name com\/sun\/tools\/javac\/Main\n+header extends java\/lang\/Object flags 21\n+\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.compiler-K.sym.txt","additions":381,"deletions":0,"binary":false,"changes":381,"status":"added"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.dynalink-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.dynalink-J.sym.txt","status":"copied"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.httpserver-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.httpserver-J.sym.txt","status":"copied"},{"patch":"@@ -0,0 +1,57 @@\n+#\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+module name jdk.incubator.concurrent\n+header exports jdk\/incubator\/concurrent requires name\\u0020;java.base\\u0020;flags\\u0020;8000 target linux-amd64 resolution 9 flags 8000 classAnnotations @Ljdk\/internal\/javac\/ParticipatesInPreview;\n+\n+class name jdk\/incubator\/concurrent\/StructuredTaskScope\n+header extends java\/lang\/Object implements java\/lang\/AutoCloseable nestMembers jdk\/incubator\/concurrent\/StructuredTaskScope$ShutdownOnFailure,jdk\/incubator\/concurrent\/StructuredTaskScope$ShutdownOnSuccess flags 21 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/lang\/AutoCloseable;\n+innerclass innerClass java\/lang\/Thread$Builder outerClass java\/lang\/Thread innerClassName Builder flags 609\n+innerclass innerClass java\/lang\/Thread$Builder$OfVirtual outerClass java\/lang\/Thread$Builder innerClassName OfVirtual flags 609\n+innerclass innerClass java\/util\/concurrent\/ConcurrentHashMap$KeySetView outerClass java\/util\/concurrent\/ConcurrentHashMap innerClassName KeySetView flags 19\n+innerclass innerClass java\/util\/concurrent\/Future$State outerClass java\/util\/concurrent\/Future innerClassName State flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+innerclass innerClass jdk\/incubator\/concurrent\/StructuredTaskScope$ShutdownOnFailure outerClass jdk\/incubator\/concurrent\/StructuredTaskScope innerClassName ShutdownOnFailure flags 19\n+innerclass innerClass jdk\/incubator\/concurrent\/StructuredTaskScope$ShutdownOnSuccess outerClass jdk\/incubator\/concurrent\/StructuredTaskScope innerClassName ShutdownOnSuccess flags 19\n+\n+class name jdk\/incubator\/concurrent\/StructuredTaskScope$ShutdownOnFailure\n+header extends jdk\/incubator\/concurrent\/StructuredTaskScope nestHost jdk\/incubator\/concurrent\/StructuredTaskScope flags 31 signature Ljdk\/incubator\/concurrent\/StructuredTaskScope<Ljava\/lang\/Object;>;\n+innerclass innerClass java\/lang\/Thread$Builder outerClass java\/lang\/Thread innerClassName Builder flags 609\n+innerclass innerClass java\/lang\/Thread$Builder$OfVirtual outerClass java\/lang\/Thread$Builder innerClassName OfVirtual flags 609\n+innerclass innerClass java\/util\/concurrent\/Future$State outerClass java\/util\/concurrent\/Future innerClassName State flags 4019\n+innerclass innerClass jdk\/incubator\/concurrent\/StructuredTaskScope$ShutdownOnFailure outerClass jdk\/incubator\/concurrent\/StructuredTaskScope innerClassName ShutdownOnFailure flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/incubator\/concurrent\/StructuredTaskScope$ShutdownOnSuccess\n+header extends jdk\/incubator\/concurrent\/StructuredTaskScope nestHost jdk\/incubator\/concurrent\/StructuredTaskScope flags 31 signature <T:Ljava\/lang\/Object;>Ljdk\/incubator\/concurrent\/StructuredTaskScope<TT;>;\n+innerclass innerClass java\/lang\/Thread$Builder outerClass java\/lang\/Thread innerClassName Builder flags 609\n+innerclass innerClass java\/lang\/Thread$Builder$OfVirtual outerClass java\/lang\/Thread$Builder innerClassName OfVirtual flags 609\n+innerclass innerClass java\/util\/concurrent\/Future$State outerClass java\/util\/concurrent\/Future innerClassName State flags 4019\n+innerclass innerClass jdk\/incubator\/concurrent\/StructuredTaskScope$ShutdownOnSuccess outerClass jdk\/incubator\/concurrent\/StructuredTaskScope innerClassName ShutdownOnSuccess flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.incubator.concurrent-K.sym.txt","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+#\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+module name jdk.incubator.vector\n+header exports jdk\/incubator\/vector requires name\\u0020;java.base\\u0020;flags\\u0020;8000 target linux-amd64 resolution 9 flags 8000 classAnnotations @Ljdk\/internal\/javac\/ParticipatesInPreview;\n+\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.incubator.vector-K.sym.txt","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+#\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+module name jdk.jartool\n+header exports com\/sun\/jarsigner,jdk\/security\/jarsigner requires name\\u0020;java.base\\u0020;flags\\u0020;8000,name\\u0020;jdk.internal.opt\\u0020;flags\\u0020;0 provides interface\\u0020;java\/util\/spi\/ToolProvider\\u0020;impls\\u0020;sun\/tools\/jar\/JarToolProvider target linux-amd64 flags 8000\n+\n+class name jdk\/security\/jarsigner\/JarSignerException\n+header extends java\/lang\/RuntimeException flags 21\n+\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.jartool-K.sym.txt","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.javadoc-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.javadoc-J.sym.txt","status":"copied"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.jconsole-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.jconsole-J.sym.txt","status":"copied"},{"patch":"@@ -0,0 +1,395 @@\n+#\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/jdi\/AbsentInformationException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/Accessible\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/jdi\/ArrayReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/ArrayType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ReferenceType flags 601\n+\n+class name com\/sun\/jdi\/BooleanType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/BooleanValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue flags 601\n+\n+class name com\/sun\/jdi\/Bootstrap\n+header extends java\/lang\/Object flags 21\n+\n+class name com\/sun\/jdi\/ByteType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/ByteValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/ByteValue;>;\n+\n+class name com\/sun\/jdi\/CharType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/CharValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/CharValue;>;\n+\n+class name com\/sun\/jdi\/ClassLoaderReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/ClassNotLoadedException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/ClassNotPreparedException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/ClassObjectReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/ClassType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ReferenceType flags 601\n+\n+class name com\/sun\/jdi\/DoubleType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/DoubleValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/DoubleValue;>;\n+\n+class name com\/sun\/jdi\/Field\n+header extends java\/lang\/Object implements com\/sun\/jdi\/TypeComponent,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/TypeComponent;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/Field;>;\n+\n+class name com\/sun\/jdi\/FloatType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/FloatValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/FloatValue;>;\n+\n+class name com\/sun\/jdi\/IncompatibleThreadStateException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/InconsistentDebugInfoException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/IntegerType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/IntegerValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/IntegerValue;>;\n+\n+class name com\/sun\/jdi\/InterfaceType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ReferenceType flags 601\n+\n+class name com\/sun\/jdi\/InternalException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/InvalidCodeIndexException\n+header extends java\/lang\/RuntimeException flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;\n+\n+class name com\/sun\/jdi\/InvalidLineNumberException\n+header extends java\/lang\/RuntimeException flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;\n+\n+class name com\/sun\/jdi\/InvalidModuleException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/InvalidStackFrameException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/InvalidTypeException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/InvocationException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/JDIPermission\n+header extends java\/security\/BasicPermission flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/jdi\/LocalVariable\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/Mirror;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/LocalVariable;>;\n+\n+class name com\/sun\/jdi\/Locatable\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/jdi\/Location\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/Mirror;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/Location;>;\n+\n+class name com\/sun\/jdi\/LongType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/LongValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/LongValue;>;\n+\n+class name com\/sun\/jdi\/Method\n+header extends java\/lang\/Object implements com\/sun\/jdi\/TypeComponent,com\/sun\/jdi\/Locatable,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/TypeComponent;Lcom\/sun\/jdi\/Locatable;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/Method;>;\n+\n+class name com\/sun\/jdi\/Mirror\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/jdi\/ModuleReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/MonitorInfo\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/ObjectCollectedException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/ObjectReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Value flags 601\n+\n+class name com\/sun\/jdi\/OpaqueFrameException\n+header extends java\/lang\/RuntimeException sealed true flags 21\n+\n+class name com\/sun\/jdi\/PathSearchingVirtualMachine\n+header extends java\/lang\/Object implements com\/sun\/jdi\/VirtualMachine flags 601\n+\n+class name com\/sun\/jdi\/PrimitiveType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Type flags 601\n+\n+class name com\/sun\/jdi\/PrimitiveValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Value flags 601\n+\n+class name com\/sun\/jdi\/ReferenceType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Type,java\/lang\/Comparable,com\/sun\/jdi\/Accessible flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/Type;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/ReferenceType;>;Lcom\/sun\/jdi\/Accessible;\n+\n+class name com\/sun\/jdi\/ShortType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/ShortValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/ShortValue;>;\n+\n+class name com\/sun\/jdi\/StackFrame\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror,com\/sun\/jdi\/Locatable flags 601\n+\n+class name com\/sun\/jdi\/StringReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/ThreadGroupReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/ThreadReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/Type\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/TypeComponent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror,com\/sun\/jdi\/Accessible flags 601\n+\n+class name com\/sun\/jdi\/VMCannotBeModifiedException\n+header extends java\/lang\/UnsupportedOperationException flags 21\n+\n+class name com\/sun\/jdi\/VMDisconnectedException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/VMMismatchException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/VMOutOfMemoryException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/Value\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/VirtualMachine\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/VirtualMachineManager\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/jdi\/VoidType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Type flags 601\n+\n+class name com\/sun\/jdi\/VoidValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Value flags 601\n+\n+class name com\/sun\/jdi\/connect\/AttachingConnector\n+header extends java\/lang\/Object implements com\/sun\/jdi\/connect\/Connector flags 601\n+innerclass innerClass com\/sun\/jdi\/connect\/Connector$Argument outerClass com\/sun\/jdi\/connect\/Connector innerClassName Argument flags 609\n+\n+class name com\/sun\/jdi\/connect\/IllegalConnectorArgumentsException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/connect\/LaunchingConnector\n+header extends java\/lang\/Object implements com\/sun\/jdi\/connect\/Connector flags 601\n+innerclass innerClass com\/sun\/jdi\/connect\/Connector$Argument outerClass com\/sun\/jdi\/connect\/Connector innerClassName Argument flags 609\n+\n+class name com\/sun\/jdi\/connect\/ListeningConnector\n+header extends java\/lang\/Object implements com\/sun\/jdi\/connect\/Connector flags 601\n+innerclass innerClass com\/sun\/jdi\/connect\/Connector$Argument outerClass com\/sun\/jdi\/connect\/Connector innerClassName Argument flags 609\n+\n+class name com\/sun\/jdi\/connect\/Transport\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/jdi\/connect\/TransportTimeoutException\n+header extends java\/io\/IOException flags 21\n+\n+class name com\/sun\/jdi\/connect\/VMStartException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/connect\/spi\/ClosedConnectionException\n+header extends java\/io\/IOException flags 21\n+\n+class name com\/sun\/jdi\/connect\/spi\/Connection\n+header extends java\/lang\/Object flags 421\n+\n+class name com\/sun\/jdi\/event\/AccessWatchpointEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/WatchpointEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/BreakpointEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/ClassPrepareEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/ClassUnloadEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/Event\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/event\/EventIterator\n+header extends java\/lang\/Object implements java\/util\/Iterator flags 601 signature Ljava\/lang\/Object;Ljava\/util\/Iterator<Lcom\/sun\/jdi\/event\/Event;>;\n+\n+class name com\/sun\/jdi\/event\/EventQueue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/event\/EventSet\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror,java\/util\/Set flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/Mirror;Ljava\/util\/Set<Lcom\/sun\/jdi\/event\/Event;>;\n+\n+class name com\/sun\/jdi\/event\/ExceptionEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/LocatableEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event,com\/sun\/jdi\/Locatable flags 601\n+\n+class name com\/sun\/jdi\/event\/MethodEntryEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/MethodExitEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/ModificationWatchpointEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/WatchpointEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/MonitorContendedEnterEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/MonitorContendedEnteredEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/MonitorWaitEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/MonitorWaitedEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/StepEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/ThreadDeathEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/ThreadStartEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/VMDeathEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/VMDisconnectEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/VMStartEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/WatchpointEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/request\/AccessWatchpointRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/WatchpointRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/BreakpointRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest,com\/sun\/jdi\/Locatable flags 601\n+\n+class name com\/sun\/jdi\/request\/ClassPrepareRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/ClassUnloadRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/DuplicateRequestException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/request\/EventRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/request\/EventRequestManager\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/request\/ExceptionRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/InvalidRequestStateException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/request\/MethodEntryRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/MethodExitRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/ModificationWatchpointRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/WatchpointRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/MonitorContendedEnterRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/MonitorContendedEnteredRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/MonitorWaitRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/MonitorWaitedRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/StepRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/ThreadDeathRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/ThreadStartRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/VMDeathRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/WatchpointRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.jdi-K.sym.txt","additions":395,"deletions":0,"binary":false,"changes":395,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+#\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/jfr\/consumer\/RecordedObject\n+header extends java\/lang\/Object sealed true flags 21\n+\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.jfr-K.sym.txt","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+#\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+module name jdk.jlink\n+header requires name\\u0020;java.base\\u0020;flags\\u0020;8000,name\\u0020;jdk.internal.opt\\u0020;flags\\u0020;0,name\\u0020;jdk.jdeps\\u0020;flags\\u0020;0 uses jdk\/tools\/jlink\/plugin\/Plugin provides interface\\u0020;java\/util\/spi\/ToolProvider\\u0020;impls\\u0020;jdk\/tools\/jmod\/Main$JmodToolProvider\\u005C;u002C;jdk\/tools\/jlink\/internal\/Main$JlinkToolProvider,interface\\u0020;jdk\/tools\/jlink\/plugin\/Plugin\\u0020;impls\\u0020;jdk\/tools\/jlink\/internal\/plugins\/DefaultStripDebugPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/StripJavaDebugAttributesPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/ExcludePlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/ExcludeFilesPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/ExcludeJmodSectionPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/LegalNoticeFilePlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/SystemModulesPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/StripNativeCommandsPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/OrderResourcesPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/DefaultCompressPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/ExcludeVMPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/IncludeLocalesPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/GenerateJLIClassesPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/ReleaseInfoPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/AddOptionsPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/VendorBugURLPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/VendorVMBugURLPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/VendorVersionPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/CDSPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/SaveJlinkArgfilesPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/StripNativeDebugSymbolsPlugin target linux-amd64 flags 8000\n+\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.jlink-K.sym.txt","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+#\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+module name jdk.jpackage\n+header requires name\\u0020;java.base\\u0020;flags\\u0020;8000,name\\u0020;jdk.internal.opt\\u0020;flags\\u0020;0,name\\u0020;jdk.jlink\\u0020;flags\\u0020;0,name\\u0020;java.desktop\\u0020;flags\\u0020;0 uses jdk\/jpackage\/internal\/Bundler,jdk\/jpackage\/internal\/Bundlers provides interface\\u0020;java\/util\/spi\/ToolProvider\\u0020;impls\\u0020;jdk\/jpackage\/internal\/JPackageToolProvider,interface\\u0020;jdk\/jpackage\/internal\/Bundler\\u0020;impls\\u0020;jdk\/jpackage\/internal\/LinuxAppBundler\\u005C;u002C;jdk\/jpackage\/internal\/LinuxDebBundler\\u005C;u002C;jdk\/jpackage\/internal\/LinuxRpmBundler,interface\\u0020;jdk\/jpackage\/internal\/Bundlers\\u0020;impls\\u0020;jdk\/jpackage\/internal\/BasicBundlers target linux-amd64 flags 8000\n+\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.jpackage-K.sym.txt","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,135 @@\n+#\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/jshell\/DeclarationSnippet\n+header extends jdk\/jshell\/PersistentSnippet flags 421\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/jshell\/Diag\n+header extends java\/lang\/Object flags 421\n+\n+class name jdk\/jshell\/EvalException\n+header extends jdk\/jshell\/JShellException flags 21\n+\n+class name jdk\/jshell\/ExpressionSnippet\n+header extends jdk\/jshell\/Snippet flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/ImportSnippet\n+header extends jdk\/jshell\/PersistentSnippet flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/JShellException\n+header extends java\/lang\/Exception flags 21\n+\n+class name jdk\/jshell\/MethodSnippet\n+header extends jdk\/jshell\/DeclarationSnippet flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/PersistentSnippet\n+header extends jdk\/jshell\/Snippet flags 421\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/SnippetEvent\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$Status outerClass jdk\/jshell\/Snippet innerClassName Status flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/jshell\/StatementSnippet\n+header extends jdk\/jshell\/Snippet flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/TypeDeclSnippet\n+header extends jdk\/jshell\/DeclarationSnippet flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/execution\/DirectExecutionControl\n+header extends java\/lang\/Object implements jdk\/jshell\/spi\/ExecutionControl flags 21\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$ClassBytecodes outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName ClassBytecodes flags 19\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$NotImplementedException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName NotImplementedException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$InternalException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName InternalException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$RunException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName RunException flags 409\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$EngineTerminationException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName EngineTerminationException flags 9\n+innerclass innerClass java\/util\/PrimitiveIterator$OfInt outerClass java\/util\/PrimitiveIterator innerClassName OfInt flags 609\n+innerclass innerClass java\/lang\/Character$UnicodeBlock outerClass java\/lang\/Character innerClassName UnicodeBlock flags 19\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$ResolutionException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName ResolutionException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$UserException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName UserException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$ClassInstallException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName ClassInstallException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$ExecutionControlException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName ExecutionControlException flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/jshell\/execution\/FailOverExecutionControlProvider\n+header extends java\/lang\/Object implements jdk\/jshell\/spi\/ExecutionControlProvider flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/jshell\/execution\/JdiDefaultExecutionControl\n+header extends jdk\/jshell\/execution\/JdiExecutionControl flags 21\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$InternalException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName InternalException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$EngineTerminationException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName EngineTerminationException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$RunException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName RunException flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/jshell\/execution\/JdiExecutionControlProvider\n+header extends java\/lang\/Object implements jdk\/jshell\/spi\/ExecutionControlProvider flags 21\n+\n+class name jdk\/jshell\/execution\/LoaderDelegate\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$ClassBytecodes outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName ClassBytecodes flags 19\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$ClassInstallException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName ClassInstallException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$NotImplementedException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName NotImplementedException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$EngineTerminationException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName EngineTerminationException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$InternalException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName InternalException flags 9\n+\n+class name jdk\/jshell\/execution\/LocalExecutionControl\n+header extends jdk\/jshell\/execution\/DirectExecutionControl flags 21\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$ClassBytecodes outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName ClassBytecodes flags 19\n+innerclass innerClass java\/lang\/Thread$UncaughtExceptionHandler outerClass java\/lang\/Thread innerClassName UncaughtExceptionHandler flags 609\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$StoppedException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName StoppedException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$InternalException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName InternalException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$ClassInstallException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName ClassInstallException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$NotImplementedException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName NotImplementedException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$EngineTerminationException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName EngineTerminationException flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name load descriptor ([Ljdk\/jshell\/spi\/ExecutionControl$ClassBytecodes;)V thrownTypes jdk\/jshell\/spi\/ExecutionControl$ClassInstallException,jdk\/jshell\/spi\/ExecutionControl$NotImplementedException,jdk\/jshell\/spi\/ExecutionControl$EngineTerminationException flags 1\n+\n+class name jdk\/jshell\/execution\/LocalExecutionControlProvider\n+header extends java\/lang\/Object implements jdk\/jshell\/spi\/ExecutionControlProvider flags 21\n+\n+class name jdk\/jshell\/spi\/ExecutionControlProvider\n+header extends java\/lang\/Object flags 601\n+\n+class name jdk\/jshell\/spi\/ExecutionEnv\n+header extends java\/lang\/Object flags 601\n+\n+class name jdk\/jshell\/spi\/SPIResolutionException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name jdk\/jshell\/tool\/JavaShellToolBuilder\n+header extends java\/lang\/Object flags 601\n+\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.jshell-K.sym.txt","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.jsobject-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.jsobject-J.sym.txt","status":"copied"},{"patch":"@@ -0,0 +1,46 @@\n+#\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/management\/GarbageCollectionNotificationInfo\n+header extends java\/lang\/Object implements javax\/management\/openmbean\/CompositeDataView flags 21\n+\n+class name com\/sun\/management\/GarbageCollectorMXBean\n+header extends java\/lang\/Object implements java\/lang\/management\/GarbageCollectorMXBean flags 601\n+\n+class name com\/sun\/management\/GcInfo\n+header extends java\/lang\/Object implements javax\/management\/openmbean\/CompositeData,javax\/management\/openmbean\/CompositeDataView flags 21\n+\n+class name com\/sun\/management\/OperatingSystemMXBean\n+header extends java\/lang\/Object implements java\/lang\/management\/OperatingSystemMXBean flags 601\n+\n+class name com\/sun\/management\/ThreadMXBean\n+header extends java\/lang\/Object implements java\/lang\/management\/ThreadMXBean flags 601\n+\n+class name com\/sun\/management\/UnixOperatingSystemMXBean\n+header extends java\/lang\/Object implements com\/sun\/management\/OperatingSystemMXBean flags 601\n+\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.management-K.sym.txt","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+#\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/net\/NetworkPermission\n+header extends java\/security\/BasicPermission flags 31\n+\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.net-K.sym.txt","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.sctp-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.sctp-J.sym.txt","status":"copied"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.security.auth-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.security.auth-J.sym.txt","status":"copied"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.security.jgss-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.security.jgss-J.sym.txt","status":"copied"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.unsupported-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.unsupported-J.sym.txt","status":"copied"},{"patch":"","filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.xml.dom-K.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/data\/symbols\/jdk.xml.dom-J.sym.txt","status":"copied"},{"patch":"@@ -32,1 +32,1 @@\n-generate platforms 8:9:A:B:C:D:E:F:G:H:I:J\n+generate platforms 8:9:A:B:C:D:E:F:G:H:I:J:K\n@@ -45,0 +45,1 @@\n+platform version K base J files java.base-K.sym.txt:java.compiler-K.sym.txt:java.datatransfer-K.sym.txt:java.desktop-K.sym.txt:java.instrument-K.sym.txt:java.logging-K.sym.txt:java.management-K.sym.txt:java.management.rmi-K.sym.txt:java.naming-K.sym.txt:java.rmi-K.sym.txt:java.scripting-K.sym.txt:java.security.jgss-K.sym.txt:java.security.sasl-K.sym.txt:java.smartcardio-K.sym.txt:java.sql-K.sym.txt:java.sql.rowset-K.sym.txt:java.xml-K.sym.txt:java.xml.crypto-K.sym.txt:jdk.accessibility-K.sym.txt:jdk.attach-K.sym.txt:jdk.compiler-K.sym.txt:jdk.dynalink-K.sym.txt:jdk.httpserver-K.sym.txt:jdk.incubator.concurrent-K.sym.txt:jdk.incubator.vector-K.sym.txt:jdk.jartool-K.sym.txt:jdk.javadoc-K.sym.txt:jdk.jconsole-K.sym.txt:jdk.jdi-K.sym.txt:jdk.jfr-K.sym.txt:jdk.jlink-K.sym.txt:jdk.jpackage-K.sym.txt:jdk.jshell-K.sym.txt:jdk.jsobject-K.sym.txt:jdk.management-K.sym.txt:jdk.net-K.sym.txt:jdk.sctp-K.sym.txt:jdk.security.auth-K.sym.txt:jdk.security.jgss-K.sym.txt:jdk.unsupported-K.sym.txt:jdk.xml.dom-K.sym.txt\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/symbols","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -58,0 +60,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -708,0 +712,1 @@\n+        NIO_ACCESS.acquireSession(inBuffer);\n@@ -709,22 +714,17 @@\n-            ensureInitialized();\n-\n-            long inAddr = 0;\n-            byte[] in = null;\n-            int inOfs = 0;\n-            if (dataBuffer.size() > 0) {\n-                if (inLen > 0) {\n-                    byte[] temp = new byte[inLen];\n-                    inBuffer.get(temp);\n-                    dataBuffer.write(temp, 0, temp.length);\n-                }\n-                in = dataBuffer.toByteArray();\n-                inOfs = 0;\n-                inLen = in.length;\n-            } else {\n-                if (inBuffer instanceof DirectBuffer) {\n-                    inAddr = ((DirectBuffer) inBuffer).address();\n-                    inOfs = inBuffer.position();\n-                } else {\n-                    if (inBuffer.hasArray()) {\n-                        in = inBuffer.array();\n-                        inOfs = inBuffer.position() + inBuffer.arrayOffset();\n+            NIO_ACCESS.acquireSession(outBuffer);\n+            try {\n+                try {\n+                    ensureInitialized();\n+\n+                    long inAddr = 0;\n+                    byte[] in = null;\n+                    int inOfs = 0;\n+                    if (dataBuffer.size() > 0) {\n+                        if (inLen > 0) {\n+                            byte[] temp = new byte[inLen];\n+                            inBuffer.get(temp);\n+                            dataBuffer.write(temp, 0, temp.length);\n+                        }\n+                        in = dataBuffer.toByteArray();\n+                        inOfs = 0;\n+                        inLen = in.length;\n@@ -732,2 +732,26 @@\n-                        in = new byte[inLen];\n-                        inBuffer.get(in);\n+                        if (inBuffer instanceof DirectBuffer dInBuffer) {\n+                            inAddr = dInBuffer.address();\n+                            inOfs = inBuffer.position();\n+                        } else {\n+                            if (inBuffer.hasArray()) {\n+                                in = inBuffer.array();\n+                                inOfs = inBuffer.position() + inBuffer.arrayOffset();\n+                            } else {\n+                                in = new byte[inLen];\n+                                inBuffer.get(in);\n+                            }\n+                        }\n+                    }\n+                    long outAddr = 0;\n+                    byte[] outArray = null;\n+                    int outOfs = 0;\n+                    if (outBuffer instanceof DirectBuffer dOutBuffer) {\n+                        outAddr = dOutBuffer.address();\n+                        outOfs = outBuffer.position();\n+                    } else {\n+                        if (outBuffer.hasArray()) {\n+                            outArray = outBuffer.array();\n+                            outOfs = outBuffer.position() + outBuffer.arrayOffset();\n+                        } else {\n+                            outArray = new byte[outLen];\n+                        }\n@@ -735,16 +759,0 @@\n-                }\n-            }\n-            long outAddr = 0;\n-            byte[] outArray = null;\n-            int outOfs = 0;\n-            if (outBuffer instanceof DirectBuffer) {\n-                outAddr = ((DirectBuffer) outBuffer).address();\n-                outOfs = outBuffer.position();\n-            } else {\n-                if (outBuffer.hasArray()) {\n-                    outArray = outBuffer.array();\n-                    outOfs = outBuffer.position() + outBuffer.arrayOffset();\n-                } else {\n-                    outArray = new byte[outLen];\n-                }\n-            }\n@@ -752,9 +760,34 @@\n-            int k = 0;\n-            if (encrypt) {\n-                k = token.p11.C_Encrypt(session.id(), inAddr, in, inOfs, inLen,\n-                        outAddr, outArray, outOfs, outLen);\n-                doCancel = false;\n-            } else {\n-                \/\/ Special handling to match SunJCE provider behavior\n-                if (inLen == 0) {\n-                    return 0;\n+                    int k = 0;\n+                    if (encrypt) {\n+                        k = token.p11.C_Encrypt(session.id(), inAddr, in, inOfs, inLen,\n+                                outAddr, outArray, outOfs, outLen);\n+                        doCancel = false;\n+                    } else {\n+                        \/\/ Special handling to match SunJCE provider behavior\n+                        if (inLen == 0) {\n+                            return 0;\n+                        }\n+                        k = token.p11.C_Decrypt(session.id(), inAddr, in, inOfs, inLen,\n+                                outAddr, outArray, outOfs, outLen);\n+                        doCancel = false;\n+                    }\n+                    inBuffer.position(inBuffer.limit());\n+                    outBuffer.position(outBuffer.position() + k);\n+                    return k;\n+                } catch (PKCS11Exception e) {\n+                    \/\/ As per the PKCS#11 standard, C_Encrypt and C_Decrypt may only\n+                    \/\/ keep the operation active on CKR_BUFFER_TOO_SMALL errors or\n+                    \/\/ successful calls to determine the output length. However,\n+                    \/\/ these cases are not expected here because the output length\n+                    \/\/ is checked in the OpenJDK side before making the PKCS#11 call.\n+                    \/\/ Thus, doCancel can safely be 'false'.\n+                    doCancel = false;\n+                    handleException(e);\n+                    throw new ProviderException(\"doFinal() failed\", e);\n+                } finally {\n+                    if (encrypt) {\n+                        lastEncKey = this.p11Key;\n+                        lastEncIv = this.iv;\n+                        requireReinit = true;\n+                    }\n+                    reset(doCancel);\n@@ -762,3 +795,2 @@\n-                k = token.p11.C_Decrypt(session.id(), inAddr, in, inOfs, inLen,\n-                        outAddr, outArray, outOfs, outLen);\n-                doCancel = false;\n+            } finally {\n+                NIO_ACCESS.releaseSession(outBuffer);\n@@ -766,13 +798,0 @@\n-            inBuffer.position(inBuffer.limit());\n-            outBuffer.position(outBuffer.position() + k);\n-            return k;\n-        } catch (PKCS11Exception e) {\n-            \/\/ As per the PKCS#11 standard, C_Encrypt and C_Decrypt may only\n-            \/\/ keep the operation active on CKR_BUFFER_TOO_SMALL errors or\n-            \/\/ successful calls to determine the output length. However,\n-            \/\/ these cases are not expected here because the output length\n-            \/\/ is checked in the OpenJDK side before making the PKCS#11 call.\n-            \/\/ Thus, doCancel can safely be 'false'.\n-            doCancel = false;\n-            handleException(e);\n-            throw new ProviderException(\"doFinal() failed\", e);\n@@ -780,6 +799,1 @@\n-            if (encrypt) {\n-                lastEncKey = this.p11Key;\n-                lastEncIv = this.iv;\n-                requireReinit = true;\n-            }\n-            reset(doCancel);\n+            NIO_ACCESS.releaseSession(inBuffer);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11AEADCipher.java","additions":85,"deletions":71,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -59,0 +61,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -681,0 +685,1 @@\n+        NIO_ACCESS.acquireSession(inBuffer);\n@@ -682,13 +687,15 @@\n-            ensureInitialized();\n-\n-            long inAddr = 0;\n-            int inOfs = 0;\n-            byte[] inArray = null;\n-\n-            if (inBuffer instanceof DirectBuffer) {\n-                inAddr = ((DirectBuffer) inBuffer).address();\n-                inOfs = origPos;\n-            } else if (inBuffer.hasArray()) {\n-                inArray = inBuffer.array();\n-                inOfs = (origPos + inBuffer.arrayOffset());\n-            }\n+            NIO_ACCESS.acquireSession(outBuffer);\n+            try {\n+                ensureInitialized();\n+\n+                long inAddr = 0;\n+                int inOfs = 0;\n+                byte[] inArray = null;\n+\n+                if (inBuffer instanceof DirectBuffer dInBuffer) {\n+                    inAddr = dInBuffer.address();\n+                    inOfs = origPos;\n+                } else if (inBuffer.hasArray()) {\n+                    inArray = inBuffer.array();\n+                    inOfs = (origPos + inBuffer.arrayOffset());\n+                }\n@@ -696,10 +703,6 @@\n-            long outAddr = 0;\n-            int outOfs = 0;\n-            byte[] outArray = null;\n-            if (outBuffer instanceof DirectBuffer) {\n-                outAddr = ((DirectBuffer) outBuffer).address();\n-                outOfs = outBuffer.position();\n-            } else {\n-                if (outBuffer.hasArray()) {\n-                    outArray = outBuffer.array();\n-                    outOfs = (outBuffer.position() + outBuffer.arrayOffset());\n+                long outAddr = 0;\n+                int outOfs = 0;\n+                byte[] outArray = null;\n+                if (outBuffer instanceof DirectBuffer dOutBuffer) {\n+                    outAddr = dOutBuffer.address();\n+                    outOfs = outBuffer.position();\n@@ -707,1 +710,6 @@\n-                    outArray = new byte[outLen];\n+                    if (outBuffer.hasArray()) {\n+                        outArray = outBuffer.array();\n+                        outOfs = (outBuffer.position() + outBuffer.arrayOffset());\n+                    } else {\n+                        outArray = new byte[outLen];\n+                    }\n@@ -709,1 +717,0 @@\n-            }\n@@ -711,10 +718,19 @@\n-            int k = 0;\n-            int newPadBufferLen = 0;\n-            if (paddingObj != null  && (!encrypt || reqBlockUpdates)) {\n-                if (padBufferLen != 0) {\n-                    if (padBufferLen != padBuffer.length) {\n-                        int bufCapacity = padBuffer.length - padBufferLen;\n-                        if (inLen > bufCapacity) {\n-                            bufferInputBytes(inBuffer, bufCapacity);\n-                            inOfs += bufCapacity;\n-                            inLen -= bufCapacity;\n+                int k = 0;\n+                int newPadBufferLen = 0;\n+                if (paddingObj != null && (!encrypt || reqBlockUpdates)) {\n+                    if (padBufferLen != 0) {\n+                        if (padBufferLen != padBuffer.length) {\n+                            int bufCapacity = padBuffer.length - padBufferLen;\n+                            if (inLen > bufCapacity) {\n+                                bufferInputBytes(inBuffer, bufCapacity);\n+                                inOfs += bufCapacity;\n+                                inLen -= bufCapacity;\n+                            } else {\n+                                bufferInputBytes(inBuffer, inLen);\n+                                return 0;\n+                            }\n+                        }\n+                        if (encrypt) {\n+                            k = token.p11.C_EncryptUpdate(session.id(), 0,\n+                                    padBuffer, 0, padBufferLen, outAddr, outArray,\n+                                    outOfs, outLen);\n@@ -722,2 +738,3 @@\n-                            bufferInputBytes(inBuffer, inLen);\n-                            return 0;\n+                            k = token.p11.C_DecryptUpdate(session.id(), 0,\n+                                    padBuffer, 0, padBufferLen, outAddr, outArray,\n+                                    outOfs, outLen);\n@@ -725,0 +742,19 @@\n+                        padBufferLen = 0;\n+                    }\n+                    newPadBufferLen = inLen & (blockSize - 1);\n+                    if (!encrypt && newPadBufferLen == 0) {\n+                        \/\/ While decrypting with implUpdate, the last encrypted block\n+                        \/\/ is always held in a buffer. If it's the final one (unknown\n+                        \/\/ at this point), it may contain padding bytes and need further\n+                        \/\/ processing. In implDoFinal (where we know it's the final one)\n+                        \/\/ the buffer is decrypted, unpadded and returned.\n+                        newPadBufferLen = padBuffer.length;\n+                    }\n+                    inLen -= newPadBufferLen;\n+                }\n+                if (inLen > 0) {\n+                    if (inAddr == 0 && inArray == null) {\n+                        inArray = new byte[inLen];\n+                        inBuffer.get(inArray);\n+                    } else {\n+                        inBuffer.position(inBuffer.position() + inLen);\n@@ -727,3 +763,3 @@\n-                        k = token.p11.C_EncryptUpdate(session.id(), 0,\n-                                padBuffer, 0, padBufferLen, outAddr, outArray,\n-                                outOfs, outLen);\n+                        k += token.p11.C_EncryptUpdate(session.id(), inAddr,\n+                                inArray, inOfs, inLen, outAddr, outArray,\n+                                (outOfs + k), (outLen - k));\n@@ -731,3 +767,3 @@\n-                        k = token.p11.C_DecryptUpdate(session.id(), 0,\n-                                padBuffer, 0, padBufferLen, outAddr, outArray,\n-                                outOfs, outLen);\n+                        k += token.p11.C_DecryptUpdate(session.id(), inAddr,\n+                                inArray, inOfs, inLen, outAddr, outArray,\n+                                (outOfs + k), (outLen - k));\n@@ -735,1 +771,0 @@\n-                    padBufferLen = 0;\n@@ -737,8 +772,3 @@\n-                newPadBufferLen = inLen & (blockSize - 1);\n-                if (!encrypt && newPadBufferLen == 0) {\n-                    \/\/ While decrypting with implUpdate, the last encrypted block\n-                    \/\/ is always held in a buffer. If it's the final one (unknown\n-                    \/\/ at this point), it may contain padding bytes and need further\n-                    \/\/ processing. In implDoFinal (where we know it's the final one)\n-                    \/\/ the buffer is decrypted, unpadded and returned.\n-                    newPadBufferLen = padBuffer.length;\n+                \/\/ update 'padBuffer' if using our own padding impl.\n+                if (paddingObj != null && newPadBufferLen > 0) {\n+                    bufferInputBytes(inBuffer, newPadBufferLen);\n@@ -746,6 +776,4 @@\n-                inLen -= newPadBufferLen;\n-            }\n-            if (inLen > 0) {\n-                if (inAddr == 0 && inArray == null) {\n-                    inArray = new byte[inLen];\n-                    inBuffer.get(inArray);\n+                bytesBuffered += (inLen - k);\n+                if (!(outBuffer instanceof DirectBuffer) &&\n+                        !outBuffer.hasArray()) {\n+                    outBuffer.put(outArray, outOfs, k);\n@@ -753,1 +781,1 @@\n-                    inBuffer.position(inBuffer.position() + inLen);\n+                    outBuffer.position(outBuffer.position() + k);\n@@ -755,8 +783,7 @@\n-                if (encrypt) {\n-                    k += token.p11.C_EncryptUpdate(session.id(), inAddr,\n-                            inArray, inOfs, inLen, outAddr, outArray,\n-                            (outOfs + k), (outLen - k));\n-                } else {\n-                    k += token.p11.C_DecryptUpdate(session.id(), inAddr,\n-                            inArray, inOfs, inLen, outAddr, outArray,\n-                            (outOfs + k), (outLen - k));\n+                return k;\n+            } catch (PKCS11Exception e) {\n+                \/\/ Reset input buffer to its original position for\n+                inBuffer.position(origPos);\n+                if (e.match(CKR_BUFFER_TOO_SMALL)) {\n+                    throw (ShortBufferException)\n+                            (new ShortBufferException().initCause(e));\n@@ -764,0 +791,8 @@\n+                \/\/ Some implementations such as the NSS Software Token do not\n+                \/\/ cancel the operation upon a C_EncryptUpdate\/C_DecryptUpdate\n+                \/\/ failure (as required by the PKCS#11 standard). See JDK-8258833\n+                \/\/ for further information.\n+                reset(true);\n+                throw new ProviderException(\"update() failed\", e);\n+            } finally {\n+                NIO_ACCESS.releaseSession(outBuffer);\n@@ -765,25 +800,2 @@\n-            \/\/ update 'padBuffer' if using our own padding impl.\n-            if (paddingObj != null && newPadBufferLen > 0) {\n-                bufferInputBytes(inBuffer, newPadBufferLen);\n-            }\n-            bytesBuffered += (inLen - k);\n-            if (!(outBuffer instanceof DirectBuffer) &&\n-                    !outBuffer.hasArray()) {\n-                outBuffer.put(outArray, outOfs, k);\n-            } else {\n-                outBuffer.position(outBuffer.position() + k);\n-            }\n-            return k;\n-        } catch (PKCS11Exception e) {\n-            \/\/ Reset input buffer to its original position for\n-            inBuffer.position(origPos);\n-            if (e.match(CKR_BUFFER_TOO_SMALL)) {\n-                throw (ShortBufferException)\n-                        (new ShortBufferException().initCause(e));\n-            }\n-            \/\/ Some implementations such as the NSS Software Token do not\n-            \/\/ cancel the operation upon a C_EncryptUpdate\/C_DecryptUpdate\n-            \/\/ failure (as required by the PKCS#11 standard). See JDK-8258833\n-            \/\/ for further information.\n-            reset(true);\n-            throw new ProviderException(\"update() failed\", e);\n+        } finally {\n+            NIO_ACCESS.releaseSession(inBuffer);\n@@ -880,0 +892,1 @@\n+        NIO_ACCESS.acquireSession(outBuffer);\n@@ -881,12 +894,9 @@\n-            ensureInitialized();\n-\n-            long outAddr = 0;\n-            byte[] outArray = null;\n-            int outOfs = 0;\n-            if (outBuffer instanceof DirectBuffer) {\n-                outAddr = ((DirectBuffer) outBuffer).address();\n-                outOfs = outBuffer.position();\n-            } else {\n-                if (outBuffer.hasArray()) {\n-                    outArray = outBuffer.array();\n-                    outOfs = outBuffer.position() + outBuffer.arrayOffset();\n+            try {\n+                ensureInitialized();\n+\n+                long outAddr = 0;\n+                byte[] outArray = null;\n+                int outOfs = 0;\n+                if (outBuffer instanceof DirectBuffer dOutBuffer) {\n+                    outAddr = dOutBuffer.address();\n+                    outOfs = outBuffer.position();\n@@ -894,1 +904,6 @@\n-                    outArray = new byte[outLen];\n+                    if (outBuffer.hasArray()) {\n+                        outArray = outBuffer.array();\n+                        outOfs = outBuffer.position() + outBuffer.arrayOffset();\n+                    } else {\n+                        outArray = new byte[outLen];\n+                    }\n@@ -896,1 +911,0 @@\n-            }\n@@ -898,1 +912,1 @@\n-            int k = 0;\n+                int k = 0;\n@@ -900,12 +914,13 @@\n-            if (encrypt) {\n-                if (paddingObj != null) {\n-                    int startOff = 0;\n-                    if (reqBlockUpdates) {\n-                        \/\/ call C_EncryptUpdate first if the padBuffer is full\n-                        \/\/ to make room for padding bytes\n-                        if (padBufferLen == padBuffer.length) {\n-                            k = token.p11.C_EncryptUpdate(session.id(),\n-                                0, padBuffer, 0, padBufferLen,\n-                                outAddr, outArray, outOfs, outLen);\n-                        } else {\n-                            startOff = padBufferLen;\n+                if (encrypt) {\n+                    if (paddingObj != null) {\n+                        int startOff = 0;\n+                        if (reqBlockUpdates) {\n+                            \/\/ call C_EncryptUpdate first if the padBuffer is full\n+                            \/\/ to make room for padding bytes\n+                            if (padBufferLen == padBuffer.length) {\n+                                k = token.p11.C_EncryptUpdate(session.id(),\n+                                        0, padBuffer, 0, padBufferLen,\n+                                        outAddr, outArray, outOfs, outLen);\n+                            } else {\n+                                startOff = padBufferLen;\n+                            }\n@@ -913,27 +928,5 @@\n-                    }\n-                    int actualPadLen = paddingObj.setPaddingBytes(padBuffer,\n-                            startOff, requiredOutLen - bytesBuffered);\n-                    k += token.p11.C_EncryptUpdate(session.id(),\n-                            0, padBuffer, 0, startOff + actualPadLen,\n-                            outAddr, outArray, outOfs + k, outLen - k);\n-                }\n-                \/\/ Some implementations such as the NSS Software Token do not\n-                \/\/ cancel the operation upon a C_EncryptUpdate failure (as\n-                \/\/ required by the PKCS#11 standard). Cancel is not needed\n-                \/\/ only after this point. See JDK-8258833 for further\n-                \/\/ information.\n-                doCancel = false;\n-                k += token.p11.C_EncryptFinal(session.id(),\n-                        outAddr, outArray, (outOfs + k), (outLen - k));\n-            } else {\n-                \/\/ Special handling to match SunJCE provider behavior\n-                if (bytesBuffered == 0 && padBufferLen == 0) {\n-                    return 0;\n-                }\n-\n-                if (paddingObj != null) {\n-                    if (padBufferLen != 0) {\n-                        k = token.p11.C_DecryptUpdate(session.id(),\n-                                0, padBuffer, 0, padBufferLen,\n-                                0, padBuffer, 0, padBuffer.length);\n-                        padBufferLen = 0;\n+                        int actualPadLen = paddingObj.setPaddingBytes(padBuffer,\n+                                startOff, requiredOutLen - bytesBuffered);\n+                        k += token.p11.C_EncryptUpdate(session.id(),\n+                                0, padBuffer, 0, startOff + actualPadLen,\n+                                outAddr, outArray, outOfs + k, outLen - k);\n@@ -942,1 +935,1 @@\n-                    \/\/ cancel the operation upon a C_DecryptUpdate failure (as\n+                    \/\/ cancel the operation upon a C_EncryptUpdate failure (as\n@@ -947,2 +940,7 @@\n-                    k += token.p11.C_DecryptFinal(session.id(),\n-                            0, padBuffer, k, padBuffer.length - k);\n+                    k += token.p11.C_EncryptFinal(session.id(),\n+                            outAddr, outArray, (outOfs + k), (outLen - k));\n+                } else {\n+                    \/\/ Special handling to match SunJCE provider behavior\n+                    if (bytesBuffered == 0 && padBufferLen == 0) {\n+                        return 0;\n+                    }\n@@ -950,4 +948,30 @@\n-                    int actualPadLen = paddingObj.unpad(padBuffer, k);\n-                    k -= actualPadLen;\n-                    outArray = padBuffer;\n-                    outOfs = 0;\n+                    if (paddingObj != null) {\n+                        if (padBufferLen != 0) {\n+                            k = token.p11.C_DecryptUpdate(session.id(),\n+                                    0, padBuffer, 0, padBufferLen,\n+                                    0, padBuffer, 0, padBuffer.length);\n+                            padBufferLen = 0;\n+                        }\n+                        \/\/ Some implementations such as the NSS Software Token do not\n+                        \/\/ cancel the operation upon a C_DecryptUpdate failure (as\n+                        \/\/ required by the PKCS#11 standard). Cancel is not needed\n+                        \/\/ only after this point. See JDK-8258833 for further\n+                        \/\/ information.\n+                        doCancel = false;\n+                        k += token.p11.C_DecryptFinal(session.id(),\n+                                0, padBuffer, k, padBuffer.length - k);\n+\n+                        int actualPadLen = paddingObj.unpad(padBuffer, k);\n+                        k -= actualPadLen;\n+                        outArray = padBuffer;\n+                        outOfs = 0;\n+                    } else {\n+                        doCancel = false;\n+                        k = token.p11.C_DecryptFinal(session.id(),\n+                                outAddr, outArray, outOfs, outLen);\n+                    }\n+                }\n+                if ((!encrypt && paddingObj != null) ||\n+                        (!(outBuffer instanceof DirectBuffer) &&\n+                                !outBuffer.hasArray())) {\n+                    outBuffer.put(outArray, outOfs, k);\n@@ -955,3 +979,1 @@\n-                    doCancel = false;\n-                    k = token.p11.C_DecryptFinal(session.id(),\n-                            outAddr, outArray, outOfs, outLen);\n+                    outBuffer.position(outBuffer.position() + k);\n@@ -959,0 +981,6 @@\n+                return k;\n+            } catch (PKCS11Exception e) {\n+                handleException(e);\n+                throw new ProviderException(\"doFinal() failed\", e);\n+            } finally {\n+                reset(doCancel);\n@@ -960,11 +988,0 @@\n-            if ((!encrypt && paddingObj != null) ||\n-                    (!(outBuffer instanceof DirectBuffer) &&\n-                    !outBuffer.hasArray())) {\n-                outBuffer.put(outArray, outOfs, k);\n-            } else {\n-                outBuffer.position(outBuffer.position() + k);\n-            }\n-            return k;\n-        } catch (PKCS11Exception e) {\n-            handleException(e);\n-            throw new ProviderException(\"doFinal() failed\", e);\n@@ -972,1 +989,1 @@\n-            reset(doCancel);\n+            NIO_ACCESS.releaseSession(outBuffer);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Cipher.java","additions":185,"deletions":168,"binary":false,"changes":353,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.util.*;\n@@ -35,0 +34,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -58,0 +59,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -271,1 +274,1 @@\n-        if (!(byteBuffer instanceof DirectBuffer)) {\n+        if (!(byteBuffer instanceof DirectBuffer dByteBuffer)) {\n@@ -277,1 +280,0 @@\n-        long addr = ((DirectBuffer)byteBuffer).address();\n@@ -288,1 +290,6 @@\n-            token.p11.C_DigestUpdate(session.id(), addr + ofs, null, 0, len);\n+            NIO_ACCESS.acquireSession(byteBuffer);\n+            try {\n+                token.p11.C_DigestUpdate(session.id(), dByteBuffer.address() + ofs, null, 0, len);\n+            } finally {\n+                NIO_ACCESS.releaseSession(byteBuffer);\n+            }\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Digest.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -46,1 +48,0 @@\n-import static sun.security.pkcs11.P11Cipher.*;\n@@ -61,0 +62,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -555,0 +558,1 @@\n+        NIO_ACCESS.acquireSession(inBuffer);\n@@ -556,24 +560,19 @@\n-            ensureInitialized();\n-\n-            long inAddr = 0;\n-            byte[] in = null;\n-            int inOfs = 0;\n-\n-            if (dataBuffer.size() > 0) {\n-                if (inBuffer != null && inLen > 0) {\n-                    byte[] temp = new byte[inLen];\n-                    inBuffer.get(temp);\n-                    dataBuffer.write(temp, 0, temp.length);\n-                }\n-\n-                in = dataBuffer.toByteArray();\n-                inOfs = 0;\n-                inLen = in.length;\n-            } else {\n-                if (inBuffer instanceof DirectBuffer) {\n-                    inAddr = ((DirectBuffer) inBuffer).address();\n-                    inOfs = inBuffer.position();\n-                } else {\n-                    if (inBuffer.hasArray()) {\n-                        in = inBuffer.array();\n-                        inOfs = inBuffer.position() + inBuffer.arrayOffset();\n+            NIO_ACCESS.acquireSession(outBuffer);\n+            try {\n+                try {\n+                    ensureInitialized();\n+\n+                    long inAddr = 0;\n+                    byte[] in = null;\n+                    int inOfs = 0;\n+\n+                    if (dataBuffer.size() > 0) {\n+                        if (inBuffer != null && inLen > 0) {\n+                            byte[] temp = new byte[inLen];\n+                            inBuffer.get(temp);\n+                            dataBuffer.write(temp, 0, temp.length);\n+                        }\n+\n+                        in = dataBuffer.toByteArray();\n+                        inOfs = 0;\n+                        inLen = in.length;\n@@ -581,2 +580,26 @@\n-                        in = new byte[inLen];\n-                        inBuffer.get(in);\n+                        if (inBuffer instanceof DirectBuffer dInBuffer) {\n+                            inAddr = dInBuffer.address();\n+                            inOfs = inBuffer.position();\n+                        } else {\n+                            if (inBuffer.hasArray()) {\n+                                in = inBuffer.array();\n+                                inOfs = inBuffer.position() + inBuffer.arrayOffset();\n+                            } else {\n+                                in = new byte[inLen];\n+                                inBuffer.get(in);\n+                            }\n+                        }\n+                    }\n+                    long outAddr = 0;\n+                    byte[] outArray = null;\n+                    int outOfs = 0;\n+                    if (outBuffer instanceof DirectBuffer dOutBuffer) {\n+                        outAddr = dOutBuffer.address();\n+                        outOfs = outBuffer.position();\n+                    } else {\n+                        if (outBuffer.hasArray()) {\n+                            outArray = outBuffer.array();\n+                            outOfs = outBuffer.position() + outBuffer.arrayOffset();\n+                        } else {\n+                            outArray = new byte[outLen];\n+                        }\n@@ -584,16 +607,0 @@\n-                }\n-            }\n-            long outAddr = 0;\n-            byte[] outArray = null;\n-            int outOfs = 0;\n-            if (outBuffer instanceof DirectBuffer) {\n-                outAddr = ((DirectBuffer) outBuffer).address();\n-                outOfs = outBuffer.position();\n-            } else {\n-                if (outBuffer.hasArray()) {\n-                    outArray = outBuffer.array();\n-                    outOfs = outBuffer.position() + outBuffer.arrayOffset();\n-                } else {\n-                    outArray = new byte[outLen];\n-                }\n-            }\n@@ -601,8 +608,26 @@\n-            if (opmode == Cipher.ENCRYPT_MODE) {\n-                k = token.p11.C_Encrypt(session.id(), inAddr, in, inOfs, inLen,\n-                        outAddr, outArray, outOfs, outLen);\n-                doCancel = false;\n-            } else {\n-                \/\/ Special handling to match SunJCE provider behavior\n-                if (inLen == 0) {\n-                    return 0;\n+                    if (opmode == Cipher.ENCRYPT_MODE) {\n+                        k = token.p11.C_Encrypt(session.id(), inAddr, in, inOfs, inLen,\n+                                outAddr, outArray, outOfs, outLen);\n+                        doCancel = false;\n+                    } else {\n+                        \/\/ Special handling to match SunJCE provider behavior\n+                        if (inLen == 0) {\n+                            return 0;\n+                        }\n+                        k = token.p11.C_Decrypt(session.id(), inAddr, in, inOfs, inLen,\n+                                outAddr, outArray, outOfs, outLen);\n+                        doCancel = false;\n+                    }\n+                    inBuffer.position(inBuffer.limit());\n+                    outBuffer.position(outBuffer.position() + k);\n+                } catch (PKCS11Exception e) {\n+                    \/\/ As per the PKCS#11 standard, C_Encrypt and C_Decrypt may only\n+                    \/\/ keep the operation active on CKR_BUFFER_TOO_SMALL errors or\n+                    \/\/ successful calls to determine the output length. However,\n+                    \/\/ these cases are not expected here because the output length\n+                    \/\/ is checked in the OpenJDK side before making the PKCS#11 call.\n+                    \/\/ Thus, doCancel can safely be 'false'.\n+                    doCancel = false;\n+                    handleEncException(\"doFinal() failed\", e);\n+                } finally {\n+                    reset(doCancel);\n@@ -610,3 +635,2 @@\n-                k = token.p11.C_Decrypt(session.id(), inAddr, in, inOfs, inLen,\n-                        outAddr, outArray, outOfs, outLen);\n-                doCancel = false;\n+            } finally {\n+                NIO_ACCESS.releaseSession(outBuffer);\n@@ -614,11 +638,0 @@\n-            inBuffer.position(inBuffer.limit());\n-            outBuffer.position(outBuffer.position() + k);\n-        } catch (PKCS11Exception e) {\n-            \/\/ As per the PKCS#11 standard, C_Encrypt and C_Decrypt may only\n-            \/\/ keep the operation active on CKR_BUFFER_TOO_SMALL errors or\n-            \/\/ successful calls to determine the output length. However,\n-            \/\/ these cases are not expected here because the output length\n-            \/\/ is checked in the OpenJDK side before making the PKCS#11 call.\n-            \/\/ Thus, doCancel can safely be 'false'.\n-            doCancel = false;\n-            handleEncException(\"doFinal() failed\", e);\n@@ -626,1 +639,1 @@\n-            reset(doCancel);\n+            NIO_ACCESS.releaseSession(inBuffer);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyWrapCipher.java","additions":79,"deletions":66,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -58,0 +60,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -249,1 +253,1 @@\n-            if (!(byteBuffer instanceof DirectBuffer directBuffer)) {\n+            if (!(byteBuffer instanceof DirectBuffer dByteBuffer)) {\n@@ -253,1 +257,0 @@\n-            long addr = directBuffer.address();\n@@ -255,1 +258,6 @@\n-            token.p11.C_SignUpdate(session.id(), addr + ofs, null, 0, len);\n+            NIO_ACCESS.acquireSession(byteBuffer);\n+            try  {\n+                token.p11.C_SignUpdate(session.id(), dByteBuffer.address() + ofs, null, 0, len);\n+            } finally {\n+                NIO_ACCESS.releaseSession(byteBuffer);\n+            }\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Mac.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n@@ -31,0 +29,3 @@\n+\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -34,1 +35,0 @@\n-import java.util.Arrays;\n@@ -71,0 +71,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -616,1 +618,1 @@\n-                if (byteBuffer instanceof DirectBuffer == false) {\n+                if (!(byteBuffer instanceof DirectBuffer dByteBuffer)) {\n@@ -621,1 +623,0 @@\n-                long addr = ((DirectBuffer) byteBuffer).address();\n@@ -623,0 +624,1 @@\n+                NIO_ACCESS.acquireSession(byteBuffer);\n@@ -624,0 +626,1 @@\n+                    long addr = dByteBuffer.address();\n@@ -638,0 +641,2 @@\n+                } finally {\n+                    NIO_ACCESS.releaseSession(byteBuffer);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11PSSSignature.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -35,0 +35,3 @@\n+\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -38,1 +41,0 @@\n-import sun.security.x509.AlgorithmId;\n@@ -101,0 +103,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -578,1 +582,1 @@\n-                if (!(byteBuffer instanceof DirectBuffer)) {\n+                if (!(byteBuffer instanceof DirectBuffer dByteBuffer)) {\n@@ -583,1 +587,0 @@\n-                long addr = ((DirectBuffer) byteBuffer).address();\n@@ -585,0 +588,1 @@\n+                NIO_ACCESS.acquireSession(byteBuffer);\n@@ -586,0 +590,1 @@\n+                    long addr = dByteBuffer.address();\n@@ -598,0 +603,2 @@\n+                } finally {\n+                    NIO_ACCESS.releaseSession(byteBuffer);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Signature.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,838 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.incubator.concurrent;\n+\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.lang.ref.Reference;\n+import java.util.concurrent.Callable;\n+import java.util.function.Supplier;\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.JavaUtilConcurrentTLRAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Hidden;\n+import jdk.internal.vm.annotation.Stable;\n+import jdk.internal.vm.ScopedValueContainer;\n+import sun.security.action.GetPropertyAction;\n+\n+\/**\n+ * A value that is set once and is then available for reading for a bounded period of\n+ * execution by a thread. A {@code ScopedValue} allows for safely and efficiently sharing\n+ * data for a bounded period of execution without passing the data as method arguments.\n+ *\n+ * <p> {@code ScopedValue} defines the {@link #where(ScopedValue, Object, Runnable)}\n+ * method to set the value of a {@code ScopedValue} for the bouned period of execution by\n+ * a thread of the runnable's {@link Runnable#run() run} method. The unfolding execution of\n+ * the methods executed by {@code run} defines a <b><em>dynamic scope<\/em><\/b>. The scoped\n+ * value is {@linkplain #isBound() bound} while executing in the dynamic scope, it reverts\n+ * to being <em>unbound<\/em> when the {@code run} method completes (normally or with an\n+ * exception). Code executing in the dynamic scope uses the {@code ScopedValue} {@link\n+ * #get() get} method to read its value.\n+ *\n+ * <p> Like a {@linkplain ThreadLocal thread-local variable}, a scoped value has multiple\n+ * incarnations, one per thread. The particular incarnation that is used depends on which\n+ * thread calls its methods.\n+ *\n+ * <p> Consider the following example with a scoped value {@code USERNAME} that is\n+ * <em>bound<\/em> to the value \"{@code duke}\" for the execution, by a thread, of a run\n+ * method that invokes {@code doSomething()}.\n+ * {@snippet lang=java :\n+ *     \/\/ @link substring=\"newInstance\" target=\"#newInstance\" :\n+ *     private static final ScopedValue<String> USERNAME = ScopedValue.newInstance();\n+ *\n+ *     ScopedValue.where(USERNAME, \"duke\", () -> doSomething());\n+ * }\n+ * Code executed directly or indirectly by {@code doSomething()} that invokes {@code\n+ * USERNAME.get()} will read the value \"{@code duke}\". The scoped value is bound while\n+ * executing {@code doSomething()} and becomes unbound when {@code doSomething()}\n+ * completes (normally or with an exception). If one thread were to call {@code\n+ * doSomething()} with {@code USERNAME} bound to \"{@code duke1}\", and another thread\n+ * were to call the method with {@code USERNAME} bound to \"{@code duke2}\", then\n+ * {@code USERNAME.get()} would read the value \"{@code duke1}\" or \"{@code duke2}\",\n+ * depending on which thread is executing.\n+ *\n+ * <p> In addition to the {@code where} method that executes a {@code run} method, {@code\n+ * ScopedValue} defines the {@link #where(ScopedValue, Object, Callable)} method to execute\n+ * a method that returns a result. It also defines the {@link #where(ScopedValue, Object)}\n+ * method for cases where it is useful to accumulate mappings of {@code ScopedValue} to\n+ * value.\n+ *\n+ * <p> A {@code ScopedValue} will typically be declared in a {@code final} and {@code\n+ * static} field. The accessibility of the field will determine which components can\n+ * bind or read its value.\n+ *\n+ * <p> Unless otherwise specified, passing a {@code null} argument to a method in this\n+ * class will cause a {@link NullPointerException} to be thrown.\n+ *\n+ * <h2><a id=\"rebind\">Rebinding<\/a><\/h2>\n+ *\n+ * The {@code ScopedValue} API allows a new binding to be established for <em>nested\n+ * dynamic scopes<\/em>. This is known as <em>rebinding<\/em>. A {@code ScopedValue} that\n+ * is bound to some value may be bound to a new value for the bounded execution of some\n+ * method. The unfolding execution of code executed by that method defines the nested\n+ * dynamic scope. When the method completes (normally or with an exception), the value of\n+ * the {@code ScopedValue} reverts to its previous value.\n+ *\n+ * <p> In the above example, suppose that code executed by {@code doSomething()} binds\n+ * {@code USERNAME} to a new value with:\n+ * {@snippet lang=java :\n+ *     ScopedValue.where(USERNAME, \"duchess\", () -> doMore());\n+ * }\n+ * Code executed directly or indirectly by {@code doMore()} that invokes {@code\n+ * USERNAME.get()} will read the value \"{@code duchess}\". When {@code doMore()} completes\n+ * (normally or with an exception), the value of {@code USERNAME} reverts to\n+ * \"{@code duke}\".\n+ *\n+ * <h2><a id=\"inheritance\">Inheritance<\/a><\/h2>\n+ *\n+ * {@code ScopedValue} supports sharing data across threads. This sharing is limited to\n+ * structured cases where child threads are started and terminate within the bounded\n+ * period of execution by a parent thread. More specifically, when using a {@link\n+ * StructuredTaskScope}, scoped value bindings are <em>captured<\/em> when creating a\n+ * {@code StructuredTaskScope} and inherited by all threads started in that scope with\n+ * the {@link StructuredTaskScope#fork(Callable) fork} method.\n+ *\n+ * <p> In the following example, the {@code ScopedValue} {@code USERNAME} is bound to the\n+ * value \"{@code duke}\" for the execution of a runnable operation. The code in the {@code\n+ * run} method creates a {@code StructuredTaskScope} and forks three child threads. Code\n+ * executed directly or indirectly by these threads running {@code childTask1()},\n+ * {@code childTask2()}, and {@code childTask3()} will read the value \"{@code duke}\".\n+ *\n+ * {@snippet lang=java :\n+ *     private static final ScopedValue<String> USERNAME = ScopedValue.newInstance();\n+\n+ *     ScopedValue.where(USERNAME, \"duke\", () -> {\n+ *         try (var scope = new StructuredTaskScope<String>()) {\n+ *\n+ *             scope.fork(() -> childTask1());\n+ *             scope.fork(() -> childTask2());\n+ *             scope.fork(() -> childTask3());\n+ *\n+ *             ...\n+ *          }\n+ *     });\n+ * }\n+ *\n+ * @implNote\n+ * Scoped values are designed to be used in fairly small\n+ * numbers. {@link #get} initially performs a search through enclosing\n+ * scopes to find a scoped value's innermost binding. It\n+ * then caches the result of the search in a small thread-local\n+ * cache. Subsequent invocations of {@link #get} for that scoped value\n+ * will almost always be very fast. However, if a program has many\n+ * scoped values that it uses cyclically, the cache hit rate\n+ * will be low and performance will be poor. This design allows\n+ * scoped-value inheritance by {@link StructuredTaskScope} threads to\n+ * be very fast: in essence, no more than copying a pointer, and\n+ * leaving a scoped-value binding also requires little more than\n+ * updating a pointer.\n+ *\n+ * <p>Because the scoped-value per-thread cache is small, clients\n+ * should minimize the number of bound scoped values in use. For\n+ * example, if it is necessary to pass a number of values in this way,\n+ * it makes sense to create a record class to hold those values, and\n+ * then bind a single {@code ScopedValue} to an instance of that record.\n+ *\n+ * <p>For this incubator release, the reference implementation\n+ * provides some system properties to tune the performance of scoped\n+ * values.\n+ *\n+ * <p>The system property {@code jdk.incubator.concurrent.ScopedValue.cacheSize}\n+ * controls the size of the (per-thread) scoped-value cache. This cache is crucial\n+ * for the performance of scoped values. If it is too small,\n+ * the runtime library will repeatedly need to scan for each\n+ * {@link #get}. If it is too large, memory will be unnecessarily\n+ * consumed. The default scoped-value cache size is 16 entries. It may\n+ * be varied from 2 to 16 entries in size. {@code ScopedValue.cacheSize}\n+ * must be an integer power of 2.\n+ *\n+ * <p>For example, you could use {@code -Djdk.incubator.concurrent.ScopedValue.cacheSize=8}.\n+ *\n+ * <p>The other system property is {@code jdk.preserveScopedValueCache}.\n+ * This property determines whether the per-thread scoped-value\n+ * cache is preserved when a virtual thread is blocked. By default\n+ * this property is set to {@code true}, meaning that every virtual\n+ * thread preserves its scoped-value cache when blocked. Like {@code\n+ * ScopedValue.cacheSize}, this is a space versus speed trade-off: in\n+ * situations where many virtual threads are blocked most of the time,\n+ * setting this property to {@code false} might result in a useful\n+ * memory saving, but each virtual thread's scoped-value cache would\n+ * have to be regenerated after a blocking operation.\n+ *\n+ * @param <T> the type of the object bound to this {@code ScopedValue}\n+ * @since 20\n+ *\/\n+public final class ScopedValue<T> {\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n+    private final @Stable int hash;\n+\n+    @Override\n+    public int hashCode() { return hash; }\n+\n+    \/**\n+     * An immutable map from {@code ScopedValue} to values.\n+     *\n+     * <p> Unless otherwise specified, passing a {@code null} argument to a constructor\n+     * or method in this class will cause a {@link NullPointerException} to be thrown.\n+     *\/\n+    static final class Snapshot {\n+        final Snapshot prev;\n+        final Carrier bindings;\n+        final int bitmask;\n+\n+        private static final Object NIL = new Object();\n+\n+        static final Snapshot EMPTY_SNAPSHOT = new Snapshot();\n+\n+        Snapshot(Carrier bindings, Snapshot prev) {\n+            this.prev = prev;\n+            this.bindings = bindings;\n+            this.bitmask = bindings.bitmask | prev.bitmask;\n+        }\n+\n+        protected Snapshot() {\n+            this.prev = null;\n+            this.bindings = null;\n+            this.bitmask = 0;\n+        }\n+\n+        Object find(ScopedValue<?> key) {\n+            int bits = key.bitmask();\n+            for (Snapshot snapshot = this;\n+                 containsAll(snapshot.bitmask, bits);\n+                 snapshot = snapshot.prev) {\n+                for (Carrier carrier = snapshot.bindings;\n+                     carrier != null && containsAll(carrier.bitmask, bits);\n+                     carrier = carrier.prev) {\n+                    if (carrier.getKey() == key) {\n+                        Object value = carrier.get();\n+                        return value;\n+                    }\n+                }\n+            }\n+            return NIL;\n+        }\n+    }\n+\n+    \/**\n+     * A mapping of scoped values, as <em>keys<\/em>, to values.\n+     *\n+     * <p> A {@code Carrier} is used to accumlate mappings so that an operation (a\n+     * {@link Runnable} or {@link Callable}) can be executed with all scoped values in the\n+     * mapping bound to values. The following example runs an operation with {@code k1}\n+     * bound (or rebound) to {@code v1}, and {@code k2} bound (or rebound) to {@code v2}.\n+     * {@snippet lang=java :\n+     *     \/\/ @link substring=\"where\" target=\"#where(ScopedValue, Object)\" :\n+     *     ScopedValue.where(k1, v1).where(k2, v2).run(() -> ... );\n+     * }\n+     *\n+     * <p> A {@code Carrier} is immutable and thread-safe. The {@link\n+     * #where(ScopedValue, Object) where} method returns a new {@code Carrier} object,\n+     * it does not mutate an existing mapping.\n+     *\n+     * <p> Unless otherwise specified, passing a {@code null} argument to a method in\n+     * this class will cause a {@link NullPointerException} to be thrown.\n+     *\n+     * @since 20\n+     *\/\n+    public static final class Carrier {\n+        \/\/ Bit masks: a 1 in postion n indicates that this set of bound values\n+        \/\/ hits that slot in the cache.\n+        final int bitmask;\n+        final ScopedValue<?> key;\n+        final Object value;\n+        final Carrier prev;\n+\n+        Carrier(ScopedValue<?> key, Object value, Carrier prev) {\n+            this.key = key;\n+            this.value = value;\n+            this.prev = prev;\n+            int bits = key.bitmask();\n+            if (prev != null) {\n+                bits |= prev.bitmask;\n+            }\n+            this.bitmask = bits;\n+        }\n+\n+        \/**\n+         * Add a binding to this map, returning a new Carrier instance.\n+         *\/\n+        private static final <T> Carrier where(ScopedValue<T> key, T value,\n+                                               Carrier prev) {\n+            return new Carrier(key, value, prev);\n+        }\n+\n+        \/**\n+         * Returns a new {@code Carrier} with the mappings from this carrier plus a\n+         * new mapping from {@code key} to {@code value}. If this carrier already has a\n+         * mapping for the scoped value {@code key} then it will map to the new\n+         * {@code value}. The current carrier is immutable, so it is not changed by this\n+         * method.\n+         *\n+         * @param key the {@code ScopedValue} key\n+         * @param value the value, can be {@code null}\n+         * @param <T> the type of the value\n+         * @return a new {@code Carrier} with the mappings from this carrier plus the new mapping\n+         *\/\n+        public <T> Carrier where(ScopedValue<T> key, T value) {\n+            return where(key, value, this);\n+        }\n+\n+        \/*\n+         * Return a new set consisting of a single binding.\n+         *\/\n+        static <T> Carrier of(ScopedValue<T> key, T value) {\n+            return where(key, value, null);\n+        }\n+\n+        final Object get() {\n+            return value;\n+        }\n+\n+        final ScopedValue<?> getKey() {\n+            return key;\n+        }\n+\n+        \/**\n+         * Returns the value of a {@link ScopedValue} in this mapping.\n+         *\n+         * @param key the {@code ScopedValue} key\n+         * @param <T> the type of the value\n+         * @return the value\n+         * @throws NoSuchElementException if the key is not present in this mapping\n+         *\/\n+        @SuppressWarnings(\"unchecked\")\n+        public <T> T get(ScopedValue<T> key) {\n+            var bits = key.bitmask();\n+            for (Carrier carrier = this;\n+                 carrier != null && containsAll(carrier.bitmask, bits);\n+                 carrier = carrier.prev) {\n+                if (carrier.getKey() == key) {\n+                    Object value = carrier.get();\n+                    return (T)value;\n+                }\n+            }\n+            throw new NoSuchElementException();\n+        }\n+\n+        \/**\n+         * Calls a value-returning operation with each scoped value in this mapping bound\n+         * to its value in the current thread.\n+         * When the operation completes (normally or with an exception), each scoped value\n+         * in the mapping will revert to being unbound, or revert to its previous value\n+         * when previously bound, in the current thread.\n+         *\n+         * <p> Scoped values are intended to be used in a <em>structured manner<\/em>.\n+         * If {@code op} creates a {@link StructuredTaskScope} but does not {@linkplain\n+         * StructuredTaskScope#close() close} it, then exiting {@code op} causes the\n+         * underlying construct of each {@code StructuredTaskScope} created in the\n+         * dynamic scope to be closed. This may require blocking until all child threads\n+         * have completed their sub-tasks. The closing is done in the reverse order that\n+         * they were created. Once closed, {@link StructureViolationException} is thrown.\n+         *\n+         * @param op the operation to run\n+         * @param <R> the type of the result of the operation\n+         * @return the result\n+         * @throws Exception if {@code op} completes with an exception\n+         * @see ScopedValue#where(ScopedValue, Object, Callable)\n+         *\/\n+        public <R> R call(Callable<? extends R> op) throws Exception {\n+            Objects.requireNonNull(op);\n+            Cache.invalidate(bitmask);\n+            var prevSnapshot = scopedValueBindings();\n+            var newSnapshot = new Snapshot(this, prevSnapshot);\n+            return runWith(newSnapshot, op);\n+        }\n+\n+        \/**\n+         * Execute the action with a set of ScopedValue bindings.\n+         *\n+         * The VM recognizes this method as special, so any changes to the\n+         * name or signature require corresponding changes in\n+         * JVM_FindScopedValueBindings().\n+         *\/\n+        @Hidden\n+        @ForceInline\n+        private <R> R runWith(Snapshot newSnapshot, Callable<R> op) throws Exception {\n+            try {\n+                JLA.setScopedValueBindings(newSnapshot);\n+                JLA.ensureMaterializedForStackWalk(newSnapshot);\n+                return ScopedValueContainer.call(op);\n+            } finally {\n+                Reference.reachabilityFence(newSnapshot);\n+                JLA.setScopedValueBindings(newSnapshot.prev);\n+                Cache.invalidate(bitmask);\n+            }\n+        }\n+\n+        \/**\n+         * Runs an operation with each scoped value in this mapping bound to its value\n+         * in the current thread.\n+         * When the operation completes (normally or with an exception), each scoped value\n+         * in the mapping will revert to being unbound, or revert to its previous value\n+         * when previously bound, in the current thread.\n+         *\n+         * <p> Scoped values are intended to be used in a <em>structured manner<\/em>.\n+         * If {@code op} creates a {@link StructuredTaskScope} but does not {@linkplain\n+         * StructuredTaskScope#close() close} it, then exiting {@code op} causes the\n+         * underlying construct of each {@code StructuredTaskScope} created in the\n+         * dynamic scope to be closed. This may require blocking until all child threads\n+         * have completed their sub-tasks. The closing is done in the reverse order that\n+         * they were created. Once closed, {@link StructureViolationException} is thrown.\n+         *\n+         * @param op the operation to run\n+         * @see ScopedValue#where(ScopedValue, Object, Runnable)\n+         *\/\n+        public void run(Runnable op) {\n+            Objects.requireNonNull(op);\n+            Cache.invalidate(bitmask);\n+            var prevSnapshot = scopedValueBindings();\n+            var newSnapshot = new Snapshot(this, prevSnapshot);\n+            runWith(newSnapshot, op);\n+        }\n+\n+        \/**\n+         * Execute the action with a set of {@code ScopedValue} bindings.\n+         *\n+         * The VM recognizes this method as special, so any changes to the\n+         * name or signature require corresponding changes in\n+         * JVM_FindScopedValueBindings().\n+         *\/\n+        @Hidden\n+        @ForceInline\n+        private void runWith(Snapshot newSnapshot, Runnable op) {\n+            try {\n+                JLA.setScopedValueBindings(newSnapshot);\n+                JLA.ensureMaterializedForStackWalk(newSnapshot);\n+                ScopedValueContainer.run(op);\n+            } finally {\n+                Reference.reachabilityFence(newSnapshot);\n+                JLA.setScopedValueBindings(newSnapshot.prev);\n+                Cache.invalidate(bitmask);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Creates a new {@code Carrier} with a single mapping of a {@code ScopedValue}\n+     * <em>key<\/em> to a value. The {@code Carrier} can be used to accumlate mappings so\n+     * that an operation can be executed with all scoped values in the mapping bound to\n+     * values. The following example runs an operation with {@code k1} bound (or rebound)\n+     * to {@code v1}, and {@code k2} bound (or rebound) to {@code v2}.\n+     * {@snippet lang=java :\n+     *     \/\/ @link substring=\"run\" target=\"Carrier#run(Runnable)\" :\n+     *     ScopedValue.where(k1, v1).where(k2, v2).run(() -> ... );\n+     * }\n+     *\n+     * @param key the {@code ScopedValue} key\n+     * @param value the value, can be {@code null}\n+     * @param <T> the type of the value\n+     * @return a new {@code Carrier} with a single mapping\n+     *\/\n+    public static <T> Carrier where(ScopedValue<T> key, T value) {\n+        return Carrier.of(key, value);\n+    }\n+\n+    \/**\n+     * Calls a value-returning operation with a {@code ScopedValue} bound to a value\n+     * in the current thread. When the operation completes (normally or with an\n+     * exception), the {@code ScopedValue} will revert to being unbound, or revert to\n+     * its previous value when previously bound, in the current thread.\n+     *\n+     * <p> Scoped values are intended to be used in a <em>structured manner<\/em>.\n+     * If {@code op} creates a {@link StructuredTaskScope} but does not {@linkplain\n+     * StructuredTaskScope#close() close} it, then exiting {@code op} causes the\n+     * underlying construct of each {@code StructuredTaskScope} created in the\n+     * dynamic scope to be closed. This may require blocking until all child threads\n+     * have completed their sub-tasks. The closing is done in the reverse order that\n+     * they were created. Once closed, {@link StructureViolationException} is thrown.\n+     *\n+     * @implNote\n+     * This method is implemented to be equivalent to:\n+     * {@snippet lang=java :\n+     *     \/\/ @link substring=\"call\" target=\"Carrier#call(Callable)\" :\n+     *     ScopedValue.where(key, value).call(op);\n+     * }\n+     *\n+     * @param key the {@code ScopedValue} key\n+     * @param value the value, can be {@code null}\n+     * @param <T> the type of the value\n+     * @param <R> the result type\n+     * @param op the operation to call\n+     * @return the result\n+     * @throws Exception if the operation completes with an exception\n+     *\/\n+    public static <T, R> R where(ScopedValue<T> key,\n+                                 T value,\n+                                 Callable<? extends R> op) throws Exception {\n+        return where(key, value).call(op);\n+    }\n+\n+    \/**\n+     * Run an operation with a {@code ScopedValue} bound to a value in the current\n+     * thread. When the operation completes (normally or with an exception), the\n+     * {@code ScopedValue} will revert to being unbound, or revert to its previous value\n+     * when previously bound, in the current thread.\n+     *\n+     * <p> Scoped values are intended to be used in a <em>structured manner<\/em>.\n+     * If {@code op} creates a {@link StructuredTaskScope} but does not {@linkplain\n+     * StructuredTaskScope#close() close} it, then exiting {@code op} causes the\n+     * underlying construct of each {@code StructuredTaskScope} created in the\n+     * dynamic scope to be closed. This may require blocking until all child threads\n+     * have completed their sub-tasks. The closing is done in the reverse order that\n+     * they were created. Once closed, {@link StructureViolationException} is thrown.\n+     *\n+     * @implNote\n+     * This method is implemented to be equivalent to:\n+     * {@snippet lang=java :\n+     *     \/\/ @link substring=\"run\" target=\"Carrier#run(Runnable)\" :\n+     *     ScopedValue.where(key, value).run(op);\n+     * }\n+     *\n+     * @param key the {@code ScopedValue} key\n+     * @param value the value, can be {@code null}\n+     * @param <T> the type of the value\n+     * @param op the operation to call\n+     *\/\n+    public static <T> void where(ScopedValue<T> key, T value, Runnable op) {\n+        where(key, value).run(op);\n+    }\n+\n+    private ScopedValue() {\n+        this.hash = generateKey();\n+    }\n+\n+    \/**\n+     * Creates a scoped value that is initially unbound for all threads.\n+     *\n+     * @param <T> the type of the value\n+     * @return a new {@code ScopedValue}\n+     *\/\n+    public static <T> ScopedValue<T> newInstance() {\n+        return new ScopedValue<T>();\n+    }\n+\n+    \/**\n+     * {@return the value of the scoped value if bound in the current thread}\n+     *\n+     * @throws NoSuchElementException if the scoped value is not bound\n+     *\/\n+    @ForceInline\n+    @SuppressWarnings(\"unchecked\")\n+    public T get() {\n+        Object[] objects;\n+        if ((objects = scopedValueCache()) != null) {\n+            \/\/ This code should perhaps be in class Cache. We do it\n+            \/\/ here because the generated code is small and fast and\n+            \/\/ we really want it to be inlined in the caller.\n+            int n = (hash & Cache.SLOT_MASK) * 2;\n+            if (objects[n] == this) {\n+                return (T)objects[n + 1];\n+            }\n+            n = ((hash >>> Cache.INDEX_BITS) & Cache.SLOT_MASK) * 2;\n+            if (objects[n] == this) {\n+                return (T)objects[n + 1];\n+            }\n+        }\n+        return slowGet();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private T slowGet() {\n+        var value = findBinding();\n+        if (value == Snapshot.NIL) {\n+            throw new NoSuchElementException();\n+        }\n+        Cache.put(this, value);\n+        return (T)value;\n+    }\n+\n+    \/**\n+     * {@return {@code true} if this scoped value is bound in the current thread}\n+     *\/\n+    public boolean isBound() {\n+        Object[] objects = scopedValueCache();\n+        if (objects != null) {\n+            int n = (hash & Cache.SLOT_MASK) * 2;\n+            if (objects[n] == this) {\n+                return true;\n+            }\n+            n = ((hash >>> Cache.INDEX_BITS) & Cache.SLOT_MASK) * 2;\n+            if (objects[n] == this) {\n+                return true;\n+            }\n+        }\n+        var value = findBinding();\n+        boolean result = (value != Snapshot.NIL);\n+        if (result)  Cache.put(this, value);\n+        return result;\n+    }\n+\n+    \/**\n+     * Return the value of the scoped value or NIL if not bound.\n+     *\/\n+    private Object findBinding() {\n+        Object value = scopedValueBindings().find(this);\n+        return value;\n+    }\n+\n+    \/**\n+     * Returns the value of this scoped value if bound in the current thread, otherwise\n+     * returns {@code other}.\n+     *\n+     * @param other the value to return if not bound, can be {@code null}\n+     * @return the value of the scoped value if bound, otherwise {@code other}\n+     *\/\n+    public T orElse(T other) {\n+        Object obj = findBinding();\n+        if (obj != Snapshot.NIL) {\n+            @SuppressWarnings(\"unchecked\")\n+            T value = (T) obj;\n+            return value;\n+        } else {\n+            return other;\n+        }\n+    }\n+\n+    \/**\n+     * Returns the value of this scoped value if bound in the current thread, otherwise\n+     * throws an exception produced by the exception supplying function.\n+     *\n+     * @param <X> the type of the exception that may be thrown\n+     * @param exceptionSupplier the supplying function that produces the exception to throw\n+     * @return the value of the scoped value if bound in the current thread\n+     * @throws X if the scoped value is not bound in the current thread\n+     *\/\n+    public <X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier) throws X {\n+        Objects.requireNonNull(exceptionSupplier);\n+        Object obj = findBinding();\n+        if (obj != Snapshot.NIL) {\n+            @SuppressWarnings(\"unchecked\")\n+            T value = (T) obj;\n+            return value;\n+        } else {\n+            throw exceptionSupplier.get();\n+        }\n+    }\n+\n+    private static Object[] scopedValueCache() {\n+        return JLA.scopedValueCache();\n+    }\n+\n+    private static void setScopedValueCache(Object[] cache) {\n+        JLA.setScopedValueCache(cache);\n+    }\n+\n+    \/\/ Special value to indicate this is a newly-created Thread\n+    \/\/ Note that his must match the declaration in j.l.Thread.\n+    private static final Object NEW_THREAD_BINDINGS = Thread.class;\n+\n+    private static Snapshot scopedValueBindings() {\n+        \/\/ Bindings can be in one of four states:\n+        \/\/\n+        \/\/ 1: class Thread: this is a new Thread instance, and no\n+        \/\/ scoped values have ever been bound in this Thread.\n+        \/\/ 2: EmptySnapshot.SINGLETON: This is effectively an empty binding.\n+        \/\/ 3: A Snapshot instance: this contains one or more scoped value\n+        \/\/ bindings.\n+        \/\/ 4: null: there may be some bindings in this Thread, but we don't know\n+        \/\/ where they are. We must invoke JLA.findScopedValueBindings() to walk\n+        \/\/ the stack to find them.\n+\n+        Object bindings = JLA.scopedValueBindings();\n+        if (bindings == NEW_THREAD_BINDINGS) {\n+            \/\/ This must be a new thread\n+           return Snapshot.EMPTY_SNAPSHOT;\n+        }\n+        if (bindings == null) {\n+            \/\/ Search the stack\n+            bindings = JLA.findScopedValueBindings();\n+            if (bindings == null) {\n+                \/\/ Nothing on the stack.\n+                bindings = Snapshot.EMPTY_SNAPSHOT;\n+            }\n+        }\n+        assert (bindings != null);\n+        JLA.setScopedValueBindings(bindings);\n+        return (Snapshot) bindings;\n+    }\n+\n+    private static int nextKey = 0xf0f0_f0f0;\n+\n+    \/\/ A Marsaglia xor-shift generator used to generate hashes. This one has full period, so\n+    \/\/ it generates 2**32 - 1 hashes before it repeats. We're going to use the lowest n bits\n+    \/\/ and the next n bits as cache indexes, so we make sure that those indexes map\n+    \/\/ to different slots in the cache.\n+    private static synchronized int generateKey() {\n+        int x = nextKey;\n+        do {\n+            x ^= x >>> 12;\n+            x ^= x << 9;\n+            x ^= x >>> 23;\n+        } while (Cache.primarySlot(x) == Cache.secondarySlot(x));\n+        return (nextKey = x);\n+    }\n+\n+    \/**\n+     * Return a bit mask that may be used to determine if this ScopedValue is\n+     * bound in the current context. Each Carrier holds a bit mask which is\n+     * the OR of all the bit masks of the bound ScopedValues.\n+     * @return the bitmask\n+     *\/\n+    int bitmask() {\n+        return (1 << Cache.primaryIndex(this)) | (1 << (Cache.secondaryIndex(this) + Cache.TABLE_SIZE));\n+    }\n+\n+    \/\/ Return true iff bitmask, considered as a set of bits, contains all\n+    \/\/ of the bits in targetBits.\n+    static boolean containsAll(int bitmask, int targetBits) {\n+        return (bitmask & targetBits) == targetBits;\n+    }\n+\n+    \/\/ A small fixed-size key-value cache. When a scoped value's get() method\n+    \/\/ is invoked, we record the result of the lookup in this per-thread cache\n+    \/\/ for fast access in future.\n+    private static final class Cache {\n+        static final int INDEX_BITS = 4;  \/\/ Must be a power of 2\n+        static final int TABLE_SIZE = 1 << INDEX_BITS;\n+        static final int TABLE_MASK = TABLE_SIZE - 1;\n+        static final int PRIMARY_MASK = (1 << TABLE_SIZE) - 1;\n+\n+        \/\/ The number of elements in the cache array, and a bit mask used to\n+        \/\/ select elements from it.\n+        private static final int CACHE_TABLE_SIZE, SLOT_MASK;\n+        \/\/ The largest cache we allow. Must be a power of 2 and greater than\n+        \/\/ or equal to 2.\n+        private static final int MAX_CACHE_SIZE = 16;\n+\n+        static {\n+            final String propertyName = \"jdk.incubator.concurrent.ScopedValue.cacheSize\";\n+            var sizeString = GetPropertyAction.privilegedGetProperty(propertyName, \"16\");\n+            var cacheSize = Integer.valueOf(sizeString);\n+            if (cacheSize < 2 || cacheSize > MAX_CACHE_SIZE) {\n+                cacheSize = MAX_CACHE_SIZE;\n+                System.err.println(propertyName + \" is out of range: is \" + sizeString);\n+            }\n+            if ((cacheSize & (cacheSize - 1)) != 0) {  \/\/ a power of 2\n+                cacheSize = MAX_CACHE_SIZE;\n+                System.err.println(propertyName + \" must be an integer power of 2: is \" + sizeString);\n+            }\n+            CACHE_TABLE_SIZE = cacheSize;\n+            SLOT_MASK = cacheSize - 1;\n+        }\n+\n+        static int primaryIndex(ScopedValue<?> key) {\n+            return key.hash & TABLE_MASK;\n+        }\n+\n+        static int secondaryIndex(ScopedValue<?> key) {\n+            return (key.hash >> INDEX_BITS) & TABLE_MASK;\n+        }\n+\n+        private static int primarySlot(ScopedValue<?> key) {\n+            return key.hashCode() & SLOT_MASK;\n+        }\n+\n+        private static int secondarySlot(ScopedValue<?> key) {\n+            return (key.hash >> INDEX_BITS) & SLOT_MASK;\n+        }\n+\n+        static int primarySlot(int hash) {\n+            return hash & SLOT_MASK;\n+        }\n+\n+        static int secondarySlot(int hash) {\n+            return (hash >> INDEX_BITS) & SLOT_MASK;\n+        }\n+\n+        static void put(ScopedValue<?> key, Object value) {\n+            Object[] theCache = scopedValueCache();\n+            if (theCache == null) {\n+                theCache = new Object[CACHE_TABLE_SIZE * 2];\n+                setScopedValueCache(theCache);\n+            }\n+            \/\/ Update the cache to replace one entry with the value we just looked up.\n+            \/\/ Each value can be in one of two possible places in the cache.\n+            \/\/ Pick a victim at (pseudo-)random.\n+            int k1 = primarySlot(key);\n+            int k2 = secondarySlot(key);\n+            var usePrimaryIndex = chooseVictim();\n+            int victim = usePrimaryIndex ? k1 : k2;\n+            int other = usePrimaryIndex ? k2 : k1;\n+            setKeyAndObjectAt(victim, key, value);\n+            if (getKey(theCache, other) == key) {\n+                setKeyAndObjectAt(other, key, value);\n+            }\n+        }\n+\n+        private static void setKeyAndObjectAt(int n, Object key, Object value) {\n+            var cache = scopedValueCache();\n+            cache[n * 2] = key;\n+            cache[n * 2 + 1] = value;\n+        }\n+\n+        private static void setKeyAndObjectAt(Object[] cache, int n, Object key, Object value) {\n+            cache[n * 2] = key;\n+            cache[n * 2 + 1] = value;\n+        }\n+\n+        private static Object getKey(Object[] objs, int n) {\n+            return objs[n * 2];\n+        }\n+\n+        private static void setKey(Object[] objs, int n, Object key) {\n+            objs[n * 2] = key;\n+        }\n+\n+        private static final JavaUtilConcurrentTLRAccess THREAD_LOCAL_RANDOM_ACCESS\n+                = SharedSecrets.getJavaUtilConcurrentTLRAccess();\n+\n+        \/\/ Return either true or false, at pseudo-random, with a bias towards true.\n+        \/\/ This chooses either the primary or secondary cache slot, but the\n+        \/\/ primary slot is approximately twice as likely to be chosen as the\n+        \/\/ secondary one.\n+        private static boolean chooseVictim() {\n+            int r = THREAD_LOCAL_RANDOM_ACCESS.nextSecondaryThreadLocalRandomSeed();\n+            return (r & 15) >= 5;\n+        }\n+\n+        \/\/ Null a set of cache entries, indicated by the 1-bits given\n+        static void invalidate(int toClearBits) {\n+            toClearBits = (toClearBits >>> TABLE_SIZE) | (toClearBits & PRIMARY_MASK);\n+            Object[] objects;\n+            if ((objects = scopedValueCache()) != null) {\n+                for (int bits = toClearBits; bits != 0; ) {\n+                    int index = Integer.numberOfTrailingZeros(bits);\n+                    setKeyAndObjectAt(objects, index & SLOT_MASK, null, null);\n+                    bits &= ~1 << index;\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.concurrent\/share\/classes\/jdk\/incubator\/concurrent\/ScopedValue.java","additions":838,"deletions":0,"binary":false,"changes":838,"status":"added"},{"patch":"@@ -213,2 +213,2 @@\n- * StructuredTaskScopes form a tree where parent-child relations are established\n- * implicitly when opening a new task scope:\n+ * Task scopes form a tree where parent-child relations are established implicitly when\n+ * opening a new task scope:\n@@ -225,4 +225,39 @@\n- * <p> The tree structure supports confinement checks. The phrase \"threads contained in\n- * the task scope\" in method descriptions means threads started in the task scope or\n- * descendant scopes. {@code StructuredTaskScope} does not define APIs that exposes the\n- * tree structure at this time.\n+ * The <i>descendants<\/i> of a task scope are the child task scopes that it is a parent\n+ * of, plus the descendants of the child task scopes, recursively.\n+ *\n+ * <p> The tree structure supports:\n+ * <ul>\n+ *   <li> Inheritance of {@linkplain ScopedValue scoped values} across threads.\n+ *   <li> Confinement checks. The phrase \"threads contained in the task scope\" in method\n+ *   descriptions means threads started in the task scope or descendant scopes.\n+ * <\/ul>\n+ *\n+ * <p> The following example demonstrates the inheritance of a scoped value. A scoped\n+ * value {@code USERNAME} is bound to the value \"{@code duke}\". A {@code StructuredTaskScope}\n+ * is created and its {@code fork} method invoked to start a thread to execute {@code\n+ * childTask}. The thread inherits the scoped value <em>bindings<\/em> captured when\n+ * creating the task scope. The code in {@code childTask} uses the value of the scoped\n+ * value and so reads the value \"{@code duke}\".\n+ * {@snippet lang=java :\n+ *     private static final ScopedValue<String> USERNAME = ScopedValue.newInstance();\n+ *\n+ *     \/\/ @link substring=\"where\" target=\"ScopedValue#where(ScopedValue, Object, Runnable)\" :\n+ *     ScopedValue.where(USERNAME, \"duke\", () -> {\n+ *         try (var scope = new StructuredTaskScope<String>()) {\n+ *\n+ *             scope.fork(() -> childTask());           \/\/ @highlight substring=\"fork\"\n+ *             ...\n+ *          }\n+ *     });\n+ *\n+ *     ...\n+ *\n+ *     String childTask() {\n+ *         \/\/ @link substring=\"get\" target=\"ScopedValue#get()\" :\n+ *         String name = USERNAME.get();   \/\/ \"duke\"\n+ *         ...\n+ *     }\n+ * }\n+ *\n+ * <p> {@code StructuredTaskScope} does not define APIs that exposes the tree structure\n+ * at this time.\n@@ -237,1 +272,1 @@\n- * <a href=\"..\/..\/..\/..\/java.base\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\">\n+ * <a href=\"{@docRoot}\/java.base\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\">\n@@ -283,0 +318,6 @@\n+     * <p> This method captures the current thread's {@linkplain ScopedValue scoped value}\n+     * bindings for inheritance by threads created in the task scope. The\n+     * <a href=\"#TreeStructure\">Tree Structure<\/a> section in the class description\n+     * details how parent-child relations are established implicitly for the purpose of\n+     * inheritance of scoped value bindings.\n+     *\n@@ -370,1 +411,3 @@\n-     * <p> The new thread is created with the task scope's {@link ThreadFactory}.\n+     * <p> The new thread is created with the task scope's {@link ThreadFactory}. It\n+     * inherits the current thread's {@linkplain ScopedValue scoped value} bindings. The\n+     * bindings must match the bindings captured when the task scope was created.\n@@ -373,7 +416,8 @@\n-     * then the {@link #handleComplete(Future) handle} method is invoked to consume the\n-     * completed task. The {@code handleComplete} method is run when the task completes\n-     * with a result or exception. If the {@code Future} {@link Future#cancel(boolean)\n-     * cancel} method is used the cancel a task before the task scope is shut down, then\n-     * the {@code handleComplete} method is run by the thread that invokes {@code cancel}.\n-     * If the task scope shuts down at or around the same time that the task completes or\n-     * is cancelled then the {@code handleComplete} method may or may not be invoked.\n+     * then the {@link #handleComplete(Future) handleComplete} method is invoked to\n+     * consume the completed task. The {@code handleComplete} method is run when the task\n+     * completes with a result or exception. If the {@code Future}'s {@link\n+     * Future#cancel(boolean) cancel} method is used to cancel a task before the task scope\n+     * is shut down, then the {@code handleComplete} method is run by the thread that\n+     * invokes {@code cancel}. If the task scope shuts down at or around the same time\n+     * that the task completes or is cancelled then the {@code handleComplete} method may\n+     * or may not be invoked.\n@@ -398,0 +442,2 @@\n+     * @throws StructureViolationException if the current scoped value bindings are not\n+     * the same as when the task scope was created\n@@ -631,0 +677,6 @@\n+     *\n+     * Similarly, if this method is called to close a task scope while executing with\n+     * {@linkplain ScopedValue scoped value} bindings, and the task scope was created\n+     * before the scoped values were bound, then {@code StructureViolationException} is\n+     * thrown after closing the task scope.\n+     *\n@@ -827,0 +879,6 @@\n+         * <p> This method captures the current thread's {@linkplain ScopedValue scoped value}\n+         * bindings for inheritance by threads created in the task scope. The\n+         * <a href=\"StructuredTaskScope.html#TreeStructure\">Tree Structure<\/a> section in\n+         * the class description details how parent-child relations are established\n+         * implicitly for the purpose of inheritance of scoped value bindings.\n+         *\n@@ -1003,0 +1061,6 @@\n+         * <p> This method captures the current thread's {@linkplain ScopedValue scoped value}\n+         * bindings for inheritance by threads created in the task scope. The\n+         * <a href=\"StructuredTaskScope.html#TreeStructure\">Tree Structure<\/a> section in\n+         * the class description details how parent-child relations are established\n+         * implicitly for the purpose of inheritance of scoped value bindings.\n+         *\n","filename":"src\/jdk.incubator.concurrent\/share\/classes\/jdk\/incubator\/concurrent\/StructuredTaskScope.java","additions":79,"deletions":15,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.org.jline;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.Reader;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.Charset;\n+\n+import jdk.internal.io.JdkConsole;\n+import jdk.internal.io.JdkConsoleProvider;\n+import jdk.internal.org.jline.reader.EndOfFileException;\n+import jdk.internal.org.jline.reader.LineReader;\n+import jdk.internal.org.jline.reader.LineReaderBuilder;\n+import jdk.internal.org.jline.terminal.Terminal;\n+import jdk.internal.org.jline.terminal.TerminalBuilder;\n+\n+\/**\n+ * JdkConsole\/Provider implementations for jline\n+ *\/\n+public class JdkConsoleProviderImpl implements JdkConsoleProvider {\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public JdkConsole console(boolean isTTY, Charset charset) {\n+        return new JdkConsoleImpl(charset);\n+    }\n+\n+    \/**\n+     * An implementation of JdkConsole, which act as a delegate for the\n+     * public Console class.\n+     *\/\n+    private static class JdkConsoleImpl implements JdkConsole {\n+        @Override\n+        public PrintWriter writer() {\n+            return terminal.writer();\n+        }\n+\n+        @Override\n+        public Reader reader() {\n+            return terminal.reader();\n+        }\n+\n+        @Override\n+        public JdkConsole format(String fmt, Object ... args) {\n+            writer().format(fmt, args).flush();\n+            return this;\n+        }\n+\n+        @Override\n+        public JdkConsole printf(String format, Object ... args) {\n+            return format(format, args);\n+        }\n+\n+        @Override\n+        public String readLine(String fmt, Object ... args) {\n+            try {\n+                return jline.readLine(fmt.formatted(args));\n+            } catch (EndOfFileException eofe) {\n+                return null;\n+            }\n+        }\n+\n+        @Override\n+        public String readLine() {\n+            return readLine(\"\");\n+        }\n+\n+        @Override\n+        public char[] readPassword(String fmt, Object ... args) {\n+            try {\n+                return jline.readLine(fmt.formatted(args), '\\0').toCharArray();\n+            } catch (EndOfFileException eofe) {\n+                return null;\n+            }\n+        }\n+\n+        @Override\n+        public char[] readPassword() {\n+            return readPassword(\"\");\n+        }\n+\n+        @Override\n+        public void flush() {\n+            terminal.flush();\n+        }\n+\n+        @Override\n+        public Charset charset() {\n+            return terminal.encoding();\n+        }\n+\n+        private final LineReader jline;\n+        private final Terminal terminal;\n+\n+        public JdkConsoleImpl(Charset charset) {\n+            try {\n+                terminal = TerminalBuilder.builder().encoding(charset).build();\n+                jline = LineReaderBuilder.builder().terminal(terminal).build();\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/JdkConsoleProviderImpl.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,3 @@\n+    \/\/ Console\n+    provides jdk.internal.io.JdkConsoleProvider with\n+            jdk.internal.org.jline.JdkConsoleProviderImpl;\n","filename":"src\/jdk.internal.le\/share\/classes\/module-info.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -209,58 +209,0 @@\n-    \/**\n-     * Decodes the exception encoded in {@code buffer} and throws it.\n-     *\n-     * @param errorOrBuffer an error code or a native byte buffer containing an exception encoded by\n-     *            {@link #encodeThrowable}. Error code values and their meanings are:\n-     *\n-     *            <pre>\n-     *             0: native memory for the buffer could not be allocated\n-     *            -1: an OutOfMemoryError was thrown while encoding the exception\n-     *            -2: some other throwable was thrown while encoding the exception\n-     *            <\/pre>\n-     *\/\n-    @VMEntryPoint\n-    static void decodeAndThrowThrowable(long errorOrBuffer) throws Throwable {\n-        if (errorOrBuffer >= -2L && errorOrBuffer <= 0) {\n-            String context = String.format(\"while encoding an exception to translate it from %s to %s\",\n-                            IS_IN_NATIVE_IMAGE ? \"HotSpot\" : \"libjvmci\",\n-                            IS_IN_NATIVE_IMAGE ? \"libjvmci\" : \"HotSpot\");\n-            if (errorOrBuffer == 0) {\n-                throw new InternalError(\"native buffer could not be allocated \" + context);\n-            }\n-            if (errorOrBuffer == -1L) {\n-                throw new OutOfMemoryError(\"OutOfMemoryError occurred \" + context);\n-            }\n-            throw new InternalError(\"unexpected problem occurred \" + context);\n-        }\n-        Unsafe unsafe = UnsafeAccess.UNSAFE;\n-        int encodingLength = unsafe.getInt(errorOrBuffer);\n-        byte[] encoding = new byte[encodingLength];\n-        unsafe.copyMemory(null, errorOrBuffer + 4, encoding, Unsafe.ARRAY_BYTE_BASE_OFFSET, encodingLength);\n-        throw TranslatedException.decodeThrowable(encoding);\n-    }\n-\n-    \/**\n-     * If {@code bufferSize} is large enough, encodes {@code throwable} into a byte array and writes\n-     * it to {@code buffer}. The encoding in {@code buffer} can be decoded by\n-     * {@link #decodeAndThrowThrowable}.\n-     *\n-     * @param throwable the exception to encode\n-     * @param buffer a native byte buffer\n-     * @param bufferSize the size of {@code buffer} in bytes\n-     * @return the number of bytes written into {@code buffer} if {@code bufferSize} is large\n-     *         enough, otherwise {@code -N} where {@code N} is the value {@code bufferSize} needs to\n-     *         be to fit the encoding\n-     *\/\n-    @VMEntryPoint\n-    static int encodeThrowable(Throwable throwable, long buffer, int bufferSize) throws Throwable {\n-        byte[] encoding = TranslatedException.encodeThrowable(throwable);\n-        int requiredSize = 4 + encoding.length;\n-        if (bufferSize < requiredSize) {\n-            return -requiredSize;\n-        }\n-        Unsafe unsafe = UnsafeAccess.UNSAFE;\n-        unsafe.putInt(buffer, encoding.length);\n-        unsafe.copyMemory(encoding, Unsafe.ARRAY_BYTE_BASE_OFFSET, null, buffer + 4, encoding.length);\n-        return requiredSize;\n-    }\n-\n@@ -1333,1 +1275,1 @@\n-                throw new JVMCIError(Option.ForceTranslateFailure + \" filter does not match \" + FORCE_TRANSLATE_FAILURE_FILTER_RE + \": \" + filter);\n+                throw new IllegalArgumentException(Option.ForceTranslateFailure + \" filter does not match \" + FORCE_TRANSLATE_FAILURE_FILTER_RE + \": \" + filter);\n@@ -1353,1 +1295,1 @@\n-                throw new JVMCIError(\"translation of \" + translatedObject + \" failed due to matching \" + Option.ForceTranslateFailure + \" filter \\\"\" + filter + \"\\\"\");\n+                throw new RuntimeException(\"translation of \" + translatedObject + \" failed due to matching \" + Option.ForceTranslateFailure + \" filter \\\"\" + filter + \"\\\"\");\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIRuntime.java","additions":2,"deletions":60,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -1,275 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.vm.ci.hotspot;\n-\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.DataInputStream;\n-import java.io.DataOutputStream;\n-import java.io.IOException;\n-import java.lang.reflect.InvocationTargetException;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.zip.GZIPInputStream;\n-import java.util.zip.GZIPOutputStream;\n-\n-import jdk.vm.ci.common.JVMCIError;\n-\n-\/**\n- * Support for translating exceptions between different runtime heaps.\n- *\/\n-@SuppressWarnings(\"serial\")\n-final class TranslatedException extends Exception {\n-\n-    \/**\n-     * The value returned by {@link #encodeThrowable(Throwable)} when encoding fails due to an\n-     * {@link OutOfMemoryError}.\n-     *\/\n-    private static final byte[] FALLBACK_ENCODED_OUTOFMEMORYERROR_BYTES;\n-\n-    \/**\n-     * The value returned by {@link #encodeThrowable(Throwable)} when encoding fails for any reason\n-     * other than {@link OutOfMemoryError}.\n-     *\/\n-    private static final byte[] FALLBACK_ENCODED_THROWABLE_BYTES;\n-    static {\n-        try {\n-            FALLBACK_ENCODED_THROWABLE_BYTES = encodeThrowable(new TranslatedException(\"error during encoding\", \"<unknown>\"), false);\n-            FALLBACK_ENCODED_OUTOFMEMORYERROR_BYTES = encodeThrowable(new OutOfMemoryError(), false);\n-        } catch (IOException e) {\n-            throw new JVMCIError(e);\n-        }\n-    }\n-\n-    \/**\n-     * Class name of exception that could not be instantiated.\n-     *\/\n-    private String originalExceptionClassName;\n-\n-    private TranslatedException(String message, String originalExceptionClassName) {\n-        super(message);\n-        this.originalExceptionClassName = originalExceptionClassName;\n-    }\n-\n-    \/**\n-     * No need to record an initial stack trace since it will be manually overwritten.\n-     *\/\n-    @SuppressWarnings(\"sync-override\")\n-    @Override\n-    public Throwable fillInStackTrace() {\n-        return this;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        String s;\n-        if (originalExceptionClassName.equals(TranslatedException.class.getName())) {\n-            s = getClass().getName();\n-        } else {\n-            s = getClass().getName() + \"[\" + originalExceptionClassName + \"]\";\n-        }\n-        String message = getMessage();\n-        return (message != null) ? (s + \": \" + message) : s;\n-    }\n-\n-    \/**\n-     * Prints a stack trace for {@code throwable} and returns {@code true}. Used to print stack\n-     * traces only when assertions are enabled.\n-     *\/\n-    private static boolean printStackTrace(Throwable throwable) {\n-        throwable.printStackTrace();\n-        return true;\n-    }\n-\n-    private static Throwable initCause(Throwable throwable, Throwable cause) {\n-        if (cause != null) {\n-            try {\n-                throwable.initCause(cause);\n-            } catch (IllegalStateException e) {\n-                \/\/ Cause could not be set or overwritten.\n-                assert printStackTrace(e);\n-            }\n-        }\n-        return throwable;\n-    }\n-\n-    private static Throwable create(String className, String message, Throwable cause) {\n-        \/\/ Try create with reflection first.\n-        try {\n-            Class<?> cls = Class.forName(className);\n-            if (cause != null) {\n-                \/\/ Handle known exception types whose cause must be set in the constructor\n-                if (cls == InvocationTargetException.class) {\n-                    return new InvocationTargetException(cause, message);\n-                }\n-                if (cls == ExceptionInInitializerError.class) {\n-                    return new ExceptionInInitializerError(cause);\n-                }\n-            }\n-            if (message == null) {\n-                return initCause((Throwable) cls.getConstructor().newInstance(), cause);\n-            }\n-            return initCause((Throwable) cls.getDeclaredConstructor(String.class).newInstance(message), cause);\n-        } catch (Throwable translationFailure) {\n-            return initCause(new TranslatedException(message, className), cause);\n-        }\n-    }\n-\n-    private static String emptyIfNull(String value) {\n-        return value == null ? \"\" : value;\n-    }\n-\n-    private static String emptyAsNull(String value) {\n-        return value.isEmpty() ? null : value;\n-    }\n-\n-    \/**\n-     * Encodes {@code throwable} including its stack and causes as a {@linkplain GZIPOutputStream\n-     * compressed} byte array that can be decoded by {@link #decodeThrowable}.\n-     *\/\n-    static byte[] encodeThrowable(Throwable throwable) throws Throwable {\n-        try {\n-            return encodeThrowable(throwable, true);\n-        } catch (OutOfMemoryError e) {\n-            return FALLBACK_ENCODED_OUTOFMEMORYERROR_BYTES;\n-        } catch (Throwable e) {\n-            return FALLBACK_ENCODED_THROWABLE_BYTES;\n-        }\n-    }\n-\n-    private static byte[] encodeThrowable(Throwable throwable, boolean withCauseAndStack) throws IOException {\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        try (DataOutputStream dos = new DataOutputStream(new GZIPOutputStream(baos))) {\n-            List<Throwable> throwables = new ArrayList<>();\n-            for (Throwable current = throwable; current != null; current = current.getCause()) {\n-                throwables.add(current);\n-                if (!withCauseAndStack) {\n-                    break;\n-                }\n-            }\n-\n-            \/\/ Encode from inner most cause outwards\n-            Collections.reverse(throwables);\n-\n-            for (Throwable current : throwables) {\n-                dos.writeUTF(current.getClass().getName());\n-                dos.writeUTF(emptyIfNull(current.getMessage()));\n-                StackTraceElement[] stackTrace = withCauseAndStack ? current.getStackTrace() : null;\n-                if (stackTrace == null) {\n-                    stackTrace = new StackTraceElement[0];\n-                }\n-                dos.writeInt(stackTrace.length);\n-                for (int i = 0; i < stackTrace.length; i++) {\n-                    StackTraceElement frame = stackTrace[i];\n-                    if (frame != null) {\n-                        dos.writeUTF(emptyIfNull(frame.getClassLoaderName()));\n-                        dos.writeUTF(emptyIfNull(frame.getModuleName()));\n-                        dos.writeUTF(emptyIfNull(frame.getModuleVersion()));\n-                        dos.writeUTF(emptyIfNull(frame.getClassName()));\n-                        dos.writeUTF(emptyIfNull(frame.getMethodName()));\n-                        dos.writeUTF(emptyIfNull(frame.getFileName()));\n-                        dos.writeInt(frame.getLineNumber());\n-                    }\n-                }\n-            }\n-        }\n-        return baos.toByteArray();\n-    }\n-\n-    \/**\n-     * Gets the stack of the current thread without the frames between this call and the one just\n-     * below the frame of the first method in {@link CompilerToVM}. The chopped frames are for the\n-     * VM call to {@link HotSpotJVMCIRuntime#decodeAndThrowThrowable}.\n-     *\/\n-    private static StackTraceElement[] getMyStackTrace() {\n-        StackTraceElement[] stack = new Exception().getStackTrace();\n-        for (int i = 0; i < stack.length; i++) {\n-            StackTraceElement e = stack[i];\n-            if (e.getClassName().equals(CompilerToVM.class.getName())) {\n-                return Arrays.copyOfRange(stack, i, stack.length);\n-            }\n-        }\n-        \/\/ This should never happen but since we're in exception handling\n-        \/\/ code, just return a safe value instead raising a nested exception.\n-        return new StackTraceElement[0];\n-    }\n-\n-    \/**\n-     * Decodes {@code encodedThrowable} into a {@link TranslatedException}.\n-     *\n-     * @param encodedThrowable an encoded exception in the format specified by\n-     *            {@link #encodeThrowable}\n-     *\/\n-    static Throwable decodeThrowable(byte[] encodedThrowable) {\n-        try (DataInputStream dis = new DataInputStream(new GZIPInputStream(new ByteArrayInputStream(encodedThrowable)))) {\n-            Throwable cause = null;\n-            Throwable throwable = null;\n-            StackTraceElement[] myStack = getMyStackTrace();\n-            while (dis.available() != 0) {\n-                String exceptionClassName = dis.readUTF();\n-                String exceptionMessage = emptyAsNull(dis.readUTF());\n-                throwable = create(exceptionClassName, exceptionMessage, cause);\n-                int stackTraceDepth = dis.readInt();\n-                StackTraceElement[] stackTrace = new StackTraceElement[stackTraceDepth + myStack.length];\n-                int stackTraceIndex = 0;\n-                int myStackIndex = 0;\n-                for (int j = 0; j < stackTraceDepth; j++) {\n-                    String classLoaderName = emptyAsNull(dis.readUTF());\n-                    String moduleName = emptyAsNull(dis.readUTF());\n-                    String moduleVersion = emptyAsNull(dis.readUTF());\n-                    String className = emptyAsNull(dis.readUTF());\n-                    String methodName = emptyAsNull(dis.readUTF());\n-                    String fileName = emptyAsNull(dis.readUTF());\n-                    int lineNumber = dis.readInt();\n-                    StackTraceElement ste = new StackTraceElement(classLoaderName, moduleName, moduleVersion, className, methodName, fileName, lineNumber);\n-\n-                    if (ste.isNativeMethod()) {\n-                        \/\/ Best effort attempt to weave stack traces from two heaps into\n-                        \/\/ a single stack trace using native method frames as stitching points.\n-                        \/\/ This is not 100% reliable as there's no guarantee that native method\n-                        \/\/ frames only exist for calls between HotSpot and libjvmci.\n-                        while (myStackIndex < myStack.length) {\n-                            StackTraceElement suffixSTE = myStack[myStackIndex++];\n-                            if (suffixSTE.isNativeMethod()) {\n-                                break;\n-                            }\n-                            stackTrace[stackTraceIndex++] = suffixSTE;\n-                        }\n-                    }\n-                    stackTrace[stackTraceIndex++] = ste;\n-                }\n-                while (myStackIndex < myStack.length) {\n-                    stackTrace[stackTraceIndex++] = myStack[myStackIndex++];\n-                }\n-                throwable.setStackTrace(stackTrace);\n-                cause = throwable;\n-            }\n-            return throwable;\n-        } catch (Throwable translationFailure) {\n-            assert printStackTrace(translationFailure);\n-            return new TranslatedException(\"Error decoding exception: \" + encodedThrowable, translationFailure.getClass().getName());\n-        }\n-    }\n-}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/TranslatedException.java","additions":0,"deletions":275,"binary":false,"changes":275,"status":"deleted"},{"patch":"@@ -26,3 +26,0 @@\n-import java.io.ByteArrayOutputStream;\n-import java.io.DataInputStream;\n-import java.io.DataOutputStream;\n@@ -37,0 +34,1 @@\n+import java.util.Properties;\n@@ -45,2 +43,0 @@\n-import static java.nio.charset.StandardCharsets.UTF_8;\n-\n@@ -269,70 +265,2 @@\n-     * A Java {@code char} has a maximal UTF8 length of 3.\n-     *\/\n-    private static final int MAX_UNICODE_IN_UTF8_LENGTH = 3;\n-\n-    \/**\n-     * {@link DataOutputStream#writeUTF(String)} only supports values whose UTF8 encoding length is\n-     * less than 65535.\n-     *\/\n-    private static final int MAX_UTF8_PROPERTY_STRING_LENGTH = 65535 \/ MAX_UNICODE_IN_UTF8_LENGTH;\n-\n-    \/**\n-     * Serializes the {@linkplain #getSavedProperties() saved system properties} to a byte array for\n-     * the purpose of {@linkplain #initializeSavedProperties(byte[]) initializing} the initial\n-     * properties in the JVMCI shared library.\n-     *\/\n-    @VMEntryPoint\n-    private static byte[] serializeSavedProperties() throws IOException {\n-        if (IS_IN_NATIVE_IMAGE) {\n-            throw new InternalError(\"Can only serialize saved properties in HotSpot runtime\");\n-        }\n-        return serializeProperties(Services.getSavedProperties());\n-    }\n-\n-    private static byte[] serializeProperties(Map<String, String> props) throws IOException {\n-        \/\/ Compute size of output on the assumption that\n-        \/\/ all system properties have ASCII names and values\n-        int estimate = 4 + 4;\n-        int nonUtf8Props = 0;\n-        for (Map.Entry<String, String> e : props.entrySet()) {\n-            String name = e.getKey();\n-            String value = e.getValue();\n-            estimate += (2 + (name.length())) + (2 + (value.length()));\n-            if (name.length() > MAX_UTF8_PROPERTY_STRING_LENGTH || value.length() > MAX_UTF8_PROPERTY_STRING_LENGTH) {\n-                nonUtf8Props++;\n-            }\n-        }\n-\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream(estimate);\n-        DataOutputStream out = new DataOutputStream(baos);\n-        out.writeInt(props.size() - nonUtf8Props);\n-        out.writeInt(nonUtf8Props);\n-        for (Map.Entry<String, String> e : props.entrySet()) {\n-            String name = e.getKey();\n-            String value = e.getValue();\n-            if (name.length() <= MAX_UTF8_PROPERTY_STRING_LENGTH && value.length() <= MAX_UTF8_PROPERTY_STRING_LENGTH) {\n-                out.writeUTF(name);\n-                out.writeUTF(value);\n-            }\n-        }\n-        if (nonUtf8Props != 0) {\n-            for (Map.Entry<String, String> e : props.entrySet()) {\n-                String name = e.getKey();\n-                String value = e.getValue();\n-                if (name.length() > MAX_UTF8_PROPERTY_STRING_LENGTH || value.length() > MAX_UTF8_PROPERTY_STRING_LENGTH) {\n-                    byte[] utf8Name = name.getBytes(UTF_8);\n-                    byte[] utf8Value = value.getBytes(UTF_8);\n-                    out.writeInt(utf8Name.length);\n-                    out.write(utf8Name);\n-                    out.writeInt(utf8Value.length);\n-                    out.write(utf8Value);\n-                }\n-            }\n-        }\n-        return baos.toByteArray();\n-    }\n-\n-    \/**\n-     * Initialized the {@linkplain #getSavedProperties() saved system properties} in the JVMCI\n-     * shared library from the {@linkplain #serializeSavedProperties() serialized saved properties}\n-     * in the HotSpot runtime.\n+     * Initializes {@link #savedProperties} from the byte array returned by\n+     * {@code jdk.internal.vm.VMSupport.serializeSavedPropertiesToByteArray()}.\n@@ -345,26 +273,5 @@\n-        savedProperties = Collections.unmodifiableMap(deserializeProperties(serializedProperties));\n-    }\n-\n-    private static Map<String, String> deserializeProperties(byte[] serializedProperties) throws IOException {\n-        DataInputStream in = new DataInputStream(new ByteArrayInputStream(serializedProperties));\n-        int utf8Props = in.readInt();\n-        int nonUtf8Props = in.readInt();\n-        Map<String, String> props = new HashMap<>(utf8Props + nonUtf8Props);\n-        int index = 0;\n-        while (in.available() != 0) {\n-            if (index < utf8Props) {\n-                String name = in.readUTF();\n-                String value = in.readUTF();\n-                props.put(name, value);\n-            } else {\n-                int nameLen = in.readInt();\n-                byte[] nameBytes = new byte[nameLen];\n-                in.read(nameBytes);\n-                int valueLen = in.readInt();\n-                byte[] valueBytes = new byte[valueLen];\n-                in.read(valueBytes);\n-                String name = new String(nameBytes, UTF_8);\n-                String value = new String(valueBytes, UTF_8);\n-                props.put(name, value);\n-            }\n-            index++;\n+        Properties props = new Properties();\n+        props.load(new ByteArrayInputStream(serializedProperties));\n+        Map<String, String> map = new HashMap<>(props.size());\n+        for (var e : props.entrySet()) {\n+            map.put((String) e.getKey(), (String) e.getValue());\n@@ -372,1 +279,2 @@\n-        return props;\n+\n+        savedProperties = Collections.unmodifiableMap(map);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.services\/src\/jdk\/vm\/ci\/services\/Services.java","additions":10,"deletions":102,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -1,2 +0,0 @@\n-\/*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org\/license *\/\n-!function(e,t){\"use strict\";\"object\"==typeof module&&\"object\"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error(\"jQuery requires a window with a document\");return t(e)}:t(e)}(\"undefined\"!=typeof window?window:this,function(C,e){\"use strict\";var t=[],r=Object.getPrototypeOf,s=t.slice,g=t.flat?function(e){return t.flat.call(e)}:function(e){return t.concat.apply([],e)},u=t.push,i=t.indexOf,n={},o=n.toString,v=n.hasOwnProperty,a=v.toString,l=a.call(Object),y={},m=function(e){return\"function\"==typeof e&&\"number\"!=typeof e.nodeType&&\"function\"!=typeof e.item},x=function(e){return null!=e&&e===e.window},E=C.document,c={type:!0,src:!0,nonce:!0,noModule:!0};function b(e,t,n){var r,i,o=(n=n||E).createElement(\"script\");if(o.text=e,t)for(r in c)(i=t[r]||t.getAttribute&&t.getAttribute(r))&&o.setAttribute(r,i);n.head.appendChild(o).parentNode.removeChild(o)}function w(e){return null==e?e+\"\":\"object\"==typeof e||\"function\"==typeof e?n[o.call(e)]||\"object\":typeof e}var f=\"3.6.0\",S=function(e,t){return new S.fn.init(e,t)};function p(e){var t=!!e&&\"length\"in e&&e.length,n=w(e);return!m(e)&&!x(e)&&(\"array\"===n||0===t||\"number\"==typeof t&&0<t&&t-1 in e)}S.fn=S.prototype={jquery:f,constructor:S,length:0,toArray:function(){return s.call(this)},get:function(e){return null==e?s.call(this):e<0?this[e+this.length]:this[e]},pushStack:function(e){var t=S.merge(this.constructor(),e);return t.prevObject=this,t},each:function(e){return S.each(this,e)},map:function(n){return this.pushStack(S.map(this,function(e,t){return n.call(e,t,e)}))},slice:function(){return this.pushStack(s.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},even:function(){return this.pushStack(S.grep(this,function(e,t){return(t+1)%2}))},odd:function(){return this.pushStack(S.grep(this,function(e,t){return t%2}))},eq:function(e){var t=this.length,n=+e+(e<0?t:0);return this.pushStack(0<=n&&n<t?[this[n]]:[])},end:function(){return this.prevObject||this.constructor()},push:u,sort:t.sort,splice:t.splice},S.extend=S.fn.extend=function(){var e,t,n,r,i,o,a=arguments[0]||{},s=1,u=arguments.length,l=!1;for(\"boolean\"==typeof a&&(l=a,a=arguments[s]||{},s++),\"object\"==typeof a||m(a)||(a={}),s===u&&(a=this,s--);s<u;s++)if(null!=(e=arguments[s]))for(t in e)r=e[t],\"__proto__\"!==t&&a!==r&&(l&&r&&(S.isPlainObject(r)||(i=Array.isArray(r)))?(n=a[t],o=i&&!Array.isArray(n)?[]:i||S.isPlainObject(n)?n:{},i=!1,a[t]=S.extend(l,o,r)):void 0!==r&&(a[t]=r));return a},S.extend({expando:\"jQuery\"+(f+Math.random()).replace(\/\\D\/g,\"\"),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isPlainObject:function(e){var t,n;return!(!e||\"[object Object]\"!==o.call(e))&&(!(t=r(e))||\"function\"==typeof(n=v.call(t,\"constructor\")&&t.constructor)&&a.call(n)===l)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},globalEval:function(e,t,n){b(e,{nonce:t&&t.nonce},n)},each:function(e,t){var n,r=0;if(p(e)){for(n=e.length;r<n;r++)if(!1===t.call(e[r],r,e[r]))break}else for(r in e)if(!1===t.call(e[r],r,e[r]))break;return e},makeArray:function(e,t){var n=t||[];return null!=e&&(p(Object(e))?S.merge(n,\"string\"==typeof e?[e]:e):u.call(n,e)),n},inArray:function(e,t,n){return null==t?-1:i.call(t,e,n)},merge:function(e,t){for(var n=+t.length,r=0,i=e.length;r<n;r++)e[i++]=t[r];return e.length=i,e},grep:function(e,t,n){for(var r=[],i=0,o=e.length,a=!n;i<o;i++)!t(e[i],i)!==a&&r.push(e[i]);return r},map:function(e,t,n){var r,i,o=0,a=[];if(p(e))for(r=e.length;o<r;o++)null!=(i=t(e[o],o,n))&&a.push(i);else for(o in e)null!=(i=t(e[o],o,n))&&a.push(i);return g(a)},guid:1,support:y}),\"function\"==typeof Symbol&&(S.fn[Symbol.iterator]=t[Symbol.iterator]),S.each(\"Boolean Number String Function Array Date RegExp Object Error Symbol\".split(\" \"),function(e,t){n[\"[object \"+t+\"]\"]=t.toLowerCase()});var d=function(n){var e,d,b,o,i,h,f,g,w,u,l,T,C,a,E,v,s,c,y,S=\"sizzle\"+1*new Date,p=n.document,k=0,r=0,m=ue(),x=ue(),A=ue(),N=ue(),j=function(e,t){return e===t&&(l=!0),0},D={}.hasOwnProperty,t=[],q=t.pop,L=t.push,H=t.push,O=t.slice,P=function(e,t){for(var n=0,r=e.length;n<r;n++)if(e[n]===t)return n;return-1},R=\"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",M=\"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",I=\"(?:\\\\\\\\[\\\\da-fA-F]{1,6}\"+M+\"?|\\\\\\\\[^\\\\r\\\\n\\\\f]|[\\\\w-]|[^\\0-\\\\x7f])+\",W=\"\\\\[\"+M+\"*(\"+I+\")(?:\"+M+\"*([*^$|!~]?=)\"+M+\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\"+I+\"))|)\"+M+\"*\\\\]\",F=\":(\"+I+\")(?:\\\\((('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\"+W+\")*)|.*)\\\\)|)\",B=new RegExp(M+\"+\",\"g\"),$=new RegExp(\"^\"+M+\"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\"+M+\"+$\",\"g\"),_=new RegExp(\"^\"+M+\"*,\"+M+\"*\"),z=new RegExp(\"^\"+M+\"*([>+~]|\"+M+\")\"+M+\"*\"),U=new RegExp(M+\"|>\"),X=new RegExp(F),V=new RegExp(\"^\"+I+\"$\"),G={ID:new RegExp(\"^#(\"+I+\")\"),CLASS:new RegExp(\"^\\\\.(\"+I+\")\"),TAG:new RegExp(\"^(\"+I+\"|[*])\"),ATTR:new RegExp(\"^\"+W),PSEUDO:new RegExp(\"^\"+F),CHILD:new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\"+M+\"*(even|odd|(([+-]|)(\\\\d*)n|)\"+M+\"*(?:([+-]|)\"+M+\"*(\\\\d+)|))\"+M+\"*\\\\)|)\",\"i\"),bool:new RegExp(\"^(?:\"+R+\")$\",\"i\"),needsContext:new RegExp(\"^\"+M+\"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\"+M+\"*((?:-\\\\d)?\\\\d*)\"+M+\"*\\\\)|)(?=[^-]|$)\",\"i\")},Y=\/HTML$\/i,Q=\/^(?:input|select|textarea|button)$\/i,J=\/^h\\d$\/i,K=\/^[^{]+\\{\\s*\\[native \\w\/,Z=\/^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$\/,ee=\/[+~]\/,te=new RegExp(\"\\\\\\\\[\\\\da-fA-F]{1,6}\"+M+\"?|\\\\\\\\([^\\\\r\\\\n\\\\f])\",\"g\"),ne=function(e,t){var n=\"0x\"+e.slice(1)-65536;return t||(n<0?String.fromCharCode(n+65536):String.fromCharCode(n>>10|55296,1023&n|56320))},re=\/([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]\/g,ie=function(e,t){return t?\"\\0\"===e?\"\\ufffd\":e.slice(0,-1)+\"\\\\\"+e.charCodeAt(e.length-1).toString(16)+\" \":\"\\\\\"+e},oe=function(){T()},ae=be(function(e){return!0===e.disabled&&\"fieldset\"===e.nodeName.toLowerCase()},{dir:\"parentNode\",next:\"legend\"});try{H.apply(t=O.call(p.childNodes),p.childNodes),t[p.childNodes.length].nodeType}catch(e){H={apply:t.length?function(e,t){L.apply(e,O.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function se(t,e,n,r){var i,o,a,s,u,l,c,f=e&&e.ownerDocument,p=e?e.nodeType:9;if(n=n||[],\"string\"!=typeof t||!t||1!==p&&9!==p&&11!==p)return n;if(!r&&(T(e),e=e||C,E)){if(11!==p&&(u=Z.exec(t)))if(i=u[1]){if(9===p){if(!(a=e.getElementById(i)))return n;if(a.id===i)return n.push(a),n}else if(f&&(a=f.getElementById(i))&&y(e,a)&&a.id===i)return n.push(a),n}else{if(u[2])return H.apply(n,e.getElementsByTagName(t)),n;if((i=u[3])&&d.getElementsByClassName&&e.getElementsByClassName)return H.apply(n,e.getElementsByClassName(i)),n}if(d.qsa&&!N[t+\" \"]&&(!v||!v.test(t))&&(1!==p||\"object\"!==e.nodeName.toLowerCase())){if(c=t,f=e,1===p&&(U.test(t)||z.test(t))){(f=ee.test(t)&&ye(e.parentNode)||e)===e&&d.scope||((s=e.getAttribute(\"id\"))?s=s.replace(re,ie):e.setAttribute(\"id\",s=S)),o=(l=h(t)).length;while(o--)l[o]=(s?\"#\"+s:\":scope\")+\" \"+xe(l[o]);c=l.join(\",\")}try{return H.apply(n,f.querySelectorAll(c)),n}catch(e){N(t,!0)}finally{s===S&&e.removeAttribute(\"id\")}}}return g(t.replace($,\"$1\"),e,n,r)}function ue(){var r=[];return function e(t,n){return r.push(t+\" \")>b.cacheLength&&delete e[r.shift()],e[t+\" \"]=n}}function le(e){return e[S]=!0,e}function ce(e){var t=C.createElement(\"fieldset\");try{return!!e(t)}catch(e){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function fe(e,t){var n=e.split(\"|\"),r=n.length;while(r--)b.attrHandle[n[r]]=t}function pe(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&e.sourceIndex-t.sourceIndex;if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function de(t){return function(e){return\"input\"===e.nodeName.toLowerCase()&&e.type===t}}function he(n){return function(e){var t=e.nodeName.toLowerCase();return(\"input\"===t||\"button\"===t)&&e.type===n}}function ge(t){return function(e){return\"form\"in e?e.parentNode&&!1===e.disabled?\"label\"in e?\"label\"in e.parentNode?e.parentNode.disabled===t:e.disabled===t:e.isDisabled===t||e.isDisabled!==!t&&ae(e)===t:e.disabled===t:\"label\"in e&&e.disabled===t}}function ve(a){return le(function(o){return o=+o,le(function(e,t){var n,r=a([],e.length,o),i=r.length;while(i--)e[n=r[i]]&&(e[n]=!(t[n]=e[n]))})})}function ye(e){return e&&\"undefined\"!=typeof e.getElementsByTagName&&e}for(e in d=se.support={},i=se.isXML=function(e){var t=e&&e.namespaceURI,n=e&&(e.ownerDocument||e).documentElement;return!Y.test(t||n&&n.nodeName||\"HTML\")},T=se.setDocument=function(e){var t,n,r=e?e.ownerDocument||e:p;return r!=C&&9===r.nodeType&&r.documentElement&&(a=(C=r).documentElement,E=!i(C),p!=C&&(n=C.defaultView)&&n.top!==n&&(n.addEventListener?n.addEventListener(\"unload\",oe,!1):n.attachEvent&&n.attachEvent(\"onunload\",oe)),d.scope=ce(function(e){return a.appendChild(e).appendChild(C.createElement(\"div\")),\"undefined\"!=typeof e.querySelectorAll&&!e.querySelectorAll(\":scope fieldset div\").length}),d.attributes=ce(function(e){return e.className=\"i\",!e.getAttribute(\"className\")}),d.getElementsByTagName=ce(function(e){return e.appendChild(C.createComment(\"\")),!e.getElementsByTagName(\"*\").length}),d.getElementsByClassName=K.test(C.getElementsByClassName),d.getById=ce(function(e){return a.appendChild(e).id=S,!C.getElementsByName||!C.getElementsByName(S).length}),d.getById?(b.filter.ID=function(e){var t=e.replace(te,ne);return function(e){return e.getAttribute(\"id\")===t}},b.find.ID=function(e,t){if(\"undefined\"!=typeof t.getElementById&&E){var n=t.getElementById(e);return n?[n]:[]}}):(b.filter.ID=function(e){var n=e.replace(te,ne);return function(e){var t=\"undefined\"!=typeof e.getAttributeNode&&e.getAttributeNode(\"id\");return t&&t.value===n}},b.find.ID=function(e,t){if(\"undefined\"!=typeof t.getElementById&&E){var n,r,i,o=t.getElementById(e);if(o){if((n=o.getAttributeNode(\"id\"))&&n.value===e)return[o];i=t.getElementsByName(e),r=0;while(o=i[r++])if((n=o.getAttributeNode(\"id\"))&&n.value===e)return[o]}return[]}}),b.find.TAG=d.getElementsByTagName?function(e,t){return\"undefined\"!=typeof t.getElementsByTagName?t.getElementsByTagName(e):d.qsa?t.querySelectorAll(e):void 0}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if(\"*\"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},b.find.CLASS=d.getElementsByClassName&&function(e,t){if(\"undefined\"!=typeof t.getElementsByClassName&&E)return t.getElementsByClassName(e)},s=[],v=[],(d.qsa=K.test(C.querySelectorAll))&&(ce(function(e){var t;a.appendChild(e).innerHTML=\"<a id='\"+S+\"'><\/a><select id='\"+S+\"-\\r\\\\' msallowcapture=''><option selected=''><\/option><\/select>\",e.querySelectorAll(\"[msallowcapture^='']\").length&&v.push(\"[*^$]=\"+M+\"*(?:''|\\\"\\\")\"),e.querySelectorAll(\"[selected]\").length||v.push(\"\\\\[\"+M+\"*(?:value|\"+R+\")\"),e.querySelectorAll(\"[id~=\"+S+\"-]\").length||v.push(\"~=\"),(t=C.createElement(\"input\")).setAttribute(\"name\",\"\"),e.appendChild(t),e.querySelectorAll(\"[name='']\").length||v.push(\"\\\\[\"+M+\"*name\"+M+\"*=\"+M+\"*(?:''|\\\"\\\")\"),e.querySelectorAll(\":checked\").length||v.push(\":checked\"),e.querySelectorAll(\"a#\"+S+\"+*\").length||v.push(\".#.+[+~]\"),e.querySelectorAll(\"\\\\\\f\"),v.push(\"[\\\\r\\\\n\\\\f]\")}),ce(function(e){e.innerHTML=\"<a href='' disabled='disabled'><\/a><select disabled='disabled'><option\/><\/select>\";var t=C.createElement(\"input\");t.setAttribute(\"type\",\"hidden\"),e.appendChild(t).setAttribute(\"name\",\"D\"),e.querySelectorAll(\"[name=d]\").length&&v.push(\"name\"+M+\"*[*^$|!~]?=\"),2!==e.querySelectorAll(\":enabled\").length&&v.push(\":enabled\",\":disabled\"),a.appendChild(e).disabled=!0,2!==e.querySelectorAll(\":disabled\").length&&v.push(\":enabled\",\":disabled\"),e.querySelectorAll(\"*,:x\"),v.push(\",.*:\")})),(d.matchesSelector=K.test(c=a.matches||a.webkitMatchesSelector||a.mozMatchesSelector||a.oMatchesSelector||a.msMatchesSelector))&&ce(function(e){d.disconnectedMatch=c.call(e,\"*\"),c.call(e,\"[s!='']:x\"),s.push(\"!=\",F)}),v=v.length&&new RegExp(v.join(\"|\")),s=s.length&&new RegExp(s.join(\"|\")),t=K.test(a.compareDocumentPosition),y=t||K.test(a.contains)?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},j=t?function(e,t){if(e===t)return l=!0,0;var n=!e.compareDocumentPosition-!t.compareDocumentPosition;return n||(1&(n=(e.ownerDocument||e)==(t.ownerDocument||t)?e.compareDocumentPosition(t):1)||!d.sortDetached&&t.compareDocumentPosition(e)===n?e==C||e.ownerDocument==p&&y(p,e)?-1:t==C||t.ownerDocument==p&&y(p,t)?1:u?P(u,e)-P(u,t):0:4&n?-1:1)}:function(e,t){if(e===t)return l=!0,0;var n,r=0,i=e.parentNode,o=t.parentNode,a=[e],s=[t];if(!i||!o)return e==C?-1:t==C?1:i?-1:o?1:u?P(u,e)-P(u,t):0;if(i===o)return pe(e,t);n=e;while(n=n.parentNode)a.unshift(n);n=t;while(n=n.parentNode)s.unshift(n);while(a[r]===s[r])r++;return r?pe(a[r],s[r]):a[r]==p?-1:s[r]==p?1:0}),C},se.matches=function(e,t){return se(e,null,null,t)},se.matchesSelector=function(e,t){if(T(e),d.matchesSelector&&E&&!N[t+\" \"]&&(!s||!s.test(t))&&(!v||!v.test(t)))try{var n=c.call(e,t);if(n||d.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(e){N(t,!0)}return 0<se(t,C,null,[e]).length},se.contains=function(e,t){return(e.ownerDocument||e)!=C&&T(e),y(e,t)},se.attr=function(e,t){(e.ownerDocument||e)!=C&&T(e);var n=b.attrHandle[t.toLowerCase()],r=n&&D.call(b.attrHandle,t.toLowerCase())?n(e,t,!E):void 0;return void 0!==r?r:d.attributes||!E?e.getAttribute(t):(r=e.getAttributeNode(t))&&r.specified?r.value:null},se.escape=function(e){return(e+\"\").replace(re,ie)},se.error=function(e){throw new Error(\"Syntax error, unrecognized expression: \"+e)},se.uniqueSort=function(e){var t,n=[],r=0,i=0;if(l=!d.detectDuplicates,u=!d.sortStable&&e.slice(0),e.sort(j),l){while(t=e[i++])t===e[i]&&(r=n.push(i));while(r--)e.splice(n[r],1)}return u=null,e},o=se.getText=function(e){var t,n=\"\",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if(\"string\"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=o(e)}else if(3===i||4===i)return e.nodeValue}else while(t=e[r++])n+=o(t);return n},(b=se.selectors={cacheLength:50,createPseudo:le,match:G,attrHandle:{},find:{},relative:{\">\":{dir:\"parentNode\",first:!0},\" \":{dir:\"parentNode\"},\"+\":{dir:\"previousSibling\",first:!0},\"~\":{dir:\"previousSibling\"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(te,ne),e[3]=(e[3]||e[4]||e[5]||\"\").replace(te,ne),\"~=\"===e[2]&&(e[3]=\" \"+e[3]+\" \"),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),\"nth\"===e[1].slice(0,3)?(e[3]||se.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*(\"even\"===e[3]||\"odd\"===e[3])),e[5]=+(e[7]+e[8]||\"odd\"===e[3])):e[3]&&se.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return G.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||\"\":n&&X.test(n)&&(t=h(n,!0))&&(t=n.indexOf(\")\",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(te,ne).toLowerCase();return\"*\"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=m[e+\" \"];return t||(t=new RegExp(\"(^|\"+M+\")\"+e+\"(\"+M+\"|$)\"))&&m(e,function(e){return t.test(\"string\"==typeof e.className&&e.className||\"undefined\"!=typeof e.getAttribute&&e.getAttribute(\"class\")||\"\")})},ATTR:function(n,r,i){return function(e){var t=se.attr(e,n);return null==t?\"!=\"===r:!r||(t+=\"\",\"=\"===r?t===i:\"!=\"===r?t!==i:\"^=\"===r?i&&0===t.indexOf(i):\"*=\"===r?i&&-1<t.indexOf(i):\"$=\"===r?i&&t.slice(-i.length)===i:\"~=\"===r?-1<(\" \"+t.replace(B,\" \")+\" \").indexOf(i):\"|=\"===r&&(t===i||t.slice(0,i.length+1)===i+\"-\"))}},CHILD:function(h,e,t,g,v){var y=\"nth\"!==h.slice(0,3),m=\"last\"!==h.slice(-4),x=\"of-type\"===e;return 1===g&&0===v?function(e){return!!e.parentNode}:function(e,t,n){var r,i,o,a,s,u,l=y!==m?\"nextSibling\":\"previousSibling\",c=e.parentNode,f=x&&e.nodeName.toLowerCase(),p=!n&&!x,d=!1;if(c){if(y){while(l){a=e;while(a=a[l])if(x?a.nodeName.toLowerCase()===f:1===a.nodeType)return!1;u=l=\"only\"===h&&!u&&\"nextSibling\"}return!0}if(u=[m?c.firstChild:c.lastChild],m&&p){d=(s=(r=(i=(o=(a=c)[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===k&&r[1])&&r[2],a=s&&c.childNodes[s];while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if(1===a.nodeType&&++d&&a===e){i[h]=[k,s,d];break}}else if(p&&(d=s=(r=(i=(o=(a=e)[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===k&&r[1]),!1===d)while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if((x?a.nodeName.toLowerCase()===f:1===a.nodeType)&&++d&&(p&&((i=(o=a[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]=[k,d]),a===e))break;return(d-=v)===g||d%g==0&&0<=d\/g}}},PSEUDO:function(e,o){var t,a=b.pseudos[e]||b.setFilters[e.toLowerCase()]||se.error(\"unsupported pseudo: \"+e);return a[S]?a(o):1<a.length?(t=[e,e,\"\",o],b.setFilters.hasOwnProperty(e.toLowerCase())?le(function(e,t){var n,r=a(e,o),i=r.length;while(i--)e[n=P(e,r[i])]=!(t[n]=r[i])}):function(e){return a(e,0,t)}):a}},pseudos:{not:le(function(e){var r=[],i=[],s=f(e.replace($,\"$1\"));return s[S]?le(function(e,t,n,r){var i,o=s(e,null,r,[]),a=e.length;while(a--)(i=o[a])&&(e[a]=!(t[a]=i))}):function(e,t,n){return r[0]=e,s(r,null,n,i),r[0]=null,!i.pop()}}),has:le(function(t){return function(e){return 0<se(t,e).length}}),contains:le(function(t){return t=t.replace(te,ne),function(e){return-1<(e.textContent||o(e)).indexOf(t)}}),lang:le(function(n){return V.test(n||\"\")||se.error(\"unsupported lang: \"+n),n=n.replace(te,ne).toLowerCase(),function(e){var t;do{if(t=E?e.lang:e.getAttribute(\"xml:lang\")||e.getAttribute(\"lang\"))return(t=t.toLowerCase())===n||0===t.indexOf(n+\"-\")}while((e=e.parentNode)&&1===e.nodeType);return!1}}),target:function(e){var t=n.location&&n.location.hash;return t&&t.slice(1)===e.id},root:function(e){return e===a},focus:function(e){return e===C.activeElement&&(!C.hasFocus||C.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:ge(!1),disabled:ge(!0),checked:function(e){var t=e.nodeName.toLowerCase();return\"input\"===t&&!!e.checked||\"option\"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!b.pseudos.empty(e)},header:function(e){return J.test(e.nodeName)},input:function(e){return Q.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return\"input\"===t&&\"button\"===e.type||\"button\"===t},text:function(e){var t;return\"input\"===e.nodeName.toLowerCase()&&\"text\"===e.type&&(null==(t=e.getAttribute(\"type\"))||\"text\"===t.toLowerCase())},first:ve(function(){return[0]}),last:ve(function(e,t){return[t-1]}),eq:ve(function(e,t,n){return[n<0?n+t:n]}),even:ve(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:ve(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:ve(function(e,t,n){for(var r=n<0?n+t:t<n?t:n;0<=--r;)e.push(r);return e}),gt:ve(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}}).pseudos.nth=b.pseudos.eq,{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})b.pseudos[e]=de(e);for(e in{submit:!0,reset:!0})b.pseudos[e]=he(e);function me(){}function xe(e){for(var t=0,n=e.length,r=\"\";t<n;t++)r+=e[t].value;return r}function be(s,e,t){var u=e.dir,l=e.next,c=l||u,f=t&&\"parentNode\"===c,p=r++;return e.first?function(e,t,n){while(e=e[u])if(1===e.nodeType||f)return s(e,t,n);return!1}:function(e,t,n){var r,i,o,a=[k,p];if(n){while(e=e[u])if((1===e.nodeType||f)&&s(e,t,n))return!0}else while(e=e[u])if(1===e.nodeType||f)if(i=(o=e[S]||(e[S]={}))[e.uniqueID]||(o[e.uniqueID]={}),l&&l===e.nodeName.toLowerCase())e=e[u]||e;else{if((r=i[c])&&r[0]===k&&r[1]===p)return a[2]=r[2];if((i[c]=a)[2]=s(e,t,n))return!0}return!1}}function we(i){return 1<i.length?function(e,t,n){var r=i.length;while(r--)if(!i[r](e,t,n))return!1;return!0}:i[0]}function Te(e,t,n,r,i){for(var o,a=[],s=0,u=e.length,l=null!=t;s<u;s++)(o=e[s])&&(n&&!n(o,r,i)||(a.push(o),l&&t.push(s)));return a}function Ce(d,h,g,v,y,e){return v&&!v[S]&&(v=Ce(v)),y&&!y[S]&&(y=Ce(y,e)),le(function(e,t,n,r){var i,o,a,s=[],u=[],l=t.length,c=e||function(e,t,n){for(var r=0,i=t.length;r<i;r++)se(e,t[r],n);return n}(h||\"*\",n.nodeType?[n]:n,[]),f=!d||!e&&h?c:Te(c,s,d,n,r),p=g?y||(e?d:l||v)?[]:t:f;if(g&&g(f,p,n,r),v){i=Te(p,u),v(i,[],n,r),o=i.length;while(o--)(a=i[o])&&(p[u[o]]=!(f[u[o]]=a))}if(e){if(y||d){if(y){i=[],o=p.length;while(o--)(a=p[o])&&i.push(f[o]=a);y(null,p=[],i,r)}o=p.length;while(o--)(a=p[o])&&-1<(i=y?P(e,a):s[o])&&(e[i]=!(t[i]=a))}}else p=Te(p===t?p.splice(l,p.length):p),y?y(null,t,p,r):H.apply(t,p)})}function Ee(e){for(var i,t,n,r=e.length,o=b.relative[e[0].type],a=o||b.relative[\" \"],s=o?1:0,u=be(function(e){return e===i},a,!0),l=be(function(e){return-1<P(i,e)},a,!0),c=[function(e,t,n){var r=!o&&(n||t!==w)||((i=t).nodeType?u(e,t,n):l(e,t,n));return i=null,r}];s<r;s++)if(t=b.relative[e[s].type])c=[be(we(c),t)];else{if((t=b.filter[e[s].type].apply(null,e[s].matches))[S]){for(n=++s;n<r;n++)if(b.relative[e[n].type])break;return Ce(1<s&&we(c),1<s&&xe(e.slice(0,s-1).concat({value:\" \"===e[s-2].type?\"*\":\"\"})).replace($,\"$1\"),t,s<n&&Ee(e.slice(s,n)),n<r&&Ee(e=e.slice(n)),n<r&&xe(e))}c.push(t)}return we(c)}return me.prototype=b.filters=b.pseudos,b.setFilters=new me,h=se.tokenize=function(e,t){var n,r,i,o,a,s,u,l=x[e+\" \"];if(l)return t?0:l.slice(0);a=e,s=[],u=b.preFilter;while(a){for(o in n&&!(r=_.exec(a))||(r&&(a=a.slice(r[0].length)||a),s.push(i=[])),n=!1,(r=z.exec(a))&&(n=r.shift(),i.push({value:n,type:r[0].replace($,\" \")}),a=a.slice(n.length)),b.filter)!(r=G[o].exec(a))||u[o]&&!(r=u[o](r))||(n=r.shift(),i.push({value:n,type:o,matches:r}),a=a.slice(n.length));if(!n)break}return t?a.length:a?se.error(e):x(e,s).slice(0)},f=se.compile=function(e,t){var n,v,y,m,x,r,i=[],o=[],a=A[e+\" \"];if(!a){t||(t=h(e)),n=t.length;while(n--)(a=Ee(t[n]))[S]?i.push(a):o.push(a);(a=A(e,(v=o,m=0<(y=i).length,x=0<v.length,r=function(e,t,n,r,i){var o,a,s,u=0,l=\"0\",c=e&&[],f=[],p=w,d=e||x&&b.find.TAG(\"*\",i),h=k+=null==p?1:Math.random()||.1,g=d.length;for(i&&(w=t==C||t||i);l!==g&&null!=(o=d[l]);l++){if(x&&o){a=0,t||o.ownerDocument==C||(T(o),n=!E);while(s=v[a++])if(s(o,t||C,n)){r.push(o);break}i&&(k=h)}m&&((o=!s&&o)&&u--,e&&c.push(o))}if(u+=l,m&&l!==u){a=0;while(s=y[a++])s(c,f,t,n);if(e){if(0<u)while(l--)c[l]||f[l]||(f[l]=q.call(r));f=Te(f)}H.apply(r,f),i&&!e&&0<f.length&&1<u+y.length&&se.uniqueSort(r)}return i&&(k=h,w=p),c},m?le(r):r))).selector=e}return a},g=se.select=function(e,t,n,r){var i,o,a,s,u,l=\"function\"==typeof e&&e,c=!r&&h(e=l.selector||e);if(n=n||[],1===c.length){if(2<(o=c[0]=c[0].slice(0)).length&&\"ID\"===(a=o[0]).type&&9===t.nodeType&&E&&b.relative[o[1].type]){if(!(t=(b.find.ID(a.matches[0].replace(te,ne),t)||[])[0]))return n;l&&(t=t.parentNode),e=e.slice(o.shift().value.length)}i=G.needsContext.test(e)?0:o.length;while(i--){if(a=o[i],b.relative[s=a.type])break;if((u=b.find[s])&&(r=u(a.matches[0].replace(te,ne),ee.test(o[0].type)&&ye(t.parentNode)||t))){if(o.splice(i,1),!(e=r.length&&xe(o)))return H.apply(n,r),n;break}}}return(l||f(e,c))(r,t,!E,n,!t||ee.test(e)&&ye(t.parentNode)||t),n},d.sortStable=S.split(\"\").sort(j).join(\"\")===S,d.detectDuplicates=!!l,T(),d.sortDetached=ce(function(e){return 1&e.compareDocumentPosition(C.createElement(\"fieldset\"))}),ce(function(e){return e.innerHTML=\"<a href='#'><\/a>\",\"#\"===e.firstChild.getAttribute(\"href\")})||fe(\"type|href|height|width\",function(e,t,n){if(!n)return e.getAttribute(t,\"type\"===t.toLowerCase()?1:2)}),d.attributes&&ce(function(e){return e.innerHTML=\"<input\/>\",e.firstChild.setAttribute(\"value\",\"\"),\"\"===e.firstChild.getAttribute(\"value\")})||fe(\"value\",function(e,t,n){if(!n&&\"input\"===e.nodeName.toLowerCase())return e.defaultValue}),ce(function(e){return null==e.getAttribute(\"disabled\")})||fe(R,function(e,t,n){var r;if(!n)return!0===e[t]?t.toLowerCase():(r=e.getAttributeNode(t))&&r.specified?r.value:null}),se}(C);S.find=d,S.expr=d.selectors,S.expr[\":\"]=S.expr.pseudos,S.uniqueSort=S.unique=d.uniqueSort,S.text=d.getText,S.isXMLDoc=d.isXML,S.contains=d.contains,S.escapeSelector=d.escape;var h=function(e,t,n){var r=[],i=void 0!==n;while((e=e[t])&&9!==e.nodeType)if(1===e.nodeType){if(i&&S(e).is(n))break;r.push(e)}return r},T=function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n},k=S.expr.match.needsContext;function A(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()}var N=\/^<([a-z][^\\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\\/?>(?:<\\\/\\1>|)$\/i;function j(e,n,r){return m(n)?S.grep(e,function(e,t){return!!n.call(e,t,e)!==r}):n.nodeType?S.grep(e,function(e){return e===n!==r}):\"string\"!=typeof n?S.grep(e,function(e){return-1<i.call(n,e)!==r}):S.filter(n,e,r)}S.filter=function(e,t,n){var r=t[0];return n&&(e=\":not(\"+e+\")\"),1===t.length&&1===r.nodeType?S.find.matchesSelector(r,e)?[r]:[]:S.find.matches(e,S.grep(t,function(e){return 1===e.nodeType}))},S.fn.extend({find:function(e){var t,n,r=this.length,i=this;if(\"string\"!=typeof e)return this.pushStack(S(e).filter(function(){for(t=0;t<r;t++)if(S.contains(i[t],this))return!0}));for(n=this.pushStack([]),t=0;t<r;t++)S.find(e,i[t],n);return 1<r?S.uniqueSort(n):n},filter:function(e){return this.pushStack(j(this,e||[],!1))},not:function(e){return this.pushStack(j(this,e||[],!0))},is:function(e){return!!j(this,\"string\"==typeof e&&k.test(e)?S(e):e||[],!1).length}});var D,q=\/^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$\/;(S.fn.init=function(e,t,n){var r,i;if(!e)return this;if(n=n||D,\"string\"==typeof e){if(!(r=\"<\"===e[0]&&\">\"===e[e.length-1]&&3<=e.length?[null,e,null]:q.exec(e))||!r[1]&&t)return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e);if(r[1]){if(t=t instanceof S?t[0]:t,S.merge(this,S.parseHTML(r[1],t&&t.nodeType?t.ownerDocument||t:E,!0)),N.test(r[1])&&S.isPlainObject(t))for(r in t)m(this[r])?this[r](t[r]):this.attr(r,t[r]);return this}return(i=E.getElementById(r[2]))&&(this[0]=i,this.length=1),this}return e.nodeType?(this[0]=e,this.length=1,this):m(e)?void 0!==n.ready?n.ready(e):e(S):S.makeArray(e,this)}).prototype=S.fn,D=S(E);var L=\/^(?:parents|prev(?:Until|All))\/,H={children:!0,contents:!0,next:!0,prev:!0};function O(e,t){while((e=e[t])&&1!==e.nodeType);return e}S.fn.extend({has:function(e){var t=S(e,this),n=t.length;return this.filter(function(){for(var e=0;e<n;e++)if(S.contains(this,t[e]))return!0})},closest:function(e,t){var n,r=0,i=this.length,o=[],a=\"string\"!=typeof e&&S(e);if(!k.test(e))for(;r<i;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(n.nodeType<11&&(a?-1<a.index(n):1===n.nodeType&&S.find.matchesSelector(n,e))){o.push(n);break}return this.pushStack(1<o.length?S.uniqueSort(o):o)},index:function(e){return e?\"string\"==typeof e?i.call(S(e),this[0]):i.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){return this.pushStack(S.uniqueSort(S.merge(this.get(),S(e,t))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),S.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return h(e,\"parentNode\")},parentsUntil:function(e,t,n){return h(e,\"parentNode\",n)},next:function(e){return O(e,\"nextSibling\")},prev:function(e){return O(e,\"previousSibling\")},nextAll:function(e){return h(e,\"nextSibling\")},prevAll:function(e){return h(e,\"previousSibling\")},nextUntil:function(e,t,n){return h(e,\"nextSibling\",n)},prevUntil:function(e,t,n){return h(e,\"previousSibling\",n)},siblings:function(e){return T((e.parentNode||{}).firstChild,e)},children:function(e){return T(e.firstChild)},contents:function(e){return null!=e.contentDocument&&r(e.contentDocument)?e.contentDocument:(A(e,\"template\")&&(e=e.content||e),S.merge([],e.childNodes))}},function(r,i){S.fn[r]=function(e,t){var n=S.map(this,i,e);return\"Until\"!==r.slice(-5)&&(t=e),t&&\"string\"==typeof t&&(n=S.filter(t,n)),1<this.length&&(H[r]||S.uniqueSort(n),L.test(r)&&n.reverse()),this.pushStack(n)}});var P=\/[^\\x20\\t\\r\\n\\f]+\/g;function R(e){return e}function M(e){throw e}function I(e,t,n,r){var i;try{e&&m(i=e.promise)?i.call(e).done(t).fail(n):e&&m(i=e.then)?i.call(e,t,n):t.apply(void 0,[e].slice(r))}catch(e){n.apply(void 0,[e])}}S.Callbacks=function(r){var e,n;r=\"string\"==typeof r?(e=r,n={},S.each(e.match(P)||[],function(e,t){n[t]=!0}),n):S.extend({},r);var i,t,o,a,s=[],u=[],l=-1,c=function(){for(a=a||r.once,o=i=!0;u.length;l=-1){t=u.shift();while(++l<s.length)!1===s[l].apply(t[0],t[1])&&r.stopOnFalse&&(l=s.length,t=!1)}r.memory||(t=!1),i=!1,a&&(s=t?[]:\"\")},f={add:function(){return s&&(t&&!i&&(l=s.length-1,u.push(t)),function n(e){S.each(e,function(e,t){m(t)?r.unique&&f.has(t)||s.push(t):t&&t.length&&\"string\"!==w(t)&&n(t)})}(arguments),t&&!i&&c()),this},remove:function(){return S.each(arguments,function(e,t){var n;while(-1<(n=S.inArray(t,s,n)))s.splice(n,1),n<=l&&l--}),this},has:function(e){return e?-1<S.inArray(e,s):0<s.length},empty:function(){return s&&(s=[]),this},disable:function(){return a=u=[],s=t=\"\",this},disabled:function(){return!s},lock:function(){return a=u=[],t||i||(s=t=\"\"),this},locked:function(){return!!a},fireWith:function(e,t){return a||(t=[e,(t=t||[]).slice?t.slice():t],u.push(t),i||c()),this},fire:function(){return f.fireWith(this,arguments),this},fired:function(){return!!o}};return f},S.extend({Deferred:function(e){var o=[[\"notify\",\"progress\",S.Callbacks(\"memory\"),S.Callbacks(\"memory\"),2],[\"resolve\",\"done\",S.Callbacks(\"once memory\"),S.Callbacks(\"once memory\"),0,\"resolved\"],[\"reject\",\"fail\",S.Callbacks(\"once memory\"),S.Callbacks(\"once memory\"),1,\"rejected\"]],i=\"pending\",a={state:function(){return i},always:function(){return s.done(arguments).fail(arguments),this},\"catch\":function(e){return a.then(null,e)},pipe:function(){var i=arguments;return S.Deferred(function(r){S.each(o,function(e,t){var n=m(i[t[4]])&&i[t[4]];s[t[1]](function(){var e=n&&n.apply(this,arguments);e&&m(e.promise)?e.promise().progress(r.notify).done(r.resolve).fail(r.reject):r[t[0]+\"With\"](this,n?[e]:arguments)})}),i=null}).promise()},then:function(t,n,r){var u=0;function l(i,o,a,s){return function(){var n=this,r=arguments,e=function(){var e,t;if(!(i<u)){if((e=a.apply(n,r))===o.promise())throw new TypeError(\"Thenable self-resolution\");t=e&&(\"object\"==typeof e||\"function\"==typeof e)&&e.then,m(t)?s?t.call(e,l(u,o,R,s),l(u,o,M,s)):(u++,t.call(e,l(u,o,R,s),l(u,o,M,s),l(u,o,R,o.notifyWith))):(a!==R&&(n=void 0,r=[e]),(s||o.resolveWith)(n,r))}},t=s?e:function(){try{e()}catch(e){S.Deferred.exceptionHook&&S.Deferred.exceptionHook(e,t.stackTrace),u<=i+1&&(a!==M&&(n=void 0,r=[e]),o.rejectWith(n,r))}};i?t():(S.Deferred.getStackHook&&(t.stackTrace=S.Deferred.getStackHook()),C.setTimeout(t))}}return S.Deferred(function(e){o[0][3].add(l(0,e,m(r)?r:R,e.notifyWith)),o[1][3].add(l(0,e,m(t)?t:R)),o[2][3].add(l(0,e,m(n)?n:M))}).promise()},promise:function(e){return null!=e?S.extend(e,a):a}},s={};return S.each(o,function(e,t){var n=t[2],r=t[5];a[t[1]]=n.add,r&&n.add(function(){i=r},o[3-e][2].disable,o[3-e][3].disable,o[0][2].lock,o[0][3].lock),n.add(t[3].fire),s[t[0]]=function(){return s[t[0]+\"With\"](this===s?void 0:this,arguments),this},s[t[0]+\"With\"]=n.fireWith}),a.promise(s),e&&e.call(s,s),s},when:function(e){var n=arguments.length,t=n,r=Array(t),i=s.call(arguments),o=S.Deferred(),a=function(t){return function(e){r[t]=this,i[t]=1<arguments.length?s.call(arguments):e,--n||o.resolveWith(r,i)}};if(n<=1&&(I(e,o.done(a(t)).resolve,o.reject,!n),\"pending\"===o.state()||m(i[t]&&i[t].then)))return o.then();while(t--)I(i[t],a(t),o.reject);return o.promise()}});var W=\/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$\/;S.Deferred.exceptionHook=function(e,t){C.console&&C.console.warn&&e&&W.test(e.name)&&C.console.warn(\"jQuery.Deferred exception: \"+e.message,e.stack,t)},S.readyException=function(e){C.setTimeout(function(){throw e})};var F=S.Deferred();function B(){E.removeEventListener(\"DOMContentLoaded\",B),C.removeEventListener(\"load\",B),S.ready()}S.fn.ready=function(e){return F.then(e)[\"catch\"](function(e){S.readyException(e)}),this},S.extend({isReady:!1,readyWait:1,ready:function(e){(!0===e?--S.readyWait:S.isReady)||(S.isReady=!0)!==e&&0<--S.readyWait||F.resolveWith(E,[S])}}),S.ready.then=F.then,\"complete\"===E.readyState||\"loading\"!==E.readyState&&!E.documentElement.doScroll?C.setTimeout(S.ready):(E.addEventListener(\"DOMContentLoaded\",B),C.addEventListener(\"load\",B));var $=function(e,t,n,r,i,o,a){var s=0,u=e.length,l=null==n;if(\"object\"===w(n))for(s in i=!0,n)$(e,t,s,n[s],!0,o,a);else if(void 0!==r&&(i=!0,m(r)||(a=!0),l&&(a?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(S(e),n)})),t))for(;s<u;s++)t(e[s],n,a?r:r.call(e[s],s,t(e[s],n)));return i?e:l?t.call(e):u?t(e[0],n):o},_=\/^-ms-\/,z=\/-([a-z])\/g;function U(e,t){return t.toUpperCase()}function X(e){return e.replace(_,\"ms-\").replace(z,U)}var V=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType};function G(){this.expando=S.expando+G.uid++}G.uid=1,G.prototype={cache:function(e){var t=e[this.expando];return t||(t={},V(e)&&(e.nodeType?e[this.expando]=t:Object.defineProperty(e,this.expando,{value:t,configurable:!0}))),t},set:function(e,t,n){var r,i=this.cache(e);if(\"string\"==typeof t)i[X(t)]=n;else for(r in t)i[X(r)]=t[r];return i},get:function(e,t){return void 0===t?this.cache(e):e[this.expando]&&e[this.expando][X(t)]},access:function(e,t,n){return void 0===t||t&&\"string\"==typeof t&&void 0===n?this.get(e,t):(this.set(e,t,n),void 0!==n?n:t)},remove:function(e,t){var n,r=e[this.expando];if(void 0!==r){if(void 0!==t){n=(t=Array.isArray(t)?t.map(X):(t=X(t))in r?[t]:t.match(P)||[]).length;while(n--)delete r[t[n]]}(void 0===t||S.isEmptyObject(r))&&(e.nodeType?e[this.expando]=void 0:delete e[this.expando])}},hasData:function(e){var t=e[this.expando];return void 0!==t&&!S.isEmptyObject(t)}};var Y=new G,Q=new G,J=\/^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$\/,K=\/[A-Z]\/g;function Z(e,t,n){var r,i;if(void 0===n&&1===e.nodeType)if(r=\"data-\"+t.replace(K,\"-$&\").toLowerCase(),\"string\"==typeof(n=e.getAttribute(r))){try{n=\"true\"===(i=n)||\"false\"!==i&&(\"null\"===i?null:i===+i+\"\"?+i:J.test(i)?JSON.parse(i):i)}catch(e){}Q.set(e,t,n)}else n=void 0;return n}S.extend({hasData:function(e){return Q.hasData(e)||Y.hasData(e)},data:function(e,t,n){return Q.access(e,t,n)},removeData:function(e,t){Q.remove(e,t)},_data:function(e,t,n){return Y.access(e,t,n)},_removeData:function(e,t){Y.remove(e,t)}}),S.fn.extend({data:function(n,e){var t,r,i,o=this[0],a=o&&o.attributes;if(void 0===n){if(this.length&&(i=Q.get(o),1===o.nodeType&&!Y.get(o,\"hasDataAttrs\"))){t=a.length;while(t--)a[t]&&0===(r=a[t].name).indexOf(\"data-\")&&(r=X(r.slice(5)),Z(o,r,i[r]));Y.set(o,\"hasDataAttrs\",!0)}return i}return\"object\"==typeof n?this.each(function(){Q.set(this,n)}):$(this,function(e){var t;if(o&&void 0===e)return void 0!==(t=Q.get(o,n))?t:void 0!==(t=Z(o,n))?t:void 0;this.each(function(){Q.set(this,n,e)})},null,e,1<arguments.length,null,!0)},removeData:function(e){return this.each(function(){Q.remove(this,e)})}}),S.extend({queue:function(e,t,n){var r;if(e)return t=(t||\"fx\")+\"queue\",r=Y.get(e,t),n&&(!r||Array.isArray(n)?r=Y.access(e,t,S.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||\"fx\";var n=S.queue(e,t),r=n.length,i=n.shift(),o=S._queueHooks(e,t);\"inprogress\"===i&&(i=n.shift(),r--),i&&(\"fx\"===t&&n.unshift(\"inprogress\"),delete o.stop,i.call(e,function(){S.dequeue(e,t)},o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+\"queueHooks\";return Y.get(e,n)||Y.access(e,n,{empty:S.Callbacks(\"once memory\").add(function(){Y.remove(e,[t+\"queue\",n])})})}}),S.fn.extend({queue:function(t,n){var e=2;return\"string\"!=typeof t&&(n=t,t=\"fx\",e--),arguments.length<e?S.queue(this[0],t):void 0===n?this:this.each(function(){var e=S.queue(this,t,n);S._queueHooks(this,t),\"fx\"===t&&\"inprogress\"!==e[0]&&S.dequeue(this,t)})},dequeue:function(e){return this.each(function(){S.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||\"fx\",[])},promise:function(e,t){var n,r=1,i=S.Deferred(),o=this,a=this.length,s=function(){--r||i.resolveWith(o,[o])};\"string\"!=typeof e&&(t=e,e=void 0),e=e||\"fx\";while(a--)(n=Y.get(o[a],e+\"queueHooks\"))&&n.empty&&(r++,n.empty.add(s));return s(),i.promise(t)}});var ee=\/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)\/.source,te=new RegExp(\"^(?:([+-])=|)(\"+ee+\")([a-z%]*)$\",\"i\"),ne=[\"Top\",\"Right\",\"Bottom\",\"Left\"],re=E.documentElement,ie=function(e){return S.contains(e.ownerDocument,e)},oe={composed:!0};re.getRootNode&&(ie=function(e){return S.contains(e.ownerDocument,e)||e.getRootNode(oe)===e.ownerDocument});var ae=function(e,t){return\"none\"===(e=t||e).style.display||\"\"===e.style.display&&ie(e)&&\"none\"===S.css(e,\"display\")};function se(e,t,n,r){var i,o,a=20,s=r?function(){return r.cur()}:function(){return S.css(e,t,\"\")},u=s(),l=n&&n[3]||(S.cssNumber[t]?\"\":\"px\"),c=e.nodeType&&(S.cssNumber[t]||\"px\"!==l&&+u)&&te.exec(S.css(e,t));if(c&&c[3]!==l){u\/=2,l=l||c[3],c=+u||1;while(a--)S.style(e,t,c+l),(1-o)*(1-(o=s()\/u||.5))<=0&&(a=0),c\/=o;c*=2,S.style(e,t,c+l),n=n||[]}return n&&(c=+c||+u||0,i=n[1]?c+(n[1]+1)*n[2]:+n[2],r&&(r.unit=l,r.start=c,r.end=i)),i}var ue={};function le(e,t){for(var n,r,i,o,a,s,u,l=[],c=0,f=e.length;c<f;c++)(r=e[c]).style&&(n=r.style.display,t?(\"none\"===n&&(l[c]=Y.get(r,\"display\")||null,l[c]||(r.style.display=\"\")),\"\"===r.style.display&&ae(r)&&(l[c]=(u=a=o=void 0,a=(i=r).ownerDocument,s=i.nodeName,(u=ue[s])||(o=a.body.appendChild(a.createElement(s)),u=S.css(o,\"display\"),o.parentNode.removeChild(o),\"none\"===u&&(u=\"block\"),ue[s]=u)))):\"none\"!==n&&(l[c]=\"none\",Y.set(r,\"display\",n)));for(c=0;c<f;c++)null!=l[c]&&(e[c].style.display=l[c]);return e}S.fn.extend({show:function(){return le(this,!0)},hide:function(){return le(this)},toggle:function(e){return\"boolean\"==typeof e?e?this.show():this.hide():this.each(function(){ae(this)?S(this).show():S(this).hide()})}});var ce,fe,pe=\/^(?:checkbox|radio)$\/i,de=\/<([a-z][^\\\/\\0>\\x20\\t\\r\\n\\f]*)\/i,he=\/^$|^module$|\\\/(?:java|ecma)script\/i;ce=E.createDocumentFragment().appendChild(E.createElement(\"div\")),(fe=E.createElement(\"input\")).setAttribute(\"type\",\"radio\"),fe.setAttribute(\"checked\",\"checked\"),fe.setAttribute(\"name\",\"t\"),ce.appendChild(fe),y.checkClone=ce.cloneNode(!0).cloneNode(!0).lastChild.checked,ce.innerHTML=\"<textarea>x<\/textarea>\",y.noCloneChecked=!!ce.cloneNode(!0).lastChild.defaultValue,ce.innerHTML=\"<option><\/option>\",y.option=!!ce.lastChild;var ge={thead:[1,\"<table>\",\"<\/table>\"],col:[2,\"<table><colgroup>\",\"<\/colgroup><\/table>\"],tr:[2,\"<table><tbody>\",\"<\/tbody><\/table>\"],td:[3,\"<table><tbody><tr>\",\"<\/tr><\/tbody><\/table>\"],_default:[0,\"\",\"\"]};function ve(e,t){var n;return n=\"undefined\"!=typeof e.getElementsByTagName?e.getElementsByTagName(t||\"*\"):\"undefined\"!=typeof e.querySelectorAll?e.querySelectorAll(t||\"*\"):[],void 0===t||t&&A(e,t)?S.merge([e],n):n}function ye(e,t){for(var n=0,r=e.length;n<r;n++)Y.set(e[n],\"globalEval\",!t||Y.get(t[n],\"globalEval\"))}ge.tbody=ge.tfoot=ge.colgroup=ge.caption=ge.thead,ge.th=ge.td,y.option||(ge.optgroup=ge.option=[1,\"<select multiple='multiple'>\",\"<\/select>\"]);var me=\/<|&#?\\w+;\/;function xe(e,t,n,r,i){for(var o,a,s,u,l,c,f=t.createDocumentFragment(),p=[],d=0,h=e.length;d<h;d++)if((o=e[d])||0===o)if(\"object\"===w(o))S.merge(p,o.nodeType?[o]:o);else if(me.test(o)){a=a||f.appendChild(t.createElement(\"div\")),s=(de.exec(o)||[\"\",\"\"])[1].toLowerCase(),u=ge[s]||ge._default,a.innerHTML=u[1]+S.htmlPrefilter(o)+u[2],c=u[0];while(c--)a=a.lastChild;S.merge(p,a.childNodes),(a=f.firstChild).textContent=\"\"}else p.push(t.createTextNode(o));f.textContent=\"\",d=0;while(o=p[d++])if(r&&-1<S.inArray(o,r))i&&i.push(o);else if(l=ie(o),a=ve(f.appendChild(o),\"script\"),l&&ye(a),n){c=0;while(o=a[c++])he.test(o.type||\"\")&&n.push(o)}return f}var be=\/^([^.]*)(?:\\.(.+)|)\/;function we(){return!0}function Te(){return!1}function Ce(e,t){return e===function(){try{return E.activeElement}catch(e){}}()==(\"focus\"===t)}function Ee(e,t,n,r,i,o){var a,s;if(\"object\"==typeof t){for(s in\"string\"!=typeof n&&(r=r||n,n=void 0),t)Ee(e,s,n,r,t[s],o);return e}if(null==r&&null==i?(i=n,r=n=void 0):null==i&&(\"string\"==typeof n?(i=r,r=void 0):(i=r,r=n,n=void 0)),!1===i)i=Te;else if(!i)return e;return 1===o&&(a=i,(i=function(e){return S().off(e),a.apply(this,arguments)}).guid=a.guid||(a.guid=S.guid++)),e.each(function(){S.event.add(this,t,i,r,n)})}function Se(e,i,o){o?(Y.set(e,i,!1),S.event.add(e,i,{namespace:!1,handler:function(e){var t,n,r=Y.get(this,i);if(1&e.isTrigger&&this[i]){if(r.length)(S.event.special[i]||{}).delegateType&&e.stopPropagation();else if(r=s.call(arguments),Y.set(this,i,r),t=o(this,i),this[i](),r!==(n=Y.get(this,i))||t?Y.set(this,i,!1):n={},r!==n)return e.stopImmediatePropagation(),e.preventDefault(),n&&n.value}else r.length&&(Y.set(this,i,{value:S.event.trigger(S.extend(r[0],S.Event.prototype),r.slice(1),this)}),e.stopImmediatePropagation())}})):void 0===Y.get(e,i)&&S.event.add(e,i,we)}S.event={global:{},add:function(t,e,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Y.get(t);if(V(t)){n.handler&&(n=(o=n).handler,i=o.selector),i&&S.find.matchesSelector(re,i),n.guid||(n.guid=S.guid++),(u=v.events)||(u=v.events=Object.create(null)),(a=v.handle)||(a=v.handle=function(e){return\"undefined\"!=typeof S&&S.event.triggered!==e.type?S.event.dispatch.apply(t,arguments):void 0}),l=(e=(e||\"\").match(P)||[\"\"]).length;while(l--)d=g=(s=be.exec(e[l])||[])[1],h=(s[2]||\"\").split(\".\").sort(),d&&(f=S.event.special[d]||{},d=(i?f.delegateType:f.bindType)||d,f=S.event.special[d]||{},c=S.extend({type:d,origType:g,data:r,handler:n,guid:n.guid,selector:i,needsContext:i&&S.expr.match.needsContext.test(i),namespace:h.join(\".\")},o),(p=u[d])||((p=u[d]=[]).delegateCount=0,f.setup&&!1!==f.setup.call(t,r,h,a)||t.addEventListener&&t.addEventListener(d,a)),f.add&&(f.add.call(t,c),c.handler.guid||(c.handler.guid=n.guid)),i?p.splice(p.delegateCount++,0,c):p.push(c),S.event.global[d]=!0)}},remove:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Y.hasData(e)&&Y.get(e);if(v&&(u=v.events)){l=(t=(t||\"\").match(P)||[\"\"]).length;while(l--)if(d=g=(s=be.exec(t[l])||[])[1],h=(s[2]||\"\").split(\".\").sort(),d){f=S.event.special[d]||{},p=u[d=(r?f.delegateType:f.bindType)||d]||[],s=s[2]&&new RegExp(\"(^|\\\\.)\"+h.join(\"\\\\.(?:.*\\\\.|)\")+\"(\\\\.|$)\"),a=o=p.length;while(o--)c=p[o],!i&&g!==c.origType||n&&n.guid!==c.guid||s&&!s.test(c.namespace)||r&&r!==c.selector&&(\"**\"!==r||!c.selector)||(p.splice(o,1),c.selector&&p.delegateCount--,f.remove&&f.remove.call(e,c));a&&!p.length&&(f.teardown&&!1!==f.teardown.call(e,h,v.handle)||S.removeEvent(e,d,v.handle),delete u[d])}else for(d in u)S.event.remove(e,d+t[l],n,r,!0);S.isEmptyObject(u)&&Y.remove(e,\"handle events\")}},dispatch:function(e){var t,n,r,i,o,a,s=new Array(arguments.length),u=S.event.fix(e),l=(Y.get(this,\"events\")||Object.create(null))[u.type]||[],c=S.event.special[u.type]||{};for(s[0]=u,t=1;t<arguments.length;t++)s[t]=arguments[t];if(u.delegateTarget=this,!c.preDispatch||!1!==c.preDispatch.call(this,u)){a=S.event.handlers.call(this,u,l),t=0;while((i=a[t++])&&!u.isPropagationStopped()){u.currentTarget=i.elem,n=0;while((o=i.handlers[n++])&&!u.isImmediatePropagationStopped())u.rnamespace&&!1!==o.namespace&&!u.rnamespace.test(o.namespace)||(u.handleObj=o,u.data=o.data,void 0!==(r=((S.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,s))&&!1===(u.result=r)&&(u.preventDefault(),u.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,u),u.result}},handlers:function(e,t){var n,r,i,o,a,s=[],u=t.delegateCount,l=e.target;if(u&&l.nodeType&&!(\"click\"===e.type&&1<=e.button))for(;l!==this;l=l.parentNode||this)if(1===l.nodeType&&(\"click\"!==e.type||!0!==l.disabled)){for(o=[],a={},n=0;n<u;n++)void 0===a[i=(r=t[n]).selector+\" \"]&&(a[i]=r.needsContext?-1<S(i,this).index(l):S.find(i,this,null,[l]).length),a[i]&&o.push(r);o.length&&s.push({elem:l,handlers:o})}return l=this,u<t.length&&s.push({elem:l,handlers:t.slice(u)}),s},addProp:function(t,e){Object.defineProperty(S.Event.prototype,t,{enumerable:!0,configurable:!0,get:m(e)?function(){if(this.originalEvent)return e(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[t]},set:function(e){Object.defineProperty(this,t,{enumerable:!0,configurable:!0,writable:!0,value:e})}})},fix:function(e){return e[S.expando]?e:new S.Event(e)},special:{load:{noBubble:!0},click:{setup:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,\"input\")&&Se(t,\"click\",we),!1},trigger:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,\"input\")&&Se(t,\"click\"),!0},_default:function(e){var t=e.target;return pe.test(t.type)&&t.click&&A(t,\"input\")&&Y.get(t,\"click\")||A(t,\"a\")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&e.originalEvent&&(e.originalEvent.returnValue=e.result)}}}},S.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n)},S.Event=function(e,t){if(!(this instanceof S.Event))return new S.Event(e,t);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&!1===e.returnValue?we:Te,this.target=e.target&&3===e.target.nodeType?e.target.parentNode:e.target,this.currentTarget=e.currentTarget,this.relatedTarget=e.relatedTarget):this.type=e,t&&S.extend(this,t),this.timeStamp=e&&e.timeStamp||Date.now(),this[S.expando]=!0},S.Event.prototype={constructor:S.Event,isDefaultPrevented:Te,isPropagationStopped:Te,isImmediatePropagationStopped:Te,isSimulated:!1,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=we,e&&!this.isSimulated&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=we,e&&!this.isSimulated&&e.stopPropagation()},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=we,e&&!this.isSimulated&&e.stopImmediatePropagation(),this.stopPropagation()}},S.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,\"char\":!0,code:!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:!0},S.event.addProp),S.each({focus:\"focusin\",blur:\"focusout\"},function(e,t){S.event.special[e]={setup:function(){return Se(this,e,Ce),!1},trigger:function(){return Se(this,e),!0},_default:function(){return!0},delegateType:t}}),S.each({mouseenter:\"mouseover\",mouseleave:\"mouseout\",pointerenter:\"pointerover\",pointerleave:\"pointerout\"},function(e,i){S.event.special[e]={delegateType:i,bindType:i,handle:function(e){var t,n=e.relatedTarget,r=e.handleObj;return n&&(n===this||S.contains(this,n))||(e.type=r.origType,t=r.handler.apply(this,arguments),e.type=i),t}}}),S.fn.extend({on:function(e,t,n,r){return Ee(this,e,t,n,r)},one:function(e,t,n,r){return Ee(this,e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,S(e.delegateTarget).off(r.namespace?r.origType+\".\"+r.namespace:r.origType,r.selector,r.handler),this;if(\"object\"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return!1!==t&&\"function\"!=typeof t||(n=t,t=void 0),!1===n&&(n=Te),this.each(function(){S.event.remove(this,e,n,t)})}});var ke=\/<script|<style|<link\/i,Ae=\/checked\\s*(?:[^=]|=\\s*.checked.)\/i,Ne=\/^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$\/g;function je(e,t){return A(e,\"table\")&&A(11!==t.nodeType?t:t.firstChild,\"tr\")&&S(e).children(\"tbody\")[0]||e}function De(e){return e.type=(null!==e.getAttribute(\"type\"))+\"\/\"+e.type,e}function qe(e){return\"true\/\"===(e.type||\"\").slice(0,5)?e.type=e.type.slice(5):e.removeAttribute(\"type\"),e}function Le(e,t){var n,r,i,o,a,s;if(1===t.nodeType){if(Y.hasData(e)&&(s=Y.get(e).events))for(i in Y.remove(t,\"handle events\"),s)for(n=0,r=s[i].length;n<r;n++)S.event.add(t,i,s[i][n]);Q.hasData(e)&&(o=Q.access(e),a=S.extend({},o),Q.set(t,a))}}function He(n,r,i,o){r=g(r);var e,t,a,s,u,l,c=0,f=n.length,p=f-1,d=r[0],h=m(d);if(h||1<f&&\"string\"==typeof d&&!y.checkClone&&Ae.test(d))return n.each(function(e){var t=n.eq(e);h&&(r[0]=d.call(this,e,t.html())),He(t,r,i,o)});if(f&&(t=(e=xe(r,n[0].ownerDocument,!1,n,o)).firstChild,1===e.childNodes.length&&(e=t),t||o)){for(s=(a=S.map(ve(e,\"script\"),De)).length;c<f;c++)u=e,c!==p&&(u=S.clone(u,!0,!0),s&&S.merge(a,ve(u,\"script\"))),i.call(n[c],u,c);if(s)for(l=a[a.length-1].ownerDocument,S.map(a,qe),c=0;c<s;c++)u=a[c],he.test(u.type||\"\")&&!Y.access(u,\"globalEval\")&&S.contains(l,u)&&(u.src&&\"module\"!==(u.type||\"\").toLowerCase()?S._evalUrl&&!u.noModule&&S._evalUrl(u.src,{nonce:u.nonce||u.getAttribute(\"nonce\")},l):b(u.textContent.replace(Ne,\"\"),u,l))}return n}function Oe(e,t,n){for(var r,i=t?S.filter(t,e):e,o=0;null!=(r=i[o]);o++)n||1!==r.nodeType||S.cleanData(ve(r)),r.parentNode&&(n&&ie(r)&&ye(ve(r,\"script\")),r.parentNode.removeChild(r));return e}S.extend({htmlPrefilter:function(e){return e},clone:function(e,t,n){var r,i,o,a,s,u,l,c=e.cloneNode(!0),f=ie(e);if(!(y.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||S.isXMLDoc(e)))for(a=ve(c),r=0,i=(o=ve(e)).length;r<i;r++)s=o[r],u=a[r],void 0,\"input\"===(l=u.nodeName.toLowerCase())&&pe.test(s.type)?u.checked=s.checked:\"input\"!==l&&\"textarea\"!==l||(u.defaultValue=s.defaultValue);if(t)if(n)for(o=o||ve(e),a=a||ve(c),r=0,i=o.length;r<i;r++)Le(o[r],a[r]);else Le(e,c);return 0<(a=ve(c,\"script\")).length&&ye(a,!f&&ve(e,\"script\")),c},cleanData:function(e){for(var t,n,r,i=S.event.special,o=0;void 0!==(n=e[o]);o++)if(V(n)){if(t=n[Y.expando]){if(t.events)for(r in t.events)i[r]?S.event.remove(n,r):S.removeEvent(n,r,t.handle);n[Y.expando]=void 0}n[Q.expando]&&(n[Q.expando]=void 0)}}}),S.fn.extend({detach:function(e){return Oe(this,e,!0)},remove:function(e){return Oe(this,e)},text:function(e){return $(this,function(e){return void 0===e?S.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)})},null,e,arguments.length)},append:function(){return He(this,arguments,function(e){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||je(this,e).appendChild(e)})},prepend:function(){return He(this,arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=je(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return He(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return He(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)1===e.nodeType&&(S.cleanData(ve(e,!1)),e.textContent=\"\");return this},clone:function(e,t){return e=null!=e&&e,t=null==t?e:t,this.map(function(){return S.clone(this,e,t)})},html:function(e){return $(this,function(e){var t=this[0]||{},n=0,r=this.length;if(void 0===e&&1===t.nodeType)return t.innerHTML;if(\"string\"==typeof e&&!ke.test(e)&&!ge[(de.exec(e)||[\"\",\"\"])[1].toLowerCase()]){e=S.htmlPrefilter(e);try{for(;n<r;n++)1===(t=this[n]||{}).nodeType&&(S.cleanData(ve(t,!1)),t.innerHTML=e);t=0}catch(e){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var n=[];return He(this,arguments,function(e){var t=this.parentNode;S.inArray(this,n)<0&&(S.cleanData(ve(this)),t&&t.replaceChild(e,this))},n)}}),S.each({appendTo:\"append\",prependTo:\"prepend\",insertBefore:\"before\",insertAfter:\"after\",replaceAll:\"replaceWith\"},function(e,a){S.fn[e]=function(e){for(var t,n=[],r=S(e),i=r.length-1,o=0;o<=i;o++)t=o===i?this:this.clone(!0),S(r[o])[a](t),u.apply(n,t.get());return this.pushStack(n)}});var Pe=new RegExp(\"^(\"+ee+\")(?!px)[a-z%]+$\",\"i\"),Re=function(e){var t=e.ownerDocument.defaultView;return t&&t.opener||(t=C),t.getComputedStyle(e)},Me=function(e,t,n){var r,i,o={};for(i in t)o[i]=e.style[i],e.style[i]=t[i];for(i in r=n.call(e),t)e.style[i]=o[i];return r},Ie=new RegExp(ne.join(\"|\"),\"i\");function We(e,t,n){var r,i,o,a,s=e.style;return(n=n||Re(e))&&(\"\"!==(a=n.getPropertyValue(t)||n[t])||ie(e)||(a=S.style(e,t)),!y.pixelBoxStyles()&&Pe.test(a)&&Ie.test(t)&&(r=s.width,i=s.minWidth,o=s.maxWidth,s.minWidth=s.maxWidth=s.width=a,a=n.width,s.width=r,s.minWidth=i,s.maxWidth=o)),void 0!==a?a+\"\":a}function Fe(e,t){return{get:function(){if(!e())return(this.get=t).apply(this,arguments);delete this.get}}}!function(){function e(){if(l){u.style.cssText=\"position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0\",l.style.cssText=\"position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%\",re.appendChild(u).appendChild(l);var e=C.getComputedStyle(l);n=\"1%\"!==e.top,s=12===t(e.marginLeft),l.style.right=\"60%\",o=36===t(e.right),r=36===t(e.width),l.style.position=\"absolute\",i=12===t(l.offsetWidth\/3),re.removeChild(u),l=null}}function t(e){return Math.round(parseFloat(e))}var n,r,i,o,a,s,u=E.createElement(\"div\"),l=E.createElement(\"div\");l.style&&(l.style.backgroundClip=\"content-box\",l.cloneNode(!0).style.backgroundClip=\"\",y.clearCloneStyle=\"content-box\"===l.style.backgroundClip,S.extend(y,{boxSizingReliable:function(){return e(),r},pixelBoxStyles:function(){return e(),o},pixelPosition:function(){return e(),n},reliableMarginLeft:function(){return e(),s},scrollboxSize:function(){return e(),i},reliableTrDimensions:function(){var e,t,n,r;return null==a&&(e=E.createElement(\"table\"),t=E.createElement(\"tr\"),n=E.createElement(\"div\"),e.style.cssText=\"position:absolute;left:-11111px;border-collapse:separate\",t.style.cssText=\"border:1px solid\",t.style.height=\"1px\",n.style.height=\"9px\",n.style.display=\"block\",re.appendChild(e).appendChild(t).appendChild(n),r=C.getComputedStyle(t),a=parseInt(r.height,10)+parseInt(r.borderTopWidth,10)+parseInt(r.borderBottomWidth,10)===t.offsetHeight,re.removeChild(e)),a}}))}();var Be=[\"Webkit\",\"Moz\",\"ms\"],$e=E.createElement(\"div\").style,_e={};function ze(e){var t=S.cssProps[e]||_e[e];return t||(e in $e?e:_e[e]=function(e){var t=e[0].toUpperCase()+e.slice(1),n=Be.length;while(n--)if((e=Be[n]+t)in $e)return e}(e)||e)}var Ue=\/^(none|table(?!-c[ea]).+)\/,Xe=\/^--\/,Ve={position:\"absolute\",visibility:\"hidden\",display:\"block\"},Ge={letterSpacing:\"0\",fontWeight:\"400\"};function Ye(e,t,n){var r=te.exec(t);return r?Math.max(0,r[2]-(n||0))+(r[3]||\"px\"):t}function Qe(e,t,n,r,i,o){var a=\"width\"===t?1:0,s=0,u=0;if(n===(r?\"border\":\"content\"))return 0;for(;a<4;a+=2)\"margin\"===n&&(u+=S.css(e,n+ne[a],!0,i)),r?(\"content\"===n&&(u-=S.css(e,\"padding\"+ne[a],!0,i)),\"margin\"!==n&&(u-=S.css(e,\"border\"+ne[a]+\"Width\",!0,i))):(u+=S.css(e,\"padding\"+ne[a],!0,i),\"padding\"!==n?u+=S.css(e,\"border\"+ne[a]+\"Width\",!0,i):s+=S.css(e,\"border\"+ne[a]+\"Width\",!0,i));return!r&&0<=o&&(u+=Math.max(0,Math.ceil(e[\"offset\"+t[0].toUpperCase()+t.slice(1)]-o-u-s-.5))||0),u}function Je(e,t,n){var r=Re(e),i=(!y.boxSizingReliable()||n)&&\"border-box\"===S.css(e,\"boxSizing\",!1,r),o=i,a=We(e,t,r),s=\"offset\"+t[0].toUpperCase()+t.slice(1);if(Pe.test(a)){if(!n)return a;a=\"auto\"}return(!y.boxSizingReliable()&&i||!y.reliableTrDimensions()&&A(e,\"tr\")||\"auto\"===a||!parseFloat(a)&&\"inline\"===S.css(e,\"display\",!1,r))&&e.getClientRects().length&&(i=\"border-box\"===S.css(e,\"boxSizing\",!1,r),(o=s in e)&&(a=e[s])),(a=parseFloat(a)||0)+Qe(e,t,n||(i?\"border\":\"content\"),o,r,a)+\"px\"}function Ke(e,t,n,r,i){return new Ke.prototype.init(e,t,n,r,i)}S.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=We(e,\"opacity\");return\"\"===n?\"1\":n}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,gridArea:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnStart:!0,gridRow:!0,gridRowEnd:!0,gridRowStart:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,a,s=X(t),u=Xe.test(t),l=e.style;if(u||(t=ze(s)),a=S.cssHooks[t]||S.cssHooks[s],void 0===n)return a&&\"get\"in a&&void 0!==(i=a.get(e,!1,r))?i:l[t];\"string\"===(o=typeof n)&&(i=te.exec(n))&&i[1]&&(n=se(e,t,i),o=\"number\"),null!=n&&n==n&&(\"number\"!==o||u||(n+=i&&i[3]||(S.cssNumber[s]?\"\":\"px\")),y.clearCloneStyle||\"\"!==n||0!==t.indexOf(\"background\")||(l[t]=\"inherit\"),a&&\"set\"in a&&void 0===(n=a.set(e,n,r))||(u?l.setProperty(t,n):l[t]=n))}},css:function(e,t,n,r){var i,o,a,s=X(t);return Xe.test(t)||(t=ze(s)),(a=S.cssHooks[t]||S.cssHooks[s])&&\"get\"in a&&(i=a.get(e,!0,n)),void 0===i&&(i=We(e,t,r)),\"normal\"===i&&t in Ge&&(i=Ge[t]),\"\"===n||n?(o=parseFloat(i),!0===n||isFinite(o)?o||0:i):i}}),S.each([\"height\",\"width\"],function(e,u){S.cssHooks[u]={get:function(e,t,n){if(t)return!Ue.test(S.css(e,\"display\"))||e.getClientRects().length&&e.getBoundingClientRect().width?Je(e,u,n):Me(e,Ve,function(){return Je(e,u,n)})},set:function(e,t,n){var r,i=Re(e),o=!y.scrollboxSize()&&\"absolute\"===i.position,a=(o||n)&&\"border-box\"===S.css(e,\"boxSizing\",!1,i),s=n?Qe(e,u,n,a,i):0;return a&&o&&(s-=Math.ceil(e[\"offset\"+u[0].toUpperCase()+u.slice(1)]-parseFloat(i[u])-Qe(e,u,\"border\",!1,i)-.5)),s&&(r=te.exec(t))&&\"px\"!==(r[3]||\"px\")&&(e.style[u]=t,t=S.css(e,u)),Ye(0,t,s)}}}),S.cssHooks.marginLeft=Fe(y.reliableMarginLeft,function(e,t){if(t)return(parseFloat(We(e,\"marginLeft\"))||e.getBoundingClientRect().left-Me(e,{marginLeft:0},function(){return e.getBoundingClientRect().left}))+\"px\"}),S.each({margin:\"\",padding:\"\",border:\"Width\"},function(i,o){S.cssHooks[i+o]={expand:function(e){for(var t=0,n={},r=\"string\"==typeof e?e.split(\" \"):[e];t<4;t++)n[i+ne[t]+o]=r[t]||r[t-2]||r[0];return n}},\"margin\"!==i&&(S.cssHooks[i+o].set=Ye)}),S.fn.extend({css:function(e,t){return $(this,function(e,t,n){var r,i,o={},a=0;if(Array.isArray(t)){for(r=Re(e),i=t.length;a<i;a++)o[t[a]]=S.css(e,t[a],!1,r);return o}return void 0!==n?S.style(e,t,n):S.css(e,t)},e,t,1<arguments.length)}}),((S.Tween=Ke).prototype={constructor:Ke,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||S.easing._default,this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(S.cssNumber[n]?\"\":\"px\")},cur:function(){var e=Ke.propHooks[this.prop];return e&&e.get?e.get(this):Ke.propHooks._default.get(this)},run:function(e){var t,n=Ke.propHooks[this.prop];return this.options.duration?this.pos=t=S.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):Ke.propHooks._default.set(this),this}}).init.prototype=Ke.prototype,(Ke.propHooks={_default:{get:function(e){var t;return 1!==e.elem.nodeType||null!=e.elem[e.prop]&&null==e.elem.style[e.prop]?e.elem[e.prop]:(t=S.css(e.elem,e.prop,\"\"))&&\"auto\"!==t?t:0},set:function(e){S.fx.step[e.prop]?S.fx.step[e.prop](e):1!==e.elem.nodeType||!S.cssHooks[e.prop]&&null==e.elem.style[ze(e.prop)]?e.elem[e.prop]=e.now:S.style(e.elem,e.prop,e.now+e.unit)}}}).scrollTop=Ke.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},S.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)\/2},_default:\"swing\"},S.fx=Ke.prototype.init,S.fx.step={};var Ze,et,tt,nt,rt=\/^(?:toggle|show|hide)$\/,it=\/queueHooks$\/;function ot(){et&&(!1===E.hidden&&C.requestAnimationFrame?C.requestAnimationFrame(ot):C.setTimeout(ot,S.fx.interval),S.fx.tick())}function at(){return C.setTimeout(function(){Ze=void 0}),Ze=Date.now()}function st(e,t){var n,r=0,i={height:e};for(t=t?1:0;r<4;r+=2-t)i[\"margin\"+(n=ne[r])]=i[\"padding\"+n]=e;return t&&(i.opacity=i.width=e),i}function ut(e,t,n){for(var r,i=(lt.tweeners[t]||[]).concat(lt.tweeners[\"*\"]),o=0,a=i.length;o<a;o++)if(r=i[o].call(n,t,e))return r}function lt(o,e,t){var n,a,r=0,i=lt.prefilters.length,s=S.Deferred().always(function(){delete u.elem}),u=function(){if(a)return!1;for(var e=Ze||at(),t=Math.max(0,l.startTime+l.duration-e),n=1-(t\/l.duration||0),r=0,i=l.tweens.length;r<i;r++)l.tweens[r].run(n);return s.notifyWith(o,[l,n,t]),n<1&&i?t:(i||s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l]),!1)},l=s.promise({elem:o,props:S.extend({},e),opts:S.extend(!0,{specialEasing:{},easing:S.easing._default},t),originalProperties:e,originalOptions:t,startTime:Ze||at(),duration:t.duration,tweens:[],createTween:function(e,t){var n=S.Tween(o,l.opts,e,t,l.opts.specialEasing[e]||l.opts.easing);return l.tweens.push(n),n},stop:function(e){var t=0,n=e?l.tweens.length:0;if(a)return this;for(a=!0;t<n;t++)l.tweens[t].run(1);return e?(s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l,e])):s.rejectWith(o,[l,e]),this}}),c=l.props;for(!function(e,t){var n,r,i,o,a;for(n in e)if(i=t[r=X(n)],o=e[n],Array.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),(a=S.cssHooks[r])&&\"expand\"in a)for(n in o=a.expand(o),delete e[r],o)n in e||(e[n]=o[n],t[n]=i);else t[r]=i}(c,l.opts.specialEasing);r<i;r++)if(n=lt.prefilters[r].call(l,o,c,l.opts))return m(n.stop)&&(S._queueHooks(l.elem,l.opts.queue).stop=n.stop.bind(n)),n;return S.map(c,ut,l),m(l.opts.start)&&l.opts.start.call(o,l),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always),S.fx.timer(S.extend(u,{elem:o,anim:l,queue:l.opts.queue})),l}S.Animation=S.extend(lt,{tweeners:{\"*\":[function(e,t){var n=this.createTween(e,t);return se(n.elem,e,te.exec(t),n),n}]},tweener:function(e,t){m(e)?(t=e,e=[\"*\"]):e=e.match(P);for(var n,r=0,i=e.length;r<i;r++)n=e[r],lt.tweeners[n]=lt.tweeners[n]||[],lt.tweeners[n].unshift(t)},prefilters:[function(e,t,n){var r,i,o,a,s,u,l,c,f=\"width\"in t||\"height\"in t,p=this,d={},h=e.style,g=e.nodeType&&ae(e),v=Y.get(e,\"fxshow\");for(r in n.queue||(null==(a=S._queueHooks(e,\"fx\")).unqueued&&(a.unqueued=0,s=a.empty.fire,a.empty.fire=function(){a.unqueued||s()}),a.unqueued++,p.always(function(){p.always(function(){a.unqueued--,S.queue(e,\"fx\").length||a.empty.fire()})})),t)if(i=t[r],rt.test(i)){if(delete t[r],o=o||\"toggle\"===i,i===(g?\"hide\":\"show\")){if(\"show\"!==i||!v||void 0===v[r])continue;g=!0}d[r]=v&&v[r]||S.style(e,r)}if((u=!S.isEmptyObject(t))||!S.isEmptyObject(d))for(r in f&&1===e.nodeType&&(n.overflow=[h.overflow,h.overflowX,h.overflowY],null==(l=v&&v.display)&&(l=Y.get(e,\"display\")),\"none\"===(c=S.css(e,\"display\"))&&(l?c=l:(le([e],!0),l=e.style.display||l,c=S.css(e,\"display\"),le([e]))),(\"inline\"===c||\"inline-block\"===c&&null!=l)&&\"none\"===S.css(e,\"float\")&&(u||(p.done(function(){h.display=l}),null==l&&(c=h.display,l=\"none\"===c?\"\":c)),h.display=\"inline-block\")),n.overflow&&(h.overflow=\"hidden\",p.always(function(){h.overflow=n.overflow[0],h.overflowX=n.overflow[1],h.overflowY=n.overflow[2]})),u=!1,d)u||(v?\"hidden\"in v&&(g=v.hidden):v=Y.access(e,\"fxshow\",{display:l}),o&&(v.hidden=!g),g&&le([e],!0),p.done(function(){for(r in g||le([e]),Y.remove(e,\"fxshow\"),d)S.style(e,r,d[r])})),u=ut(g?v[r]:0,r,p),r in v||(v[r]=u.start,g&&(u.end=u.start,u.start=0))}],prefilter:function(e,t){t?lt.prefilters.unshift(e):lt.prefilters.push(e)}}),S.speed=function(e,t,n){var r=e&&\"object\"==typeof e?S.extend({},e):{complete:n||!n&&t||m(e)&&e,duration:e,easing:n&&t||t&&!m(t)&&t};return S.fx.off?r.duration=0:\"number\"!=typeof r.duration&&(r.duration in S.fx.speeds?r.duration=S.fx.speeds[r.duration]:r.duration=S.fx.speeds._default),null!=r.queue&&!0!==r.queue||(r.queue=\"fx\"),r.old=r.complete,r.complete=function(){m(r.old)&&r.old.call(this),r.queue&&S.dequeue(this,r.queue)},r},S.fn.extend({fadeTo:function(e,t,n,r){return this.filter(ae).css(\"opacity\",0).show().end().animate({opacity:t},e,n,r)},animate:function(t,e,n,r){var i=S.isEmptyObject(t),o=S.speed(e,n,r),a=function(){var e=lt(this,S.extend({},t),o);(i||Y.get(this,\"finish\"))&&e.stop(!0)};return a.finish=a,i||!1===o.queue?this.each(a):this.queue(o.queue,a)},stop:function(i,e,o){var a=function(e){var t=e.stop;delete e.stop,t(o)};return\"string\"!=typeof i&&(o=e,e=i,i=void 0),e&&this.queue(i||\"fx\",[]),this.each(function(){var e=!0,t=null!=i&&i+\"queueHooks\",n=S.timers,r=Y.get(this);if(t)r[t]&&r[t].stop&&a(r[t]);else for(t in r)r[t]&&r[t].stop&&it.test(t)&&a(r[t]);for(t=n.length;t--;)n[t].elem!==this||null!=i&&n[t].queue!==i||(n[t].anim.stop(o),e=!1,n.splice(t,1));!e&&o||S.dequeue(this,i)})},finish:function(a){return!1!==a&&(a=a||\"fx\"),this.each(function(){var e,t=Y.get(this),n=t[a+\"queue\"],r=t[a+\"queueHooks\"],i=S.timers,o=n?n.length:0;for(t.finish=!0,S.queue(this,a,[]),r&&r.stop&&r.stop.call(this,!0),e=i.length;e--;)i[e].elem===this&&i[e].queue===a&&(i[e].anim.stop(!0),i.splice(e,1));for(e=0;e<o;e++)n[e]&&n[e].finish&&n[e].finish.call(this);delete t.finish})}}),S.each([\"toggle\",\"show\",\"hide\"],function(e,r){var i=S.fn[r];S.fn[r]=function(e,t,n){return null==e||\"boolean\"==typeof e?i.apply(this,arguments):this.animate(st(r,!0),e,t,n)}}),S.each({slideDown:st(\"show\"),slideUp:st(\"hide\"),slideToggle:st(\"toggle\"),fadeIn:{opacity:\"show\"},fadeOut:{opacity:\"hide\"},fadeToggle:{opacity:\"toggle\"}},function(e,r){S.fn[e]=function(e,t,n){return this.animate(r,e,t,n)}}),S.timers=[],S.fx.tick=function(){var e,t=0,n=S.timers;for(Ze=Date.now();t<n.length;t++)(e=n[t])()||n[t]!==e||n.splice(t--,1);n.length||S.fx.stop(),Ze=void 0},S.fx.timer=function(e){S.timers.push(e),S.fx.start()},S.fx.interval=13,S.fx.start=function(){et||(et=!0,ot())},S.fx.stop=function(){et=null},S.fx.speeds={slow:600,fast:200,_default:400},S.fn.delay=function(r,e){return r=S.fx&&S.fx.speeds[r]||r,e=e||\"fx\",this.queue(e,function(e,t){var n=C.setTimeout(e,r);t.stop=function(){C.clearTimeout(n)}})},tt=E.createElement(\"input\"),nt=E.createElement(\"select\").appendChild(E.createElement(\"option\")),tt.type=\"checkbox\",y.checkOn=\"\"!==tt.value,y.optSelected=nt.selected,(tt=E.createElement(\"input\")).value=\"t\",tt.type=\"radio\",y.radioValue=\"t\"===tt.value;var ct,ft=S.expr.attrHandle;S.fn.extend({attr:function(e,t){return $(this,S.attr,e,t,1<arguments.length)},removeAttr:function(e){return this.each(function(){S.removeAttr(this,e)})}}),S.extend({attr:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return\"undefined\"==typeof e.getAttribute?S.prop(e,t,n):(1===o&&S.isXMLDoc(e)||(i=S.attrHooks[t.toLowerCase()]||(S.expr.match.bool.test(t)?ct:void 0)),void 0!==n?null===n?void S.removeAttr(e,t):i&&\"set\"in i&&void 0!==(r=i.set(e,n,t))?r:(e.setAttribute(t,n+\"\"),n):i&&\"get\"in i&&null!==(r=i.get(e,t))?r:null==(r=S.find.attr(e,t))?void 0:r)},attrHooks:{type:{set:function(e,t){if(!y.radioValue&&\"radio\"===t&&A(e,\"input\")){var n=e.value;return e.setAttribute(\"type\",t),n&&(e.value=n),t}}}},removeAttr:function(e,t){var n,r=0,i=t&&t.match(P);if(i&&1===e.nodeType)while(n=i[r++])e.removeAttribute(n)}}),ct={set:function(e,t,n){return!1===t?S.removeAttr(e,n):e.setAttribute(n,n),n}},S.each(S.expr.match.bool.source.match(\/\\w+\/g),function(e,t){var a=ft[t]||S.find.attr;ft[t]=function(e,t,n){var r,i,o=t.toLowerCase();return n||(i=ft[o],ft[o]=r,r=null!=a(e,t,n)?o:null,ft[o]=i),r}});var pt=\/^(?:input|select|textarea|button)$\/i,dt=\/^(?:a|area)$\/i;function ht(e){return(e.match(P)||[]).join(\" \")}function gt(e){return e.getAttribute&&e.getAttribute(\"class\")||\"\"}function vt(e){return Array.isArray(e)?e:\"string\"==typeof e&&e.match(P)||[]}S.fn.extend({prop:function(e,t){return $(this,S.prop,e,t,1<arguments.length)},removeProp:function(e){return this.each(function(){delete this[S.propFix[e]||e]})}}),S.extend({prop:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return 1===o&&S.isXMLDoc(e)||(t=S.propFix[t]||t,i=S.propHooks[t]),void 0!==n?i&&\"set\"in i&&void 0!==(r=i.set(e,n,t))?r:e[t]=n:i&&\"get\"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){var t=S.find.attr(e,\"tabindex\");return t?parseInt(t,10):pt.test(e.nodeName)||dt.test(e.nodeName)&&e.href?0:-1}}},propFix:{\"for\":\"htmlFor\",\"class\":\"className\"}}),y.optSelected||(S.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null},set:function(e){var t=e.parentNode;t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex)}}),S.each([\"tabIndex\",\"readOnly\",\"maxLength\",\"cellSpacing\",\"cellPadding\",\"rowSpan\",\"colSpan\",\"useMap\",\"frameBorder\",\"contentEditable\"],function(){S.propFix[this.toLowerCase()]=this}),S.fn.extend({addClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){S(this).addClass(t.call(this,e,gt(this)))});if((e=vt(t)).length)while(n=this[u++])if(i=gt(n),r=1===n.nodeType&&\" \"+ht(i)+\" \"){a=0;while(o=e[a++])r.indexOf(\" \"+o+\" \")<0&&(r+=o+\" \");i!==(s=ht(r))&&n.setAttribute(\"class\",s)}return this},removeClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){S(this).removeClass(t.call(this,e,gt(this)))});if(!arguments.length)return this.attr(\"class\",\"\");if((e=vt(t)).length)while(n=this[u++])if(i=gt(n),r=1===n.nodeType&&\" \"+ht(i)+\" \"){a=0;while(o=e[a++])while(-1<r.indexOf(\" \"+o+\" \"))r=r.replace(\" \"+o+\" \",\" \");i!==(s=ht(r))&&n.setAttribute(\"class\",s)}return this},toggleClass:function(i,t){var o=typeof i,a=\"string\"===o||Array.isArray(i);return\"boolean\"==typeof t&&a?t?this.addClass(i):this.removeClass(i):m(i)?this.each(function(e){S(this).toggleClass(i.call(this,e,gt(this),t),t)}):this.each(function(){var e,t,n,r;if(a){t=0,n=S(this),r=vt(i);while(e=r[t++])n.hasClass(e)?n.removeClass(e):n.addClass(e)}else void 0!==i&&\"boolean\"!==o||((e=gt(this))&&Y.set(this,\"__className__\",e),this.setAttribute&&this.setAttribute(\"class\",e||!1===i?\"\":Y.get(this,\"__className__\")||\"\"))})},hasClass:function(e){var t,n,r=0;t=\" \"+e+\" \";while(n=this[r++])if(1===n.nodeType&&-1<(\" \"+ht(gt(n))+\" \").indexOf(t))return!0;return!1}});var yt=\/\\r\/g;S.fn.extend({val:function(n){var r,e,i,t=this[0];return arguments.length?(i=m(n),this.each(function(e){var t;1===this.nodeType&&(null==(t=i?n.call(this,e,S(this).val()):n)?t=\"\":\"number\"==typeof t?t+=\"\":Array.isArray(t)&&(t=S.map(t,function(e){return null==e?\"\":e+\"\"})),(r=S.valHooks[this.type]||S.valHooks[this.nodeName.toLowerCase()])&&\"set\"in r&&void 0!==r.set(this,t,\"value\")||(this.value=t))})):t?(r=S.valHooks[t.type]||S.valHooks[t.nodeName.toLowerCase()])&&\"get\"in r&&void 0!==(e=r.get(t,\"value\"))?e:\"string\"==typeof(e=t.value)?e.replace(yt,\"\"):null==e?\"\":e:void 0}}),S.extend({valHooks:{option:{get:function(e){var t=S.find.attr(e,\"value\");return null!=t?t:ht(S.text(e))}},select:{get:function(e){var t,n,r,i=e.options,o=e.selectedIndex,a=\"select-one\"===e.type,s=a?null:[],u=a?o+1:i.length;for(r=o<0?u:a?o:0;r<u;r++)if(((n=i[r]).selected||r===o)&&!n.disabled&&(!n.parentNode.disabled||!A(n.parentNode,\"optgroup\"))){if(t=S(n).val(),a)return t;s.push(t)}return s},set:function(e,t){var n,r,i=e.options,o=S.makeArray(t),a=i.length;while(a--)((r=i[a]).selected=-1<S.inArray(S.valHooks.option.get(r),o))&&(n=!0);return n||(e.selectedIndex=-1),o}}}}),S.each([\"radio\",\"checkbox\"],function(){S.valHooks[this]={set:function(e,t){if(Array.isArray(t))return e.checked=-1<S.inArray(S(e).val(),t)}},y.checkOn||(S.valHooks[this].get=function(e){return null===e.getAttribute(\"value\")?\"on\":e.value})}),y.focusin=\"onfocusin\"in C;var mt=\/^(?:focusinfocus|focusoutblur)$\/,xt=function(e){e.stopPropagation()};S.extend(S.event,{trigger:function(e,t,n,r){var i,o,a,s,u,l,c,f,p=[n||E],d=v.call(e,\"type\")?e.type:e,h=v.call(e,\"namespace\")?e.namespace.split(\".\"):[];if(o=f=a=n=n||E,3!==n.nodeType&&8!==n.nodeType&&!mt.test(d+S.event.triggered)&&(-1<d.indexOf(\".\")&&(d=(h=d.split(\".\")).shift(),h.sort()),u=d.indexOf(\":\")<0&&\"on\"+d,(e=e[S.expando]?e:new S.Event(d,\"object\"==typeof e&&e)).isTrigger=r?2:3,e.namespace=h.join(\".\"),e.rnamespace=e.namespace?new RegExp(\"(^|\\\\.)\"+h.join(\"\\\\.(?:.*\\\\.|)\")+\"(\\\\.|$)\"):null,e.result=void 0,e.target||(e.target=n),t=null==t?[e]:S.makeArray(t,[e]),c=S.event.special[d]||{},r||!c.trigger||!1!==c.trigger.apply(n,t))){if(!r&&!c.noBubble&&!x(n)){for(s=c.delegateType||d,mt.test(s+d)||(o=o.parentNode);o;o=o.parentNode)p.push(o),a=o;a===(n.ownerDocument||E)&&p.push(a.defaultView||a.parentWindow||C)}i=0;while((o=p[i++])&&!e.isPropagationStopped())f=o,e.type=1<i?s:c.bindType||d,(l=(Y.get(o,\"events\")||Object.create(null))[e.type]&&Y.get(o,\"handle\"))&&l.apply(o,t),(l=u&&o[u])&&l.apply&&V(o)&&(e.result=l.apply(o,t),!1===e.result&&e.preventDefault());return e.type=d,r||e.isDefaultPrevented()||c._default&&!1!==c._default.apply(p.pop(),t)||!V(n)||u&&m(n[d])&&!x(n)&&((a=n[u])&&(n[u]=null),S.event.triggered=d,e.isPropagationStopped()&&f.addEventListener(d,xt),n[d](),e.isPropagationStopped()&&f.removeEventListener(d,xt),S.event.triggered=void 0,a&&(n[u]=a)),e.result}},simulate:function(e,t,n){var r=S.extend(new S.Event,n,{type:e,isSimulated:!0});S.event.trigger(r,null,t)}}),S.fn.extend({trigger:function(e,t){return this.each(function(){S.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];if(n)return S.event.trigger(e,t,n,!0)}}),y.focusin||S.each({focus:\"focusin\",blur:\"focusout\"},function(n,r){var i=function(e){S.event.simulate(r,e.target,S.event.fix(e))};S.event.special[r]={setup:function(){var e=this.ownerDocument||this.document||this,t=Y.access(e,r);t||e.addEventListener(n,i,!0),Y.access(e,r,(t||0)+1)},teardown:function(){var e=this.ownerDocument||this.document||this,t=Y.access(e,r)-1;t?Y.access(e,r,t):(e.removeEventListener(n,i,!0),Y.remove(e,r))}}});var bt=C.location,wt={guid:Date.now()},Tt=\/\\?\/;S.parseXML=function(e){var t,n;if(!e||\"string\"!=typeof e)return null;try{t=(new C.DOMParser).parseFromString(e,\"text\/xml\")}catch(e){}return n=t&&t.getElementsByTagName(\"parsererror\")[0],t&&!n||S.error(\"Invalid XML: \"+(n?S.map(n.childNodes,function(e){return e.textContent}).join(\"\\n\"):e)),t};var Ct=\/\\[\\]$\/,Et=\/\\r?\\n\/g,St=\/^(?:submit|button|image|reset|file)$\/i,kt=\/^(?:input|select|textarea|keygen)\/i;function At(n,e,r,i){var t;if(Array.isArray(e))S.each(e,function(e,t){r||Ct.test(n)?i(n,t):At(n+\"[\"+(\"object\"==typeof t&&null!=t?e:\"\")+\"]\",t,r,i)});else if(r||\"object\"!==w(e))i(n,e);else for(t in e)At(n+\"[\"+t+\"]\",e[t],r,i)}S.param=function(e,t){var n,r=[],i=function(e,t){var n=m(t)?t():t;r[r.length]=encodeURIComponent(e)+\"=\"+encodeURIComponent(null==n?\"\":n)};if(null==e)return\"\";if(Array.isArray(e)||e.jquery&&!S.isPlainObject(e))S.each(e,function(){i(this.name,this.value)});else for(n in e)At(n,e[n],t,i);return r.join(\"&\")},S.fn.extend({serialize:function(){return S.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=S.prop(this,\"elements\");return e?S.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!S(this).is(\":disabled\")&&kt.test(this.nodeName)&&!St.test(e)&&(this.checked||!pe.test(e))}).map(function(e,t){var n=S(this).val();return null==n?null:Array.isArray(n)?S.map(n,function(e){return{name:t.name,value:e.replace(Et,\"\\r\\n\")}}):{name:t.name,value:n.replace(Et,\"\\r\\n\")}}).get()}});var Nt=\/%20\/g,jt=\/#.*$\/,Dt=\/([?&])_=[^&]*\/,qt=\/^(.*?):[ \\t]*([^\\r\\n]*)$\/gm,Lt=\/^(?:GET|HEAD)$\/,Ht=\/^\\\/\\\/\/,Ot={},Pt={},Rt=\"*\/\".concat(\"*\"),Mt=E.createElement(\"a\");function It(o){return function(e,t){\"string\"!=typeof e&&(t=e,e=\"*\");var n,r=0,i=e.toLowerCase().match(P)||[];if(m(t))while(n=i[r++])\"+\"===n[0]?(n=n.slice(1)||\"*\",(o[n]=o[n]||[]).unshift(t)):(o[n]=o[n]||[]).push(t)}}function Wt(t,i,o,a){var s={},u=t===Pt;function l(e){var r;return s[e]=!0,S.each(t[e]||[],function(e,t){var n=t(i,o,a);return\"string\"!=typeof n||u||s[n]?u?!(r=n):void 0:(i.dataTypes.unshift(n),l(n),!1)}),r}return l(i.dataTypes[0])||!s[\"*\"]&&l(\"*\")}function Ft(e,t){var n,r,i=S.ajaxSettings.flatOptions||{};for(n in t)void 0!==t[n]&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&S.extend(!0,e,r),e}Mt.href=bt.href,S.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:bt.href,type:\"GET\",isLocal:\/^(?:about|app|app-storage|.+-extension|file|res|widget):$\/.test(bt.protocol),global:!0,processData:!0,async:!0,contentType:\"application\/x-www-form-urlencoded; charset=UTF-8\",accepts:{\"*\":Rt,text:\"text\/plain\",html:\"text\/html\",xml:\"application\/xml, text\/xml\",json:\"application\/json, text\/javascript\"},contents:{xml:\/\\bxml\\b\/,html:\/\\bhtml\/,json:\/\\bjson\\b\/},responseFields:{xml:\"responseXML\",text:\"responseText\",json:\"responseJSON\"},converters:{\"* text\":String,\"text html\":!0,\"text json\":JSON.parse,\"text xml\":S.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?Ft(Ft(e,S.ajaxSettings),t):Ft(S.ajaxSettings,e)},ajaxPrefilter:It(Ot),ajaxTransport:It(Pt),ajax:function(e,t){\"object\"==typeof e&&(t=e,e=void 0),t=t||{};var c,f,p,n,d,r,h,g,i,o,v=S.ajaxSetup({},t),y=v.context||v,m=v.context&&(y.nodeType||y.jquery)?S(y):S.event,x=S.Deferred(),b=S.Callbacks(\"once memory\"),w=v.statusCode||{},a={},s={},u=\"canceled\",T={readyState:0,getResponseHeader:function(e){var t;if(h){if(!n){n={};while(t=qt.exec(p))n[t[1].toLowerCase()+\" \"]=(n[t[1].toLowerCase()+\" \"]||[]).concat(t[2])}t=n[e.toLowerCase()+\" \"]}return null==t?null:t.join(\", \")},getAllResponseHeaders:function(){return h?p:null},setRequestHeader:function(e,t){return null==h&&(e=s[e.toLowerCase()]=s[e.toLowerCase()]||e,a[e]=t),this},overrideMimeType:function(e){return null==h&&(v.mimeType=e),this},statusCode:function(e){var t;if(e)if(h)T.always(e[T.status]);else for(t in e)w[t]=[w[t],e[t]];return this},abort:function(e){var t=e||u;return c&&c.abort(t),l(0,t),this}};if(x.promise(T),v.url=((e||v.url||bt.href)+\"\").replace(Ht,bt.protocol+\"\/\/\"),v.type=t.method||t.type||v.method||v.type,v.dataTypes=(v.dataType||\"*\").toLowerCase().match(P)||[\"\"],null==v.crossDomain){r=E.createElement(\"a\");try{r.href=v.url,r.href=r.href,v.crossDomain=Mt.protocol+\"\/\/\"+Mt.host!=r.protocol+\"\/\/\"+r.host}catch(e){v.crossDomain=!0}}if(v.data&&v.processData&&\"string\"!=typeof v.data&&(v.data=S.param(v.data,v.traditional)),Wt(Ot,v,t,T),h)return T;for(i in(g=S.event&&v.global)&&0==S.active++&&S.event.trigger(\"ajaxStart\"),v.type=v.type.toUpperCase(),v.hasContent=!Lt.test(v.type),f=v.url.replace(jt,\"\"),v.hasContent?v.data&&v.processData&&0===(v.contentType||\"\").indexOf(\"application\/x-www-form-urlencoded\")&&(v.data=v.data.replace(Nt,\"+\")):(o=v.url.slice(f.length),v.data&&(v.processData||\"string\"==typeof v.data)&&(f+=(Tt.test(f)?\"&\":\"?\")+v.data,delete v.data),!1===v.cache&&(f=f.replace(Dt,\"$1\"),o=(Tt.test(f)?\"&\":\"?\")+\"_=\"+wt.guid+++o),v.url=f+o),v.ifModified&&(S.lastModified[f]&&T.setRequestHeader(\"If-Modified-Since\",S.lastModified[f]),S.etag[f]&&T.setRequestHeader(\"If-None-Match\",S.etag[f])),(v.data&&v.hasContent&&!1!==v.contentType||t.contentType)&&T.setRequestHeader(\"Content-Type\",v.contentType),T.setRequestHeader(\"Accept\",v.dataTypes[0]&&v.accepts[v.dataTypes[0]]?v.accepts[v.dataTypes[0]]+(\"*\"!==v.dataTypes[0]?\", \"+Rt+\"; q=0.01\":\"\"):v.accepts[\"*\"]),v.headers)T.setRequestHeader(i,v.headers[i]);if(v.beforeSend&&(!1===v.beforeSend.call(y,T,v)||h))return T.abort();if(u=\"abort\",b.add(v.complete),T.done(v.success),T.fail(v.error),c=Wt(Pt,v,t,T)){if(T.readyState=1,g&&m.trigger(\"ajaxSend\",[T,v]),h)return T;v.async&&0<v.timeout&&(d=C.setTimeout(function(){T.abort(\"timeout\")},v.timeout));try{h=!1,c.send(a,l)}catch(e){if(h)throw e;l(-1,e)}}else l(-1,\"No Transport\");function l(e,t,n,r){var i,o,a,s,u,l=t;h||(h=!0,d&&C.clearTimeout(d),c=void 0,p=r||\"\",T.readyState=0<e?4:0,i=200<=e&&e<300||304===e,n&&(s=function(e,t,n){var r,i,o,a,s=e.contents,u=e.dataTypes;while(\"*\"===u[0])u.shift(),void 0===r&&(r=e.mimeType||t.getResponseHeader(\"Content-Type\"));if(r)for(i in s)if(s[i]&&s[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+\" \"+u[0]]){o=i;break}a||(a=i)}o=o||a}if(o)return o!==u[0]&&u.unshift(o),n[o]}(v,T,n)),!i&&-1<S.inArray(\"script\",v.dataTypes)&&S.inArray(\"json\",v.dataTypes)<0&&(v.converters[\"text script\"]=function(){}),s=function(e,t,n,r){var i,o,a,s,u,l={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)l[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if(\"*\"===o)o=u;else if(\"*\"!==u&&u!==o){if(!(a=l[u+\" \"+o]||l[\"* \"+o]))for(i in l)if((s=i.split(\" \"))[1]===o&&(a=l[u+\" \"+s[0]]||l[\"* \"+s[0]])){!0===a?a=l[i]:!0!==l[i]&&(o=s[0],c.unshift(s[1]));break}if(!0!==a)if(a&&e[\"throws\"])t=a(t);else try{t=a(t)}catch(e){return{state:\"parsererror\",error:a?e:\"No conversion from \"+u+\" to \"+o}}}return{state:\"success\",data:t}}(v,s,T,i),i?(v.ifModified&&((u=T.getResponseHeader(\"Last-Modified\"))&&(S.lastModified[f]=u),(u=T.getResponseHeader(\"etag\"))&&(S.etag[f]=u)),204===e||\"HEAD\"===v.type?l=\"nocontent\":304===e?l=\"notmodified\":(l=s.state,o=s.data,i=!(a=s.error))):(a=l,!e&&l||(l=\"error\",e<0&&(e=0))),T.status=e,T.statusText=(t||l)+\"\",i?x.resolveWith(y,[o,l,T]):x.rejectWith(y,[T,l,a]),T.statusCode(w),w=void 0,g&&m.trigger(i?\"ajaxSuccess\":\"ajaxError\",[T,v,i?o:a]),b.fireWith(y,[T,l]),g&&(m.trigger(\"ajaxComplete\",[T,v]),--S.active||S.event.trigger(\"ajaxStop\")))}return T},getJSON:function(e,t,n){return S.get(e,t,n,\"json\")},getScript:function(e,t){return S.get(e,void 0,t,\"script\")}}),S.each([\"get\",\"post\"],function(e,i){S[i]=function(e,t,n,r){return m(t)&&(r=r||n,n=t,t=void 0),S.ajax(S.extend({url:e,type:i,dataType:r,data:t,success:n},S.isPlainObject(e)&&e))}}),S.ajaxPrefilter(function(e){var t;for(t in e.headers)\"content-type\"===t.toLowerCase()&&(e.contentType=e.headers[t]||\"\")}),S._evalUrl=function(e,t,n){return S.ajax({url:e,type:\"GET\",dataType:\"script\",cache:!0,async:!1,global:!1,converters:{\"text script\":function(){}},dataFilter:function(e){S.globalEval(e,t,n)}})},S.fn.extend({wrapAll:function(e){var t;return this[0]&&(m(e)&&(e=e.call(this[0])),t=S(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstElementChild)e=e.firstElementChild;return e}).append(this)),this},wrapInner:function(n){return m(n)?this.each(function(e){S(this).wrapInner(n.call(this,e))}):this.each(function(){var e=S(this),t=e.contents();t.length?t.wrapAll(n):e.append(n)})},wrap:function(t){var n=m(t);return this.each(function(e){S(this).wrapAll(n?t.call(this,e):t)})},unwrap:function(e){return this.parent(e).not(\"body\").each(function(){S(this).replaceWith(this.childNodes)}),this}}),S.expr.pseudos.hidden=function(e){return!S.expr.pseudos.visible(e)},S.expr.pseudos.visible=function(e){return!!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)},S.ajaxSettings.xhr=function(){try{return new C.XMLHttpRequest}catch(e){}};var Bt={0:200,1223:204},$t=S.ajaxSettings.xhr();y.cors=!!$t&&\"withCredentials\"in $t,y.ajax=$t=!!$t,S.ajaxTransport(function(i){var o,a;if(y.cors||$t&&!i.crossDomain)return{send:function(e,t){var n,r=i.xhr();if(r.open(i.type,i.url,i.async,i.username,i.password),i.xhrFields)for(n in i.xhrFields)r[n]=i.xhrFields[n];for(n in i.mimeType&&r.overrideMimeType&&r.overrideMimeType(i.mimeType),i.crossDomain||e[\"X-Requested-With\"]||(e[\"X-Requested-With\"]=\"XMLHttpRequest\"),e)r.setRequestHeader(n,e[n]);o=function(e){return function(){o&&(o=a=r.onload=r.onerror=r.onabort=r.ontimeout=r.onreadystatechange=null,\"abort\"===e?r.abort():\"error\"===e?\"number\"!=typeof r.status?t(0,\"error\"):t(r.status,r.statusText):t(Bt[r.status]||r.status,r.statusText,\"text\"!==(r.responseType||\"text\")||\"string\"!=typeof r.responseText?{binary:r.response}:{text:r.responseText},r.getAllResponseHeaders()))}},r.onload=o(),a=r.onerror=r.ontimeout=o(\"error\"),void 0!==r.onabort?r.onabort=a:r.onreadystatechange=function(){4===r.readyState&&C.setTimeout(function(){o&&a()})},o=o(\"abort\");try{r.send(i.hasContent&&i.data||null)}catch(e){if(o)throw e}},abort:function(){o&&o()}}}),S.ajaxPrefilter(function(e){e.crossDomain&&(e.contents.script=!1)}),S.ajaxSetup({accepts:{script:\"text\/javascript, application\/javascript, application\/ecmascript, application\/x-ecmascript\"},contents:{script:\/\\b(?:java|ecma)script\\b\/},converters:{\"text script\":function(e){return S.globalEval(e),e}}}),S.ajaxPrefilter(\"script\",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type=\"GET\")}),S.ajaxTransport(\"script\",function(n){var r,i;if(n.crossDomain||n.scriptAttrs)return{send:function(e,t){r=S(\"<script>\").attr(n.scriptAttrs||{}).prop({charset:n.scriptCharset,src:n.url}).on(\"load error\",i=function(e){r.remove(),i=null,e&&t(\"error\"===e.type?404:200,e.type)}),E.head.appendChild(r[0])},abort:function(){i&&i()}}});var _t,zt=[],Ut=\/(=)\\?(?=&|$)|\\?\\?\/;S.ajaxSetup({jsonp:\"callback\",jsonpCallback:function(){var e=zt.pop()||S.expando+\"_\"+wt.guid++;return this[e]=!0,e}}),S.ajaxPrefilter(\"json jsonp\",function(e,t,n){var r,i,o,a=!1!==e.jsonp&&(Ut.test(e.url)?\"url\":\"string\"==typeof e.data&&0===(e.contentType||\"\").indexOf(\"application\/x-www-form-urlencoded\")&&Ut.test(e.data)&&\"data\");if(a||\"jsonp\"===e.dataTypes[0])return r=e.jsonpCallback=m(e.jsonpCallback)?e.jsonpCallback():e.jsonpCallback,a?e[a]=e[a].replace(Ut,\"$1\"+r):!1!==e.jsonp&&(e.url+=(Tt.test(e.url)?\"&\":\"?\")+e.jsonp+\"=\"+r),e.converters[\"script json\"]=function(){return o||S.error(r+\" was not called\"),o[0]},e.dataTypes[0]=\"json\",i=C[r],C[r]=function(){o=arguments},n.always(function(){void 0===i?S(C).removeProp(r):C[r]=i,e[r]&&(e.jsonpCallback=t.jsonpCallback,zt.push(r)),o&&m(i)&&i(o[0]),o=i=void 0}),\"script\"}),y.createHTMLDocument=((_t=E.implementation.createHTMLDocument(\"\").body).innerHTML=\"<form><\/form><form><\/form>\",2===_t.childNodes.length),S.parseHTML=function(e,t,n){return\"string\"!=typeof e?[]:(\"boolean\"==typeof t&&(n=t,t=!1),t||(y.createHTMLDocument?((r=(t=E.implementation.createHTMLDocument(\"\")).createElement(\"base\")).href=E.location.href,t.head.appendChild(r)):t=E),o=!n&&[],(i=N.exec(e))?[t.createElement(i[1])]:(i=xe([e],t,o),o&&o.length&&S(o).remove(),S.merge([],i.childNodes)));var r,i,o},S.fn.load=function(e,t,n){var r,i,o,a=this,s=e.indexOf(\" \");return-1<s&&(r=ht(e.slice(s)),e=e.slice(0,s)),m(t)?(n=t,t=void 0):t&&\"object\"==typeof t&&(i=\"POST\"),0<a.length&&S.ajax({url:e,type:i||\"GET\",dataType:\"html\",data:t}).done(function(e){o=arguments,a.html(r?S(\"<div>\").append(S.parseHTML(e)).find(r):e)}).always(n&&function(e,t){a.each(function(){n.apply(this,o||[e.responseText,t,e])})}),this},S.expr.pseudos.animated=function(t){return S.grep(S.timers,function(e){return t===e.elem}).length},S.offset={setOffset:function(e,t,n){var r,i,o,a,s,u,l=S.css(e,\"position\"),c=S(e),f={};\"static\"===l&&(e.style.position=\"relative\"),s=c.offset(),o=S.css(e,\"top\"),u=S.css(e,\"left\"),(\"absolute\"===l||\"fixed\"===l)&&-1<(o+u).indexOf(\"auto\")?(a=(r=c.position()).top,i=r.left):(a=parseFloat(o)||0,i=parseFloat(u)||0),m(t)&&(t=t.call(e,n,S.extend({},s))),null!=t.top&&(f.top=t.top-s.top+a),null!=t.left&&(f.left=t.left-s.left+i),\"using\"in t?t.using.call(e,f):c.css(f)}},S.fn.extend({offset:function(t){if(arguments.length)return void 0===t?this:this.each(function(e){S.offset.setOffset(this,t,e)});var e,n,r=this[0];return r?r.getClientRects().length?(e=r.getBoundingClientRect(),n=r.ownerDocument.defaultView,{top:e.top+n.pageYOffset,left:e.left+n.pageXOffset}):{top:0,left:0}:void 0},position:function(){if(this[0]){var e,t,n,r=this[0],i={top:0,left:0};if(\"fixed\"===S.css(r,\"position\"))t=r.getBoundingClientRect();else{t=this.offset(),n=r.ownerDocument,e=r.offsetParent||n.documentElement;while(e&&(e===n.body||e===n.documentElement)&&\"static\"===S.css(e,\"position\"))e=e.parentNode;e&&e!==r&&1===e.nodeType&&((i=S(e).offset()).top+=S.css(e,\"borderTopWidth\",!0),i.left+=S.css(e,\"borderLeftWidth\",!0))}return{top:t.top-i.top-S.css(r,\"marginTop\",!0),left:t.left-i.left-S.css(r,\"marginLeft\",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent;while(e&&\"static\"===S.css(e,\"position\"))e=e.offsetParent;return e||re})}}),S.each({scrollLeft:\"pageXOffset\",scrollTop:\"pageYOffset\"},function(t,i){var o=\"pageYOffset\"===i;S.fn[t]=function(e){return $(this,function(e,t,n){var r;if(x(e)?r=e:9===e.nodeType&&(r=e.defaultView),void 0===n)return r?r[i]:e[t];r?r.scrollTo(o?r.pageXOffset:n,o?n:r.pageYOffset):e[t]=n},t,e,arguments.length)}}),S.each([\"top\",\"left\"],function(e,n){S.cssHooks[n]=Fe(y.pixelPosition,function(e,t){if(t)return t=We(e,n),Pe.test(t)?S(e).position()[n]+\"px\":t})}),S.each({Height:\"height\",Width:\"width\"},function(a,s){S.each({padding:\"inner\"+a,content:s,\"\":\"outer\"+a},function(r,o){S.fn[o]=function(e,t){var n=arguments.length&&(r||\"boolean\"!=typeof e),i=r||(!0===e||!0===t?\"margin\":\"border\");return $(this,function(e,t,n){var r;return x(e)?0===o.indexOf(\"outer\")?e[\"inner\"+a]:e.document.documentElement[\"client\"+a]:9===e.nodeType?(r=e.documentElement,Math.max(e.body[\"scroll\"+a],r[\"scroll\"+a],e.body[\"offset\"+a],r[\"offset\"+a],r[\"client\"+a])):void 0===n?S.css(e,t,i):S.style(e,t,n,i)},s,n?e:void 0,n)}})}),S.each([\"ajaxStart\",\"ajaxStop\",\"ajaxComplete\",\"ajaxError\",\"ajaxSuccess\",\"ajaxSend\"],function(e,t){S.fn[t]=function(e){return this.on(t,e)}}),S.fn.extend({bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,\"**\"):this.off(t,e||\"**\",n)},hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)}}),S.each(\"blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu\".split(\" \"),function(e,n){S.fn[n]=function(e,t){return 0<arguments.length?this.on(n,null,e,t):this.trigger(n)}});var Xt=\/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$\/g;S.proxy=function(e,t){var n,r,i;if(\"string\"==typeof t&&(n=e[t],t=e,e=n),m(e))return r=s.call(arguments,2),(i=function(){return e.apply(t||this,r.concat(s.call(arguments)))}).guid=e.guid=e.guid||S.guid++,i},S.holdReady=function(e){e?S.readyWait++:S.ready(!0)},S.isArray=Array.isArray,S.parseJSON=JSON.parse,S.nodeName=A,S.isFunction=m,S.isWindow=x,S.camelCase=X,S.type=w,S.now=Date.now,S.isNumeric=function(e){var t=S.type(e);return(\"number\"===t||\"string\"===t)&&!isNaN(e-parseFloat(e))},S.trim=function(e){return null==e?\"\":(e+\"\").replace(Xt,\"\")},\"function\"==typeof define&&define.amd&&define(\"jquery\",[],function(){return S});var Vt=C.jQuery,Gt=C.$;return S.noConflict=function(e){return C.$===S&&(C.$=Gt),e&&C.jQuery===S&&(C.jQuery=Vt),S},\"undefined\"==typeof e&&(C.jQuery=C.$=S),S});\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/script-dir\/jquery-3.6.0.min.js","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * jQuery JavaScript Library v3.6.0\n+ * jQuery JavaScript Library v3.6.1\n@@ -12,1 +12,1 @@\n- * Date: 2021-03-02T17:08Z\n+ * Date: 2022-08-26T17:52Z\n@@ -26,1 +26,1 @@\n-\t\t\/\/ See ticket #14549 for more info.\n+\t\t\/\/ See ticket trac-14549 for more info.\n@@ -154,1 +154,1 @@\n-\tversion = \"3.6.0\",\n+\tversion = \"3.6.1\",\n@@ -3132,2 +3132,2 @@\n-\t\/\/ Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n-\t\/\/ Strict HTML recognition (#11290: must start with <)\n+\t\/\/ Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)\n+\t\/\/ Strict HTML recognition (trac-11290: must start with <)\n@@ -4090,1 +4090,1 @@\n-\t\/\/ the ready event fires. See #6781\n+\t\/\/ the ready event fires. See trac-6781\n@@ -4218,1 +4218,1 @@\n-\/\/ Microsoft forgot to hump their vendor prefix (#9572)\n+\/\/ Microsoft forgot to hump their vendor prefix (trac-9572)\n@@ -4254,1 +4254,1 @@\n-\t\t\t\/\/ but we should not, see #8335.\n+\t\t\t\/\/ but we should not, see trac-8335.\n@@ -4493,1 +4493,1 @@\n-\t\t\t\t\t\t\/\/ The attrs elements can be null (#14894)\n+\t\t\t\t\t\t\/\/ The attrs elements can be null (trac-14894)\n@@ -4916,1 +4916,1 @@\n-\t\/\/ Check state lost if the name is set (#11217)\n+\t\/\/ Check state lost if the name is set (trac-11217)\n@@ -4918,1 +4918,1 @@\n-\t\/\/ `name` and `type` must use .setAttribute for WWA (#14901)\n+\t\/\/ `name` and `type` must use .setAttribute for WWA (trac-14901)\n@@ -4942,1 +4942,1 @@\n-\/\/ We have to close these tags to support XHTML (#13200)\n+\/\/ We have to close these tags to support XHTML (trac-13200)\n@@ -4968,1 +4968,1 @@\n-\t\/\/ Use typeof to avoid zero-argument method invocation on host objects (#15151)\n+\t\/\/ Use typeof to avoid zero-argument method invocation on host objects (trac-15151)\n@@ -5051,1 +5051,1 @@\n-\t\t\t\t\/\/ Ensure the created nodes are orphaned (#12392)\n+\t\t\t\t\/\/ Ensure the created nodes are orphaned (trac-12392)\n@@ -5472,2 +5472,2 @@\n-\t\t\t\t\/\/ Don't check non-elements (#13208)\n-\t\t\t\t\/\/ Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n+\t\t\t\t\/\/ Don't check non-elements (trac-13208)\n+\t\t\t\t\/\/ Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)\n@@ -5480,1 +5480,1 @@\n-\t\t\t\t\t\t\/\/ Don't conflict with Object.prototype properties (#13203)\n+\t\t\t\t\t\t\/\/ Don't conflict with Object.prototype properties (trac-13203)\n@@ -5734,1 +5734,1 @@\n-\t\t\/\/ Target should not be a text node (#504, #13143)\n+\t\t\/\/ Target should not be a text node (trac-504, trac-13143)\n@@ -5857,4 +5857,4 @@\n-\t\t\/\/ Suppress native focus or blur as it's already being fired\n-\t\t\/\/ in leverageNative.\n-\t\t_default: function() {\n-\t\t\treturn true;\n+\t\t\/\/ Suppress native focus or blur if we're currently inside\n+\t\t\/\/ a leveraged native-event stack\n+\t\t_default: function( event ) {\n+\t\t\treturn dataPriv.get( event.target, type );\n@@ -5959,1 +5959,2 @@\n-\trcleanScript = \/^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$\/g;\n+\n+\trcleanScript = \/^\\s*<!\\[CDATA\\[|\\]\\]>\\s*$\/g;\n@@ -6073,1 +6074,1 @@\n-\t\t\t\/\/ being emptied incorrectly in certain situations (#8070).\n+\t\t\t\/\/ being emptied incorrectly in certain situations (trac-8070).\n@@ -6114,0 +6115,6 @@\n+\n+\t\t\t\t\t\t\t\/\/ Unwrap a CDATA section containing script contents. This shouldn't be\n+\t\t\t\t\t\t\t\/\/ needed as in XML documents they're already not visible when\n+\t\t\t\t\t\t\t\/\/ inspecting element contents and in HTML documents they have no\n+\t\t\t\t\t\t\t\/\/ meaning but we're preserving that logic for backwards compatibility.\n+\t\t\t\t\t\t\t\/\/ This will be removed completely in 4.0. See gh-4904.\n@@ -6396,0 +6403,3 @@\n+var rcustomProp = \/^--\/;\n+\n+\n@@ -6398,1 +6408,1 @@\n-\t\t\/\/ Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n+\t\t\/\/ Support: IE <=11 only, Firefox <=30 (trac-15098, trac-14150)\n@@ -6433,0 +6443,9 @@\n+var whitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\";\n+\n+\n+var rtrimCSS = new RegExp(\n+\t\"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\",\n+\t\"g\"\n+);\n+\n+\n@@ -6498,1 +6517,1 @@\n-\t\/\/ Style of cloned element affects source element cloned (#8908)\n+\t\/\/ Style of cloned element affects source element cloned (trac-8908)\n@@ -6578,0 +6597,1 @@\n+\t\tisCustomProp = rcustomProp.test( name ),\n@@ -6588,2 +6608,2 @@\n-\t\/\/   .css('filter') (IE 9 only, #12537)\n-\t\/\/   .css('--customProperty) (#3144)\n+\t\/\/   .css('filter') (IE 9 only, trac-12537)\n+\t\/\/   .css('--customProperty) (gh-3144)\n@@ -6593,0 +6613,11 @@\n+\t\t\/\/ trim whitespace for custom property (issue gh-4926)\n+\t\tif ( isCustomProp ) {\n+\n+\t\t\t\/\/ rtrim treats U+000D CARRIAGE RETURN and U+000C FORM FEED\n+\t\t\t\/\/ as whitespace while CSS does not, but this is not a problem\n+\t\t\t\/\/ because CSS preprocessing replaces them with U+000A LINE FEED\n+\t\t\t\/\/ (which *is* CSS whitespace)\n+\t\t\t\/\/ https:\/\/www.w3.org\/TR\/css-syntax-3\/#input-preprocessing\n+\t\t\tret = ret.replace( rtrimCSS, \"$1\" );\n+\t\t}\n+\n@@ -6688,1 +6719,0 @@\n-\trcustomProp = \/^--\/,\n@@ -6924,1 +6954,1 @@\n-\t\t\t\/\/ Convert \"+=\" or \"-=\" to relative numbers (#7345)\n+\t\t\t\/\/ Convert \"+=\" or \"-=\" to relative numbers (trac-7345)\n@@ -6928,1 +6958,1 @@\n-\t\t\t\t\/\/ Fixes bug #9237\n+\t\t\t\t\/\/ Fixes bug trac-9237\n@@ -6932,1 +6962,1 @@\n-\t\t\t\/\/ Make sure that null and NaN values aren't set (#7116)\n+\t\t\t\/\/ Make sure that null and NaN values aren't set (trac-7116)\n@@ -7556,1 +7586,1 @@\n-\t\t\t\t\/\/ Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n+\t\t\t\t\/\/ Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (trac-12497)\n@@ -7946,1 +7976,0 @@\n-\/\/ https:\/\/web.archive.org\/web\/20100324014747\/http:\/\/blindsignals.com\/index.php\/2009\/07\/jquery-delay\/\n@@ -8171,2 +8200,1 @@\n-\t\t\t\t\/\/ https:\/\/web.archive.org\/web\/20141116233347\/http:\/\/fluidproject.org\/blog\/2008\/01\/09\/getting-setting-and-removing-tabindex-values-with-javascript\/\n-\t\t\t\t\/\/ Use proper attribute retrieval(#12072)\n+\t\t\t\t\/\/ Use proper attribute retrieval (trac-12072)\n@@ -8276,2 +8304,1 @@\n-\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n-\t\t\ti = 0;\n+\t\tvar classNames, cur, curValue, className, i, finalValue;\n@@ -8285,1 +8312,1 @@\n-\t\tclasses = classesToArray( value );\n+\t\tclassNames = classesToArray( value );\n@@ -8287,4 +8314,4 @@\n-\t\tif ( classes.length ) {\n-\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n-\t\t\t\tcurValue = getClass( elem );\n-\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n+\t\tif ( classNames.length ) {\n+\t\t\treturn this.each( function() {\n+\t\t\t\tcurValue = getClass( this );\n+\t\t\t\tcur = this.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n@@ -8293,4 +8320,4 @@\n-\t\t\t\t\tj = 0;\n-\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n-\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n-\t\t\t\t\t\t\tcur += clazz + \" \";\n+\t\t\t\t\tfor ( i = 0; i < classNames.length; i++ ) {\n+\t\t\t\t\t\tclassName = classNames[ i ];\n+\t\t\t\t\t\tif ( cur.indexOf( \" \" + className + \" \" ) < 0 ) {\n+\t\t\t\t\t\t\tcur += className + \" \";\n@@ -8303,1 +8330,1 @@\n-\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n+\t\t\t\t\t\tthis.setAttribute( \"class\", finalValue );\n@@ -8306,1 +8333,1 @@\n-\t\t\t}\n+\t\t\t} );\n@@ -8313,2 +8340,1 @@\n-\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n-\t\t\ti = 0;\n+\t\tvar classNames, cur, curValue, className, i, finalValue;\n@@ -8326,1 +8352,1 @@\n-\t\tclasses = classesToArray( value );\n+\t\tclassNames = classesToArray( value );\n@@ -8328,3 +8354,3 @@\n-\t\tif ( classes.length ) {\n-\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n-\t\t\t\tcurValue = getClass( elem );\n+\t\tif ( classNames.length ) {\n+\t\t\treturn this.each( function() {\n+\t\t\t\tcurValue = getClass( this );\n@@ -8333,1 +8359,1 @@\n-\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n+\t\t\t\tcur = this.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n@@ -8336,2 +8362,2 @@\n-\t\t\t\t\tj = 0;\n-\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n+\t\t\t\t\tfor ( i = 0; i < classNames.length; i++ ) {\n+\t\t\t\t\t\tclassName = classNames[ i ];\n@@ -8340,2 +8366,2 @@\n-\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) > -1 ) {\n-\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n+\t\t\t\t\t\twhile ( cur.indexOf( \" \" + className + \" \" ) > -1 ) {\n+\t\t\t\t\t\t\tcur = cur.replace( \" \" + className + \" \", \" \" );\n@@ -8348,1 +8374,1 @@\n-\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n+\t\t\t\t\t\tthis.setAttribute( \"class\", finalValue );\n@@ -8351,1 +8377,1 @@\n-\t\t\t}\n+\t\t\t} );\n@@ -8358,1 +8384,2 @@\n-\t\tvar type = typeof value,\n+\t\tvar classNames, className, i, self,\n+\t\t\ttype = typeof value,\n@@ -8361,4 +8388,0 @@\n-\t\tif ( typeof stateVal === \"boolean\" && isValidValue ) {\n-\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n-\t\t}\n-\n@@ -8374,2 +8397,5 @@\n-\t\treturn this.each( function() {\n-\t\t\tvar className, i, self, classNames;\n+\t\tif ( typeof stateVal === \"boolean\" && isValidValue ) {\n+\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n+\t\t}\n+\n+\t\tclassNames = classesToArray( value );\n@@ -8377,0 +8403,1 @@\n+\t\treturn this.each( function() {\n@@ -8380,1 +8407,0 @@\n-\t\t\t\ti = 0;\n@@ -8382,1 +8408,0 @@\n-\t\t\t\tclassNames = classesToArray( value );\n@@ -8384,1 +8409,2 @@\n-\t\t\t\twhile ( ( className = classNames[ i++ ] ) ) {\n+\t\t\t\tfor ( i = 0; i < classNames.length; i++ ) {\n+\t\t\t\t\tclassName = classNames[ i ];\n@@ -8518,1 +8544,1 @@\n-\t\t\t\t\t\/\/ option.text throws exceptions (#14686, #14858)\n+\t\t\t\t\t\/\/ option.text throws exceptions (trac-14686, trac-14858)\n@@ -8545,1 +8571,1 @@\n-\t\t\t\t\t\/\/ IE8-9 doesn't update selected after form reset (#2551)\n+\t\t\t\t\t\/\/ IE8-9 doesn't update selected after form reset (trac-2551)\n@@ -8688,2 +8714,2 @@\n-\t\t\/\/ Determine event propagation path in advance, per W3C events spec (#9951)\n-\t\t\/\/ Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n+\t\t\/\/ Determine event propagation path in advance, per W3C events spec (trac-9951)\n+\t\t\/\/ Bubble up to document, then to window; watch for a global ownerDocument var (trac-9724)\n@@ -8741,1 +8767,1 @@\n-\t\t\t\t\/\/ Don't do default actions on window, that's where global variables be (#6170)\n+\t\t\t\t\/\/ Don't do default actions on window, that's where global variables be (trac-6170)\n@@ -9015,1 +9041,1 @@\n-\t\/\/ #7653, #8125, #8152: local protocol detection\n+\t\/\/ trac-7653, trac-8125, trac-8152: local protocol detection\n@@ -9038,1 +9064,1 @@\n-\t\/\/ Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n+\t\/\/ Avoid comment-prolog char sequence (trac-10098); must appease lint and evade compression\n@@ -9109,1 +9135,1 @@\n-\/\/ Fixes #9887\n+\/\/ Fixes trac-9887\n@@ -9520,1 +9546,1 @@\n-\t\t\/\/ Handle falsy url in the settings object (#10093: consistency with old signature)\n+\t\t\/\/ Handle falsy url in the settings object (trac-10093: consistency with old signature)\n@@ -9525,1 +9551,1 @@\n-\t\t\/\/ Alias method option to type as per ticket #12004\n+\t\t\/\/ Alias method option to type as per ticket trac-12004\n@@ -9568,1 +9594,1 @@\n-\t\t\/\/ Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n+\t\t\/\/ Don't fire events if jQuery.event is undefined in an AMD-usage scenario (trac-15118)\n@@ -9597,1 +9623,1 @@\n-\t\t\t\t\/\/ #9682: remove data so that it's not used in an eventual retry\n+\t\t\t\t\/\/ trac-9682: remove data so that it's not used in an eventual retry\n@@ -9870,1 +9896,1 @@\n-\t\t\/\/ Make this explicit, since user can override this through ajaxSetup (#11264)\n+\t\t\/\/ Make this explicit, since user can override this through ajaxSetup (trac-11264)\n@@ -9979,1 +10005,1 @@\n-\t\t\/\/ #1450: sometimes IE returns 1223 when it should be 204\n+\t\t\/\/ trac-1450: sometimes IE returns 1223 when it should be 204\n@@ -10051,1 +10077,1 @@\n-\t\t\t\t\t\t\t\t\t\t\/\/ File: protocol always yields status 0; see #8605, #14207\n+\t\t\t\t\t\t\t\t\t\t\/\/ File: protocol always yields status 0; see trac-8605, trac-14207\n@@ -10112,1 +10138,1 @@\n-\t\t\t\t\t\/\/ #14683: Only rethrow if this hasn't been notified as an error yet\n+\t\t\t\t\t\/\/ trac-14683: Only rethrow if this hasn't been notified as an error yet\n@@ -10756,1 +10782,3 @@\n-var rtrim = \/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$\/g;\n+\/\/ Require that the \"whitespace run\" starts from a non-whitespace\n+\/\/ to avoid O(N^2) behavior when the engine would try matching \"\\s+$\" at each space position.\n+var rtrim = \/^[\\s\\uFEFF\\xA0]+|([^\\s\\uFEFF\\xA0])[\\s\\uFEFF\\xA0]+$\/g;\n@@ -10823,1 +10851,1 @@\n-\t\t( text + \"\" ).replace( rtrim, \"\" );\n+\t\t( text + \"\" ).replace( rtrim, \"$1\" );\n@@ -10871,2 +10899,2 @@\n-\/\/ (#7102#comment:10, https:\/\/github.com\/jquery\/jquery\/pull\/557)\n-\/\/ and CommonJS for browser emulators (#13566)\n+\/\/ (trac-7102#comment:10, https:\/\/github.com\/jquery\/jquery\/pull\/557)\n+\/\/ and CommonJS for browser emulators (trac-13566)\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/script-dir\/jquery-3.6.1.js","additions":121,"deletions":93,"binary":false,"changes":214,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/script-dir\/jquery-3.6.0.js","status":"renamed"},{"patch":"@@ -0,0 +1,2 @@\n+\/*! jQuery v3.6.1 | (c) OpenJS Foundation and other contributors | jquery.org\/license *\/\n+!function(e,t){\"use strict\";\"object\"==typeof module&&\"object\"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error(\"jQuery requires a window with a document\");return t(e)}:t(e)}(\"undefined\"!=typeof window?window:this,function(C,e){\"use strict\";var t=[],r=Object.getPrototypeOf,s=t.slice,g=t.flat?function(e){return t.flat.call(e)}:function(e){return t.concat.apply([],e)},u=t.push,i=t.indexOf,n={},o=n.toString,y=n.hasOwnProperty,a=y.toString,l=a.call(Object),v={},m=function(e){return\"function\"==typeof e&&\"number\"!=typeof e.nodeType&&\"function\"!=typeof e.item},x=function(e){return null!=e&&e===e.window},E=C.document,c={type:!0,src:!0,nonce:!0,noModule:!0};function b(e,t,n){var r,i,o=(n=n||E).createElement(\"script\");if(o.text=e,t)for(r in c)(i=t[r]||t.getAttribute&&t.getAttribute(r))&&o.setAttribute(r,i);n.head.appendChild(o).parentNode.removeChild(o)}function w(e){return null==e?e+\"\":\"object\"==typeof e||\"function\"==typeof e?n[o.call(e)]||\"object\":typeof e}var f=\"3.6.1\",S=function(e,t){return new S.fn.init(e,t)};function p(e){var t=!!e&&\"length\"in e&&e.length,n=w(e);return!m(e)&&!x(e)&&(\"array\"===n||0===t||\"number\"==typeof t&&0<t&&t-1 in e)}S.fn=S.prototype={jquery:f,constructor:S,length:0,toArray:function(){return s.call(this)},get:function(e){return null==e?s.call(this):e<0?this[e+this.length]:this[e]},pushStack:function(e){var t=S.merge(this.constructor(),e);return t.prevObject=this,t},each:function(e){return S.each(this,e)},map:function(n){return this.pushStack(S.map(this,function(e,t){return n.call(e,t,e)}))},slice:function(){return this.pushStack(s.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},even:function(){return this.pushStack(S.grep(this,function(e,t){return(t+1)%2}))},odd:function(){return this.pushStack(S.grep(this,function(e,t){return t%2}))},eq:function(e){var t=this.length,n=+e+(e<0?t:0);return this.pushStack(0<=n&&n<t?[this[n]]:[])},end:function(){return this.prevObject||this.constructor()},push:u,sort:t.sort,splice:t.splice},S.extend=S.fn.extend=function(){var e,t,n,r,i,o,a=arguments[0]||{},s=1,u=arguments.length,l=!1;for(\"boolean\"==typeof a&&(l=a,a=arguments[s]||{},s++),\"object\"==typeof a||m(a)||(a={}),s===u&&(a=this,s--);s<u;s++)if(null!=(e=arguments[s]))for(t in e)r=e[t],\"__proto__\"!==t&&a!==r&&(l&&r&&(S.isPlainObject(r)||(i=Array.isArray(r)))?(n=a[t],o=i&&!Array.isArray(n)?[]:i||S.isPlainObject(n)?n:{},i=!1,a[t]=S.extend(l,o,r)):void 0!==r&&(a[t]=r));return a},S.extend({expando:\"jQuery\"+(f+Math.random()).replace(\/\\D\/g,\"\"),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isPlainObject:function(e){var t,n;return!(!e||\"[object Object]\"!==o.call(e))&&(!(t=r(e))||\"function\"==typeof(n=y.call(t,\"constructor\")&&t.constructor)&&a.call(n)===l)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},globalEval:function(e,t,n){b(e,{nonce:t&&t.nonce},n)},each:function(e,t){var n,r=0;if(p(e)){for(n=e.length;r<n;r++)if(!1===t.call(e[r],r,e[r]))break}else for(r in e)if(!1===t.call(e[r],r,e[r]))break;return e},makeArray:function(e,t){var n=t||[];return null!=e&&(p(Object(e))?S.merge(n,\"string\"==typeof e?[e]:e):u.call(n,e)),n},inArray:function(e,t,n){return null==t?-1:i.call(t,e,n)},merge:function(e,t){for(var n=+t.length,r=0,i=e.length;r<n;r++)e[i++]=t[r];return e.length=i,e},grep:function(e,t,n){for(var r=[],i=0,o=e.length,a=!n;i<o;i++)!t(e[i],i)!==a&&r.push(e[i]);return r},map:function(e,t,n){var r,i,o=0,a=[];if(p(e))for(r=e.length;o<r;o++)null!=(i=t(e[o],o,n))&&a.push(i);else for(o in e)null!=(i=t(e[o],o,n))&&a.push(i);return g(a)},guid:1,support:v}),\"function\"==typeof Symbol&&(S.fn[Symbol.iterator]=t[Symbol.iterator]),S.each(\"Boolean Number String Function Array Date RegExp Object Error Symbol\".split(\" \"),function(e,t){n[\"[object \"+t+\"]\"]=t.toLowerCase()});var d=function(n){var e,d,b,o,i,h,f,g,w,u,l,T,C,a,E,y,s,c,v,S=\"sizzle\"+1*new Date,p=n.document,k=0,r=0,m=ue(),x=ue(),A=ue(),N=ue(),j=function(e,t){return e===t&&(l=!0),0},D={}.hasOwnProperty,t=[],q=t.pop,L=t.push,H=t.push,O=t.slice,P=function(e,t){for(var n=0,r=e.length;n<r;n++)if(e[n]===t)return n;return-1},R=\"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",M=\"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",I=\"(?:\\\\\\\\[\\\\da-fA-F]{1,6}\"+M+\"?|\\\\\\\\[^\\\\r\\\\n\\\\f]|[\\\\w-]|[^\\0-\\\\x7f])+\",W=\"\\\\[\"+M+\"*(\"+I+\")(?:\"+M+\"*([*^$|!~]?=)\"+M+\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\"+I+\"))|)\"+M+\"*\\\\]\",F=\":(\"+I+\")(?:\\\\((('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\"+W+\")*)|.*)\\\\)|)\",$=new RegExp(M+\"+\",\"g\"),B=new RegExp(\"^\"+M+\"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\"+M+\"+$\",\"g\"),_=new RegExp(\"^\"+M+\"*,\"+M+\"*\"),z=new RegExp(\"^\"+M+\"*([>+~]|\"+M+\")\"+M+\"*\"),U=new RegExp(M+\"|>\"),X=new RegExp(F),V=new RegExp(\"^\"+I+\"$\"),G={ID:new RegExp(\"^#(\"+I+\")\"),CLASS:new RegExp(\"^\\\\.(\"+I+\")\"),TAG:new RegExp(\"^(\"+I+\"|[*])\"),ATTR:new RegExp(\"^\"+W),PSEUDO:new RegExp(\"^\"+F),CHILD:new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\"+M+\"*(even|odd|(([+-]|)(\\\\d*)n|)\"+M+\"*(?:([+-]|)\"+M+\"*(\\\\d+)|))\"+M+\"*\\\\)|)\",\"i\"),bool:new RegExp(\"^(?:\"+R+\")$\",\"i\"),needsContext:new RegExp(\"^\"+M+\"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\"+M+\"*((?:-\\\\d)?\\\\d*)\"+M+\"*\\\\)|)(?=[^-]|$)\",\"i\")},Y=\/HTML$\/i,Q=\/^(?:input|select|textarea|button)$\/i,J=\/^h\\d$\/i,K=\/^[^{]+\\{\\s*\\[native \\w\/,Z=\/^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$\/,ee=\/[+~]\/,te=new RegExp(\"\\\\\\\\[\\\\da-fA-F]{1,6}\"+M+\"?|\\\\\\\\([^\\\\r\\\\n\\\\f])\",\"g\"),ne=function(e,t){var n=\"0x\"+e.slice(1)-65536;return t||(n<0?String.fromCharCode(n+65536):String.fromCharCode(n>>10|55296,1023&n|56320))},re=\/([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]\/g,ie=function(e,t){return t?\"\\0\"===e?\"\\ufffd\":e.slice(0,-1)+\"\\\\\"+e.charCodeAt(e.length-1).toString(16)+\" \":\"\\\\\"+e},oe=function(){T()},ae=be(function(e){return!0===e.disabled&&\"fieldset\"===e.nodeName.toLowerCase()},{dir:\"parentNode\",next:\"legend\"});try{H.apply(t=O.call(p.childNodes),p.childNodes),t[p.childNodes.length].nodeType}catch(e){H={apply:t.length?function(e,t){L.apply(e,O.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function se(t,e,n,r){var i,o,a,s,u,l,c,f=e&&e.ownerDocument,p=e?e.nodeType:9;if(n=n||[],\"string\"!=typeof t||!t||1!==p&&9!==p&&11!==p)return n;if(!r&&(T(e),e=e||C,E)){if(11!==p&&(u=Z.exec(t)))if(i=u[1]){if(9===p){if(!(a=e.getElementById(i)))return n;if(a.id===i)return n.push(a),n}else if(f&&(a=f.getElementById(i))&&v(e,a)&&a.id===i)return n.push(a),n}else{if(u[2])return H.apply(n,e.getElementsByTagName(t)),n;if((i=u[3])&&d.getElementsByClassName&&e.getElementsByClassName)return H.apply(n,e.getElementsByClassName(i)),n}if(d.qsa&&!N[t+\" \"]&&(!y||!y.test(t))&&(1!==p||\"object\"!==e.nodeName.toLowerCase())){if(c=t,f=e,1===p&&(U.test(t)||z.test(t))){(f=ee.test(t)&&ve(e.parentNode)||e)===e&&d.scope||((s=e.getAttribute(\"id\"))?s=s.replace(re,ie):e.setAttribute(\"id\",s=S)),o=(l=h(t)).length;while(o--)l[o]=(s?\"#\"+s:\":scope\")+\" \"+xe(l[o]);c=l.join(\",\")}try{return H.apply(n,f.querySelectorAll(c)),n}catch(e){N(t,!0)}finally{s===S&&e.removeAttribute(\"id\")}}}return g(t.replace(B,\"$1\"),e,n,r)}function ue(){var r=[];return function e(t,n){return r.push(t+\" \")>b.cacheLength&&delete e[r.shift()],e[t+\" \"]=n}}function le(e){return e[S]=!0,e}function ce(e){var t=C.createElement(\"fieldset\");try{return!!e(t)}catch(e){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function fe(e,t){var n=e.split(\"|\"),r=n.length;while(r--)b.attrHandle[n[r]]=t}function pe(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&e.sourceIndex-t.sourceIndex;if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function de(t){return function(e){return\"input\"===e.nodeName.toLowerCase()&&e.type===t}}function he(n){return function(e){var t=e.nodeName.toLowerCase();return(\"input\"===t||\"button\"===t)&&e.type===n}}function ge(t){return function(e){return\"form\"in e?e.parentNode&&!1===e.disabled?\"label\"in e?\"label\"in e.parentNode?e.parentNode.disabled===t:e.disabled===t:e.isDisabled===t||e.isDisabled!==!t&&ae(e)===t:e.disabled===t:\"label\"in e&&e.disabled===t}}function ye(a){return le(function(o){return o=+o,le(function(e,t){var n,r=a([],e.length,o),i=r.length;while(i--)e[n=r[i]]&&(e[n]=!(t[n]=e[n]))})})}function ve(e){return e&&\"undefined\"!=typeof e.getElementsByTagName&&e}for(e in d=se.support={},i=se.isXML=function(e){var t=e&&e.namespaceURI,n=e&&(e.ownerDocument||e).documentElement;return!Y.test(t||n&&n.nodeName||\"HTML\")},T=se.setDocument=function(e){var t,n,r=e?e.ownerDocument||e:p;return r!=C&&9===r.nodeType&&r.documentElement&&(a=(C=r).documentElement,E=!i(C),p!=C&&(n=C.defaultView)&&n.top!==n&&(n.addEventListener?n.addEventListener(\"unload\",oe,!1):n.attachEvent&&n.attachEvent(\"onunload\",oe)),d.scope=ce(function(e){return a.appendChild(e).appendChild(C.createElement(\"div\")),\"undefined\"!=typeof e.querySelectorAll&&!e.querySelectorAll(\":scope fieldset div\").length}),d.attributes=ce(function(e){return e.className=\"i\",!e.getAttribute(\"className\")}),d.getElementsByTagName=ce(function(e){return e.appendChild(C.createComment(\"\")),!e.getElementsByTagName(\"*\").length}),d.getElementsByClassName=K.test(C.getElementsByClassName),d.getById=ce(function(e){return a.appendChild(e).id=S,!C.getElementsByName||!C.getElementsByName(S).length}),d.getById?(b.filter.ID=function(e){var t=e.replace(te,ne);return function(e){return e.getAttribute(\"id\")===t}},b.find.ID=function(e,t){if(\"undefined\"!=typeof t.getElementById&&E){var n=t.getElementById(e);return n?[n]:[]}}):(b.filter.ID=function(e){var n=e.replace(te,ne);return function(e){var t=\"undefined\"!=typeof e.getAttributeNode&&e.getAttributeNode(\"id\");return t&&t.value===n}},b.find.ID=function(e,t){if(\"undefined\"!=typeof t.getElementById&&E){var n,r,i,o=t.getElementById(e);if(o){if((n=o.getAttributeNode(\"id\"))&&n.value===e)return[o];i=t.getElementsByName(e),r=0;while(o=i[r++])if((n=o.getAttributeNode(\"id\"))&&n.value===e)return[o]}return[]}}),b.find.TAG=d.getElementsByTagName?function(e,t){return\"undefined\"!=typeof t.getElementsByTagName?t.getElementsByTagName(e):d.qsa?t.querySelectorAll(e):void 0}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if(\"*\"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},b.find.CLASS=d.getElementsByClassName&&function(e,t){if(\"undefined\"!=typeof t.getElementsByClassName&&E)return t.getElementsByClassName(e)},s=[],y=[],(d.qsa=K.test(C.querySelectorAll))&&(ce(function(e){var t;a.appendChild(e).innerHTML=\"<a id='\"+S+\"'><\/a><select id='\"+S+\"-\\r\\\\' msallowcapture=''><option selected=''><\/option><\/select>\",e.querySelectorAll(\"[msallowcapture^='']\").length&&y.push(\"[*^$]=\"+M+\"*(?:''|\\\"\\\")\"),e.querySelectorAll(\"[selected]\").length||y.push(\"\\\\[\"+M+\"*(?:value|\"+R+\")\"),e.querySelectorAll(\"[id~=\"+S+\"-]\").length||y.push(\"~=\"),(t=C.createElement(\"input\")).setAttribute(\"name\",\"\"),e.appendChild(t),e.querySelectorAll(\"[name='']\").length||y.push(\"\\\\[\"+M+\"*name\"+M+\"*=\"+M+\"*(?:''|\\\"\\\")\"),e.querySelectorAll(\":checked\").length||y.push(\":checked\"),e.querySelectorAll(\"a#\"+S+\"+*\").length||y.push(\".#.+[+~]\"),e.querySelectorAll(\"\\\\\\f\"),y.push(\"[\\\\r\\\\n\\\\f]\")}),ce(function(e){e.innerHTML=\"<a href='' disabled='disabled'><\/a><select disabled='disabled'><option\/><\/select>\";var t=C.createElement(\"input\");t.setAttribute(\"type\",\"hidden\"),e.appendChild(t).setAttribute(\"name\",\"D\"),e.querySelectorAll(\"[name=d]\").length&&y.push(\"name\"+M+\"*[*^$|!~]?=\"),2!==e.querySelectorAll(\":enabled\").length&&y.push(\":enabled\",\":disabled\"),a.appendChild(e).disabled=!0,2!==e.querySelectorAll(\":disabled\").length&&y.push(\":enabled\",\":disabled\"),e.querySelectorAll(\"*,:x\"),y.push(\",.*:\")})),(d.matchesSelector=K.test(c=a.matches||a.webkitMatchesSelector||a.mozMatchesSelector||a.oMatchesSelector||a.msMatchesSelector))&&ce(function(e){d.disconnectedMatch=c.call(e,\"*\"),c.call(e,\"[s!='']:x\"),s.push(\"!=\",F)}),y=y.length&&new RegExp(y.join(\"|\")),s=s.length&&new RegExp(s.join(\"|\")),t=K.test(a.compareDocumentPosition),v=t||K.test(a.contains)?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},j=t?function(e,t){if(e===t)return l=!0,0;var n=!e.compareDocumentPosition-!t.compareDocumentPosition;return n||(1&(n=(e.ownerDocument||e)==(t.ownerDocument||t)?e.compareDocumentPosition(t):1)||!d.sortDetached&&t.compareDocumentPosition(e)===n?e==C||e.ownerDocument==p&&v(p,e)?-1:t==C||t.ownerDocument==p&&v(p,t)?1:u?P(u,e)-P(u,t):0:4&n?-1:1)}:function(e,t){if(e===t)return l=!0,0;var n,r=0,i=e.parentNode,o=t.parentNode,a=[e],s=[t];if(!i||!o)return e==C?-1:t==C?1:i?-1:o?1:u?P(u,e)-P(u,t):0;if(i===o)return pe(e,t);n=e;while(n=n.parentNode)a.unshift(n);n=t;while(n=n.parentNode)s.unshift(n);while(a[r]===s[r])r++;return r?pe(a[r],s[r]):a[r]==p?-1:s[r]==p?1:0}),C},se.matches=function(e,t){return se(e,null,null,t)},se.matchesSelector=function(e,t){if(T(e),d.matchesSelector&&E&&!N[t+\" \"]&&(!s||!s.test(t))&&(!y||!y.test(t)))try{var n=c.call(e,t);if(n||d.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(e){N(t,!0)}return 0<se(t,C,null,[e]).length},se.contains=function(e,t){return(e.ownerDocument||e)!=C&&T(e),v(e,t)},se.attr=function(e,t){(e.ownerDocument||e)!=C&&T(e);var n=b.attrHandle[t.toLowerCase()],r=n&&D.call(b.attrHandle,t.toLowerCase())?n(e,t,!E):void 0;return void 0!==r?r:d.attributes||!E?e.getAttribute(t):(r=e.getAttributeNode(t))&&r.specified?r.value:null},se.escape=function(e){return(e+\"\").replace(re,ie)},se.error=function(e){throw new Error(\"Syntax error, unrecognized expression: \"+e)},se.uniqueSort=function(e){var t,n=[],r=0,i=0;if(l=!d.detectDuplicates,u=!d.sortStable&&e.slice(0),e.sort(j),l){while(t=e[i++])t===e[i]&&(r=n.push(i));while(r--)e.splice(n[r],1)}return u=null,e},o=se.getText=function(e){var t,n=\"\",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if(\"string\"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=o(e)}else if(3===i||4===i)return e.nodeValue}else while(t=e[r++])n+=o(t);return n},(b=se.selectors={cacheLength:50,createPseudo:le,match:G,attrHandle:{},find:{},relative:{\">\":{dir:\"parentNode\",first:!0},\" \":{dir:\"parentNode\"},\"+\":{dir:\"previousSibling\",first:!0},\"~\":{dir:\"previousSibling\"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(te,ne),e[3]=(e[3]||e[4]||e[5]||\"\").replace(te,ne),\"~=\"===e[2]&&(e[3]=\" \"+e[3]+\" \"),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),\"nth\"===e[1].slice(0,3)?(e[3]||se.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*(\"even\"===e[3]||\"odd\"===e[3])),e[5]=+(e[7]+e[8]||\"odd\"===e[3])):e[3]&&se.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return G.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||\"\":n&&X.test(n)&&(t=h(n,!0))&&(t=n.indexOf(\")\",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(te,ne).toLowerCase();return\"*\"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=m[e+\" \"];return t||(t=new RegExp(\"(^|\"+M+\")\"+e+\"(\"+M+\"|$)\"))&&m(e,function(e){return t.test(\"string\"==typeof e.className&&e.className||\"undefined\"!=typeof e.getAttribute&&e.getAttribute(\"class\")||\"\")})},ATTR:function(n,r,i){return function(e){var t=se.attr(e,n);return null==t?\"!=\"===r:!r||(t+=\"\",\"=\"===r?t===i:\"!=\"===r?t!==i:\"^=\"===r?i&&0===t.indexOf(i):\"*=\"===r?i&&-1<t.indexOf(i):\"$=\"===r?i&&t.slice(-i.length)===i:\"~=\"===r?-1<(\" \"+t.replace($,\" \")+\" \").indexOf(i):\"|=\"===r&&(t===i||t.slice(0,i.length+1)===i+\"-\"))}},CHILD:function(h,e,t,g,y){var v=\"nth\"!==h.slice(0,3),m=\"last\"!==h.slice(-4),x=\"of-type\"===e;return 1===g&&0===y?function(e){return!!e.parentNode}:function(e,t,n){var r,i,o,a,s,u,l=v!==m?\"nextSibling\":\"previousSibling\",c=e.parentNode,f=x&&e.nodeName.toLowerCase(),p=!n&&!x,d=!1;if(c){if(v){while(l){a=e;while(a=a[l])if(x?a.nodeName.toLowerCase()===f:1===a.nodeType)return!1;u=l=\"only\"===h&&!u&&\"nextSibling\"}return!0}if(u=[m?c.firstChild:c.lastChild],m&&p){d=(s=(r=(i=(o=(a=c)[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===k&&r[1])&&r[2],a=s&&c.childNodes[s];while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if(1===a.nodeType&&++d&&a===e){i[h]=[k,s,d];break}}else if(p&&(d=s=(r=(i=(o=(a=e)[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===k&&r[1]),!1===d)while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if((x?a.nodeName.toLowerCase()===f:1===a.nodeType)&&++d&&(p&&((i=(o=a[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]=[k,d]),a===e))break;return(d-=y)===g||d%g==0&&0<=d\/g}}},PSEUDO:function(e,o){var t,a=b.pseudos[e]||b.setFilters[e.toLowerCase()]||se.error(\"unsupported pseudo: \"+e);return a[S]?a(o):1<a.length?(t=[e,e,\"\",o],b.setFilters.hasOwnProperty(e.toLowerCase())?le(function(e,t){var n,r=a(e,o),i=r.length;while(i--)e[n=P(e,r[i])]=!(t[n]=r[i])}):function(e){return a(e,0,t)}):a}},pseudos:{not:le(function(e){var r=[],i=[],s=f(e.replace(B,\"$1\"));return s[S]?le(function(e,t,n,r){var i,o=s(e,null,r,[]),a=e.length;while(a--)(i=o[a])&&(e[a]=!(t[a]=i))}):function(e,t,n){return r[0]=e,s(r,null,n,i),r[0]=null,!i.pop()}}),has:le(function(t){return function(e){return 0<se(t,e).length}}),contains:le(function(t){return t=t.replace(te,ne),function(e){return-1<(e.textContent||o(e)).indexOf(t)}}),lang:le(function(n){return V.test(n||\"\")||se.error(\"unsupported lang: \"+n),n=n.replace(te,ne).toLowerCase(),function(e){var t;do{if(t=E?e.lang:e.getAttribute(\"xml:lang\")||e.getAttribute(\"lang\"))return(t=t.toLowerCase())===n||0===t.indexOf(n+\"-\")}while((e=e.parentNode)&&1===e.nodeType);return!1}}),target:function(e){var t=n.location&&n.location.hash;return t&&t.slice(1)===e.id},root:function(e){return e===a},focus:function(e){return e===C.activeElement&&(!C.hasFocus||C.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:ge(!1),disabled:ge(!0),checked:function(e){var t=e.nodeName.toLowerCase();return\"input\"===t&&!!e.checked||\"option\"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!b.pseudos.empty(e)},header:function(e){return J.test(e.nodeName)},input:function(e){return Q.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return\"input\"===t&&\"button\"===e.type||\"button\"===t},text:function(e){var t;return\"input\"===e.nodeName.toLowerCase()&&\"text\"===e.type&&(null==(t=e.getAttribute(\"type\"))||\"text\"===t.toLowerCase())},first:ye(function(){return[0]}),last:ye(function(e,t){return[t-1]}),eq:ye(function(e,t,n){return[n<0?n+t:n]}),even:ye(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:ye(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:ye(function(e,t,n){for(var r=n<0?n+t:t<n?t:n;0<=--r;)e.push(r);return e}),gt:ye(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}}).pseudos.nth=b.pseudos.eq,{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})b.pseudos[e]=de(e);for(e in{submit:!0,reset:!0})b.pseudos[e]=he(e);function me(){}function xe(e){for(var t=0,n=e.length,r=\"\";t<n;t++)r+=e[t].value;return r}function be(s,e,t){var u=e.dir,l=e.next,c=l||u,f=t&&\"parentNode\"===c,p=r++;return e.first?function(e,t,n){while(e=e[u])if(1===e.nodeType||f)return s(e,t,n);return!1}:function(e,t,n){var r,i,o,a=[k,p];if(n){while(e=e[u])if((1===e.nodeType||f)&&s(e,t,n))return!0}else while(e=e[u])if(1===e.nodeType||f)if(i=(o=e[S]||(e[S]={}))[e.uniqueID]||(o[e.uniqueID]={}),l&&l===e.nodeName.toLowerCase())e=e[u]||e;else{if((r=i[c])&&r[0]===k&&r[1]===p)return a[2]=r[2];if((i[c]=a)[2]=s(e,t,n))return!0}return!1}}function we(i){return 1<i.length?function(e,t,n){var r=i.length;while(r--)if(!i[r](e,t,n))return!1;return!0}:i[0]}function Te(e,t,n,r,i){for(var o,a=[],s=0,u=e.length,l=null!=t;s<u;s++)(o=e[s])&&(n&&!n(o,r,i)||(a.push(o),l&&t.push(s)));return a}function Ce(d,h,g,y,v,e){return y&&!y[S]&&(y=Ce(y)),v&&!v[S]&&(v=Ce(v,e)),le(function(e,t,n,r){var i,o,a,s=[],u=[],l=t.length,c=e||function(e,t,n){for(var r=0,i=t.length;r<i;r++)se(e,t[r],n);return n}(h||\"*\",n.nodeType?[n]:n,[]),f=!d||!e&&h?c:Te(c,s,d,n,r),p=g?v||(e?d:l||y)?[]:t:f;if(g&&g(f,p,n,r),y){i=Te(p,u),y(i,[],n,r),o=i.length;while(o--)(a=i[o])&&(p[u[o]]=!(f[u[o]]=a))}if(e){if(v||d){if(v){i=[],o=p.length;while(o--)(a=p[o])&&i.push(f[o]=a);v(null,p=[],i,r)}o=p.length;while(o--)(a=p[o])&&-1<(i=v?P(e,a):s[o])&&(e[i]=!(t[i]=a))}}else p=Te(p===t?p.splice(l,p.length):p),v?v(null,t,p,r):H.apply(t,p)})}function Ee(e){for(var i,t,n,r=e.length,o=b.relative[e[0].type],a=o||b.relative[\" \"],s=o?1:0,u=be(function(e){return e===i},a,!0),l=be(function(e){return-1<P(i,e)},a,!0),c=[function(e,t,n){var r=!o&&(n||t!==w)||((i=t).nodeType?u(e,t,n):l(e,t,n));return i=null,r}];s<r;s++)if(t=b.relative[e[s].type])c=[be(we(c),t)];else{if((t=b.filter[e[s].type].apply(null,e[s].matches))[S]){for(n=++s;n<r;n++)if(b.relative[e[n].type])break;return Ce(1<s&&we(c),1<s&&xe(e.slice(0,s-1).concat({value:\" \"===e[s-2].type?\"*\":\"\"})).replace(B,\"$1\"),t,s<n&&Ee(e.slice(s,n)),n<r&&Ee(e=e.slice(n)),n<r&&xe(e))}c.push(t)}return we(c)}return me.prototype=b.filters=b.pseudos,b.setFilters=new me,h=se.tokenize=function(e,t){var n,r,i,o,a,s,u,l=x[e+\" \"];if(l)return t?0:l.slice(0);a=e,s=[],u=b.preFilter;while(a){for(o in n&&!(r=_.exec(a))||(r&&(a=a.slice(r[0].length)||a),s.push(i=[])),n=!1,(r=z.exec(a))&&(n=r.shift(),i.push({value:n,type:r[0].replace(B,\" \")}),a=a.slice(n.length)),b.filter)!(r=G[o].exec(a))||u[o]&&!(r=u[o](r))||(n=r.shift(),i.push({value:n,type:o,matches:r}),a=a.slice(n.length));if(!n)break}return t?a.length:a?se.error(e):x(e,s).slice(0)},f=se.compile=function(e,t){var n,y,v,m,x,r,i=[],o=[],a=A[e+\" \"];if(!a){t||(t=h(e)),n=t.length;while(n--)(a=Ee(t[n]))[S]?i.push(a):o.push(a);(a=A(e,(y=o,m=0<(v=i).length,x=0<y.length,r=function(e,t,n,r,i){var o,a,s,u=0,l=\"0\",c=e&&[],f=[],p=w,d=e||x&&b.find.TAG(\"*\",i),h=k+=null==p?1:Math.random()||.1,g=d.length;for(i&&(w=t==C||t||i);l!==g&&null!=(o=d[l]);l++){if(x&&o){a=0,t||o.ownerDocument==C||(T(o),n=!E);while(s=y[a++])if(s(o,t||C,n)){r.push(o);break}i&&(k=h)}m&&((o=!s&&o)&&u--,e&&c.push(o))}if(u+=l,m&&l!==u){a=0;while(s=v[a++])s(c,f,t,n);if(e){if(0<u)while(l--)c[l]||f[l]||(f[l]=q.call(r));f=Te(f)}H.apply(r,f),i&&!e&&0<f.length&&1<u+v.length&&se.uniqueSort(r)}return i&&(k=h,w=p),c},m?le(r):r))).selector=e}return a},g=se.select=function(e,t,n,r){var i,o,a,s,u,l=\"function\"==typeof e&&e,c=!r&&h(e=l.selector||e);if(n=n||[],1===c.length){if(2<(o=c[0]=c[0].slice(0)).length&&\"ID\"===(a=o[0]).type&&9===t.nodeType&&E&&b.relative[o[1].type]){if(!(t=(b.find.ID(a.matches[0].replace(te,ne),t)||[])[0]))return n;l&&(t=t.parentNode),e=e.slice(o.shift().value.length)}i=G.needsContext.test(e)?0:o.length;while(i--){if(a=o[i],b.relative[s=a.type])break;if((u=b.find[s])&&(r=u(a.matches[0].replace(te,ne),ee.test(o[0].type)&&ve(t.parentNode)||t))){if(o.splice(i,1),!(e=r.length&&xe(o)))return H.apply(n,r),n;break}}}return(l||f(e,c))(r,t,!E,n,!t||ee.test(e)&&ve(t.parentNode)||t),n},d.sortStable=S.split(\"\").sort(j).join(\"\")===S,d.detectDuplicates=!!l,T(),d.sortDetached=ce(function(e){return 1&e.compareDocumentPosition(C.createElement(\"fieldset\"))}),ce(function(e){return e.innerHTML=\"<a href='#'><\/a>\",\"#\"===e.firstChild.getAttribute(\"href\")})||fe(\"type|href|height|width\",function(e,t,n){if(!n)return e.getAttribute(t,\"type\"===t.toLowerCase()?1:2)}),d.attributes&&ce(function(e){return e.innerHTML=\"<input\/>\",e.firstChild.setAttribute(\"value\",\"\"),\"\"===e.firstChild.getAttribute(\"value\")})||fe(\"value\",function(e,t,n){if(!n&&\"input\"===e.nodeName.toLowerCase())return e.defaultValue}),ce(function(e){return null==e.getAttribute(\"disabled\")})||fe(R,function(e,t,n){var r;if(!n)return!0===e[t]?t.toLowerCase():(r=e.getAttributeNode(t))&&r.specified?r.value:null}),se}(C);S.find=d,S.expr=d.selectors,S.expr[\":\"]=S.expr.pseudos,S.uniqueSort=S.unique=d.uniqueSort,S.text=d.getText,S.isXMLDoc=d.isXML,S.contains=d.contains,S.escapeSelector=d.escape;var h=function(e,t,n){var r=[],i=void 0!==n;while((e=e[t])&&9!==e.nodeType)if(1===e.nodeType){if(i&&S(e).is(n))break;r.push(e)}return r},T=function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n},k=S.expr.match.needsContext;function A(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()}var N=\/^<([a-z][^\\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\\/?>(?:<\\\/\\1>|)$\/i;function j(e,n,r){return m(n)?S.grep(e,function(e,t){return!!n.call(e,t,e)!==r}):n.nodeType?S.grep(e,function(e){return e===n!==r}):\"string\"!=typeof n?S.grep(e,function(e){return-1<i.call(n,e)!==r}):S.filter(n,e,r)}S.filter=function(e,t,n){var r=t[0];return n&&(e=\":not(\"+e+\")\"),1===t.length&&1===r.nodeType?S.find.matchesSelector(r,e)?[r]:[]:S.find.matches(e,S.grep(t,function(e){return 1===e.nodeType}))},S.fn.extend({find:function(e){var t,n,r=this.length,i=this;if(\"string\"!=typeof e)return this.pushStack(S(e).filter(function(){for(t=0;t<r;t++)if(S.contains(i[t],this))return!0}));for(n=this.pushStack([]),t=0;t<r;t++)S.find(e,i[t],n);return 1<r?S.uniqueSort(n):n},filter:function(e){return this.pushStack(j(this,e||[],!1))},not:function(e){return this.pushStack(j(this,e||[],!0))},is:function(e){return!!j(this,\"string\"==typeof e&&k.test(e)?S(e):e||[],!1).length}});var D,q=\/^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$\/;(S.fn.init=function(e,t,n){var r,i;if(!e)return this;if(n=n||D,\"string\"==typeof e){if(!(r=\"<\"===e[0]&&\">\"===e[e.length-1]&&3<=e.length?[null,e,null]:q.exec(e))||!r[1]&&t)return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e);if(r[1]){if(t=t instanceof S?t[0]:t,S.merge(this,S.parseHTML(r[1],t&&t.nodeType?t.ownerDocument||t:E,!0)),N.test(r[1])&&S.isPlainObject(t))for(r in t)m(this[r])?this[r](t[r]):this.attr(r,t[r]);return this}return(i=E.getElementById(r[2]))&&(this[0]=i,this.length=1),this}return e.nodeType?(this[0]=e,this.length=1,this):m(e)?void 0!==n.ready?n.ready(e):e(S):S.makeArray(e,this)}).prototype=S.fn,D=S(E);var L=\/^(?:parents|prev(?:Until|All))\/,H={children:!0,contents:!0,next:!0,prev:!0};function O(e,t){while((e=e[t])&&1!==e.nodeType);return e}S.fn.extend({has:function(e){var t=S(e,this),n=t.length;return this.filter(function(){for(var e=0;e<n;e++)if(S.contains(this,t[e]))return!0})},closest:function(e,t){var n,r=0,i=this.length,o=[],a=\"string\"!=typeof e&&S(e);if(!k.test(e))for(;r<i;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(n.nodeType<11&&(a?-1<a.index(n):1===n.nodeType&&S.find.matchesSelector(n,e))){o.push(n);break}return this.pushStack(1<o.length?S.uniqueSort(o):o)},index:function(e){return e?\"string\"==typeof e?i.call(S(e),this[0]):i.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){return this.pushStack(S.uniqueSort(S.merge(this.get(),S(e,t))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),S.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return h(e,\"parentNode\")},parentsUntil:function(e,t,n){return h(e,\"parentNode\",n)},next:function(e){return O(e,\"nextSibling\")},prev:function(e){return O(e,\"previousSibling\")},nextAll:function(e){return h(e,\"nextSibling\")},prevAll:function(e){return h(e,\"previousSibling\")},nextUntil:function(e,t,n){return h(e,\"nextSibling\",n)},prevUntil:function(e,t,n){return h(e,\"previousSibling\",n)},siblings:function(e){return T((e.parentNode||{}).firstChild,e)},children:function(e){return T(e.firstChild)},contents:function(e){return null!=e.contentDocument&&r(e.contentDocument)?e.contentDocument:(A(e,\"template\")&&(e=e.content||e),S.merge([],e.childNodes))}},function(r,i){S.fn[r]=function(e,t){var n=S.map(this,i,e);return\"Until\"!==r.slice(-5)&&(t=e),t&&\"string\"==typeof t&&(n=S.filter(t,n)),1<this.length&&(H[r]||S.uniqueSort(n),L.test(r)&&n.reverse()),this.pushStack(n)}});var P=\/[^\\x20\\t\\r\\n\\f]+\/g;function R(e){return e}function M(e){throw e}function I(e,t,n,r){var i;try{e&&m(i=e.promise)?i.call(e).done(t).fail(n):e&&m(i=e.then)?i.call(e,t,n):t.apply(void 0,[e].slice(r))}catch(e){n.apply(void 0,[e])}}S.Callbacks=function(r){var e,n;r=\"string\"==typeof r?(e=r,n={},S.each(e.match(P)||[],function(e,t){n[t]=!0}),n):S.extend({},r);var i,t,o,a,s=[],u=[],l=-1,c=function(){for(a=a||r.once,o=i=!0;u.length;l=-1){t=u.shift();while(++l<s.length)!1===s[l].apply(t[0],t[1])&&r.stopOnFalse&&(l=s.length,t=!1)}r.memory||(t=!1),i=!1,a&&(s=t?[]:\"\")},f={add:function(){return s&&(t&&!i&&(l=s.length-1,u.push(t)),function n(e){S.each(e,function(e,t){m(t)?r.unique&&f.has(t)||s.push(t):t&&t.length&&\"string\"!==w(t)&&n(t)})}(arguments),t&&!i&&c()),this},remove:function(){return S.each(arguments,function(e,t){var n;while(-1<(n=S.inArray(t,s,n)))s.splice(n,1),n<=l&&l--}),this},has:function(e){return e?-1<S.inArray(e,s):0<s.length},empty:function(){return s&&(s=[]),this},disable:function(){return a=u=[],s=t=\"\",this},disabled:function(){return!s},lock:function(){return a=u=[],t||i||(s=t=\"\"),this},locked:function(){return!!a},fireWith:function(e,t){return a||(t=[e,(t=t||[]).slice?t.slice():t],u.push(t),i||c()),this},fire:function(){return f.fireWith(this,arguments),this},fired:function(){return!!o}};return f},S.extend({Deferred:function(e){var o=[[\"notify\",\"progress\",S.Callbacks(\"memory\"),S.Callbacks(\"memory\"),2],[\"resolve\",\"done\",S.Callbacks(\"once memory\"),S.Callbacks(\"once memory\"),0,\"resolved\"],[\"reject\",\"fail\",S.Callbacks(\"once memory\"),S.Callbacks(\"once memory\"),1,\"rejected\"]],i=\"pending\",a={state:function(){return i},always:function(){return s.done(arguments).fail(arguments),this},\"catch\":function(e){return a.then(null,e)},pipe:function(){var i=arguments;return S.Deferred(function(r){S.each(o,function(e,t){var n=m(i[t[4]])&&i[t[4]];s[t[1]](function(){var e=n&&n.apply(this,arguments);e&&m(e.promise)?e.promise().progress(r.notify).done(r.resolve).fail(r.reject):r[t[0]+\"With\"](this,n?[e]:arguments)})}),i=null}).promise()},then:function(t,n,r){var u=0;function l(i,o,a,s){return function(){var n=this,r=arguments,e=function(){var e,t;if(!(i<u)){if((e=a.apply(n,r))===o.promise())throw new TypeError(\"Thenable self-resolution\");t=e&&(\"object\"==typeof e||\"function\"==typeof e)&&e.then,m(t)?s?t.call(e,l(u,o,R,s),l(u,o,M,s)):(u++,t.call(e,l(u,o,R,s),l(u,o,M,s),l(u,o,R,o.notifyWith))):(a!==R&&(n=void 0,r=[e]),(s||o.resolveWith)(n,r))}},t=s?e:function(){try{e()}catch(e){S.Deferred.exceptionHook&&S.Deferred.exceptionHook(e,t.stackTrace),u<=i+1&&(a!==M&&(n=void 0,r=[e]),o.rejectWith(n,r))}};i?t():(S.Deferred.getStackHook&&(t.stackTrace=S.Deferred.getStackHook()),C.setTimeout(t))}}return S.Deferred(function(e){o[0][3].add(l(0,e,m(r)?r:R,e.notifyWith)),o[1][3].add(l(0,e,m(t)?t:R)),o[2][3].add(l(0,e,m(n)?n:M))}).promise()},promise:function(e){return null!=e?S.extend(e,a):a}},s={};return S.each(o,function(e,t){var n=t[2],r=t[5];a[t[1]]=n.add,r&&n.add(function(){i=r},o[3-e][2].disable,o[3-e][3].disable,o[0][2].lock,o[0][3].lock),n.add(t[3].fire),s[t[0]]=function(){return s[t[0]+\"With\"](this===s?void 0:this,arguments),this},s[t[0]+\"With\"]=n.fireWith}),a.promise(s),e&&e.call(s,s),s},when:function(e){var n=arguments.length,t=n,r=Array(t),i=s.call(arguments),o=S.Deferred(),a=function(t){return function(e){r[t]=this,i[t]=1<arguments.length?s.call(arguments):e,--n||o.resolveWith(r,i)}};if(n<=1&&(I(e,o.done(a(t)).resolve,o.reject,!n),\"pending\"===o.state()||m(i[t]&&i[t].then)))return o.then();while(t--)I(i[t],a(t),o.reject);return o.promise()}});var W=\/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$\/;S.Deferred.exceptionHook=function(e,t){C.console&&C.console.warn&&e&&W.test(e.name)&&C.console.warn(\"jQuery.Deferred exception: \"+e.message,e.stack,t)},S.readyException=function(e){C.setTimeout(function(){throw e})};var F=S.Deferred();function $(){E.removeEventListener(\"DOMContentLoaded\",$),C.removeEventListener(\"load\",$),S.ready()}S.fn.ready=function(e){return F.then(e)[\"catch\"](function(e){S.readyException(e)}),this},S.extend({isReady:!1,readyWait:1,ready:function(e){(!0===e?--S.readyWait:S.isReady)||(S.isReady=!0)!==e&&0<--S.readyWait||F.resolveWith(E,[S])}}),S.ready.then=F.then,\"complete\"===E.readyState||\"loading\"!==E.readyState&&!E.documentElement.doScroll?C.setTimeout(S.ready):(E.addEventListener(\"DOMContentLoaded\",$),C.addEventListener(\"load\",$));var B=function(e,t,n,r,i,o,a){var s=0,u=e.length,l=null==n;if(\"object\"===w(n))for(s in i=!0,n)B(e,t,s,n[s],!0,o,a);else if(void 0!==r&&(i=!0,m(r)||(a=!0),l&&(a?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(S(e),n)})),t))for(;s<u;s++)t(e[s],n,a?r:r.call(e[s],s,t(e[s],n)));return i?e:l?t.call(e):u?t(e[0],n):o},_=\/^-ms-\/,z=\/-([a-z])\/g;function U(e,t){return t.toUpperCase()}function X(e){return e.replace(_,\"ms-\").replace(z,U)}var V=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType};function G(){this.expando=S.expando+G.uid++}G.uid=1,G.prototype={cache:function(e){var t=e[this.expando];return t||(t={},V(e)&&(e.nodeType?e[this.expando]=t:Object.defineProperty(e,this.expando,{value:t,configurable:!0}))),t},set:function(e,t,n){var r,i=this.cache(e);if(\"string\"==typeof t)i[X(t)]=n;else for(r in t)i[X(r)]=t[r];return i},get:function(e,t){return void 0===t?this.cache(e):e[this.expando]&&e[this.expando][X(t)]},access:function(e,t,n){return void 0===t||t&&\"string\"==typeof t&&void 0===n?this.get(e,t):(this.set(e,t,n),void 0!==n?n:t)},remove:function(e,t){var n,r=e[this.expando];if(void 0!==r){if(void 0!==t){n=(t=Array.isArray(t)?t.map(X):(t=X(t))in r?[t]:t.match(P)||[]).length;while(n--)delete r[t[n]]}(void 0===t||S.isEmptyObject(r))&&(e.nodeType?e[this.expando]=void 0:delete e[this.expando])}},hasData:function(e){var t=e[this.expando];return void 0!==t&&!S.isEmptyObject(t)}};var Y=new G,Q=new G,J=\/^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$\/,K=\/[A-Z]\/g;function Z(e,t,n){var r,i;if(void 0===n&&1===e.nodeType)if(r=\"data-\"+t.replace(K,\"-$&\").toLowerCase(),\"string\"==typeof(n=e.getAttribute(r))){try{n=\"true\"===(i=n)||\"false\"!==i&&(\"null\"===i?null:i===+i+\"\"?+i:J.test(i)?JSON.parse(i):i)}catch(e){}Q.set(e,t,n)}else n=void 0;return n}S.extend({hasData:function(e){return Q.hasData(e)||Y.hasData(e)},data:function(e,t,n){return Q.access(e,t,n)},removeData:function(e,t){Q.remove(e,t)},_data:function(e,t,n){return Y.access(e,t,n)},_removeData:function(e,t){Y.remove(e,t)}}),S.fn.extend({data:function(n,e){var t,r,i,o=this[0],a=o&&o.attributes;if(void 0===n){if(this.length&&(i=Q.get(o),1===o.nodeType&&!Y.get(o,\"hasDataAttrs\"))){t=a.length;while(t--)a[t]&&0===(r=a[t].name).indexOf(\"data-\")&&(r=X(r.slice(5)),Z(o,r,i[r]));Y.set(o,\"hasDataAttrs\",!0)}return i}return\"object\"==typeof n?this.each(function(){Q.set(this,n)}):B(this,function(e){var t;if(o&&void 0===e)return void 0!==(t=Q.get(o,n))?t:void 0!==(t=Z(o,n))?t:void 0;this.each(function(){Q.set(this,n,e)})},null,e,1<arguments.length,null,!0)},removeData:function(e){return this.each(function(){Q.remove(this,e)})}}),S.extend({queue:function(e,t,n){var r;if(e)return t=(t||\"fx\")+\"queue\",r=Y.get(e,t),n&&(!r||Array.isArray(n)?r=Y.access(e,t,S.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||\"fx\";var n=S.queue(e,t),r=n.length,i=n.shift(),o=S._queueHooks(e,t);\"inprogress\"===i&&(i=n.shift(),r--),i&&(\"fx\"===t&&n.unshift(\"inprogress\"),delete o.stop,i.call(e,function(){S.dequeue(e,t)},o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+\"queueHooks\";return Y.get(e,n)||Y.access(e,n,{empty:S.Callbacks(\"once memory\").add(function(){Y.remove(e,[t+\"queue\",n])})})}}),S.fn.extend({queue:function(t,n){var e=2;return\"string\"!=typeof t&&(n=t,t=\"fx\",e--),arguments.length<e?S.queue(this[0],t):void 0===n?this:this.each(function(){var e=S.queue(this,t,n);S._queueHooks(this,t),\"fx\"===t&&\"inprogress\"!==e[0]&&S.dequeue(this,t)})},dequeue:function(e){return this.each(function(){S.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||\"fx\",[])},promise:function(e,t){var n,r=1,i=S.Deferred(),o=this,a=this.length,s=function(){--r||i.resolveWith(o,[o])};\"string\"!=typeof e&&(t=e,e=void 0),e=e||\"fx\";while(a--)(n=Y.get(o[a],e+\"queueHooks\"))&&n.empty&&(r++,n.empty.add(s));return s(),i.promise(t)}});var ee=\/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)\/.source,te=new RegExp(\"^(?:([+-])=|)(\"+ee+\")([a-z%]*)$\",\"i\"),ne=[\"Top\",\"Right\",\"Bottom\",\"Left\"],re=E.documentElement,ie=function(e){return S.contains(e.ownerDocument,e)},oe={composed:!0};re.getRootNode&&(ie=function(e){return S.contains(e.ownerDocument,e)||e.getRootNode(oe)===e.ownerDocument});var ae=function(e,t){return\"none\"===(e=t||e).style.display||\"\"===e.style.display&&ie(e)&&\"none\"===S.css(e,\"display\")};function se(e,t,n,r){var i,o,a=20,s=r?function(){return r.cur()}:function(){return S.css(e,t,\"\")},u=s(),l=n&&n[3]||(S.cssNumber[t]?\"\":\"px\"),c=e.nodeType&&(S.cssNumber[t]||\"px\"!==l&&+u)&&te.exec(S.css(e,t));if(c&&c[3]!==l){u\/=2,l=l||c[3],c=+u||1;while(a--)S.style(e,t,c+l),(1-o)*(1-(o=s()\/u||.5))<=0&&(a=0),c\/=o;c*=2,S.style(e,t,c+l),n=n||[]}return n&&(c=+c||+u||0,i=n[1]?c+(n[1]+1)*n[2]:+n[2],r&&(r.unit=l,r.start=c,r.end=i)),i}var ue={};function le(e,t){for(var n,r,i,o,a,s,u,l=[],c=0,f=e.length;c<f;c++)(r=e[c]).style&&(n=r.style.display,t?(\"none\"===n&&(l[c]=Y.get(r,\"display\")||null,l[c]||(r.style.display=\"\")),\"\"===r.style.display&&ae(r)&&(l[c]=(u=a=o=void 0,a=(i=r).ownerDocument,s=i.nodeName,(u=ue[s])||(o=a.body.appendChild(a.createElement(s)),u=S.css(o,\"display\"),o.parentNode.removeChild(o),\"none\"===u&&(u=\"block\"),ue[s]=u)))):\"none\"!==n&&(l[c]=\"none\",Y.set(r,\"display\",n)));for(c=0;c<f;c++)null!=l[c]&&(e[c].style.display=l[c]);return e}S.fn.extend({show:function(){return le(this,!0)},hide:function(){return le(this)},toggle:function(e){return\"boolean\"==typeof e?e?this.show():this.hide():this.each(function(){ae(this)?S(this).show():S(this).hide()})}});var ce,fe,pe=\/^(?:checkbox|radio)$\/i,de=\/<([a-z][^\\\/\\0>\\x20\\t\\r\\n\\f]*)\/i,he=\/^$|^module$|\\\/(?:java|ecma)script\/i;ce=E.createDocumentFragment().appendChild(E.createElement(\"div\")),(fe=E.createElement(\"input\")).setAttribute(\"type\",\"radio\"),fe.setAttribute(\"checked\",\"checked\"),fe.setAttribute(\"name\",\"t\"),ce.appendChild(fe),v.checkClone=ce.cloneNode(!0).cloneNode(!0).lastChild.checked,ce.innerHTML=\"<textarea>x<\/textarea>\",v.noCloneChecked=!!ce.cloneNode(!0).lastChild.defaultValue,ce.innerHTML=\"<option><\/option>\",v.option=!!ce.lastChild;var ge={thead:[1,\"<table>\",\"<\/table>\"],col:[2,\"<table><colgroup>\",\"<\/colgroup><\/table>\"],tr:[2,\"<table><tbody>\",\"<\/tbody><\/table>\"],td:[3,\"<table><tbody><tr>\",\"<\/tr><\/tbody><\/table>\"],_default:[0,\"\",\"\"]};function ye(e,t){var n;return n=\"undefined\"!=typeof e.getElementsByTagName?e.getElementsByTagName(t||\"*\"):\"undefined\"!=typeof e.querySelectorAll?e.querySelectorAll(t||\"*\"):[],void 0===t||t&&A(e,t)?S.merge([e],n):n}function ve(e,t){for(var n=0,r=e.length;n<r;n++)Y.set(e[n],\"globalEval\",!t||Y.get(t[n],\"globalEval\"))}ge.tbody=ge.tfoot=ge.colgroup=ge.caption=ge.thead,ge.th=ge.td,v.option||(ge.optgroup=ge.option=[1,\"<select multiple='multiple'>\",\"<\/select>\"]);var me=\/<|&#?\\w+;\/;function xe(e,t,n,r,i){for(var o,a,s,u,l,c,f=t.createDocumentFragment(),p=[],d=0,h=e.length;d<h;d++)if((o=e[d])||0===o)if(\"object\"===w(o))S.merge(p,o.nodeType?[o]:o);else if(me.test(o)){a=a||f.appendChild(t.createElement(\"div\")),s=(de.exec(o)||[\"\",\"\"])[1].toLowerCase(),u=ge[s]||ge._default,a.innerHTML=u[1]+S.htmlPrefilter(o)+u[2],c=u[0];while(c--)a=a.lastChild;S.merge(p,a.childNodes),(a=f.firstChild).textContent=\"\"}else p.push(t.createTextNode(o));f.textContent=\"\",d=0;while(o=p[d++])if(r&&-1<S.inArray(o,r))i&&i.push(o);else if(l=ie(o),a=ye(f.appendChild(o),\"script\"),l&&ve(a),n){c=0;while(o=a[c++])he.test(o.type||\"\")&&n.push(o)}return f}var be=\/^([^.]*)(?:\\.(.+)|)\/;function we(){return!0}function Te(){return!1}function Ce(e,t){return e===function(){try{return E.activeElement}catch(e){}}()==(\"focus\"===t)}function Ee(e,t,n,r,i,o){var a,s;if(\"object\"==typeof t){for(s in\"string\"!=typeof n&&(r=r||n,n=void 0),t)Ee(e,s,n,r,t[s],o);return e}if(null==r&&null==i?(i=n,r=n=void 0):null==i&&(\"string\"==typeof n?(i=r,r=void 0):(i=r,r=n,n=void 0)),!1===i)i=Te;else if(!i)return e;return 1===o&&(a=i,(i=function(e){return S().off(e),a.apply(this,arguments)}).guid=a.guid||(a.guid=S.guid++)),e.each(function(){S.event.add(this,t,i,r,n)})}function Se(e,i,o){o?(Y.set(e,i,!1),S.event.add(e,i,{namespace:!1,handler:function(e){var t,n,r=Y.get(this,i);if(1&e.isTrigger&&this[i]){if(r.length)(S.event.special[i]||{}).delegateType&&e.stopPropagation();else if(r=s.call(arguments),Y.set(this,i,r),t=o(this,i),this[i](),r!==(n=Y.get(this,i))||t?Y.set(this,i,!1):n={},r!==n)return e.stopImmediatePropagation(),e.preventDefault(),n&&n.value}else r.length&&(Y.set(this,i,{value:S.event.trigger(S.extend(r[0],S.Event.prototype),r.slice(1),this)}),e.stopImmediatePropagation())}})):void 0===Y.get(e,i)&&S.event.add(e,i,we)}S.event={global:{},add:function(t,e,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,y=Y.get(t);if(V(t)){n.handler&&(n=(o=n).handler,i=o.selector),i&&S.find.matchesSelector(re,i),n.guid||(n.guid=S.guid++),(u=y.events)||(u=y.events=Object.create(null)),(a=y.handle)||(a=y.handle=function(e){return\"undefined\"!=typeof S&&S.event.triggered!==e.type?S.event.dispatch.apply(t,arguments):void 0}),l=(e=(e||\"\").match(P)||[\"\"]).length;while(l--)d=g=(s=be.exec(e[l])||[])[1],h=(s[2]||\"\").split(\".\").sort(),d&&(f=S.event.special[d]||{},d=(i?f.delegateType:f.bindType)||d,f=S.event.special[d]||{},c=S.extend({type:d,origType:g,data:r,handler:n,guid:n.guid,selector:i,needsContext:i&&S.expr.match.needsContext.test(i),namespace:h.join(\".\")},o),(p=u[d])||((p=u[d]=[]).delegateCount=0,f.setup&&!1!==f.setup.call(t,r,h,a)||t.addEventListener&&t.addEventListener(d,a)),f.add&&(f.add.call(t,c),c.handler.guid||(c.handler.guid=n.guid)),i?p.splice(p.delegateCount++,0,c):p.push(c),S.event.global[d]=!0)}},remove:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,y=Y.hasData(e)&&Y.get(e);if(y&&(u=y.events)){l=(t=(t||\"\").match(P)||[\"\"]).length;while(l--)if(d=g=(s=be.exec(t[l])||[])[1],h=(s[2]||\"\").split(\".\").sort(),d){f=S.event.special[d]||{},p=u[d=(r?f.delegateType:f.bindType)||d]||[],s=s[2]&&new RegExp(\"(^|\\\\.)\"+h.join(\"\\\\.(?:.*\\\\.|)\")+\"(\\\\.|$)\"),a=o=p.length;while(o--)c=p[o],!i&&g!==c.origType||n&&n.guid!==c.guid||s&&!s.test(c.namespace)||r&&r!==c.selector&&(\"**\"!==r||!c.selector)||(p.splice(o,1),c.selector&&p.delegateCount--,f.remove&&f.remove.call(e,c));a&&!p.length&&(f.teardown&&!1!==f.teardown.call(e,h,y.handle)||S.removeEvent(e,d,y.handle),delete u[d])}else for(d in u)S.event.remove(e,d+t[l],n,r,!0);S.isEmptyObject(u)&&Y.remove(e,\"handle events\")}},dispatch:function(e){var t,n,r,i,o,a,s=new Array(arguments.length),u=S.event.fix(e),l=(Y.get(this,\"events\")||Object.create(null))[u.type]||[],c=S.event.special[u.type]||{};for(s[0]=u,t=1;t<arguments.length;t++)s[t]=arguments[t];if(u.delegateTarget=this,!c.preDispatch||!1!==c.preDispatch.call(this,u)){a=S.event.handlers.call(this,u,l),t=0;while((i=a[t++])&&!u.isPropagationStopped()){u.currentTarget=i.elem,n=0;while((o=i.handlers[n++])&&!u.isImmediatePropagationStopped())u.rnamespace&&!1!==o.namespace&&!u.rnamespace.test(o.namespace)||(u.handleObj=o,u.data=o.data,void 0!==(r=((S.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,s))&&!1===(u.result=r)&&(u.preventDefault(),u.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,u),u.result}},handlers:function(e,t){var n,r,i,o,a,s=[],u=t.delegateCount,l=e.target;if(u&&l.nodeType&&!(\"click\"===e.type&&1<=e.button))for(;l!==this;l=l.parentNode||this)if(1===l.nodeType&&(\"click\"!==e.type||!0!==l.disabled)){for(o=[],a={},n=0;n<u;n++)void 0===a[i=(r=t[n]).selector+\" \"]&&(a[i]=r.needsContext?-1<S(i,this).index(l):S.find(i,this,null,[l]).length),a[i]&&o.push(r);o.length&&s.push({elem:l,handlers:o})}return l=this,u<t.length&&s.push({elem:l,handlers:t.slice(u)}),s},addProp:function(t,e){Object.defineProperty(S.Event.prototype,t,{enumerable:!0,configurable:!0,get:m(e)?function(){if(this.originalEvent)return e(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[t]},set:function(e){Object.defineProperty(this,t,{enumerable:!0,configurable:!0,writable:!0,value:e})}})},fix:function(e){return e[S.expando]?e:new S.Event(e)},special:{load:{noBubble:!0},click:{setup:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,\"input\")&&Se(t,\"click\",we),!1},trigger:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,\"input\")&&Se(t,\"click\"),!0},_default:function(e){var t=e.target;return pe.test(t.type)&&t.click&&A(t,\"input\")&&Y.get(t,\"click\")||A(t,\"a\")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&e.originalEvent&&(e.originalEvent.returnValue=e.result)}}}},S.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n)},S.Event=function(e,t){if(!(this instanceof S.Event))return new S.Event(e,t);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&!1===e.returnValue?we:Te,this.target=e.target&&3===e.target.nodeType?e.target.parentNode:e.target,this.currentTarget=e.currentTarget,this.relatedTarget=e.relatedTarget):this.type=e,t&&S.extend(this,t),this.timeStamp=e&&e.timeStamp||Date.now(),this[S.expando]=!0},S.Event.prototype={constructor:S.Event,isDefaultPrevented:Te,isPropagationStopped:Te,isImmediatePropagationStopped:Te,isSimulated:!1,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=we,e&&!this.isSimulated&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=we,e&&!this.isSimulated&&e.stopPropagation()},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=we,e&&!this.isSimulated&&e.stopImmediatePropagation(),this.stopPropagation()}},S.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,\"char\":!0,code:!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:!0},S.event.addProp),S.each({focus:\"focusin\",blur:\"focusout\"},function(t,e){S.event.special[t]={setup:function(){return Se(this,t,Ce),!1},trigger:function(){return Se(this,t),!0},_default:function(e){return Y.get(e.target,t)},delegateType:e}}),S.each({mouseenter:\"mouseover\",mouseleave:\"mouseout\",pointerenter:\"pointerover\",pointerleave:\"pointerout\"},function(e,i){S.event.special[e]={delegateType:i,bindType:i,handle:function(e){var t,n=e.relatedTarget,r=e.handleObj;return n&&(n===this||S.contains(this,n))||(e.type=r.origType,t=r.handler.apply(this,arguments),e.type=i),t}}}),S.fn.extend({on:function(e,t,n,r){return Ee(this,e,t,n,r)},one:function(e,t,n,r){return Ee(this,e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,S(e.delegateTarget).off(r.namespace?r.origType+\".\"+r.namespace:r.origType,r.selector,r.handler),this;if(\"object\"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return!1!==t&&\"function\"!=typeof t||(n=t,t=void 0),!1===n&&(n=Te),this.each(function(){S.event.remove(this,e,n,t)})}});var ke=\/<script|<style|<link\/i,Ae=\/checked\\s*(?:[^=]|=\\s*.checked.)\/i,Ne=\/^\\s*<!\\[CDATA\\[|\\]\\]>\\s*$\/g;function je(e,t){return A(e,\"table\")&&A(11!==t.nodeType?t:t.firstChild,\"tr\")&&S(e).children(\"tbody\")[0]||e}function De(e){return e.type=(null!==e.getAttribute(\"type\"))+\"\/\"+e.type,e}function qe(e){return\"true\/\"===(e.type||\"\").slice(0,5)?e.type=e.type.slice(5):e.removeAttribute(\"type\"),e}function Le(e,t){var n,r,i,o,a,s;if(1===t.nodeType){if(Y.hasData(e)&&(s=Y.get(e).events))for(i in Y.remove(t,\"handle events\"),s)for(n=0,r=s[i].length;n<r;n++)S.event.add(t,i,s[i][n]);Q.hasData(e)&&(o=Q.access(e),a=S.extend({},o),Q.set(t,a))}}function He(n,r,i,o){r=g(r);var e,t,a,s,u,l,c=0,f=n.length,p=f-1,d=r[0],h=m(d);if(h||1<f&&\"string\"==typeof d&&!v.checkClone&&Ae.test(d))return n.each(function(e){var t=n.eq(e);h&&(r[0]=d.call(this,e,t.html())),He(t,r,i,o)});if(f&&(t=(e=xe(r,n[0].ownerDocument,!1,n,o)).firstChild,1===e.childNodes.length&&(e=t),t||o)){for(s=(a=S.map(ye(e,\"script\"),De)).length;c<f;c++)u=e,c!==p&&(u=S.clone(u,!0,!0),s&&S.merge(a,ye(u,\"script\"))),i.call(n[c],u,c);if(s)for(l=a[a.length-1].ownerDocument,S.map(a,qe),c=0;c<s;c++)u=a[c],he.test(u.type||\"\")&&!Y.access(u,\"globalEval\")&&S.contains(l,u)&&(u.src&&\"module\"!==(u.type||\"\").toLowerCase()?S._evalUrl&&!u.noModule&&S._evalUrl(u.src,{nonce:u.nonce||u.getAttribute(\"nonce\")},l):b(u.textContent.replace(Ne,\"\"),u,l))}return n}function Oe(e,t,n){for(var r,i=t?S.filter(t,e):e,o=0;null!=(r=i[o]);o++)n||1!==r.nodeType||S.cleanData(ye(r)),r.parentNode&&(n&&ie(r)&&ve(ye(r,\"script\")),r.parentNode.removeChild(r));return e}S.extend({htmlPrefilter:function(e){return e},clone:function(e,t,n){var r,i,o,a,s,u,l,c=e.cloneNode(!0),f=ie(e);if(!(v.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||S.isXMLDoc(e)))for(a=ye(c),r=0,i=(o=ye(e)).length;r<i;r++)s=o[r],u=a[r],void 0,\"input\"===(l=u.nodeName.toLowerCase())&&pe.test(s.type)?u.checked=s.checked:\"input\"!==l&&\"textarea\"!==l||(u.defaultValue=s.defaultValue);if(t)if(n)for(o=o||ye(e),a=a||ye(c),r=0,i=o.length;r<i;r++)Le(o[r],a[r]);else Le(e,c);return 0<(a=ye(c,\"script\")).length&&ve(a,!f&&ye(e,\"script\")),c},cleanData:function(e){for(var t,n,r,i=S.event.special,o=0;void 0!==(n=e[o]);o++)if(V(n)){if(t=n[Y.expando]){if(t.events)for(r in t.events)i[r]?S.event.remove(n,r):S.removeEvent(n,r,t.handle);n[Y.expando]=void 0}n[Q.expando]&&(n[Q.expando]=void 0)}}}),S.fn.extend({detach:function(e){return Oe(this,e,!0)},remove:function(e){return Oe(this,e)},text:function(e){return B(this,function(e){return void 0===e?S.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)})},null,e,arguments.length)},append:function(){return He(this,arguments,function(e){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||je(this,e).appendChild(e)})},prepend:function(){return He(this,arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=je(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return He(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return He(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)1===e.nodeType&&(S.cleanData(ye(e,!1)),e.textContent=\"\");return this},clone:function(e,t){return e=null!=e&&e,t=null==t?e:t,this.map(function(){return S.clone(this,e,t)})},html:function(e){return B(this,function(e){var t=this[0]||{},n=0,r=this.length;if(void 0===e&&1===t.nodeType)return t.innerHTML;if(\"string\"==typeof e&&!ke.test(e)&&!ge[(de.exec(e)||[\"\",\"\"])[1].toLowerCase()]){e=S.htmlPrefilter(e);try{for(;n<r;n++)1===(t=this[n]||{}).nodeType&&(S.cleanData(ye(t,!1)),t.innerHTML=e);t=0}catch(e){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var n=[];return He(this,arguments,function(e){var t=this.parentNode;S.inArray(this,n)<0&&(S.cleanData(ye(this)),t&&t.replaceChild(e,this))},n)}}),S.each({appendTo:\"append\",prependTo:\"prepend\",insertBefore:\"before\",insertAfter:\"after\",replaceAll:\"replaceWith\"},function(e,a){S.fn[e]=function(e){for(var t,n=[],r=S(e),i=r.length-1,o=0;o<=i;o++)t=o===i?this:this.clone(!0),S(r[o])[a](t),u.apply(n,t.get());return this.pushStack(n)}});var Pe=new RegExp(\"^(\"+ee+\")(?!px)[a-z%]+$\",\"i\"),Re=\/^--\/,Me=function(e){var t=e.ownerDocument.defaultView;return t&&t.opener||(t=C),t.getComputedStyle(e)},Ie=function(e,t,n){var r,i,o={};for(i in t)o[i]=e.style[i],e.style[i]=t[i];for(i in r=n.call(e),t)e.style[i]=o[i];return r},We=new RegExp(ne.join(\"|\"),\"i\"),Fe=\"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",$e=new RegExp(\"^\"+Fe+\"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\"+Fe+\"+$\",\"g\");function Be(e,t,n){var r,i,o,a,s=Re.test(t),u=e.style;return(n=n||Me(e))&&(a=n.getPropertyValue(t)||n[t],s&&(a=a.replace($e,\"$1\")),\"\"!==a||ie(e)||(a=S.style(e,t)),!v.pixelBoxStyles()&&Pe.test(a)&&We.test(t)&&(r=u.width,i=u.minWidth,o=u.maxWidth,u.minWidth=u.maxWidth=u.width=a,a=n.width,u.width=r,u.minWidth=i,u.maxWidth=o)),void 0!==a?a+\"\":a}function _e(e,t){return{get:function(){if(!e())return(this.get=t).apply(this,arguments);delete this.get}}}!function(){function e(){if(l){u.style.cssText=\"position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0\",l.style.cssText=\"position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%\",re.appendChild(u).appendChild(l);var e=C.getComputedStyle(l);n=\"1%\"!==e.top,s=12===t(e.marginLeft),l.style.right=\"60%\",o=36===t(e.right),r=36===t(e.width),l.style.position=\"absolute\",i=12===t(l.offsetWidth\/3),re.removeChild(u),l=null}}function t(e){return Math.round(parseFloat(e))}var n,r,i,o,a,s,u=E.createElement(\"div\"),l=E.createElement(\"div\");l.style&&(l.style.backgroundClip=\"content-box\",l.cloneNode(!0).style.backgroundClip=\"\",v.clearCloneStyle=\"content-box\"===l.style.backgroundClip,S.extend(v,{boxSizingReliable:function(){return e(),r},pixelBoxStyles:function(){return e(),o},pixelPosition:function(){return e(),n},reliableMarginLeft:function(){return e(),s},scrollboxSize:function(){return e(),i},reliableTrDimensions:function(){var e,t,n,r;return null==a&&(e=E.createElement(\"table\"),t=E.createElement(\"tr\"),n=E.createElement(\"div\"),e.style.cssText=\"position:absolute;left:-11111px;border-collapse:separate\",t.style.cssText=\"border:1px solid\",t.style.height=\"1px\",n.style.height=\"9px\",n.style.display=\"block\",re.appendChild(e).appendChild(t).appendChild(n),r=C.getComputedStyle(t),a=parseInt(r.height,10)+parseInt(r.borderTopWidth,10)+parseInt(r.borderBottomWidth,10)===t.offsetHeight,re.removeChild(e)),a}}))}();var ze=[\"Webkit\",\"Moz\",\"ms\"],Ue=E.createElement(\"div\").style,Xe={};function Ve(e){var t=S.cssProps[e]||Xe[e];return t||(e in Ue?e:Xe[e]=function(e){var t=e[0].toUpperCase()+e.slice(1),n=ze.length;while(n--)if((e=ze[n]+t)in Ue)return e}(e)||e)}var Ge=\/^(none|table(?!-c[ea]).+)\/,Ye={position:\"absolute\",visibility:\"hidden\",display:\"block\"},Qe={letterSpacing:\"0\",fontWeight:\"400\"};function Je(e,t,n){var r=te.exec(t);return r?Math.max(0,r[2]-(n||0))+(r[3]||\"px\"):t}function Ke(e,t,n,r,i,o){var a=\"width\"===t?1:0,s=0,u=0;if(n===(r?\"border\":\"content\"))return 0;for(;a<4;a+=2)\"margin\"===n&&(u+=S.css(e,n+ne[a],!0,i)),r?(\"content\"===n&&(u-=S.css(e,\"padding\"+ne[a],!0,i)),\"margin\"!==n&&(u-=S.css(e,\"border\"+ne[a]+\"Width\",!0,i))):(u+=S.css(e,\"padding\"+ne[a],!0,i),\"padding\"!==n?u+=S.css(e,\"border\"+ne[a]+\"Width\",!0,i):s+=S.css(e,\"border\"+ne[a]+\"Width\",!0,i));return!r&&0<=o&&(u+=Math.max(0,Math.ceil(e[\"offset\"+t[0].toUpperCase()+t.slice(1)]-o-u-s-.5))||0),u}function Ze(e,t,n){var r=Me(e),i=(!v.boxSizingReliable()||n)&&\"border-box\"===S.css(e,\"boxSizing\",!1,r),o=i,a=Be(e,t,r),s=\"offset\"+t[0].toUpperCase()+t.slice(1);if(Pe.test(a)){if(!n)return a;a=\"auto\"}return(!v.boxSizingReliable()&&i||!v.reliableTrDimensions()&&A(e,\"tr\")||\"auto\"===a||!parseFloat(a)&&\"inline\"===S.css(e,\"display\",!1,r))&&e.getClientRects().length&&(i=\"border-box\"===S.css(e,\"boxSizing\",!1,r),(o=s in e)&&(a=e[s])),(a=parseFloat(a)||0)+Ke(e,t,n||(i?\"border\":\"content\"),o,r,a)+\"px\"}function et(e,t,n,r,i){return new et.prototype.init(e,t,n,r,i)}S.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=Be(e,\"opacity\");return\"\"===n?\"1\":n}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,gridArea:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnStart:!0,gridRow:!0,gridRowEnd:!0,gridRowStart:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,a,s=X(t),u=Re.test(t),l=e.style;if(u||(t=Ve(s)),a=S.cssHooks[t]||S.cssHooks[s],void 0===n)return a&&\"get\"in a&&void 0!==(i=a.get(e,!1,r))?i:l[t];\"string\"===(o=typeof n)&&(i=te.exec(n))&&i[1]&&(n=se(e,t,i),o=\"number\"),null!=n&&n==n&&(\"number\"!==o||u||(n+=i&&i[3]||(S.cssNumber[s]?\"\":\"px\")),v.clearCloneStyle||\"\"!==n||0!==t.indexOf(\"background\")||(l[t]=\"inherit\"),a&&\"set\"in a&&void 0===(n=a.set(e,n,r))||(u?l.setProperty(t,n):l[t]=n))}},css:function(e,t,n,r){var i,o,a,s=X(t);return Re.test(t)||(t=Ve(s)),(a=S.cssHooks[t]||S.cssHooks[s])&&\"get\"in a&&(i=a.get(e,!0,n)),void 0===i&&(i=Be(e,t,r)),\"normal\"===i&&t in Qe&&(i=Qe[t]),\"\"===n||n?(o=parseFloat(i),!0===n||isFinite(o)?o||0:i):i}}),S.each([\"height\",\"width\"],function(e,u){S.cssHooks[u]={get:function(e,t,n){if(t)return!Ge.test(S.css(e,\"display\"))||e.getClientRects().length&&e.getBoundingClientRect().width?Ze(e,u,n):Ie(e,Ye,function(){return Ze(e,u,n)})},set:function(e,t,n){var r,i=Me(e),o=!v.scrollboxSize()&&\"absolute\"===i.position,a=(o||n)&&\"border-box\"===S.css(e,\"boxSizing\",!1,i),s=n?Ke(e,u,n,a,i):0;return a&&o&&(s-=Math.ceil(e[\"offset\"+u[0].toUpperCase()+u.slice(1)]-parseFloat(i[u])-Ke(e,u,\"border\",!1,i)-.5)),s&&(r=te.exec(t))&&\"px\"!==(r[3]||\"px\")&&(e.style[u]=t,t=S.css(e,u)),Je(0,t,s)}}}),S.cssHooks.marginLeft=_e(v.reliableMarginLeft,function(e,t){if(t)return(parseFloat(Be(e,\"marginLeft\"))||e.getBoundingClientRect().left-Ie(e,{marginLeft:0},function(){return e.getBoundingClientRect().left}))+\"px\"}),S.each({margin:\"\",padding:\"\",border:\"Width\"},function(i,o){S.cssHooks[i+o]={expand:function(e){for(var t=0,n={},r=\"string\"==typeof e?e.split(\" \"):[e];t<4;t++)n[i+ne[t]+o]=r[t]||r[t-2]||r[0];return n}},\"margin\"!==i&&(S.cssHooks[i+o].set=Je)}),S.fn.extend({css:function(e,t){return B(this,function(e,t,n){var r,i,o={},a=0;if(Array.isArray(t)){for(r=Me(e),i=t.length;a<i;a++)o[t[a]]=S.css(e,t[a],!1,r);return o}return void 0!==n?S.style(e,t,n):S.css(e,t)},e,t,1<arguments.length)}}),((S.Tween=et).prototype={constructor:et,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||S.easing._default,this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(S.cssNumber[n]?\"\":\"px\")},cur:function(){var e=et.propHooks[this.prop];return e&&e.get?e.get(this):et.propHooks._default.get(this)},run:function(e){var t,n=et.propHooks[this.prop];return this.options.duration?this.pos=t=S.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):et.propHooks._default.set(this),this}}).init.prototype=et.prototype,(et.propHooks={_default:{get:function(e){var t;return 1!==e.elem.nodeType||null!=e.elem[e.prop]&&null==e.elem.style[e.prop]?e.elem[e.prop]:(t=S.css(e.elem,e.prop,\"\"))&&\"auto\"!==t?t:0},set:function(e){S.fx.step[e.prop]?S.fx.step[e.prop](e):1!==e.elem.nodeType||!S.cssHooks[e.prop]&&null==e.elem.style[Ve(e.prop)]?e.elem[e.prop]=e.now:S.style(e.elem,e.prop,e.now+e.unit)}}}).scrollTop=et.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},S.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)\/2},_default:\"swing\"},S.fx=et.prototype.init,S.fx.step={};var tt,nt,rt,it,ot=\/^(?:toggle|show|hide)$\/,at=\/queueHooks$\/;function st(){nt&&(!1===E.hidden&&C.requestAnimationFrame?C.requestAnimationFrame(st):C.setTimeout(st,S.fx.interval),S.fx.tick())}function ut(){return C.setTimeout(function(){tt=void 0}),tt=Date.now()}function lt(e,t){var n,r=0,i={height:e};for(t=t?1:0;r<4;r+=2-t)i[\"margin\"+(n=ne[r])]=i[\"padding\"+n]=e;return t&&(i.opacity=i.width=e),i}function ct(e,t,n){for(var r,i=(ft.tweeners[t]||[]).concat(ft.tweeners[\"*\"]),o=0,a=i.length;o<a;o++)if(r=i[o].call(n,t,e))return r}function ft(o,e,t){var n,a,r=0,i=ft.prefilters.length,s=S.Deferred().always(function(){delete u.elem}),u=function(){if(a)return!1;for(var e=tt||ut(),t=Math.max(0,l.startTime+l.duration-e),n=1-(t\/l.duration||0),r=0,i=l.tweens.length;r<i;r++)l.tweens[r].run(n);return s.notifyWith(o,[l,n,t]),n<1&&i?t:(i||s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l]),!1)},l=s.promise({elem:o,props:S.extend({},e),opts:S.extend(!0,{specialEasing:{},easing:S.easing._default},t),originalProperties:e,originalOptions:t,startTime:tt||ut(),duration:t.duration,tweens:[],createTween:function(e,t){var n=S.Tween(o,l.opts,e,t,l.opts.specialEasing[e]||l.opts.easing);return l.tweens.push(n),n},stop:function(e){var t=0,n=e?l.tweens.length:0;if(a)return this;for(a=!0;t<n;t++)l.tweens[t].run(1);return e?(s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l,e])):s.rejectWith(o,[l,e]),this}}),c=l.props;for(!function(e,t){var n,r,i,o,a;for(n in e)if(i=t[r=X(n)],o=e[n],Array.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),(a=S.cssHooks[r])&&\"expand\"in a)for(n in o=a.expand(o),delete e[r],o)n in e||(e[n]=o[n],t[n]=i);else t[r]=i}(c,l.opts.specialEasing);r<i;r++)if(n=ft.prefilters[r].call(l,o,c,l.opts))return m(n.stop)&&(S._queueHooks(l.elem,l.opts.queue).stop=n.stop.bind(n)),n;return S.map(c,ct,l),m(l.opts.start)&&l.opts.start.call(o,l),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always),S.fx.timer(S.extend(u,{elem:o,anim:l,queue:l.opts.queue})),l}S.Animation=S.extend(ft,{tweeners:{\"*\":[function(e,t){var n=this.createTween(e,t);return se(n.elem,e,te.exec(t),n),n}]},tweener:function(e,t){m(e)?(t=e,e=[\"*\"]):e=e.match(P);for(var n,r=0,i=e.length;r<i;r++)n=e[r],ft.tweeners[n]=ft.tweeners[n]||[],ft.tweeners[n].unshift(t)},prefilters:[function(e,t,n){var r,i,o,a,s,u,l,c,f=\"width\"in t||\"height\"in t,p=this,d={},h=e.style,g=e.nodeType&&ae(e),y=Y.get(e,\"fxshow\");for(r in n.queue||(null==(a=S._queueHooks(e,\"fx\")).unqueued&&(a.unqueued=0,s=a.empty.fire,a.empty.fire=function(){a.unqueued||s()}),a.unqueued++,p.always(function(){p.always(function(){a.unqueued--,S.queue(e,\"fx\").length||a.empty.fire()})})),t)if(i=t[r],ot.test(i)){if(delete t[r],o=o||\"toggle\"===i,i===(g?\"hide\":\"show\")){if(\"show\"!==i||!y||void 0===y[r])continue;g=!0}d[r]=y&&y[r]||S.style(e,r)}if((u=!S.isEmptyObject(t))||!S.isEmptyObject(d))for(r in f&&1===e.nodeType&&(n.overflow=[h.overflow,h.overflowX,h.overflowY],null==(l=y&&y.display)&&(l=Y.get(e,\"display\")),\"none\"===(c=S.css(e,\"display\"))&&(l?c=l:(le([e],!0),l=e.style.display||l,c=S.css(e,\"display\"),le([e]))),(\"inline\"===c||\"inline-block\"===c&&null!=l)&&\"none\"===S.css(e,\"float\")&&(u||(p.done(function(){h.display=l}),null==l&&(c=h.display,l=\"none\"===c?\"\":c)),h.display=\"inline-block\")),n.overflow&&(h.overflow=\"hidden\",p.always(function(){h.overflow=n.overflow[0],h.overflowX=n.overflow[1],h.overflowY=n.overflow[2]})),u=!1,d)u||(y?\"hidden\"in y&&(g=y.hidden):y=Y.access(e,\"fxshow\",{display:l}),o&&(y.hidden=!g),g&&le([e],!0),p.done(function(){for(r in g||le([e]),Y.remove(e,\"fxshow\"),d)S.style(e,r,d[r])})),u=ct(g?y[r]:0,r,p),r in y||(y[r]=u.start,g&&(u.end=u.start,u.start=0))}],prefilter:function(e,t){t?ft.prefilters.unshift(e):ft.prefilters.push(e)}}),S.speed=function(e,t,n){var r=e&&\"object\"==typeof e?S.extend({},e):{complete:n||!n&&t||m(e)&&e,duration:e,easing:n&&t||t&&!m(t)&&t};return S.fx.off?r.duration=0:\"number\"!=typeof r.duration&&(r.duration in S.fx.speeds?r.duration=S.fx.speeds[r.duration]:r.duration=S.fx.speeds._default),null!=r.queue&&!0!==r.queue||(r.queue=\"fx\"),r.old=r.complete,r.complete=function(){m(r.old)&&r.old.call(this),r.queue&&S.dequeue(this,r.queue)},r},S.fn.extend({fadeTo:function(e,t,n,r){return this.filter(ae).css(\"opacity\",0).show().end().animate({opacity:t},e,n,r)},animate:function(t,e,n,r){var i=S.isEmptyObject(t),o=S.speed(e,n,r),a=function(){var e=ft(this,S.extend({},t),o);(i||Y.get(this,\"finish\"))&&e.stop(!0)};return a.finish=a,i||!1===o.queue?this.each(a):this.queue(o.queue,a)},stop:function(i,e,o){var a=function(e){var t=e.stop;delete e.stop,t(o)};return\"string\"!=typeof i&&(o=e,e=i,i=void 0),e&&this.queue(i||\"fx\",[]),this.each(function(){var e=!0,t=null!=i&&i+\"queueHooks\",n=S.timers,r=Y.get(this);if(t)r[t]&&r[t].stop&&a(r[t]);else for(t in r)r[t]&&r[t].stop&&at.test(t)&&a(r[t]);for(t=n.length;t--;)n[t].elem!==this||null!=i&&n[t].queue!==i||(n[t].anim.stop(o),e=!1,n.splice(t,1));!e&&o||S.dequeue(this,i)})},finish:function(a){return!1!==a&&(a=a||\"fx\"),this.each(function(){var e,t=Y.get(this),n=t[a+\"queue\"],r=t[a+\"queueHooks\"],i=S.timers,o=n?n.length:0;for(t.finish=!0,S.queue(this,a,[]),r&&r.stop&&r.stop.call(this,!0),e=i.length;e--;)i[e].elem===this&&i[e].queue===a&&(i[e].anim.stop(!0),i.splice(e,1));for(e=0;e<o;e++)n[e]&&n[e].finish&&n[e].finish.call(this);delete t.finish})}}),S.each([\"toggle\",\"show\",\"hide\"],function(e,r){var i=S.fn[r];S.fn[r]=function(e,t,n){return null==e||\"boolean\"==typeof e?i.apply(this,arguments):this.animate(lt(r,!0),e,t,n)}}),S.each({slideDown:lt(\"show\"),slideUp:lt(\"hide\"),slideToggle:lt(\"toggle\"),fadeIn:{opacity:\"show\"},fadeOut:{opacity:\"hide\"},fadeToggle:{opacity:\"toggle\"}},function(e,r){S.fn[e]=function(e,t,n){return this.animate(r,e,t,n)}}),S.timers=[],S.fx.tick=function(){var e,t=0,n=S.timers;for(tt=Date.now();t<n.length;t++)(e=n[t])()||n[t]!==e||n.splice(t--,1);n.length||S.fx.stop(),tt=void 0},S.fx.timer=function(e){S.timers.push(e),S.fx.start()},S.fx.interval=13,S.fx.start=function(){nt||(nt=!0,st())},S.fx.stop=function(){nt=null},S.fx.speeds={slow:600,fast:200,_default:400},S.fn.delay=function(r,e){return r=S.fx&&S.fx.speeds[r]||r,e=e||\"fx\",this.queue(e,function(e,t){var n=C.setTimeout(e,r);t.stop=function(){C.clearTimeout(n)}})},rt=E.createElement(\"input\"),it=E.createElement(\"select\").appendChild(E.createElement(\"option\")),rt.type=\"checkbox\",v.checkOn=\"\"!==rt.value,v.optSelected=it.selected,(rt=E.createElement(\"input\")).value=\"t\",rt.type=\"radio\",v.radioValue=\"t\"===rt.value;var pt,dt=S.expr.attrHandle;S.fn.extend({attr:function(e,t){return B(this,S.attr,e,t,1<arguments.length)},removeAttr:function(e){return this.each(function(){S.removeAttr(this,e)})}}),S.extend({attr:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return\"undefined\"==typeof e.getAttribute?S.prop(e,t,n):(1===o&&S.isXMLDoc(e)||(i=S.attrHooks[t.toLowerCase()]||(S.expr.match.bool.test(t)?pt:void 0)),void 0!==n?null===n?void S.removeAttr(e,t):i&&\"set\"in i&&void 0!==(r=i.set(e,n,t))?r:(e.setAttribute(t,n+\"\"),n):i&&\"get\"in i&&null!==(r=i.get(e,t))?r:null==(r=S.find.attr(e,t))?void 0:r)},attrHooks:{type:{set:function(e,t){if(!v.radioValue&&\"radio\"===t&&A(e,\"input\")){var n=e.value;return e.setAttribute(\"type\",t),n&&(e.value=n),t}}}},removeAttr:function(e,t){var n,r=0,i=t&&t.match(P);if(i&&1===e.nodeType)while(n=i[r++])e.removeAttribute(n)}}),pt={set:function(e,t,n){return!1===t?S.removeAttr(e,n):e.setAttribute(n,n),n}},S.each(S.expr.match.bool.source.match(\/\\w+\/g),function(e,t){var a=dt[t]||S.find.attr;dt[t]=function(e,t,n){var r,i,o=t.toLowerCase();return n||(i=dt[o],dt[o]=r,r=null!=a(e,t,n)?o:null,dt[o]=i),r}});var ht=\/^(?:input|select|textarea|button)$\/i,gt=\/^(?:a|area)$\/i;function yt(e){return(e.match(P)||[]).join(\" \")}function vt(e){return e.getAttribute&&e.getAttribute(\"class\")||\"\"}function mt(e){return Array.isArray(e)?e:\"string\"==typeof e&&e.match(P)||[]}S.fn.extend({prop:function(e,t){return B(this,S.prop,e,t,1<arguments.length)},removeProp:function(e){return this.each(function(){delete this[S.propFix[e]||e]})}}),S.extend({prop:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return 1===o&&S.isXMLDoc(e)||(t=S.propFix[t]||t,i=S.propHooks[t]),void 0!==n?i&&\"set\"in i&&void 0!==(r=i.set(e,n,t))?r:e[t]=n:i&&\"get\"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){var t=S.find.attr(e,\"tabindex\");return t?parseInt(t,10):ht.test(e.nodeName)||gt.test(e.nodeName)&&e.href?0:-1}}},propFix:{\"for\":\"htmlFor\",\"class\":\"className\"}}),v.optSelected||(S.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null},set:function(e){var t=e.parentNode;t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex)}}),S.each([\"tabIndex\",\"readOnly\",\"maxLength\",\"cellSpacing\",\"cellPadding\",\"rowSpan\",\"colSpan\",\"useMap\",\"frameBorder\",\"contentEditable\"],function(){S.propFix[this.toLowerCase()]=this}),S.fn.extend({addClass:function(t){var e,n,r,i,o,a;return m(t)?this.each(function(e){S(this).addClass(t.call(this,e,vt(this)))}):(e=mt(t)).length?this.each(function(){if(r=vt(this),n=1===this.nodeType&&\" \"+yt(r)+\" \"){for(o=0;o<e.length;o++)i=e[o],n.indexOf(\" \"+i+\" \")<0&&(n+=i+\" \");a=yt(n),r!==a&&this.setAttribute(\"class\",a)}}):this},removeClass:function(t){var e,n,r,i,o,a;return m(t)?this.each(function(e){S(this).removeClass(t.call(this,e,vt(this)))}):arguments.length?(e=mt(t)).length?this.each(function(){if(r=vt(this),n=1===this.nodeType&&\" \"+yt(r)+\" \"){for(o=0;o<e.length;o++){i=e[o];while(-1<n.indexOf(\" \"+i+\" \"))n=n.replace(\" \"+i+\" \",\" \")}a=yt(n),r!==a&&this.setAttribute(\"class\",a)}}):this:this.attr(\"class\",\"\")},toggleClass:function(t,n){var e,r,i,o,a=typeof t,s=\"string\"===a||Array.isArray(t);return m(t)?this.each(function(e){S(this).toggleClass(t.call(this,e,vt(this),n),n)}):\"boolean\"==typeof n&&s?n?this.addClass(t):this.removeClass(t):(e=mt(t),this.each(function(){if(s)for(o=S(this),i=0;i<e.length;i++)r=e[i],o.hasClass(r)?o.removeClass(r):o.addClass(r);else void 0!==t&&\"boolean\"!==a||((r=vt(this))&&Y.set(this,\"__className__\",r),this.setAttribute&&this.setAttribute(\"class\",r||!1===t?\"\":Y.get(this,\"__className__\")||\"\"))}))},hasClass:function(e){var t,n,r=0;t=\" \"+e+\" \";while(n=this[r++])if(1===n.nodeType&&-1<(\" \"+yt(vt(n))+\" \").indexOf(t))return!0;return!1}});var xt=\/\\r\/g;S.fn.extend({val:function(n){var r,e,i,t=this[0];return arguments.length?(i=m(n),this.each(function(e){var t;1===this.nodeType&&(null==(t=i?n.call(this,e,S(this).val()):n)?t=\"\":\"number\"==typeof t?t+=\"\":Array.isArray(t)&&(t=S.map(t,function(e){return null==e?\"\":e+\"\"})),(r=S.valHooks[this.type]||S.valHooks[this.nodeName.toLowerCase()])&&\"set\"in r&&void 0!==r.set(this,t,\"value\")||(this.value=t))})):t?(r=S.valHooks[t.type]||S.valHooks[t.nodeName.toLowerCase()])&&\"get\"in r&&void 0!==(e=r.get(t,\"value\"))?e:\"string\"==typeof(e=t.value)?e.replace(xt,\"\"):null==e?\"\":e:void 0}}),S.extend({valHooks:{option:{get:function(e){var t=S.find.attr(e,\"value\");return null!=t?t:yt(S.text(e))}},select:{get:function(e){var t,n,r,i=e.options,o=e.selectedIndex,a=\"select-one\"===e.type,s=a?null:[],u=a?o+1:i.length;for(r=o<0?u:a?o:0;r<u;r++)if(((n=i[r]).selected||r===o)&&!n.disabled&&(!n.parentNode.disabled||!A(n.parentNode,\"optgroup\"))){if(t=S(n).val(),a)return t;s.push(t)}return s},set:function(e,t){var n,r,i=e.options,o=S.makeArray(t),a=i.length;while(a--)((r=i[a]).selected=-1<S.inArray(S.valHooks.option.get(r),o))&&(n=!0);return n||(e.selectedIndex=-1),o}}}}),S.each([\"radio\",\"checkbox\"],function(){S.valHooks[this]={set:function(e,t){if(Array.isArray(t))return e.checked=-1<S.inArray(S(e).val(),t)}},v.checkOn||(S.valHooks[this].get=function(e){return null===e.getAttribute(\"value\")?\"on\":e.value})}),v.focusin=\"onfocusin\"in C;var bt=\/^(?:focusinfocus|focusoutblur)$\/,wt=function(e){e.stopPropagation()};S.extend(S.event,{trigger:function(e,t,n,r){var i,o,a,s,u,l,c,f,p=[n||E],d=y.call(e,\"type\")?e.type:e,h=y.call(e,\"namespace\")?e.namespace.split(\".\"):[];if(o=f=a=n=n||E,3!==n.nodeType&&8!==n.nodeType&&!bt.test(d+S.event.triggered)&&(-1<d.indexOf(\".\")&&(d=(h=d.split(\".\")).shift(),h.sort()),u=d.indexOf(\":\")<0&&\"on\"+d,(e=e[S.expando]?e:new S.Event(d,\"object\"==typeof e&&e)).isTrigger=r?2:3,e.namespace=h.join(\".\"),e.rnamespace=e.namespace?new RegExp(\"(^|\\\\.)\"+h.join(\"\\\\.(?:.*\\\\.|)\")+\"(\\\\.|$)\"):null,e.result=void 0,e.target||(e.target=n),t=null==t?[e]:S.makeArray(t,[e]),c=S.event.special[d]||{},r||!c.trigger||!1!==c.trigger.apply(n,t))){if(!r&&!c.noBubble&&!x(n)){for(s=c.delegateType||d,bt.test(s+d)||(o=o.parentNode);o;o=o.parentNode)p.push(o),a=o;a===(n.ownerDocument||E)&&p.push(a.defaultView||a.parentWindow||C)}i=0;while((o=p[i++])&&!e.isPropagationStopped())f=o,e.type=1<i?s:c.bindType||d,(l=(Y.get(o,\"events\")||Object.create(null))[e.type]&&Y.get(o,\"handle\"))&&l.apply(o,t),(l=u&&o[u])&&l.apply&&V(o)&&(e.result=l.apply(o,t),!1===e.result&&e.preventDefault());return e.type=d,r||e.isDefaultPrevented()||c._default&&!1!==c._default.apply(p.pop(),t)||!V(n)||u&&m(n[d])&&!x(n)&&((a=n[u])&&(n[u]=null),S.event.triggered=d,e.isPropagationStopped()&&f.addEventListener(d,wt),n[d](),e.isPropagationStopped()&&f.removeEventListener(d,wt),S.event.triggered=void 0,a&&(n[u]=a)),e.result}},simulate:function(e,t,n){var r=S.extend(new S.Event,n,{type:e,isSimulated:!0});S.event.trigger(r,null,t)}}),S.fn.extend({trigger:function(e,t){return this.each(function(){S.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];if(n)return S.event.trigger(e,t,n,!0)}}),v.focusin||S.each({focus:\"focusin\",blur:\"focusout\"},function(n,r){var i=function(e){S.event.simulate(r,e.target,S.event.fix(e))};S.event.special[r]={setup:function(){var e=this.ownerDocument||this.document||this,t=Y.access(e,r);t||e.addEventListener(n,i,!0),Y.access(e,r,(t||0)+1)},teardown:function(){var e=this.ownerDocument||this.document||this,t=Y.access(e,r)-1;t?Y.access(e,r,t):(e.removeEventListener(n,i,!0),Y.remove(e,r))}}});var Tt=C.location,Ct={guid:Date.now()},Et=\/\\?\/;S.parseXML=function(e){var t,n;if(!e||\"string\"!=typeof e)return null;try{t=(new C.DOMParser).parseFromString(e,\"text\/xml\")}catch(e){}return n=t&&t.getElementsByTagName(\"parsererror\")[0],t&&!n||S.error(\"Invalid XML: \"+(n?S.map(n.childNodes,function(e){return e.textContent}).join(\"\\n\"):e)),t};var St=\/\\[\\]$\/,kt=\/\\r?\\n\/g,At=\/^(?:submit|button|image|reset|file)$\/i,Nt=\/^(?:input|select|textarea|keygen)\/i;function jt(n,e,r,i){var t;if(Array.isArray(e))S.each(e,function(e,t){r||St.test(n)?i(n,t):jt(n+\"[\"+(\"object\"==typeof t&&null!=t?e:\"\")+\"]\",t,r,i)});else if(r||\"object\"!==w(e))i(n,e);else for(t in e)jt(n+\"[\"+t+\"]\",e[t],r,i)}S.param=function(e,t){var n,r=[],i=function(e,t){var n=m(t)?t():t;r[r.length]=encodeURIComponent(e)+\"=\"+encodeURIComponent(null==n?\"\":n)};if(null==e)return\"\";if(Array.isArray(e)||e.jquery&&!S.isPlainObject(e))S.each(e,function(){i(this.name,this.value)});else for(n in e)jt(n,e[n],t,i);return r.join(\"&\")},S.fn.extend({serialize:function(){return S.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=S.prop(this,\"elements\");return e?S.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!S(this).is(\":disabled\")&&Nt.test(this.nodeName)&&!At.test(e)&&(this.checked||!pe.test(e))}).map(function(e,t){var n=S(this).val();return null==n?null:Array.isArray(n)?S.map(n,function(e){return{name:t.name,value:e.replace(kt,\"\\r\\n\")}}):{name:t.name,value:n.replace(kt,\"\\r\\n\")}}).get()}});var Dt=\/%20\/g,qt=\/#.*$\/,Lt=\/([?&])_=[^&]*\/,Ht=\/^(.*?):[ \\t]*([^\\r\\n]*)$\/gm,Ot=\/^(?:GET|HEAD)$\/,Pt=\/^\\\/\\\/\/,Rt={},Mt={},It=\"*\/\".concat(\"*\"),Wt=E.createElement(\"a\");function Ft(o){return function(e,t){\"string\"!=typeof e&&(t=e,e=\"*\");var n,r=0,i=e.toLowerCase().match(P)||[];if(m(t))while(n=i[r++])\"+\"===n[0]?(n=n.slice(1)||\"*\",(o[n]=o[n]||[]).unshift(t)):(o[n]=o[n]||[]).push(t)}}function $t(t,i,o,a){var s={},u=t===Mt;function l(e){var r;return s[e]=!0,S.each(t[e]||[],function(e,t){var n=t(i,o,a);return\"string\"!=typeof n||u||s[n]?u?!(r=n):void 0:(i.dataTypes.unshift(n),l(n),!1)}),r}return l(i.dataTypes[0])||!s[\"*\"]&&l(\"*\")}function Bt(e,t){var n,r,i=S.ajaxSettings.flatOptions||{};for(n in t)void 0!==t[n]&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&S.extend(!0,e,r),e}Wt.href=Tt.href,S.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Tt.href,type:\"GET\",isLocal:\/^(?:about|app|app-storage|.+-extension|file|res|widget):$\/.test(Tt.protocol),global:!0,processData:!0,async:!0,contentType:\"application\/x-www-form-urlencoded; charset=UTF-8\",accepts:{\"*\":It,text:\"text\/plain\",html:\"text\/html\",xml:\"application\/xml, text\/xml\",json:\"application\/json, text\/javascript\"},contents:{xml:\/\\bxml\\b\/,html:\/\\bhtml\/,json:\/\\bjson\\b\/},responseFields:{xml:\"responseXML\",text:\"responseText\",json:\"responseJSON\"},converters:{\"* text\":String,\"text html\":!0,\"text json\":JSON.parse,\"text xml\":S.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?Bt(Bt(e,S.ajaxSettings),t):Bt(S.ajaxSettings,e)},ajaxPrefilter:Ft(Rt),ajaxTransport:Ft(Mt),ajax:function(e,t){\"object\"==typeof e&&(t=e,e=void 0),t=t||{};var c,f,p,n,d,r,h,g,i,o,y=S.ajaxSetup({},t),v=y.context||y,m=y.context&&(v.nodeType||v.jquery)?S(v):S.event,x=S.Deferred(),b=S.Callbacks(\"once memory\"),w=y.statusCode||{},a={},s={},u=\"canceled\",T={readyState:0,getResponseHeader:function(e){var t;if(h){if(!n){n={};while(t=Ht.exec(p))n[t[1].toLowerCase()+\" \"]=(n[t[1].toLowerCase()+\" \"]||[]).concat(t[2])}t=n[e.toLowerCase()+\" \"]}return null==t?null:t.join(\", \")},getAllResponseHeaders:function(){return h?p:null},setRequestHeader:function(e,t){return null==h&&(e=s[e.toLowerCase()]=s[e.toLowerCase()]||e,a[e]=t),this},overrideMimeType:function(e){return null==h&&(y.mimeType=e),this},statusCode:function(e){var t;if(e)if(h)T.always(e[T.status]);else for(t in e)w[t]=[w[t],e[t]];return this},abort:function(e){var t=e||u;return c&&c.abort(t),l(0,t),this}};if(x.promise(T),y.url=((e||y.url||Tt.href)+\"\").replace(Pt,Tt.protocol+\"\/\/\"),y.type=t.method||t.type||y.method||y.type,y.dataTypes=(y.dataType||\"*\").toLowerCase().match(P)||[\"\"],null==y.crossDomain){r=E.createElement(\"a\");try{r.href=y.url,r.href=r.href,y.crossDomain=Wt.protocol+\"\/\/\"+Wt.host!=r.protocol+\"\/\/\"+r.host}catch(e){y.crossDomain=!0}}if(y.data&&y.processData&&\"string\"!=typeof y.data&&(y.data=S.param(y.data,y.traditional)),$t(Rt,y,t,T),h)return T;for(i in(g=S.event&&y.global)&&0==S.active++&&S.event.trigger(\"ajaxStart\"),y.type=y.type.toUpperCase(),y.hasContent=!Ot.test(y.type),f=y.url.replace(qt,\"\"),y.hasContent?y.data&&y.processData&&0===(y.contentType||\"\").indexOf(\"application\/x-www-form-urlencoded\")&&(y.data=y.data.replace(Dt,\"+\")):(o=y.url.slice(f.length),y.data&&(y.processData||\"string\"==typeof y.data)&&(f+=(Et.test(f)?\"&\":\"?\")+y.data,delete y.data),!1===y.cache&&(f=f.replace(Lt,\"$1\"),o=(Et.test(f)?\"&\":\"?\")+\"_=\"+Ct.guid+++o),y.url=f+o),y.ifModified&&(S.lastModified[f]&&T.setRequestHeader(\"If-Modified-Since\",S.lastModified[f]),S.etag[f]&&T.setRequestHeader(\"If-None-Match\",S.etag[f])),(y.data&&y.hasContent&&!1!==y.contentType||t.contentType)&&T.setRequestHeader(\"Content-Type\",y.contentType),T.setRequestHeader(\"Accept\",y.dataTypes[0]&&y.accepts[y.dataTypes[0]]?y.accepts[y.dataTypes[0]]+(\"*\"!==y.dataTypes[0]?\", \"+It+\"; q=0.01\":\"\"):y.accepts[\"*\"]),y.headers)T.setRequestHeader(i,y.headers[i]);if(y.beforeSend&&(!1===y.beforeSend.call(v,T,y)||h))return T.abort();if(u=\"abort\",b.add(y.complete),T.done(y.success),T.fail(y.error),c=$t(Mt,y,t,T)){if(T.readyState=1,g&&m.trigger(\"ajaxSend\",[T,y]),h)return T;y.async&&0<y.timeout&&(d=C.setTimeout(function(){T.abort(\"timeout\")},y.timeout));try{h=!1,c.send(a,l)}catch(e){if(h)throw e;l(-1,e)}}else l(-1,\"No Transport\");function l(e,t,n,r){var i,o,a,s,u,l=t;h||(h=!0,d&&C.clearTimeout(d),c=void 0,p=r||\"\",T.readyState=0<e?4:0,i=200<=e&&e<300||304===e,n&&(s=function(e,t,n){var r,i,o,a,s=e.contents,u=e.dataTypes;while(\"*\"===u[0])u.shift(),void 0===r&&(r=e.mimeType||t.getResponseHeader(\"Content-Type\"));if(r)for(i in s)if(s[i]&&s[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+\" \"+u[0]]){o=i;break}a||(a=i)}o=o||a}if(o)return o!==u[0]&&u.unshift(o),n[o]}(y,T,n)),!i&&-1<S.inArray(\"script\",y.dataTypes)&&S.inArray(\"json\",y.dataTypes)<0&&(y.converters[\"text script\"]=function(){}),s=function(e,t,n,r){var i,o,a,s,u,l={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)l[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if(\"*\"===o)o=u;else if(\"*\"!==u&&u!==o){if(!(a=l[u+\" \"+o]||l[\"* \"+o]))for(i in l)if((s=i.split(\" \"))[1]===o&&(a=l[u+\" \"+s[0]]||l[\"* \"+s[0]])){!0===a?a=l[i]:!0!==l[i]&&(o=s[0],c.unshift(s[1]));break}if(!0!==a)if(a&&e[\"throws\"])t=a(t);else try{t=a(t)}catch(e){return{state:\"parsererror\",error:a?e:\"No conversion from \"+u+\" to \"+o}}}return{state:\"success\",data:t}}(y,s,T,i),i?(y.ifModified&&((u=T.getResponseHeader(\"Last-Modified\"))&&(S.lastModified[f]=u),(u=T.getResponseHeader(\"etag\"))&&(S.etag[f]=u)),204===e||\"HEAD\"===y.type?l=\"nocontent\":304===e?l=\"notmodified\":(l=s.state,o=s.data,i=!(a=s.error))):(a=l,!e&&l||(l=\"error\",e<0&&(e=0))),T.status=e,T.statusText=(t||l)+\"\",i?x.resolveWith(v,[o,l,T]):x.rejectWith(v,[T,l,a]),T.statusCode(w),w=void 0,g&&m.trigger(i?\"ajaxSuccess\":\"ajaxError\",[T,y,i?o:a]),b.fireWith(v,[T,l]),g&&(m.trigger(\"ajaxComplete\",[T,y]),--S.active||S.event.trigger(\"ajaxStop\")))}return T},getJSON:function(e,t,n){return S.get(e,t,n,\"json\")},getScript:function(e,t){return S.get(e,void 0,t,\"script\")}}),S.each([\"get\",\"post\"],function(e,i){S[i]=function(e,t,n,r){return m(t)&&(r=r||n,n=t,t=void 0),S.ajax(S.extend({url:e,type:i,dataType:r,data:t,success:n},S.isPlainObject(e)&&e))}}),S.ajaxPrefilter(function(e){var t;for(t in e.headers)\"content-type\"===t.toLowerCase()&&(e.contentType=e.headers[t]||\"\")}),S._evalUrl=function(e,t,n){return S.ajax({url:e,type:\"GET\",dataType:\"script\",cache:!0,async:!1,global:!1,converters:{\"text script\":function(){}},dataFilter:function(e){S.globalEval(e,t,n)}})},S.fn.extend({wrapAll:function(e){var t;return this[0]&&(m(e)&&(e=e.call(this[0])),t=S(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstElementChild)e=e.firstElementChild;return e}).append(this)),this},wrapInner:function(n){return m(n)?this.each(function(e){S(this).wrapInner(n.call(this,e))}):this.each(function(){var e=S(this),t=e.contents();t.length?t.wrapAll(n):e.append(n)})},wrap:function(t){var n=m(t);return this.each(function(e){S(this).wrapAll(n?t.call(this,e):t)})},unwrap:function(e){return this.parent(e).not(\"body\").each(function(){S(this).replaceWith(this.childNodes)}),this}}),S.expr.pseudos.hidden=function(e){return!S.expr.pseudos.visible(e)},S.expr.pseudos.visible=function(e){return!!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)},S.ajaxSettings.xhr=function(){try{return new C.XMLHttpRequest}catch(e){}};var _t={0:200,1223:204},zt=S.ajaxSettings.xhr();v.cors=!!zt&&\"withCredentials\"in zt,v.ajax=zt=!!zt,S.ajaxTransport(function(i){var o,a;if(v.cors||zt&&!i.crossDomain)return{send:function(e,t){var n,r=i.xhr();if(r.open(i.type,i.url,i.async,i.username,i.password),i.xhrFields)for(n in i.xhrFields)r[n]=i.xhrFields[n];for(n in i.mimeType&&r.overrideMimeType&&r.overrideMimeType(i.mimeType),i.crossDomain||e[\"X-Requested-With\"]||(e[\"X-Requested-With\"]=\"XMLHttpRequest\"),e)r.setRequestHeader(n,e[n]);o=function(e){return function(){o&&(o=a=r.onload=r.onerror=r.onabort=r.ontimeout=r.onreadystatechange=null,\"abort\"===e?r.abort():\"error\"===e?\"number\"!=typeof r.status?t(0,\"error\"):t(r.status,r.statusText):t(_t[r.status]||r.status,r.statusText,\"text\"!==(r.responseType||\"text\")||\"string\"!=typeof r.responseText?{binary:r.response}:{text:r.responseText},r.getAllResponseHeaders()))}},r.onload=o(),a=r.onerror=r.ontimeout=o(\"error\"),void 0!==r.onabort?r.onabort=a:r.onreadystatechange=function(){4===r.readyState&&C.setTimeout(function(){o&&a()})},o=o(\"abort\");try{r.send(i.hasContent&&i.data||null)}catch(e){if(o)throw e}},abort:function(){o&&o()}}}),S.ajaxPrefilter(function(e){e.crossDomain&&(e.contents.script=!1)}),S.ajaxSetup({accepts:{script:\"text\/javascript, application\/javascript, application\/ecmascript, application\/x-ecmascript\"},contents:{script:\/\\b(?:java|ecma)script\\b\/},converters:{\"text script\":function(e){return S.globalEval(e),e}}}),S.ajaxPrefilter(\"script\",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type=\"GET\")}),S.ajaxTransport(\"script\",function(n){var r,i;if(n.crossDomain||n.scriptAttrs)return{send:function(e,t){r=S(\"<script>\").attr(n.scriptAttrs||{}).prop({charset:n.scriptCharset,src:n.url}).on(\"load error\",i=function(e){r.remove(),i=null,e&&t(\"error\"===e.type?404:200,e.type)}),E.head.appendChild(r[0])},abort:function(){i&&i()}}});var Ut,Xt=[],Vt=\/(=)\\?(?=&|$)|\\?\\?\/;S.ajaxSetup({jsonp:\"callback\",jsonpCallback:function(){var e=Xt.pop()||S.expando+\"_\"+Ct.guid++;return this[e]=!0,e}}),S.ajaxPrefilter(\"json jsonp\",function(e,t,n){var r,i,o,a=!1!==e.jsonp&&(Vt.test(e.url)?\"url\":\"string\"==typeof e.data&&0===(e.contentType||\"\").indexOf(\"application\/x-www-form-urlencoded\")&&Vt.test(e.data)&&\"data\");if(a||\"jsonp\"===e.dataTypes[0])return r=e.jsonpCallback=m(e.jsonpCallback)?e.jsonpCallback():e.jsonpCallback,a?e[a]=e[a].replace(Vt,\"$1\"+r):!1!==e.jsonp&&(e.url+=(Et.test(e.url)?\"&\":\"?\")+e.jsonp+\"=\"+r),e.converters[\"script json\"]=function(){return o||S.error(r+\" was not called\"),o[0]},e.dataTypes[0]=\"json\",i=C[r],C[r]=function(){o=arguments},n.always(function(){void 0===i?S(C).removeProp(r):C[r]=i,e[r]&&(e.jsonpCallback=t.jsonpCallback,Xt.push(r)),o&&m(i)&&i(o[0]),o=i=void 0}),\"script\"}),v.createHTMLDocument=((Ut=E.implementation.createHTMLDocument(\"\").body).innerHTML=\"<form><\/form><form><\/form>\",2===Ut.childNodes.length),S.parseHTML=function(e,t,n){return\"string\"!=typeof e?[]:(\"boolean\"==typeof t&&(n=t,t=!1),t||(v.createHTMLDocument?((r=(t=E.implementation.createHTMLDocument(\"\")).createElement(\"base\")).href=E.location.href,t.head.appendChild(r)):t=E),o=!n&&[],(i=N.exec(e))?[t.createElement(i[1])]:(i=xe([e],t,o),o&&o.length&&S(o).remove(),S.merge([],i.childNodes)));var r,i,o},S.fn.load=function(e,t,n){var r,i,o,a=this,s=e.indexOf(\" \");return-1<s&&(r=yt(e.slice(s)),e=e.slice(0,s)),m(t)?(n=t,t=void 0):t&&\"object\"==typeof t&&(i=\"POST\"),0<a.length&&S.ajax({url:e,type:i||\"GET\",dataType:\"html\",data:t}).done(function(e){o=arguments,a.html(r?S(\"<div>\").append(S.parseHTML(e)).find(r):e)}).always(n&&function(e,t){a.each(function(){n.apply(this,o||[e.responseText,t,e])})}),this},S.expr.pseudos.animated=function(t){return S.grep(S.timers,function(e){return t===e.elem}).length},S.offset={setOffset:function(e,t,n){var r,i,o,a,s,u,l=S.css(e,\"position\"),c=S(e),f={};\"static\"===l&&(e.style.position=\"relative\"),s=c.offset(),o=S.css(e,\"top\"),u=S.css(e,\"left\"),(\"absolute\"===l||\"fixed\"===l)&&-1<(o+u).indexOf(\"auto\")?(a=(r=c.position()).top,i=r.left):(a=parseFloat(o)||0,i=parseFloat(u)||0),m(t)&&(t=t.call(e,n,S.extend({},s))),null!=t.top&&(f.top=t.top-s.top+a),null!=t.left&&(f.left=t.left-s.left+i),\"using\"in t?t.using.call(e,f):c.css(f)}},S.fn.extend({offset:function(t){if(arguments.length)return void 0===t?this:this.each(function(e){S.offset.setOffset(this,t,e)});var e,n,r=this[0];return r?r.getClientRects().length?(e=r.getBoundingClientRect(),n=r.ownerDocument.defaultView,{top:e.top+n.pageYOffset,left:e.left+n.pageXOffset}):{top:0,left:0}:void 0},position:function(){if(this[0]){var e,t,n,r=this[0],i={top:0,left:0};if(\"fixed\"===S.css(r,\"position\"))t=r.getBoundingClientRect();else{t=this.offset(),n=r.ownerDocument,e=r.offsetParent||n.documentElement;while(e&&(e===n.body||e===n.documentElement)&&\"static\"===S.css(e,\"position\"))e=e.parentNode;e&&e!==r&&1===e.nodeType&&((i=S(e).offset()).top+=S.css(e,\"borderTopWidth\",!0),i.left+=S.css(e,\"borderLeftWidth\",!0))}return{top:t.top-i.top-S.css(r,\"marginTop\",!0),left:t.left-i.left-S.css(r,\"marginLeft\",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent;while(e&&\"static\"===S.css(e,\"position\"))e=e.offsetParent;return e||re})}}),S.each({scrollLeft:\"pageXOffset\",scrollTop:\"pageYOffset\"},function(t,i){var o=\"pageYOffset\"===i;S.fn[t]=function(e){return B(this,function(e,t,n){var r;if(x(e)?r=e:9===e.nodeType&&(r=e.defaultView),void 0===n)return r?r[i]:e[t];r?r.scrollTo(o?r.pageXOffset:n,o?n:r.pageYOffset):e[t]=n},t,e,arguments.length)}}),S.each([\"top\",\"left\"],function(e,n){S.cssHooks[n]=_e(v.pixelPosition,function(e,t){if(t)return t=Be(e,n),Pe.test(t)?S(e).position()[n]+\"px\":t})}),S.each({Height:\"height\",Width:\"width\"},function(a,s){S.each({padding:\"inner\"+a,content:s,\"\":\"outer\"+a},function(r,o){S.fn[o]=function(e,t){var n=arguments.length&&(r||\"boolean\"!=typeof e),i=r||(!0===e||!0===t?\"margin\":\"border\");return B(this,function(e,t,n){var r;return x(e)?0===o.indexOf(\"outer\")?e[\"inner\"+a]:e.document.documentElement[\"client\"+a]:9===e.nodeType?(r=e.documentElement,Math.max(e.body[\"scroll\"+a],r[\"scroll\"+a],e.body[\"offset\"+a],r[\"offset\"+a],r[\"client\"+a])):void 0===n?S.css(e,t,i):S.style(e,t,n,i)},s,n?e:void 0,n)}})}),S.each([\"ajaxStart\",\"ajaxStop\",\"ajaxComplete\",\"ajaxError\",\"ajaxSuccess\",\"ajaxSend\"],function(e,t){S.fn[t]=function(e){return this.on(t,e)}}),S.fn.extend({bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,\"**\"):this.off(t,e||\"**\",n)},hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)}}),S.each(\"blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu\".split(\" \"),function(e,n){S.fn[n]=function(e,t){return 0<arguments.length?this.on(n,null,e,t):this.trigger(n)}});var Gt=\/^[\\s\\uFEFF\\xA0]+|([^\\s\\uFEFF\\xA0])[\\s\\uFEFF\\xA0]+$\/g;S.proxy=function(e,t){var n,r,i;if(\"string\"==typeof t&&(n=e[t],t=e,e=n),m(e))return r=s.call(arguments,2),(i=function(){return e.apply(t||this,r.concat(s.call(arguments)))}).guid=e.guid=e.guid||S.guid++,i},S.holdReady=function(e){e?S.readyWait++:S.ready(!0)},S.isArray=Array.isArray,S.parseJSON=JSON.parse,S.nodeName=A,S.isFunction=m,S.isWindow=x,S.camelCase=X,S.type=w,S.now=Date.now,S.isNumeric=function(e){var t=S.type(e);return(\"number\"===t||\"string\"===t)&&!isNaN(e-parseFloat(e))},S.trim=function(e){return null==e?\"\":(e+\"\").replace(Gt,\"$1\")},\"function\"==typeof define&&define.amd&&define(\"jquery\",[],function(){return S});var Yt=C.jQuery,Qt=C.$;return S.noConflict=function(e){return C.$===S&&(C.$=Qt),e&&C.jQuery===S&&(C.jQuery=Yt),S},\"undefined\"==typeof e&&(C.jQuery=C.$=S),S});\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/script-dir\/jquery-3.6.1.min.js","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -232,1 +232,1 @@\n-                throw new BadSnippetException(a, \"doclet.exception.read.file\", v, e.getCause());\n+                throw new BadSnippetException(a, \"doclet.exception.read.file\", v, e);\n@@ -244,1 +244,1 @@\n-                        fileObject.getName(), e.getCause());\n+                        fileObject.getName(), e);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SnippetTaglet.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-    public static final DocPath JQUERY_JS = DocPath.create(\"jquery-3.6.0.min.js\");\n+    public static final DocPath JQUERY_JS = DocPath.create(\"jquery-3.6.1.min.js\");\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/DocPaths.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-## jQuery v3.6.0\n+## jQuery v3.6.1\n@@ -5,1 +5,1 @@\n-jQuery v 3.6.0\n+jQuery v 3.6.1\n@@ -29,1 +29,1 @@\n-The jQuery JavaScript Library v3.6.0 also includes Sizzle.js\n+The jQuery JavaScript Library v3.6.1 also includes Sizzle.js\n","filename":"src\/jdk.javadoc\/share\/legal\/jquery.md","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -117,1 +117,1 @@\n-     * If static, the field must not be final.\n+     * The field must not be final.\n@@ -132,1 +132,1 @@\n-     * this object's class.\n+     * this object's class or the field is final.\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/jdi\/ObjectReference.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -195,0 +195,9 @@\n+     * <p>\n+     * The following example shows how to listen to new event types, register\n+     * an action if the event type name matches a regular expression and increase a\n+     * counter if a matching event is found. A benefit of using an action per\n+     * event type, instead of the generic {@link #onEvent(Consumer)} method,\n+     * is that a stream implementation can avoid reading events that are of no\n+     * interest.\n+     *\n+     * {@snippet class = \"Snippets\" region = \"EventStreamMetadata\"}\n@@ -202,0 +211,1 @@\n+     * @since 16\n@@ -208,0 +218,5 @@\n+     * <p>\n+     * To perform an action on a subset of event types, consider using\n+     * {@link #onEvent(String, Consumer)} and {@link #onMetadata(Consumer)} as it is\n+     * likely more performant than any selection or filtering mechanism implemented\n+     * in a generic action.\n@@ -211,0 +226,3 @@\n+     *\n+     * @see #onEvent(Consumer)\n+     * @see #onMetadata(Consumer)\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/EventStream.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -397,1 +397,1 @@\n-     * <p>\n+     *\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordingStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.regex.Pattern;\n@@ -39,0 +40,1 @@\n+import jdk.jfr.EventType;\n@@ -43,1 +45,1 @@\n-    class PackageOveriview {\n+    class PackageOverview {\n@@ -91,0 +93,19 @@\n+    class EventStreamMetadata {\n+        \/\/ @start region=\"EventStreamMetadata\"\n+        static long count = 0;\n+        public static void main(String... args) throws IOException {\n+            Path file = Path.of(args[0]);\n+            String regExp = args[1];\n+            var pr = Pattern.compile(regExp).asMatchPredicate();\n+            try (var s = EventStream.openFile(file)) {\n+                s.setOrdered(false);\n+                s.onMetadata(metadata -> metadata.getAddedEventTypes()\n+                 .stream().map(EventType::getName).filter(pr)\n+                 .forEach(eventName -> s.onEvent(eventName, event -> count++)));\n+                s.start();\n+                System.out.println(count + \" events matches \" + regExp);\n+            }\n+        }\n+        \/\/ @end\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/snippet-files\/Snippets.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -481,0 +481,4 @@\n+                \/\/ long startTime = this.startTime\n+                methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);\n+                methodVisitor.visitFieldInsn(Opcodes.GETFIELD, getInternalClassName(), FIELD_START_TIME, \"J\");\n+                methodVisitor.visitVarInsn(Opcodes.LSTORE, 1);\n@@ -484,2 +488,1 @@\n-                methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);\n-                methodVisitor.visitFieldInsn(Opcodes.GETFIELD, getInternalClassName(), FIELD_START_TIME, \"J\");\n+                methodVisitor.visitVarInsn(Opcodes.LLOAD, 1);\n@@ -490,1 +493,0 @@\n-                methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);\n@@ -492,1 +494,1 @@\n-                methodVisitor.visitFieldInsn(Opcodes.PUTFIELD, getInternalClassName(), FIELD_START_TIME, \"J\");\n+                methodVisitor.visitVarInsn(Opcodes.LSTORE, 1);\n@@ -508,2 +510,1 @@\n-                methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);\n-                methodVisitor.visitFieldInsn(Opcodes.GETFIELD, getInternalClassName(), FIELD_START_TIME, \"J\");\n+                methodVisitor.visitVarInsn(Opcodes.LLOAD, 1);\n@@ -534,3 +535,1 @@\n-                methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);\n-                \/\/ stack: [EW] [EW] [this]\n-                methodVisitor.visitFieldInsn(Opcodes.GETFIELD, getInternalClassName(), FIELD_START_TIME, \"J\");\n+                methodVisitor.visitVarInsn(Opcodes.LLOAD, 1);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventInstrumentation.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-     * @param when when it is being done {@link Periodic.When}\n+     * @param periodicType when it is being done {@link PeriodicType.When}\n@@ -125,1 +125,1 @@\n-    public native boolean emitEvent(long eventTypeId, long timestamp, long when);\n+    public native boolean emitEvent(long eventTypeId, long timestamp, long periodicType);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVM.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,3 @@\n+    enum PeriodicType {\n+        BEGIN_CHUNK, INTERVAL, END_CHUNK\n+    }\n@@ -65,1 +68,1 @@\n-        private void execute() {\n+        private void execute(long timestamp, PeriodicType periodicType) {\n@@ -71,1 +74,1 @@\n-                        emitJVMEvent(type);\n+                        emitJVMEvent(type, timestamp, periodicType);\n@@ -85,1 +88,1 @@\n-        private void emitJVMEvent(PlatformEventType type) {\n+        private void emitJVMEvent(PlatformEventType type, long timestamp, PeriodicType periodicType) {\n@@ -91,1 +94,1 @@\n-                jvm.emitEvent(type.getId(), JVM.counterTime(), 0);\n+                jvm.emitEvent(type.getId(), timestamp, periodicType.ordinal());\n@@ -186,1 +189,1 @@\n-        doChunk(x -> x.isEndChunk());\n+        doChunk(x -> x.isEndChunk(), PeriodicType.END_CHUNK);\n@@ -190,1 +193,1 @@\n-        doChunk(x -> x.isBeginChunk());\n+        doChunk(x -> x.isBeginChunk(), PeriodicType.BEGIN_CHUNK);\n@@ -193,1 +196,2 @@\n-    private static void doChunk(Predicate<PlatformEventType> predicate) {\n+    private static void doChunk(Predicate<PlatformEventType> predicate, PeriodicType type) {\n+        long timestamp = JVM.counterTime();\n@@ -197,1 +201,1 @@\n-                requestHook.execute();\n+                requestHook.execute(timestamp, type);\n@@ -203,1 +207,1 @@\n-        return run_requests(entries);\n+        return run_requests(entries, JVM.counterTime());\n@@ -207,1 +211,1 @@\n-    private static long run_requests(Collection<RequestHook> entries) {\n+    private static long run_requests(Collection<RequestHook> entries, long eventTimestamp) {\n@@ -209,6 +213,3 @@\n-        \/\/ Bug 9000556 - current time millis has rather lame resolution\n-        \/\/ The use of os::elapsed_counter() is deliberate here, we don't\n-        \/\/ want it exchanged for os::ft_elapsed_counter().\n-        \/\/ Keeping direct call os::elapsed_counter() here for reliable\n-        \/\/ real time values in order to decide when registered requestable\n-        \/\/ events are due.\n+        \/\/ The interval for periodic events is typically at least 1 s, so\n+        \/\/ System.currentTimeMillis() is sufficient. JVM.counterTime() lacks\n+        \/\/ unit and has in the past been more unreliable.\n@@ -252,1 +253,1 @@\n-                he.execute();\n+                he.execute(eventTimestamp, PeriodicType.INTERVAL);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/RequestEngine.java","additions":19,"deletions":18,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -231,1 +231,1 @@\n-            int size = input.readInt();\n+            long size = input.readLong();\n@@ -246,1 +246,1 @@\n-                            input.readInt(); \/\/ size\n+                            input.readLong(); \/\/ size\n@@ -313,1 +313,1 @@\n-            int size = input.readInt(); \/\/ size\n+            long size = input.readLong(); \/\/ size\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/ChunkParser.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -169,1 +169,0 @@\n-                    barrier.check(); \/\/ block if recording is being stopped\n@@ -172,4 +171,0 @@\n-                    long endMillis = Instant.ofEpochSecond(0, endNanos).toEpochMilli();\n-                    if (barrier.getStreamEnd() <= endMillis) {\n-                        return;\n-                    }\n@@ -180,1 +175,9 @@\n-                if (isLastChunk()) {\n+                long endNanos = currentParser.getStartNanos() + currentParser.getChunkDuration();\n+                long endMillis = Instant.ofEpochSecond(0, endNanos).toEpochMilli();\n+\n+                barrier.check(); \/\/ block if recording is being stopped\n+                if (barrier.getStreamEnd() <= endMillis) {\n+                    return;\n+                }\n+\n+                if (!barrier.hasStreamEnd() && isLastChunk()) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventDirectoryStream.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -65,0 +65,4 @@\n+    public synchronized boolean hasStreamEnd() {\n+        return end != Long.MAX_VALUE;\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/StreamBarrier.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -515,0 +515,10 @@\n+    <event name=\"jdk.NativeMemoryUsage\">\n+      <setting name=\"enabled\" control=\"gc-enabled-normal\">true<\/setting>\n+      <setting name=\"period\">1000 ms<\/setting>\n+    <\/event>\n+\n+    <event name=\"jdk.NativeMemoryUsageTotal\">\n+      <setting name=\"enabled\" control=\"gc-enabled-normal\">true<\/setting>\n+      <setting name=\"period\">1000 ms<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -515,0 +515,10 @@\n+    <event name=\"jdk.NativeMemoryUsage\">\n+      <setting name=\"enabled\" control=\"gc-enabled-normal\">true<\/setting>\n+      <setting name=\"period\">1000 ms<\/setting>\n+    <\/event>\n+\n+    <event name=\"jdk.NativeMemoryUsageTotal\">\n+      <setting name=\"enabled\" control=\"gc-enabled-normal\">true<\/setting>\n+      <setting name=\"period\">1000 ms<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-                iconSwap(resourceLock, icon.toString());\n+                iconSwapWrapper(resourceLock, icon.toString());\n@@ -211,4 +211,2 @@\n-        if (versionSwap(resourceLock, propList.toArray(String[]::new)) != 0) {\n-            throw new RuntimeException(MessageFormat.format(\n-                    I18N.getString(\"error.version-swap\"), target));\n-        }\n+        versionSwapWrapper(resourceLock, propList.toArray(String[]::new),\n+                target.toString());\n@@ -231,0 +229,16 @@\n+    private static void iconSwapWrapper(long resourceLock,\n+            String iconTarget) {\n+        if (iconSwap(resourceLock, iconTarget) != 0) {\n+            throw new RuntimeException(MessageFormat.format(I18N.getString(\n+                    \"error.icon-swap\"), iconTarget));\n+        }\n+    }\n+\n+    private static void versionSwapWrapper(long resourceLock,\n+            String[] executableProperties, String target) {\n+        if (versionSwap(resourceLock, executableProperties) != 0) {\n+            throw new RuntimeException(MessageFormat.format(I18N.getString(\n+                    \"error.version-swap\"), target));\n+        }\n+    }\n+\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/ExecutableRebrander.java","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+error.icon-swap=Failed to update icon for {0}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/WinResources.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+error.icon-swap=Failed to update icon for {0}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/WinResources_de.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+error.icon-swap=Failed to update icon for {0}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/WinResources_ja.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+error.icon-swap=Failed to update icon for {0}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/WinResources_zh_CN.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -431,0 +431,1 @@\n+            {\"America\/Ciudad_Juarez\", MST},\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/TimeZoneNames_de.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -431,0 +431,1 @@\n+            {\"America\/Ciudad_Juarez\", MST},\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/TimeZoneNames_es.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -431,0 +431,1 @@\n+            {\"America\/Ciudad_Juarez\", MST},\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/TimeZoneNames_fr.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -431,0 +431,1 @@\n+            {\"America\/Ciudad_Juarez\", MST},\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/TimeZoneNames_it.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -431,0 +431,1 @@\n+            {\"America\/Ciudad_Juarez\", MST},\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/TimeZoneNames_ja.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -431,0 +431,1 @@\n+            {\"America\/Ciudad_Juarez\", MST},\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/TimeZoneNames_ko.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -431,0 +431,1 @@\n+            {\"America\/Ciudad_Juarez\", MST},\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/TimeZoneNames_pt_BR.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -431,0 +431,1 @@\n+            {\"America\/Ciudad_Juarez\", MST},\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/TimeZoneNames_sv.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -431,0 +431,1 @@\n+            {\"America\/Ciudad_Juarez\", MST},\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/TimeZoneNames_zh_CN.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -431,0 +431,1 @@\n+            {\"America\/Ciudad_Juarez\", MST},\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/TimeZoneNames_zh_TW.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-     * Try to receieve another message or notification.\n+     * Try to receive another message or notification.\n","filename":"src\/jdk.sctp\/share\/classes\/com\/sun\/nio\/sctp\/HandlerResult.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.io.Serial;\n+\n@@ -35,0 +37,1 @@\n+    @Serial\n","filename":"src\/jdk.sctp\/share\/classes\/com\/sun\/nio\/sctp\/IllegalReceiveException.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.io.Serial;\n+\n@@ -35,0 +37,1 @@\n+    @Serial\n","filename":"src\/jdk.sctp\/share\/classes\/com\/sun\/nio\/sctp\/IllegalUnbindException.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.io.Serial;\n+\n@@ -34,0 +36,1 @@\n+    @Serial\n","filename":"src\/jdk.sctp\/share\/classes\/com\/sun\/nio\/sctp\/InvalidStreamException.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-public class SctpStandardSocketOptions {\n+public final class SctpStandardSocketOptions {\n@@ -44,1 +44,1 @@\n-     * fragmentation will be performed. Instead if a message being sent\n+     * fragmentation will be performed. Instead, if a message being sent\n@@ -51,3 +51,4 @@\n-    public static final SctpSocketOption<Boolean> SCTP_DISABLE_FRAGMENTS = new\n-        SctpStdSocketOption<Boolean>(\"SCTP_DISABLE_FRAGMENTS\", Boolean.class,\n-        sun.nio.ch.sctp.SctpStdSocketOption.SCTP_DISABLE_FRAGMENTS);\n+    public static final SctpSocketOption<Boolean> SCTP_DISABLE_FRAGMENTS =\n+            new SctpStdSocketOption<>(\"SCTP_DISABLE_FRAGMENTS\",\n+                    Boolean.class,\n+                    SctpStdSocketOption.SCTP_DISABLE_FRAGMENTS);\n@@ -70,3 +71,4 @@\n-    public static final SctpSocketOption<Boolean> SCTP_EXPLICIT_COMPLETE = new\n-        SctpStdSocketOption<Boolean>(\"SCTP_EXPLICIT_COMPLETE\", Boolean.class,\n-        sun.nio.ch.sctp.SctpStdSocketOption.SCTP_EXPLICIT_COMPLETE);\n+    public static final SctpSocketOption<Boolean> SCTP_EXPLICIT_COMPLETE =\n+            new SctpStdSocketOption<>(\"SCTP_EXPLICIT_COMPLETE\",\n+                    Boolean.class,\n+                    SctpStdSocketOption.SCTP_EXPLICIT_COMPLETE);\n@@ -121,1 +123,1 @@\n-            new SctpStdSocketOption<Integer>(\"SCTP_FRAGMENT_INTERLEAVE\",\n+            new SctpStdSocketOption<>(\"SCTP_FRAGMENT_INTERLEAVE\",\n@@ -123,1 +125,1 @@\n-                  sun.nio.ch.sctp.SctpStdSocketOption.SCTP_FRAGMENT_INTERLEAVE);\n+                  SctpStdSocketOption.SCTP_FRAGMENT_INTERLEAVE);\n@@ -161,2 +163,2 @@\n-        new SctpStdSocketOption<SctpStandardSocketOptions.InitMaxStreams>(\n-        \"SCTP_INIT_MAXSTREAMS\", SctpStandardSocketOptions.InitMaxStreams.class);\n+            new SctpStdSocketOption<>(\"SCTP_INIT_MAXSTREAMS\",\n+                    SctpStandardSocketOptions.InitMaxStreams.class);\n@@ -173,2 +175,3 @@\n-        new SctpStdSocketOption<Boolean>(\"SCTP_NODELAY\", Boolean.class,\n-        sun.nio.ch.sctp.SctpStdSocketOption.SCTP_NODELAY);\n+            new SctpStdSocketOption<>(\"SCTP_NODELAY\",\n+                    Boolean.class,\n+                    SctpStdSocketOption.SCTP_NODELAY);\n@@ -194,2 +197,2 @@\n-            new SctpStdSocketOption<SocketAddress>\n-            (\"SCTP_PRIMARY_ADDR\", SocketAddress.class);\n+            new SctpStdSocketOption<>(\"SCTP_PRIMARY_ADDR\",\n+                    SocketAddress.class);\n@@ -219,2 +222,2 @@\n-            new SctpStdSocketOption<SocketAddress>\n-            (\"SCTP_SET_PEER_PRIMARY_ADDR\", SocketAddress.class);\n+            new SctpStdSocketOption<>(\"SCTP_SET_PEER_PRIMARY_ADDR\",\n+                    SocketAddress.class);\n@@ -248,2 +251,3 @@\n-        new SctpStdSocketOption<Integer>(\"SO_SNDBUF\", Integer.class,\n-        sun.nio.ch.sctp.SctpStdSocketOption.SO_SNDBUF);\n+            new SctpStdSocketOption<>(\"SO_SNDBUF\",\n+                    Integer.class,\n+                    SctpStdSocketOption.SO_SNDBUF);\n@@ -275,2 +279,3 @@\n-        new SctpStdSocketOption<Integer>(\"SO_RCVBUF\", Integer.class,\n-        sun.nio.ch.sctp.SctpStdSocketOption.SO_RCVBUF);\n+            new SctpStdSocketOption<>(\"SO_RCVBUF\",\n+                    Integer.class,\n+                    SctpStdSocketOption.SO_RCVBUF);\n@@ -306,2 +311,3 @@\n-        new SctpStdSocketOption<Integer>(\"SO_LINGER\", Integer.class,\n-        sun.nio.ch.sctp.SctpStdSocketOption.SO_LINGER);\n+            new SctpStdSocketOption<>(\"SO_LINGER\",\n+                    Integer.class,\n+                    SctpStdSocketOption.SO_LINGER);\n@@ -319,2 +325,2 @@\n-        private int maxInStreams;\n-        private int maxOutStreams;\n+        private final int maxInStreams;\n+        private final int maxOutStreams;\n@@ -381,5 +387,3 @@\n-            StringBuilder sb = new StringBuilder();\n-            sb.append(super.toString()).append(\" [\");\n-            sb.append(\"maxInStreams:\").append(maxInStreams);\n-            sb.append(\"maxOutStreams:\").append(maxOutStreams).append(\"]\");\n-            return sb.toString();\n+            return super.toString() + \" [\" +\n+                    \"maxInStreams:\" + maxInStreams +\n+                    \"maxOutStreams:\" + maxOutStreams + \"]\";\n@@ -401,5 +405,3 @@\n-            if (obj != null && obj instanceof InitMaxStreams) {\n-                InitMaxStreams that = (InitMaxStreams) obj;\n-                if (this.maxInStreams == that.maxInStreams &&\n-                    this.maxOutStreams == that.maxOutStreams)\n-                    return true;\n+            if (obj instanceof InitMaxStreams that) {\n+                return this.maxInStreams == that.maxInStreams &&\n+                        this.maxOutStreams == that.maxOutStreams;\n","filename":"src\/jdk.sctp\/share\/classes\/com\/sun\/nio\/sctp\/SctpStandardSocketOptions.java","additions":38,"deletions":36,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * Typically this is because the association has been shutdown with unsent data\n+ * Typically, this is because the association has been shutdown with unsent data\n@@ -84,1 +84,1 @@\n-     * Returns the stream number that the messge was to be sent on.\n+     * Returns the stream number that the message was to be sent on.\n","filename":"src\/jdk.sctp\/share\/classes\/com\/sun\/nio\/sctp\/SendFailedNotification.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -159,10 +159,8 @@\n-        StringBuilder sb = new StringBuilder(super.toString());\n-        sb.append( \"[Address: \").append(address)\n-          .append(\", Association: \").append(association)\n-          .append(\", Assoc ID: \").append(assocId)\n-          .append(\", Bytes: \").append(bytes)\n-          .append(\", Stream Number: \").append(streamNumber)\n-          .append(\", Complete: \").append(complete)\n-          .append(\", isUnordered: \").append(unordered)\n-          .append(\"]\");\n-        return sb.toString();\n+        return super.toString() + \"[Address: \" + address +\n+                \", Association: \" + association +\n+                \", Assoc ID: \" + assocId +\n+                \", Bytes: \" + bytes +\n+                \", Stream Number: \" + streamNumber +\n+                \", Complete: \" + complete +\n+                \", isUnordered: \" + unordered +\n+                \"]\";\n","filename":"src\/jdk.sctp\/share\/classes\/sun\/nio\/ch\/sctp\/MessageInfoImpl.java","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-public class SctpStdSocketOption<T>\n+public final class SctpStdSocketOption<T>\n@@ -46,1 +46,1 @@\n-    private int constValue;\n+    private final int constValue;\n@@ -49,2 +49,1 @@\n-        this.name = name;\n-        this.type = type;\n+        this(name, type, 0);\n","filename":"src\/jdk.sctp\/share\/classes\/sun\/nio\/ch\/sctp\/SctpStdSocketOption.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    \/* assocId is used to lookup the association before the notification is\n+    \/* assocId is used to look up the association before the notification is\n@@ -48,4 +48,4 @@\n-    private int assocId;\n-    private AssocChangeEvent event;\n-    private int maxOutStreams;\n-    private int maxInStreams;\n+    private final int assocId;\n+    private final AssocChangeEvent event;\n+    private final int maxOutStreams;\n+    private final int maxInStreams;\n@@ -58,20 +58,9 @@\n-        switch (intEvent) {\n-            case SCTP_COMM_UP :\n-                this.event = AssocChangeEvent.COMM_UP;\n-                break;\n-            case SCTP_COMM_LOST :\n-                this.event = AssocChangeEvent.COMM_LOST;\n-                break;\n-            case SCTP_RESTART :\n-                this.event = AssocChangeEvent.RESTART;\n-                break;\n-            case SCTP_SHUTDOWN :\n-                this.event = AssocChangeEvent.SHUTDOWN;\n-                break;\n-            case SCTP_CANT_START :\n-                this.event = AssocChangeEvent.CANT_START;\n-                break;\n-            default :\n-                throw new AssertionError(\n-                      \"Unknown Association Change Event type: \" + intEvent);\n-        }\n+        this.event = switch (intEvent) {\n+            case SCTP_COMM_UP    -> AssocChangeEvent.COMM_UP;\n+            case SCTP_COMM_LOST  -> AssocChangeEvent.COMM_LOST;\n+            case SCTP_RESTART    -> AssocChangeEvent.RESTART;\n+            case SCTP_SHUTDOWN   -> AssocChangeEvent.SHUTDOWN;\n+            case SCTP_CANT_START -> AssocChangeEvent.CANT_START;\n+            default -> throw new AssertionError(\n+                    \"Unknown Association Change Event type: \" + intEvent);\n+        };\n@@ -115,5 +104,3 @@\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(super.toString()).append(\" [\");\n-        sb.append(\"Association:\").append(association);\n-        sb.append(\", Event: \").append(event).append(\"]\");\n-        return sb.toString();\n+        return super.toString() + \" [\" +\n+                \"Association:\" + association +\n+                \", Event: \" + event + \"]\";\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/AssociationChange.java","additions":17,"deletions":30,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -41,9 +41,7 @@\n-        StringBuffer sb = new StringBuffer(super.toString());\n-        return sb.append(\"[associationID:\")\n-                 .append(associationID())\n-                 .append(\", maxIn:\")\n-                 .append(maxInboundStreams())\n-                 .append(\", maxOut:\")\n-                 .append(maxOutboundStreams())\n-                 .append(\"]\")\n-                 .toString();\n+        return super.toString() + \"[associationID:\" +\n+                associationID() +\n+                \", maxIn:\" +\n+                maxInboundStreams() +\n+                \", maxOut:\" +\n+                maxOutboundStreams() +\n+                \"]\";\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/AssociationImpl.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-    \/* assocId is used to lookup the association before the notification is\n+    \/* assocId is used to look up the association before the notification is\n@@ -50,3 +50,3 @@\n-    private int assocId;\n-    private SocketAddress address;\n-    private AddressChangeEvent event;\n+    private final int assocId;\n+    private final SocketAddress address;\n+    private final AddressChangeEvent event;\n@@ -56,22 +56,9 @@\n-        switch (intEvent) {\n-            case SCTP_ADDR_AVAILABLE :\n-                this.event = AddressChangeEvent.ADDR_AVAILABLE;\n-                break;\n-            case SCTP_ADDR_UNREACHABLE :\n-                this.event = AddressChangeEvent.ADDR_UNREACHABLE;\n-                break;\n-            case SCTP_ADDR_REMOVED :\n-                this.event = AddressChangeEvent.ADDR_REMOVED;\n-                break;\n-            case SCTP_ADDR_ADDED :\n-                this.event = AddressChangeEvent.ADDR_ADDED;\n-                break;\n-            case SCTP_ADDR_MADE_PRIM :\n-                this.event = AddressChangeEvent.ADDR_MADE_PRIMARY;\n-                break;\n-            case SCTP_ADDR_CONFIRMED :\n-                this.event = AddressChangeEvent.ADDR_CONFIRMED;\n-                break;\n-            default:\n-                throw new AssertionError(\"Unknown event type\");\n-        }\n+        this.event = switch (intEvent) {\n+            case SCTP_ADDR_AVAILABLE   -> AddressChangeEvent.ADDR_AVAILABLE;\n+            case SCTP_ADDR_UNREACHABLE -> AddressChangeEvent.ADDR_UNREACHABLE;\n+            case SCTP_ADDR_REMOVED     -> AddressChangeEvent.ADDR_REMOVED;\n+            case SCTP_ADDR_ADDED       -> AddressChangeEvent.ADDR_ADDED;\n+            case SCTP_ADDR_MADE_PRIM   -> AddressChangeEvent.ADDR_MADE_PRIMARY;\n+            case SCTP_ADDR_CONFIRMED   -> AddressChangeEvent.ADDR_CONFIRMED;\n+            default -> throw new AssertionError(\"Unknown event type\");\n+        };\n@@ -106,1 +93,0 @@\n-        assert event != null;\n@@ -112,6 +98,4 @@\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(super.toString()).append(\" [\");\n-        sb.append(\"Address: \").append(address);\n-        sb.append(\", Association:\").append(association);\n-        sb.append(\", Event: \").append(event).append(\"]\");\n-        return sb.toString();\n+        return super.toString() + \" [\" +\n+                \"Address: \" + address +\n+                \", Association:\" + association +\n+                \", Event: \" + event + \"]\";\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/PeerAddrChange.java","additions":17,"deletions":33,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-        return type() != MESSAGE && type() != NOTHING ? true : false;\n+        return type() != MESSAGE && type() != NOTHING;\n@@ -71,2 +71,2 @@\n-        if (value instanceof MessageInfoImpl)\n-            return (MessageInfoImpl) value;\n+        if (value instanceof MessageInfoImpl messageInfo)\n+            return messageInfo;\n@@ -80,2 +80,2 @@\n-        if (value instanceof SendFailed)\n-            return (SendFailed) value;\n+        if (value instanceof SendFailed sendFailed)\n+            return sendFailed;\n@@ -89,2 +89,2 @@\n-        if (value instanceof AssociationChange)\n-            return (AssociationChange) value;\n+        if (value instanceof AssociationChange associationChanged)\n+            return associationChanged;\n@@ -98,2 +98,2 @@\n-        if (value instanceof PeerAddrChange)\n-            return (PeerAddrChange) value;\n+        if (value instanceof PeerAddrChange peerAddressChanged)\n+            return peerAddressChanged;\n@@ -107,2 +107,2 @@\n-        if (value instanceof Shutdown)\n-            return (Shutdown) value;\n+        if (value instanceof Shutdown shutdown)\n+            return shutdown;\n@@ -118,7 +118,7 @@\n-            case NOTHING:              sb.append(\"NOTHING\");             break;\n-            case MESSAGE:              sb.append(\"MESSAGE\");             break;\n-            case SEND_FAILED:          sb.append(\"SEND FAILED\");         break;\n-            case ASSOCIATION_CHANGED:  sb.append(\"ASSOCIATION CHANGE\");  break;\n-            case PEER_ADDRESS_CHANGED: sb.append(\"PEER ADDRESS CHANGE\"); break;\n-            case SHUTDOWN:             sb.append(\"SHUTDOWN\");            break;\n-            default :                  sb.append(\"Unknown result type\");\n+            case NOTHING              -> sb.append(\"NOTHING\");\n+            case MESSAGE              -> sb.append(\"MESSAGE\");\n+            case SEND_FAILED          -> sb.append(\"SEND FAILED\");\n+            case ASSOCIATION_CHANGED  -> sb.append(\"ASSOCIATION CHANGE\");\n+            case PEER_ADDRESS_CHANGED -> sb.append(\"PEER ADDRESS CHANGE\");\n+            case SHUTDOWN             -> sb.append(\"SHUTDOWN\");\n+            default                   -> sb.append(\"Unknown result type\");\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/ResultContainer.java","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n@@ -56,0 +58,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -77,0 +81,3 @@\n+\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -81,3 +88,3 @@\n-    \/* IDs of native threads doing send and receivess, for signalling *\/\n-    private volatile long receiverThread = 0;\n-    private volatile long senderThread = 0;\n+    \/* IDs of native threads doing send and receive, for signalling *\/\n+    private volatile long receiverThread;\n+    private volatile long senderThread;\n@@ -92,1 +99,1 @@\n-        new ThreadLocal<Boolean>() {\n+        new ThreadLocal<>() {\n@@ -111,1 +118,1 @@\n-    private ChannelState state = ChannelState.UNINITIALIZED;\n+    private ChannelState state;\n@@ -115,1 +122,1 @@\n-    private HashSet<InetSocketAddress> localAddresses = new HashSet<InetSocketAddress>();\n+    private final Set<InetSocketAddress> localAddresses = new HashSet<>();\n@@ -223,1 +230,1 @@\n-    private SctpChannel bindUnbindAddress(InetAddress address, boolean add)\n+    private void bindUnbindAddress(InetAddress address, boolean add)\n@@ -279,1 +286,0 @@\n-        return this;\n@@ -284,1 +290,1 @@\n-            return port == -1 ? false : true;\n+            return port != -1;\n@@ -694,19 +700,0 @@\n-    private static class DefaultOptionsHolder {\n-        static final Set<SctpSocketOption<?>> defaultOptions = defaultOptions();\n-\n-        private static Set<SctpSocketOption<?>> defaultOptions() {\n-            HashSet<SctpSocketOption<?>> set = new HashSet<SctpSocketOption<?>>(10);\n-            set.add(SCTP_DISABLE_FRAGMENTS);\n-            set.add(SCTP_EXPLICIT_COMPLETE);\n-            set.add(SCTP_FRAGMENT_INTERLEAVE);\n-            set.add(SCTP_INIT_MAXSTREAMS);\n-            set.add(SCTP_NODELAY);\n-            set.add(SCTP_PRIMARY_ADDR);\n-            set.add(SCTP_SET_PEER_PRIMARY_ADDR);\n-            set.add(SO_SNDBUF);\n-            set.add(SO_RCVBUF);\n-            set.add(SO_LINGER);\n-            return Collections.unmodifiableSet(set);\n-        }\n-    }\n-\n@@ -715,1 +702,14 @@\n-        return DefaultOptionsHolder.defaultOptions;\n+        final class Holder {\n+            static final Set<SctpSocketOption<?>> DEFAULT_OPTIONS = Set.of(\n+                    SCTP_DISABLE_FRAGMENTS,\n+                    SCTP_EXPLICIT_COMPLETE,\n+                    SCTP_FRAGMENT_INTERLEAVE,\n+                    SCTP_INIT_MAXSTREAMS,\n+                    SCTP_NODELAY,\n+                    SCTP_PRIMARY_ADDR,\n+                    SCTP_SET_PEER_PRIMARY_ADDR,\n+                    SO_SNDBUF,\n+                    SO_RCVBUF,\n+                    SO_LINGER);\n+        }\n+        return Holder.DEFAULT_OPTIONS;\n@@ -842,1 +842,3 @@\n-        int n = receive0(fd, resultContainer, ((DirectBuffer)bb).address() + pos, rem, peek);\n+        NIO_ACCESS.acquireSession(bb);\n+        try {\n+            int n = receive0(fd, resultContainer, ((DirectBuffer)bb).address() + pos, rem, peek);\n@@ -844,3 +846,6 @@\n-        if (n > 0)\n-            bb.position(pos + n);\n-        return n;\n+            if (n > 0)\n+                bb.position(pos + n);\n+            return n;\n+        } finally {\n+            NIO_ACCESS.releaseSession(bb);\n+        }\n@@ -849,1 +854,1 @@\n-    private InternalNotificationHandler internalNotificationHandler =\n+    private final InternalNotificationHandler internalNotificationHandler =\n@@ -852,2 +857,1 @@\n-    private void handleNotificationInternal(ResultContainer resultContainer)\n-    {\n+    private void handleNotificationInternal(ResultContainer resultContainer) {\n@@ -858,3 +862,2 @@\n-    private class InternalNotificationHandler\n-            extends AbstractNotificationHandler<Object>\n-    {\n+    private final class InternalNotificationHandler\n+            extends AbstractNotificationHandler<Object> {\n@@ -862,4 +865,3 @@\n-        public HandlerResult handleNotification(\n-                AssociationChangeNotification not, Object unused) {\n-            if (not.event().equals(\n-                    AssociationChangeNotification.AssocChangeEvent.COMM_UP) &&\n+        public HandlerResult handleNotification(AssociationChangeNotification not,\n+                                                Object unused) {\n+            if (not.event().equals(AssociationChangeNotification.AssocChangeEvent.COMM_UP) &&\n@@ -875,4 +877,3 @@\n-    private <T> HandlerResult invokeNotificationHandler\n-                                 (ResultContainer resultContainer,\n-                                  NotificationHandler<T> handler,\n-                                  T attachment) {\n+    private <T> HandlerResult invokeNotificationHandler(ResultContainer resultContainer,\n+                                                        NotificationHandler<T> handler,\n+                                                        T attachment) {\n@@ -884,1 +885,1 @@\n-        if (!(handler instanceof AbstractNotificationHandler)) {\n+        if (!(handler instanceof AbstractNotificationHandler<T> absHandler)) {\n@@ -889,20 +890,13 @@\n-        AbstractNotificationHandler<T> absHandler =\n-                (AbstractNotificationHandler<T>)handler;\n-        switch(resultContainer.type()) {\n-            case ASSOCIATION_CHANGED :\n-                return absHandler.handleNotification(\n-                        resultContainer.getAssociationChanged(), attachment);\n-            case PEER_ADDRESS_CHANGED :\n-                return absHandler.handleNotification(\n-                        resultContainer.getPeerAddressChanged(), attachment);\n-            case SEND_FAILED :\n-                return absHandler.handleNotification(\n-                        resultContainer.getSendFailed(), attachment);\n-            case SHUTDOWN :\n-                return absHandler.handleNotification(\n-                        resultContainer.getShutdown(), attachment);\n-            default :\n-                \/* implementation specific handlers *\/\n-                return absHandler.handleNotification(\n-                        resultContainer.notification(), attachment);\n-        }\n+        return switch (resultContainer.type()) {\n+            case ASSOCIATION_CHANGED  -> absHandler.handleNotification(\n+                    resultContainer.getAssociationChanged(), attachment);\n+            case PEER_ADDRESS_CHANGED -> absHandler.handleNotification(\n+                    resultContainer.getPeerAddressChanged(), attachment);\n+            case SEND_FAILED          -> absHandler.handleNotification(\n+                    resultContainer.getSendFailed(), attachment);\n+            case SHUTDOWN             -> absHandler.handleNotification(\n+                    resultContainer.getShutdown(), attachment);\n+            \/* implementation specific handlers *\/\n+            default                   -> absHandler.handleNotification(\n+                    resultContainer.notification(), attachment);\n+        };\n@@ -1031,5 +1025,10 @@\n-        int written = send0(fd, ((DirectBuffer)bb).address() + pos, rem, addr,\n-                            port, -1 \/*121*\/, streamNumber, unordered, ppid);\n-        if (written > 0)\n-            bb.position(pos + written);\n-        return written;\n+        NIO_ACCESS.acquireSession(bb);\n+        try {\n+            int written = send0(fd, ((DirectBuffer)bb).address() + pos, rem, addr,\n+                    port, -1 \/*121*\/, streamNumber, unordered, ppid);\n+            if (written > 0)\n+                bb.position(pos + written);\n+            return written;\n+        } finally {\n+            NIO_ACCESS.releaseSession(bb);\n+        }\n@@ -1101,2 +1100,2 @@\n-        java.security.AccessController.doPrivileged(\n-            new java.security.PrivilegedAction<Void>() {\n+        AccessController.doPrivileged(\n+            new PrivilegedAction<>() {\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpChannelImpl.java","additions":74,"deletions":75,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.util.Map;\n@@ -56,0 +57,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -74,0 +77,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -79,2 +84,2 @@\n-    private volatile long receiverThread = 0;\n-    private volatile long senderThread = 0;\n+    private volatile long receiverThread;\n+    private volatile long senderThread;\n@@ -103,1 +108,1 @@\n-    private HashSet<InetSocketAddress> localAddresses = new HashSet<InetSocketAddress>();\n+    private final Set<InetSocketAddress> localAddresses = new HashSet<>();\n@@ -107,5 +112,5 @@\n-    \/* Keeps a map of addresses to association, and visa versa *\/\n-    private HashMap<SocketAddress, Association> addressMap =\n-                         new HashMap<SocketAddress, Association>();\n-    private HashMap<Association, Set<SocketAddress>> associationMap =\n-                         new HashMap<Association, Set<SocketAddress>>();\n+    \/* Keeps a map of addresses to association, and vice versa *\/\n+    private final Map<SocketAddress, Association> addressMap =\n+                         new HashMap<>();\n+    private final Map<Association, Set<SocketAddress>> associationMap =\n+                         new HashMap<>();\n@@ -117,6 +122,1 @@\n-    private final ThreadLocal<Association> associationToRemove =\n-        new ThreadLocal<Association>() {\n-             @Override protected Association initialValue() {\n-                 return null;\n-            }\n-    };\n+    private final ThreadLocal<Association> associationToRemove = new ThreadLocal<>();\n@@ -126,1 +126,1 @@\n-        new ThreadLocal<Boolean>() {\n+        new ThreadLocal<>() {\n@@ -258,1 +258,1 @@\n-            return port == -1 ? false : true;\n+            return port != -1;\n@@ -439,19 +439,0 @@\n-    private static class DefaultOptionsHolder {\n-        static final Set<SctpSocketOption<?>> defaultOptions = defaultOptions();\n-\n-        private static Set<SctpSocketOption<?>> defaultOptions() {\n-            HashSet<SctpSocketOption<?>> set = new HashSet<SctpSocketOption<?>>(10);\n-            set.add(SCTP_DISABLE_FRAGMENTS);\n-            set.add(SCTP_EXPLICIT_COMPLETE);\n-            set.add(SCTP_FRAGMENT_INTERLEAVE);\n-            set.add(SCTP_INIT_MAXSTREAMS);\n-            set.add(SCTP_NODELAY);\n-            set.add(SCTP_PRIMARY_ADDR);\n-            set.add(SCTP_SET_PEER_PRIMARY_ADDR);\n-            set.add(SO_SNDBUF);\n-            set.add(SO_RCVBUF);\n-            set.add(SO_LINGER);\n-            return Collections.unmodifiableSet(set);\n-        }\n-    }\n-\n@@ -460,1 +441,15 @@\n-        return DefaultOptionsHolder.defaultOptions;\n+        final class Holder {\n+            static final Set<SctpSocketOption<?>> DEFAULT_OPTIONS = Set.of(\n+                    SCTP_DISABLE_FRAGMENTS,\n+                    SCTP_EXPLICIT_COMPLETE,\n+                    SCTP_FRAGMENT_INTERLEAVE,\n+                    SCTP_INIT_MAXSTREAMS,\n+                    SCTP_NODELAY,\n+                    SCTP_PRIMARY_ADDR,\n+                    SCTP_SET_PEER_PRIMARY_ADDR,\n+                    SO_SNDBUF,\n+                    SO_RCVBUF,\n+                    SO_LINGER);\n+\n+        }\n+        return Holder.DEFAULT_OPTIONS;\n@@ -586,4 +581,9 @@\n-        int n = receive0(fd, resultContainer, ((DirectBuffer)bb).address() + pos, rem);\n-        if (n > 0)\n-            bb.position(pos + n);\n-        return n;\n+        NIO_ACCESS.acquireSession(bb);\n+        try {\n+            int n = receive0(fd, resultContainer, ((DirectBuffer)bb).address() + pos, rem);\n+            if (n > 0)\n+                bb.position(pos + n);\n+            return n;\n+        } finally {\n+            NIO_ACCESS.releaseSession(bb);\n+        }\n@@ -592,1 +592,1 @@\n-    private InternalNotificationHandler internalNotificationHandler =\n+    private final InternalNotificationHandler internalNotificationHandler =\n@@ -601,1 +601,1 @@\n-    private class InternalNotificationHandler\n+    private final class InternalNotificationHandler\n@@ -605,2 +605,2 @@\n-        public HandlerResult handleNotification(\n-                AssociationChangeNotification not, Object unused) {\n+        public HandlerResult handleNotification(AssociationChangeNotification not,\n+                                                Object unused) {\n@@ -611,1 +611,1 @@\n-                case COMM_UP :\n+                case COMM_UP -> {\n@@ -613,1 +613,1 @@\n-                       (sac.assocId(), sac.maxInStreams(), sac.maxOutStreams());\n+                            (sac.assocId(), sac.maxInStreams(), sac.maxOutStreams());\n@@ -615,4 +615,3 @@\n-                    break;\n-                case SHUTDOWN :\n-                case COMM_LOST :\n-                \/\/case RESTART: ???\n+                }\n+                case SHUTDOWN, COMM_LOST ->\n+                    \/\/case RESTART: ???\n@@ -620,1 +619,1 @@\n-                    associationToRemove.set(lookupAssociation(sac.assocId()));\n+                        associationToRemove.set(lookupAssociation(sac.assocId()));\n@@ -626,4 +625,3 @@\n-    private <T> HandlerResult invokeNotificationHandler(\n-                                   ResultContainer resultContainer,\n-                                   NotificationHandler<T> handler,\n-                                   T attachment) {\n+    private <T> HandlerResult invokeNotificationHandler(ResultContainer resultContainer,\n+                                                        NotificationHandler<T> handler,\n+                                                        T attachment) {\n@@ -634,1 +632,1 @@\n-        if (!(handler instanceof AbstractNotificationHandler)) {\n+        if (!(handler instanceof AbstractNotificationHandler<T> absHandler)) {\n@@ -637,24 +635,13 @@\n-            AbstractNotificationHandler<T> absHandler =\n-                    (AbstractNotificationHandler<T>)handler;\n-            switch(resultContainer.type()) {\n-                case ASSOCIATION_CHANGED :\n-                    result = absHandler.handleNotification(\n-                            resultContainer.getAssociationChanged(), attachment);\n-                    break;\n-                case PEER_ADDRESS_CHANGED :\n-                    result = absHandler.handleNotification(\n-                            resultContainer.getPeerAddressChanged(), attachment);\n-                    break;\n-                case SEND_FAILED :\n-                    result = absHandler.handleNotification(\n-                            resultContainer.getSendFailed(), attachment);\n-                    break;\n-                case SHUTDOWN :\n-                    result =  absHandler.handleNotification(\n-                            resultContainer.getShutdown(), attachment);\n-                    break;\n-                default :\n-                    \/* implementation specific handlers *\/\n-                    result =  absHandler.handleNotification(\n-                            resultContainer.notification(), attachment);\n-            }\n+            result = switch (resultContainer.type()) {\n+                case ASSOCIATION_CHANGED  -> absHandler.handleNotification(\n+                        resultContainer.getAssociationChanged(), attachment);\n+                case PEER_ADDRESS_CHANGED -> absHandler.handleNotification(\n+                        resultContainer.getPeerAddressChanged(), attachment);\n+                case SEND_FAILED          -> absHandler.handleNotification(\n+                        resultContainer.getSendFailed(), attachment);\n+                case SHUTDOWN             -> absHandler.handleNotification(\n+                        resultContainer.getShutdown(), attachment);\n+                \/* implementation specific handlers *\/\n+                default                   -> absHandler.handleNotification(\n+                        resultContainer.notification(), attachment);\n+            };\n@@ -748,2 +735,1 @@\n-     * @throws  IllegalArgumentException\n-     *          If the given association is not controlled by this channel\n+     * Checks if the given association is controlled by this channel.\n@@ -751,2 +737,1 @@\n-     * @return  {@code true} if, and only if, the given association is one\n-     *          of the current associations controlled by this channel\n+     * @throws IllegalArgumentException If the given association is not controlled by this channel\n@@ -754,1 +739,1 @@\n-    private boolean checkAssociation(Association messageAssoc) {\n+    private void checkAssociation(Association messageAssoc) {\n@@ -758,1 +743,1 @@\n-                    return true;\n+                    return;\n@@ -911,5 +896,10 @@\n-        int written = send0(fd, ((DirectBuffer)bb).address() + pos, rem, addr,\n-                            port, assocId, streamNumber, unordered, ppid);\n-        if (written > 0)\n-            bb.position(pos + written);\n-        return written;\n+        NIO_ACCESS.acquireSession(bb);\n+        try {\n+            int written = send0(fd, ((DirectBuffer)bb).address() + pos, rem, addr,\n+                    port, assocId, streamNumber, unordered, ppid);\n+            if (written > 0)\n+                bb.position(pos + written);\n+            return written;\n+        } finally {\n+            NIO_ACCESS.releaseSession(bb);\n+        }\n@@ -956,2 +946,1 @@\n-                Set<SocketAddress> addrs = associationMap.get(association);\n-                return addrs != null ? addrs : Collections.<SocketAddress>emptySet();\n+                return associationMap.getOrDefault(association, Collections.emptySet());\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpMultiChannelImpl.java","additions":82,"deletions":93,"binary":false,"changes":175,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-        HashSet<SocketAddress> set = null;\n+        Set<SocketAddress> set = null;\n@@ -139,1 +139,1 @@\n-            set = new HashSet<SocketAddress>(saa.length);\n+            set = new HashSet<>(saa.length);\n@@ -163,2 +163,0 @@\n-            if (addr == null)\n-                throw new IllegalArgumentException(\"Invalid option value\");\n@@ -260,1 +258,1 @@\n-        setIntOption0(fd, ((SctpStdSocketOption)name).constValue(), arg);\n+        setIntOption0(fd, ((SctpStdSocketOption<?>)name).constValue(), arg);\n@@ -270,1 +268,1 @@\n-        if (!(name instanceof SctpStdSocketOption))\n+        if (!(name instanceof SctpStdSocketOption<?> option))\n@@ -273,2 +271,1 @@\n-        int value = getIntOption0(fd,\n-                ((SctpStdSocketOption)name).constValue());\n+        int value = getIntOption0(fd, option.constValue());\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpNet.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n- * All Notification implemenations MUST implement this interface to provide\n- * access to the native association identidier.\n+ * All Notification implementations MUST implement this interface to provide\n+ * access to the native association identifier.\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpNotification.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-import sun.nio.ch.DirectBuffer;\n@@ -51,1 +50,0 @@\n-import sun.nio.ch.Util;\n@@ -64,1 +62,1 @@\n-    private volatile long thread = 0;\n+    private volatile long thread;\n@@ -84,1 +82,1 @@\n-    private HashSet<InetSocketAddress> localAddresses = new HashSet<InetSocketAddress>();\n+    private final HashSet<InetSocketAddress> localAddresses = new HashSet<>();\n@@ -203,1 +201,1 @@\n-            return port == -1 ? false : true;\n+            return port != -1;\n@@ -392,10 +390,0 @@\n-    private static class DefaultOptionsHolder {\n-        static final Set<SctpSocketOption<?>> defaultOptions = defaultOptions();\n-\n-        private static Set<SctpSocketOption<?>> defaultOptions() {\n-            HashSet<SctpSocketOption<?>> set = new HashSet<SctpSocketOption<?>>(1);\n-            set.add(SctpStandardSocketOptions.SCTP_INIT_MAXSTREAMS);\n-            return Collections.unmodifiableSet(set);\n-        }\n-    }\n-\n@@ -404,1 +392,5 @@\n-        return DefaultOptionsHolder.defaultOptions;\n+        final class Holder {\n+            static final Set<SctpSocketOption<?>> DEFAULT_OPTIONS =\n+                    Set.of(SctpStandardSocketOptions.SCTP_INIT_MAXSTREAMS);\n+        }\n+        return Holder.DEFAULT_OPTIONS;\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpServerChannelImpl.java","additions":8,"deletions":16,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -41,5 +41,5 @@\n-    private int assocId;\n-    private SocketAddress address;\n-    private ByteBuffer buffer;\n-    private int errorCode;\n-    private int streamNumber;\n+    private final int assocId;\n+    private final SocketAddress address;\n+    private final ByteBuffer buffer;\n+    private final int errorCode;\n+    private final int streamNumber;\n@@ -100,9 +100,7 @@\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(super.toString()).append(\" [\");\n-        sb.append(\"Association:\").append(association);\n-        sb.append(\", Address: \").append(address);\n-        sb.append(\", buffer: \").append(buffer);\n-        sb.append(\", errorCode: \").append(errorCode);\n-        sb.append(\", streamNumber: \").append(streamNumber);\n-        sb.append(\"]\");\n-        return sb.toString();\n+        return super.toString() + \" [\" +\n+                \"Association:\" + association +\n+                \", Address: \" + address +\n+                \", buffer: \" + buffer +\n+                \", errorCode: \" + errorCode +\n+                \", streamNumber: \" + streamNumber +\n+                \"]\";\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SendFailed.java","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-    \/* assocId is used to lookup the association before the notification is\n+    \/* assocId is used to look up the association before the notification is\n@@ -39,1 +39,1 @@\n-    private int assocId;\n+    private final int assocId;\n@@ -64,4 +64,2 @@\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(super.toString()).append(\" [\");\n-        sb.append(\"Association:\").append(association).append(\"]\");\n-        return sb.toString();\n+        return super.toString() + \" [\" +\n+                \"Association:\" + association + \"]\";\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/Shutdown.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shenandoah\/shenandoahNumberSeq.hpp\"\n+#include <iostream>\n+#include \"unittest.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+class ShenandoahNumberSeqTest: public ::testing::Test {\n+ protected:\n+  HdrSeq seq;\n+};\n+\n+class BasicShenandoahNumberSeqTest: public ShenandoahNumberSeqTest {\n+ protected:\n+  const double err = 0.5;\n+  BasicShenandoahNumberSeqTest() {\n+    seq.add(0);\n+    seq.add(1);\n+    seq.add(10);\n+    for (int i = 0; i < 7; i++) {\n+      seq.add(100);\n+    }\n+    std::cout << \" p0 = \" << seq.percentile(0);\n+    std::cout << \" p10 = \" << seq.percentile(10);\n+    std::cout << \" p20 = \" << seq.percentile(20);\n+    std::cout << \" p30 = \" << seq.percentile(30);\n+    std::cout << \" p50 = \" << seq.percentile(50);\n+    std::cout << \" p80 = \" << seq.percentile(80);\n+    std::cout << \" p90 = \" << seq.percentile(90);\n+    std::cout << \" p100 = \" << seq.percentile(100);\n+  }\n+};\n+\n+TEST_VM_F(BasicShenandoahNumberSeqTest, maximum_test) {\n+  EXPECT_EQ(seq.maximum(), 100);\n+}\n+\n+TEST_VM_F(BasicShenandoahNumberSeqTest, minimum_test) {\n+  EXPECT_EQ(0, seq.percentile(0));\n+}\n+\n+TEST_VM_F(BasicShenandoahNumberSeqTest, percentile_test) {\n+  EXPECT_NEAR(0, seq.percentile(10), err);\n+  EXPECT_NEAR(1, seq.percentile(20), err);\n+  EXPECT_NEAR(10, seq.percentile(30), err);\n+  EXPECT_NEAR(100, seq.percentile(40), err);\n+  EXPECT_NEAR(100, seq.percentile(50), err);\n+  EXPECT_NEAR(100, seq.percentile(75), err);\n+  EXPECT_NEAR(100, seq.percentile(90), err);\n+  EXPECT_NEAR(100, seq.percentile(100), err);\n+}\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahNumberSeq.cpp","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -60,4 +60,2 @@\n-  if (!UseMallocOnly) {\n-    \/\/ contains works differently for malloced mode (and there its broken anyway)\n-    ASSERT_FALSE(ar.contains(p));\n-  }\n+\n+  ASSERT_FALSE(ar.contains(p));\n@@ -66,5 +64,3 @@\n-  if (!UseMallocOnly) {\n-    void* p2 = ar.Amalloc(1);\n-    ASSERT_AMALLOC(ar, p2);\n-    ASSERT_EQ(p2, p);\n-  }\n+  void* p2 = ar.Amalloc(1);\n+  ASSERT_AMALLOC(ar, p2);\n+  ASSERT_EQ(p2, p);\n@@ -84,4 +80,2 @@\n-  if (!UseMallocOnly) {\n-    void* p3 = ar.Amalloc(0x20);\n-    ASSERT_EQ(p3, p1);\n-  }\n+  void* p3 = ar.Amalloc(0x20);\n+  ASSERT_EQ(p3, p1);\n@@ -99,3 +93,1 @@\n-  if (!UseMallocOnly) {\n-    ASSERT_EQ(p2, p1);\n-  }\n+  ASSERT_EQ(p2, p1);\n@@ -160,4 +152,2 @@\n-  if (!UseMallocOnly) {\n-    void* p2 = ar.Amalloc(0x20);\n-    ASSERT_EQ(p2, p);\n-  }\n+  void* p2 = ar.Amalloc(0x20);\n+  ASSERT_EQ(p2, p);\n@@ -166,0 +156,1 @@\n+\n@@ -168,2 +159,1 @@\n-  if (!UseMallocOnly) {\n-    Arena ar(mtTest);\n+  Arena ar(mtTest);\n@@ -171,3 +161,3 @@\n-    void* p1 = ar.Amalloc(0x200);\n-    ASSERT_AMALLOC(ar, p1);\n-    GtestUtils::mark_range(p1, 0x200);\n+  void* p1 = ar.Amalloc(0x200);\n+  ASSERT_AMALLOC(ar, p1);\n+  GtestUtils::mark_range(p1, 0x200);\n@@ -175,3 +165,3 @@\n-    void* p2 = ar.Arealloc(p1, 0x200, 0x100);\n-    ASSERT_EQ(p1, p2);\n-    ASSERT_RANGE_IS_MARKED(p2, 0x100); \/\/ realloc should preserve old content\n+  void* p2 = ar.Arealloc(p1, 0x200, 0x100);\n+  ASSERT_EQ(p1, p2);\n+  ASSERT_RANGE_IS_MARKED(p2, 0x100); \/\/ realloc should preserve old content\n@@ -179,4 +169,3 @@\n-    \/\/ A subsequent allocation should be placed right after the end of the first, shrunk, allocation\n-    void* p3 = ar.Amalloc(1);\n-    ASSERT_EQ(p3, ((char*)p1) + 0x100);\n-  }\n+  \/\/ A subsequent allocation should be placed right after the end of the first, shrunk, allocation\n+  void* p3 = ar.Amalloc(1);\n+  ASSERT_EQ(p3, ((char*)p1) + 0x100);\n@@ -196,3 +185,1 @@\n-  if (!UseMallocOnly) {\n-    ASSERT_EQ(p1, p2); \/\/ should still shrink in place\n-  }\n+  ASSERT_EQ(p1, p2); \/\/ should still shrink in place\n@@ -211,3 +198,1 @@\n-  if (!UseMallocOnly) {\n-    ASSERT_EQ(p1, p2);\n-  }\n+  ASSERT_EQ(p1, p2);\n","filename":"test\/hotspot\/gtest\/memory\/test_arena.cpp","additions":23,"deletions":38,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -144,0 +144,13 @@\n+\n+TEST_VM(NMT, HeaderKeepsIntegrityAfterRevival) {\n+  if (!MemTracker::enabled()) {\n+    return;\n+  }\n+  size_t some_size = 16;\n+  void* p = os::malloc(some_size, mtTest);\n+  ASSERT_NOT_NULL(p) << \"Failed to malloc()\";\n+  MallocHeader* hdr = MallocTracker::malloc_header(p);\n+  hdr->mark_block_as_dead();\n+  hdr->revive();\n+  check_expected_malloc_header(p, mtTest, some_size);\n+}\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_cornercases.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+\n+compiler\/c1\/TestPrintC1Statistics.java 8298053 linux-aarch64\n","filename":"test\/hotspot\/jtreg\/ProblemList-Xcomp.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,0 +49,40 @@\n+\n+vmTestbase\/nsk\/monitoring\/stress\/lowmem\/lowmem001\/TestDescription.java 8297979 generic-all\n+vmTestbase\/nsk\/monitoring\/stress\/lowmem\/lowmem002\/TestDescription.java 8297979 generic-all\n+vmTestbase\/nsk\/monitoring\/stress\/lowmem\/lowmem003\/TestDescription.java 8297979 generic-all\n+vmTestbase\/nsk\/monitoring\/stress\/lowmem\/lowmem004\/TestDescription.java 8297979 generic-all\n+vmTestbase\/nsk\/monitoring\/stress\/lowmem\/lowmem005\/TestDescription.java 8297979 generic-all\n+vmTestbase\/nsk\/monitoring\/stress\/lowmem\/lowmem006\/TestDescription.java 8297979 generic-all\n+vmTestbase\/nsk\/monitoring\/stress\/lowmem\/lowmem007\/TestDescription.java 8297979 generic-all\n+vmTestbase\/nsk\/monitoring\/stress\/lowmem\/lowmem008\/TestDescription.java 8297979 generic-all\n+vmTestbase\/nsk\/monitoring\/stress\/lowmem\/lowmem009\/TestDescription.java 8297979 generic-all\n+vmTestbase\/nsk\/monitoring\/stress\/lowmem\/lowmem010\/TestDescription.java 8297979 generic-all\n+vmTestbase\/nsk\/monitoring\/stress\/lowmem\/lowmem011\/TestDescription.java 8297979 generic-all\n+vmTestbase\/nsk\/monitoring\/stress\/lowmem\/lowmem012\/TestDescription.java 8297979 generic-all\n+vmTestbase\/nsk\/monitoring\/stress\/lowmem\/lowmem013\/TestDescription.java 8297979 generic-all\n+vmTestbase\/nsk\/monitoring\/stress\/lowmem\/lowmem014\/TestDescription.java 8297979 generic-all\n+vmTestbase\/nsk\/monitoring\/stress\/lowmem\/lowmem015\/TestDescription.java 8297979 generic-all\n+vmTestbase\/nsk\/monitoring\/stress\/lowmem\/lowmem016\/TestDescription.java 8297979 generic-all\n+vmTestbase\/nsk\/monitoring\/stress\/lowmem\/lowmem017\/TestDescription.java 8297979 generic-all\n+vmTestbase\/nsk\/monitoring\/stress\/lowmem\/lowmem018\/TestDescription.java 8297979 generic-all\n+vmTestbase\/nsk\/monitoring\/stress\/lowmem\/lowmem019\/TestDescription.java 8297979 generic-all\n+vmTestbase\/nsk\/monitoring\/stress\/lowmem\/lowmem020\/TestDescription.java 8297979 generic-all\n+vmTestbase\/nsk\/monitoring\/stress\/lowmem\/lowmem021\/TestDescription.java 8297979 generic-all\n+vmTestbase\/nsk\/monitoring\/stress\/lowmem\/lowmem022\/TestDescription.java 8297979 generic-all\n+vmTestbase\/nsk\/monitoring\/stress\/lowmem\/lowmem023\/TestDescription.java 8297979 generic-all\n+vmTestbase\/nsk\/monitoring\/stress\/lowmem\/lowmem024\/TestDescription.java 8297979 generic-all\n+vmTestbase\/nsk\/monitoring\/stress\/lowmem\/lowmem025\/TestDescription.java 8297979 generic-all\n+vmTestbase\/nsk\/monitoring\/stress\/lowmem\/lowmem026\/TestDescription.java 8297979 generic-all\n+vmTestbase\/nsk\/monitoring\/stress\/lowmem\/lowmem027\/TestDescription.java 8297979 generic-all\n+vmTestbase\/nsk\/monitoring\/stress\/lowmem\/lowmem028\/TestDescription.java 8297979 generic-all\n+vmTestbase\/nsk\/monitoring\/stress\/lowmem\/lowmem029\/TestDescription.java 8297979 generic-all\n+vmTestbase\/nsk\/monitoring\/stress\/lowmem\/lowmem030\/TestDescription.java 8297979 generic-all\n+vmTestbase\/nsk\/monitoring\/stress\/lowmem\/lowmem031\/TestDescription.java 8297979 generic-all\n+vmTestbase\/nsk\/monitoring\/stress\/lowmem\/lowmem032\/TestDescription.java 8297979 generic-all\n+vmTestbase\/nsk\/monitoring\/stress\/lowmem\/lowmem033\/TestDescription.java 8297979 generic-all\n+vmTestbase\/nsk\/monitoring\/stress\/lowmem\/lowmem034\/TestDescription.java 8297979 generic-all\n+vmTestbase\/nsk\/monitoring\/stress\/lowmem\/lowmem035\/TestDescription.java 8297979 generic-all\n+vmTestbase\/nsk\/monitoring\/stress\/lowmem\/lowmem036\/TestDescription.java 8297979 generic-all\n+\n+vmTestbase\/nsk\/jdi\/ExceptionRequest\/addInstanceFilter\/instancefilter001\/TestDescription.java 8298059 generic-x64\n+vmTestbase\/nsk\/jdi\/ExceptionRequest\/addInstanceFilter\/instancefilter004\/TestDescription.java 8298059 generic-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList-zgc.txt","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -48,2 +48,0 @@\n-compiler\/jvmci\/compilerToVM\/GetFlagValueTest.java 8204459 generic-all\n-compiler\/tiered\/LevelTransitionTest.java 8067651 generic-all\n@@ -83,1 +81,1 @@\n-gc\/metaspace\/CompressedClassSpaceSizeInJmapHeap.java 8241293 macosx-x64\n+gc\/metaspace\/CompressedClassSpaceSizeInJmapHeap.java 8241293,8298073 macosx-x64,macosx-aarch64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-requiredVersion=7.1+1\n+requiredVersion=7.1.1+1\n","filename":"test\/hotspot\/jtreg\/TEST.ROOT","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2022, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8290432\n+ * @summary Unexpected parallel induction variable pattern was recongized\n+ *\n+ * @run main\/othervm -XX:-TieredCompilation -Xcomp\n+ *           -XX:CompileCommand=compileonly,compiler.c2.TestUnexpectedParallelIV::test\n+ *           -XX:CompileCommand=compileonly,compiler.c2.TestUnexpectedParallelIV::test2\n+ *           -XX:CompileCommand=quiet\n+ *           -XX:CompileCommand=dontinline,compiler.c2.TestUnexpectedParallelIV::* compiler.c2.TestUnexpectedParallelIV\n+ *\/\n+\n+package compiler.c2;\n+\n+public class TestUnexpectedParallelIV {\n+\n+    static boolean bFld;\n+\n+    static int dontInline() {\n+        return 0;\n+    }\n+\n+    static int test2(int i1) {\n+        int i2, i3 = 0, i4, i5 = 0, i6;\n+        for (i2 = 0; 4 > i2; ++i2) {\n+            for (i4 = 1; i4 < 5; ++i4) {\n+                i3 -= --i1;\n+                i6 = 1;\n+                while (++i6 < 2) {\n+                    dontInline();\n+                    if (bFld) {\n+                        i1 = 5;\n+                    }\n+                }\n+                if (bFld) {\n+                    break;\n+                }\n+            }\n+        }\n+        return i3;\n+    }\n+\n+    static long test(int val, boolean b) {\n+        long ret = 0;\n+        long dArr[] = new long[100];\n+        for (int i = 15; 293 > i; ++i) {\n+            ret = val;\n+            int j = 1;\n+            while (++j < 6) {\n+                int k = (val--);\n+                for (long l = i; 1 > l; ) {\n+                    if (k != 0) {\n+                        ret += dontInline();\n+                    }\n+                }\n+                if (b) {\n+                    break;\n+                }\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 1000; i++) {\n+            test(0, false);\n+        }\n+\n+        test2(5);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestUnexpectedParallelIV.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -34,1 +34,1 @@\n- * @requires os.arch == \"x86_64\" | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n+ * @requires os.arch == \"x86_64\" | os.arch == \"aarch64\" | (os.arch == \"riscv64\" & vm.opt.UseZbb == true)\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/RotateLeftNodeIntIdealizationTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * @requires os.arch == \"x86_64\" | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n+ * @requires os.arch == \"x86_64\" | os.arch == \"aarch64\" | (os.arch == \"riscv64\" & vm.opt.UseZbb == true)\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/RotateLeftNodeLongIdealizationTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -119,0 +119,16 @@\n+    @Test\n+    @IR(failOn = {IRNode.COUNTTRAILINGZEROS_VL})\n+    public void testNumberOfTrailingZeros() {\n+        for (int i = 0; i < SIZE; ++i) {\n+            inta[i] = Long.numberOfTrailingZeros(longa[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.COUNTLEADINGZEROS_VL})\n+    public void testNumberOfLeadingZeros() {\n+        for (int i = 0; i < SIZE; ++i) {\n+            inta[i] = Long.numberOfLeadingZeros(longa[i]);\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestDisableAutoVectOpcodes.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+ * @requires os.arch != \"riscv64\"\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestFPComparison.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8296545\n+ * @requires vm.compiler2.enabled\n+ * @summary Blackholes should allow load optimizations\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.blackhole.BlackholeLoadOptoTest\n+ *\/\n+\n+package compiler.c2.irTests.blackhole;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+public class BlackholeLoadOptoTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:CompileCommand=blackhole,compiler.c2.irTests.blackhole.BlackholeLoadOptoTest::blackhole\",\n+            \"-XX:CompileCommand=dontinline,compiler.c2.irTests.blackhole.BlackholeLoadOptoTest::dontinline\"\n+        );\n+    }\n+\n+    static int x, y;\n+\n+\n+    \/*\n+     * Negative test: check that dangling expressions are eliminated\n+     *\/\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD_I, IRNode.MUL_I})\n+    static void testNothing() {\n+        int r1 = x * y;\n+        int r2 = x * y;\n+    }\n+\n+    @Run(test = \"testNothing\")\n+    static void runNothing() {\n+        testNothing();\n+    }\n+\n+    \/*\n+     * Auxiliary test: check that dontinline method does break optimizations\n+     *\/\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_I, \"4\"})\n+    @IR(counts = {IRNode.MUL_I, \"2\"})\n+    static void testDontline() {\n+        int r1 = x * y;\n+        dontinline(r1);\n+        int r2 = x * y;\n+        dontinline(r2);\n+    }\n+\n+    static void dontinline(int x) {}\n+\n+    @Run(test = \"testDontline\")\n+    static void runDontinline() {\n+        testDontline();\n+    }\n+\n+    \/*\n+     * Positive test: check that blackhole does not break optimizations\n+     *\/\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_I, \"2\"})\n+    @IR(counts = {IRNode.MUL_I, \"1\"})\n+    static void testBlackholed() {\n+        int r1 = x * y;\n+        blackhole(r1);\n+        int r2 = x * y;\n+        blackhole(r2);\n+    }\n+\n+    static void blackhole(int x) {}\n+\n+    @Run(test = \"testBlackholed\")\n+    static void runBlackholed() {\n+        testBlackholed();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/blackhole\/BlackholeLoadOptoTest.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8297264\n+ * @summary Test that CastII nodes are added to the CCP worklist if they could have been\n+ *          optimized due to a CmpI\/If pattern.\n+ * @run main\/othervm -Xcomp -XX:CompileCommand=compileonly,compiler.ccp.TestCastIIWrongTypeCCP::*\n+ *                   compiler.ccp.TestCastIIWrongTypeCCP\n+ *\/\n+package compiler.ccp;\n+\n+public class TestCastIIWrongTypeCCP {\n+\n+    static int x;\n+\n+    public static void main(String[] args) {\n+        test();\n+    }\n+\n+    static void test() {\n+        int iArr[] = new int[400];\n+        int i = 0;\n+        do {\n+            for (int i5 = 1; i5 < 4; i5++) {\n+                for (int i9 = 2; i9 > i5; i9 -= 3) {\n+                    if (x != 0) {\n+                        A.unloaded(); \/\/ unloaded UCT\n+                    }\n+                    x = 1;\n+                    iArr[5] = 1;\n+                }\n+            }\n+            i++;\n+        } while (i < 10000);\n+    }\n+}\n+\n+class A {\n+    public static void unloaded() {\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/ccp\/TestCastIIWrongTypeCCP.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022 SAP SE. All rights reserved.ights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test MHIntrinsicAllocFailureTest\n+ * @bug 8295724\n+ * @requires vm.compMode == \"Xmixed\"\n+ * @requires vm.opt.TieredCompilation == null | vm.opt.TieredCompilation == true\n+ * @summary test allocation failure of method handle intrinsic in profiled\/non-profiled space\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI -XX:CompileCommand=compileonly,null::*\n+ *                   -XX:ReservedCodeCacheSize=16m -XX:+SegmentedCodeCache\n+ *                   compiler.codecache.MHIntrinsicAllocFailureTest\n+ *\/\n+\n+package compiler.codecache;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.whitebox.WhiteBox;\n+import jdk.test.whitebox.code.BlobType;\n+\n+import java.lang.management.MemoryPoolMXBean;\n+\n+public class MHIntrinsicAllocFailureTest {\n+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+\n+    private interface TestInterface {\n+        int testMethod(int a, int b, Object c);\n+    }\n+\n+    private static void fillCodeCacheSegment(BlobType type) {\n+        \/\/ Fill with large blobs.\n+        MemoryPoolMXBean bean = type.getMemoryPool();\n+        int size = (int) (bean.getUsage().getMax() >> 7);\n+        while (WHITE_BOX.allocateCodeBlob(size, type.id) != 0) {}\n+        \/\/ Fill rest with minimal blobs.\n+        while (WHITE_BOX.allocateCodeBlob(1, type.id) != 0) {}\n+    }\n+\n+    public static void main(String[] args) {\n+        \/\/ Lock compilation to be able to better control code cache space\n+        WHITE_BOX.lockCompilation();\n+        fillCodeCacheSegment(BlobType.MethodNonProfiled);\n+        fillCodeCacheSegment(BlobType.MethodProfiled);\n+        \/\/ JIT compilers should be off, now.\n+        Asserts.assertNotEquals(WHITE_BOX.getCompilationActivityMode(), 1);\n+        System.out.println(\"Code cache segments for non-profiled and profiled nmethods are full.\");\n+        \/\/ Generate and use a MH itrinsic. Should not trigger one of the following:\n+        \/\/ - VirtualMachineError: Out of space in CodeCache for method handle intrinsic\n+        \/\/ - InternalError: java.lang.NoSuchMethodException: no such method:\n+        \/\/   java.lang.invoke.MethodHandle.linkToStatic(int,int,Object,MemberName)int\/invokeStatic\n+        TestInterface add2ints = (a, b, c) -> a + b;\n+        System.out.println(\"Result of lambda expression: \" + add2ints.testMethod(1, 2, null));\n+        \/\/ Let GC check the code cache.\n+        WHITE_BOX.unlockCompilation();\n+        WHITE_BOX.fullGC();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/MHIntrinsicAllocFailureTest.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -1,93 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.jvmci\n- * @modules jdk.internal.vm.ci\/jdk.vm.ci.services:+open\n- * @library \/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\n- * @run testng\/othervm\n- *      -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:-UseJVMCICompiler\n- *      jdk.vm.ci.hotspot.test.TestServices\n- *\/\n-\n-package jdk.vm.ci.hotspot.test;\n-\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n-\n-import jdk.vm.ci.services.Services;\n-\n-public class TestServices {\n-\n-    @SuppressWarnings(\"unchecked\")\n-    @Test\n-    public void serializeSavedPropertiesTest() throws Exception {\n-\n-        Field f = Services.class.getDeclaredField(\"MAX_UTF8_PROPERTY_STRING_LENGTH\");\n-        f.setAccessible(true);\n-        int maxUtf8PropertyStringLength = (int) f.get(null);\n-\n-        Method serializeProperties = Services.class.getDeclaredMethod(\"serializeProperties\", Map.class);\n-        Method deserializeProperties = Services.class.getDeclaredMethod(\"deserializeProperties\", byte[].class);\n-        serializeProperties.setAccessible(true);\n-        deserializeProperties.setAccessible(true);\n-\n-        Map<String, String> props = new HashMap<>(Services.getSavedProperties());\n-        String[] names = {\n-                        new String(new char[maxUtf8PropertyStringLength - 100]).replace('\\0', 'x'),\n-                        new String(new char[maxUtf8PropertyStringLength - 1]).replace('\\0', 'x'),\n-                        new String(new char[maxUtf8PropertyStringLength]).replace('\\0', 'y'),\n-                        new String(new char[maxUtf8PropertyStringLength + 1]).replace('\\0', 'z'),\n-                        new String(new char[maxUtf8PropertyStringLength + 100]).replace('\\0', 'z')\n-        };\n-        String[] values = {\n-                        new String(new char[maxUtf8PropertyStringLength - 100]).replace('\\0', '1'),\n-                        new String(new char[maxUtf8PropertyStringLength - 1]).replace('\\0', '1'),\n-                        new String(new char[maxUtf8PropertyStringLength]).replace('\\0', '2'),\n-                        new String(new char[maxUtf8PropertyStringLength + 1]).replace('\\0', '1'),\n-                        new String(new char[maxUtf8PropertyStringLength + 100]).replace('\\0', '3')\n-        };\n-        for (String name : names) {\n-            for (String value : values) {\n-                props.put(name, value);\n-            }\n-        }\n-\n-        byte[] data = (byte[]) serializeProperties.invoke(null, props);\n-\n-        Map<String, String> newProps = (Map<String, String>) deserializeProperties.invoke(null, data);\n-\n-        Assert.assertEquals(props.size(), newProps.size());\n-        for (String name : props.keySet()) {\n-            String expect = props.get(name);\n-            String actual = newProps.get(name);\n-            Assert.assertEquals(expect, actual);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/TestServices.java","additions":0,"deletions":93,"binary":false,"changes":93,"status":"deleted"},{"patch":"@@ -1,153 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.jvmci\n- * @modules jdk.internal.vm.ci\/jdk.vm.ci.hotspot:+open\n- *          java.base\/jdk.internal.misc\n- * @library \/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\n- * @run testng\/othervm\n- *      -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:-UseJVMCICompiler\n- *      jdk.vm.ci.hotspot.test.TestTranslatedException\n- *\/\n-\n-package jdk.vm.ci.hotspot.test;\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.PrintStream;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n-\n-import jdk.internal.misc.Unsafe;\n-import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;\n-\n-public class TestTranslatedException {\n-    @SuppressWarnings(\"serial\")\n-    public static class Untranslatable extends RuntimeException {\n-        public Untranslatable(String message, Throwable cause) {\n-            super(message, cause);\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    @Test\n-    public void encodeDecodeTest() throws Exception {\n-\n-        Class<?> translatedExceptionClass = Class.forName(\"jdk.vm.ci.hotspot.TranslatedException\");\n-\n-        Method encode = translatedExceptionClass.getDeclaredMethod(\"encodeThrowable\", Throwable.class);\n-        Method decode = translatedExceptionClass.getDeclaredMethod(\"decodeThrowable\", byte[].class);\n-        encode.setAccessible(true);\n-        decode.setAccessible(true);\n-\n-        Throwable throwable = new ExceptionInInitializerError(new InvocationTargetException(new Untranslatable(\"test exception\", new NullPointerException()), \"invoke\"));\n-        for (int i = 0; i < 10; i++) {\n-            throwable = new ExceptionInInitializerError(new InvocationTargetException(new RuntimeException(String.valueOf(i), throwable), \"invoke\"));\n-        }\n-        byte[] encoding = (byte[]) encode.invoke(null, throwable);\n-        Throwable decoded = (Throwable) decode.invoke(null, encoding);\n-        assertThrowableEquals(throwable, decoded);\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    @Test\n-    public void encodeDecodeTest2() throws Exception {\n-        Unsafe unsafe = Unsafe.getUnsafe();\n-        int bufferSize = 512;\n-        long buffer = 0L;\n-        while (true) {\n-            buffer = unsafe.allocateMemory(bufferSize);\n-            try {\n-                Throwable throwable = new ExceptionInInitializerError(new InvocationTargetException(new Untranslatable(\"test exception\", new NullPointerException()), \"invoke\"));\n-                for (int i = 0; i < 10; i++) {\n-                    throwable = new ExceptionInInitializerError(new InvocationTargetException(new RuntimeException(String.valueOf(i), throwable), \"invoke\"));\n-                }\n-\n-                Method encode = HotSpotJVMCIRuntime.class.getDeclaredMethod(\"encodeThrowable\", Throwable.class, long.class, int.class);\n-                Method decode = HotSpotJVMCIRuntime.class.getDeclaredMethod(\"decodeAndThrowThrowable\", long.class);\n-                encode.setAccessible(true);\n-                decode.setAccessible(true);\n-\n-                int res = (Integer) encode.invoke(null, throwable, buffer, bufferSize);\n-\n-                if (res < 0) {\n-                    bufferSize = -res;\n-                } else {\n-                    try {\n-                        decode.invoke(null, buffer);\n-                        throw new AssertionError(\"expected decodeAndThrowThrowable to throw an exception\");\n-                    } catch (InvocationTargetException e) {\n-                        Throwable decoded = e.getCause();\n-                        assertThrowableEquals(throwable, decoded);\n-                    }\n-                    return;\n-                }\n-            } finally {\n-                unsafe.freeMemory(buffer);\n-            }\n-        }\n-    }\n-\n-    private static void assertThrowableEquals(Throwable original, Throwable decoded) {\n-        try {\n-            Assert.assertEquals(original == null, decoded == null);\n-            while (original != null) {\n-                if (Untranslatable.class.equals(original.getClass())) {\n-                    Assert.assertEquals(\"jdk.vm.ci.hotspot.TranslatedException\", decoded.getClass().getName());\n-                    Assert.assertEquals(\"jdk.vm.ci.hotspot.TranslatedException[jdk.vm.ci.hotspot.test.TestTranslatedException$Untranslatable]: test exception\", decoded.toString());\n-                    Assert.assertEquals(\"test exception\", original.getMessage());\n-                } else {\n-                    Assert.assertEquals(original.getClass().getName(), decoded.getClass().getName());\n-                    Assert.assertEquals(original.getMessage(), decoded.getMessage());\n-                }\n-                StackTraceElement[] originalStack = original.getStackTrace();\n-                StackTraceElement[] decodedStack = decoded.getStackTrace();\n-                Assert.assertEquals(originalStack.length, decodedStack.length);\n-                for (int i = 0, n = originalStack.length; i < n; ++i) {\n-                    StackTraceElement originalStackElement = originalStack[i];\n-                    StackTraceElement decodedStackElement = decodedStack[i];\n-                    Assert.assertEquals(originalStackElement.getClassLoaderName(), decodedStackElement.getClassLoaderName());\n-                    Assert.assertEquals(originalStackElement.getModuleName(), decodedStackElement.getModuleName());\n-                    Assert.assertEquals(originalStackElement.getClassName(), decodedStackElement.getClassName());\n-                    Assert.assertEquals(originalStackElement.getMethodName(), decodedStackElement.getMethodName());\n-                    Assert.assertEquals(originalStackElement.getFileName(), decodedStackElement.getFileName());\n-                    Assert.assertEquals(originalStackElement.getLineNumber(), decodedStackElement.getLineNumber());\n-                }\n-                original = original.getCause();\n-                decoded = decoded.getCause();\n-            }\n-        } catch (AssertionError e) {\n-            System.err.println(\"original:[\");\n-            original.printStackTrace(System.err);\n-            System.err.println(\"]\");\n-            System.err.println(\"decoded:[\");\n-            original.printStackTrace(System.err);\n-            System.err.println(\"]\");\n-            throw e;\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/TestTranslatedException.java","additions":0,"deletions":153,"binary":false,"changes":153,"status":"deleted"},{"patch":"@@ -717,0 +717,10 @@\n+    public static final String COUNTTRAILINGZEROS_VL = PREFIX + \"COUNTTRAILINGZEROS_VL\" + POSTFIX;\n+    static {\n+        superWordNodes(COUNTTRAILINGZEROS_VL, \"CountTrailingZerosV\");\n+    }\n+\n+    public static final String COUNTLEADINGZEROS_VL = PREFIX + \"COUNTLEADINGZEROS_VL\" + POSTFIX;\n+    static {\n+        superWordNodes(COUNTLEADINGZEROS_VL, \"CountLeadingZerosV\");\n+    }\n+\n@@ -1072,0 +1082,10 @@\n+    public static final String VECTOR_CAST_F2HF = PREFIX + \"VECTOR_CAST_F2HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_CAST_F2HF, \"VectorCastF2HF\");\n+    }\n+\n+    public static final String VECTOR_CAST_HF2F = PREFIX + \"VECTOR_CAST_HF2F\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_CAST_HF2F, \"VectorCastHF2F\");\n+    }\n+\n@@ -1097,0 +1117,5 @@\n+    public static final String VECTOR_TEST = PREFIX + \"VECTOR_TEST\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_TEST, \"VectorTest\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -142,0 +142,1 @@\n+                    \"UseZbb\",\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8269820\n+ * @summary C2 PhaseIdealLoop::do_unroll get wrong opaque node\n+ *\n+ * @run main\/othervm -Xbatch -XX:-TieredCompilation TestCanonicalLoopEntryOpaqueOrder\n+ *\n+ *\/\n+\n+public class TestCanonicalLoopEntryOpaqueOrder {\n+    static void test() {\n+        int ina8[] = new int[1478];\n+        int in2 = 136;\n+        long lo3 = 0L;\n+        try {\n+            for (int i = 0; i < 34; i++) {\n+                Math.log1p(1);\n+            }\n+        } catch (Exception e) {\n+            in2 = 1;\n+        }\n+\n+        for (int i = 0; i < in2; i++) {\n+            if (in2 > 10) {  \/\/ split if and create wrong opaque order\n+                for (int j = 0; j < in2; j++) {\n+                    lo3 -= 1L;\n+                }\n+            }\n+        }\n+    }\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 10000; i++) {\n+            test();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestCanonicalLoopEntryOpaqueOrder.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,408 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8290850\n+ * @summary Test cloning of pinned phi input nodes in create_new_if_for_predicate().\n+ * @run main\/othervm -Xcomp -XX:CompileCommand=compileonly,compiler.loopopts.TestCreateNewIfForPredicateCloning::*\n+ *                   compiler.loopopts.TestCreateNewIfForPredicateCloning\n+ *\/\n+\n+package compiler.loopopts;\n+\n+public class TestCreateNewIfForPredicateCloning {\n+    static int iFld, iFld2, iFld3, nonZero = 2, nonZero2 = 3;\n+    static boolean bFld = true, bFld2 = false;\n+    static int[] iArrFld = new int[100];\n+\n+    public static void main(String[] args) {\n+        try {\n+            testUnswitching();\n+            testLoopPredicatation();\n+            testLoopPredicatationComplex();\n+            testUnswitchingWithPredicates();\n+            testUnswitchingWithPredicatesDiv();\n+            testFuzzer1();\n+            testFuzzer2();\n+            testFuzzer3();\n+        } catch (Exception e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test case for the already fixed problem in 8271954: Calling create_new_if_for_predicate in\n+    \/\/ clone_predicate_to_unswitched_loop(). This does not crash anymore. But still use it as sanity test here with the\n+    \/\/ new fix.\n+    static void testUnswitching() {\n+        int x = 3;\n+\n+        \/\/ Block to delay precise type information to after CCP.\n+        int limit = 2;\n+        int constantAfterCCP = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            constantAfterCCP = 6; \/\/ Only known to be constant 6 after CCP.\n+        }\n+\n+        for (int i = 51; i > 9; i -= 3) {\n+            if (bFld) {\n+                x *= 6;\n+            }\n+            \/\/ (1) after unswitching:\n+            \/\/ if (bFld) {...}\n+            \/\/ Since we have a back to back if now with the same condition, we can merge them together by using the\n+            \/\/ split if optimization. That will create phi nodes for the UCT regions. Whenever we then call\n+            \/\/ create_new_if_for_predicate(), we would just reuse the old phi input for the newly create uncommon trap\n+            \/\/ projection. This is done when unswitching again to clone the predicates to the fast and slow loop. But\n+            \/\/ in the meantime, we have sunk x out of the loop with CastII nodes which are pinned on the old uncommon\n+            \/\/ trap projections. Just reusing these data nodes on the new uncommon trap proj leads to a broken graph:\n+            \/\/ the LCA of the old and new uncommon projection would be above the early control (control input of the\n+            \/\/ CastII nodes).\n+            \/\/\n+            \/\/ 8271954 fixes this when calling create_new_if_for_predicate() in\n+            \/\/ clone_predicate_to_unswitched_loop().\n+            x -= 5;\n+\n+            for (int j = 1; j < 10; j++) {\n+                if (bFld) { \/\/ Unswitching on bFld such that this condition is moved to (1)\n+                    continue;\n+                }\n+                x = 34; \/\/ Redefine x such that x is only used in UCT before this loop after split if.\n+                int y = 34;\n+                if (constantAfterCCP == 2) {\n+                    \/\/ Known to be never taken after CCP, so y will always be 34.\n+                    y = 35;\n+                }\n+                if (y == iFld) { \/\/ Folds to 34 == iFld after CCP and trigger another unswitching\n+                    continue;\n+                }\n+                iFld3 = 34; \/\/ Just another statement sucht that the second round of unswitching is done\n+\n+            }\n+        }\n+\n+        \/\/ This loop is only needed to delay the second round of unswitching for the inner loop above.\n+        for (int i = 0; i < iArrFld.length; i++) {\n+            iArrFld[i] = 3;\n+        }\n+    }\n+\n+    \/\/ Similar to testUnswitching() but we are calling create_new_if_for_predicate in Loop Predication for:\n+    \/\/ - Creating hoised range check predicate and skeleton predicate\n+    \/\/ - Creating invariant check predicate\n+    \/\/ which leads to a crash.\n+    static void testLoopPredicatation() {\n+        int x = 3;\n+\n+        \/\/ Block to delay precise type information to after CCP.\n+        int limit = 2;\n+        int constantAfterCCP = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            constantAfterCCP = 6; \/\/ Only known to be constant 6 after CCP.\n+        }\n+\n+        for (int i = 51; i > 9; i -= 3) {\n+            if (bFld) {\n+                x *= 6;\n+            }\n+            \/\/ (1) after unswitching:\n+            \/\/ if (bFld) {...}\n+            \/\/ Since we have a back to back if now with the same condition, we can merge them together by using the\n+            \/\/ split if optimization. That will create phi nodes for the UCT regions. Whenever we then call\n+            \/\/ create_new_if_for_predicate(), we would just reuse the old phi input for the newly create uncommon trap\n+            \/\/ projection. This is done when unswitching again to clone the predicates to the fast and slow loop. But\n+            \/\/ in the meantime, we have sunk x out of the loop with CastII nodes which are pinned on the old uncommon\n+            \/\/ trap projections. Just reusing these data nodes on the new uncommon trap proj leads to a broken graph:\n+            \/\/ the LCA of the old and new uncommon projection would be above the early control (control input of the\n+            \/\/ CastII nodes).\n+            x -= 5;\n+\n+            for (int j = 1; j < 10; j++) {\n+                if (bFld) { \/\/ Unswitching on bFld such that this condition is moved to (1)\n+                    continue;\n+                }\n+                x = 34; \/\/ Redefine x such that x is only used in UCT before this loop after split if.\n+                int y = iArrFld[j]; \/\/ Range check and null check will be hoisted after Unswitching and split if.\n+            }\n+        }\n+\n+        \/\/ This loop is only needed to delay the second round of unswitching for the inner loop above.\n+        for (int i = 0; i < iArrFld.length; i++) {\n+            iArrFld[i] = 3;\n+        }\n+    }\n+\n+    \/\/ Similar to testLoopPredicatation() but we are adding some computations for x such that we sink more nodes which\n+    \/\/ need to be cloned when calling create_new_if_for_predicate().\n+    static void testLoopPredicatationComplex() {\n+        int x = 3;\n+\n+        \/\/ Block to delay precise type information to after CCP.\n+        int limit = 2;\n+        int constantAfterCCP = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            constantAfterCCP = 6; \/\/ Only known to be constant 6 after CCP.\n+        }\n+\n+        for (int i = 51; i > 9; i -= 3) {\n+            if (bFld) {\n+                x *= 6;\n+            }\n+            \/\/ (1) after unswitching:\n+            \/\/ if (bFld) {...}\n+            \/\/ Since we have a back to back if now with the same condition, we can merge them together by using the\n+            \/\/ split if optimization. That will create phi nodes for the UCT regions. Whenever we then call\n+            \/\/ create_new_if_for_predicate(), we would just reuse the old phi input for the newly create uncommon trap\n+            \/\/ projection. This is done when unswitching again to clone the predicates to the fast and slow loop. But\n+            \/\/ in the meantime, we have sunk x out of the loop with CastII nodes which are pinned on the old uncommon\n+            \/\/ trap projections. Just reusing these data nodes on the new uncommon trap proj leads to a broken graph:\n+            \/\/ the LCA of the old and new uncommon projection would be above the early control (control input of the\n+            \/\/ CastII nodes).\n+            x -= 5;\n+\n+            \/\/ Add some more computations such that more nodes are sunk and therefore more nodes need to be cloned in\n+            \/\/ create_new_if_for_predicate().\n+            double d1 = 5 + (double) x;\n+            x = (int)((d1 + iFld2) - (d1 + iFld));\n+            d1 = 5 + (double) x;\n+            x = (int)((d1 + iFld2) - (d1 + iFld));\n+            d1 = 5 + (double) x;\n+            x = (int)((d1 + iFld2) - (d1 + iFld));\n+            d1 = 5 + (double) x;\n+            x = (int)((d1 + iFld2) - (d1 + iFld));\n+            d1 = 5 + (double) x;\n+            x = (int)((d1 + iFld2) - (d1 + iFld));\n+            d1 = 5 + (double) x;\n+            x = (int)((d1 + iFld2) - (d1 + iFld));\n+\n+            for (int j = 1; j < 10; j++) {\n+                if (bFld) { \/\/ Unswitching on bFld such that this condition is moved to (1)\n+                    continue;\n+                }\n+                x = 34; \/\/ Redefine x such that x is only used in UCT before this loop after split if.\n+                int y = iArrFld[j]; \/\/ Range check and null check will be hoisted after Unswitching and split if.\n+            }\n+        }\n+\n+        \/\/ This loop is only needed to delay the second round of unswitching for the inner loop above.\n+        for (int i = 0; i < iArrFld.length; i++) {\n+            iArrFld[i] = 3;\n+        }\n+    }\n+\n+    \/\/ Combination of testUnswitching() and testLoopPredicatation(): After creating predicates in loop predication,\n+    \/\/ we perform another round of loop unswitching where we additionally call create_new_if_for_predicate in\n+    \/\/ clone_skeleton_predicate_for_unswitched_loops() which currently leads to a crash.\n+    static void testUnswitchingWithPredicates() {\n+        int x = 3;\n+        if (iArrFld == null) {\n+            \/\/ Makes sure to get rid of null check for iArrFld to only create range check predicate\n+            return;\n+        }\n+        \/\/ Block to delay precise type information to after CCP.\n+        int limit = 2;\n+        int constantAfterCCP = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            constantAfterCCP = 6; \/\/ Only known to be constant 6 after CCP.\n+        }\n+\n+        for (int i = 51; i > 9; i -= 3) {\n+            if (bFld) {\n+                x *= 6;\n+            }\n+            \/\/ (1) after unswitching:\n+            \/\/ if (bFld) {...}\n+            \/\/ Since we have a back to back if now with the same condition, we can merge them together by using the\n+            \/\/ split if optimization. That will create phi nodes for the UCT regions. Whenever we then call\n+            \/\/ create_new_if_for_predicate(), we would just reuse the old phi input for the newly create uncommon trap\n+            \/\/ projection. This is done when unswitching again to clone the predicates to the fast and slow loop. But\n+            \/\/ in the meantime, we have sunk x out of the loop with CastII nodes which are pinned on the old uncommon\n+            \/\/ trap projections. Just reusing these data nodes on the new uncommon trap proj leads to a broken graph:\n+            \/\/ the LCA of the old and new uncommon projection would be above the early control (control input of the\n+            \/\/ CastII nodes).\n+            x -= 5;\n+\n+            for (int j = 1; j < 10; j++) {\n+                if (bFld) { \/\/ Unswitching on bFld such that this condition is moved to (1)\n+                    continue;\n+                }\n+                x = 34; \/\/ Redefine x such that x is only used in UCT before this loop after split if.\n+                int z = iArrFld[j]; \/\/ Range check and null check will be hoisted after Unswitching and split if.\n+                int y = 34;\n+                if (constantAfterCCP == 2) {\n+                    \/\/ Known to be never taken after CCP, so y will always be 34.\n+                    y = 35;\n+                }\n+                if (y == iFld) { \/\/ Folds to 34 == iFld after CCP and trigger another unswitching\n+                    continue;\n+                }\n+                iFld3 = 34; \/\/ Just another statement sucht that the second round of unswitching is done\n+            }\n+        }\n+\n+        \/\/ This loop is only needed to delay the second round of unswitching for the inner loop above.\n+        for (int i = 0; i < iArrFld.length; i++) {\n+            iArrFld[i] = 3;\n+        }\n+    }\n+\n+    \/\/ Same as testUnswitchingWithPredicates() but with a DivI node which has a control input which needs\n+    \/\/ to be rewired as well.\n+    static void testUnswitchingWithPredicatesDiv() {\n+        int x = 3;\n+        if (iArrFld == null) {\n+            \/\/ Makes sure to get rid of null check for iArrFld to only create range check predicate\n+            return;\n+        }\n+        \/\/ Block to delay precise type information to after CCP.\n+        int limit = 2;\n+        int constantAfterCCP = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            constantAfterCCP = 6; \/\/ Only known to be constant 6 after CCP.\n+        }\n+\n+        for (int i = 51; i > 9; i -= 3) {\n+            if (bFld) {\n+                x *= 6;\n+            }\n+            \/\/ (1) after unswitching:\n+            \/\/ if (bFld) {...}\n+            \/\/ Since we have a back to back if now with the same condition, we can merge them together by using the\n+            \/\/ split if optimization. That will create phi nodes for the UCT regions. Whenever we then call\n+            \/\/ create_new_if_for_predicate(), we would just reuse the old phi input for the newly create uncommon trap\n+            \/\/ projection. This is done when unswitching again to clone the predicates to the fast and slow loop. But\n+            \/\/ in the meantime, we have sunk x out of the loop with CastII nodes which are pinned on the old uncommon\n+            \/\/ trap projections. Just reusing these data nodes on the new uncommon trap proj leads to a broken graph:\n+            \/\/ the LCA of the old and new uncommon projection would be above the early control (control input of the\n+            \/\/ CastII nodes).\n+            x -= 5;\n+\n+            double d = 5.5f + (double) x;\n+            int a = (int)d;\n+            x = (a \/ nonZero) - (a \/ nonZero2);\n+\n+\n+            for (int j = 1; j < 10; j++) {\n+                if (bFld) { \/\/ Unswitching on bFld such that this condition is moved to (1)\n+                    continue;\n+                }\n+                x = 34; \/\/ Redefine x such that x is only used in UCT before this loop after split if.\n+                int z = iArrFld[j]; \/\/ Range check and null check will be hoisted after Unswitching and split if.\n+                int y = 34;\n+                if (constantAfterCCP == 2) {\n+                    \/\/ Known to be never taken after CCP, so y will always be 34.\n+                    y = 35;\n+                }\n+                if (y == iFld) { \/\/ Folds to 34 == iFld after CCP and trigger another unswitching\n+                    continue;\n+                }\n+                iFld3 = 34; \/\/ Just another statement sucht that the second round of unswitching is done\n+            }\n+        }\n+\n+        \/\/ This loop is only needed to delay the second round of unswitching for the inner loop above.\n+        for (int i = 0; i < iArrFld.length; i++) {\n+            iArrFld[i] = 3;\n+        }\n+    }\n+\n+    static void testFuzzer1() {\n+        int x = 0;\n+        int[] iArr = new int[400];\n+        boolean b = true;\n+        long[] lArr = new long[400];\n+        for (long l1 : lArr) {\n+            for (int i = 63; i > 1; i -= 3) {\n+                for (int j = 1; j < 4; j++) {\n+                    if (!b) {\n+                        x -= 5;\n+                    }\n+                }\n+                for (int j = 1; j < 4; j++) {\n+                    if (!b) {\n+                        x = iArr[j];\n+                    }\n+                    if (i == 0) {\n+                        l1 += 5;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    static void testFuzzer2() {\n+        int i, i1, i17 = 6, i18;\n+        short s1;\n+        boolean b2 = true;\n+        float f3;\n+        long lArr[][] = new long[400][];\n+        byte byArrFld[] = new byte[4];\n+        i = 1;\n+        do {\n+            for (i1 = 14; 6 < i1; i1--)\n+                ;\n+            i17 -= i18 = 1;\n+            while (i18 < 4) {\n+                i18 <<= i17 = 2;\n+                switch (i1) {\n+                    case 114:\n+                        s1 = byArrFld[1];\n+                        break;\n+                    case 116:\n+                        lArr[1][i18] = iFld;\n+                        if (b2)\n+                            continue;\n+                    case 118:\n+                        f3 = iFld;\n+                }\n+            }\n+            i++;\n+        } while (i < 10000);\n+    }\n+\n+    static void testFuzzer3() {\n+        int x = 8;\n+        int y = 4;\n+        for (int i : iArrFld) {\n+            x += 2;\n+            if (bFld) {\n+                x = 3;\n+            } else {\n+                y = 2;\n+            }\n+            for (int j = 0; j < 10; j++) {\n+                x = 0;\n+                y += 5;\n+                if (!bFld) {\n+                    iArrFld[1] = 5;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestCreateNewIfForPredicateCloning.java","additions":408,"deletions":0,"binary":false,"changes":408,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8297951\n+ * @summary Test that crashes because we do not emit skeleton predicates for normal If nodes for which a range check\n+ *          predicate is created in loop predication.\n+ * @requires vm.debug == true & vm.compiler2.enabled\n+ * @run main\/othervm -XX:-TieredCompilation -Xbatch -XX:-RangeCheckElimination -XX:+BailoutToInterpreterForThrows\n+                     compiler.loopopts.TestMissingSkeletonPredicateForIfNode\n+ *\/\n+package compiler.loopopts;\n+\n+public class TestMissingSkeletonPredicateForIfNode {\n+    static int iFld = 2, x;\n+    static short limit = 10;\n+\n+    public static void main(String[] args) throws Exception {\n+        for (int i = 0; i < 5000; i++) {\n+            try {\n+                test(i % 2 == 0, i % 3);\n+            } catch (Exception e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    public static void test(boolean flag, int arg) throws Exception {\n+        int sum = 1;\n+        int[] iArr2 = new int[4];\n+        RuntimeException r = new RuntimeException();\n+\n+        for (int i = 0; i < limit; i+=2) { \/\/ Pre\/main\/post + Unrolled once. This results in the following type for the iv phi i: [2..SHORT_MAX]\n+            x = 5 \/ sum;\n+            if (Integer.compareUnsigned(i, iArr2.length) < 0) { \/\/ (**) Loop predication creates a RC predicate for this check\n+                \/\/ After unrolling, we have:\n+                \/\/\n+                \/\/ iArr2[i]\n+                \/\/ iArr2[i+2]\n+                \/\/\n+                \/\/ The type of iArr2[i+2] is [4..SHORT_MAX+2] (we need limit to be short such that we do not have an integer overflow\n+                \/\/ which would set the type to int). However, the type of the CastII node for the index i+2 is [0..3] because its size\n+                \/\/ is only 4. Since the type of i+2 is outside the range of the CastII node, the CastII node is replaced by top and\n+                \/\/ some of the data nodes and memory nodes die. We are left with a broken graph and later assert because of that.\n+                iFld += iArr2[i]; \/\/ RangeCheck node is removed because it shares the same bool as the If (**).\n+                sum += iFld;\n+            } else {\n+                \/\/ Emits an UCT with -XX:+BailoutToInterpreterForThrows and therefore the If (**) satisfies the condition of being a\n+                \/\/ range check if with one of its blocks being an UCT.\n+                throw r;\n+            }\n+            if (i > 50) {\n+                break;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestMissingSkeletonPredicateForIfNode.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+super public class TestOnlyInfiniteLoops\n+{\n+    public Method \"<init>\":\"()V\"\n+    stack 2 locals 1\n+    {\n+        aload_0;\n+        invokespecial  Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+    }\n+\n+    static Method test_simple:\"(III)I\"\n+    stack 200 locals 10\n+    {\n+    \/\/ Nested infinite loop, where inner loop eventually\n+    \/\/ looses exit to outer loop. Then, the inner loop\n+    \/\/ floats outside the inner loop. The entry from\n+    \/\/ outer to inner loop now becomes an exit for the\n+    \/\/ outer loop, where it now enters the next loop, that\n+    \/\/ used to be the inner loop.\n+        iconst_0;\n+        istore     9;\n+\n+        iload      0;\n+        ifeq LEND; \/\/ skip\n+\n+    LOOP1:\n+        iload      1;\n+        ifeq LOOP1; \/\/ dominates\n+    LOOP2:\n+        \/\/ SKIP: prevent loop-exit from becoming zero-trip guard\n+        iload      2;\n+        ifeq SKIP;\n+        iinc       9, 1;\n+    SKIP:\n+        iload      1;\n+        ifeq LOOP1; \/\/ is dominated\n+        goto LOOP2;\n+\n+    LEND:\n+        iload      9;\n+        ireturn;\n+    }\n+    static Method test_irreducible:\"(IIII)V\"\n+    stack 200 locals 200\n+    {\n+        iload_0;\n+        ifeq LEND; \/\/ skip\n+\n+    L1:\n+        iload      1;\n+        ifgt MERGE;\n+    L2:\n+        iload      2;\n+        ifge MERGE;\n+        goto L1;\n+\n+    MERGE:\n+        nop;\n+    LOOP:\n+        iload      3;\n+        ifle L2;\n+        iconst_0; \/\/ always true\n+        ifeq LOOP;\n+        iconst_0; \/\/ always true\n+        ifeq LOOP;\n+    INFTY:\n+        goto INFTY; \/\/ infinite loop\n+\n+    LEND:\n+        return;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestOnlyInfiniteLoops.jasm","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8297642\n+ * @compile TestOnlyInfiniteLoops.jasm\n+ * @summary Nested irreducible loops, where the inner loop floats out of the outer\n+ * @run main\/othervm\n+ *      -XX:CompileCommand=compileonly,TestOnlyInfiniteLoops::test*\n+ *      -XX:-TieredCompilation -Xcomp\n+ *      TestOnlyInfiniteLoopsMain\n+ *\n+ * @test\n+ * @bug 8297642\n+ * @compile TestOnlyInfiniteLoops.jasm\n+ * @summary Nested irreducible loops, where the inner loop floats out of the outer\n+ * @run main\/othervm\n+ *      -XX:CompileCommand=compileonly,TestOnlyInfiniteLoops::test*\n+ *      -XX:-TieredCompilation -Xcomp\n+ *      -XX:PerMethodTrapLimit=0\n+ *      TestOnlyInfiniteLoopsMain\n+*\/\n+\n+public class TestOnlyInfiniteLoopsMain {\n+    public static void main(String[] args) {\n+        TestOnlyInfiniteLoops t = new TestOnlyInfiniteLoops();\n+        System.out.println(\"test_simple\");\n+        t.test_simple(0, 0, 0);\n+        System.out.println(\"test_irreducible\");\n+        t.test_irreducible(0, 0, 0, 0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestOnlyInfiniteLoopsMain.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.vectorapi;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.VectorMask;\n+\n+\/*\n+ * @test\n+ * @bug 8292289\n+ * @summary Test idealization of VectorTest intrinsics to eliminate\n+ *          the materialization of the result as an int\n+ * @modules jdk.incubator.vector\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" & vm.cpu.features ~= \".*sse4.*\" & (vm.opt.UseSSE == \"null\" | vm.opt.UseSSE > 3))\n+ *           | os.arch == \"aarch64\"\n+ * @run driver compiler.vectorapi.TestVectorTest\n+ *\/\n+public class TestVectorTest {\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\");\n+    }\n+\n+    @DontInline\n+    public int call() { return 1; }\n+\n+    @Test\n+    @IR(failOn = {IRNode.CMP_I, IRNode.CMOVE_I})\n+    @IR(counts = {IRNode.VECTOR_TEST, \"1\"})\n+    public int branch(long maskLong) {\n+        var mask = VectorMask.fromLong(ByteVector.SPECIES_PREFERRED, maskLong);\n+        return mask.allTrue() ? call() : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.CMP_I})\n+    @IR(counts = {IRNode.VECTOR_TEST, \"1\", IRNode.CMOVE_I, \"1\"})\n+    public int cmove(long maskLong) {\n+        var mask = VectorMask.fromLong(ByteVector.SPECIES_PREFERRED, maskLong);\n+        return mask.allTrue() ? 1 : 0;\n+    }\n+\n+    @Run(test = {\"branch\", \"cmove\"})\n+    public void run() {\n+        branch(-1);\n+        branch(100);\n+        cmove(-1);\n+        cmove(100);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorTest.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8294588\n+ * @summary Auto-vectorize Float.floatToFloat16, Float.float16ToFloat APIs\n+ * @requires vm.compiler2.enabled\n+ * @requires os.simpleArch == \"x64\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.vectorization.TestFloatConversionsVector\n+ *\/\n+\n+package compiler.vectorization;\n+\n+import compiler.lib.ir_framework.*;\n+\n+public class TestFloatConversionsVector {\n+  private static final int ARRLEN = 1024;\n+  private static final int ITERS  = 11000;\n+  private static float  [] finp;\n+  private static short  [] sout;\n+  private static short  [] sinp;\n+  private static float  [] fout;\n+\n+  public static void main(String args[]) {\n+      TestFramework.runWithFlags(\"-XX:-TieredCompilation\",\n+                                 \"-XX:CompileThresholdScaling=0.3\");\n+      System.out.println(\"PASSED\");\n+  }\n+\n+  @Test\n+  @IR(counts = {IRNode.VECTOR_CAST_F2HF, \"> 0\"}, applyIfCPUFeatureOr = {\"avx512f\", \"true\", \"f16c\", \"true\"})\n+  public void test_float_float16(short[] sout, float[] finp) {\n+      for (int i = 0; i < finp.length; i++) {\n+          sout[i] = Float.floatToFloat16(finp[i]);\n+      }\n+  }\n+\n+  @Run(test = {\"test_float_float16\"}, mode = RunMode.STANDALONE)\n+  public void kernel_test_float_float16() {\n+      finp = new float[ARRLEN];\n+      sout = new short[ARRLEN];\n+\n+      for (int i = 0; i < ARRLEN; i++) {\n+          finp[i] = (float) i * 1.4f;\n+      }\n+\n+      for (int i = 0; i < ITERS; i++) {\n+         test_float_float16(sout, finp);\n+      }\n+  }\n+\n+  @Test\n+  @IR(counts = {IRNode.VECTOR_CAST_HF2F, \"> 0\"}, applyIfCPUFeatureOr = {\"avx512f\", \"true\", \"f16c\", \"true\"})\n+  public void test_float16_float(float[] fout, short[] sinp) {\n+      for (int i = 0; i < sinp.length; i++) {\n+          fout[i] = Float.float16ToFloat(sinp[i]);\n+      }\n+  }\n+\n+  @Run(test = {\"test_float16_float\"}, mode = RunMode.STANDALONE)\n+  public void kernel_test_float16_float() {\n+      sinp = new short[ARRLEN];\n+      fout = new float[ARRLEN];\n+\n+      for (int i = 0; i < ARRLEN; i++) {\n+          sinp[i] = (short)i;\n+      }\n+\n+      for (int i = 0; i < ITERS; i++) {\n+          test_float16_float(fout , sinp);\n+      }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloatConversionsVector.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @key randomness\n+* @summary Test vectorization of numberOfTrailingZeros\/numberOfLeadingZeros for Long\n+* @requires vm.compiler2.enabled\n+* @requires (os.simpleArch == \"x64\" & vm.cpu.features ~= \".*avx2.*\") |\n+*           (os.simpleArch == \"aarch64\" & vm.cpu.features ~= \".*sve.*\" & (vm.opt.UseSVE == \"null\" | vm.opt.UseSVE > 0))\n+* @library \/test\/lib \/\n+* @run driver compiler.vectorization.TestNumberOfContinuousZeros\n+*\/\n+\n+package compiler.vectorization;\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.test.lib.Asserts;\n+\n+public class TestNumberOfContinuousZeros {\n+    private long[] input;\n+    private int[] output;\n+    private static final int LEN = 1024;\n+    private Random rng;\n+\n+    public static void main(String args[]) {\n+        TestFramework.run();\n+    }\n+\n+    public TestNumberOfContinuousZeros() {\n+        input = new long[LEN];\n+        output = new int[LEN];\n+        rng = new Random(42);\n+        for (int i = 0; i < LEN; ++i) {\n+            input[i] = rng.nextLong();\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.COUNTTRAILINGZEROS_VL, \"> 0\"})\n+    public void vectorizeNumberOfTrailingZeros() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = Long.numberOfTrailingZeros(input[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.COUNTLEADINGZEROS_VL, \"> 0\"})\n+    public void vectorizeNumberOfLeadingZeros() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = Long.numberOfLeadingZeros(input[i]);\n+        }\n+    }\n+\n+    @Run(test = {\"vectorizeNumberOfTrailingZeros\", \"vectorizeNumberOfLeadingZeros\"})\n+    public void checkResult() {\n+        vectorizeNumberOfTrailingZeros();\n+        for (int i = 0; i < LEN; ++i) {\n+            Asserts.assertEquals(output[i], Long.numberOfTrailingZeros(input[i]));\n+        }\n+        vectorizeNumberOfLeadingZeros();\n+        for (int i = 0; i < LEN; ++i) {\n+            Asserts.assertEquals(output[i], Long.numberOfLeadingZeros(input[i]));\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestNumberOfContinuousZeros.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -28,2 +28,2 @@\n-* @requires vm.cpu.features ~= \".*avx512bw.*\" | (vm.cpu.features ~= \".*sve.*\" & (vm.opt.UseSVE == \"null\" | vm.opt.UseSVE > 0))\n-* @requires os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+* @requires ((os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\") & vm.cpu.features ~= \".*avx512bw.*\") |\n+*           os.simpleArch == \"aarch64\"\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestPopCountVectorLong.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,2 +28,1 @@\n- * @requires vm.cpu.features ~= \".*avx2.*\"\n- * @requires os.simpleArch == \"x64\"\n+ * @requires (os.simpleArch == \"x64\" & vm.cpu.features ~= \".*avx2.*\") | os.simpleArch == \"AArch64\"\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestReverseBytes.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorization;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8297689\n+ * @summary Test miscompilation of reverseBytes call from subword types\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @run driver compiler.vectorization.TestSubwordReverseBytes\n+ *\/\n+\n+public class TestSubwordReverseBytes {\n+    private static final int SIZE = 32000;\n+\n+    private static   int[] idx = new int[SIZE];\n+    private static short[] rbs = new short[SIZE];\n+    private static  char[] rbc = new char[SIZE];\n+\n+    static {\n+        for (int i = 0; i < SIZE; i++) {\n+            idx[i] = i;\n+        }\n+        for (short s = 0; s < SIZE; s++) {\n+            rbs[s] = Short.reverseBytes(s);\n+        }\n+        for (char c = 0; c < SIZE; c++) {\n+            rbc[c] = Character.reverseBytes(c);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.REVERSE_BYTES_V})\n+    public static int[] testShortReverseBytes() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+           res[i] = Short.reverseBytes((short) idx[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"testShortReverseBytes\")\n+    public static void testShort() {\n+        int[] res = testShortReverseBytes();\n+        for (int i = 0; i < SIZE; i++) {\n+            if (res[i] != rbs[i]) {\n+                throw new RuntimeException(\"Wrong result: expected = \" +\n+                        (int) rbs[i] + \", actual = \" + res[i]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.REVERSE_BYTES_V})\n+    public static int[] testCharacterReverseBytes() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+           res[i] = Character.reverseBytes((char) idx[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"testCharacterReverseBytes\")\n+    public static void testChar() {\n+        int[] res = testCharacterReverseBytes();\n+        for (int i = 0; i < SIZE; i++) {\n+            if (res[i] != rbc[i]) {\n+                throw new RuntimeException(\"Wrong result: expected = \" +\n+                        (int) rbc[i] + \", actual = \" + res[i]);\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestSubwordReverseBytes.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -50,0 +50,1 @@\n+    private int[] idx;\n@@ -55,0 +56,1 @@\n+        idx = new int[SIZE];\n@@ -59,0 +61,1 @@\n+            idx[i] = i;\n@@ -192,0 +195,19 @@\n+\n+    \/\/ ------------- ReverseBytes -------------\n+    @Test\n+    public char[] reverseBytesWithChar() {\n+        char[] res = new char[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = Character.reverseBytes(a[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] reverseBytesWithInt() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = Character.reverseBytes((char) idx[i]);\n+        }\n+        return res;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicCharOpTest.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+    private int[] idx;\n@@ -55,0 +56,1 @@\n+        idx = new int[SIZE];\n@@ -59,0 +61,1 @@\n+            idx[i] = i;\n@@ -190,0 +193,19 @@\n+\n+    \/\/ ------------- ReverseBytes -------------\n+    @Test\n+    public short[] reverseBytesWithShort() {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = Short.reverseBytes(a[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] reverseBytesWithInt() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = Short.reverseBytes((short) idx[i]);\n+        }\n+        return res;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicShortOpTest.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -99,1 +99,2 @@\n-                     new GCBeanDescription(\"G1 Old Generation\",   new String[] {\"G1 Eden Space\", \"G1 Survivor Space\", \"G1 Old Gen\"}));\n+                     new GCBeanDescription(\"G1 Old Generation\",   new String[] {\"G1 Eden Space\", \"G1 Survivor Space\", \"G1 Old Gen\"}),\n+                     new GCBeanDescription(\"G1 Concurrent GC\",    new String[] {\"G1 Old Gen\"}));\n","filename":"test\/hotspot\/jtreg\/gc\/TestMemoryMXBeansAndPoolsPresence.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.g1;\n+\n+\/*\n+ * @test\n+ * @bug 8297186\n+ * @requires vm.gc.G1\n+ * @library \/test\/lib\n+ * @run driver gc.g1.TestOneEdenRegionAfterGC\n+ * @summary Test that on a very small heap g1 with very little data (smaller than region size)\n+ *          will use at least one eden region after gc to avoid full gcs.\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestOneEdenRegionAfterGC {\n+  private static long YoungGenSize = 32 * 1024 * 1024;\n+\n+  private static OutputAnalyzer run() throws Exception {\n+    ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+      \"-Xbootclasspath\/a:.\",\n+      \"-Xmn\" + YoungGenSize,\n+      \"-Xmx512M\",\n+      \"-Xms512M\",\n+      \"-XX:G1HeapRegionSize=32M\",\n+      \"-XX:+UseG1GC\",\n+      \"-Xlog:gc,gc+ergo*=trace\",\n+      TestOneEdenRegionAfterGC.Allocate.class.getName(),\n+      \"\" + YoungGenSize);\n+    return new OutputAnalyzer(pb.start());\n+  }\n+\n+  public static void main(String args[]) throws Exception {\n+    OutputAnalyzer out = run();\n+\n+    out.shouldMatch(\".*Pause Young \\\\(Normal\\\\).*\");\n+    out.shouldNotMatch(\".*Pause Full.*\");\n+  }\n+\n+  public static class Allocate {\n+    public static Object dummy;\n+\n+    public static void main(String [] args) throws Exception {\n+      if (args.length != 1) {\n+        throw new IllegalArgumentException(\"Usage: <YoungGenSize>\");\n+      }\n+\n+      long youngGenSize = Long.parseLong(args[0]);\n+      triggerYoungGCs(youngGenSize);\n+    }\n+\n+    public static void triggerYoungGCs(long youngGenSize) {\n+      long approxAllocSize = 32 * 1024;\n+      long numAllocations  = 2 * youngGenSize \/ approxAllocSize;\n+\n+      for (long i = 0; i < numAllocations; i++) {\n+        dummy = new byte[(int)approxAllocSize];\n+      }\n+    }\n+  }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestOneEdenRegionAfterGC.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2022, Alibaba Group Holding Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.g1;\n+\n+\/*\n+ * @test TestRemarkCleanupMXBean\n+ * @bug 8297247\n+ * @summary Test that Remark and Cleanup are correctly reported by\n+ *          a GarbageCollectorMXBean\n+ * @requires vm.gc.G1\n+ * @library \/test\/lib \/\n+ * @build   jdk.test.whitebox.WhiteBox\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run     driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -XX:+UseG1GC -Xlog:gc\n+ *                   -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   gc.g1.TestRemarkCleanupMXBean\n+ *\/\n+\n+import java.lang.management.GarbageCollectorMXBean;\n+import java.lang.management.ManagementFactory;\n+import jdk.test.whitebox.WhiteBox;\n+import jdk.test.whitebox.gc.GC;\n+import gc.testlibrary.g1.MixedGCProvoker;\n+\n+public class TestRemarkCleanupMXBean {\n+    public static void main(String[] args) throws Exception {\n+        GarbageCollectorMXBean g1ConcGCBean = null;\n+        String expectedName = \"G1 Concurrent GC\";\n+        for (GarbageCollectorMXBean bean : ManagementFactory.getGarbageCollectorMXBeans()) {\n+            if (expectedName.equals(bean.getName())) {\n+                g1ConcGCBean = bean;\n+                break;\n+            }\n+        }\n+        if (g1ConcGCBean == null) {\n+            throw new RuntimeException(\"Unable to find GC bean: \" + expectedName);\n+        }\n+\n+        long before = g1ConcGCBean.getCollectionCount();\n+        MixedGCProvoker.provokeConcMarkCycle();\n+        long after = g1ConcGCBean.getCollectionCount();\n+\n+        if (after >= before + 2) { \/\/ Must report a Remark and a Cleanup\n+            System.out.println(g1ConcGCBean.getName() + \" reports a difference \" +\n+                               after + \" - \" + before + \" = \" + (after - before));\n+        } else {\n+            throw new RuntimeException(\"Remark or Cleanup not reported by \" +\n+                                       g1ConcGCBean.getName());\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestRemarkCleanupMXBean.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -107,0 +107,4 @@\n+                } else if (info.getGcName().startsWith(\"G1\")) {\n+                    if (\"end of minor GC\".equals(info.getGcAction())) {\n+                        gcCount++;\n+                    }\n","filename":"test\/hotspot\/jtreg\/gc\/stringdedup\/TestStringDeduplicationTools.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -76,2 +76,1 @@\n-     * Provoke at least one mixed gc by starting a marking cycle, waiting for its end and triggering two GCs.\n-     * @param liveOldObjects The objects supposed to survive this marking cycle.\n+     * Provoke a concurrent mark cycle, and wait for it to end.\n@@ -79,1 +78,1 @@\n-    public static void provokeMixedGC(List<byte[]> liveOldObjects) {\n+    public static void provokeConcMarkCycle() {\n@@ -83,0 +82,8 @@\n+    }\n+\n+    \/**\n+     * Provoke at least one mixed gc by starting a marking cycle, waiting for its end and triggering two GCs.\n+     * @param liveOldObjects The objects supposed to survive this marking cycle.\n+     *\/\n+    public static void provokeMixedGC(List<byte[]> liveOldObjects) {\n+        provokeConcMarkCycle();\n","filename":"test\/hotspot\/jtreg\/gc\/testlibrary\/g1\/MixedGCProvoker.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,40 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/*\n- * Note: This runs the Arena portion of the gtests with UseMallocOnly\n- * (restricted to debug since UseMallocOnly is debug-only)\n- *\/\n-\n-\/* @test\n- * @bug 8271242\n- * @summary Run arena tests with UseMallocOnly\n- * @requires vm.debug\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.xml\n- * @requires vm.flagless\n- * @run main\/native GTestWrapper --gtest_filter=Arena* -XX:+UseMallocOnly\n- *\/\n","filename":"test\/hotspot\/jtreg\/gtest\/ArenaGtests.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8007475\n- * @summary Test memory stomp in stack map test\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+UseMallocOnly StackMapFrameTest\n- *\/\n-public class StackMapFrameTest {\n-\n-  public static void foo() {\n-    Object o = new Object();\n-  }\n-\n-  public static void main(String args[]) {\n-    for (int i = 0; i < 25000; i++) {\n-      foo();\n-    }\n-  }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/8007475\/StackMapFrameTest.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -80,1 +80,1 @@\n-        if (ver != 64) {\n+        if (ver != latestMajor) {\n@@ -84,1 +84,1 @@\n-                \"Expected 0:64, but got \" + got_minor + \":\" + got_major + \" for primitive array\");\n+                \"Expected 0:\" + latestMajor + \", but got \" + got_minor + \":\" + got_major + \" for primitive array\");\n","filename":"test\/hotspot\/jtreg\/runtime\/ClassFile\/ClassFileVersionTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -64,1 +64,0 @@\n-            {\"EnableWaitForParallelLoad\", \"false\"},\n","filename":"test\/hotspot\/jtreg\/runtime\/CommandLine\/VMDeprecatedOptions.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,2 +28,1 @@\n- * @bug 8065895\n- * @summary Synchronous signals during error reporting may terminate or hang VM process\n+ * @summary Check secondary error handling\n@@ -33,1 +32,0 @@\n- * @author Thomas Stuefe (SAP)\n@@ -36,1 +34,12 @@\n- * @run driver SecondaryErrorTest\n+ * @run driver SecondaryErrorTest no_callstacks\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Check secondary error handling\n+ * @library \/test\/lib\n+ * @requires vm.debug\n+ * @requires os.family != \"windows\"\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver SecondaryErrorTest with_callstacks\n@@ -39,1 +48,0 @@\n-import java.io.BufferedReader;\n@@ -41,2 +49,1 @@\n-import java.io.FileInputStream;\n-import java.io.InputStreamReader;\n+import java.util.ArrayList;\n@@ -52,0 +59,22 @@\n+\n+    boolean with_callstacks = false;\n+    if (args.length != 1) {\n+      throw new IllegalArgumentException(\"Missing argument\");\n+    } else if (args[0].equals(\"with_callstacks\")) {\n+      with_callstacks = true;\n+    } else if (args[0].equals(\"no_callstacks\")) {\n+      with_callstacks = false;\n+    } else {\n+      throw new IllegalArgumentException(\"unknown argument (\" + args[0] + \")\");\n+    }\n+\n+    \/\/ How this works:\n+    \/\/ The test will fault with SIGFPE (ErrorHandlerTest=15) and then, during error handling,\n+    \/\/ fault twice with SIGSEGV (TestCrashInErrorHandler=14). The point is not only to test\n+    \/\/ secondary crashes, but secondary crashes with a *different* error signal. This should\n+    \/\/ be handled correctly and not hang\/end the process (so the signal mask must be set correctly).\n+    \/\/ See JDK-8065895.\n+    \/\/ We do this twice, to check that secondary signal handling works repeatedly.\n+    \/\/ We also check, optionally, that +ErrorLogSecondaryErrorDetails produces callstacks for\n+    \/\/ the secondary error.\n+\n@@ -58,0 +87,1 @@\n+        \"-XX:\" + (with_callstacks ? \"+\" : \"-\") + \"ErrorLogSecondaryErrorDetails\",\n@@ -75,6 +105,17 @@\n-    Pattern [] pattern = new Pattern[] {\n-        Pattern.compile(\"Will crash now \\\\(TestCrashInErrorHandler=14\\\\)...\"),\n-        Pattern.compile(\"\\\\[error occurred during error reporting \\\\(test secondary crash 1\\\\).*\\\\]\"),\n-        Pattern.compile(\"Will crash now \\\\(TestCrashInErrorHandler=14\\\\)...\"),\n-        Pattern.compile(\"\\\\[error occurred during error reporting \\\\(test secondary crash 2\\\\).*\\\\]\"),\n-    };\n+    ArrayList<Pattern> patternlist = new ArrayList<>();\n+    patternlist.add(Pattern.compile(\"Will crash now \\\\(TestCrashInErrorHandler=14\\\\)...\"));\n+    patternlist.add(Pattern.compile(\"\\\\[error occurred during error reporting \\\\(test secondary crash 1\\\\).*\\\\]\"));\n+    if (with_callstacks) {\n+        patternlist.add(Pattern.compile(\"\\\\[siginfo:.*\\\\(SIGSEGV\\\\).*\\\\]\"));\n+        patternlist.add(Pattern.compile(\"\\\\[stack: Native frames:.*\"));\n+        patternlist.add(Pattern.compile(\".*VMError::controlled_crash.*\"));\n+    }\n+    \/\/ and again, to see that repeated error reporting steps work\n+    patternlist.add(Pattern.compile(\"Will crash now \\\\(TestCrashInErrorHandler=14\\\\)...\"));\n+    patternlist.add(Pattern.compile(\"\\\\[error occurred during error reporting \\\\(test secondary crash 2\\\\).*\\\\]\"));\n+    if (with_callstacks) {\n+        patternlist.add(Pattern.compile(\"\\\\[siginfo:.*\\\\(SIGSEGV\\\\).*\\\\]\"));\n+        patternlist.add(Pattern.compile(\"\\\\[stack: Native frames:.*\"));\n+        patternlist.add(Pattern.compile(\".*VMError::controlled_crash.*\"));\n+    }\n+    Pattern[] pattern = patternlist.toArray(new Pattern[] {});\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/SecondaryErrorTest.java","additions":54,"deletions":13,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+        opts.addSuffix(\"-XX:MetaspaceSize=500M\"); \/\/ avoid heap fragmentation by avoiding metaspace-limit induced GCs\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/LotsOfClasses.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-           checkFrames(Thread.currentThread(), false, 9);\n+           checkFrames(Thread.currentThread(), false, 10);\n@@ -82,1 +82,1 @@\n-        checkFrames(vThread1, false, 14);\n+        checkFrames(vThread1, false, 15);\n@@ -88,1 +88,1 @@\n-            checkFrames(Thread.currentThread(), false, 5);\n+            checkFrames(Thread.currentThread(), false, 6);\n@@ -104,1 +104,1 @@\n-        checkFrames(pThread1, false, 5);\n+        checkFrames(pThread1, false, 6);\n@@ -121,1 +121,1 @@\n-    \/\/ Each stack has 2 frames additional to expected depth\n+    \/\/ Each stack has 3 frames additional to expected depth\n@@ -124,1 +124,2 @@\n-    static final int ADDITIONAL_STACK_COUNT = 2;\n+    \/\/ 2: java\/lang\/Thread: runWith()V\n+    static final int ADDITIONAL_STACK_COUNT = 3;\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetFrameCount\/framecnt01\/framecnt01.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -39,1 +39,2 @@\n-    {\"Ljava\/lang\/VirtualThread;\", \"run\", \"(Ljava\/lang\/Runnable;)V\"}\n+    {\"Ljava\/lang\/VirtualThread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n+    {\"Ljava\/lang\/VirtualThread;\", \"run\", \"(Ljava\/lang\/Runnable;)V\"},\n@@ -47,1 +48,2 @@\n-    {\"Ljava\/lang\/Thread;\", \"run\", \"()V\"}\n+    {\"Ljava\/lang\/Thread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n+    {\"Ljava\/lang\/Thread;\", \"run\", \"()V\"},\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/GetStackTraceCurrentThreadTest\/libGetStackTraceCurrentThreadTest.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,1 +38,2 @@\n-    {\"Ljava\/lang\/Thread;\", \"run\", \"()V\"}\n+    {\"Ljava\/lang\/Thread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n+    {\"Ljava\/lang\/Thread;\", \"run\", \"()V\"},\n@@ -46,0 +47,1 @@\n+    {\"Ljava\/lang\/VirtualThread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/getstacktr03\/libgetstacktr03.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+    {\"Ljava\/lang\/Thread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n@@ -51,0 +52,1 @@\n+    {\"Ljava\/lang\/VirtualThread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/getstacktr04\/libgetstacktr04.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+    {\"Ljava\/lang\/Thread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n@@ -51,0 +52,1 @@\n+    {\"Ljava\/lang\/VirtualThread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/getstacktr05\/libgetstacktr05.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+    {\"Ljava\/lang\/Thread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n@@ -55,0 +56,1 @@\n+    {\"Ljava\/lang\/VirtualThread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/getstacktr06\/libgetstacktr06.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+    {\"Ljava\/lang\/Thread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n@@ -58,0 +59,1 @@\n+    {\"Ljava\/lang\/VirtualThread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/getstacktr07\/libgetstacktr07.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+    {\"Ljava\/lang\/Thread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n@@ -59,0 +60,1 @@\n+    {\"Ljava\/lang\/VirtualThread;\", \"runWith\", \"(Ljava\/lang\/Object;Ljava\/lang\/Runnable;)V\"},\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/getstacktr08\/libgetstacktr08.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n- * debuggee's static field which is declared as final.<br>\n+ * debuggee's final field.\n@@ -65,1 +65,0 @@\n-    static final int FLDS_NUM = 9;\n@@ -67,0 +66,1 @@\n+        \/\/ static final fields\n@@ -75,1 +75,11 @@\n-        \"sStrFld\"\n+        \"sStrFld\",\n+        \/\/ instance final fields\n+        \"iByteFld\",\n+        \"iShortFld\",\n+        \"iIntFld\",\n+        \"iLongFld\",\n+        \"iFloatFld\",\n+        \"iDoubleFld\",\n+        \"iCharFld\",\n+        \"iBooleanFld\",\n+        \"iStrFld\"\n@@ -144,1 +154,1 @@\n-            for (int i=0; i<FLDS_NUM; i++) {\n+            for (int i = 0; i < DEBUGGEE_FLDS.length; i++) {\n@@ -147,1 +157,1 @@\n-                    log.display(\"\\nTrying to set value for the static final field \\\"\"\n+                    log.display(\"\\nTrying to set value for the final field \\\"\"\n@@ -153,1 +163,1 @@\n-                        + \"\\n\\twhen attempted to set value for the static final field \\\"\"\n+                        + \"\\n\\twhen attempted to set value for the final field \\\"\"\n@@ -164,1 +174,1 @@\n-                        + \"\\n\\twhen attempted to set value for the static final field \\\"\"\n+                        + \"\\n\\twhen attempted to set value for the final field \\\"\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ObjectReference\/setValue\/setvalue004.java","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,1 @@\n- *     attempts to set value of debuggee's static field which\n- *     is declared as final.\n+ *     attempts to set value of debuggee's final field.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ObjectReference\/setValue\/setvalue004\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,11 @@\n+    \/\/ tested instance final fields\n+    final byte    iByteFld = 127;\n+    final short   iShortFld = -32768;\n+    final int     iIntFld = 2147483647;\n+    final long    iLongFld = 9223372036854775807L;\n+    final float   iFloatFld = 5.1F;\n+    final double  iDoubleFld = 6.2D;\n+    final char    iCharFld = 'a';\n+    final boolean iBooleanFld = false;\n+    final String  iStrFld = \"instance field\";\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ObjectReference\/setValue\/setvalue004t.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-requiredVersion=7.1+1\n+requiredVersion=7.1.1+1\n","filename":"test\/jaxp\/TEST.ROOT","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,67 @@\n+java\/lang\/StackWalker\/AcrossThreads.java 8297235 generic-x64\n+java\/math\/BigInteger\/BigIntegerParallelMultiplyTest.java 8297235 generic-x64\n+java\/util\/Arrays\/SetAllTest.java 8297235 generic-x64\n+java\/util\/Arrays\/Sorting.java 8297235 generic-x64\n+java\/util\/Arrays\/largeMemory\/ParallelPrefix.java 8297235 generic-x64\n+java\/util\/BitSet\/stream\/BitSetStreamTest.java 8297235 generic-x64\n+java\/util\/Collection\/IteratorMicroBenchmark.java 8297235 generic-x64\n+java\/util\/Collections\/UnmodifiableMapEntrySet.java 8297235 generic-x64\n+java\/util\/DoubleStreamSums\/CompensatedSums.java 8297235 generic-x64\n+java\/util\/Random\/RandomTest.java 8297235 generic-x64\n+java\/util\/Scanner\/ScannerStreamTest.java 8297235 generic-x64\n+java\/util\/concurrent\/forkjoin\/AsyncShutdownNow.java 8297235 generic-x64\n+java\/util\/concurrent\/forkjoin\/AsyncShutdownNowInvokeAny.java 8297235 generic-x64\n+java\/util\/concurrent\/forkjoin\/AsyncShutdownNowInvokeAnyRace.java 8297235 generic-x64\n+java\/util\/concurrent\/forkjoin\/Integrate.java 8297235 generic-x64\n+java\/util\/concurrent\/forkjoin\/NQueensCS.java 8297235 generic-x64\n+java\/util\/concurrent\/tck\/JSR166TestCase.java 8297235 generic-x64\n+java\/util\/regex\/PatternStreamTest.java 8297235 generic-x64\n+java\/util\/stream\/CustomFJPoolTest.java 8297235 generic-x64\n+java\/util\/stream\/boottest\/java.base\/java\/util\/stream\/DoubleNodeTest.java 8297235 generic-x64\n+java\/util\/stream\/boottest\/java.base\/java\/util\/stream\/FlagOpTest.java 8297235 generic-x64\n+java\/util\/stream\/boottest\/java.base\/java\/util\/stream\/IntNodeTest.java 8297235 generic-x64\n+java\/util\/stream\/boottest\/java.base\/java\/util\/stream\/LongNodeTest.java 8297235 generic-x64\n+java\/util\/stream\/boottest\/java.base\/java\/util\/stream\/NodeTest.java 8297235 generic-x64\n+java\/util\/stream\/boottest\/java.base\/java\/util\/stream\/StreamReuseTest.java 8297235 generic-x64\n+java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/SplittableRandomTest.java 8297235 generic-x64\n+java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/CollectAndSummaryStatisticsTest.java 8297235 generic-x64\n+java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/CollectorsTest.java 8297235 generic-x64\n+java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/ConcatOpTest.java 8297235 generic-x64\n+java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/CountTest.java 8297235 generic-x64\n+java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/DistinctOpTest.java 8297235 generic-x64\n+java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/DoublePrimitiveOpsTests.java 8297235 generic-x64\n+java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/FilterOpTest.java 8297235 generic-x64\n+java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/FindAnyOpTest.java 8297235 generic-x64\n+java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/FindFirstOpTest.java 8297235 generic-x64\n+java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/FlatMapOpTest.java 8297235 generic-x64\n+java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/ForEachOpTest.java 8297235 generic-x64\n+java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/GroupByOpTest.java 8297235 generic-x64\n+java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/InfiniteStreamWithLimitOpTest.java 8297235 generic-x64\n+java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/IntPrimitiveOpsTests.java 8297235 generic-x64\n+java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/IntReduceTest.java 8297235 generic-x64\n+java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/IntSliceOpTest.java 8297235 generic-x64\n+java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/IntUniqOpTest.java 8297235 generic-x64\n+java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/IterateTest.java 8297235 generic-x64\n+java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/LongPrimitiveOpsTests.java 8297235 generic-x64\n+java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/MapOpTest.java 8297235 generic-x64\n+java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/MatchOpTest.java 8297235 generic-x64\n+java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/MinMaxTest.java 8297235 generic-x64\n+java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/PrimitiveAverageOpTest.java 8297235 generic-x64\n+java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/PrimitiveSumTest.java 8297235 generic-x64\n+java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/RangeTest.java 8297235 generic-x64\n+java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/ReduceByOpTest.java 8297235 generic-x64\n+java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/ReduceTest.java 8297235 generic-x64\n+java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/SequentialOpTest.java 8297235 generic-x64\n+java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/SliceOpTest.java 8297235 generic-x64\n+java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/SortedOpTest.java 8297235 generic-x64\n+java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/StreamBuilderTest.java 8297235 generic-x64\n+java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/StreamLinkTest.java 8297235 generic-x64\n+java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/StreamSpliteratorTest.java 8297235 generic-x64\n+java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/TeeOpTest.java 8297235 generic-x64\n+java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/ToArrayOpTest.java 8297235 generic-x64\n+java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/ToListOpTest.java 8297235 generic-x64\n+java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/WhileOpStatefulTest.java 8297235 generic-x64\n+java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/WhileOpTest.java 8297235 generic-x64\n+java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/mapMultiOpTest.java 8297235 generic-x64\n+\n+jdk\/internal\/vm\/Continuation\/Fuzz.java#default 8298058 generic-x64\n","filename":"test\/jdk\/ProblemList-zgc.txt","additions":68,"deletions":1,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -122,0 +122,1 @@\n+java\/awt\/Frame\/MaximizedToIconified\/MaximizedToIconified.java 8296972 macosx-all\n@@ -475,0 +476,7 @@\n+# jdk_foreign\n+\n+java\/foreign\/callarranger\/TestAarch64CallArranger.java generic-x86\n+java\/foreign\/TestLargeSegmentCopy.java generic-x86\n+\n+############################################################################\n+\n@@ -613,0 +621,2 @@\n+java\/security\/SignedJar\/spi-calendar-provider\/TestSPISigned.java 8298271 windows-all\n+\n@@ -645,1 +655,0 @@\n-javax\/swing\/JSpinner\/4788637\/bug4788637.java 8296084 linux-all\n@@ -658,0 +667,1 @@\n+javax\/swing\/JRadioButton\/4314194\/bug4314194.java 8298153 linux-all\n@@ -666,0 +676,3 @@\n+java\/awt\/Focus\/NonFocusableWindowTest\/NonfocusableOwnerTest.java 8280392 windows-x64\n+java\/awt\/Mixing\/AWT_Mixing\/OpaqueOverlapping.java 8294264 windows-x64\n+java\/awt\/Mixing\/AWT_Mixing\/ViewportOverlapping.java 8253184,8295813 windows-x64\n@@ -707,0 +720,1 @@\n+java\/util\/concurrent\/forkjoin\/AsyncShutdownNow.java             8286352 linux-all,windows-x64\n@@ -786,0 +800,1 @@\n+\n","filename":"test\/jdk\/ProblemList.txt","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-requiredVersion=7.1+1\n+requiredVersion=7.1.1+1\n","filename":"test\/jdk\/TEST.ROOT","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.Random;\n@@ -39,1 +40,1 @@\n-                final int repeat = 100;\n+                final int repeat = 1000;\n@@ -47,1 +48,1 @@\n-                java.util.Random rnd = new java.util.Random();\n+                Random rnd = new Random();\n@@ -55,0 +56,1 @@\n+                rnd.nextBytes(message);\n@@ -65,1 +67,1 @@\n-                if (rnd.nextBoolean()) {\n+                if (rnd.nextBoolean() && message.length > 16) {\n@@ -67,3 +69,4 @@\n-                        int initDataLen = rnd.nextInt(8, 24);\n-                        authenticator.engineUpdate(message, 0, initDataLen);\n-                        slowUpdate(authenticatorSlow, message, 0, initDataLen);\n+                        int initDataLen = rnd.nextInt(1, 16);\n+                        int initDataOffset = rnd.nextInt(0, message.length - initDataLen);\n+                        fastUpdate(authenticator, rnd, message, initDataOffset, initDataLen);\n+                        slowUpdate(authenticatorSlow, message, initDataOffset, initDataLen);\n@@ -74,2 +77,3 @@\n-                        authenticator.engineUpdate(message, 0, message.length);\n-                        slowUpdate(authenticatorSlow, message, 0, message.length);\n+                        int initDataOffset = rnd.nextInt(0, message.length);\n+                        fastUpdate(authenticator, rnd, message, initDataOffset, message.length - initDataOffset);\n+                        slowUpdate(authenticatorSlow, message, initDataOffset, message.length - initDataOffset);\n@@ -78,1 +82,1 @@\n-                authenticator.engineUpdate(message, 0, message.length);\n+                fastUpdate(authenticator, rnd, message, 0, message.length);\n@@ -90,2 +94,1 @@\n-                len = Math.min(message.length, offset + len);\n-                for (int i = offset; i < len; i++) {\n+                for (int i = offset; i < offset + len; i++) {\n@@ -95,0 +98,26 @@\n+\n+        static void fastUpdate(Poly1305 authenticator, Random rnd, byte[] message, int offset, int len) {\n+                ByteBuffer buf;\n+                switch(rnd.nextInt(4)) {\n+                        case 0: \/\/ byte[]\n+                                authenticator.engineUpdate(message, offset, len);\n+                                break;\n+                        case 1: \/\/ ByteArray with backing array\n+                                buf = ByteBuffer.wrap(message, offset, len)\n+                                                .order(java.nio.ByteOrder.LITTLE_ENDIAN);\n+                                authenticator.engineUpdate(buf);\n+                                break;\n+                        case 2: \/\/ ByteArray with backing array (non-zero position)\n+                                buf = ByteBuffer.wrap(message, 0, len+offset)\n+                                                .order(java.nio.ByteOrder.LITTLE_ENDIAN)\n+                                                .position(offset);\n+                                authenticator.engineUpdate(buf);\n+                                break;\n+                        case 3: \/\/ ByteArray without backing array (wont be sent to intrinsic)\n+                                buf = ByteBuffer.wrap(message, offset, len)\n+                                                .asReadOnlyBuffer()\n+                                                .order(java.nio.ByteOrder.LITTLE_ENDIAN);\n+                                authenticator.engineUpdate(buf);\n+                                break;\n+                }\n+        }\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/ChaCha20\/unittest\/java.base\/com\/sun\/crypto\/provider\/Poly1305IntrinsicFuzzTest.java","additions":40,"deletions":11,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-            lookup.lookup(\"GetLastError\").orElseThrow(),\n+            lookup.find(\"GetLastError\").orElseThrow(),\n@@ -60,1 +60,1 @@\n-            lookup.lookup(\"SetLastError\").orElseThrow(),\n+            lookup.find(\"SetLastError\").orElseThrow(),\n","filename":"test\/jdk\/com\/sun\/jdi\/JdbLastErrorTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,5 @@\n- * @run     main\/othervm -Xms64m -Xmx64m GarbageCollectionNotificationContentTest\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\n+ * @build   jdk.test.whitebox.WhiteBox\n+ * @run     driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run     main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                       -Xms64m -Xmx64m GarbageCollectionNotificationContentTest\n@@ -45,0 +49,2 @@\n+import jdk.test.whitebox.gc.GC;\n+import gc.testlibrary.g1.MixedGCProvoker;\n@@ -49,2 +55,2 @@\n-    static volatile long count = 0;\n-    static volatile long number = 0;\n+    static volatile long notificationReceivedCount = 0;\n+    static volatile long numberOfGCMBeans = 0;\n@@ -61,6 +67,6 @@\n-                    if(listenerInvoked.get(source) == null) {\n-                            listenerInvoked.put(((ObjectName)notif.getSource()).getCanonicalName(),gcNotif);\n-                            count++;\n-                            if(count >= number) {\n-                                synchronizer.notify();\n-                            }\n+                    if (listenerInvoked.get(source) == null) {\n+                        listenerInvoked.put(((ObjectName)notif.getSource()).getCanonicalName(), gcNotif);\n+                        notificationReceivedCount++;\n+                        if (notificationReceivedCount >= numberOfGCMBeans) {\n+                            synchronizer.notify();\n+                        }\n@@ -82,4 +88,2 @@\n-        final ObjectName gcMXBeanPattern =\n-                new ObjectName(\"java.lang:type=GarbageCollector,*\");\n-        Set<ObjectName> names =\n-                mbs.queryNames(gcMXBeanPattern, null);\n+        final ObjectName gcMXBeanPattern = new ObjectName(\"java.lang:type=GarbageCollector,*\");\n+        Set<ObjectName> names = mbs.queryNames(gcMXBeanPattern, null);\n@@ -88,1 +92,1 @@\n-        number = names.size();\n+        numberOfGCMBeans = names.size();\n@@ -90,2 +94,2 @@\n-            if(mbs.isInstanceOf(n,\"javax.management.NotificationEmitter\")) {\n-                listenerInvoked.put(n.getCanonicalName(),null);\n+            if (mbs.isInstanceOf(n, \"javax.management.NotificationEmitter\")) {\n+                listenerInvoked.put(n.getCanonicalName(), null);\n@@ -103,0 +107,4 @@\n+        \/\/ Trigger G1's concurrent mark\n+        if (GC.G1.isSelected()) {\n+            MixedGCProvoker.provokeConcMarkCycle();\n+        }\n@@ -105,1 +113,1 @@\n-            while(count != number) {\n+            while(notificationReceivedCount != numberOfGCMBeans) {\n@@ -119,3 +127,3 @@\n-        System.out.println(\"GC notification for \"+notif.getGcName());\n-        System.out.print(\"Action: \"+notif.getGcAction());\n-        System.out.println(\" Cause: \"+notif.getGcCause());\n+        System.out.println(\"GC notification for \" + notif.getGcName());\n+        System.out.print(\"Action: \" + notif.getGcAction());\n+        System.out.println(\" Cause: \" + notif.getGcCause());\n@@ -129,0 +137,6 @@\n+        \/\/ Check MemoryUsage is present. For all but No GC events, check Eden usage decreases:\n+        boolean doCheckMemoryUsage = true;\n+        if (notif.getGcCause().equals(\"No GC\")) {\n+            System.out.println(\"(skip memory usage check for event with 'No GC' cause)\");\n+            doCheckMemoryUsage = false;\n+        }\n@@ -136,2 +150,1 @@\n-                throw new RuntimeException(\"After Gc Memory does not exist\" +\n-                    \" for \" + poolname);\n+                throw new RuntimeException(\"After Gc Memory does not exist for \" + poolname);\n@@ -143,1 +156,3 @@\n-            checkMemoryUsage(poolname, busage, ausage);\n+            if (doCheckMemoryUsage) {\n+                checkMemoryUsage(poolname, busage, ausage);\n+            }\n@@ -150,2 +165,1 @@\n-                throw new RuntimeException(\"GcInfo does not contain \" +\n-                    \"memory usage for pool \" + p.getName());\n+                throw new RuntimeException(\"GcInfo does not contain memory usage for pool \" + p.getName());\n","filename":"test\/jdk\/com\/sun\/management\/GarbageCollectorMXBean\/GarbageCollectionNotificationContentTest.java","additions":40,"deletions":26,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -32,1 +32,5 @@\n- * @run     main\/othervm GarbageCollectionNotificationTest\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\n+ * @build   jdk.test.whitebox.WhiteBox\n+ * @run     driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run     main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                       GarbageCollectionNotificationTest\n@@ -45,0 +49,2 @@\n+import jdk.test.whitebox.gc.GC;\n+import gc.testlibrary.g1.MixedGCProvoker;\n@@ -102,0 +108,4 @@\n+        \/\/ Trigger G1's concurrent mark\n+        if (GC.G1.isSelected()) {\n+            MixedGCProvoker.provokeConcMarkCycle();\n+        }\n","filename":"test\/jdk\/com\/sun\/management\/GarbageCollectorMXBean\/GarbageCollectionNotificationTest.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,141 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.awt.Dimension;\n-import java.awt.EventQueue;\n-import java.awt.FlowLayout;\n-import java.awt.Frame;\n-import java.awt.Point;\n-import java.awt.Robot;\n-import java.awt.TextArea;\n-import java.awt.event.InputEvent;\n-import java.awt.event.KeyEvent;\n-\n-\/*\n- * @test\n- * @key headful\n- * @bug 8296632\n- * @summary Verify the content changes of a TextArea via TextListener.\n- * @run main TextAreaTextEventTest\n- *\/\n-public class TextAreaTextEventTest {\n-\n-    private static Frame frame;\n-    private volatile static TextArea textArea;\n-    private volatile static boolean textChanged = false;\n-    private volatile static Point textAreaAt;\n-    private volatile static Dimension textAreaSize;\n-    private static Robot robot = null;\n-\n-    public static void main(String[] args) throws Exception {\n-        try {\n-            EventQueue.invokeAndWait(TextAreaTextEventTest::initializeGUI);\n-\n-            robot = new Robot();\n-            robot.setAutoDelay(100);\n-\n-            robot.waitForIdle();\n-            EventQueue.invokeAndWait(() -> {\n-                textAreaAt = textArea.getLocationOnScreen();\n-                textAreaSize = textArea.getSize();\n-            });\n-            robot.mouseMove(textAreaAt.x + textAreaSize.width \/ 2,\n-                textAreaAt.y + textAreaSize.height \/ 2);\n-            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n-            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n-            typeKey(KeyEvent.VK_T);\n-\n-            robot.waitForIdle();\n-            if (!textChanged) {\n-                throw new RuntimeException(\n-                    \"FAIL: TextEvent not triggered when key 'T' typed on TextArea\");\n-            }\n-\n-            typeKey(KeyEvent.VK_E);\n-            typeKey(KeyEvent.VK_S);\n-            typeKey(KeyEvent.VK_T);\n-\n-            textChanged = false;\n-            typeKey(KeyEvent.VK_ENTER);\n-\n-            robot.waitForIdle();\n-            if (!textChanged) {\n-                throw new RuntimeException(\n-                    \"FAIL: TextEvent not triggered when Enter pressed on TextArea\");\n-            }\n-\n-            textChanged = false;\n-            robot.mouseMove(textAreaAt.x + 4, textAreaAt.y + 10);\n-            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n-            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n-            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n-            for (int i = 0; i < textAreaSize.width \/ 2; i++) {\n-                robot.mouseMove(textAreaAt.x + 4 + i, textAreaAt.y + 10);\n-            }\n-            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n-\n-            robot.waitForIdle();\n-            if (textChanged) {\n-                throw new RuntimeException(\n-                    \"FAIL: TextEvent triggered when text is selected on TextArea!\");\n-            }\n-\n-            textChanged = false;\n-            typeKey(KeyEvent.VK_F3);\n-\n-            robot.waitForIdle();\n-            if (textChanged) {\n-                throw new RuntimeException(\n-                    \"FAIL: TextEvent triggered when special key F3 is pressed on TextArea!\");\n-            }\n-            System.out.println(\"Test passed!\");\n-        } finally {\n-            EventQueue.invokeAndWait(TextAreaTextEventTest::disposeFrame);\n-        }\n-    }\n-\n-    private static void initializeGUI() {\n-        frame = new Frame(\"Test Frame\");\n-        frame.setLayout(new FlowLayout());\n-        textArea = new TextArea(5, 15);\n-        textArea.addTextListener((event) -> {\n-            System.out.println(\"Got a text event: \" + event);\n-            textChanged = true;\n-        });\n-        frame.add(textArea);\n-        frame.pack();\n-        frame.setLocationRelativeTo(null);\n-        frame.setVisible(true);\n-    }\n-\n-    public static void disposeFrame() {\n-        if (frame != null) {\n-            frame.dispose();\n-        }\n-    }\n-\n-    private static void typeKey(int key) throws Exception {\n-        robot.keyPress(key);\n-        robot.keyRelease(key);\n-    }\n-}\n","filename":"test\/jdk\/java\/awt\/event\/ComponentEvent\/TextAreaTextEventTest.java","additions":0,"deletions":141,"binary":false,"changes":141,"status":"deleted"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.TextArea;\n+import java.awt.TextComponent;\n+import java.awt.TextField;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 8297489 8296632\n+ * @summary Verify the content changes of a TextComponent via TextListener.\n+ * @run main TextComponentTextEventTest\n+ *\/\n+public class TextComponentTextEventTest {\n+\n+    private static Frame frame;\n+    private static Robot robot = null;\n+    private volatile static TextComponent[] components;\n+    private volatile static boolean textChanged = false;\n+    private volatile static Point textCompAt;\n+    private volatile static Dimension textCompSize;\n+\n+    private static void initializeGUI() {\n+        TextField textField = new TextField(20);\n+        textField.addTextListener((event) -> {\n+            textChanged = true;\n+            System.out.println(\"TextField got a text event: \" + event);\n+        });\n+\n+        TextArea textArea = new TextArea(5, 15);\n+        textArea.addTextListener((event) -> {\n+            System.out.println(\"TextArea got a text event: \" + event);\n+            textChanged = true;\n+        });\n+\n+        components = new TextComponent[] { textField, textArea };\n+\n+        frame = new Frame(\"Test Frame\");\n+        frame.setLayout(new FlowLayout());\n+        for (TextComponent textComp : components) {\n+            frame.add(textComp);\n+        }\n+        frame.pack();\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            EventQueue.invokeAndWait(TextComponentTextEventTest::initializeGUI);\n+            robot = new Robot();\n+            robot.setAutoDelay(100);\n+            robot.setAutoWaitForIdle(true);\n+\n+            for (TextComponent textComp : components) {\n+                robot.waitForIdle();\n+                EventQueue.invokeAndWait(() -> {\n+                    textCompAt = textComp.getLocationOnScreen();\n+                    textCompSize = textComp.getSize();\n+                });\n+\n+                robot.mouseMove(textCompAt.x + textCompSize.width \/ 2,\n+                    textCompAt.y + textCompSize.height \/ 2);\n+                robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+                robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+\n+                typeKey(KeyEvent.VK_T);\n+\n+                robot.waitForIdle();\n+                if (!textChanged) {\n+                    throw new RuntimeException(\n+                        \"FAIL: TextEvent not triggered when text entered in \" + textComp);\n+                }\n+\n+                typeKey(KeyEvent.VK_E);\n+                typeKey(KeyEvent.VK_S);\n+                typeKey(KeyEvent.VK_T);\n+\n+                textChanged = false;\n+                typeKey(KeyEvent.VK_ENTER);\n+\n+                robot.waitForIdle();\n+                if (textComp instanceof TextField && textChanged) {\n+                    throw new RuntimeException(\n+                        \"FAIL: TextEvent triggered when Enter pressed on \" + textComp);\n+                } else if (textComp instanceof TextArea && !textChanged) {\n+                    throw new RuntimeException(\n+                        \"FAIL: TextEvent not triggered when Enter pressed on \" + textComp);\n+                }\n+\n+                textChanged = false;\n+                robot.mouseMove(textCompAt.x + 4, textCompAt.y + 10);\n+                robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+                robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+                robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+                for (int i = 0; i < textCompSize.width \/ 2; i++) {\n+                    robot.mouseMove(textCompAt.x + 4 + i, textCompAt.y + 10);\n+                }\n+                robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+\n+                robot.waitForIdle();\n+                if (textChanged) {\n+                    throw new RuntimeException(\n+                        \"FAIL: TextEvent triggered when selection made in \" + textComp);\n+                }\n+\n+                textChanged = false;\n+                typeKey(KeyEvent.VK_F3);\n+\n+                robot.waitForIdle();\n+                if (textChanged) {\n+                    throw new RuntimeException(\n+                        \"FAIL: TextEvent triggered when F3 pressed on \" + textComp);\n+                }\n+            }\n+            System.out.println(\"Test passed!\");\n+        } finally {\n+            EventQueue.invokeAndWait(TextComponentTextEventTest::disposeFrame);\n+        }\n+    }\n+\n+    public static void disposeFrame() {\n+        if (frame != null) {\n+            frame.dispose();\n+        }\n+    }\n+\n+    private static void typeKey(int key) {\n+        robot.keyPress(key);\n+        robot.keyRelease(key);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/event\/ComponentEvent\/TextComponentTextEventTest.java","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -0,0 +1,165 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8165943\n+ * @summary LineBreakMeasurer does not measure correctly if TextAttribute.TRACKING is set\n+ * @library ..\/..\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual LineBreakWithTracking\n+ *\/\n+\n+import javax.swing.*;\n+import java.awt.*;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.awt.font.FontRenderContext;\n+import java.awt.font.LineBreakMeasurer;\n+import java.awt.font.TextAttribute;\n+import java.awt.font.TextLayout;\n+import java.text.AttributedString;\n+import java.util.Hashtable;\n+import java.lang.reflect.InvocationTargetException;\n+\n+class LineBreakPanel extends JPanel implements ActionListener {\n+\n+  private float textTracking = 0.0f;\n+  private static String fontName = \"Dialog\";\n+  private static String text = \"This is a long line of text that should be broken across multiple lines. \"\n+          + \"Please set the different tracking values to test via menu! This test should pass if \"\n+          + \"these lines are broken to fit the width, and fail otherwise.  It should \"\n+          + \"also format the hebrew (\\u05d0\\u05d1\\u05d2 \\u05d3\\u05d4\\u05d5) and arabic \"\n+          + \"(\\u0627\\u0628\\u062a\\u062c \\u062e\\u0644\\u0627\\u062e) and CJK \"\n+          + \"(\\u4e00\\u4e01\\u4e02\\uac00\\uac01\\uc4fa\\u67b1\\u67b2\\u67b3\\u67b4\\u67b5\\u67b6\\u67b7\"\n+          + \"\\u67b8\\u67b9) text correctly.\";\n+\n+  private LineBreakMeasurer lineMeasurer;\n+\n+  public void actionPerformed(ActionEvent e) {\n+    textTracking = (float)((JRadioButtonMenuItem)e.getSource()).getClientProperty( \"tracking\" );\n+    lineMeasurer = null;\n+    invalidate();\n+    repaint();\n+  }\n+\n+  public void paintComponent(Graphics g) {\n+    super.paintComponent(g);\n+    setBackground(Color.white);\n+\n+    Graphics2D g2d = (Graphics2D)g;\n+\n+    if (lineMeasurer == null) {\n+      Float regular = Float.valueOf(16.0f);\n+      Float big = Float.valueOf(24.0f);\n+\n+      Hashtable map = new Hashtable();\n+      map.put(TextAttribute.SIZE, (float)18.0);\n+      map.put(TextAttribute.TRACKING, (float)textTracking);\n+\n+      AttributedString astr = new AttributedString(text, map);\n+      astr.addAttribute(TextAttribute.SIZE, regular, 0, text.length());\n+      astr.addAttribute(TextAttribute.FAMILY, fontName, 0, text.length());\n+\n+      int ix = text.indexOf(\"broken\");\n+      astr.addAttribute(TextAttribute.SIZE, big, ix, ix + 6);\n+      ix = text.indexOf(\"hebrew\");\n+      astr.addAttribute(TextAttribute.SIZE, big, ix, ix + 6);\n+      ix = text.indexOf(\"arabic\");\n+      astr.addAttribute(TextAttribute.SIZE, big, ix, ix + 6);\n+      ix = text.indexOf(\"CJK\");\n+      astr.addAttribute(TextAttribute.SIZE, big, ix, ix + 3);\n+\n+      FontRenderContext frc = g2d.getFontRenderContext();\n+      lineMeasurer = new LineBreakMeasurer(astr.getIterator(), frc);\n+    }\n+\n+    lineMeasurer.setPosition(0);\n+\n+    float w = (float)getSize().width;\n+    float x = 0, y = 0;\n+    TextLayout layout;\n+    while ((layout = lineMeasurer.nextLayout(w)) != null) {\n+      x = layout.isLeftToRight() ? 0 : w - layout.getAdvance();\n+      y += layout.getAscent();\n+      layout.draw(g2d, x, y);\n+      y += layout.getDescent() + layout.getLeading();\n+    }\n+  }\n+}\n+\n+public class LineBreakWithTracking {\n+\n+  private static final String INSTRUCTIONS = \"\"\"\n+     This manual test verifies that LineBreakMeasurer measures the lines'\n+     breaks correctly taking into account the TextAttribute.TRACKING value.\n+     The test string includes Latin, Arabic, CJK and Hebrew.\n+\n+     You should choose a tracking value from the menu and resize the window.\n+     If the text lines break exactly to the wrapping width:\n+     no room for one more word exists and\n+     the text lines are not too long for given wrapping width, -\n+     then press PASS, otherwise - FAIL.\n+     \"\"\";\n+\n+  public void createGUI(JFrame frame) {\n+\n+    LineBreakPanel panel = new LineBreakPanel();\n+    frame.getContentPane().add(panel, BorderLayout.CENTER);\n+\n+    JMenuBar menuBar = new JMenuBar();\n+\n+    JMenu menu = new JMenu(\"Tracking\");\n+    ButtonGroup btnGroup = new ButtonGroup();\n+    String btnLabels[] = {\"-0.1\", \"0\", \"0.1\", \"0.2\", \"0.3\"};\n+    float val = -0.1f;\n+    for (String label : btnLabels) {\n+      JRadioButtonMenuItem btn = new JRadioButtonMenuItem(label);\n+      btn.putClientProperty( \"tracking\", val );\n+      btn.addActionListener(panel);\n+      btnGroup.add(btn);\n+      menu.add(btn);\n+      val += 0.1f;\n+    }\n+    menuBar.add(menu);\n+\n+    frame.setJMenuBar(menuBar);\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException, InvocationTargetException {\n+\n+    JFrame frame = new JFrame(\"LineBreakMeasurer with Tracking\");\n+    frame.setSize(new Dimension(640, 480));\n+\n+    LineBreakWithTracking controller = new LineBreakWithTracking();\n+    controller.createGUI(frame);\n+\n+    PassFailJFrame passFailJFrame = new PassFailJFrame(INSTRUCTIONS);\n+    PassFailJFrame.addTestWindow(frame);\n+    PassFailJFrame.positionTestWindow(frame, PassFailJFrame.Position.HORIZONTAL);\n+    frame.setVisible(true);\n+    passFailJFrame.awaitAndCheck();\n+  }\n+}\n","filename":"test\/jdk\/java\/awt\/font\/LineBreakMeasurer\/LineBreakWithTracking.java","additions":165,"deletions":0,"binary":false,"changes":165,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 8165943\n+  @summary LineBreakMeasurer does not measure correctly if TextAttribute.TRACKING is set\n+  @run main\/othervm LineBreakWithTrackingAuto\n+*\/\n+\n+import java.awt.font.FontRenderContext;\n+import java.awt.font.LineBreakMeasurer;\n+import java.awt.font.TextAttribute;\n+import java.awt.font.TextLayout;\n+import java.text.AttributedString;\n+\n+public class LineBreakWithTrackingAuto {\n+\n+  private static final String WORD = \"word\";\n+  private static final String SPACE = \" \";\n+  private static final int NUM_WORDS = 12;\n+  private static final float FONT_SIZE = 24.0f;\n+  private static final float TEXT_TRACKING[] = { -0.1f, 0f, 0.1f, 0.2f, 0.3f };\n+  private static final float EPSILON = 0.005f;\n+\n+\n+  public static void main(String[] args) {\n+    new LineBreakWithTrackingAuto().test();\n+  }\n+\n+  public void test() {\n+\n+    final FontRenderContext frc = new FontRenderContext(null, false, false);\n+\n+    \/\/ construct a paragraph as follows: [SPACE + WORD] + ...\n+    StringBuffer text = new StringBuffer();\n+    for (int i = 0; i < NUM_WORDS; i++) {\n+      text.append(SPACE);\n+      text.append(WORD);\n+    }\n+    AttributedString attrString = new AttributedString(text.toString());\n+    attrString.addAttribute(TextAttribute.SIZE, Float.valueOf(FONT_SIZE));\n+\n+    \/\/ test different tracking values: -0.1f, 0f, 0.1f, 0.2f, 0.3f\n+    for (float textTracking : TEXT_TRACKING) {\n+\n+      final float trackingAdvance = FONT_SIZE * textTracking;\n+      attrString.addAttribute(TextAttribute.TRACKING, textTracking);\n+\n+      LineBreakMeasurer measurer = new LineBreakMeasurer(attrString.getIterator(), frc);\n+\n+      final int sequenceLength = WORD.length() + SPACE.length();\n+      final float sequenceAdvance = getSequenceAdvance(measurer, text.length(), sequenceLength);\n+      final float textAdvance = NUM_WORDS * sequenceAdvance;\n+\n+      \/\/ test different wrapping width starting from the WORD+SPACE to TEXT width\n+      for (float wrappingWidth = sequenceAdvance; wrappingWidth < textAdvance; wrappingWidth += sequenceAdvance \/ sequenceLength) {\n+\n+        measurer.setPosition(0);\n+\n+        \/\/ break a paragraph into lines that fit the given wrapping width\n+        do {\n+          TextLayout layout = measurer.nextLayout(wrappingWidth);\n+          float visAdvance = layout.getVisibleAdvance();\n+\n+          int currPos = measurer.getPosition();\n+          if ((trackingAdvance <= 0 && visAdvance - wrappingWidth > EPSILON)\n+                  || (trackingAdvance > 0 && visAdvance - wrappingWidth > trackingAdvance + EPSILON)) {\n+            throw new Error(\"text line is too long for given wrapping width\");\n+          }\n+\n+          if (currPos < text.length() && visAdvance <= wrappingWidth - sequenceAdvance) {\n+            throw new Error(\"text line is too short for given wrapping width\");\n+          }\n+        } while (measurer.getPosition() != text.length());\n+\n+      }\n+    }\n+  }\n+\n+  private float getSequenceAdvance(LineBreakMeasurer measurer, int textLength, int sequenceLength) {\n+\n+    measurer.setPosition(textLength - sequenceLength);\n+\n+    TextLayout layout = measurer.nextLayout(10000.0f);\n+    if (layout.getCharacterCount() != sequenceLength) {\n+      throw new Error(\"layout length is incorrect\");\n+    }\n+\n+    return layout.getVisibleAdvance();\n+  }\n+\n+}\n","filename":"test\/jdk\/java\/awt\/font\/LineBreakMeasurer\/LineBreakWithTrackingAuto.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -24,1 +24,1 @@\n-\/* @test @(#)TestOldHangul.java\n+\/* @test\n@@ -83,1 +83,0 @@\n-\n","filename":"test\/jdk\/java\/awt\/font\/TextLayout\/TestOldHangul.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-\/* @test @(#)TestTibetan.java\n+\/* @test\n@@ -87,1 +87,0 @@\n-\n","filename":"test\/jdk\/java\/awt\/font\/TextLayout\/TestTibetan.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.image.ColorModel;\n+\n+\/**\n+ * @test\n+ * @bug 4677581\n+ * @summary checks when the ColorModel#getComponentSize() throws AIOBE\n+ *\/\n+public final class GetComponentSizeAIOBE {\n+\n+    public static void main(String[] args) {\n+        ColorModel cm = ColorModel.getRGBdefault();\n+        for (int i = 0; i < cm.getNumComponents(); ++i) {\n+            cm.getComponentSize(i);\n+        }\n+\n+        testAIOBE(cm, Integer.MIN_VALUE);\n+        testAIOBE(cm, -1);\n+        testAIOBE(cm, cm.getNumComponents());\n+        testAIOBE(cm, cm.getNumComponents() + 1);\n+        testAIOBE(cm, Integer.MAX_VALUE);\n+    }\n+\n+    private static void testAIOBE(ColorModel cm, int componentIdx) {\n+        try {\n+            cm.getComponentSize(componentIdx);\n+            throw new RuntimeException(\"AIOBE is not thrown\");\n+        } catch (ArrayIndexOutOfBoundsException ignore) {\n+            \/\/ expected\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/image\/ColorModel\/GetComponentSizeAIOBE.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -453,0 +453,1 @@\n+            @SuppressWarnings(\"removal\")\n","filename":"test\/jdk\/java\/awt\/regtesthelpers\/Util.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -381,1 +382,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n+            MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n@@ -385,1 +386,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(1L, MemorySession.implicit());\n+            MemorySegment segment = MemorySegment.allocateNative(1L, SegmentScope.auto());\n","filename":"test\/jdk\/java\/foreign\/CallGeneratorHelper.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -55,1 +55,1 @@\n-            callFunc(loadLibrary(arena0.session()));\n+            callFunc(loadLibrary(arena0.scope()));\n@@ -57,1 +57,1 @@\n-                callFunc(loadLibrary(arena1.session()));\n+                callFunc(loadLibrary(arena1.scope()));\n@@ -59,1 +59,1 @@\n-                    callFunc(loadLibrary(arena2.session()));\n+                    callFunc(loadLibrary(arena2.scope()));\n@@ -69,1 +69,1 @@\n-            addr = loadLibrary(arena.session());\n+            addr = loadLibrary(arena.scope());\n@@ -74,1 +74,1 @@\n-    private static MemorySegment loadLibrary(MemorySession session) {\n+    private static MemorySegment loadLibrary(SegmentScope session) {\n@@ -77,1 +77,1 @@\n-        assertEquals(addr.session(), session);\n+        assertEquals(addr.scope(), session);\n@@ -97,1 +97,1 @@\n-        SymbolLookup.libraryLookup(\"nonExistent\", MemorySession.global());\n+        SymbolLookup.libraryLookup(\"nonExistent\", SegmentScope.global());\n@@ -102,1 +102,1 @@\n-        SymbolLookup.libraryLookup(Path.of(\"nonExistent\"), MemorySession.global());\n+        SymbolLookup.libraryLookup(Path.of(\"nonExistent\"), SegmentScope.global());\n@@ -120,1 +120,1 @@\n-                    callFunc(loadLibrary(arena.session()));\n+                    callFunc(loadLibrary(arena.scope()));\n@@ -129,1 +129,1 @@\n-        MemorySegment addr = loadLibrary(arena.session());\n+        MemorySegment addr = loadLibrary(arena.scope());\n","filename":"test\/jdk\/java\/foreign\/LibraryLookupTest.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-public class MemoryLayoutPrincipalTotalityTest extends NativeTestHelper {\n+public class MemoryLayoutPrincipalTotalityTest {\n","filename":"test\/jdk\/java\/foreign\/MemoryLayoutPrincipalTotalityTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-public class MemoryLayoutTypeRetentionTest extends NativeTestHelper {\n+public class MemoryLayoutTypeRetentionTest {\n","filename":"test\/jdk\/java\/foreign\/MemoryLayoutTypeRetentionTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -124,1 +124,1 @@\n-            return LINKER.upcallStub(target, descriptor, MemorySession.implicit());\n+            return LINKER.upcallStub(target, descriptor, SegmentScope.auto());\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -38,0 +37,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -64,1 +64,1 @@\n-        assertFalse(segment.session().isAlive());\n+        assertFalse(segment.scope().isAlive());\n@@ -96,1 +96,1 @@\n-                    assertFalse(allocations[j].drop().session().isAlive());\n+                    assertFalse(allocations[j].drop().scope().isAlive());\n@@ -98,1 +98,1 @@\n-                    assertTrue(allocations[j].drop().session().isAlive());\n+                    assertTrue(allocations[j].drop().scope().isAlive());\n@@ -119,1 +119,1 @@\n-            list = VaList.make(b -> b.addVarg(C_INT, 42), arena.session());\n+            list = VaList.make(b -> b.addVarg(C_INT, 42), arena.scope());\n@@ -121,1 +121,1 @@\n-        assertFalse(list.segment().session().isAlive());\n+        assertFalse(list.segment().scope().isAlive());\n@@ -134,1 +134,1 @@\n-            upcall = Linker.nativeLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), arena.session());\n+            upcall = Linker.nativeLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), arena.scope());\n@@ -136,1 +136,1 @@\n-        assertFalse(upcall.session().isAlive());\n+        assertFalse(upcall.scope().isAlive());\n@@ -153,1 +153,1 @@\n-            VaList list = VaList.make(b -> b.addVarg(C_INT, 42), arena.session());\n+            VaList list = VaList.make(b -> b.addVarg(C_INT, 42), arena.scope());\n@@ -178,1 +178,1 @@\n-            MemorySegment upcall = Linker.nativeLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), arena.session());\n+            MemorySegment upcall = Linker.nativeLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), arena.scope());\n@@ -188,1 +188,1 @@\n-            return Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), MemorySession.implicit());\n+            return Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), SegmentScope.auto());\n","filename":"test\/jdk\/java\/foreign\/SafeFunctionAccessTest.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -282,1 +282,1 @@\n-                MemorySegment qsortUpcallStub = abi.upcallStub(qsortCompar, qsortComparFunction, arena.session());\n+                MemorySegment qsortUpcallStub = abi.upcallStub(qsortCompar, qsortComparFunction, arena.scope());\n@@ -311,1 +311,1 @@\n-                VaList vaList = VaList.make(b -> args.forEach(a -> a.accept(b, arena)), arena.session());\n+                VaList vaList = VaList.make(b -> args.forEach(a -> a.accept(b, arena)), arena.scope());\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -97,1 +97,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n@@ -116,1 +116,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n@@ -137,1 +137,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n@@ -195,1 +195,1 @@\n-            MemorySegment seg = MemorySegment.allocateNative(ValueLayout.JAVA_INT, arena.session());\n+            MemorySegment seg = MemorySegment.allocateNative(ValueLayout.JAVA_INT, arena.scope());\n@@ -206,1 +206,1 @@\n-            MemorySegment seg = MemorySegment.allocateNative(ValueLayout.JAVA_INT, arena.session());\n+            MemorySegment seg = MemorySegment.allocateNative(ValueLayout.JAVA_INT, arena.scope());\n@@ -214,1 +214,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n@@ -257,1 +257,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n@@ -295,1 +295,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n@@ -334,1 +334,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n@@ -377,1 +377,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n","filename":"test\/jdk\/java\/foreign\/TestAdaptVarHandles.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -111,1 +111,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n@@ -122,1 +122,1 @@\n-        MemorySegment segment = MemorySegment.ofAddress(0, seq.byteSize(), MemorySession.global());\n+        MemorySegment segment = MemorySegment.ofAddress(0, seq.byteSize(), SegmentScope.global());\n@@ -131,1 +131,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(layout.byteSize() + 1, layout.byteSize(), arena.session());\n+            MemorySegment segment = MemorySegment.allocateNative(layout.byteSize() + 1, layout.byteSize(), arena.scope());\n@@ -140,1 +140,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, arena.session());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, arena.scope());\n","filename":"test\/jdk\/java\/foreign\/TestArrays.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -189,1 +189,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(tuples, arena.session());;\n+            MemorySegment segment = MemorySegment.allocateNative(tuples, arena.scope());;\n@@ -235,1 +235,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 8L, arena.session());\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 8L, arena.scope());\n@@ -241,1 +241,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, 8L, arena.session());\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, 8L, arena.scope());\n@@ -255,1 +255,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, tuples.byteSize(), arena.session());\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, tuples.byteSize(), arena.scope());\n@@ -263,1 +263,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, tuples.byteSize(), arena.session());\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, tuples.byteSize(), arena.scope());\n@@ -276,1 +276,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 8L, arena.session());\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 8L, arena.scope());\n@@ -296,1 +296,1 @@\n-                MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, i, tuples.byteSize(), arena.session());\n+                MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, i, tuples.byteSize(), arena.scope());\n@@ -307,1 +307,1 @@\n-                MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, tuples.byteSize(), arena.session());\n+                MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, tuples.byteSize(), arena.scope());\n@@ -327,1 +327,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, LARGE_SIZE, arena.session());\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, LARGE_SIZE, arena.scope());\n@@ -364,1 +364,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(bytes, arena.session());;\n+            MemorySegment segment = MemorySegment.allocateNative(bytes, arena.scope());;\n@@ -390,1 +390,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(bytes, arena.session());;\n+            MemorySegment segment = MemorySegment.allocateNative(bytes, arena.scope());;\n@@ -424,1 +424,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(bytes, arena.session());;\n+            MemorySegment segment = MemorySegment.allocateNative(bytes, arena.scope());;\n@@ -437,1 +437,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(seq, arena.session());;\n+            MemorySegment segment = MemorySegment.allocateNative(seq, arena.scope());;\n@@ -475,1 +475,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(seq, arena.session());;\n+            MemorySegment segment = MemorySegment.allocateNative(seq, arena.scope());;\n@@ -486,1 +486,1 @@\n-            leaked = MemorySegment.allocateNative(bytes, arena.session());;\n+            leaked = MemorySegment.allocateNative(bytes, arena.scope());;\n@@ -494,1 +494,1 @@\n-        MemorySegment segment = MemorySegment.ofAddress(0, Integer.MAX_VALUE + 10L, MemorySession.implicit());\n+        MemorySegment segment = MemorySegment.ofAddress(0, Integer.MAX_VALUE + 10L, SegmentScope.auto());\n@@ -504,1 +504,1 @@\n-            fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, -1L, MemorySession.implicit());\n+            fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, -1L, SegmentScope.auto());\n@@ -514,1 +514,1 @@\n-            fileChannel.map(FileChannel.MapMode.READ_WRITE, -1L, 1L, MemorySession.implicit());\n+            fileChannel.map(FileChannel.MapMode.READ_WRITE, -1L, 1L, SegmentScope.auto());\n@@ -528,1 +528,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, SIZE, arena.session());\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, SIZE, arena.scope());\n@@ -538,1 +538,1 @@\n-                MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, offset, SIZE - offset, arena.session());\n+                MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, offset, SIZE - offset, arena.scope());\n@@ -552,1 +552,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 0L, arena.session());\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 0L, arena.scope());\n@@ -564,1 +564,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, 0L, arena.session());\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, 0L, arena.scope());\n@@ -579,1 +579,1 @@\n-            fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 0L, MemorySession.implicit());\n+            fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 0L, SegmentScope.auto());\n@@ -588,1 +588,1 @@\n-            MemorySegment nativeArray = MemorySegment.allocateNative(bytes, 1, arena.session());;\n+            MemorySegment nativeArray = MemorySegment.allocateNative(bytes, 1, arena.scope());;\n@@ -601,1 +601,1 @@\n-            MemorySegment nativeArray = MemorySegment.allocateNative(seq, arena.session());;\n+            MemorySegment nativeArray = MemorySegment.allocateNative(seq, arena.scope());;\n@@ -673,1 +673,1 @@\n-            MemorySegment ms = MemorySegment.allocateNative(4, 1, arena.session());;\n+            MemorySegment ms = MemorySegment.allocateNative(4, 1, arena.scope());;\n@@ -683,1 +683,1 @@\n-        MemorySegment s1 = MemorySegment.allocateNative(JAVA_INT, arena.session());\n+        MemorySegment s1 = MemorySegment.allocateNative(JAVA_INT, arena.scope());\n@@ -698,1 +698,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(10, 1, arena.session());;\n+            MemorySegment segment = MemorySegment.allocateNative(10, 1, arena.scope());;\n@@ -719,1 +719,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(10, arena.session());\n+            MemorySegment segment = MemorySegment.allocateNative(10, arena.scope());\n@@ -737,1 +737,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(16, arena.session());;\n+            MemorySegment segment = MemorySegment.allocateNative(16, arena.scope());;\n@@ -755,1 +755,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(16, arena.session());;\n+            MemorySegment segment = MemorySegment.allocateNative(16, arena.scope());;\n@@ -765,2 +765,2 @@\n-                { (Supplier<MemorySegment>) () -> MemorySegment.allocateNative(16, MemorySession.implicit()) },\n-                { (Supplier<MemorySegment>) () -> MemorySegment.allocateNative(16, Arena.openConfined().session()) },\n+                { (Supplier<MemorySegment>) () -> MemorySegment.allocateNative(16, SegmentScope.auto()) },\n+                { (Supplier<MemorySegment>) () -> MemorySegment.allocateNative(16, Arena.openConfined().scope()) },\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":34,"deletions":34,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -65,1 +65,1 @@\n-                MemorySession.global());\n+                SegmentScope.global());\n","filename":"test\/jdk\/java\/foreign\/TestClassLoaderFindNative.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-                    SegmentAllocator.nativeAllocator(arena.session()) :\n+                    SegmentAllocator.nativeAllocator(arena.scope()) :\n@@ -76,1 +76,1 @@\n-                    assertEquals(((MemorySegment)res).session(), arena.session());\n+                    assertEquals(((MemorySegment)res).scope(), arena.scope());\n","filename":"test\/jdk\/java\/foreign\/TestDowncallScope.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-                    SegmentAllocator.nativeAllocator(arena.session()) :\n+                    SegmentAllocator.nativeAllocator(arena.scope()) :\n@@ -72,1 +72,1 @@\n-                    assertEquals(((MemorySegment)res).session(), arena.session());\n+                    assertEquals(((MemorySegment)res).scope(), arena.scope());\n","filename":"test\/jdk\/java\/foreign\/TestDowncallStack.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(SEGMENT_SIZE, 1, arena.session());\n+            MemorySegment segment = MemorySegment.allocateNative(SEGMENT_SIZE, 1, arena.scope());\n@@ -85,1 +85,1 @@\n-            assertTrue(!segment.session().isAlive());\n+            assertTrue(!segment.scope().isAlive());\n@@ -102,1 +102,1 @@\n-            outer: while (segment.session().isAlive()) {\n+            outer: while (segment.scope().isAlive()) {\n@@ -196,1 +196,1 @@\n-            this.copy = MemorySegment.allocateNative(SEGMENT_SIZE, 1, segment.session());\n+            this.copy = MemorySegment.allocateNative(SEGMENT_SIZE, 1, segment.scope());\n","filename":"test\/jdk\/java\/foreign\/TestHandshake.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -103,1 +103,1 @@\n-        NATIVE(MemorySegment.allocateNative(8, MemorySession.implicit()), -1);\n+        NATIVE(MemorySegment.allocateNative(8, SegmentScope.auto()), -1);\n","filename":"test\/jdk\/java\/foreign\/TestHeapAlignment.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @requires sun.arch.data.model == \"64\"\n@@ -48,1 +49,1 @@\n-            var segment = MemorySegment.allocateNative((long) longArrayLength * Long.BYTES, Long.SIZE, arena.session());\n+            var segment = MemorySegment.allocateNative((long) longArrayLength * Long.BYTES, Long.SIZE, arena.scope());\n","filename":"test\/jdk\/java\/foreign\/TestLargeSegmentCopy.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -437,1 +437,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(layout, arena.session());\n+            MemorySegment segment = MemorySegment.allocateNative(layout, arena.scope());\n@@ -472,1 +472,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(layout, arena.session());\n+            MemorySegment segment = MemorySegment.allocateNative(layout, arena.scope());\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(seq, arena.session());;\n+            MemorySegment segment = MemorySegment.allocateNative(seq, arena.scope());;\n","filename":"test\/jdk\/java\/foreign\/TestLayouts.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n","filename":"test\/jdk\/java\/foreign\/TestLinker.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-            MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(layout, arena.session()));\n+            MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(layout, arena.scope()));\n@@ -127,1 +127,1 @@\n-            MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq, arena.session()));\n+            MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq, arena.scope()));\n@@ -196,1 +196,1 @@\n-            MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq, arena.session()));\n+            MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq, arena.scope()));\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccess.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-                MemorySegment segment = MemorySegment.allocateNative(128, arena.session());;\n+                MemorySegment segment = MemorySegment.allocateNative(128, arena.scope());;\n@@ -96,1 +96,1 @@\n-                MemorySegment segment = MemorySegment.allocateNative(64, arena.session());;\n+                MemorySegment segment = MemorySegment.allocateNative(64, arena.scope());;\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccessInstance.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(aligned, arena.session());;\n+            MemorySegment segment = MemorySegment.allocateNative(aligned, arena.scope());;\n@@ -74,1 +74,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(alignedGroup, arena.session());;\n+            MemorySegment segment = MemorySegment.allocateNative(alignedGroup, arena.scope());;\n@@ -101,1 +101,1 @@\n-                MemorySegment segment = MemorySegment.allocateNative(layout, arena.session());;\n+                MemorySegment segment = MemorySegment.allocateNative(layout, arena.scope());;\n@@ -125,1 +125,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(g, arena.session());;\n+            MemorySegment segment = MemorySegment.allocateNative(g, arena.scope());;\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAlignment.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -297,1 +297,1 @@\n-            var segment = MemorySegment.allocateNative(size, arena.session());;\n+            var segment = MemorySegment.allocateNative(size, arena.scope());\n","filename":"test\/jdk\/java\/foreign\/TestMemoryInspection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -57,1 +57,1 @@\n-            addCloseAction(arena.session(), () -> acc.addAndGet(delta));\n+            addCloseAction(arena.scope(), () -> acc.addAndGet(delta));\n@@ -68,1 +68,1 @@\n-        MemorySession session = sessionSupplier.get();\n+        SegmentScope session = sessionSupplier.get();\n@@ -91,2 +91,2 @@\n-        MemorySession session = sessionSupplier.get();\n-        AtomicReference<MemorySession> sessionRef = new AtomicReference<>(session);\n+        SegmentScope session = sessionSupplier.get();\n+        AtomicReference<SegmentScope> sessionRef = new AtomicReference<>(session);\n@@ -149,1 +149,1 @@\n-            keepAlive(handle.session(), arena.session());\n+            keepAlive(handle.scope(), arena.scope());\n@@ -173,1 +173,1 @@\n-                    keepAlive(handle.session(), arena.session());\n+                    keepAlive(handle.scope(), arena.scope());\n@@ -208,1 +208,1 @@\n-        keepAlive(handle.session(), arena.session());\n+        keepAlive(handle.scope(), arena.scope());\n@@ -229,1 +229,1 @@\n-        MemorySession session = sessionSupplier.get();\n+        SegmentScope session = sessionSupplier.get();\n@@ -235,1 +235,1 @@\n-    private void acquireRecursive(MemorySession session, int acquireCount) {\n+    private void acquireRecursive(SegmentScope session, int acquireCount) {\n@@ -237,1 +237,1 @@\n-            keepAlive(arena.session(), session);\n+            keepAlive(arena.scope(), session);\n@@ -253,1 +253,1 @@\n-            keepAlive(MemorySession.implicit(), root.session());\n+            keepAlive(SegmentScope.auto(), root.scope());\n@@ -266,1 +266,1 @@\n-                        keepAlive(arena.session(), root.session());\n+                        keepAlive(arena.scope(), root.scope());\n@@ -282,1 +282,1 @@\n-            keepAlive(arena.session(), root.session());\n+            keepAlive(arena.scope(), root.scope());\n@@ -289,1 +289,1 @@\n-                keepAlive(arena.session(), root.session());\n+                keepAlive(arena.scope(), root.scope());\n@@ -329,2 +329,2 @@\n-    private void keepAlive(MemorySession child, MemorySession parent) {\n-        MemorySessionImpl parentImpl = MemorySessionImpl.toSessionImpl(parent);\n+    private void keepAlive(SegmentScope child, SegmentScope parent) {\n+        MemorySessionImpl parentImpl = (MemorySessionImpl) parent;\n@@ -335,2 +335,2 @@\n-    private void addCloseAction(MemorySession session, Runnable action) {\n-        MemorySessionImpl sessionImpl = MemorySessionImpl.toSessionImpl(session);\n+    private void addCloseAction(SegmentScope session, Runnable action) {\n+        MemorySessionImpl sessionImpl = (MemorySessionImpl) session;\n@@ -340,1 +340,1 @@\n-    interface SessionSupplier extends Supplier<MemorySession> {\n+    interface SessionSupplier extends Supplier<SegmentScope> {\n@@ -342,1 +342,1 @@\n-        static void close(MemorySession session) {\n+        static void close(SegmentScope session) {\n@@ -346,1 +346,1 @@\n-        static boolean isImplicit(MemorySession session) {\n+        static boolean isImplicit(SegmentScope session) {\n@@ -351,1 +351,1 @@\n-            return MemorySession::implicit;\n+            return SegmentScope::auto;\n@@ -355,1 +355,1 @@\n-            return () -> arenaSupplier.get().session();\n+            return () -> arenaSupplier.get().scope();\n","filename":"test\/jdk\/java\/foreign\/TestMemorySession.java","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -176,1 +176,1 @@\n-            var nativeSegment = MemorySegment.allocateNative(4, 4, arena.session());;\n+            var nativeSegment = MemorySegment.allocateNative(4, 4, arena.scope());;\n@@ -188,2 +188,2 @@\n-                var s1 = MemorySegment.allocateNative((long) Integer.MAX_VALUE + 10L, 8, arena.session());;\n-                var s2 = MemorySegment.allocateNative((long) Integer.MAX_VALUE + 10L, 8, arena.session());;\n+                var s1 = MemorySegment.allocateNative((long) Integer.MAX_VALUE + 10L, 8, arena.scope());;\n+                var s2 = MemorySegment.allocateNative((long) Integer.MAX_VALUE + 10L, 8, arena.scope());;\n@@ -232,2 +232,2 @@\n-            s1 = MemorySegment.allocateNative(4, 1, arena.session());;\n-            s2 = MemorySegment.allocateNative(4, 1, arena.session());;\n+            s1 = MemorySegment.allocateNative(4, 1, arena.scope());;\n+            s2 = MemorySegment.allocateNative(4, 1, arena.scope());;\n@@ -243,1 +243,1 @@\n-            var segment = MemorySegment.allocateNative(4, 1, arena.session());;\n+            var segment = MemorySegment.allocateNative(4, 1, arena.scope());;\n@@ -284,1 +284,1 @@\n-        NATIVE(i -> MemorySegment.allocateNative(i, MemorySession.implicit())),\n+        NATIVE(i -> MemorySegment.allocateNative(i, SegmentScope.auto())),\n","filename":"test\/jdk\/java\/foreign\/TestMismatch.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -37,0 +36,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -149,1 +149,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(seq, arena.session());;\n+            MemorySegment segment = MemorySegment.allocateNative(seq, arena.scope());;\n@@ -159,1 +159,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(doubles, arena.session());;\n+            MemorySegment segment = MemorySegment.allocateNative(doubles, arena.scope());;\n@@ -173,1 +173,1 @@\n-                    arena.session(), () -> freeMemory(addr));\n+                    arena.scope(), () -> freeMemory(addr));\n@@ -184,1 +184,1 @@\n-                    arena.session(), () -> freeMemory(addr));\n+                    arena.scope(), () -> freeMemory(addr));\n@@ -188,1 +188,1 @@\n-        assertTrue(!mallocSegment.session().isAlive());\n+        assertTrue(!mallocSegment.scope().isAlive());\n@@ -202,2 +202,2 @@\n-            MemorySegment segment = MemorySegment.allocateNative(4, 1, arena.session());;\n-            MemorySegment.ofAddress(segment.address(), -1, MemorySession.global());\n+            MemorySegment segment = MemorySegment.allocateNative(4, 1, arena.scope());;\n+            MemorySegment.ofAddress(segment.address(), -1, SegmentScope.global());\n","filename":"test\/jdk\/java\/foreign\/TestNative.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -104,1 +105,1 @@\n-            MemorySession.class,\n+            SegmentScope.class,\n@@ -109,3 +110,3 @@\n-            \"java.lang.foreign.MemorySegment\/ofAddress(long,long,java.lang.foreign.MemorySession,java.lang.Runnable)\/3\/0\",\n-            \"java.lang.foreign.MemorySession\/openConfined(java.lang.ref.Cleaner)\/0\/0\",\n-            \"java.lang.foreign.MemorySession\/openShared(java.lang.ref.Cleaner)\/0\/0\",\n+            \"java.lang.foreign.MemorySegment\/ofAddress(long,long,java.lang.foreign.SegmentScope,java.lang.Runnable)\/3\/0\",\n+            \"java.lang.foreign.MemorySegment.MemorySession\/openConfined(java.lang.ref.Cleaner)\/0\/0\",\n+            \"java.lang.foreign.MemorySegment.MemorySession\/openShared(java.lang.ref.Cleaner)\/0\/0\",\n@@ -186,1 +187,1 @@\n-        addDefaultMapping(MemorySession.class, MemorySession.implicit());\n+        addDefaultMapping(SegmentScope.class, SegmentScope.auto());\n@@ -201,1 +202,1 @@\n-            }, MemorySession.implicit());\n+            }, SegmentScope.auto());\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -78,1 +78,1 @@\n-        Z obj = scopedOperation.apply(arena.session());\n+        Z obj = scopedOperation.apply(arena.scope());\n@@ -91,1 +91,1 @@\n-            Z obj = scopedOperation.apply(arena.session());\n+            Z obj = scopedOperation.apply(arena.scope());\n@@ -164,1 +164,1 @@\n-    static class ScopedOperation<X> implements Consumer<X>, Function<MemorySession, X> {\n+    static class ScopedOperation<X> implements Consumer<X>, Function<SegmentScope, X> {\n@@ -166,1 +166,1 @@\n-        final Function<MemorySession, X> factory;\n+        final Function<SegmentScope, X> factory;\n@@ -170,1 +170,1 @@\n-        private ScopedOperation(Function<MemorySession, X> factory, Consumer<X> operation, String name) {\n+        private ScopedOperation(Function<SegmentScope, X> factory, Consumer<X> operation, String name) {\n@@ -182,1 +182,1 @@\n-        public X apply(MemorySession session) {\n+        public X apply(SegmentScope session) {\n@@ -186,1 +186,1 @@\n-        static <Z> void of(Function<MemorySession, Z> factory, Consumer<Z> consumer, String name) {\n+        static <Z> void of(Function<SegmentScope, Z> factory, Consumer<Z> consumer, String name) {\n@@ -190,1 +190,1 @@\n-        static void ofScope(Consumer<MemorySession> scopeConsumer, String name) {\n+        static void ofScope(Consumer<SegmentScope> scopeConsumer, String name) {\n@@ -239,1 +239,1 @@\n-            final Function<MemorySession, MemorySegment> segmentFactory;\n+            final Function<SegmentScope, MemorySegment> segmentFactory;\n@@ -241,1 +241,1 @@\n-            SegmentFactory(Function<MemorySession, MemorySegment> segmentFactory) {\n+            SegmentFactory(Function<SegmentScope, MemorySegment> segmentFactory) {\n@@ -249,1 +249,1 @@\n-            final Function<MemorySession, SegmentAllocator> allocatorFactory;\n+            final Function<SegmentScope, SegmentAllocator> allocatorFactory;\n@@ -251,1 +251,1 @@\n-            AllocatorFactory(Function<MemorySession, SegmentAllocator> allocatorFactory) {\n+            AllocatorFactory(Function<SegmentScope, SegmentAllocator> allocatorFactory) {\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -95,1 +96,1 @@\n-                    assertFalse(address.session().isAlive());\n+                    assertFalse(address.scope().isAlive());\n@@ -190,1 +191,1 @@\n-                return MemorySegment.allocateNative(byteSize, byteAlignment, MemorySession.implicit());\n+                return MemorySegment.allocateNative(byteSize, byteAlignment, SegmentScope.auto());\n@@ -350,2 +351,2 @@\n-        SLICING(true, (size, drop) -> SegmentAllocator.slicingAllocator(MemorySegment.allocateNative(size, drop.session()))),\n-        NATIVE_ALLOCATOR(false, (size, drop) -> SegmentAllocator.nativeAllocator(drop.session()));\n+        SLICING(true, (size, drop) -> SegmentAllocator.slicingAllocator(MemorySegment.allocateNative(size, drop.scope()))),\n+        NATIVE_ALLOCATOR(false, (size, drop) -> SegmentAllocator.nativeAllocator(drop.scope()));\n@@ -483,2 +484,2 @@\n-                { SegmentAllocator.nativeAllocator(MemorySession.global()) },\n-                { SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(10, MemorySession.global())) },\n+                { SegmentAllocator.nativeAllocator(SegmentScope.global()) },\n+                { SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(10, SegmentScope.global())) },\n","filename":"test\/jdk\/java\/foreign\/TestSegmentAllocators.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -147,1 +147,1 @@\n-            NATIVE(i -> MemorySegment.allocateNative(i, MemorySession.implicit())),\n+            NATIVE(i -> MemorySegment.allocateNative(i, SegmentScope.auto())),\n","filename":"test\/jdk\/java\/foreign\/TestSegmentCopy.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import java.lang.foreign.MemorySession;\n+\n@@ -34,0 +34,2 @@\n+\n+import java.lang.foreign.SegmentScope;\n@@ -82,1 +84,1 @@\n-            NATIVE(i -> MemorySegment.allocateNative(i, MemorySession.implicit())),\n+            NATIVE(i -> MemorySegment.allocateNative(i, SegmentScope.auto())),\n","filename":"test\/jdk\/java\/foreign\/TestSegmentOffset.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -39,1 +40,1 @@\n-import java.lang.foreign.MemorySession;\n+\n@@ -64,1 +65,1 @@\n-                () -> MemorySegment.allocateNative(16, MemorySession.implicit()),\n+                () -> MemorySegment.allocateNative(16, SegmentScope.auto()),\n@@ -67,1 +68,1 @@\n-                        return fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 16L, MemorySession.implicit());\n+                        return fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 16L, SegmentScope.auto());\n@@ -101,1 +102,1 @@\n-        assertEquals(s1.asOverlappingSlice(s2).get().session(), s1.session());\n+        assertEquals(s1.asOverlappingSlice(s2).get().scope(), s1.scope());\n@@ -104,1 +105,1 @@\n-        assertEquals(s2.asOverlappingSlice(s1).get().session(), s2.session());\n+        assertEquals(s2.asOverlappingSlice(s1).get().scope(), s2.scope());\n@@ -120,1 +121,1 @@\n-            assertEquals(s1.asOverlappingSlice(slice).get().session(), s1.session());\n+            assertEquals(s1.asOverlappingSlice(slice).get().scope(), s1.scope());\n@@ -123,1 +124,1 @@\n-            assertEquals(slice.asOverlappingSlice(s1).get().session(), slice.session());\n+            assertEquals(slice.asOverlappingSlice(s1).get().scope(), slice.scope());\n@@ -134,1 +135,1 @@\n-        NATIVE(() -> MemorySegment.allocateNative(16, MemorySession.implicit())),\n+        NATIVE(() -> MemorySegment.allocateNative(16, SegmentScope.auto())),\n","filename":"test\/jdk\/java\/foreign\/TestSegmentOverlap.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -53,1 +53,1 @@\n-        MemorySegment.allocateNative(size, align, MemorySession.implicit());\n+        MemorySegment.allocateNative(size, align, SegmentScope.auto());\n@@ -59,1 +59,1 @@\n-            MemorySession session = arena.session();\n+            SegmentScope session = arena.scope();\n@@ -78,1 +78,1 @@\n-        MemorySegment.allocateNative(Long.MAX_VALUE, MemorySession.implicit());\n+        MemorySegment.allocateNative(Long.MAX_VALUE, SegmentScope.auto());\n@@ -83,1 +83,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(1024L * 1024 * 8 * 2, MemorySession.implicit()); \/\/ 2M\n+        MemorySegment segment = MemorySegment.allocateNative(1024L * 1024 * 8 * 2, SegmentScope.auto()); \/\/ 2M\n@@ -90,1 +90,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(1000, 1, arena.session());\n+            MemorySegment segment = MemorySegment.allocateNative(1000, 1, arena.scope());\n@@ -101,1 +101,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(10, 1, arena.session());\n+            MemorySegment segment = MemorySegment.allocateNative(10, 1, arena.scope());\n@@ -121,1 +121,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(100, arena.session());\n+            MemorySegment segment = MemorySegment.allocateNative(100, arena.scope());\n@@ -126,2 +126,2 @@\n-            assertEquals(segment, MemorySegment.ofAddress(segment.address(), 100, MemorySession.global()));\n-            MemorySegment segment2 = MemorySegment.allocateNative(100, arena.session());\n+            assertEquals(segment, MemorySegment.ofAddress(segment.address(), 100, SegmentScope.global()));\n+            MemorySegment segment2 = MemorySegment.allocateNative(100, arena.scope());\n@@ -146,1 +146,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(100, arena.session());\n+            MemorySegment segment = MemorySegment.allocateNative(100, arena.scope());\n@@ -150,1 +150,1 @@\n-            assertEquals(segment.hashCode(), MemorySegment.ofAddress(segment.address(), 100, MemorySession.global()).hashCode());\n+            assertEquals(segment.hashCode(), MemorySegment.ofAddress(segment.address(), 100, SegmentScope.global()).hashCode());\n@@ -165,1 +165,1 @@\n-        MemorySegment memorySegment = MemorySegment.allocateNative(10, MemorySession.implicit());\n+        MemorySegment memorySegment = MemorySegment.allocateNative(10, SegmentScope.auto());\n@@ -172,1 +172,1 @@\n-        MemorySegment memorySegment = MemorySegment.allocateNative(10L, MemorySession.implicit());\n+        MemorySegment memorySegment = MemorySegment.allocateNative(10L, SegmentScope.auto());\n@@ -179,1 +179,1 @@\n-            var segment = MemorySegment.allocateNative(10, MemorySession.global());\n+            var segment = MemorySegment.allocateNative(10, SegmentScope.global());\n@@ -204,6 +204,6 @@\n-                () -> MemorySegment.allocateNative(4L, MemorySession.implicit()),\n-                () -> MemorySegment.allocateNative(4L, 8, MemorySession.implicit()),\n-                () -> MemorySegment.allocateNative(JAVA_INT, MemorySession.implicit()),\n-                () -> MemorySegment.allocateNative(4L, MemorySession.implicit()),\n-                () -> MemorySegment.allocateNative(4L, 8, MemorySession.implicit()),\n-                () -> MemorySegment.allocateNative(JAVA_INT, MemorySession.implicit())\n+                () -> MemorySegment.allocateNative(4L, SegmentScope.auto()),\n+                () -> MemorySegment.allocateNative(4L, 8, SegmentScope.auto()),\n+                () -> MemorySegment.allocateNative(JAVA_INT, SegmentScope.auto()),\n+                () -> MemorySegment.allocateNative(4L, SegmentScope.auto()),\n+                () -> MemorySegment.allocateNative(4L, 8, SegmentScope.auto()),\n+                () -> MemorySegment.allocateNative(JAVA_INT, SegmentScope.auto())\n@@ -267,1 +267,1 @@\n-        if (segment.session().isOwnedBy(Thread.currentThread())) {\n+        if (segment.scope().isAccessibleBy(Thread.currentThread())) {\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-            MemorySegment s = MemorySegment.allocateNative(layout, arena.session());;\n+            MemorySegment s = MemorySegment.allocateNative(layout, arena.scope());;\n@@ -98,1 +98,1 @@\n-            MemorySegment s = MemorySegment.allocateNative(4, 1, arena.session());;\n+            MemorySegment s = MemorySegment.allocateNative(4, 1, arena.scope());;\n@@ -102,1 +102,1 @@\n-            MemorySegment sharedSegment = MemorySegment.ofAddress(s.address(), s.byteSize(), arena.session());\n+            MemorySegment sharedSegment = MemorySegment.ofAddress(s.address(), s.byteSize(), arena.scope());\n@@ -125,1 +125,1 @@\n-            MemorySegment s1 = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(2, ValueLayout.JAVA_INT), arena.session());;\n+            MemorySegment s1 = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(2, ValueLayout.JAVA_INT), arena.scope());;\n","filename":"test\/jdk\/java\/foreign\/TestSharedAccess.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(LAYOUT, arena.session());;\n+            MemorySegment segment = MemorySegment.allocateNative(LAYOUT, arena.scope());;\n@@ -65,1 +65,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(LAYOUT, arena.session());;\n+            MemorySegment segment = MemorySegment.allocateNative(LAYOUT, arena.scope());;\n","filename":"test\/jdk\/java\/foreign\/TestSlices.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -63,1 +63,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(layout, arena.session());;\n+            MemorySegment segment = MemorySegment.allocateNative(layout, arena.scope());;\n@@ -89,1 +89,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n@@ -104,1 +104,2 @@\n-        MemorySegment.ofArray(new byte[2]).spliterator(ValueLayout.JAVA_INT);\n+        MemorySegment.allocateNative(2, SegmentScope.auto())\n+                .spliterator(ValueLayout.JAVA_INT);\n@@ -109,1 +110,2 @@\n-        MemorySegment.ofArray(new byte[2]).elements(ValueLayout.JAVA_INT);\n+        MemorySegment.allocateNative(2, SegmentScope.auto())\n+                .elements(ValueLayout.JAVA_INT);\n@@ -114,1 +116,2 @@\n-        MemorySegment.ofArray(new byte[7]).spliterator(ValueLayout.JAVA_INT);\n+        MemorySegment.allocateNative(7, SegmentScope.auto())\n+                .spliterator(ValueLayout.JAVA_INT);\n@@ -119,1 +122,14 @@\n-        MemorySegment.ofArray(new byte[7]).elements(ValueLayout.JAVA_INT);\n+        MemorySegment.allocateNative(7, SegmentScope.auto())\n+                .elements(ValueLayout.JAVA_INT);\n+    }\n+\n+    @Test\n+    public void testSpliteratorElementSizeMultipleButNotPowerOfTwo() {\n+        MemorySegment.allocateNative(12, SegmentScope.auto())\n+                .spliterator(ValueLayout.JAVA_INT);\n+    }\n+\n+    @Test\n+    public void testStreamElementSizeMultipleButNotPowerOfTwo() {\n+        MemorySegment.allocateNative(12, SegmentScope.auto())\n+                .elements(ValueLayout.JAVA_INT);\n@@ -124,1 +140,2 @@\n-        MemorySegment.ofArray(new byte[7]).spliterator(MemoryLayout.sequenceLayout(0, ValueLayout.JAVA_INT));\n+        MemorySegment.allocateNative(7, SegmentScope.auto())\n+                .spliterator(MemoryLayout.sequenceLayout(0, ValueLayout.JAVA_INT));\n@@ -129,1 +146,2 @@\n-        MemorySegment.ofArray(new byte[7]).elements(MemoryLayout.sequenceLayout(0, ValueLayout.JAVA_INT));\n+        MemorySegment.allocateNative(7, SegmentScope.auto())\n+                .elements(MemoryLayout.sequenceLayout(0, ValueLayout.JAVA_INT));\n@@ -134,1 +152,4 @@\n-        MemorySegment.ofArray(new byte[8]).elements(MemoryLayout.sequenceLayout(2, ValueLayout.JAVA_INT.withBitAlignment(64)));\n+        MemorySegment segment = MemorySegment.allocateNative(8, SegmentScope.auto());\n+        \/\/ compute an alignment constraint (in bytes) which exceed that of the native segment\n+        long bigByteAlign = Long.lowestOneBit(segment.address()) << 1;\n+        segment.elements(MemoryLayout.sequenceLayout(2, ValueLayout.JAVA_INT.withBitAlignment(bigByteAlign * 8)));\n","filename":"test\/jdk\/java\/foreign\/TestSpliterator.java","additions":31,"deletions":10,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-            MemorySegment s = MemorySegment.allocateNative(8, 8, arena.session());;\n+            MemorySegment s = MemorySegment.allocateNative(8, 8, arena.scope());;\n@@ -65,1 +65,1 @@\n-            MemorySegment s = MemorySegment.allocateNative(8, 8, arena.session());;\n+            MemorySegment s = MemorySegment.allocateNative(8, 8, arena.scope());;\n@@ -73,1 +73,1 @@\n-            MemorySegment s = MemorySegment.allocateNative(8, 8, arena.session());;\n+            MemorySegment s = MemorySegment.allocateNative(8, 8, arena.scope());;\n@@ -81,1 +81,1 @@\n-            MemorySegment s = MemorySegment.allocateNative(8, 8, arena.session());;\n+            MemorySegment s = MemorySegment.allocateNative(8, 8, arena.scope());;\n","filename":"test\/jdk\/java\/foreign\/TestTypeAccess.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -52,1 +52,1 @@\n-        VaList.make(builder -> builder.addVarg(ValueLayout.JAVA_INT, 42), MemorySession.implicit());\n+        VaList.make(builder -> builder.addVarg(ValueLayout.JAVA_INT, 42), SegmentScope.auto());\n@@ -57,1 +57,1 @@\n-        VaList.ofAddress(0L, MemorySession.implicit());\n+        VaList.ofAddress(0L, SegmentScope.auto());\n","filename":"test\/jdk\/java\/foreign\/TestUnsupportedLinker.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -45,0 +44,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -68,1 +68,1 @@\n-            Object[] args = makeArgs(MemorySession.implicit(), ret, paramTypes, fields, returnChecks, argChecks);\n+            Object[] args = makeArgs(SegmentScope.auto(), ret, paramTypes, fields, returnChecks, argChecks);\n@@ -75,1 +75,1 @@\n-            MemorySegment callback = ABI.upcallStub(mh, callbackDesc, arena.session());\n+            MemorySegment callback = ABI.upcallStub(mh, callbackDesc, arena.scope());\n@@ -81,1 +81,1 @@\n-                    ? invoker.invoke(arena.session(), callback)\n+                    ? invoker.invoke(arena.scope(), callback)\n","filename":"test\/jdk\/java\/foreign\/TestUpcallAsync.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -68,1 +68,1 @@\n-        DUMMY_STUB = ABI.upcallStub(DUMMY, FunctionDescriptor.ofVoid(), MemorySession.implicit());\n+        DUMMY_STUB = ABI.upcallStub(DUMMY, FunctionDescriptor.ofVoid(), SegmentScope.auto());\n@@ -84,1 +84,1 @@\n-    static Object[] makeArgs(MemorySession session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {\n+    static Object[] makeArgs(SegmentScope session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {\n@@ -88,1 +88,1 @@\n-    static Object[] makeArgs(MemorySession session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) throws ReflectiveOperationException {\n+    static Object[] makeArgs(SegmentScope session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) throws ReflectiveOperationException {\n@@ -101,1 +101,1 @@\n-    static MemorySegment makeCallback(MemorySession session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) {\n+    static MemorySegment makeCallback(SegmentScope session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) {\n@@ -155,1 +155,1 @@\n-                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize(), MemorySession.implicit());\n+                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize(), SegmentScope.auto());\n","filename":"test\/jdk\/java\/foreign\/TestUpcallBase.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -47,0 +46,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -90,1 +90,1 @@\n-                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize(), MemorySession.implicit());\n+                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize(), SegmentScope.auto());\n@@ -106,1 +106,1 @@\n-            MemorySegment upcallStub = LINKER.upcallStub(target, upcallDescriptor, arena.session());\n+            MemorySegment upcallStub = LINKER.upcallStub(target, upcallDescriptor, arena.scope());\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-            Object[] args = makeArgs(arena.session(), ret, paramTypes, fields, returnChecks, argChecks);\n+            Object[] args = makeArgs(arena.scope(), ret, paramTypes, fields, returnChecks, argChecks);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallScope.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -60,1 +60,1 @@\n-            Object[] args = makeArgsStack(arena.session(), ret, paramTypes, fields, returnChecks, argChecks);\n+            Object[] args = makeArgsStack(arena.scope(), ret, paramTypes, fields, returnChecks, argChecks);\n@@ -74,1 +74,1 @@\n-    static Object[] makeArgsStack(MemorySession session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {\n+    static Object[] makeArgsStack(SegmentScope session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStack.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -93,2 +93,2 @@\n-            MemorySegment upcallStub = LINKER.upcallStub(target, upcallDesc, arena.session());\n-            MemorySegment argSegment = MemorySegment.allocateNative(S_PDI_LAYOUT, arena.session());;\n+            MemorySegment upcallStub = LINKER.upcallStub(target, upcallDesc, arena.scope());\n+            MemorySegment argSegment = MemorySegment.allocateNative(S_PDI_LAYOUT, arena.scope());;\n@@ -99,1 +99,1 @@\n-        assertFalse(captured.session().isAlive());\n+        assertFalse(captured.scope().isAlive());\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -75,3 +75,3 @@\n-            MemorySegment writeBack = LINKER.upcallStub(checker, FunctionDescriptor.ofVoid(C_INT, C_POINTER), arena.session());\n-            MemorySegment callInfo = MemorySegment.allocateNative(CallInfo.LAYOUT, arena.session());;\n-            MemorySegment argIDs = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(args.size(), C_INT), arena.session());;\n+            MemorySegment writeBack = LINKER.upcallStub(checker, FunctionDescriptor.ofVoid(C_INT, C_POINTER), arena.scope());\n+            MemorySegment callInfo = MemorySegment.allocateNative(CallInfo.LAYOUT, arena.scope());;\n+            MemorySegment argIDs = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(args.size(), C_INT), arena.scope());;\n@@ -129,1 +129,1 @@\n-            MemorySegment seg = MemorySegment.ofAddress(ptr.address(), layout.byteSize(), arena.session());\n+            MemorySegment seg = MemorySegment.ofAddress(ptr.address(), layout.byteSize(), arena.scope());\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -69,1 +69,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(1L, 2, MemorySession.implicit());\n+        MemorySegment segment = MemorySegment.allocateNative(1L, 2, SegmentScope.auto());\n@@ -106,1 +106,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(inner_size * outer_size * 8, 4, arena.session());;\n+            MemorySegment segment = MemorySegment.allocateNative(inner_size * outer_size * 8, 4, arena.scope());;\n","filename":"test\/jdk\/java\/foreign\/TestVarHandleCombinators.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-            MemorySegment stub = Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), arena.session());\n+            MemorySegment stub = Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), arena.scope());\n@@ -89,1 +89,1 @@\n-            MemorySegment stub = Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.of(C_INT, C_INT), arena.session());\n+            MemorySegment stub = Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.of(C_INT, C_INT), arena.scope());\n","filename":"test\/jdk\/java\/foreign\/ThrowingUpcall.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @requires sun.arch.data.model == \"64\"\n@@ -56,0 +57,1 @@\n+\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestLinuxAArch64CallArranger.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestSysVCallArranger.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestWindowsCallArranger.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import java.lang.foreign.MemorySession;\n","filename":"test\/jdk\/java\/foreign\/capturecallstate\/TestCaptureCallState.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -71,1 +71,1 @@\n-    static ByteBuffer segmentBufferOfSize(MemorySession session, int size) {\n+    static ByteBuffer segmentBufferOfSize(SegmentScope session, int size) {\n@@ -79,1 +79,1 @@\n-    static ByteBuffer[] segmentBuffersOfSize(int len, MemorySession session, int size) {\n+    static ByteBuffer[] segmentBuffersOfSize(int len, SegmentScope session, int size) {\n@@ -91,1 +91,1 @@\n-    static ByteBuffer[] mixedBuffersOfSize(int len, MemorySession session, int size) {\n+    static ByteBuffer[] mixedBuffersOfSize(int len, SegmentScope session, int size) {\n","filename":"test\/jdk\/java\/foreign\/channels\/AbstractChannelsTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -79,1 +78,1 @@\n-            var segment = MemorySegment.allocateNative(10, 1, drop.session());\n+            var segment = MemorySegment.allocateNative(10, 1, drop.scope());\n@@ -112,2 +111,2 @@\n-            ByteBuffer bb = segmentBufferOfSize(drop.session(), 64);\n-            ByteBuffer[] buffers = segmentBuffersOfSize(8, drop.session(), 32);\n+            ByteBuffer bb = segmentBufferOfSize(drop.scope(), 64);\n+            ByteBuffer[] buffers = segmentBuffersOfSize(8, drop.scope(), 32);\n@@ -164,2 +163,2 @@\n-            MemorySegment segment1 = MemorySegment.allocateNative(10, 1, drop.session());\n-            MemorySegment segment2 = MemorySegment.allocateNative(10, 1, drop.session());\n+            MemorySegment segment1 = MemorySegment.allocateNative(10, 1, drop.scope());\n+            MemorySegment segment2 = MemorySegment.allocateNative(10, 1, drop.scope());\n@@ -188,2 +187,2 @@\n-                var writeBuffers = mixedBuffersOfSize(16, drop.session(), 32);\n-                var readBuffers = mixedBuffersOfSize(16, drop.session(), 32);\n+                var writeBuffers = mixedBuffersOfSize(16, drop.scope(), 32);\n+                var readBuffers = mixedBuffersOfSize(16, drop.scope(), 32);\n@@ -211,1 +210,1 @@\n-            var segment = MemorySegment.allocateNative(10, 1, drop.session());\n+            var segment = MemorySegment.allocateNative(10, 1, drop.scope());\n@@ -225,1 +224,1 @@\n-                assertTrue(drop.session().isAlive());\n+                assertTrue(drop.scope().isAlive());\n@@ -232,1 +231,1 @@\n-                assertTrue(drop.session().isAlive());\n+                assertTrue(drop.scope().isAlive());\n@@ -256,1 +255,1 @@\n-            var bba = segmentBuffersOfSize(32, drop.session(), 128);\n+            var bba = segmentBuffersOfSize(32, drop.scope(), 128);\n@@ -265,1 +264,1 @@\n-                                var bba = segmentBuffersOfSize(32, drop.session(), 128);\n+                                var bba = segmentBuffersOfSize(32, drop.scope(), 128);\n@@ -276,1 +275,1 @@\n-            assertTrue(drop.session().isAlive());\n+            assertTrue(drop.scope().isAlive());\n@@ -284,1 +283,1 @@\n-            assertTrue(drop.session().isAlive());\n+            assertTrue(drop.scope().isAlive());\n","filename":"test\/jdk\/java\/foreign\/channels\/TestAsyncSocketChannels.java","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-import java.lang.foreign.MemorySession;\n+\n@@ -68,1 +68,1 @@\n-            ByteBuffer bb = segmentBufferOfSize(drop.session(), 16);\n+            ByteBuffer bb = segmentBufferOfSize(drop.scope(), 16);\n@@ -87,1 +87,1 @@\n-            ByteBuffer[] buffers = segmentBuffersOfSize(8, drop.session(), 16);\n+            ByteBuffer[] buffers = segmentBuffersOfSize(8, drop.scope(), 16);\n@@ -105,2 +105,2 @@\n-            MemorySegment segment1 = MemorySegment.allocateNative(10, 1, drop.session());\n-            MemorySegment segment2 = MemorySegment.allocateNative(10, 1, drop.session());\n+            MemorySegment segment1 = MemorySegment.allocateNative(10, 1, drop.scope());\n+            MemorySegment segment2 = MemorySegment.allocateNative(10, 1, drop.scope());\n@@ -144,1 +144,1 @@\n-            var segment = MemorySegment.allocateNative(10, 1, drop.session());\n+            var segment = MemorySegment.allocateNative(10, 1, drop.scope());\n@@ -174,2 +174,2 @@\n-            var writeBuffers = mixedBuffersOfSize(32, drop.session(), 64);\n-            var readBuffers = mixedBuffersOfSize(32, drop.session(), 64);\n+            var writeBuffers = mixedBuffersOfSize(32, drop.scope(), 64);\n+            var readBuffers = mixedBuffersOfSize(32, drop.scope(), 64);\n@@ -192,1 +192,1 @@\n-            var writeBuffers = Stream.of(mixedBuffersOfSize(16, drop1.session(), 64), mixedBuffersOfSize(16, drop2.session(), 64))\n+            var writeBuffers = Stream.of(mixedBuffersOfSize(16, drop1.scope(), 64), mixedBuffersOfSize(16, drop2.scope(), 64))\n@@ -195,1 +195,1 @@\n-            var readBuffers = Stream.of(mixedBuffersOfSize(16, drop1.session(), 64), mixedBuffersOfSize(16, drop2.session(), 64))\n+            var readBuffers = Stream.of(mixedBuffersOfSize(16, drop1.scope(), 64), mixedBuffersOfSize(16, drop2.scope(), 64))\n","filename":"test\/jdk\/java\/foreign\/channels\/TestSocketChannels.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -55,1 +54,1 @@\n-            arena.session().whileAlive(() -> {\n+            arena.scope().whileAlive(() -> {\n","filename":"test\/jdk\/java\/foreign\/dontrelease\/TestDontRelease.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -42,1 +43,1 @@\n-        MemorySegment.ofAddress(0, 4000, MemorySession.global());\n+        MemorySegment.ofAddress(0, 4000, SegmentScope.global());\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainDirect.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -46,2 +47,2 @@\n-                MethodType.methodType(MemorySegment.class, long.class, long.class, MemorySession.class));\n-        var seg = (MemorySegment)mh.invokeExact(0L, 4000L, MemorySession.global());\n+                MethodType.methodType(MemorySegment.class, long.class, long.class, SegmentScope.class));\n+        var seg = (MemorySegment)mh.invokeExact(0L, 4000L, SegmentScope.global());\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainInvoke.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -44,2 +45,2 @@\n-        Method method = MemorySegment.class.getDeclaredMethod(\"ofAddress\", long.class, long.class, MemorySession.class);\n-        method.invoke(null, 0L, 4000L, MemorySession.global());\n+        Method method = MemorySegment.class.getDeclaredMethod(\"ofAddress\", long.class, long.class, SegmentScope.class);\n+        method.invoke(null, 0L, 4000L, SegmentScope.global());\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainReflection.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -75,1 +75,1 @@\n-        addDefaultMapping(MemorySession.class, MemorySession.implicit());\n+        addDefaultMapping(SegmentScope.class, SegmentScope.auto());\n","filename":"test\/jdk\/java\/foreign\/handles\/invoker_module\/handle\/invoker\/MethodHandleInvoker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -54,1 +54,1 @@\n-                            MethodType.methodType(MemorySegment.class, long.class, long.class, MemorySession.class)),\n+                            MethodType.methodType(MemorySegment.class, long.class, long.class, SegmentScope.class)),\n@@ -57,1 +57,1 @@\n-                            MethodType.methodType(SymbolLookup.class, String.class, MemorySession.class)),\n+                            MethodType.methodType(SymbolLookup.class, String.class, SegmentScope.class)),\n@@ -60,1 +60,1 @@\n-                            MethodType.methodType(SymbolLookup.class, Path.class, MemorySession.class)),\n+                            MethodType.methodType(SymbolLookup.class, Path.class, SegmentScope.class)),\n","filename":"test\/jdk\/java\/foreign\/handles\/lookup_module\/handle\/lookup\/MethodHandleLookup.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-            MemorySegment upcallStub = LINKER.upcallStub(saver, upcallDesc, arena.session());\n+            MemorySegment upcallStub = LINKER.upcallStub(saver, upcallDesc, arena.scope());\n@@ -189,1 +189,1 @@\n-            MemorySegment callback = LINKER.upcallStub(upcallTarget, FunctionDescriptor.ofVoid(JAVA_BOOLEAN), arena.session());\n+            MemorySegment callback = LINKER.upcallStub(upcallTarget, FunctionDescriptor.ofVoid(JAVA_BOOLEAN), arena.scope());\n@@ -203,1 +203,1 @@\n-            { 0b01,          true  }, \/\/ zero least significant bit, but non-zero first byte\n+            { 0b10,          true  }, \/\/ zero least significant bit, but non-zero first byte\n","filename":"test\/jdk\/java\/foreign\/normalize\/TestNormalize.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), arena.session());\n+            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), arena.scope());\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestAsyncStackWalk.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), arena.session());\n+            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), arena.scope());\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestStackWalk.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(C_INT, C_INT, C_INT, C_INT), arena.session());\n+            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(C_INT, C_INT, C_INT, C_INT), arena.scope());\n","filename":"test\/jdk\/java\/foreign\/upcalldeopt\/TestUpcallDeopt.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -129,1 +130,1 @@\n-            = actions -> Windowsx64Linker.newVaList(actions, MemorySession.implicit());\n+            = actions -> Windowsx64Linker.newVaList(actions, SegmentScope.auto());\n@@ -131,1 +132,1 @@\n-            = actions -> SysVx64Linker.newVaList(actions, MemorySession.implicit());\n+            = actions -> SysVx64Linker.newVaList(actions, SegmentScope.auto());\n@@ -133,1 +134,1 @@\n-            = actions -> LinuxAArch64Linker.newVaList(actions, MemorySession.implicit());\n+            = actions -> LinuxAArch64Linker.newVaList(actions, SegmentScope.auto());\n@@ -135,1 +136,1 @@\n-            = actions -> MacOsAArch64Linker.newVaList(actions, MemorySession.implicit());\n+            = actions -> MacOsAArch64Linker.newVaList(actions, SegmentScope.auto());\n@@ -137,1 +138,1 @@\n-            = (builder) -> VaList.make(builder, MemorySession.implicit());\n+            = (builder) -> VaList.make(builder, SegmentScope.auto());\n@@ -139,1 +140,1 @@\n-    private static final BiFunction<Consumer<VaList.Builder>, MemorySession, VaList> winVaListScopedFactory\n+    private static final BiFunction<Consumer<VaList.Builder>, SegmentScope, VaList> winVaListScopedFactory\n@@ -141,1 +142,1 @@\n-    private static final BiFunction<Consumer<VaList.Builder>, MemorySession, VaList> sysvVaListScopedFactory\n+    private static final BiFunction<Consumer<VaList.Builder>, SegmentScope, VaList> sysvVaListScopedFactory\n@@ -143,1 +144,1 @@\n-    private static final BiFunction<Consumer<VaList.Builder>, MemorySession, VaList> linuxAArch64VaListScopedFactory\n+    private static final BiFunction<Consumer<VaList.Builder>, SegmentScope, VaList> linuxAArch64VaListScopedFactory\n@@ -145,1 +146,1 @@\n-    private static final BiFunction<Consumer<VaList.Builder>, MemorySession, VaList> macAArch64VaListScopedFactory\n+    private static final BiFunction<Consumer<VaList.Builder>, SegmentScope, VaList> macAArch64VaListScopedFactory\n@@ -147,1 +148,1 @@\n-    private static final BiFunction<Consumer<VaList.Builder>, MemorySession, VaList> platformVaListScopedFactory\n+    private static final BiFunction<Consumer<VaList.Builder>, SegmentScope, VaList> platformVaListScopedFactory\n@@ -229,1 +230,1 @@\n-            MemorySegment msInt = MemorySegment.allocateNative(JAVA_INT, arena.session());;\n+            MemorySegment msInt = MemorySegment.allocateNative(JAVA_INT, arena.scope());;\n@@ -247,1 +248,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(pointLayout, MemorySession.implicit());\n+                    MemorySegment struct = MemorySegment.allocateNative(pointLayout, SegmentScope.auto());\n@@ -284,1 +285,1 @@\n-            MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT, arena.session());;\n+            MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT, arena.scope());;\n@@ -300,1 +301,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, MemorySession.implicit());\n+                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, SegmentScope.auto());\n@@ -337,1 +338,1 @@\n-            MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, arena.session());;\n+            MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, arena.scope());;\n@@ -353,1 +354,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT, MemorySession.implicit());\n+                    MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT, SegmentScope.auto());\n@@ -391,1 +392,1 @@\n-            MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT, arena.session());;\n+            MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT, arena.scope());;\n@@ -411,1 +412,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT, MemorySession.implicit());\n+                    MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT, SegmentScope.auto());\n@@ -455,1 +456,1 @@\n-            MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT, arena.session());;\n+            MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT, arena.scope());;\n@@ -507,2 +508,2 @@\n-            MemorySegment longSum = MemorySegment.allocateNative(longLayout, arena.session());;\n-            MemorySegment doubleSum = MemorySegment.allocateNative(doubleLayout, arena.session());;\n+            MemorySegment longSum = MemorySegment.allocateNative(longLayout, arena.scope());;\n+            MemorySegment doubleSum = MemorySegment.allocateNative(doubleLayout, arena.scope());;\n@@ -535,1 +536,1 @@\n-            MemorySegment stub = abi.upcallStub(callback, desc, arena.session());\n+            MemorySegment stub = abi.upcallStub(callback, desc, arena.scope());\n@@ -571,1 +572,1 @@\n-    public void testScopedVaList(BiFunction<Consumer<VaList.Builder>, MemorySession, VaList> vaListFactory,\n+    public void testScopedVaList(BiFunction<Consumer<VaList.Builder>, SegmentScope, VaList> vaListFactory,\n@@ -577,1 +578,1 @@\n-                    .addVarg(intLayout, 8), arena.session());\n+                    .addVarg(intLayout, 8), arena.scope());\n@@ -582,1 +583,1 @@\n-        assertFalse(listLeaked.segment().session().isAlive());\n+        assertFalse(listLeaked.segment().scope().isAlive());\n@@ -592,1 +593,1 @@\n-                MemorySegment pointIn = MemorySegment.allocateNative(Point_LAYOUT, innerArena.session());;\n+                MemorySegment pointIn = MemorySegment.allocateNative(Point_LAYOUT, innerArena.scope());;\n@@ -596,1 +597,1 @@\n-                pointOut = MemorySegment.allocateNative(Point_LAYOUT, arena.session());;\n+                pointOut = MemorySegment.allocateNative(Point_LAYOUT, arena.scope());;\n@@ -600,1 +601,1 @@\n-                assertTrue(pointOut.session().isAlive()); \/\/ after VaList freed\n+                assertTrue(pointOut.scope().isAlive()); \/\/ after VaList freed\n@@ -602,1 +603,1 @@\n-            assertTrue(pointOut.session().isAlive()); \/\/ after inner session freed\n+            assertTrue(pointOut.scope().isAlive()); \/\/ after inner session freed\n@@ -604,1 +605,1 @@\n-        assertFalse(pointOut.session().isAlive()); \/\/ after outer session freed\n+        assertFalse(pointOut.scope().isAlive()); \/\/ after outer session freed\n@@ -618,1 +619,1 @@\n-    public void testCopy(BiFunction<Consumer<VaList.Builder>, MemorySession, VaList> vaListFactory, ValueLayout.OfInt intLayout) {\n+    public void testCopy(BiFunction<Consumer<VaList.Builder>, SegmentScope, VaList> vaListFactory, ValueLayout.OfInt intLayout) {\n@@ -621,1 +622,1 @@\n-                    .addVarg(intLayout, 8), arena.session());\n+                    .addVarg(intLayout, 8), arena.scope());\n@@ -640,1 +641,1 @@\n-    public void testCopyUnusableAfterOriginalClosed(BiFunction<Consumer<VaList.Builder>, MemorySession, VaList> vaListFactory,\n+    public void testCopyUnusableAfterOriginalClosed(BiFunction<Consumer<VaList.Builder>, SegmentScope, VaList> vaListFactory,\n@@ -645,1 +646,1 @@\n-                    .addVarg(intLayout, 8), arena.session());\n+                    .addVarg(intLayout, 8), arena.scope());\n@@ -683,1 +684,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, MemorySession.implicit());\n+                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, SegmentScope.auto());\n@@ -690,1 +691,1 @@\n-                    MemorySegment struct =  MemorySegment.allocateNative(BigPoint_LAYOUT, MemorySession.implicit());\n+                    MemorySegment struct =  MemorySegment.allocateNative(BigPoint_LAYOUT, SegmentScope.auto());\n@@ -704,1 +705,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, MemorySession.implicit());\n+                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, SegmentScope.auto());\n@@ -716,1 +717,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT, MemorySession.implicit());\n+                    MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT, SegmentScope.auto());\n@@ -722,1 +723,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT, MemorySession.implicit());\n+                    MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT, SegmentScope.auto());\n@@ -729,1 +730,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT, MemorySession.implicit());\n+                    MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT, SegmentScope.auto());\n@@ -774,1 +775,1 @@\n-                    MemorySegment buffer = MemorySegment.allocateNative(BigPoint_LAYOUT, MemorySession.implicit());\n+                    MemorySegment buffer = MemorySegment.allocateNative(BigPoint_LAYOUT, SegmentScope.auto());\n@@ -824,1 +825,1 @@\n-        return VaList.ofAddress(segment.address(), MemorySession.implicit());\n+        return VaList.ofAddress(segment.address(), SegmentScope.auto());\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":43,"deletions":42,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8295803\n+ * @summary Tests System.console() returns correct Console (or null) from the expected\n+ *          module.\n+ * @modules java.base\/java.io:+open\n+ * @run main\/othervm ModuleSelectionTest jdk.internal.le\n+ * @run main\/othervm -Djdk.console=jdk.internal.le ModuleSelectionTest jdk.internal.le\n+ * @run main\/othervm -Djdk.console=java.base ModuleSelectionTest java.base\n+ * @run main\/othervm --limit-modules java.base ModuleSelectionTest java.base\n+ *\/\n+\n+import java.io.Console;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+\n+public class ModuleSelectionTest {\n+    public static void main(String... args) throws Throwable {\n+        var con = System.console();\n+        var pc = Class.forName(\"java.io.ProxyingConsole\");\n+        var jdkc = Class.forName(\"jdk.internal.io.JdkConsole\");\n+        var istty = (boolean)MethodHandles.privateLookupIn(Console.class, MethodHandles.lookup())\n+                .findStatic(Console.class, \"istty\", MethodType.methodType(boolean.class))\n+                .invoke();\n+        var impl = con != null ? MethodHandles.privateLookupIn(pc, MethodHandles.lookup())\n+                .findGetter(pc, \"delegate\", jdkc)\n+                .invoke(con) : null;\n+\n+        var expected = switch (args[0]) {\n+            case \"java.base\" -> istty ? \"java.base\" : \"null\";\n+            default -> args[0];\n+        };\n+        var actual = con == null ? \"null\" : impl.getClass().getModule().getName();\n+\n+        if (!actual.equals(expected)) {\n+            throw new RuntimeException(\"\"\"\n+                Console implementation is not the expected one.\n+                Expected: %s\n+                Actual: %s\n+                \"\"\".formatted(expected, actual));\n+        } else {\n+            System.out.printf(\"%s is the expected implementation. (tty: %s)\\n\", impl, istty);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/Console\/ModuleSelectionTest.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.nio.file.Files;\n+\n+import jdk.test.lib.process.ProcessTools;\n+\n+\/**\n+ * @test\n+ * @bug 8295803\n+ * @summary Tests System.console() works with standard input redirection.\n+ * @library \/test\/lib\n+ *\/\n+public class RedirectTest {\n+    public static void main(String... args) throws Throwable {\n+        if (args.length == 0) {\n+            \/\/ no arg will launch the child process that actually perform tests\n+            var pb = ProcessTools.createTestJvm(\"RedirectTest\", \"dummy\");\n+            var input = new File(System.getProperty(\"test.src\", \".\"), \"input.txt\");\n+            pb.redirectInput(input);\n+            var oa = ProcessTools.executeProcess(pb);\n+            var output = oa.asLines();\n+            var expected = Files.readAllLines(input.toPath());\n+            if (!output.equals(expected)) {\n+                throw new RuntimeException(\"\"\"\n+                        Standard out had unexpected strings:\n+                        Actual output: %s\n+                        Expected output: %s\n+                        \"\"\".formatted(output, expected));\n+            }\n+            oa.shouldHaveExitValue(0);\n+        } else {\n+            var con = System.console();\n+            String line;\n+            while ((line = con.readLine()) != null) {\n+                System.out.println(line);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/Console\/RedirectTest.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8295803\n+ * @summary Tests System.console() works with the security manager\n+ * @run main\/othervm\/java.security.policy=test.policy -Djava.security.manager -Djdk.console=jdk.internal.le SecurityManagerTest\n+ *\/\n+public class SecurityManagerTest {\n+    public static void main(String... args) {\n+        System.console();\n+        \/\/ consider it successful if ServiceConfigurationError was not thrown here\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/Console\/SecurityManagerTest.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+This is line 1\n+This is line 2\n+This is the last line\n","filename":"test\/jdk\/java\/io\/Console\/input.txt","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+grant {\n+    permission java.io.FilePermission \"<<ALL FILES>>\",\"read,write,delete\";\n+};\n","filename":"test\/jdk\/java\/io\/Console\/test.policy","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,206 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.SequenceInputStream;\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+import org.testng.annotations.Test;\n+\n+import jdk.test.lib.RandomFactory;\n+\n+import static java.lang.String.format;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertThrows;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n+ * @run testng\/othervm\/timeout=180 TransferTo\n+ * @bug 8297298\n+ * @summary Tests whether java.io.SequenceInputStream.transferTo conforms to the\n+ *          InputStream.transferTo specification\n+ * @key randomness\n+ *\/\n+public class TransferTo {\n+    private static final int MIN_SIZE      = 10_000;\n+    private static final int MAX_SIZE_INCR = 100_000_000 - MIN_SIZE;\n+\n+    private static final int ITERATIONS = 10;\n+\n+    private static final Random RND = RandomFactory.getRandom();\n+\n+    \/*\n+     * Testing API compliance: input stream must throw NullPointerException\n+     * when parameter \"out\" is null.\n+     *\/\n+    @Test\n+    public void testNullPointerException() throws Exception {\n+        \/\/ factory for incoming data provider\n+        InputStreamProvider inputStreamProvider = byteArrayInput();\n+\n+        \/\/ tests empty input stream\n+        assertThrows(NullPointerException.class,\n+                () -> inputStreamProvider.input().transferTo(null));\n+\n+        \/\/ tests single-byte input stream\n+        assertThrows(NullPointerException.class,\n+                () -> inputStreamProvider.input((byte) 1).transferTo(null));\n+\n+        \/\/ tests dual-byte input stream\n+        assertThrows(NullPointerException.class,\n+                () -> inputStreamProvider.input((byte) 1, (byte) 2).transferTo(null));\n+    }\n+\n+    \/*\n+     * Testing API compliance: complete content of input stream must be\n+     * transferred to output stream.\n+     *\/\n+    @Test\n+    public void testStreamContents() throws Exception {\n+        \/\/ factory for incoming data provider\n+        InputStreamProvider inputStreamProvider = byteArrayInput();\n+\n+        \/\/ factory for outgoing data recorder\n+        OutputStreamProvider outputStreamProvider = byteArrayOutput();\n+\n+        \/\/ tests empty input stream\n+        checkTransferredContents(inputStreamProvider,\n+                outputStreamProvider, new byte[0]);\n+\n+        \/\/ tests input stream with a length between 1k and 4k\n+        checkTransferredContents(inputStreamProvider,\n+                outputStreamProvider, createRandomBytes(1024, 4096));\n+\n+        \/\/ tests input stream with several data chunks, as 16k is more than a\n+        \/\/ single chunk can hold\n+        checkTransferredContents(inputStreamProvider,\n+                outputStreamProvider, createRandomBytes(16384, 16384));\n+\n+        \/\/ tests randomly chosen starting positions within source and\n+        \/\/ target stream\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            byte[] inBytes = createRandomBytes(MIN_SIZE, MAX_SIZE_INCR);\n+            int posIn = RND.nextInt(inBytes.length);\n+            int posOut = RND.nextInt(MIN_SIZE);\n+            checkTransferredContents(inputStreamProvider,\n+                    outputStreamProvider, inBytes, posIn, posOut);\n+        }\n+\n+        \/\/ tests reading beyond source EOF (must not transfer any bytes)\n+        checkTransferredContents(inputStreamProvider,\n+                outputStreamProvider, createRandomBytes(4096, 0), 4096, 0);\n+\n+        \/\/ tests writing beyond target EOF (must extend output stream)\n+        checkTransferredContents(inputStreamProvider,\n+                outputStreamProvider, createRandomBytes(4096, 0), 0, 4096);\n+    }\n+\n+    \/*\n+     * Asserts that the transferred content is correct, i.e., compares the bytes\n+     * actually transferred to those expected. The position of the input and\n+     * output streams before the transfer are zero (BOF).\n+     *\/\n+    private static void checkTransferredContents(InputStreamProvider inputStreamProvider,\n+            OutputStreamProvider outputStreamProvider, byte[] inBytes) throws Exception {\n+        checkTransferredContents(inputStreamProvider,\n+                outputStreamProvider, inBytes, 0, 0);\n+    }\n+\n+    \/*\n+     * Asserts that the transferred content is correct, i. e. compares the bytes\n+     * actually transferred to those expected. The positions of the input and\n+     * output streams before the transfer are provided by the caller.\n+     *\/\n+    private static void checkTransferredContents(InputStreamProvider inputStreamProvider,\n+            OutputStreamProvider outputStreamProvider, byte[] inBytes, int posIn,\n+            int posOut) throws Exception {\n+        AtomicReference<Supplier<byte[]>> recorder = new AtomicReference<>();\n+        try (InputStream in = inputStreamProvider.input(inBytes);\n+            OutputStream out = outputStreamProvider.output(recorder::set)) {\n+            \/\/ skip bytes until starting position\n+            in.skipNBytes(posIn);\n+            out.write(new byte[posOut]);\n+\n+            long reported = in.transferTo(out);\n+            int count = inBytes.length - posIn;\n+\n+            assertEquals(reported, count,\n+                    format(\"reported %d bytes but should report %d\", reported, count));\n+\n+            byte[] outBytes = recorder.get().get();\n+            assertTrue(Arrays.equals(inBytes, posIn, posIn + count,\n+                    outBytes, posOut, posOut + count),\n+                    format(\"inBytes.length=%d, outBytes.length=%d\", count, outBytes.length));\n+        }\n+    }\n+\n+    \/*\n+     * Creates an array of random size (between min and min + maxRandomAdditive)\n+     * filled with random bytes\n+     *\/\n+    private static byte[] createRandomBytes(int min, int maxRandomAdditive) {\n+        byte[] bytes = new byte[min +\n+                                (maxRandomAdditive == 0 ? 0 : RND.nextInt(maxRandomAdditive))];\n+        RND.nextBytes(bytes);\n+        return bytes;\n+    }\n+\n+    private interface InputStreamProvider {\n+        InputStream input(byte... bytes) throws Exception;\n+    }\n+\n+    private interface OutputStreamProvider {\n+        OutputStream output(Consumer<Supplier<byte[]>> spy) throws Exception;\n+    }\n+\n+    private static InputStreamProvider byteArrayInput() {\n+        return bytes -> {\n+            InputStream is1 = new ByteArrayInputStream(bytes, 0, bytes.length \/ 2);\n+            InputStream is2 = new ByteArrayInputStream(bytes, bytes.length \/ 2, bytes.length);\n+            return new SequenceInputStream(is1, is2);\n+        };\n+    }\n+\n+    private static OutputStreamProvider byteArrayOutput() {\n+        return new OutputStreamProvider() {\n+            @Override\n+            public OutputStream output(Consumer<Supplier<byte[]>> spy) {\n+                ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n+                spy.accept(outputStream::toByteArray);\n+                return outputStream;\n+            }\n+        };\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/io\/SequenceInputStream\/TransferTo.java","additions":206,"deletions":0,"binary":false,"changes":206,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4533872 4985214 4985217 4993841 5017268 5017280\n+ * @bug 4533872 4985214 4985217 4993841 5017268 5017280 8298033\n@@ -800,1 +800,1 @@\n-                                      Class expectedException) {\n+                                      Class<? extends Exception> expectedException) {\n@@ -805,1 +805,1 @@\n-            if (expectedException.isInstance(e)) {\n+            if (expectedException == e.getClass()) {\n","filename":"test\/jdk\/java\/lang\/Character\/Supplementary.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-                MemorySession.global());\n+                SegmentScope.global());\n","filename":"test\/jdk\/java\/lang\/Thread\/jni\/AttachCurrentThread\/ImplicitAttach.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Test Thread.yield submits the virtual thread task to the expected queue\n+ * @requires vm.continuations\n+ * @enablePreview\n+ * @run junit\/othervm -Djdk.virtualThreadScheduler.maxPoolSize=1 YieldQueuing\n+ *\/\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.LockSupport;\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class YieldQueuing {\n+\n+    \/**\n+     * Test Thread.yield submits the task for the current virtual thread to a scheduler\n+     * submission queue when there are no tasks in the local queue.\n+     *\/\n+    @Test\n+    void testYieldWithEmptyLocalQueue() throws Exception {\n+        var list = new CopyOnWriteArrayList<String>();\n+\n+        var threadsStarted = new AtomicBoolean();\n+\n+        var threadA = Thread.ofVirtual().unstarted(() -> {\n+            \/\/ pin thread until task for B is in submission queue\n+            while (!threadsStarted.get()) {\n+                Thread.onSpinWait();\n+            }\n+\n+            list.add(\"A\");\n+            Thread.yield();      \/\/ push task for A to submission queue, B should run\n+            list.add(\"A\");\n+        });\n+\n+        var threadB = Thread.ofVirtual().unstarted(() -> {\n+            list.add(\"B\");\n+        });\n+\n+        \/\/ push tasks for A and B to submission queue\n+        threadA.start();\n+        threadB.start();\n+\n+        \/\/ release A\n+        threadsStarted.set(true);\n+\n+        \/\/ wait for result\n+        threadA.join();\n+        threadB.join();\n+        assertEquals(list, List.of(\"A\", \"B\", \"A\"));\n+    }\n+\n+    \/**\n+     * Test Thread.yield submits the task for the current virtual thread to the local\n+     * queue when there are tasks in the local queue.\n+     *\/\n+    @Test\n+    void testYieldWithNonEmptyLocalQueue() throws Exception {\n+        var list = new CopyOnWriteArrayList<String>();\n+\n+        var threadsStarted = new AtomicBoolean();\n+\n+        var threadA = Thread.ofVirtual().unstarted(() -> {\n+            \/\/ pin thread until tasks for B and C are in submission queue\n+            while (!threadsStarted.get()) {\n+                Thread.onSpinWait();\n+            }\n+\n+            list.add(\"A\");\n+            LockSupport.park();   \/\/ B should run\n+            list.add(\"A\");\n+        });\n+\n+        var threadB = Thread.ofVirtual().unstarted(() -> {\n+            list.add(\"B\");\n+            LockSupport.unpark(threadA);  \/\/ push task for A to local queue\n+            Thread.yield();               \/\/ push task for B to local queue, A should run\n+            list.add(\"B\");\n+        });\n+\n+        var threadC = Thread.ofVirtual().unstarted(() -> {\n+            list.add(\"C\");\n+        });\n+\n+        \/\/ push tasks for A, B and C to submission queue\n+        threadA.start();\n+        threadB.start();\n+        threadC.start();\n+\n+        \/\/ release A\n+        threadsStarted.set(true);\n+\n+        \/\/ wait for result\n+        threadA.join();\n+        threadB.join();\n+        threadC.join();\n+        assertEquals(list, List.of(\"A\", \"B\", \"A\", \"B\", \"C\"));\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/YieldQueuing.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -29,1 +29,1 @@\n- * @run main YieldALot 500000\n+ * @run main YieldALot 350000\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/YieldALot.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -753,7 +753,0 @@\n-    @Test\n-    public void testAllowThreadSuspension() {\n-        ThreadGroup group = new ThreadGroup(\"foo\");\n-        assertFalse(group.allowThreadSuspension(false));\n-        assertFalse(group.allowThreadSuspension(true));\n-    }\n-\n","filename":"test\/jdk\/java\/lang\/ThreadGroup\/BasicTests.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -291,1 +291,1 @@\n- * @run main\/othervm -Xmx8g\n+ * @run main\/othervm\/timeout=180 -Xmx8g\n","filename":"test\/jdk\/java\/lang\/instrument\/GetObjectSizeIntrinsicsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-import java.lang.foreign.MemorySession;\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestExact.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @requires vm.gc != \"Z\" & vm.gc != \"Shenandoah\"\n+ * @requires vm.gc != \"Z\" & vm.gc != \"Shenandoah\" & !vm.gc.G1\n@@ -48,0 +48,12 @@\n+\/*\n+ * @test\n+ * @bug     4530538\n+ * @summary Basic unit test of MemoryMXBean.getMemoryPools() and\n+ *          MemoryMXBean.getMemoryManager().\n+ * @requires vm.gc.G1\n+ * @author  Mandy Chung\n+ *\n+ * @modules jdk.management\n+ * @run main MemoryTest 3 3\n+ *\/\n+\n","filename":"test\/jdk\/java\/lang\/management\/MemoryMXBean\/MemoryTest.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-        Class<?> modulePrivateIntf = Class.forName(\"sun.net.ProgressListener\");\n+        Class<?> modulePrivateIntf = Class.forName(\"sun.net.PlatformSocketImpl\");\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/ProxyModuleMapping.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- *      7171415 6339649 6933879 8037396 8272072 8051627\n+ *      7171415 6339649 6933879 8037396 8272072 8051627 8297687\n@@ -1622,0 +1622,47 @@\n+        b8297687();\n+    }\n+\n+    private static void b8297687() {\n+        \/\/ constructors that take a hostname should fail\n+        test(\"ftps\", \"p.e.local|SIT@p.e.local\", \"\/path\", null)\n+                .x().z();\n+        test(\"ftps\", null,\"p.e.local|SIT@p.e.local\", -1, \"\/path\", null, null)\n+                .x().z();\n+        \/\/ constructors that take an authority component should succeed\n+        test(\"ftps\", \"p.e.local|SIT@p.e.local\", \"\/path\", null,null)\n+                .s(\"ftps\")\n+                .sp(\"\/\/p.e.local%7CSIT@p.e.local\/path\")\n+                .spd(\"\/\/p.e.local|SIT@p.e.local\/path\")\n+                .u(\"p.e.local%7CSIT\")\n+                .ud(\"p.e.local|SIT\")\n+                .h(\"p.e.local\")\n+                .n(-1)\n+                .p(\"\/path\")\n+                .pd(\"\/path\")\n+                .z();\n+\n+        \/\/ check index in exception for constructors that should fail\n+        try {\n+            URI uri = new URI(\"ftps\", \"p.e.local|SIT@p.e.local\", \"\/path\", null);\n+            throw new AssertionError(\"Expected URISyntaxException not thrown for \" + uri);\n+        } catch (URISyntaxException ex) {\n+            if (ex.getMessage().contains(\"at index 16\")) {\n+                 System.out.println(\"Got expected exception: \" + ex);\n+            } else {\n+                throw new AssertionError(\"Exception does not point at index 16\", ex);\n+            }\n+        }\n+        testCount++;\n+\n+        \/\/ check index in exception for constructors that should fail\n+        try {\n+            URI uri = new URI(\"ftps\", null, \"p.e.local|SIT@p.e.local\", -1, \"\/path\", null, null);\n+            throw new AssertionError(\"Expected URISyntaxException not thrown for \" + uri);\n+        } catch (URISyntaxException ex) {\n+            if (ex.getMessage().contains(\"at index 16\")) {\n+                System.out.println(\"Got expected exception: \" + ex);\n+            } else {\n+                throw new AssertionError(\"Exception does not point at index 16\", ex);\n+            }\n+        }\n+        testCount++;\n","filename":"test\/jdk\/java\/net\/URI\/Test.java","additions":48,"deletions":1,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -0,0 +1,176 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8294047\n+ * @library \/test\/lib\n+ * @run junit HttpResponseInputStreamInterruptTest\n+ *\/\n+\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n+import jdk.test.lib.net.URIBuilder;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n+public class HttpResponseInputStreamInterruptTest {\n+\n+    HttpServer server;\n+    int port;\n+    private final CountDownLatch interruptReadyLatch = new CountDownLatch(2);\n+    private final CountDownLatch interruptDoneLatch = new CountDownLatch(1);\n+    static final String FIRST_MESSAGE = \"Should be received\";\n+    static final String SECOND_MESSAGE = \"Shouldn't be received\";\n+\n+    @BeforeAll\n+    void before() throws Exception {\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n+        InetSocketAddress addr = new InetSocketAddress(loopback, 0);\n+        server = HttpServer.create(addr, 0);\n+        port = server.getAddress().getPort();\n+        Handler handler = new Handler(interruptReadyLatch, interruptDoneLatch);\n+        server.createContext(\"\/HttpResponseInputStreamInterruptTest\/\", handler);\n+        server.start();\n+    }\n+\n+    @AfterAll\n+    void after() throws Exception {\n+        server.stop(0);\n+    }\n+\n+    @Test\n+    public void test() throws Exception {\n+        \/\/ create client and interrupter threads\n+        Thread clientThread = createClientThread(interruptReadyLatch, port);\n+        Thread interrupterThread = new Thread(() -> {\n+            try {\n+                \/\/ wait until the clientThread is just about to read the second message sent by the server\n+                \/\/ then interrupt the thread to cause an error to be thrown\n+                interruptReadyLatch.await();\n+                clientThread.interrupt();\n+                interruptDoneLatch.countDown();\n+            } catch (InterruptedException e) {\n+                System.out.println(\"interrupterThread failed\");\n+                throw new RuntimeException(e);\n+            }\n+        });\n+\n+        \/\/ Start the threads then wait until clientThread completes\n+        clientThread.start();\n+        interrupterThread.start();\n+        clientThread.join();\n+    }\n+\n+    static class Handler implements HttpHandler {\n+\n+        CountDownLatch interruptReadyLatch;\n+        CountDownLatch interruptDoneLatch;\n+\n+        public Handler(CountDownLatch interruptReadyLatch, CountDownLatch interruptDoneLatch) {\n+            this.interruptReadyLatch = interruptReadyLatch;\n+            this.interruptDoneLatch = interruptDoneLatch;\n+        }\n+\n+        @Override\n+        public void handle(HttpExchange exchange) throws IOException {\n+            try (OutputStream os = exchange.getResponseBody()) {\n+                byte[] workingResponse = FIRST_MESSAGE.getBytes();\n+                byte[] errorResponse = SECOND_MESSAGE.getBytes();\n+                exchange.sendResponseHeaders(200, workingResponse.length + errorResponse.length);\n+\n+                \/\/ write and flush the first message which is expected to be received successfully\n+                os.write(workingResponse);\n+                os.flush();\n+\n+                \/\/ await the interrupt threads completion, then write the second message\n+                interruptReadyLatch.countDown();\n+                interruptDoneLatch.await();\n+                os.write(errorResponse);\n+            } catch (InterruptedException e) {\n+                System.out.println(\"interruptDoneLatch await failed\");\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    static Thread createClientThread(CountDownLatch interruptReadyLatch, int port) {\n+        return new Thread(() -> {\n+            try {\n+                HttpClient client = HttpClient\n+                        .newBuilder()\n+                        .proxy(HttpClient.Builder.NO_PROXY)\n+                        .build();\n+\n+                URI uri = URIBuilder.newBuilder()\n+                        .scheme(\"http\")\n+                        .loopback()\n+                        .port(port)\n+                        .path(\"\/HttpResponseInputStreamInterruptTest\/\")\n+                        .build();\n+\n+                HttpRequest request = HttpRequest\n+                        .newBuilder(uri)\n+                        .GET()\n+                        .build();\n+\n+                \/\/ Send a httpRequest and assert the first response is received as expected\n+                HttpResponse<InputStream> response = client.send(request, HttpResponse.BodyHandlers.ofInputStream());\n+                String firstOutput = new String(response.body().readNBytes(FIRST_MESSAGE.getBytes().length));\n+                assertEquals(firstOutput, FIRST_MESSAGE);\n+\n+                \/\/ countdown on latch, and assert that an IOException is throw due to the interrupt\n+                \/\/ and assert that the cause is a InterruptedException\n+                interruptReadyLatch.countDown();\n+                var thrown = assertThrows(IOException.class, () -> response.body().readAllBytes(), \"expected IOException\");\n+                var cause = thrown.getCause();\n+                assertTrue(cause instanceof InterruptedException, cause + \" is not an InterruptedException\");\n+                var thread = Thread.currentThread();\n+                assertTrue(thread.isInterrupted(), \"Thread \" + thread + \" is not interrupted\");\n+            } catch (Throwable t) {\n+                t.printStackTrace();\n+                fail();\n+            }\n+        });\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpResponseInputStreamInterruptTest.java","additions":176,"deletions":0,"binary":false,"changes":176,"status":"added"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -81,1 +81,1 @@\n-                       MemorySession.openImplicit());\n+                       SegmentScope.auto());\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/LargeMapTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.foreign.Arena;\n@@ -34,1 +35,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -64,1 +65,1 @@\n-        var session = MemorySession.openConfined();\n+        var arena = Arena.openConfined();\n@@ -67,2 +68,2 @@\n-        try (session; fileChannel){\n-            fileChannel.map(FileChannel.MapMode.READ_WRITE, 1L, 10L, session);\n+        try (arena; fileChannel){\n+            fileChannel.map(FileChannel.MapMode.READ_WRITE, 1L, 10L, arena.scope());\n@@ -74,1 +75,1 @@\n-        var session = MemorySession.openConfined();\n+        var arena = Arena.openConfined();\n@@ -77,2 +78,2 @@\n-        try (session; fileChannel){\n-            fileChannel.map(FileChannel.MapMode.READ_WRITE, 1L, 10L, session);\n+        try (arena; fileChannel){\n+            fileChannel.map(FileChannel.MapMode.READ_WRITE, 1L, 10L, arena.scope());\n@@ -163,1 +164,1 @@\n-        public MemorySegment map(MapMode mode, long offset, long size, MemorySession session)\n+        public MemorySegment map(MapMode mode, long offset, long size, SegmentScope scope)\n@@ -166,1 +167,1 @@\n-            return fc.map(mode, offset, size, session);\n+            return fc.map(mode, offset, size, scope);\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/MapToMemorySegmentTest.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @bug 4313887 8129632 8129633 8162624 8146215 8162745 8273655 8274171 8287237\n+ * @bug 4313887 8129632 8129633 8162624 8146215 8162745 8273655 8274171 8287237 8297609\n@@ -190,0 +190,1 @@\n+                new ExType(\"wasm\", List.of(\"application\/wasm\")),\n","filename":"test\/jdk\/java\/nio\/file\/Files\/probeContentType\/Basic.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,85 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.nio.file.Path;\n-\n-import org.testng.Assert;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n-\/*\n- * @test\n- * @bug 8057113\n- * @summary Verify getExtension method\n- * @run testng Extensions\n- *\/\n-public class Extensions {\n-    \/**\n-     * Returns path name string and expected extension pairs.\n-     *\n-     * @return {@code {{\"pathname\", \"extension\"},...}}\n-     *\/\n-    @DataProvider\n-    static Object[][] getProvider() {\n-        Object[][] pairs = {\n-            {\"\",               null},\n-            {\".\",              null},\n-            {\"..\",             \"\"},\n-            {\"...\",            \"\"},\n-            {\"....\",           \"\"},\n-            {\".....\",          \"\"},\n-            {\"aa\",             null},\n-            {\"a.\",             \"\"},\n-            {\".a\",             null},\n-            {\"..a\",            \"a\"},\n-            {\"...a\",           \"a\"},\n-            {\"....a\",          \"a\"},\n-            {\".a.b\",           \"b\"},\n-            {\"...a.b\",         \"b\"},\n-            {\"...a.b.\",        \"\"},\n-            {\"..foo\",          \"foo\"},\n-            {\"foo.\",           \"\"},\n-            {\"test.\",          \"\"},\n-            {\"test..\",         \"\"},\n-            {\"test...\",        \"\"},\n-            {\"test.rb\",        \"rb\"},\n-            {\"a\/b\/d\/test.rb\" , \"rb\"},\n-            {\".a\/b\/d\/test.rb\", \"rb\"},\n-            {\"test\",           null},\n-            {\".profile\",       null},\n-            {\".profile.sh\",    \"sh\"},\n-            {\"foo.tar.gz\",     \"gz\"},\n-            {\"foo.bar.\",       \"\"},\n-            {\"archive.zip\",    \"zip\"},\n-            {\"compress.gzip\",  \"gzip\"},\n-            {\"waitwhat.&$!#%\", \"&$!#%\"},\n-            {\"6.283185307\",    \"283185307\"}\n-        };\n-        return pairs;\n-    }\n-\n-    @Test(dataProvider = \"getProvider\")\n-    public static void get(String pathname, String extension) {\n-        Assert.assertEquals(Path.of(pathname).getExtension(), extension);\n-    }\n-}\n","filename":"test\/jdk\/java\/nio\/file\/Path\/Extensions.java","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run main\/othervm NoSync\n+ * @run main\/othervm -Djava.security.egd=file:\/dev\/urandom NoSync\n","filename":"test\/jdk\/java\/security\/SecureRandom\/NoSync.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.util.JarUtils;\n+import jdk.test.lib.SecurityTools;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import java.util.Calendar;\n+import java.util.Locale;\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.nio.file.Paths;\n+import java.nio.file.Path;\n+import java.nio.file.Files;\n+import static java.util.Calendar.WEDNESDAY;\n+\n+\/*\n+ * @test\n+ * @bug 8297684 8269039\n+ * @summary Checking custom CalendarDataProvider with SPI contained in signed jar does\n+ *          not produce NPE.\n+ * @modules java.base\/sun.security.pkcs\n+ *          java.base\/sun.security.timestamp\n+ *          java.base\/sun.security.x509\n+ *          java.base\/sun.security.util\n+ *          java.base\/sun.security.tools.keytool\n+ *          jdk.jartool\/jdk.security.jarsigner\n+ * @library \/test\/lib\n+ * @library provider\n+ * @build baz.CalendarDataProviderImpl\n+ * @run main\/timeout=600 TestSPISigned\n+ *\/\n+public class TestSPISigned {\n+\n+    private static final String TEST_CLASSES = System.getProperty(\"test.classes\", \".\");\n+    private static final String TEST_SRC = System.getProperty(\"test.src\", \".\");\n+\n+    private static final Path META_INF_DIR = Paths.get(TEST_SRC, \"provider\", \"meta\");\n+    private static final Path PROVIDER_PARENT = Paths.get(TEST_CLASSES, \"..\");\n+    private static final Path PROVIDER_DIR = PROVIDER_PARENT.resolve(\"provider\");\n+    private static final Path MODS_DIR = Paths.get(\"mods\");\n+    private static final Path UNSIGNED_JAR = MODS_DIR.resolve(\"unsigned-with-locale.jar\");\n+    private static final Path SIGNED_JAR = MODS_DIR.resolve(\"signed-with-locale.jar\");\n+\n+    public static void main(String[] args) throws Throwable {\n+        if (args.length == 1) {\n+            String arg = args[0];\n+            if (\"run-test\".equals(arg)) {\n+                System.out.println(\"Debug: Running test\");\n+                String provProp = System.getProperty(\"java.locale.providers\");\n+                if (!\"SPI\".equals(provProp)) {\n+                   throw new RuntimeException(\"Test failed! Expected -Djava.locale.providers=SPI to be set for test run\");\n+                }\n+                doRunTest();\n+            } else {\n+               throw new RuntimeException(\"Test failed! Expected 'run-test' arg for test run\");\n+            }\n+        } else {\n+            \/\/ Set up signed jar with custom calendar data provider\n+            \/\/\n+            \/\/ 1. Create jar with custom CalendarDataProvider\n+            JarUtils.createJarFile(UNSIGNED_JAR, PROVIDER_DIR);\n+            JarUtils.updateJarFile(UNSIGNED_JAR, META_INF_DIR);\n+            \/\/ create signer's keypair\n+            SecurityTools.keytool(\"-genkeypair -keyalg RSA -keystore ks \" +\n+                                  \"-storepass changeit -dname CN=test -alias test\")\n+                     .shouldHaveExitValue(0);\n+            \/\/ sign jar\n+            SecurityTools.jarsigner(\"-keystore ks -storepass changeit \" +\n+                                \"-signedjar \" + SIGNED_JAR + \" \" + UNSIGNED_JAR + \" test\")\n+                     .shouldHaveExitValue(0);\n+            \/\/ run test, which must not throw a NPE\n+            List<String> testRun = new ArrayList<>();\n+            testRun.add(\"-Djava.locale.providers=SPI\");\n+            testRun.add(\"-cp\");\n+            String classPath = System.getProperty(\"java.class.path\");\n+            classPath = classPath + \":\" + SIGNED_JAR.toAbsolutePath().toString();\n+            testRun.add(classPath);\n+            testRun.add(TestSPISigned.class.getSimpleName());\n+            testRun.add(\"run-test\");\n+            OutputAnalyzer out = ProcessTools.executeTestJvm(testRun);\n+            out.shouldHaveExitValue(0);\n+            out.shouldContain(\"DEBUG: Getting xx language\");\n+        }\n+    }\n+\n+    private static void doRunTest() {\n+        Locale locale = new Locale(\"xx\", \"YY\");\n+        Calendar kcal = Calendar.getInstance(locale);\n+        try {\n+            check(WEDNESDAY, kcal.getFirstDayOfWeek());\n+            check(7, kcal.getMinimalDaysInFirstWeek());\n+        } catch (Throwable ex) {\n+            throw new RuntimeException(\"Test failed with signed jar and \" +\n+                    \" argument java.locale.providers=SPI\", ex);\n+        }\n+    }\n+\n+    private static <T> void check(T expected, T actual) {\n+        Asserts.assertEquals(expected, actual, \"Expected calendar from SPI to be in effect\");\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/security\/SignedJar\/spi-calendar-provider\/TestSPISigned.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package baz;\n+\n+import static java.util.Calendar.*;\n+import java.util.Locale;\n+import java.util.spi.CalendarDataProvider;\n+\n+public class CalendarDataProviderImpl extends CalendarDataProvider {\n+    private static final Locale[] locales = { new Locale(\"xx\", \"YY\") };\n+\n+    @Override\n+    public int getFirstDayOfWeek(Locale locale) {\n+        return WEDNESDAY;\n+    }\n+\n+    @Override\n+    public int getMinimalDaysInFirstWeek(Locale locale) {\n+        if (locale.getLanguage().equals(\"xx\")) {\n+            System.out.println(\"DEBUG: Getting xx language\");\n+        }\n+        return 7;\n+    }\n+\n+    @Override\n+    public Locale[] getAvailableLocales() {\n+        return locales;\n+    }\n+}\n","filename":"test\/jdk\/java\/security\/SignedJar\/spi-calendar-provider\/provider\/baz\/CalendarDataProviderImpl.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+#\n+#\n+#\n+# fully-qualified name of the java.util.spi.CalendarDataProvider\n+# implementation class\n+#\n+baz.CalendarDataProviderImpl\n","filename":"test\/jdk\/java\/security\/SignedJar\/spi-calendar-provider\/provider\/meta\/META-INF\/services\/java.util.spi.CalendarDataProvider","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -1,1 +1,1 @@\n-tzdata2022f\n+tzdata2022g\n","filename":"test\/jdk\/java\/util\/TimeZone\/TimeZoneData\/VERSION","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -207,0 +207,1 @@\n+Link\tAmerica\/Iqaluit\t\tAmerica\/Pangnirtung\n","filename":"test\/jdk\/java\/util\/TimeZone\/TimeZoneData\/aliases.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+America\/Ciudad_Juarez MST MDT\n@@ -74,1 +75,1 @@\n-America\/Ojinaga CST\n+America\/Ojinaga CST CDT\n@@ -76,1 +77,0 @@\n-America\/Pangnirtung EST EDT\n","filename":"test\/jdk\/java\/util\/TimeZone\/TimeZoneData\/displaynames.txt","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,219 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, the following notice accompanied the original version of this\n+ * file:\n+ *\n+ * Written by Doug Lea with assistance from members of JCP JSR-166\n+ * Expert Group and released to the public domain, as explained at\n+ * http:\/\/creativecommons.org\/publicdomain\/zero\/1.0\/\n+ *\/\n+\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.ForkJoinTask;\n+import java.util.concurrent.ForkJoinWorkerThread;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.LockSupport;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+\/**\n+ * Tests for ForkJoinPool and ForkJoinWorkerThread additions in JDK 20.\n+ *\/\n+public class ForkJoinPool20Test extends JSR166TestCase {\n+    public static void main(String[] args) {\n+        main(suite(), args);\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(ForkJoinPool20Test.class);\n+    }\n+\n+    \/**\n+     * Test that tasks submitted with externalSubmit execute.\n+     *\/\n+    public void testExternalSubmit1() throws Exception {\n+        try (var pool = new ForkJoinPool()) {\n+            \/\/ submit from external client\n+            var task1 = ForkJoinTask.adapt(() -> \"foo\");\n+            pool.externalSubmit(task1);\n+            assertEquals(task1.get(), \"foo\");\n+\n+            \/\/ submit from worker thread\n+            Future<Future<String>> task2 = pool.submit(() -> {\n+                return pool.externalSubmit(ForkJoinTask.adapt(() -> \"foo\"));\n+            });\n+            assertEquals(task2.get().get(), \"foo\");\n+        }\n+    }\n+\n+    \/**\n+     * Test that tasks submitted with externalSubmit are pushed to a submission queue.\n+     *\/\n+    public void testExternalSubmit2() throws Exception {\n+        try (var pool = new ForkJoinPool(1)) {\n+            pool.submit(() -> {\n+                assertTrue(pool.getQueuedTaskCount() == 0);\n+                assertTrue(pool.getQueuedSubmissionCount() == 0);\n+\n+                for (int count = 1; count <= 3; count++) {\n+                    var task = ForkJoinTask.adapt(() -> { });\n+                    pool.externalSubmit(task);\n+\n+                    assertTrue(pool.getQueuedTaskCount() == 0);\n+                    assertTrue(pool.getQueuedSubmissionCount() == count);\n+                }\n+            }).get();\n+        }\n+    }\n+\n+    \/**\n+     * Test externalSubmit return value.\n+     *\/\n+    public void testExternalSubmitReturnsTask() {\n+        try (var pool = new ForkJoinPool()) {\n+            var task = ForkJoinTask.adapt(() -> \"foo\");\n+            assertTrue(pool.externalSubmit(task) == task);\n+        }\n+    }\n+\n+    \/**\n+     * Test externalSubmit(null) throws NullPointerException.\n+     *\/\n+    public void testExternalSubmitWithNull() {\n+        try (var pool = new ForkJoinPool()) {\n+            assertThrows(NullPointerException.class, () -> pool.externalSubmit(null));\n+        }\n+    }\n+\n+    \/**\n+     * Test externalSubmit throws RejectedExecutionException when pool is shutdown.\n+     *\/\n+    public void testExternalSubmitWhenShutdown() {\n+        try (var pool = new ForkJoinPool()) {\n+            pool.shutdown();\n+            var task = ForkJoinTask.adapt(() -> { });\n+            assertThrows(RejectedExecutionException.class, () -> pool.externalSubmit(task));\n+        }\n+    }\n+\n+    \/**\n+     * Test that tasks submitted with submit(ForkJoinTask) are pushed to a\n+     * submission queue.\n+     *\/\n+    public void testSubmit() throws Exception {\n+        try (var pool = new ForkJoinPool(1)) {\n+            ForkJoinWorkerThread worker = submitBusyTask(pool);\n+            try {\n+                assertTrue(worker.getQueuedTaskCount() == 0);\n+                assertTrue(pool.getQueuedTaskCount() == 0);\n+                assertTrue(pool.getQueuedSubmissionCount() == 0);\n+\n+                for (int count = 1; count <= 3; count++) {\n+                    var task = ForkJoinTask.adapt(() -> { });\n+                    pool.submit(task);\n+\n+                    \/\/ task should be in submission queue\n+                    assertTrue(worker.getQueuedTaskCount() == 0);\n+                    assertTrue(pool.getQueuedTaskCount() == 0);\n+                    assertTrue(pool.getQueuedSubmissionCount() == count);\n+                }\n+            } finally {\n+                LockSupport.unpark(worker);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test ForkJoinWorkerThread::getQueuedTaskCount returns the number of tasks in the\n+     * current thread's queue. This test runs with parallelism of 1 to ensure that tasks\n+     * aren't stolen.\n+     *\/\n+    public void testGetQueuedTaskCount1() throws Exception {\n+        try (var pool = new ForkJoinPool(1)) {\n+            pool.submit(() -> {\n+                var worker = (ForkJoinWorkerThread) Thread.currentThread();\n+                assertTrue(worker.getQueuedTaskCount() == 0);\n+\n+                for (int count = 1; count <= 3; count++) {\n+                    pool.submit(() -> { });\n+\n+                    \/\/ task should be in this thread's task queue\n+                    assertTrue(worker.getQueuedTaskCount() == count);\n+                    assertTrue(pool.getQueuedTaskCount() == count);\n+                    assertTrue(pool.getQueuedSubmissionCount() == 0);\n+                }\n+            }).get();\n+        }\n+    }\n+\n+    \/**\n+     * Test ForkJoinWorkerThread::getQueuedTaskCount returns the number of tasks in the\n+     * thread's queue. This test runs with parallelism of 2 and one worker active running\n+     * a task. This gives the test two task queues to sample.\n+     *\/\n+    public void testGetQueuedTaskCount2() throws Exception {\n+        try (var pool = new ForkJoinPool(2)) {\n+            \/\/ keep one worker thread active\n+            ForkJoinWorkerThread worker1 = submitBusyTask(pool);\n+            try {\n+                pool.submit(() -> {\n+                    var worker2 = (ForkJoinWorkerThread) Thread.currentThread();\n+                    for (int count = 1; count <= 3; count++) {\n+                        pool.submit(() -> { });\n+\n+                        \/\/ task should be in this thread's task queue\n+                        assertTrue(worker1.getQueuedTaskCount() == 0);\n+                        assertTrue(worker2.getQueuedTaskCount() == count);\n+                        assertTrue(pool.getQueuedTaskCount() == count);\n+                        assertTrue(pool.getQueuedSubmissionCount() == 0);\n+                    }\n+                }).get();\n+            } finally {\n+                LockSupport.unpark(worker1);  \/\/ release worker1\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Submits a task to the pool, returning the worker thread that runs the\n+     * task. The task runs until the thread is unparked.\n+     *\/\n+    static ForkJoinWorkerThread submitBusyTask(ForkJoinPool pool) throws Exception {\n+        var ref = new AtomicReference<ForkJoinWorkerThread>();\n+        pool.submit(() -> {\n+            ref.set((ForkJoinWorkerThread) Thread.currentThread());\n+            LockSupport.park();\n+        });\n+        ForkJoinWorkerThread worker;\n+        while ((worker = ref.get()) == null) {\n+            Thread.sleep(20);\n+        }\n+        return worker;\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/ForkJoinPool20Test.java","additions":219,"deletions":0,"binary":false,"changes":219,"status":"added"},{"patch":"@@ -516,1 +516,2 @@\n-    public static boolean atLeastJava17() { return JAVA_CLASS_VERSION >= 61.0; }\n+    public static boolean atLeastJava19() { return JAVA_CLASS_VERSION >= 63.0; }\n+    public static boolean atLeastJava20() { return JAVA_CLASS_VERSION >= 64.0; }\n@@ -636,2 +637,2 @@\n-        if (atLeastJava17()) {\n-            String[] java17TestClassNames = {\n+        if (atLeastJava19()) {\n+            String[] java19TestClassNames = {\n@@ -640,1 +641,1 @@\n-            addNamedTestClasses(suite, java17TestClassNames);\n+            addNamedTestClasses(suite, java19TestClassNames);\n@@ -642,0 +643,8 @@\n+\n+        if (atLeastJava20()) {\n+            String[] java20TestClassNames = {\n+                \"ForkJoinPool20Test\",\n+            };\n+            addNamedTestClasses(suite, java20TestClassNames);\n+        }\n+\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/JSR166TestCase.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.lang.foreign.MemorySession;\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/SpliteratorTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,0 +59,1 @@\n+        @SuppressWarnings(\"removal\")\n","filename":"test\/jdk\/javax\/management\/Introspector\/ClassLeakTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -435,0 +435,1 @@\n+            @SuppressWarnings(\"removal\")\n","filename":"test\/jdk\/javax\/management\/MBeanServer\/PostExceptionTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+@SuppressWarnings(\"removal\")\n","filename":"test\/jdk\/javax\/management\/loading\/DocumentRootTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+@SuppressWarnings(\"removal\")\n","filename":"test\/jdk\/javax\/management\/loading\/GetMBeansFromURLTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+@SuppressWarnings(\"removal\")\n","filename":"test\/jdk\/javax\/management\/loading\/MLetCLR\/MLetCommand.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+@SuppressWarnings(\"removal\")\n","filename":"test\/jdk\/javax\/management\/loading\/MLetContentTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+@SuppressWarnings(\"removal\")\n","filename":"test\/jdk\/javax\/management\/loading\/MLetInternalsTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+@SuppressWarnings(\"removal\")\n","filename":"test\/jdk\/javax\/management\/loading\/MletParserLocaleTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,1 @@\n+@SuppressWarnings(\"removal\")\n","filename":"test\/jdk\/javax\/management\/loading\/ParserInfiniteLoopTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,0 +84,1 @@\n+            @SuppressWarnings(\"removal\")\n@@ -269,0 +270,1 @@\n+            @SuppressWarnings(\"removal\")\n","filename":"test\/jdk\/javax\/management\/mxbean\/MXBeanLoadingTest1.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,2 @@\n+\n+    @SuppressWarnings(\"removal\") \/\/ use of MLet\n","filename":"test\/jdk\/javax\/management\/relation\/NonArrayListTest.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,0 +104,1 @@\n+        @SuppressWarnings(\"removal\")\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/loading\/TargetMBeanTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,0 +83,1 @@\n+    @SuppressWarnings(\"removal\") \/\/ use of MLet\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/notif\/NotificationBufferTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,143 @@\n+\/*\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ SunJSSE does not support dynamic system properties, no way to re-use\n+\/\/ system properties in samevm\/agentvm mode.\n+\n+\/*\n+ * @test\n+ * @bug 8281236\n+ * @summary Check DTLS connection behaviors for named groups configuration\n+ * @modules java.base\/sun.security.util\n+ * @library \/test\/lib\n+ * @build DTLSOverDatagram\n+ * @run main\/othervm DTLSNamedGroups\n+ *\/\n+\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.SSLParameters;\n+import java.security.Security;\n+\n+\/**\n+ * Test DTLS client authentication.\n+ *\/\n+public class DTLSNamedGroups extends DTLSOverDatagram {\n+    \/\/ Make sure default DH(E) key exchange is not used for DTLS v1.2.\n+    private static String[] cipherSuites = new String[] {\n+        \"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\"\n+    };\n+\n+    private final String[] serverNamedGroups;\n+    private final String[] clientNamedGroups;\n+\n+    public DTLSNamedGroups(String[] serverNamedGroups,\n+                           String[] clientNamedGroups) {\n+        this.serverNamedGroups = serverNamedGroups;\n+        this.clientNamedGroups = clientNamedGroups;\n+    }\n+\n+    @Override\n+    SSLEngine createSSLEngine(boolean isClient) throws Exception {\n+        SSLEngine engine = super.createSSLEngine(isClient);\n+\n+        SSLParameters sslParameters = engine.getSSLParameters();\n+        if (isClient) {\n+            sslParameters.setNamedGroups(clientNamedGroups);\n+            sslParameters.setCipherSuites(cipherSuites);\n+        } else {\n+            sslParameters.setNamedGroups(serverNamedGroups);\n+        }\n+        engine.setSSLParameters(sslParameters);\n+\n+        return engine;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Security.setProperty(\"jdk.tls.disabledAlgorithms\", \"\");\n+\n+        runTest(new String[] {\n+                        \"x25519\",\n+                        \"secp256r1\"\n+                },\n+                new String[] {\n+                        \"x25519\",\n+                        \"secp256r1\"\n+                },\n+                false);\n+        runTest(new String[] {\n+                        \"secp256r1\"\n+                },\n+                new String[] {\n+                        \"secp256r1\"\n+                },\n+                false);\n+        runTest(null,\n+                new String[] {\n+                        \"secp256r1\"\n+                },\n+                false);\n+        runTest(new String[] {\n+                        \"secp256r1\"\n+                },\n+                null,\n+                false);\n+        runTest(new String[0],\n+                new String[] {\n+                        \"secp256r1\"\n+                },\n+                true);\n+        runTest(new String[] {\n+                        \"secp256r1\"\n+                },\n+                new String[0],\n+                true);\n+        runTest(new String[] {\n+                        \"secp256NA\"\n+                },\n+                new String[] {\n+                        \"secp256r1\"\n+                },\n+                true);\n+    }\n+\n+    private static void runTest(String[] serverNamedGroups,\n+                                String[] clientNamedGroups,\n+                                boolean exceptionExpected) throws Exception {\n+        DTLSNamedGroups testCase = new DTLSNamedGroups(\n+                serverNamedGroups, clientNamedGroups);\n+        try {\n+            testCase.runTest(testCase);\n+        } catch (Exception e) {\n+            if (!exceptionExpected) {\n+                throw e;\n+            } else { \/\/ Otherwise, swallow the expected exception and return.\n+                return;\n+            }\n+        }\n+\n+        if (exceptionExpected) {\n+            throw new RuntimeException(\"Unexpected success!\");\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/javax\/net\/ssl\/DTLS\/DTLSNamedGroups.java","additions":143,"deletions":0,"binary":false,"changes":143,"status":"added"},{"patch":"@@ -0,0 +1,147 @@\n+\/*\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ SunJSSE does not support dynamic system properties, no way to re-use\n+\/\/ system properties in samevm\/agentvm mode.\n+\n+\/*\n+ * @test\n+ * @bug 8281236\n+ * @summary Check TLS connection behaviors for named groups configuration\n+ * @library \/javax\/net\/ssl\/templates\n+ * @run main\/othervm NamedGroups\n+ *\/\n+\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLServerSocket;\n+import javax.net.ssl.SSLSocket;\n+import java.security.Security;\n+\n+public class NamedGroups extends SSLSocketTemplate {\n+    private final String[] serverNamedGroups;\n+    private final String[] clientNamedGroups;\n+    private final boolean exceptionExpected;\n+\n+    public NamedGroups(String[] serverNamedGroups,\n+                            String[] clientNamedGroups,\n+                            boolean exceptionExpected) {\n+        this.serverNamedGroups = serverNamedGroups;\n+        this.clientNamedGroups = clientNamedGroups;\n+        this.exceptionExpected = exceptionExpected;\n+    }\n+\n+    @Override\n+    protected void configureServerSocket(SSLServerSocket sslServerSocket) {\n+        SSLParameters sslParameters = sslServerSocket.getSSLParameters();\n+        sslParameters.setNamedGroups(serverNamedGroups);\n+        sslServerSocket.setSSLParameters(sslParameters);\n+    }\n+\n+    @Override\n+    protected void configureClientSocket(SSLSocket socket) {\n+        SSLParameters sslParameters = socket.getSSLParameters();\n+        sslParameters.setNamedGroups(clientNamedGroups);\n+        socket.setSSLParameters(sslParameters);\n+    }\n+\n+    @Override\n+    protected void runServerApplication(SSLSocket socket) {\n+        try {\n+            super.runServerApplication(socket);\n+        } catch (Exception ex) {\n+            \/\/ Just ignore, let the client handle the failure information.\n+        }\n+    }\n+\n+    @Override\n+    protected void runClientApplication(SSLSocket sslSocket) throws Exception {\n+        try {\n+            super.runClientApplication(sslSocket);\n+        } catch (Exception ex) {\n+            if (!exceptionExpected) {\n+                throw ex;\n+            } else {  \/\/ Otherwise, swallow the exception and return.\n+                return;\n+            }\n+        }\n+\n+        if (exceptionExpected) {\n+            throw new RuntimeException(\"Unexpected success!\");\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Security.setProperty(\"jdk.tls.disabledAlgorithms\", \"\");\n+\n+        runTest(new String[] {\n+                        \"x25519\",\n+                        \"secp256r1\"\n+                },\n+                new String[] {\n+                        \"x25519\",\n+                        \"secp256r1\"\n+                },\n+                false);\n+        runTest(new String[] {\n+                        \"secp256r1\"\n+                },\n+                new String[] {\n+                        \"secp256r1\"\n+                },\n+                false);\n+        runTest(null,\n+                new String[] {\n+                        \"secp256r1\"\n+                },\n+                false);\n+        runTest(new String[] {\n+                        \"secp256r1\"\n+                },\n+                null,\n+                false);\n+        runTest(new String[0],\n+                new String[] {\n+                        \"secp256r1\"\n+                },\n+                true);\n+        runTest(new String[] {\n+                        \"secp256r1\"\n+                },\n+                new String[0],\n+                true);\n+        runTest(new String[] {\n+                        \"secp256NA\"\n+                },\n+                new String[] {\n+                        \"secp256r1\"\n+                },\n+                true);\n+    }\n+\n+    private static void runTest(String[] serverNamedGroups,\n+                                String[] clientNamedGroups,\n+                                boolean exceptionExpected) throws Exception {\n+        new NamedGroups(serverNamedGroups,\n+                clientNamedGroups, exceptionExpected).run();\n+    }\n+}\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLParameters\/NamedGroups.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8281236\n+ * @summary check SSLParameters.setNamedGroups() implementation\n+ *\/\n+\n+import javax.net.ssl.SSLParameters;\n+import java.util.Arrays;\n+\n+public class NamedGroupsSpec {\n+    public static void main(String[] args) throws Exception {\n+        runTest(null,             \/\/ null array should be allowed.\n+                false);\n+        runTest(new String[] {    \/\/ empty array should be allowed\n+                    \/\/ blank line\n+                },\n+                false);\n+        runTest(new String[] {    \/\/ multiple elements should be fine\n+                        \"x25519\",\n+                        \"secp256r1\"\n+                },\n+                false);\n+        runTest(new String[] {    \/\/ no duplicate element should be allowed\n+                        \"x25519\",\n+                        \"x25519\"\n+                },\n+                true);\n+        runTest(new String[] {    \/\/ no null element should be allowed\n+                        null\n+                },\n+                true);\n+        runTest(new String[] {    \/\/ no blank element should be allowed\n+                        \"\"\n+                },\n+                true);\n+        runTest(new String[] {    \/\/ no blank element should be allowed\n+                        \"x25519\",\n+                        \"\"\n+                },\n+                true);\n+        runTest(new String[] {    \/\/ no null element should be allowed.\n+                        \"x25519\",\n+                        null\n+                },\n+                true);\n+    }\n+\n+    private static void runTest(String[] namedGroups,\n+                                boolean exceptionExpected) throws Exception {\n+        SSLParameters sslParams = new SSLParameters();\n+        try {\n+            sslParams.setNamedGroups(namedGroups);\n+        } catch (Exception ex) {\n+            if (!exceptionExpected ||\n+                    !(ex instanceof IllegalArgumentException)) {\n+                throw ex;\n+            } else {  \/\/ Otherwise, swallow the exception and return.\n+                return;\n+            }\n+        }\n+\n+        if (exceptionExpected) {\n+            throw new RuntimeException(\"Unexpected success!\");\n+        }\n+\n+        \/\/ Check if the getNamedGroups() method returns the same elements.\n+        String[] configuredNamedGroups = sslParams.getNamedGroups();\n+        if (!Arrays.equals(namedGroups, configuredNamedGroups)) {\n+            throw new RuntimeException(\n+                    \"SSLParameters.getNamedGroups() method does not return \"\n+                  + \"the same elements as set with setNamedGroups()\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLParameters\/NamedGroupsSpec.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.sound.sampled.AudioInputStream;\n+import javax.sound.sampled.AudioSystem;\n+import javax.sound.sampled.Clip;\n+import javax.sound.sampled.LineUnavailableException;\n+import javax.sound.sampled.UnsupportedAudioFileException;\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+\/*\n+ * @test\n+ * @key sound\n+ * @bug 8282578\n+ * @summary AIOOBE in javax.sound.sampled.Clip\n+ * @run main EmptySysExMessageTest\n+ *\/\n+\n+public class EmptySysExMessageTest {\n+    public static void main(String[] args) {\n+        String sep = System.getProperty(\"file.separator\");\n+        String dir = System.getProperty(\"test.src\", \".\");\n+        String name = \"zerosysex.mid\";\n+        try {\n+            readAudioFile(dir + sep + name);\n+        } catch (Throwable t) {\n+            throw new RuntimeException(\"Invalid file \" + name\n+                    + \" caused unexpected exception during read: \"\n+                    + t + System.lineSeparator());\n+        }\n+    }\n+\n+    static void readAudioFile(String name) throws IOException {\n+        File soundFile = new File(name);\n+        Path path = Paths.get(soundFile.getAbsolutePath());\n+        byte[] samples = Files.readAllBytes(path);\n+\n+        try {\n+            AudioInputStream audioInputStream =\n+                    AudioSystem.getAudioInputStream(new ByteArrayInputStream(samples));\n+            try (Clip clip = AudioSystem.getClip()) {\n+                clip.open(audioInputStream);\n+                clip.start();\n+                Thread.sleep(1000);\n+                clip.stop();\n+            }\n+        } catch (UnsupportedAudioFileException\n+                 | LineUnavailableException\n+                 | IOException\n+                 | InterruptedException\n+                 | IllegalArgumentException\n+                 | IllegalStateException\n+                 | SecurityException expected) {\n+            \/\/ Do nothing, these types of exception are expected on invalid file\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/sound\/midi\/SysexMessage\/EmptySysExMessageTest.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"filename":"test\/jdk\/javax\/sound\/midi\/SysexMessage\/zerosysex.mid","binary":true,"status":"added"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+\n+import javax.swing.JFrame;\n+import javax.swing.JFileChooser;\n+import javax.swing.SwingUtilities;\n+import javax.swing.Icon;\n+import javax.swing.WindowConstants;\n+import javax.swing.filechooser.FileSystemView;\n+\n+\/*\n+ * @test\n+ * @bug 8296198\n+ * @key headful\n+ * @requires (os.family == \"windows\")\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @summary Test to check if the Link to a folder is traversable with custom\n+ * FileSystemView is valid on ValueChanged property listener.\n+ * @run main\/manual CustomFSVLinkTest\n+ *\/\n+public class CustomFSVLinkTest {\n+    static JFrame frame;\n+    static JFileChooser jfc;\n+\n+    static PassFailJFrame passFailJFrame;\n+\n+    public static void main(String[] args) throws Exception {\n+        SwingUtilities.invokeAndWait(new Runnable() {\n+            public void run() {\n+                try {\n+                    initialize();\n+                } catch (InterruptedException | InvocationTargetException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+        });\n+        passFailJFrame.awaitAndCheck();\n+    }\n+\n+    static void initialize() throws InterruptedException, InvocationTargetException {\n+        \/\/Initialize the components\n+        final String INSTRUCTIONS = \"\"\"\n+                Instructions to Test:\n+                1. Create a link to a any valid folder.\n+                2. Navigate to the linked folder through the link created\n+                (From FileChooser).\n+                3. If \"link\" can't be traversed or if its absolute path is null\n+                   click FAIL. If \"link\" can be traversed then click PASS.\n+                \"\"\";\n+        frame = new JFrame(\"JFileChooser Link test\");\n+        jfc = new JFileChooser(new MyFileSystemView());\n+        passFailJFrame = new PassFailJFrame(\"Test Instructions\", INSTRUCTIONS, 5L, 8, 40);\n+\n+        PassFailJFrame.addTestWindow(frame);\n+        PassFailJFrame.positionTestWindow(frame, PassFailJFrame.Position.HORIZONTAL);\n+        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n+        jfc.setDialogType(JFileChooser.CUSTOM_DIALOG);\n+\n+        frame.add(jfc, BorderLayout.CENTER);\n+        frame.pack();\n+        frame.setVisible(true);\n+    }\n+\n+    private static class MyFileSystemView extends FileSystemView {\n+        FileSystemView delegate;\n+\n+        MyFileSystemView() {\n+            delegate = FileSystemView.getFileSystemView();\n+        }\n+\n+        @Override\n+        public File createNewFolder(File containingDir) throws IOException {\n+            return delegate.createNewFolder(containingDir);\n+        }\n+\n+        @Override\n+        public boolean isRoot(File f) {\n+            return delegate.isRoot(f);\n+        }\n+\n+        @Override\n+        public Boolean isTraversable(File f) {\n+            return delegate.isTraversable(f);\n+        }\n+\n+        @Override\n+        public String getSystemDisplayName(File f) {\n+            return delegate.getSystemDisplayName(f);\n+        }\n+\n+        @Override\n+        public String getSystemTypeDescription(File f) {\n+            return delegate.getSystemTypeDescription(f);\n+        }\n+\n+        @Override\n+        public Icon getSystemIcon(File f) {\n+            return delegate.getSystemIcon(f);\n+        }\n+\n+        @Override\n+        public boolean isParent(File folder, File file) {\n+            return delegate.isParent(folder, file);\n+        }\n+\n+        @Override\n+        public File getChild(File parent, String fileName) {\n+            return delegate.getChild(parent, fileName);\n+        }\n+\n+        @Override\n+        public boolean isFileSystem(File f) {\n+            return delegate.isFileSystem(f);\n+        }\n+\n+        @Override\n+        public boolean isHiddenFile(File f) {\n+            return delegate.isHiddenFile(f);\n+        }\n+\n+        @Override\n+        public boolean isFileSystemRoot(File dir) {\n+            return delegate.isFileSystemRoot(dir);\n+        }\n+\n+        @Override\n+        public boolean isDrive(File dir) {\n+            return delegate.isDrive(dir);\n+        }\n+\n+        @Override\n+        public boolean isFloppyDrive(File dir) {\n+            return delegate.isFloppyDrive(dir);\n+        }\n+\n+        @Override\n+        public boolean isComputerNode(File dir) {\n+            return delegate.isComputerNode(dir);\n+        }\n+\n+        @Override\n+        public File[] getRoots() {\n+            return delegate.getRoots();\n+        }\n+\n+        @Override\n+        public File getHomeDirectory() {\n+            return delegate.getHomeDirectory();\n+        }\n+\n+        @Override\n+        public File getDefaultDirectory() {\n+            return delegate.getDefaultDirectory();\n+        }\n+\n+        @Override\n+        public File createFileObject(File dir, String filename) {\n+            return delegate.createFileObject(dir, filename);\n+        }\n+\n+        @Override\n+        public File createFileObject(String path) {\n+            return delegate.createFileObject(path);\n+        }\n+\n+        @Override\n+        public File[] getFiles(File dir, boolean useFileHiding) {\n+            return delegate.getFiles(dir, useFileHiding);\n+        }\n+\n+        @Override\n+        public File getParentDirectory(File dir) {\n+            return delegate.getParentDirectory(dir);\n+        }\n+\n+        @Override\n+        public File[] getChooserComboBoxFiles() {\n+            return delegate.getChooserComboBoxFiles();\n+        }\n+\n+        @Override\n+        public boolean isLink(File file) {\n+            return delegate.isLink(file);\n+        }\n+\n+        @Override\n+        public File getLinkLocation(File file) throws FileNotFoundException {\n+            return delegate.getLinkLocation(file);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/FileSystemView\/CustomFSVLinkTest.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 4314194 8075916\n+ * @bug 4314194 8075916 8298083\n@@ -43,0 +43,1 @@\n+import javax.swing.plaf.synth.SynthLookAndFeel;\n@@ -45,5 +46,5 @@\n-    private static JFrame frame;\n-    private static JRadioButton radioButton;\n-    private static JCheckBox checkBox;\n-    private static Point point;\n-    private static Rectangle rect;\n+    private static volatile JFrame frame;\n+    private static volatile JRadioButton radioButton;\n+    private static volatile JCheckBox checkBox;\n+    private static volatile Point point;\n+    private static volatile Rectangle rect;\n@@ -90,3 +91,19 @@\n-    private static void createUI() {\n-        UIManager.getDefaults().put(\"CheckBox.disabledText\", checkboxColor);\n-        UIManager.getDefaults().put(\"RadioButton.disabledText\", radioButtonColor);\n+    private static void createUI(String laf) {\n+        if (UIManager.getLookAndFeel() instanceof SynthLookAndFeel) {\n+            \/\/ reset \"basic\" properties\n+            UIManager.getDefaults().put(\"CheckBox.disabledText\", null);\n+            UIManager.getDefaults().put(\"RadioButton.disabledText\", null);\n+            \/\/ set \"synth\" properties\n+            UIManager.getDefaults().put(\"CheckBox[Disabled].textForeground\", checkboxColor);\n+            \/\/ for some reason the RadioButton[Disabled] does not work\n+            \/\/ see https:\/\/bugs.openjdk.org\/browse\/JDK-8298149\n+            \/\/UIManager.getDefaults().put(\"RadioButton[Disabled].textForeground\", radioButtonColor);\n+            UIManager.getDefaults().put(\"RadioButton[Enabled].textForeground\", radioButtonColor);\n+        } else {\n+            \/\/ reset \"synth\" properties\n+            UIManager.getDefaults().put(\"CheckBox[Disabled].textForeground\", null);\n+            UIManager.getDefaults().put(\"RadioButton[Enabled].textForeground\", null);\n+            \/\/ set \"basic\" properties\n+            UIManager.getDefaults().put(\"CheckBox.disabledText\", checkboxColor);\n+            UIManager.getDefaults().put(\"RadioButton.disabledText\", radioButtonColor);\n+        }\n@@ -101,1 +118,1 @@\n-        frame = new JFrame(\"bug4314194\");\n+        frame = new JFrame(laf);\n@@ -125,1 +142,1 @@\n-                SwingUtilities.invokeAndWait(() -> createUI());\n+                SwingUtilities.invokeAndWait(() -> createUI(laf.getName()));\n@@ -144,1 +161,0 @@\n-\n","filename":"test\/jdk\/javax\/swing\/JRadioButton\/4314194\/bug4314194.java","additions":28,"deletions":12,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -24,0 +24,4 @@\n+import java.io.File;\n+\n+import java.awt.image.BufferedImage;\n+import java.awt.Dimension;\n@@ -29,0 +33,1 @@\n+import java.awt.Toolkit;\n@@ -41,0 +46,1 @@\n+import javax.imageio.ImageIO;\n@@ -43,0 +49,1 @@\n+\n@@ -55,2 +62,2 @@\n-    private int step;\n-    private boolean spinnerValueChanged[] = {false, false, false};\n+    private int step = 0;\n+    private volatile boolean spinnerValueChanged[] = {false, false, false};\n@@ -58,2 +65,2 @@\n-    private static Point p;\n-    private static Rectangle rect;\n+    private static volatile Point p;\n+    private static volatile Rectangle rect;\n@@ -63,1 +70,1 @@\n-        robot.setAutoDelay(50);\n+        robot.setAutoDelay(100);\n@@ -71,0 +78,1 @@\n+                robot.delay(1000);\n@@ -109,0 +117,1 @@\n+            System.out.println(\"p \" + p + \" rect \" + rect);\n@@ -111,1 +120,2 @@\n-            robot.mousePress(InputEvent.BUTTON1_MASK);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+\n@@ -126,0 +136,1 @@\n+            robot.waitForIdle();\n@@ -135,0 +146,1 @@\n+            robot.waitForIdle();\n@@ -136,1 +148,2 @@\n-            robot.mouseRelease(InputEvent.BUTTON1_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.waitForIdle();\n@@ -148,0 +161,9 @@\n+                System.out.println(\"!spinnerValueChanged[0] \" + !spinnerValueChanged[0] +\n+                                   \" spinnerValueChanged[1] \" + spinnerValueChanged[1] +\n+                                   \" !spinnerValueChanged[2] \" + !spinnerValueChanged[2]);\n+                try {\n+                    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n+                    Rectangle screen = new Rectangle(0, 0, (int) screenSize.getWidth(), (int) screenSize.getHeight());\n+                    BufferedImage fullScreen = robot.createScreenCapture(screen);\n+                    ImageIO.write(fullScreen, \"png\", new File(\"fullScreen.png\"));\n+                } catch (Exception e) {}\n","filename":"test\/jdk\/javax\/swing\/JSpinner\/4788637\/bug4788637.java","additions":29,"deletions":7,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -249,0 +249,2 @@\n+            contentPanel.add(Box.createVerticalStrut(4));\n+\n@@ -257,0 +259,1 @@\n+            panelLocations.add(childPanel.getLocation());\n@@ -264,5 +267,0 @@\n-        \/\/ Save coordinates of the panels\n-        for (Component comp : contentPanel.getComponents()) {\n-            panelLocations.add(comp.getLocation());\n-        }\n-\n","filename":"test\/jdk\/javax\/swing\/border\/LineBorder\/ScaledTextFieldBorderTest.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Stress test ScopedValue with many bindings and rebinings\n+ * @enablePreview\n+ * @modules jdk.incubator.concurrent\n+ * @library \/test\/lib\n+ * @key randomness\n+ * @run testng ManyBindings\n+ *\/\n+\n+import jdk.incubator.concurrent.ScopedValue;\n+import jdk.incubator.concurrent.ScopedValue.Carrier;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.Random;\n+\n+import jdk.test.lib.RandomFactory;\n+import jdk.test.lib.thread.VThreadRunner;\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+@Test\n+public class ManyBindings {\n+    private static final Random RND = RandomFactory.getRandom();\n+\n+    \/\/ number of scoped values to create\n+    private static final int SCOPED_VALUE_COUNT = 16;\n+\n+    \/\/ recursive depth to test\n+    private static final int MAX_DEPTH = 24;\n+\n+    \/**\n+     * Stress test bindings on platform thread.\n+     *\/\n+    public void testPlatformThread() {\n+        test();\n+    }\n+\n+    \/**\n+     * Stress test bindings on virtual thread.\n+     *\/\n+    public void testVirtualThread() throws Exception {\n+        VThreadRunner.run(() -> test());\n+    }\n+\n+    \/**\n+     * Scoped value and its expected value (or null if not bound).\n+     *\/\n+    record KeyAndValue<T>(ScopedValue<T> key, T value) {\n+        KeyAndValue() {\n+            this(ScopedValue.newInstance(), null);\n+        }\n+    }\n+\n+    \/**\n+     * Stress test bindings on current thread.\n+     *\/\n+    private void test() {\n+        KeyAndValue<Integer>[] array = new KeyAndValue[SCOPED_VALUE_COUNT];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = new KeyAndValue<>();\n+        }\n+        test(array, 1);\n+    }\n+\n+    \/**\n+     * Test that the scoped values in the array have the expected value, then\n+     * recursively call this method with some of the scoped values bound to a\n+     * new value.\n+     *\n+     * @param array the scoped values and their expected value\n+     * @param depth current recurive depth\n+     *\/\n+    private void test(KeyAndValue<Integer>[] array, int depth) {\n+        if (depth > MAX_DEPTH)\n+            return;\n+\n+        \/\/ check that the scoped values have the expected values\n+        check(array);\n+\n+        \/\/ try to pollute the cache\n+        lotsOfReads(array);\n+\n+        \/\/ create a Carrier to bind\/rebind some of the scoped values\n+        int len = array.length;\n+        Carrier carrier = null;\n+\n+        KeyAndValue<Integer>[] newArray = Arrays.copyOf(array, len);\n+        int n = Math.max(1, RND.nextInt(len \/ 2));\n+        while (n > 0) {\n+            int index = RND.nextInt(len);\n+            ScopedValue<Integer> key = array[index].key;\n+            int newValue = RND.nextInt();\n+            if (carrier == null) {\n+                carrier = ScopedValue.where(key, newValue);\n+            } else {\n+                carrier = carrier.where(key, newValue);\n+            }\n+            newArray[index] = new KeyAndValue<>(key, newValue);\n+            n--;\n+        }\n+\n+        \/\/ invoke recursively\n+        carrier.run(() -> {\n+            test(newArray, depth+1);\n+        });\n+\n+        \/\/ check that the scoped values have the origina values\n+        check(array);\n+    }\n+\n+    \/**\n+     * Check that the given scoped values have the expected value.\n+     *\/\n+    private void check(KeyAndValue<Integer>[] array) {\n+        for (int i = 0; i < array.length; i++) {\n+            ScopedValue<Integer> key = array[i].key;\n+            Integer value = array[i].value;\n+            if (value == null) {\n+                assertFalse(key.isBound());\n+            } else {\n+                assertEquals(key.get(), value);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Do lots of reads of the scoped values, to pollute the SV cache.\n+     *\/\n+    private void lotsOfReads(KeyAndValue<Integer>[] array) {\n+        for (int k = 0; k < 1000; k++) {\n+            int index = RND.nextInt(array.length);\n+            Integer value = array[index].value;\n+            if (value != null) {\n+                ScopedValue<Integer> key = array[index].key;\n+                assertEquals(key.get(), value);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/ScopedValue\/ManyBindings.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -0,0 +1,442 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test ScopedValue API\n+ * @enablePreview\n+ * @modules jdk.incubator.concurrent\n+ * @run testng ScopeValueAPI\n+ *\/\n+\n+import jdk.incubator.concurrent.ScopedValue;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+@Test\n+public class ScopeValueAPI {\n+\n+    @DataProvider\n+    public Object[][] factories() {\n+        return new Object[][] {\n+                { Thread.ofPlatform().factory() },\n+                { Thread.ofVirtual().factory() },\n+        };\n+    }\n+\n+    \/**\n+     * Test that the run method is invoked.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testRun(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            class Box { static boolean executed; }\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            ScopedValue.where(name, \"duke\", () -> { Box.executed = true; });\n+            assertTrue(Box.executed);\n+        });\n+    }\n+\n+    \/**\n+     * Test the run method throwing an exception.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testRunThrows(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            class FooException extends RuntimeException {  }\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            Runnable op = () -> { throw new FooException(); };\n+            assertThrows(FooException.class, () -> ScopedValue.where(name, \"duke\", op));\n+            assertFalse(name.isBound());\n+        });\n+    }\n+\n+    \/**\n+     * Test that the call method is invoked.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testCall(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            String result = ScopedValue.where(name, \"duke\", name::get);\n+            assertEquals(result, \"duke\");\n+        });\n+    }\n+\n+    \/**\n+     * Test the call method throwing an exception.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testCallThrows(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            class FooException extends RuntimeException {  }\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            Callable<Void> op = () -> { throw new FooException(); };\n+            assertThrows(FooException.class, () -> ScopedValue.where(name, \"duke\", op));\n+            assertFalse(name.isBound());\n+        });\n+    }\n+\n+    \/**\n+     * Test get method.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testGet(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name1 = ScopedValue.newInstance();\n+            ScopedValue<String> name2 = ScopedValue.newInstance();\n+            assertThrows(NoSuchElementException.class, name1::get);\n+            assertThrows(NoSuchElementException.class, name2::get);\n+\n+            \/\/ run\n+            ScopedValue.where(name1, \"duke\", () -> {\n+                assertEquals(name1.get(), \"duke\");\n+                assertThrows(NoSuchElementException.class, name2::get);\n+\n+            });\n+            assertThrows(NoSuchElementException.class, name1::get);\n+            assertThrows(NoSuchElementException.class, name2::get);\n+\n+            \/\/ call\n+            ScopedValue.where(name1, \"duke\", () -> {\n+                assertEquals(name1.get(), \"duke\");\n+                assertThrows(NoSuchElementException.class, name2::get);\n+                return null;\n+            });\n+            assertThrows(NoSuchElementException.class, name1::get);\n+            assertThrows(NoSuchElementException.class, name2::get);\n+        });\n+    }\n+\n+    \/**\n+     * Test isBound method.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testIsBound(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name1 = ScopedValue.newInstance();\n+            ScopedValue<String> name2 = ScopedValue.newInstance();\n+            assertFalse(name1.isBound());\n+            assertFalse(name2.isBound());\n+\n+            \/\/ run\n+            ScopedValue.where(name1, \"duke\", () -> {\n+                assertTrue(name1.isBound());\n+                assertFalse(name2.isBound());\n+            });\n+            assertFalse(name1.isBound());\n+            assertFalse(name2.isBound());\n+\n+            \/\/ call\n+            ScopedValue.where(name1, \"duke\", () -> {\n+                assertTrue(name1.isBound());\n+                assertFalse(name2.isBound());\n+                return null;\n+            });\n+            assertFalse(name1.isBound());\n+            assertFalse(name2.isBound());\n+        });\n+    }\n+\n+    \/**\n+     * Test orElse method.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testOrElse(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            assertTrue(name.orElse(null) == null);\n+            assertEquals(name.orElse(\"default\"), \"default\");\n+\n+            \/\/ run\n+            ScopedValue.where(name, \"duke\", () -> {\n+                assertEquals(name.orElse(null), \"duke\");\n+                assertEquals(name.orElse(\"default\"), \"duke\");\n+            });\n+\n+            \/\/ call\n+            ScopedValue.where(name, \"duke\", () -> {\n+                assertEquals(name.orElse(null), \"duke\");\n+                assertEquals(name.orElse(\"default\"), \"duke\");\n+                return null;\n+            });\n+        });\n+    }\n+\n+    \/**\n+     * Test orElseThrow method.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testOrElseThrow(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            class FooException extends RuntimeException { }\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            assertThrows(FooException.class, () -> name.orElseThrow(FooException::new));\n+\n+            \/\/ run\n+            ScopedValue.where(name, \"duke\", () -> {\n+                assertEquals(name.orElseThrow(FooException::new), \"duke\");\n+            });\n+\n+            \/\/ call\n+            ScopedValue.where(name, \"duke\", () -> {\n+                assertEquals(name.orElseThrow(FooException::new), \"duke\");\n+                return null;\n+            });\n+        });\n+    }\n+\n+    \/**\n+     * Test two bindings.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testTwoBindings(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            ScopedValue<Integer> age = ScopedValue.newInstance();\n+\n+            \/\/ run\n+            ScopedValue.where(name, \"duke\").where(age, 100).run(() -> {\n+                assertTrue(name.isBound());\n+                assertTrue(age.isBound());\n+                assertEquals(name.get(), \"duke\");\n+                assertEquals((int) age.get(), 100);\n+            });\n+            assertFalse(name.isBound());\n+            assertFalse(age.isBound());\n+\n+            \/\/ call\n+            ScopedValue.where(name, \"duke\").where(age, 100).call(() -> {\n+                assertTrue(name.isBound());\n+                assertTrue(age.isBound());\n+                assertEquals(name.get(), \"duke\");\n+                assertEquals((int) age.get(), 100);\n+                return null;\n+            });\n+            assertFalse(name.isBound());\n+            assertFalse(age.isBound());\n+\n+        });\n+    }\n+\n+    \/**\n+     * Test rebinding.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testRebinding(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+\n+            \/\/ run\n+            ScopedValue.where(name, \"duke\", () -> {\n+                assertTrue(name.isBound());\n+                assertEquals(name.get(), \"duke\");\n+\n+                ScopedValue.where(name, \"duchess\", () -> {\n+                    assertTrue(name.isBound());\n+                    assertTrue(\"duchess\".equals(name.get()));\n+                });\n+\n+                assertTrue(name.isBound());\n+                assertEquals(name.get(), \"duke\");\n+            });\n+            assertFalse(name.isBound());\n+\n+            \/\/ call\n+            ScopedValue.where(name, \"duke\", () -> {\n+                assertTrue(name.isBound());\n+                assertEquals(name.get(), \"duke\");\n+\n+                ScopedValue.where(name, \"duchess\", () -> {\n+                    assertTrue(name.isBound());\n+                    assertTrue(\"duchess\".equals(name.get()));\n+                    return null;\n+                });\n+\n+                assertTrue(name.isBound());\n+                assertEquals(name.get(), \"duke\");\n+                return null;\n+            });\n+            assertFalse(name.isBound());\n+        });\n+    }\n+\n+    \/**\n+     * Test rebinding from null vaue to another value.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testRebindingFromNull(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+\n+            \/\/ run\n+            ScopedValue.where(name, null, () -> {\n+                assertTrue(name.isBound());\n+                assertEquals(name.get(), null);\n+\n+                ScopedValue.where(name, \"duchess\", () -> {\n+                    assertTrue(name.isBound());\n+                    assertTrue(\"duchess\".equals(name.get()));\n+                });\n+\n+                assertTrue(name.isBound());\n+                assertTrue(name.get() == null);\n+            });\n+            assertFalse(name.isBound());\n+\n+            \/\/ call\n+            ScopedValue.where(name, null, () -> {\n+                assertTrue(name.isBound());\n+                assertEquals(name.get(), null);\n+\n+                ScopedValue.where(name, \"duchess\", () -> {\n+                    assertTrue(name.isBound());\n+                    assertTrue(\"duchess\".equals(name.get()));\n+                    return null;\n+                });\n+\n+                assertTrue(name.isBound());\n+                assertTrue(name.get() == null);\n+                return null;\n+            });\n+            assertFalse(name.isBound());\n+        });\n+    }\n+\n+    \/**\n+     * Test rebinding to null value.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testRebindingToNull(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+\n+            \/\/ run\n+            ScopedValue.where(name, \"duke\", () -> {\n+                assertTrue(name.isBound());\n+                assertEquals(name.get(), \"duke\");\n+\n+                ScopedValue.where(name, null, () -> {\n+                    assertTrue(name.isBound());\n+                    assertTrue(name.get() == null);\n+                });\n+\n+                assertTrue(name.isBound());\n+                assertEquals(name.get(), \"duke\");\n+            });\n+            assertFalse(name.isBound());\n+\n+            \/\/ call\n+            ScopedValue.where(name, \"duke\", () -> {\n+                assertTrue(name.isBound());\n+                assertEquals(name.get(), \"duke\");\n+\n+                ScopedValue.where(name, null, () -> {\n+                    assertTrue(name.isBound());\n+                    assertTrue(name.get() == null);\n+                    return null;\n+                });\n+\n+                assertTrue(name.isBound());\n+                assertEquals(name.get(), \"duke\");\n+                return null;\n+            });\n+            assertFalse(name.isBound());\n+        });\n+    }\n+\n+    \/**\n+     * Test Carrier.get.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testCarrierGet(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            ScopedValue<Integer> age = ScopedValue.newInstance();\n+\n+            \/\/ one scoped value\n+            var carrier1 = ScopedValue.where(name, \"duke\");\n+            assertEquals(carrier1.get(name), \"duke\");\n+            assertThrows(NoSuchElementException.class, () -> carrier1.get(age));\n+\n+            \/\/ two scoped values\n+            var carrier2 = carrier1.where(age, 20);\n+            assertEquals(carrier2.get(name), \"duke\");\n+            assertEquals((int) carrier2.get(age), 20);\n+        });\n+    }\n+\n+    \/**\n+     * Test NullPointerException.\n+     *\/\n+    public void testNullPointerException() {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+\n+        assertThrows(NullPointerException.class, () -> ScopedValue.where(null, \"value\"));\n+        assertThrows(NullPointerException.class, () -> ScopedValue.where(null, \"value\", () -> { }));\n+        assertThrows(NullPointerException.class, () -> ScopedValue.where(null, \"value\", () -> null));\n+\n+        assertThrows(NullPointerException.class, () -> name.orElseThrow(null));\n+\n+        var carrier = ScopedValue.where(name, \"duke\");\n+        assertThrows(NullPointerException.class, () -> carrier.where(null, \"value\"));\n+        assertThrows(NullPointerException.class, () -> carrier.get(null));\n+        assertThrows(NullPointerException.class, () -> carrier.run(null));\n+        assertThrows(NullPointerException.class, () -> carrier.call(null));\n+    }\n+\n+    @FunctionalInterface\n+    private interface ThrowingRunnable {\n+        void run() throws Exception;\n+    }\n+\n+    \/**\n+     * Run the given task in a thread created with the given thread factory.\n+     * @throws Exception if the task throws an exception\n+     *\/\n+    private static void test(ThreadFactory factory, ThrowingRunnable task) throws Exception {\n+        try (var executor = Executors.newThreadPerTaskExecutor(factory)) {\n+            var future = executor.submit(() -> {\n+                task.run();\n+                return null;\n+            });\n+            try {\n+                future.get();\n+            } catch (ExecutionException ee) {\n+                Throwable cause = ee.getCause();\n+                if (cause instanceof Exception e)\n+                    throw e;\n+                if (cause instanceof Error e)\n+                    throw e;\n+                throw new RuntimeException(cause);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/ScopedValue\/ScopeValueAPI.java","additions":442,"deletions":0,"binary":false,"changes":442,"status":"added"},{"patch":"@@ -0,0 +1,213 @@\n+\/*\n+ * Copyright (c) 2021, 2022 Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary StressStackOverflow the recovery path for ScopedValue\n+ * @modules jdk.incubator.concurrent\n+ * @compile --enable-preview -source ${jdk.version} StressStackOverflow.java\n+ * @run main\/othervm\/timeout=300 -XX:-TieredCompilation --enable-preview StressStackOverflow\n+ * @run main\/othervm\/timeout=300 -XX:TieredStopAtLevel=1 --enable-preview StressStackOverflow\n+ * @run main\/othervm\/timeout=300 --enable-preview StressStackOverflow\n+ *\/\n+\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadLocalRandom;\n+import jdk.incubator.concurrent.ScopedValue;\n+import jdk.incubator.concurrent.StructureViolationException;\n+import jdk.incubator.concurrent.StructuredTaskScope;\n+\n+public class StressStackOverflow {\n+    public static final ScopedValue<Integer> el = ScopedValue.newInstance();\n+\n+    public static final ScopedValue<Integer> inheritedValue = ScopedValue.newInstance();\n+\n+    final ThreadLocalRandom tlr = ThreadLocalRandom.current();\n+    static final TestFailureException testFailureException = new TestFailureException(\"Unexpected value for ScopedValue\");\n+    int ITERS = 1_000_000;\n+\n+    static class TestFailureException extends RuntimeException {\n+        TestFailureException(String s) { super(s); }\n+    }\n+\n+    \/\/ Test the ScopedValue recovery mechanism for stack overflows. We implement both Callable\n+    \/\/ and Runnable interfaces. Which one gets tested depends on the constructor argument.\n+    class DeepRecursion implements Callable, Runnable {\n+\n+        static enum Behaviour {CALL, RUN}\n+        final Behaviour behaviour;\n+\n+        public DeepRecursion(Behaviour behaviour) {\n+            this.behaviour = behaviour;\n+        }\n+\n+        public void run() {\n+            final var last = el.get();\n+            ITERS--;\n+            var nextRandomFloat = tlr.nextFloat();\n+            try {\n+                switch (behaviour) {\n+                    case CALL ->\n+                        ScopedValue.where(el, el.get() + 1).call(() -> fibonacci_pad(20, this));\n+                    case RUN ->\n+                        ScopedValue.where(el, el.get() + 1).run(() -> fibonacci_pad(20, this));\n+                }\n+                if (!last.equals(el.get())) {\n+                    throw testFailureException;\n+                }\n+            } catch (StackOverflowError e) {\n+                if (nextRandomFloat <= 0.1) {\n+                    ScopedValue.where(el, el.get() + 1).run(this);\n+                }\n+            } catch (TestFailureException e) {\n+                throw e;\n+            } catch (Throwable throwable) {\n+                \/\/ StackOverflowErrors cause many different failures. These include\n+                \/\/ StructureViolationExceptions and InvocationTargetExceptions. This test\n+                \/\/ checks that, no matter what the failure mode, scoped values are handled\n+                \/\/ correctly.\n+            } finally {\n+                if (!last.equals(el.get())) {\n+                    throw testFailureException;\n+                }\n+            }\n+\n+            Thread.yield();\n+        }\n+\n+        public Object call() {\n+            run();\n+            return null;\n+        }\n+    }\n+\n+    static final Runnable nop = new Runnable() {\n+        public void run() { }\n+    };\n+\n+    \/\/ Consume some stack.\n+    \/\/\n+\n+    \/\/ The double recursion used here prevents an optimizing JIT from\n+    \/\/ inlining all the recursive calls, which would make it\n+    \/\/ ineffective.\n+    private long fibonacci_pad1(int n, Runnable op) {\n+        if (n <= 1) {\n+            op.run();\n+            return n;\n+        }\n+        return fibonacci_pad1(n - 1, op) + fibonacci_pad1(n - 2, nop);\n+    }\n+\n+    private static final Integer I_42 = 42;\n+\n+    long fibonacci_pad(int n, Runnable op) {\n+        final var last = el.get();\n+        try {\n+            return fibonacci_pad1(tlr.nextInt(n), op);\n+        } catch (StackOverflowError err) {\n+            if (!inheritedValue.get().equals(I_42)) {\n+                throw testFailureException;\n+            }\n+            if (!last.equals(el.get())) {\n+                throw testFailureException;\n+            }\n+            throw err;\n+        }\n+    }\n+\n+    \/\/ Run op in a new thread. Platform or virtual threads are chosen at random.\n+    void runInNewThread(Runnable op) {\n+        var threadFactory\n+                = (tlr.nextBoolean() ? Thread.ofPlatform() : Thread.ofVirtual()).factory();\n+        try (var scope = new StructuredTaskScope<Object>(\"\", threadFactory)) {\n+            var future = scope.fork(() -> {\n+                op.run();\n+                return null;\n+            });\n+            future.get();\n+            scope.join();\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public void run() {\n+        try {\n+            ScopedValue.where(inheritedValue, 42).where(el, 0).run(() -> {\n+                try (var scope = new StructuredTaskScope<Object>()) {\n+                    try {\n+                        if (tlr.nextBoolean()) {\n+                            \/\/ Repeatedly test Scoped Values set by ScopedValue::call() and ScopedValue::run()\n+                            final var deepRecursion\n+                                    = new DeepRecursion(tlr.nextBoolean() ? DeepRecursion.Behaviour.CALL : DeepRecursion.Behaviour.RUN);\n+                            deepRecursion.run();\n+                        } else {\n+                            \/\/ Recursively run ourself until we get a stack overflow\n+                            \/\/ Catch the overflow and make sure the recovery path works\n+                            \/\/ for values inherited from a StructuredTaskScope.\n+                            Runnable op = new Runnable() {\n+                                public void run() {\n+                                    try {\n+                                        fibonacci_pad(20, this);\n+                                    } catch (StackOverflowError e) {\n+                                    } catch (TestFailureException e) {\n+                                        throw e;\n+                                    } catch (Throwable throwable) {\n+                                        \/\/ StackOverflowErrors cause many different failures. These include\n+                                        \/\/ StructureViolationExceptions and InvocationTargetExceptions. This test\n+                                        \/\/ checks that, no matter what the failure mode, scoped values are handled\n+                                        \/\/ correctly.\n+                                    } finally {\n+                                        if (!inheritedValue.get().equals(I_42)) {\n+                                            throw testFailureException;\n+                                        }\n+                                    }\n+                                }\n+                            };\n+                            runInNewThread(op);\n+                        }\n+                        scope.join();\n+                    } catch (StructureViolationException structureViolationException) {\n+                        \/\/ Can happen if a stack overflow prevented a StackableScope from\n+                        \/\/ being removed. We can continue.\n+                    } catch (Exception e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                }\n+            });\n+        } catch (StructureViolationException structureViolationException) {\n+            \/\/ Can happen if a stack overflow prevented a StackableScope from\n+            \/\/ being removed. We can continue.\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        var torture = new StressStackOverflow();\n+        while (torture.ITERS > 0) {\n+            torture.run();\n+        }\n+        System.out.println(\"OK\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/ScopedValue\/StressStackOverflow.java","additions":213,"deletions":0,"binary":false,"changes":213,"status":"added"},{"patch":"@@ -0,0 +1,216 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Basic tests for StructuredTaskScope with scoped values\n+ * @enablePreview\n+ * @modules jdk.incubator.concurrent\n+ * @run testng WithScopedValue\n+ *\/\n+\n+import jdk.incubator.concurrent.ScopedValue;\n+import jdk.incubator.concurrent.StructuredTaskScope;\n+import jdk.incubator.concurrent.StructureViolationException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+@Test\n+public class WithScopedValue {\n+\n+    @DataProvider\n+    public Object[][] factories() {\n+        return new Object[][] {\n+                { Thread.ofPlatform().factory() },\n+                { Thread.ofVirtual().factory() },\n+        };\n+    }\n+\n+    \/**\n+     * Test that fork inherits a scoped value into a child thread.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testForkInheritsScopedValue1(ThreadFactory factory) throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        String value = ScopedValue.where(name, \"x\", () -> {\n+            try (var scope = new StructuredTaskScope<String>(null, factory)) {\n+                Future<String> future = scope.fork(() -> {\n+                    return name.get(); \/\/ child should read \"x\"\n+                });\n+                scope.join();\n+                return future.resultNow();\n+            }\n+        });\n+        assertEquals(value, \"x\");\n+    }\n+\n+    \/**\n+     * Test that fork inherits a scoped value into a grandchild thread.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testForkInheritsScopedValue2(ThreadFactory factory) throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        String value = ScopedValue.where(name, \"x\", () -> {\n+            try (var scope1 = new StructuredTaskScope<String>(null, factory)) {\n+                Future<String> future1 = scope1.fork(() -> {\n+                    try (var scope2 = new StructuredTaskScope<String>(null, factory)) {\n+                        Future<String> future2 = scope2.fork(() -> {\n+                            return name.get(); \/\/ grandchild should read \"x\"\n+                        });\n+                        scope2.join();\n+                        return future2.resultNow();\n+                    }\n+                });\n+                scope1.join();\n+                return future1.resultNow();\n+            }\n+        });\n+        assertEquals(value, \"x\");\n+    }\n+\n+    \/**\n+     * Test that fork inherits a rebound scoped value into a grandchild thread.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testForkInheritsScopedValue3(ThreadFactory factory) throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        String value = ScopedValue.where(name, \"x\", () -> {\n+            try (var scope1 = new StructuredTaskScope<String>(null, factory)) {\n+                Future<String> future1 = scope1.fork(() -> {\n+                    assertEquals(name.get(), \"x\");  \/\/ child should read \"x\"\n+\n+                    \/\/ rebind name to \"y\"\n+                    String grandchildValue = ScopedValue.where(name, \"y\", () -> {\n+                        try (var scope2 = new StructuredTaskScope<String>(null, factory)) {\n+                            Future<String> future2 = scope2.fork(() -> {\n+                                return name.get(); \/\/ grandchild should read \"y\"\n+                            });\n+                            scope2.join();\n+                            return future2.resultNow();\n+                        }\n+                    });\n+\n+                    assertEquals(name.get(), \"x\");  \/\/ child should read \"x\"\n+                    return grandchildValue;\n+                });\n+                scope1.join();\n+                return future1.resultNow();\n+            }\n+        });\n+        assertEquals(value, \"y\");\n+    }\n+\n+    \/**\n+     * Test exiting a dynamic scope with an open task scope.\n+     *\/\n+    public void testStructureViolation1() throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        class Box {\n+            StructuredTaskScope<Object> scope;\n+        }\n+        var box = new Box();\n+        try {\n+            try {\n+                ScopedValue.where(name, \"x\", () -> {\n+                    box.scope = new StructuredTaskScope<Object>();\n+                });\n+                fail();\n+            } catch (StructureViolationException expected) { }\n+\n+            \/\/ underlying flock should be closed, fork should return a cancelled task\n+            StructuredTaskScope<Object> scope = box.scope;\n+            AtomicBoolean ran = new AtomicBoolean();\n+            Future<Object> future = scope.fork(() -> {\n+                ran.set(true);\n+                return null;\n+            });\n+            assertTrue(future.isCancelled());\n+            scope.join();\n+            assertFalse(ran.get());\n+\n+        } finally {\n+            StructuredTaskScope<Object> scope = box.scope;\n+            if (scope != null) {\n+                scope.close();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test closing a StructuredTaskScope while executing in a dynamic scope.\n+     *\/\n+    public void testStructureViolation2() throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        try (var scope = new StructuredTaskScope<String>()) {\n+            ScopedValue.where(name, \"x\", () -> {\n+                assertThrows(StructureViolationException.class, scope::close);\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * Test fork when a scoped value is bound after a StructuredTaskScope is created.\n+     *\/\n+    public void testStructureViolation3() throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        try (var scope = new StructuredTaskScope<String>()) {\n+            ScopedValue.where(name, \"x\", () -> {\n+                assertThrows(StructureViolationException.class,\n+                        () -> scope.fork(() -> \"foo\"));\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * Test fork when a scoped value is re-bound after a StructuredTaskScope is created.\n+     *\/\n+    public void testStructureViolation4() throws Exception {\n+        ScopedValue<String> name1 = ScopedValue.newInstance();\n+        ScopedValue<String> name2 = ScopedValue.newInstance();\n+\n+        \/\/ rebind\n+        ScopedValue.where(name1, \"x\", () -> {\n+            try (var scope = new StructuredTaskScope<String>()) {\n+                ScopedValue.where(name1, \"y\", () -> {\n+                    assertThrows(StructureViolationException.class,\n+                            () -> scope.fork(() -> \"foo\"));\n+                });\n+            }\n+        });\n+\n+        \/\/ new binding\n+        ScopedValue.where(name1, \"x\", () -> {\n+            try (var scope = new StructuredTaskScope<String>()) {\n+                ScopedValue.where(name2, \"y\", () -> {\n+                    assertThrows(StructureViolationException.class,\n+                            () -> scope.fork(() -> \"foo\"));\n+                });\n+            }\n+        });\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/StructuredTaskScope\/WithScopedValue.java","additions":216,"deletions":0,"binary":false,"changes":216,"status":"added"},{"patch":"@@ -25,1 +25,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -46,1 +46,1 @@\n-                    MemorySegment.allocateNative(s, MemorySession.implicit())\n+                    MemorySegment.allocateNative(s, SegmentScope.auto())\n@@ -54,1 +54,1 @@\n-                    MemorySegment.allocateNative(s, MemorySession.implicit())\n+                    MemorySegment.allocateNative(s, SegmentScope.auto())\n","filename":"test\/jdk\/jdk\/incubator\/vector\/AbstractVectorLoadStoreTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, SegmentScope.auto());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, SegmentScope.auto());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, SegmentScope.auto());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, SegmentScope.auto());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, SegmentScope.auto());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, SegmentScope.auto());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, SegmentScope.auto());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, SegmentScope.auto());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, SegmentScope.auto());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, SegmentScope.auto());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, SegmentScope.auto());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, SegmentScope.auto());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, SegmentScope.auto());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, SegmentScope.auto());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, SegmentScope.auto());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, SegmentScope.auto());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -489,2 +489,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, SegmentScope.auto());\n@@ -518,2 +518,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, SegmentScope.auto());\n@@ -582,2 +582,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, SegmentScope.auto());\n@@ -613,2 +613,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, SegmentScope.auto());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, SegmentScope.auto());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, SegmentScope.auto());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, SegmentScope.auto());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, SegmentScope.auto());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, SegmentScope.auto());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, SegmentScope.auto());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, SegmentScope.auto());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, SegmentScope.auto());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, SegmentScope.auto());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, SegmentScope.auto());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, SegmentScope.auto());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, SegmentScope.auto());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, SegmentScope.auto());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, SegmentScope.auto());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, SegmentScope.auto());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, SegmentScope.auto());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -489,2 +489,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, SegmentScope.auto());\n@@ -518,2 +518,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, SegmentScope.auto());\n@@ -582,2 +582,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, SegmentScope.auto());\n@@ -613,2 +613,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, SegmentScope.auto());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, SegmentScope.auto());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, SegmentScope.auto());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, SegmentScope.auto());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, SegmentScope.auto());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, SegmentScope.auto());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, SegmentScope.auto());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, SegmentScope.auto());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, SegmentScope.auto());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, SegmentScope.auto());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, SegmentScope.auto());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, SegmentScope.auto());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, SegmentScope.auto());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, SegmentScope.auto());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, SegmentScope.auto());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, SegmentScope.auto());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, SegmentScope.auto());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -489,2 +489,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, SegmentScope.auto());\n@@ -518,2 +518,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, SegmentScope.auto());\n@@ -582,2 +582,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, SegmentScope.auto());\n@@ -613,2 +613,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, SegmentScope.auto());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, SegmentScope.auto());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, SegmentScope.auto());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, SegmentScope.auto());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, SegmentScope.auto());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, SegmentScope.auto());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, SegmentScope.auto());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, SegmentScope.auto());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, SegmentScope.auto());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, SegmentScope.auto());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, SegmentScope.auto());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, SegmentScope.auto());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, SegmentScope.auto());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, SegmentScope.auto());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, SegmentScope.auto());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, SegmentScope.auto());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, SegmentScope.auto());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -489,2 +489,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, SegmentScope.auto());\n@@ -518,2 +518,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, SegmentScope.auto());\n@@ -582,2 +582,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, SegmentScope.auto());\n@@ -613,2 +613,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, SegmentScope.auto());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, SegmentScope.auto());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, SegmentScope.auto());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, SegmentScope.auto());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, SegmentScope.auto());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, SegmentScope.auto());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, SegmentScope.auto());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, SegmentScope.auto());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, SegmentScope.auto());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, SegmentScope.auto());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, SegmentScope.auto());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, SegmentScope.auto());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, SegmentScope.auto());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, SegmentScope.auto());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, SegmentScope.auto());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, SegmentScope.auto());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, SegmentScope.auto());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -489,2 +489,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, SegmentScope.auto());\n@@ -518,2 +518,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, SegmentScope.auto());\n@@ -582,2 +582,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, SegmentScope.auto());\n@@ -613,2 +613,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, SegmentScope.auto());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, SegmentScope.auto());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, SegmentScope.auto());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, SegmentScope.auto());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, SegmentScope.auto());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, SegmentScope.auto());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, SegmentScope.auto());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, SegmentScope.auto());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, SegmentScope.auto());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, SegmentScope.auto());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, SegmentScope.auto());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, SegmentScope.auto());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, SegmentScope.auto());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, SegmentScope.auto());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, SegmentScope.auto());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, SegmentScope.auto());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, SegmentScope.auto());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -489,2 +489,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, SegmentScope.auto());\n@@ -518,2 +518,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, SegmentScope.auto());\n@@ -582,2 +582,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, SegmentScope.auto());\n@@ -613,2 +613,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, SegmentScope.auto());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -502,2 +502,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, $Boxtype$.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), $Boxtype$.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, $Boxtype$.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), $Boxtype$.SIZE, SegmentScope.auto());\n@@ -531,2 +531,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, $Boxtype$.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), $Boxtype$.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, $Boxtype$.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), $Boxtype$.SIZE, SegmentScope.auto());\n@@ -595,2 +595,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, $Boxtype$.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), $Boxtype$.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, $Boxtype$.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), $Boxtype$.SIZE, SegmentScope.auto());\n@@ -626,2 +626,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, $Boxtype$.SIZE, MemorySession.implicit()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), $Boxtype$.SIZE, MemorySession.implicit());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, $Boxtype$.SIZE, SegmentScope.auto()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), $Boxtype$.SIZE, SegmentScope.auto());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/X-LoadStoreTest.java.template","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,220 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test ThreadFlock with scoped values\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.misc\n+ * @modules jdk.incubator.concurrent\n+ * @run testng WithScopedValue\n+ *\/\n+\n+import jdk.internal.misc.ThreadFlock;\n+import jdk.incubator.concurrent.ScopedValue;\n+import jdk.incubator.concurrent.StructureViolationException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+@Test\n+public class WithScopedValue {\n+\n+    @DataProvider(name = \"factories\")\n+    public Object[][] factories() {\n+        var defaultThreadFactory = Executors.defaultThreadFactory();\n+        var virtualThreadFactory = Thread.ofVirtual().factory();\n+        return new Object[][]{\n+                { defaultThreadFactory, },\n+                { virtualThreadFactory, },\n+        };\n+    }\n+\n+    \/**\n+     * Test inheritance of a scoped value.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testInheritsScopedValue(ThreadFactory factory) throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        String value = ScopedValue.where(name, \"duke\", () -> {\n+            var result = new AtomicReference<String>();\n+            try (var flock = ThreadFlock.open(null)) {\n+                Thread thread = factory.newThread(() -> {\n+                    \/\/ child\n+                    result.set(name.get());\n+                });\n+                flock.start(thread);\n+            }\n+            return result.get();\n+        });\n+        assertEquals(value, \"duke\");\n+    }\n+\n+    \/**\n+     * Test exiting a dynamic scope with open thread flocks.\n+     *\/\n+    public void testStructureViolation1() {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        class Box {\n+            ThreadFlock flock1;\n+            ThreadFlock flock2;\n+        }\n+        var box = new Box();\n+        try {\n+            ScopedValue.where(name, \"x1\", () -> {\n+                box.flock1 = ThreadFlock.open(null);\n+                box.flock2 = ThreadFlock.open(null);\n+            });\n+            fail();\n+        } catch (StructureViolationException expected) { }\n+        assertTrue(box.flock1.isClosed());\n+        assertTrue(box.flock2.isClosed());\n+    }\n+\n+    \/**\n+     * Test closing a thread flock while in a dynamic scope and with enclosing thread\n+     * flocks. This test closes enclosing flock1.\n+     *\/\n+    public void testStructureViolation2() {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        try (var flock1 = ThreadFlock.open(\"flock1\")) {\n+            ScopedValue.where(name, \"x1\", () -> {\n+                try (var flock2 = ThreadFlock.open(\"flock2\")) {\n+                    ScopedValue.where(name, \"x2\", () -> {\n+                        try (var flock3 = ThreadFlock.open(\"flock3\")) {\n+                            ScopedValue.where(name, \"x3\", () -> {\n+                                var flock4 = ThreadFlock.open(\"flock4\");\n+\n+                                try {\n+                                    flock1.close();\n+                                    fail();\n+                                } catch (StructureViolationException expected) { }\n+\n+                                assertTrue(flock1.isClosed());\n+                                assertTrue(flock2.isClosed());\n+                                assertTrue(flock3.isClosed());\n+                                assertTrue(flock4.isClosed());\n+                            });\n+                        }\n+                    });\n+                }\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * Test closing a thread flock while in a dynamic scope and with enclosing thread\n+     * flocks. This test closes enclosing flock2.\n+     *\/\n+    public void testStructureViolation3() {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        try (var flock1 = ThreadFlock.open(\"flock1\")) {\n+            ScopedValue.where(name, \"x1\", () -> {\n+                try (var flock2 = ThreadFlock.open(\"flock2\")) {\n+                    ScopedValue.where(name, \"x2\", () -> {\n+                        try (var flock3 = ThreadFlock.open(\"flock3\")) {\n+                            ScopedValue.where(name, \"x3\", () -> {\n+                                var flock4 = ThreadFlock.open(\"flock4\");\n+\n+                                try {\n+                                    flock2.close();\n+                                    fail();\n+                                } catch (StructureViolationException expected) { }\n+\n+                                assertFalse(flock1.isClosed());\n+                                assertTrue(flock2.isClosed());\n+                                assertTrue(flock3.isClosed());\n+                                assertTrue(flock4.isClosed());\n+                            });\n+                        }\n+                    });\n+                }\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * Test closing a thread flock while in a dynamic scope and with enclosing thread\n+     * flocks. This test closes enclosing flock3.\n+     *\/\n+    public void testStructureViolation4() {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        try (var flock1 = ThreadFlock.open(\"flock1\")) {\n+            ScopedValue.where(name, \"x1\", () -> {\n+                try (var flock2 = ThreadFlock.open(\"flock2\")) {\n+                    ScopedValue.where(name, \"x2\", () -> {\n+                        try (var flock3 = ThreadFlock.open(\"flock3\")) {\n+                            ScopedValue.where(name, \"x3\", () -> {\n+                                var flock4 = ThreadFlock.open(\"flock4\");\n+\n+                                try {\n+                                    flock3.close();\n+                                    fail();\n+                                } catch (StructureViolationException expected) { }\n+\n+                                assertFalse(flock1.isClosed());\n+                                assertFalse(flock2.isClosed());\n+                                assertTrue(flock3.isClosed());\n+                                assertTrue(flock4.isClosed());\n+                            });\n+                        }\n+                    });\n+                }\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * Test start when a scoped value is bound after a thread flock is created.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testStructureViolation5(ThreadFactory factory) throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        try (var flock = ThreadFlock.open(null)) {\n+            ScopedValue.where(name, \"duke\", () -> {\n+                Thread thread = factory.newThread(() -> { });\n+                expectThrows(StructureViolationException.class, () -> flock.start(thread));\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * Test start when a scoped value is re-bound after a thread flock is created.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testStructureViolation6(ThreadFactory factory) throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        ScopedValue.where(name, \"duke\", () -> {\n+            try (var flock = ThreadFlock.open(null)) {\n+                ScopedValue.where(name, \"duchess\", () -> {\n+                    Thread thread = factory.newThread(() -> { });\n+                    expectThrows(StructureViolationException.class, () -> flock.start(thread));\n+                });\n+            }\n+        });\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/misc\/ThreadFlock\/WithScopedValue.java","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"},{"patch":"@@ -75,0 +75,3 @@\n+import jdk.test.lib.Platform;\n+import jtreg.SkippedException;\n+\n@@ -87,0 +90,4 @@\n+        if (Platform.isSlowDebugBuild() && Platform.isOSX() && Platform.isAArch64()) {\n+            throw new SkippedException(\"Test is unstable with slowdebug bits \"\n+                                       + \"on macosx-aarch64\");\n+        }\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/Fuzz.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules java.base\/jdk.internal.vm\n+ *          java.base\/jdk.internal.misc\n+ * @run testng\/othervm\n+ *      jdk.internal.vm.test.TestTranslatedException\n+ *\/\n+package jdk.internal.vm.test;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.VMSupport;\n+\n+public class TestTranslatedException {\n+    @SuppressWarnings(\"serial\")\n+    public static class Untranslatable extends RuntimeException {\n+        public Untranslatable(String message, Throwable cause) {\n+            super(message, cause);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test\n+    public void encodeDecodeTest() throws Exception {\n+        Throwable throwable = new ExceptionInInitializerError(new InvocationTargetException(new Untranslatable(\"test exception\", new NullPointerException()), \"invoke\"));\n+        for (int i = 0; i < 10; i++) {\n+            throwable = new ExceptionInInitializerError(new InvocationTargetException(new RuntimeException(String.valueOf(i), throwable), \"invoke\"));\n+        }\n+        encodeDecode(throwable);\n+    }\n+    @SuppressWarnings(\"unchecked\")\n+    @Test\n+    public void encodeDecodeTest2() throws Exception {\n+        Throwable throwable = new ExceptionInInitializerError(new InvocationTargetException(new Untranslatable(\"test exception\", new NullPointerException()), \"invoke\"));\n+        for (int i = 0; i < 10; i++) {\n+            throwable = new ExceptionInInitializerError(new InvocationTargetException(new RuntimeException(String.valueOf(i), throwable), \"invoke\"));\n+        }\n+        encodeDecode(throwable);\n+    }\n+\n+    private void encodeDecode(Throwable throwable) throws Exception {\n+        Unsafe unsafe = Unsafe.getUnsafe();\n+        int bufferSize = 512;\n+        long buffer = 0L;\n+        while (true) {\n+            buffer = unsafe.allocateMemory(bufferSize);\n+            try {\n+                int res = VMSupport.encodeThrowable(throwable, buffer, bufferSize);\n+                if (res < 0) {\n+                    bufferSize = -res;\n+                } else {\n+                    try {\n+                        VMSupport.decodeAndThrowThrowable(buffer);\n+                        throw new AssertionError(\"expected decodeAndThrowThrowable to throw an exception\");\n+                    } catch (Throwable decoded) {\n+                        assertThrowableEquals(throwable, decoded);\n+                    }\n+                    return;\n+                }\n+            } finally {\n+                unsafe.freeMemory(buffer);\n+            }\n+        }\n+    }\n+\n+    private static void assertThrowableEquals(Throwable original, Throwable decoded) {\n+        try {\n+            Assert.assertEquals(original == null, decoded == null);\n+            while (original != null) {\n+                if (Untranslatable.class.equals(original.getClass())) {\n+                    Assert.assertEquals(decoded.getClass().getName(), \"jdk.internal.vm.TranslatedException\");\n+                    Assert.assertEquals(decoded.toString(), \"jdk.internal.vm.TranslatedException[jdk.internal.vm.test.TestTranslatedException$Untranslatable]: test exception\");\n+                    Assert.assertEquals(original.getMessage(), \"test exception\");\n+                } else {\n+                    Assert.assertEquals(decoded.getClass().getName(), original.getClass().getName());\n+                    Assert.assertEquals(decoded.getMessage(), original.getMessage());\n+                }\n+                StackTraceElement[] originalStack = original.getStackTrace();\n+                StackTraceElement[] decodedStack = decoded.getStackTrace();\n+                Assert.assertEquals(originalStack.length, decodedStack.length);\n+                for (int i = 0, n = originalStack.length; i < n; ++i) {\n+                    StackTraceElement originalStackElement = originalStack[i];\n+                    StackTraceElement decodedStackElement = decodedStack[i];\n+                    Assert.assertEquals(decodedStackElement.getClassLoaderName(), originalStackElement.getClassLoaderName());\n+                    Assert.assertEquals(decodedStackElement.getModuleName(), originalStackElement.getModuleName());\n+                    Assert.assertEquals(decodedStackElement.getClassName(), originalStackElement.getClassName());\n+                    Assert.assertEquals(decodedStackElement.getMethodName(), originalStackElement.getMethodName());\n+                    Assert.assertEquals(decodedStackElement.getFileName(), originalStackElement.getFileName());\n+                    Assert.assertEquals(decodedStackElement.getLineNumber(), originalStackElement.getLineNumber());\n+                }\n+                original = original.getCause();\n+                decoded = decoded.getCause();\n+            }\n+        } catch (AssertionError e) {\n+            System.err.println(\"original:[\");\n+            original.printStackTrace(System.err);\n+            System.err.println(\"]\");\n+            System.err.println(\"decoded:[\");\n+            original.printStackTrace(System.err);\n+            System.err.println(\"]\");\n+            throw e;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/vm\/TestTranslatedException.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -152,1 +152,1 @@\n-                if (outerCount.get() == 3) {\n+                if (outerCount.get() != 3) {\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/recordingstream\/TestStop.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,1 @@\n+            Events.assertField(event, \"dynamicCompilerThreadCount\");\n","filename":"test\/jdk\/jdk\/jfr\/event\/compiler\/TestCompilerConfig.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,1 +101,1 @@\n-            verifyValueDesscriptors(eventType.getFields(), types);\n+            verifyValueDescriptors(eventType.getFields(), types);\n@@ -119,1 +119,1 @@\n-    private static void verifyValueDesscriptors(List<ValueDescriptor> fields, Set<String> visitedTypes) {\n+    private static void verifyValueDescriptors(List<ValueDescriptor> fields, Set<String> visitedTypes) {\n@@ -123,1 +123,1 @@\n-                verifyValueDesscriptors(v.getFields(), visitedTypes);\n+                verifyValueDescriptors(v.getFields(), visitedTypes);\n","filename":"test\/jdk\/jdk\/jfr\/event\/metadata\/TestEventMetadata.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,175 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.runtime;\n+\n+import static jdk.test.lib.Asserts.assertGreaterThan;\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+\n+\/**\n+ * @test\n+ * @key jfr\n+ * @requires vm.opt.NativeMemoryTracking == null\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @modules jdk.jfr\n+ *          jdk.management\n+ * @run main\/othervm -XX:NativeMemoryTracking=summary -Xms16m -Xmx128m -Xlog:gc jdk.jfr.event.runtime.TestNativeMemoryUsageEvents true\n+ * @run main\/othervm -XX:NativeMemoryTracking=off -Xms16m -Xmx128m -Xlog:gc jdk.jfr.event.runtime.TestNativeMemoryUsageEvents false\n+ *\/\n+public class TestNativeMemoryUsageEvents {\n+    private final static String UsageTotalEvent = EventNames.NativeMemoryUsageTotal;\n+    private final static String UsageEvent = EventNames.NativeMemoryUsage;\n+\n+    private final static int UsagePeriod = 1000;\n+    private final static int K = 1024;\n+\n+    private final static String[] UsageEventTypes = {\n+        \"Java Heap\",\n+        \"Class\",\n+        \"Thread\",\n+        \"Thread Stack\",\n+        \"Code\",\n+        \"GC\",\n+        \"GCCardSet\",\n+        \"Compiler\",\n+        \"JVMCI\",\n+        \"Internal\",\n+        \"Other\",\n+        \"Symbol\",\n+        \"Native Memory Tracking\",\n+        \"Shared class space\",\n+        \"Arena Chunk\",\n+        \"Test\",\n+        \"Tracing\",\n+        \"Logging\",\n+        \"Statistics\",\n+        \"Arguments\",\n+        \"Module\",\n+        \"Safepoint\",\n+        \"Synchronization\",\n+        \"Serviceability\",\n+        \"Metaspace\",\n+        \"String Deduplication\",\n+        \"Object Monitors\"\n+    };\n+\n+    private static ArrayList<byte[]> data = new ArrayList<byte[]>();\n+\n+    private static void generateHeapContents() {\n+        for (int i = 0 ; i < 64; i++) {\n+            for (int j = 0; j < K; j++) {\n+                data.add(new byte[K]);\n+            }\n+        }\n+    }\n+\n+    private static void generateEvents(Recording recording) throws Exception {\n+        \/\/ Enable the two types of events for \"everyChunk\", it will give\n+        \/\/ an event at the beginning of the chunk as well as at the end.\n+        recording.enable(UsageEvent).with(\"period\", \"everyChunk\");\n+        recording.enable(UsageTotalEvent).with(\"period\", \"everyChunk\");\n+\n+        recording.start();\n+\n+        \/\/ Generate data to force heap to grow.\n+        generateHeapContents();\n+\n+        \/\/ To allow the two usage events to share a single NMTUsage snapshot\n+        \/\/ there is an AgeThreshold set to 50ms and if the two events occur\n+        \/\/ within this interval they will use the same snapshot. On fast\n+        \/\/ machines it is possible that the whole heap contents generation\n+        \/\/ take less than 50ms and therefor both beginChunk end endChunk\n+        \/\/ events will use the same NMTUsage snapshot. To avoid this, do\n+        \/\/ a short sleep.\n+        Thread.sleep(100);\n+\n+        recording.stop();\n+    }\n+\n+    private static void verifyExpectedEventTypes(List<RecordedEvent> events) throws Exception {\n+        \/\/ First verify that the number of total usage events is greater than 0.\n+        long numberOfTotal = events.stream()\n+                .filter(e -> e.getEventType().getName().equals(UsageTotalEvent))\n+                .count();\n+\n+        assertGreaterThan(numberOfTotal, 0L, \"Should exist events of type: \" + UsageTotalEvent);\n+\n+        \/\/ Now verify that we got the expected events.\n+        List<String> uniqueEventTypes = events.stream()\n+                .filter(e -> e.getEventType().getName().equals(UsageEvent))\n+                .map(e -> e.getString(\"type\"))\n+                .distinct()\n+                .toList();\n+        for (String type : UsageEventTypes) {\n+            assertTrue(uniqueEventTypes.contains(type), \"Events should include: \" + type);\n+        }\n+    }\n+\n+    private static void verifyHeapGrowth(List<RecordedEvent> events) throws Exception {\n+        List<Long> javaHeapCommitted = events.stream()\n+                .filter(e -> e.getEventType().getName().equals(UsageEvent))\n+                .filter(e -> e.getString(\"type\").equals(\"Java Heap\"))\n+                .map(e -> e.getLong(\"committed\"))\n+                .toList();\n+\n+        \/\/ Verify that the heap has grown between the first and last sample.\n+        long firstSample = javaHeapCommitted.get(0);\n+        long lastSample = javaHeapCommitted.get(javaHeapCommitted.size() - 1);\n+        assertGreaterThan(lastSample, firstSample, \"heap should have grown and NMT should show that\");\n+    }\n+\n+    private static void verifyNoUsageEvents(List<RecordedEvent> events) throws Exception {\n+        Events.hasNotEvent(events, UsageEvent);\n+        Events.hasNotEvent(events, UsageTotalEvent);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ The tests takes a single boolean argument that states wether or not\n+        \/\/ it is run with -XX:NativeMemoryTracking=summary. When tracking is\n+        \/\/ enabled the tests verifies that the correct events are sent and\n+        \/\/ the other way around when turned off.\n+        assertTrue(args.length == 1, \"Must have a single argument\");\n+        boolean nmtEnabled = Boolean.parseBoolean(args[0]);\n+\n+        try (Recording recording = new Recording()) {\n+            generateEvents(recording);\n+\n+            var events = Events.fromRecording(recording);\n+            if (nmtEnabled) {\n+                verifyExpectedEventTypes(events);\n+                verifyHeapGrowth(events);\n+            } else {\n+                verifyNoUsageEvents(events);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestNativeMemoryUsageEvents.java","additions":175,"deletions":0,"binary":false,"changes":175,"status":"added"},{"patch":"@@ -161,1 +161,1 @@\n-                if (outerCount.get() == 3) {\n+                if (outerCount.get() != 3) {\n","filename":"test\/jdk\/jdk\/jfr\/jmx\/streaming\/TestStop.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.jvm;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordingFile;\n+import java.nio.file.Path;\n+\n+\/**\n+ * @test Tests that the event duration is zero after a chunk rotation\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @modules jdk.jfr\/jdk.jfr.internal\n+ * @run main\/othervm jdk.jfr.jvm.TestEventDuration\n+ *\/\n+public class TestEventDuration {\n+\n+    static class InstantEvent extends Event {\n+        long id;\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        try (Recording r1 = new Recording()) {\n+            r1.start();\n+            long counter = 0;\n+            for (int i = 0; i < 10; i ++) {\n+                try (Recording r2 = new Recording()) {\n+                    r2.start();\n+                    InstantEvent e1 = new InstantEvent();\n+                    e1.id = counter++;\n+                    e1.commit();\n+                    InstantEvent e2 = new InstantEvent();\n+                    e2.id = counter++;\n+                    e2.commit();\n+                }\n+            }\n+            Path p = Path.of(\"dump.jfr\");\n+            r1.dump(p);\n+            var events = RecordingFile.readAllEvents(p);\n+            if (events.isEmpty()) {\n+                throw new AssertionError(\"Expected at least one event\");\n+            }\n+            events.forEach(System.out::println);\n+            for (var event : events) {\n+                if (event.getDuration().toNanos() != 0) {\n+                    throw new AssertionError(\"Expected all events to have zero duration\");\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestEventDuration.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -137,24 +137,0 @@\n-    @Test\n-    public void testCast() throws Throwable {\n-        Class<?>[] types = { Object.class, Serializable.class, String.class, Number.class, Integer.class };\n-        Object[] objects = { new Object(), Boolean.FALSE,      \"hello\",      (Long)12L,    (Integer)6    };\n-        for (Class<?> dst : types) {\n-            MethodHandle caster = ValueConversions.cast().bindTo(dst);\n-            assertEquals(caster.type(), MethodHandles.identity(Object.class).type());\n-            for (Object obj : objects) {\n-                Class<?> src = obj.getClass();\n-                boolean canCast = dst.isAssignableFrom(src);\n-                try {\n-                    Object result = caster.invokeExact(obj);\n-                    if (canCast)\n-                        assertEquals(obj, result);\n-                    else\n-                        assertEquals(\"cast should not have succeeded\", dst, obj);\n-                } catch (ClassCastException ex) {\n-                    if (canCast)\n-                        throw ex;\n-                }\n-            }\n-        }\n-    }\n-\n","filename":"test\/jdk\/sun\/invoke\/util\/ValueConversionsTest.java","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1,103 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 4333920 4994372\n- * @summary ChunkedEncoding unit test; MeteredStream\/ProgressData problem\n- * @modules java.base\/sun.net\n- *          jdk.httpserver\n- * @library \/test\/lib\n- * @run main ChunkedEncodingWithProgressMonitorTest\n- *\/\n-\n-import java.net.*;\n-import java.util.BitSet;\n-import sun.net.ProgressMeteringPolicy;\n-import sun.net.ProgressMonitor;\n-import sun.net.ProgressListener;\n-import sun.net.ProgressEvent;\n-\n-public class ChunkedEncodingWithProgressMonitorTest {\n-    public static void main (String[] args) throws Exception {\n-        ProgressMonitor.setMeteringPolicy(new MyProgressMeteringPolicy());\n-        ProgressListener listener = new MyProgressListener();\n-        ProgressMonitor.getDefault().addProgressListener(listener);\n-        ChunkedEncodingTest.test();\n-        ProgressMonitor.getDefault().removeProgressListener(listener);\n-\n-        if (flag.cardinality() != 3) {\n-            throw new RuntimeException(\"All three methods in ProgressListener\"+\n-                                       \" should be called. Yet the number of\"+\n-                                       \" methods actually called are \"+\n-                                       flag.cardinality());\n-        }\n-    }\n-\n-    static class MyProgressMeteringPolicy implements ProgressMeteringPolicy {\n-        \/**\n-         * Return true if metering should be turned on for a particular network input stream.\n-         *\/\n-        public boolean shouldMeterInput(URL url, String method) {\n-            return true;\n-        }\n-\n-        \/**\n-         * Return update notification threshold.\n-         *\/\n-        public int getProgressUpdateThreshold() {\n-            return 8192;\n-        }\n-    }\n-\n-    static BitSet flag = new BitSet(3);\n-\n-    static class MyProgressListener implements ProgressListener {\n-        \/**\n-         * Start progress.\n-         *\/\n-        public void progressStart(ProgressEvent evt) {\n-            System.out.println(\"start: received progressevent \"+evt);\n-            if (flag.nextSetBit(0) == -1)\n-                flag.set(0);\n-        }\n-\n-        \/**\n-         * Update progress.\n-         *\/\n-        public void progressUpdate(ProgressEvent evt) {\n-            System.out.println(\"update: received progressevent \"+evt);\n-            if (flag.nextSetBit(1) == -1)\n-                flag.set(1);\n-        }\n-\n-        \/**\n-         * Finish progress.\n-         *\/\n-        public void progressFinish(ProgressEvent evt) {\n-            System.out.println(\"finish: received progressevent \"+evt);\n-            if (flag.nextSetBit(2) == -1)\n-                flag.set(2);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/sun\/net\/www\/http\/ChunkedInputStream\/ChunkedEncodingWithProgressMonitorTest.java","additions":0,"deletions":103,"binary":false,"changes":103,"status":"deleted"},{"patch":"@@ -0,0 +1,293 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8240275\n+ * @library \/test\/lib\n+ * @run main\/othervm KeepAliveStreamFinalizer\n+ * @summary HttpsURLConnection: connection must not be reused after finalization\n+ *\/\n+\n+import javax.net.ssl.HandshakeCompletedListener;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLSession;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+\n+public class KeepAliveStreamFinalizer {\n+\n+    static Server server;\n+    private static volatile String failureReason;\n+\n+    static class Server extends Thread {\n+        final ServerSocket srv;\n+        static final byte[] requestEnd = new byte[] {'\\r', '\\n', '\\r', '\\n'};\n+\n+        Server(ServerSocket s) {\n+            srv = s;\n+        }\n+\n+        boolean readOneRequest(InputStream is) throws IOException {\n+            int requestEndCount = 0, r;\n+            while ((r = is.read()) != -1) {\n+                if (r == requestEnd[requestEndCount]) {\n+                    requestEndCount++;\n+                    if (requestEndCount == 4) {\n+                        return true;\n+                    }\n+                } else {\n+                    requestEndCount = 0;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        public void run() {\n+            try {\n+                while (true) {\n+                    Socket ss = srv.accept();\n+                    Thread t1 = new Thread(new Runnable() {\n+                        public void run() {\n+                            try {\n+                                InputStream in = ss.getInputStream();\n+                                OutputStream out = ss.getOutputStream();\n+                                while (readOneRequest(in)) {\n+                                    out.write(\"HTTP\/1.1 200 OK\\r\\nConnection: Keep-Alive\\r\\nContent-Length: 1\\r\\n\\r\\na\".getBytes());\n+                                    out.flush();\n+                                }\n+                                in.close();\n+                                out.close();\n+                                ss.close();\n+                            } catch (Exception e) {\n+                                e.printStackTrace();\n+                            }\n+                        }\n+                    });\n+                    t1.setDaemon(true);\n+                    t1.start();\n+                }\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        InetSocketAddress address = startHttpServer();\n+        clientHttpCalls(address);\n+        if (failureReason != null) {\n+            throw new RuntimeException(failureReason);\n+        }\n+    }\n+\n+    public static InetSocketAddress startHttpServer() throws Exception {\n+        InetAddress localHost = InetAddress.getLoopbackAddress();\n+        InetSocketAddress address = new InetSocketAddress(localHost, 0);\n+        ServerSocket serverSocket = new ServerSocket();\n+        serverSocket.bind(address);\n+        server = new Server(serverSocket);\n+        server.setDaemon(true);\n+        server.start();\n+        return (InetSocketAddress) serverSocket.getLocalSocketAddress();\n+    }\n+\n+    public static void doRequest(URL url) throws IOException {\n+        HttpsURLConnection c = (HttpsURLConnection)url.openConnection();\n+        c.setRequestMethod(\"POST\");\n+        c.setDoOutput(true);\n+        OutputStreamWriter out = new OutputStreamWriter(c.getOutputStream());\n+        out.write(\"test\");\n+        out.close();\n+        int responseCode = c.getResponseCode();\n+        \/\/ Fully reading the body causes the HttpsClient to be added to the KeepAliveCache immediately,\n+        \/\/ which avoids this issue since GC will not finalize the HttpsClient.\n+    }\n+\n+    public static void clientHttpCalls(InetSocketAddress address) throws Exception {\n+        try {\n+            System.err.println(\"http server listen on: \" + address.getPort());\n+            String hostAddr = address.getAddress().getHostAddress();\n+            if (hostAddr.indexOf(':') > -1) hostAddr = \"[\" + hostAddr + \"]\";\n+            String baseURLStr = \"https:\/\/\" + hostAddr + \":\" + address.getPort() + \"\/\";\n+\n+            URL testUrl = new URL(baseURLStr);\n+\n+            \/\/ CheckFinalizeSocketFactory is not a real SSLSocketFactory;\n+            \/\/ it produces regular non-SSL sockets. Effectively, the request\n+            \/\/ is made over http.\n+            HttpsURLConnection.setDefaultSSLSocketFactory(new CheckFinalizeSocketFactory());\n+            \/\/ now perform up to 3 requests; with the broken KeepAliveStream finalizer,\n+            \/\/ the second request usually attempts to use a finalized socket\n+            for (int i = 0; i < 3; i++) {\n+                System.err.println(\"Request #\" + (i + 1));\n+                doRequest(testUrl);\n+                System.gc();\n+                Thread.sleep(100);\n+                if (failureReason != null) break;\n+            }\n+        } finally {\n+            server.srv.close();\n+        }\n+    }\n+\n+    static class CheckFinalizeSocket extends SSLSocket {\n+        private volatile boolean finalized;\n+        public void finalize() throws Throwable {\n+            System.err.println(\"In finalize\");\n+            super.finalize();\n+            finalized = true;\n+        }\n+\n+        @Override\n+        public InputStream getInputStream() throws IOException {\n+            if (finalized) {\n+                System.err.println(failureReason = \"getInputStream called after finalize\");\n+                Thread.dumpStack();\n+            }\n+            return super.getInputStream();\n+        }\n+\n+        @Override\n+        public OutputStream getOutputStream() throws IOException {\n+            if (finalized) {\n+                System.err.println(failureReason = \"getOutputStream called after finalize\");\n+                Thread.dumpStack();\n+            }\n+            return super.getOutputStream();\n+        }\n+\n+        @Override\n+        public synchronized void close() throws IOException {\n+            if (finalized) {\n+                System.err.println(failureReason = \"close called after finalize\");\n+                Thread.dumpStack();\n+            }\n+            super.close();\n+        }\n+\n+        \/\/ required abstract method overrides\n+        @Override\n+        public String[] getSupportedCipherSuites() {\n+            return new String[0];\n+        }\n+        @Override\n+        public String[] getEnabledCipherSuites() {\n+            return new String[0];\n+        }\n+        @Override\n+        public void setEnabledCipherSuites(String[] suites) { }\n+        @Override\n+        public String[] getSupportedProtocols() {\n+            return new String[0];\n+        }\n+        @Override\n+        public String[] getEnabledProtocols() {\n+            return new String[0];\n+        }\n+        @Override\n+        public void setEnabledProtocols(String[] protocols) { }\n+        @Override\n+        public SSLSession getSession() {\n+            return null;\n+        }\n+        @Override\n+        public void addHandshakeCompletedListener(HandshakeCompletedListener listener) { }\n+        @Override\n+        public void removeHandshakeCompletedListener(HandshakeCompletedListener listener) { }\n+        @Override\n+        public void startHandshake() throws IOException { }\n+        @Override\n+        public void setUseClientMode(boolean mode) { }\n+        @Override\n+        public boolean getUseClientMode() {\n+            return false;\n+        }\n+        @Override\n+        public void setNeedClientAuth(boolean need) { }\n+        @Override\n+        public boolean getNeedClientAuth() {\n+            return false;\n+        }\n+        @Override\n+        public void setWantClientAuth(boolean want) { }\n+        @Override\n+        public boolean getWantClientAuth() {\n+            return false;\n+        }\n+        @Override\n+        public void setEnableSessionCreation(boolean flag) { }\n+        @Override\n+        public boolean getEnableSessionCreation() {\n+            return false;\n+        }\n+    }\n+\n+    static class CheckFinalizeSocketFactory extends SSLSocketFactory {\n+\n+        @Override\n+        public Socket createSocket() throws IOException {\n+            return new CheckFinalizeSocket();\n+        }\n+        \/\/ required abstract method overrides\n+        @Override\n+        public Socket createSocket(String host, int port) throws IOException, UnknownHostException {\n+            throw new UnsupportedOperationException();\n+        }\n+        @Override\n+        public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException, UnknownHostException {\n+            throw new UnsupportedOperationException();\n+        }\n+        @Override\n+        public Socket createSocket(InetAddress host, int port) throws IOException {\n+            throw new UnsupportedOperationException();\n+        }\n+        @Override\n+        public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {\n+            throw new UnsupportedOperationException();\n+        }\n+        @Override\n+        public String[] getDefaultCipherSuites() {\n+            return new String[0];\n+        }\n+        @Override\n+        public String[] getSupportedCipherSuites() {\n+            return new String[0];\n+        }\n+        @Override\n+        public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/sun\/net\/www\/http\/KeepAliveStream\/KeepAliveStreamFinalizer.java","additions":293,"deletions":0,"binary":false,"changes":293,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run main SpecTest\n+ * @run main\/othervm -Djava.security.egd=file:\/dev\/urandom SpecTest\n","filename":"test\/jdk\/sun\/security\/provider\/SecureRandom\/AbstractDrbg\/SpecTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run main\/othervm -Djava.security.egd=file:\/dev\/random SeedGeneratorChoice\n+ * @run main\/othervm -Djava.security.egd=file:\/dev\/urandom SeedGeneratorChoice\n","filename":"test\/jdk\/sun\/security\/provider\/SeedGenerator\/SeedGeneratorChoice.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1039,8 +1039,0 @@\n-            if (Platform.isWindows()) {\n-                cmd = new String[args.length + 3];\n-                System.arraycopy(args, 0, cmd, 3, args.length);\n-            } else {\n-                cmd = new String[args.length + 4];\n-                cmd[3] = \"-J-Djava.security.egd=file:\/dev\/.\/urandom\";\n-                System.arraycopy(args, 0, cmd, 4, args.length);\n-            }\n@@ -1048,0 +1040,2 @@\n+            cmd = new String[args.length + 3];\n+            System.arraycopy(args, 0, cmd, 3, args.length);\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/compatibility\/Compatibility.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import sun.security.x509.GeneralNameInterface;\n+import sun.security.x509.IPAddressName;\n+\n+import java.io.IOException;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+\/*\n+ * @test\n+ * @summary Verify IPAddressName.constrains\n+ * @bug 8267617\n+ * @modules java.base\/sun.security.x509\n+ * @run testng ConstrainsTest\n+ *\/\n+public class ConstrainsTest {\n+\n+    IPAddressName ipv4Addr = new IPAddressName(\"127.0.0.1\");\n+    IPAddressName ipv4Mask = new IPAddressName(\"127.0.0.0\/255.0.0.0\");\n+    IPAddressName ipv6Addr = new IPAddressName(\"::1\");\n+    IPAddressName ipv6Mask = new IPAddressName(\"::\/0\");\n+\n+    public ConstrainsTest() throws IOException {\n+    }\n+\n+    @DataProvider(name = \"names\")\n+    public Object[][] names() {\n+        Object[][] data = {\n+                {ipv4Addr, ipv4Addr, GeneralNameInterface.NAME_MATCH},\n+                {ipv4Addr, ipv4Mask, GeneralNameInterface.NAME_WIDENS},\n+                {ipv4Addr, ipv6Addr, GeneralNameInterface.NAME_SAME_TYPE},\n+                {ipv4Addr, ipv6Mask, GeneralNameInterface.NAME_SAME_TYPE},\n+                {ipv4Mask, ipv4Addr, GeneralNameInterface.NAME_NARROWS},\n+                {ipv4Mask, ipv4Mask, GeneralNameInterface.NAME_MATCH},\n+                {ipv4Mask, ipv6Addr, GeneralNameInterface.NAME_SAME_TYPE},\n+                {ipv4Mask, ipv6Mask, GeneralNameInterface.NAME_SAME_TYPE},\n+                {ipv6Addr, ipv4Addr, GeneralNameInterface.NAME_SAME_TYPE},\n+                {ipv6Addr, ipv4Mask, GeneralNameInterface.NAME_SAME_TYPE},\n+                {ipv6Addr, ipv6Addr, GeneralNameInterface.NAME_MATCH},\n+                {ipv6Addr, ipv6Mask, GeneralNameInterface.NAME_WIDENS},\n+                {ipv6Mask, ipv4Addr, GeneralNameInterface.NAME_SAME_TYPE},\n+                {ipv6Mask, ipv4Mask, GeneralNameInterface.NAME_SAME_TYPE},\n+                {ipv6Mask, ipv6Addr, GeneralNameInterface.NAME_NARROWS},\n+                {ipv6Mask, ipv6Mask, GeneralNameInterface.NAME_MATCH},\n+        };\n+        return data;\n+    }\n+\n+    @Test(dataProvider = \"names\")\n+    public void testNameContains(IPAddressName addr1, IPAddressName addr2, int result) throws IOException {\n+        assertEquals(addr1.constrains(addr2), result);\n+    }\n+\n+}\n","filename":"test\/jdk\/sun\/security\/x509\/IPAddressName\/ConstrainsTest.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -172,3 +172,3 @@\n-                iconSwap = executableRebranderClass.getDeclaredMethod(\"iconSwap\",\n-                        long.class, String.class);\n-                iconSwap.setAccessible(true);\n+                iconSwapWrapper = executableRebranderClass.getDeclaredMethod(\n+                        \"iconSwapWrapper\", long.class, String.class);\n+                iconSwapWrapper.setAccessible(true);\n@@ -183,0 +183,11 @@\n+            \/\/ Run .NET code to extract icon from the given executable.\n+            \/\/ ExtractAssociatedIcon() will succeed even if the target file\n+            \/\/ is locked (by an antivirus). It will output a default icon\n+            \/\/ in case of error. To prevent this \"fail safe\" behavior we try\n+            \/\/ lock the target file with Open() call. If the attempt\n+            \/\/ fails ExtractAssociatedIcon() is not called and the script exits\n+            \/\/ with the exit code that will be trapped\n+            \/\/ inside of Executor.executeAndRepeatUntilExitCode() method that\n+            \/\/ will keep running the script until it succeeds or the number of\n+            \/\/ allowed attempts is exceeded.\n+\n@@ -185,0 +196,3 @@\n+                    String.format(\n+                            \"try { [System.io.File]::Open('%s', 'Open', 'Read', 'None') } catch { exit 100 }\",\n+                            executable.toAbsolutePath().normalize()),\n@@ -192,1 +206,1 @@\n-                    script).execute();\n+                    script).executeAndRepeatUntilExitCode(0, 5, 10);\n@@ -233,1 +247,1 @@\n-                        iconSwap.invoke(null, new Object[]{lock,\n+                        iconSwapWrapper.invoke(null, new Object[]{lock,\n@@ -253,1 +267,1 @@\n-        private final Method iconSwap;\n+        private final Method iconSwapWrapper;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherIconVerifier.java","additions":20,"deletions":6,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n- * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=1440 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinL10nTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -18,1 +18,1 @@\n-requiredVersion=7.1+1\n+requiredVersion=7.1.1+1\n","filename":"test\/langtools\/TEST.ROOT","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @library \/test\/lib\n@@ -34,0 +35,2 @@\n+ * @build jtreg.SkippedException\n+ * @build jdk.test.lib.Platform\n@@ -69,0 +72,3 @@\n+import jdk.test.lib.Platform;\n+import jtreg.SkippedException;\n+\n@@ -75,0 +81,3 @@\n+        if (Platform.isSlowDebugBuild()) {\n+            throw new SkippedException(\"Test is unstable with slowdebug bits\");\n+        }\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testLinkOption\/TestRedirectLinks.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -426,1 +426,1 @@\n-                    <script type=\"text\/javascript\" src=\"script-dir\/jquery-3.6.0.min.js\"><\/script>\n+                    <script type=\"text\/javascript\" src=\"script-dir\/jquery-3.6.1.min.js\"><\/script>\n@@ -698,1 +698,1 @@\n-                \"script-dir\/jquery-3.6.0.min.js\",\n+                \"script-dir\/jquery-3.6.1.min.js\",\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSearch\/TestSearch.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -204,1 +204,1 @@\n-            \"script-dir\/jquery-3.6.0.min.js\",\n+            \"script-dir\/jquery-3.6.1.min.js\",\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/api\/basic\/APITest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @requires vm.continuations\n@@ -47,1 +48,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/langtools\/jdk\/jshell\/Test8296012.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8297602\n+ * @summary Compiler crash with type annotation and generic record during pattern matching\n+ * @enablePreview\n+ * @compile --enable-preview -source ${jdk.version} -XDrawDiagnostics T8297602.java\n+ *\/\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Target;\n+\n+public class T8297602\n+{\n+    void meth(Foo<Integer> p) {\n+        switch(p) {\n+            case Foo<@Annot(field = \"\") Integer>(): {}\n+        };\n+\n+        if (p instanceof Foo<@Annot(field = \"\") Integer>()) {\n+\n+        }\n+    }\n+\n+    @Target({ElementType.TYPE_USE})\n+    @interface Annot {\n+        String field();\n+    }\n+\n+    record Foo<T>() { }\n+}\n","filename":"test\/langtools\/tools\/javac\/T8297602.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -212,1 +212,1 @@\n-                                  0: #_A_(): LOCAL_VARIABLE, {start_pc=251, length=11, index=2}\n+                                  0: #_A_(): LOCAL_VARIABLE, {start_pc=316, length=11, index=2}\n@@ -214,1 +214,1 @@\n-                                  1: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=290, length=11, index=3}\n+                                  1: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=359, length=11, index=3}\n@@ -218,1 +218,1 @@\n-                                  2: #_A_(): LOCAL_VARIABLE, {start_pc=26, length=11, index=1}\n+                                  2: #_A_(): LOCAL_VARIABLE, {start_pc=30, length=11, index=1}\n@@ -220,1 +220,1 @@\n-                                  3: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=63, length=11, index=1}\n+                                  3: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=71, length=11, index=1}\n@@ -224,1 +224,1 @@\n-                                  4: #_A_(): LOCAL_VARIABLE, {start_pc=101, length=11, index=2}\n+                                  4: #_A_(): LOCAL_VARIABLE, {start_pc=114, length=11, index=2}\n@@ -226,1 +226,1 @@\n-                                  5: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=140, length=11, index=3}\n+                                  5: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=157, length=11, index=3}\n@@ -230,1 +230,1 @@\n-                                  6: #_A_(): LOCAL_VARIABLE, {start_pc=176, length=11, index=2}\n+                                  6: #_A_(): LOCAL_VARIABLE, {start_pc=215, length=11, index=2}\n@@ -232,1 +232,1 @@\n-                                  7: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=215, length=11, index=3}\n+                                  7: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=258, length=11, index=3}\n@@ -241,1 +241,1 @@\n-                                  0: #_A_(): LOCAL_VARIABLE, {start_pc=23, length=11, index=2}\n+                                  0: #_A_(): LOCAL_VARIABLE, {start_pc=28, length=11, index=2}\n@@ -243,1 +243,1 @@\n-                                  1: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=62, length=11, index=3}\n+                                  1: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=71, length=11, index=3}\n@@ -248,4 +248,0 @@\n-                            private static java.lang.String $proxy$s(Patterns$DeconstructionPattern$R);\n-                              descriptor: (LPatterns$DeconstructionPattern$R;)Ljava\/lang\/String;\n-                              flags: (0x100a) ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC\n-\n@@ -256,1 +252,1 @@\n-                                  0: #_A_(): LOCAL_VARIABLE, {start_pc=26, length=11, index=0}\n+                                  0: #_A_(): LOCAL_VARIABLE, {start_pc=28, length=11, index=0}\n@@ -258,1 +254,1 @@\n-                                  1: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=62, length=11, index=0}\n+                                  1: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=66, length=11, index=0}\n@@ -262,1 +258,1 @@\n-                                  2: #_A_(): LOCAL_VARIABLE, {start_pc=98, length=11, index=1}\n+                                  2: #_A_(): LOCAL_VARIABLE, {start_pc=106, length=11, index=1}\n@@ -264,1 +260,1 @@\n-                                  3: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=134, length=11, index=2}\n+                                  3: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=147, length=11, index=2}\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/classfile\/Patterns.java","additions":14,"deletions":18,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- *                                      RELEASE_18 RELEASE_19 RELEASE_20\n+ *                                      RELEASE_18 RELEASE_19 RELEASE_20 RELEASE_21\n","filename":"test\/langtools\/tools\/javac\/api\/TestGetSourceVersions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,2 @@\n-        TWENTY(\"20\", 64);\n+        TWENTY(\"20\", 64),\n+        TWENTY_ONE(\"21\", 65);\n","filename":"test\/langtools\/tools\/javac\/classfiles\/ClassVersionChecker.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-    @SupportedSourceVersion(RELEASE_20)\n+    @SupportedSourceVersion(RELEASE_21)\n@@ -126,1 +126,1 @@\n-    @SupportedSourceVersion(RELEASE_20)\n+    @SupportedSourceVersion(RELEASE_21)\n@@ -136,1 +136,1 @@\n-    @SupportedSourceVersion(RELEASE_20)\n+    @SupportedSourceVersion(RELEASE_21)\n@@ -146,1 +146,1 @@\n-    @SupportedSourceVersion(RELEASE_20)\n+    @SupportedSourceVersion(RELEASE_21)\n@@ -167,1 +167,1 @@\n-    @SupportedSourceVersion(RELEASE_20)\n+    @SupportedSourceVersion(RELEASE_21)\n@@ -186,1 +186,1 @@\n-    @SupportedSourceVersion(RELEASE_20)\n+    @SupportedSourceVersion(RELEASE_21)\n@@ -207,1 +207,1 @@\n-    @SupportedSourceVersion(RELEASE_20)\n+    @SupportedSourceVersion(RELEASE_21)\n@@ -228,1 +228,1 @@\n-    @SupportedSourceVersion(RELEASE_20)\n+    @SupportedSourceVersion(RELEASE_21)\n@@ -249,1 +249,1 @@\n-    @SupportedSourceVersion(RELEASE_20)\n+    @SupportedSourceVersion(RELEASE_21)\n","filename":"test\/langtools\/tools\/javac\/lib\/JavacTestingAbstractProcessor.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8291769\n+ * @summary Verify more complex switches work properly\n+ * @compile --enable-preview -source ${jdk.version} DeconstructionDesugaring.java\n+ * @run main\/othervm --enable-preview DeconstructionDesugaring\n+ *\/\n+\n+import java.util.function.ToIntFunction;\n+public class DeconstructionDesugaring {\n+\n+    public static void main(String... args) throws Throwable {\n+        new DeconstructionDesugaring().test();\n+    }\n+\n+    private void test() {\n+        test(this::runCheckStatement);\n+        test(this::runCheckExpression);\n+        assertEquals(runCheckExpressionWithUnconditional(new R5(new R4(new Sub3()))), 3);\n+        assertEquals(runCheckExpressionWithUnconditional(new R5(new R4(null))), 3);\n+        assertEquals(runCheckExpressionWithUnconditional1(new R5(new R4(null))), 2);\n+        assertEquals(runCheckExpressionWithUnconditional1(new R5(null)), 3);\n+    }\n+\n+    private void test(ToIntFunction<Object> task) {\n+        assertEquals(1, task.applyAsInt(new R1(new R2(\"\"))));\n+        assertEquals(2, task.applyAsInt(new R1(new R2(1))));\n+        assertEquals(3, task.applyAsInt(new R1(new R2(1.0))));\n+        assertEquals(-1, task.applyAsInt(new R1(new R2(null))));\n+        assertEquals(4, task.applyAsInt(new R1(new R2(new StringBuilder()))));\n+        assertEquals(5, task.applyAsInt(new R1(new R3(\"\"))));\n+        assertEquals(6, task.applyAsInt(new R1(new R3(1))));\n+        assertEquals(7, task.applyAsInt(new R1(new R3(1.0))));\n+        assertEquals(8, task.applyAsInt(new R1(new R3(new StringBuilder()))));\n+        assertEquals(-1, task.applyAsInt(new R1(1.0f)));\n+        assertEquals(-1, task.applyAsInt(\"foo\"));\n+    }\n+\n+    private int runCheckStatement(Object o) {\n+        switch (o) {\n+            case (((R1((((R2((((String s))))))))))) -> { return 1; }\n+            case R1(R2(Integer i)) -> { return 2; }\n+            case R1(R2(Double d)) -> { return 3; }\n+            case R1(R2(CharSequence cs)) -> { return 4; }\n+            case R1(R3(String s)) -> { return 5; }\n+            case R1(R3(Integer i)) -> { return 6; }\n+            case R1(R3(Double f)) -> { return 7; }\n+            case R1(R3(CharSequence cs)) -> { return 8; }\n+            default -> { return -1; }\n+        }\n+    }\n+\n+    private int runCheckExpression(Object o) {\n+        return switch (o) {\n+            case (((R1((((R2((((String s))))))))))) -> 1;\n+            case R1(R2(Integer i)) -> 2;\n+            case R1(R2(Double d)) -> 3;\n+            case R1(R2(CharSequence cs)) -> 4;\n+            case R1(R3(String s)) -> 5;\n+            case R1(R3(Integer i)) -> 6;\n+            case R1(R3(Double f)) -> 7;\n+            case R1(R3(CharSequence cs)) -> 8;\n+            default -> -1;\n+        };\n+    }\n+\n+    private int runCheckExpressionWithUnconditional(R5 o) {\n+        return switch (o) {\n+            case R5(R4(Sub1 s)) -> 1;\n+            case R5(R4(Sub2 s)) -> 2;\n+            case R5(R4(Super s)) -> 3;\n+        };\n+    }\n+\n+    private int runCheckExpressionWithUnconditional1(R5 o) {\n+        return switch (o) {\n+            case R5(R4(Sub1 s)) -> 1;\n+            case R5(R4(Super s)) -> 2;\n+            case R5(Object obj) -> 3;\n+        };\n+    }\n+\n+    private void assertEquals(int expected, int actual) {\n+        if (expected != actual) {\n+            throw new AssertionError(\"expected: \" + expected + \", \" +\n+                                     \"actual: \" + actual);\n+        }\n+    }\n+\n+    record R1(Object o) {}\n+    record R2(Object o) {}\n+    record R3(Object o) {}\n+\n+    sealed class Super permits Sub1, Sub2, Sub3 {}\n+    final class Sub1 extends Super {}\n+    final class Sub2 extends Super {}\n+    final class Sub3 extends Super {}\n+\n+    record R4(Super o) {}\n+    record R5(R4 o) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/DeconstructionDesugaring.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8298184\n@@ -27,0 +28,2 @@\n+ * @compile GenericRecordDeconstructionPattern.java\n+ * @run main GenericRecordDeconstructionPattern\n@@ -49,0 +52,2 @@\n+        assertEquals(1, runIfSuperBound(new Box<>(new StringBuilder())));\n+        assertEquals(1, runIfSuperBound(new Box<>(0)));\n@@ -123,0 +128,5 @@\n+    int runIfSuperBound(I<? super String> b) {\n+        if (b instanceof Box(var v)) return 1;\n+        return -1;\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/GenericRecordDeconstructionPattern.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+        assertEquals(\"box with non-empty\", convert.apply(new Box(\"a\")));\n@@ -73,0 +74,1 @@\n+            case Box(String s) : return \"box with non-empty\";\n@@ -83,0 +85,1 @@\n+            case Box(String s) -> \"box with non-empty\";\n@@ -94,0 +97,1 @@\n+            case Box(String s) -> {x = \"box with non-empty\"; yield true; }\n","filename":"test\/langtools\/tools\/javac\/patterns\/Guards.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,201 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8291769\n+ * @summary Verify the compiled code does not have unwanted constructs.\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ *          jdk.jdeps\/com.sun.tools.javap\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main PatternDesugaring\n+*\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+import toolbox.TestRunner;\n+import toolbox.JavacTask;\n+import toolbox.JavapTask;\n+import toolbox.Task;\n+import toolbox.ToolBox;\n+\n+public class PatternDesugaring extends TestRunner {\n+\n+    private static final String JAVA_VERSION = System.getProperty(\"java.specification.version\");\n+\n+    ToolBox tb;\n+\n+    public static void main(String... args) throws Exception {\n+        new PatternDesugaring().runTests();\n+    }\n+\n+    PatternDesugaring() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testPrimitiveNoBoxUnbox(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   public int test(Object obj) {\n+                       return switch (obj) {\n+                           case R(int i) -> i;\n+                           default -> -1;\n+                       };\n+                   }\n+                   record R(int i) {}\n+               }\n+               \"\"\",\n+               decompiled -> {\n+                   if (decompiled.contains(\"intValue\") || decompiled.contains(\"valueOf\")) {\n+                       throw new AssertionError(\"Has boxing\/unboxing.\");\n+                   }\n+               });\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   public int test(Object obj) {\n+                       return obj instanceof R(int i) ? i : -1;\n+                   }\n+                   record R(int i) {}\n+               }\n+               \"\"\",\n+               decompiled -> {\n+                   if (decompiled.contains(\"intValue\") || decompiled.contains(\"valueOf\")) {\n+                       throw new AssertionError(\"Has boxing\/unboxing.\");\n+                   }\n+               });\n+    }\n+\n+    @Test\n+    public void testCacheRecordsForRecordPatterns(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   public int test(Object obj) {\n+                       return switch (obj) {\n+                           case R(Integer i, Integer j, Integer k) -> i + j + k;\n+                           default -> -1;\n+                       };\n+                   }\n+                   record R(Integer i, Integer j, Integer k) {}\n+               }\n+               \"\"\",\n+               decompiled -> {\n+                   if (decompiled.split(\"checkcast\").length != 2) {\n+                       throw new AssertionError(\"Unexpected number of checkcasts.\");\n+                   }\n+               });\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   public int test(Object obj) {\n+                       return obj instanceof R(Integer i, Integer j, Integer k) ? i + j + k: -1;\n+                   }\n+                   record R(Integer i, Integer j, Integer k) {}\n+               }\n+               \"\"\",\n+               decompiled -> {\n+                   if (decompiled.split(\"checkcast\").length != 2) {\n+                       throw new AssertionError(\"Unexpected number of checkcasts.\");\n+                   }\n+               });\n+    }\n+\n+    private void doTest(Path base, String[] libraryCode, String testCode, Consumer<String> validate) throws IOException {\n+        Path current = base.resolve(\".\");\n+        Path libClasses = current.resolve(\"libClasses\");\n+\n+        Files.createDirectories(libClasses);\n+\n+        if (libraryCode.length != 0) {\n+            Path libSrc = current.resolve(\"lib-src\");\n+\n+            for (String code : libraryCode) {\n+                tb.writeJavaFiles(libSrc, code);\n+            }\n+\n+            new JavacTask(tb)\n+                    .options(\"--enable-preview\",\n+                             \"-source\", JAVA_VERSION)\n+                    .outdir(libClasses)\n+                    .files(tb.findJavaFiles(libSrc))\n+                    .run();\n+        }\n+\n+        Path src = current.resolve(\"src\");\n+        tb.writeJavaFiles(src, testCode);\n+\n+        Path classes = current.resolve(\"libClasses\");\n+\n+        Files.createDirectories(libClasses);\n+\n+        var log =\n+                new JavacTask(tb)\n+                    .options(\"--enable-preview\",\n+                             \"-source\", JAVA_VERSION,\n+                             \"-XDrawDiagnostics\",\n+                             \"-Xlint:-preview\",\n+                             \"--class-path\", libClasses.toString(),\n+                             \"-XDshould-stop.at=FLOW\")\n+                    .outdir(classes)\n+                    .files(tb.findJavaFiles(src))\n+                    .run(Task.Expect.SUCCESS)\n+                    .writeAll();\n+        var decompiled =\n+                new JavapTask(tb)\n+                    .classpath(classes.toString())\n+                    .classes(\"test.Test\")\n+                    .options(\"-s\", \"-verbose\")\n+                    .run()\n+                    .writeAll()\n+                    .getOutput(Task.OutputKind.DIRECT);\n+\n+        System.err.println(\"decompiled: \" + decompiled);\n+\n+        validate.accept(decompiled);\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/PatternDesugaring.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"},{"patch":"@@ -95,0 +95,4 @@\n+        assertEquals(\"a\", translationTest(\"a\"));\n+        assertEquals(\"Rb\", translationTest(new R(\"b\")));\n+        assertEquals(\"R2c\", translationTest(new R2(\"c\")));\n+        assertEquals(\"other\", translationTest(0));\n@@ -102,0 +106,2 @@\n+        testSimpleSwitch();\n+        testSimpleSwitchExpression();\n@@ -639,0 +645,9 @@\n+    String translationTest(Object o) {\n+        return switch (o) {\n+            case R(String s) -> \"R\" + s;\n+            case String s -> s;\n+            case R2(String s) -> \"R2\" + s;\n+            default -> \"other\";\n+        };\n+    }\n+\n@@ -662,0 +677,17 @@\n+    void testSimpleSwitch() {\n+        Object o = \"\";\n+        int res;\n+        switch (o) {\n+            default -> res = 1;\n+        };\n+        assertEquals(1, res);\n+    }\n+\n+    void testSimpleSwitchExpression() {\n+        Object o = \"\";\n+        int res = switch (o) {\n+            default -> 1;\n+        };\n+        assertEquals(1, res);\n+    }\n+\n@@ -703,0 +735,1 @@\n+    record R2(Object o) {}\n","filename":"test\/langtools\/tools\/javac\/patterns\/Switches.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,331 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8291769\n+ * @summary Check expected translation of various pattern related constructs\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.comp\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.tree\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main TranslationTest\n+*\/\n+\n+import com.sun.tools.javac.api.JavacTaskImpl;\n+import com.sun.tools.javac.comp.AttrContext;\n+import com.sun.tools.javac.comp.Env;\n+import com.sun.tools.javac.comp.TransPatterns;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.JCTree.JCCase;\n+import com.sun.tools.javac.tree.JCTree.JCSwitch;\n+import com.sun.tools.javac.tree.JCTree.JCSwitchExpression;\n+import com.sun.tools.javac.tree.JCTree.Tag;\n+import com.sun.tools.javac.tree.TreeMaker;\n+import com.sun.tools.javac.tree.TreeScanner;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.Context.Factory;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import toolbox.TestRunner;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.ToolBox;\n+\n+public class TranslationTest extends TestRunner {\n+\n+    private static final String JAVA_VERSION = System.getProperty(\"java.specification.version\");\n+\n+    ToolBox tb;\n+\n+    public static void main(String... args) throws Exception {\n+        new TranslationTest().runTests();\n+    }\n+\n+    TranslationTest() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testSimple(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public record Box(Object o) {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(Object obj) {\n+                       return switch (obj) {\n+                           case Box(String s) -> 0;\n+                           case Box(Integer i) -> 0;\n+                           case Box(Number n) -> 0;\n+                           case Box(CharSequence cs) -> 0;\n+\n+                           default -> -1;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               toplevel -> printSwitchStructure(toplevel),\n+               \"\"\"\n+               switch\n+                   case\n+                       switch\n+                           case\n+                           case\n+                           case\n+                           case\n+                           case ..., default\n+                   default\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testMultiComponent(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public record Pair(Object o1, Object o2) {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public record Triplet(Object o1, Object o2, Object o3) {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(Object obj) {\n+                       return switch (obj) {\n+                           case Pair(String c1, Pair(String o2, String s2)) -> 0;\n+                           case Pair(String c1, Pair(String o2, Integer s2)) -> 0;\n+                           case Pair(String c1, Pair(Integer o2, String s2)) -> 0;\n+                           case Pair(String c1, Pair(Integer o2, Integer s2)) -> 0;\n+\n+                           case Pair(Integer c1, Pair(String o2, String s2)) -> 0;\n+                           case Pair(Integer c1, Pair(String o2, Integer s2)) -> 0;\n+                           case Pair(Integer c1, Pair(Integer o2, String s2)) -> 0;\n+                           case Pair(Integer c1, Pair(Integer o2, Integer s2)) -> 0;\n+\n+                           default -> -1;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               toplevel -> printSwitchStructure(toplevel),\n+               \"\"\"\n+               switch\n+                   case\n+                       switch\n+                           case\n+                               switch\n+                                   case\n+                                       switch\n+                                           case\n+                                               switch\n+                                                   case\n+                                                   case\n+                                                   case ..., default\n+                                           case\n+                                               switch\n+                                                   case\n+                                                   case\n+                                                   case ..., default\n+                                           case ..., default\n+                                   case ..., default\n+                           case\n+                               switch\n+                                   case\n+                                       switch\n+                                           case\n+                                               switch\n+                                                   case\n+                                                   case\n+                                                   case ..., default\n+                                           case\n+                                               switch\n+                                                   case\n+                                                   case\n+                                                   case ..., default\n+                                           case ..., default\n+                                   case ..., default\n+                           case ..., default\n+                   default\n+               \"\"\");\n+    }\n+\n+    private void doTest(Path base, String[] libraryCode, String testCode,\n+                        Callback callback, String expectedOutput) throws IOException {\n+        Path current = base.resolve(\".\");\n+        Path libClasses = current.resolve(\"libClasses\");\n+\n+        Files.createDirectories(libClasses);\n+\n+        if (libraryCode.length != 0) {\n+            Path libSrc = current.resolve(\"lib-src\");\n+\n+            for (String code : libraryCode) {\n+                tb.writeJavaFiles(libSrc, code);\n+            }\n+\n+            new JavacTask(tb)\n+                    .options(\"--enable-preview\",\n+                             \"-source\", JAVA_VERSION)\n+                    .outdir(libClasses)\n+                    .files(tb.findJavaFiles(libSrc))\n+                    .run();\n+        }\n+\n+        Path src = current.resolve(\"src\");\n+        tb.writeJavaFiles(src, testCode);\n+\n+        Path classes = current.resolve(\"libClasses\");\n+\n+        Files.createDirectories(libClasses);\n+\n+        List<String> output = new ArrayList<>();\n+\n+        new JavacTask(tb)\n+            .options(\"--enable-preview\",\n+                     \"-source\", JAVA_VERSION,\n+                     \"-Xlint:-preview\",\n+                     \"--class-path\", libClasses.toString(),\n+                     \"-XDshould-stop.at=FLOW\")\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .callback(task -> {\n+                 Context ctx = ((JavacTaskImpl) task).getContext();\n+\n+                 TestTransPatterns.preRegister(ctx, callback, output);\n+             })\n+            .run()\n+            .writeAll()\n+            .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        if (output.size() != 1 || !expectedOutput.equals(output.get(0))) {\n+            throw new AssertionError(\"Unexpected output:\\n\" + output);\n+        }\n+    }\n+\n+    private String printSwitchStructure(JCTree topLevel) {\n+        StringBuilder structure = new StringBuilder();\n+\n+        new TreeScanner() {\n+            private static final int INDENT = 4;\n+            private int indent = 0;\n+            @Override\n+            public void visitSwitch(JCSwitch node) {\n+                int prevIndent = indent;\n+                appendLine(\"switch\");\n+                try {\n+                    indent += INDENT;\n+                    super.visitSwitch(node);\n+                } finally {\n+                    indent = prevIndent;\n+                }\n+            }\n+\n+            @Override\n+            public void visitSwitchExpression(JCSwitchExpression node) {\n+                int prevIndent = indent;\n+                appendLine(\"switch\");\n+                try {\n+                    indent += INDENT;\n+                    super.visitSwitchExpression(node);\n+                } finally {\n+                    indent = prevIndent;\n+                }\n+            }\n+            @Override\n+            public void visitCase(JCCase node) {\n+                int prevIndent = indent;\n+                if (node.labels.size() == 1 && node.labels.head.hasTag(Tag.DEFAULTCASELABEL)) {\n+                    appendLine(\"default\");\n+                } else if (node.labels.stream().anyMatch(l -> l.hasTag(Tag.DEFAULTCASELABEL))) {\n+                    appendLine(\"case ..., default\");\n+                } else {\n+                    appendLine(\"case\");\n+                }\n+                try {\n+                    indent += INDENT;\n+                    super.visitCase(node);\n+                } finally {\n+                    indent = prevIndent;\n+                }\n+            }\n+            private void appendLine(String what) {\n+                for (int i = 0; i < indent; i++) {\n+                    structure.append(' ');\n+                }\n+                structure.append(what);\n+                structure.append('\\n');\n+            }\n+        }.scan(topLevel);\n+\n+        return structure.toString();\n+    }\n+\n+    public interface Callback {\n+        public String patternsTranslated(JCTree topLevel);\n+    }\n+\n+    private static final class TestTransPatterns extends TransPatterns {\n+\n+        public static void preRegister(Context ctx, Callback validator, List<String> output) {\n+            ctx.put(transPatternsKey, (Factory<TransPatterns>) c -> new TestTransPatterns(c, validator, output));\n+        }\n+\n+        private final Callback callback;\n+        private final List<String> output;\n+\n+        public TestTransPatterns(Context context, Callback callback, List<String> output) {\n+            super(context);\n+            this.callback = callback;\n+            this.output = output;\n+        }\n+\n+        @Override\n+        public JCTree translateTopLevelClass(Env<AttrContext> env, JCTree cdef, TreeMaker make) {\n+            JCTree result = super.translateTopLevelClass(env, cdef, make);\n+            output.add(callback.patternsTranslated(cdef));\n+            return result;\n+        }\n+\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/TranslationTest.java","additions":331,"deletions":0,"binary":false,"changes":331,"status":"added"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.function.ToIntFunction;\n@@ -41,0 +42,3 @@\n+        testTryExpr();\n+        run(this::testLambda);\n+        runBoxed();\n@@ -85,0 +89,76 @@\n+    void testTryExpr() {\n+        TEST: {\n+            try {\n+                var v = switch ((Pair<String, Integer>) (Object) new Pair<Integer, Integer>(1, 1)) {\n+                    case Pair<String, Integer>(String s, Integer i) -> s.length() + i;\n+                    case Object o -> -1;\n+                };\n+            } catch (ClassCastException ex) {\n+                \/\/OK\n+                break TEST;\n+            } catch (Throwable t) {\n+                t.printStackTrace();\n+                fail(\"Unexpected Throwable!\");\n+            }\n+            fail(\"ClassCastException not thrown!\");\n+        }\n+        TEST: {\n+            try {\n+                var v = switch (new Pair<String, Integer>(\"fail\", 1)) {\n+                    case Pair<String, Integer>(String s, Integer i) -> s.length() + i;\n+                    case Object o -> -1;\n+                };\n+            } catch (MatchException ex) {\n+                \/\/OK\n+                break TEST;\n+            } catch (Throwable t) {\n+                t.printStackTrace();\n+                fail(\"Unexpected Throwable!\");\n+            }\n+            fail(\"MatchException not thrown!\");\n+        }\n+    }\n+\n+    int testLambda(Pair<String, Integer> p) {\n+        var r = prepareLambda();\n+        return r.applyAsInt(p);\n+    }\n+\n+    ToIntFunction<Pair<String, Integer>> prepareLambda() {\n+        return p -> switch (p) {\n+            case Pair<String, Integer>(String s, Integer i) -> s.length() + i;\n+            case Object o -> -1;\n+        };\n+    }\n+\n+    void runBoxed() {\n+        assertEquals(2, testBoxed(new Box(new Pair<>(\"1\", 1))));\n+        try {\n+            testBoxed(new Box((Pair<String, Integer>) (Object) new Pair<Integer, Integer>(1, 1)));\n+            fail(\"Expected an exception, but none happened!\");\n+        } catch (ClassCastException ex) {\n+            System.err.println(\"expected exception:\");\n+            ex.printStackTrace();\n+        }\n+        try {\n+            testBoxed(new Box(new Pair<String, Integer>(\"fail\", 1)));\n+            fail(\"Expected an exception, but none happened!\");\n+        } catch (MatchException ex) {\n+            assertEquals(TestPatternFailed.class.getName() + \": \" + EXCEPTION_MESSAGE,\n+                         ex.getMessage());\n+            if (ex.getCause() instanceof TestPatternFailed ex2) {\n+                System.err.println(\"expected exception:\");\n+                ex2.printStackTrace();\n+            } else {\n+                fail(\"Not the correct exception.\");\n+            }\n+        }\n+    }\n+\n+    int testBoxed(Object p) {\n+        return switch (p) {\n+            case Box(Pair<String, Integer>(String s, Integer i)) -> s.length() + i;\n+            case Object o -> -1;\n+        };\n+    }\n+\n@@ -99,0 +179,2 @@\n+    record Box(Pair<String, Integer> boxed) {}\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/TypedDeconstructionPatternExc.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-- compiler.err.preview.feature.disabled.classfile: Bar.class, 20\n+- compiler.err.preview.feature.disabled.classfile: Bar.class, 21\n","filename":"test\/langtools\/tools\/javac\/preview\/classReaderTest\/Client.nopreview.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-- compiler.warn.preview.feature.use.classfile: Bar.class, 20\n+- compiler.warn.preview.feature.use.classfile: Bar.class, 21\n","filename":"test\/langtools\/tools\/javac\/preview\/classReaderTest\/Client.preview.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8295184\n+ * @summary Printing messages with a RecordComponentElement does not include position\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ * @compile TestWarning.java\n+ * @compile ReproducingAP.java\n+ * @run main RecordComponentSourcePositionTest\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import toolbox.JavacTask;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+import toolbox.Task;\n+\n+public class RecordComponentSourcePositionTest extends TestRunner {\n+\n+    ToolBox tb;\n+\n+    public RecordComponentSourcePositionTest() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        RecordComponentSourcePositionTest t = new RecordComponentSourcePositionTest();\n+        t.runTests();\n+    }\n+\n+    @Test\n+    public void testRecordComponentPositionInDiagnostics() throws Exception {\n+        String code = \"\"\"\n+                      @TestWarning(includeAnnotation = true)\n+                      public record Test(\n+                              @TestWarning(includeAnnotation = true) int first,\n+                              @TestWarning int second) {\n+                      }\n+\n+                      @TestWarning\n+                      record Test2() {}\n+                      \"\"\";\n+\n+        Path curPath = Path.of(\".\");\n+\n+        List<String> output = new JavacTask(tb)\n+                .sources(code)\n+                .outdir(curPath)\n+                .options(\"-XDrawDiagnostics\", \"-processor\", \"ReproducingAP\")\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        List<String> expected = Arrays.asList(\n+                \"Test.java:1:1: compiler.warn.proc.messager: Reporting Test with an annotation\",\n+                \"Test.java:3:9: compiler.warn.proc.messager: Reporting first with an annotation\",\n+                \"Test.java:4:26: compiler.warn.proc.messager: Reporting second\",\n+                \"Test.java:8:1: compiler.warn.proc.messager: Reporting Test2\",\n+                \"4 warnings\");\n+        tb.checkEqual(expected, output);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/records\/recordComponent\/8295184\/RecordComponentSourcePositionTest.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.Set;\n+\n+import javax.annotation.processing.AbstractProcessor;\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.annotation.processing.SupportedSourceVersion;\n+import javax.lang.model.SourceVersion;\n+import javax.lang.model.element.TypeElement;\n+\n+public class ReproducingAP extends AbstractProcessor {\n+\n+    @Override\n+    public Set<String> getSupportedAnnotationTypes() {\n+        return Set.of(TestWarning.class.getName());\n+    }\n+\n+    @Override\n+    public SourceVersion getSupportedSourceVersion() {\n+        return SourceVersion.latest();\n+    }\n+\n+    @Override\n+    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+        roundEnv.getElementsAnnotatedWith(TestWarning.class).forEach(e -> {\n+            var annotation = e.getAnnotation(TestWarning.class);\n+            if (annotation.includeAnnotation()) {\n+                processingEnv.getMessager().printMessage(\n+                        javax.tools.Diagnostic.Kind.WARNING,\n+                        \"Reporting \" + e.getSimpleName() + \" with an annotation\",\n+                        e,\n+                        e.getAnnotationMirrors().get(0));\n+            } else {\n+                processingEnv.getMessager().printMessage(\n+                        javax.tools.Diagnostic.Kind.WARNING,\n+                        \"Reporting \" + e.getSimpleName(),\n+                        e);\n+            }\n+        });\n+        return false;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/records\/recordComponent\/8295184\/ReproducingAP.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Target;\n+\n+\/**\n+ * Direct {@link ReproducingAP} to emit a warning.\n+ *\/\n+@Target({ElementType.TYPE, ElementType.RECORD_COMPONENT})\n+public @interface TestWarning {\n+    \/**\n+     * {@return {@code true} to include the relevant mirror in the warning message}\n+     *\/\n+    boolean includeAnnotation() default false;\n+}\n","filename":"test\/langtools\/tools\/javac\/records\/recordComponent\/8295184\/TestWarning.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8297974\n+ * @summary Verify error recovery w.r.t. lambdas\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.jdeps\/com.sun.tools.classfile\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main LambdaRecovery\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import toolbox.JavacTask;\n+import toolbox.Task.Expect;\n+import toolbox.Task.OutputKind;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+\n+public class LambdaRecovery extends TestRunner {\n+\n+    ToolBox tb;\n+\n+    public LambdaRecovery() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        LambdaRecovery t = new LambdaRecovery();\n+        t.runTests();\n+    }\n+\n+    @Test\n+    public void testRecoveryExpressionLambda() throws Exception {\n+        String code = \"\"\"\n+                      class Test {\n+                          interface I {\n+                              int convert(int i);\n+                          }\n+                          interface O {\n+                              Object convert(Object o);\n+                          }\n+                          void t1(I f, String e) {\n+                              t1(param -> param);\n+                              t1(param -> voidMethod(param));\n+                          }\n+                          void t2(O f, String e) {\n+                              t2(param -> param);\n+                              t2(param -> voidMethod(param));\n+                          }\n+                          void voidMethod(Object o) {}\n+                      }\n+                      \"\"\";\n+        Path curPath = Path.of(\".\");\n+        List<String> actual = new JavacTask(tb)\n+                .options(\"-XDrawDiagnostics\", \"-XDdev\")\n+                .sources(code)\n+                .outdir(curPath)\n+                .run(Expect.FAIL)\n+                .getOutputLines(OutputKind.DIRECT);\n+\n+        List<String> expected = List.of(\n+                \"Test.java:9:9: compiler.err.cant.apply.symbol: kindname.method, t1, Test.I,java.lang.String, @12, kindname.class, Test, (compiler.misc.arg.length.mismatch)\",\n+                \"Test.java:10:9: compiler.err.cant.apply.symbol: kindname.method, t1, Test.I,java.lang.String, @12, kindname.class, Test, (compiler.misc.arg.length.mismatch)\",\n+                \"Test.java:10:11: compiler.err.cant.apply.symbol: kindname.method, t1, Test.I,java.lang.String, @12,<any>, kindname.class, Test, (compiler.misc.no.conforming.assignment.exists: (compiler.misc.incompatible.ret.type.in.lambda: (compiler.misc.inconvertible.types: void, int)))\",\n+                \"Test.java:13:9: compiler.err.cant.apply.symbol: kindname.method, t2, Test.O,java.lang.String, @12, kindname.class, Test, (compiler.misc.arg.length.mismatch)\",\n+                \"Test.java:14:9: compiler.err.cant.apply.symbol: kindname.method, t2, Test.O,java.lang.String, @12, kindname.class, Test, (compiler.misc.arg.length.mismatch)\",\n+                \"Test.java:14:11: compiler.err.cant.apply.symbol: kindname.method, t2, Test.O,java.lang.String, @12,<any>, kindname.class, Test, (compiler.misc.no.conforming.assignment.exists: (compiler.misc.incompatible.ret.type.in.lambda: (compiler.misc.inconvertible.types: void, java.lang.Object)))\",\n+                \"6 errors\"\n+        );\n+\n+        if (!Objects.equals(actual, expected)) {\n+            error(\"Expected: \" + expected + \", but got: \" + actual);\n+        }\n+\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/recovery\/LambdaRecovery.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -74,1 +74,1 @@\n-               \"15\", \"16\", \"17\", \"18\", \"19\", \"20\");\n+               \"15\", \"16\", \"17\", \"18\", \"19\", \"20\", \"21\");\n@@ -76,1 +76,1 @@\n-    public static final String LATEST_MAJOR_VERSION = \"64.0\";\n+    public static final String LATEST_MAJOR_VERSION = \"65.0\";\n@@ -79,9 +79,9 @@\n-        EIGHT(true,   \"52.0\",  \"8\", Versions::checksrc8),\n-        NINE(true,    \"53.0\",  \"9\", Versions::checksrc9),\n-        TEN(true,     \"54.0\", \"10\", Versions::checksrc10),\n-        ELEVEN(false, \"55.0\", \"11\", Versions::checksrc11),\n-        TWELVE(false, \"56.0\", \"12\", Versions::checksrc12),\n-        THIRTEEN(false, \"57.0\", \"13\", Versions::checksrc13),\n-        FOURTEEN(false, \"58.0\", \"14\", Versions::checksrc14),\n-        FIFTEEN(false,  \"59.0\", \"15\", Versions::checksrc15),\n-        SIXTEEN(false,  \"60.0\", \"16\", Versions::checksrc16),\n+        EIGHT(true,      \"52.0\",  \"8\", Versions::checksrc8),\n+        NINE(true,       \"53.0\",  \"9\", Versions::checksrc9),\n+        TEN(true,        \"54.0\", \"10\", Versions::checksrc10),\n+        ELEVEN(false,    \"55.0\", \"11\", Versions::checksrc11),\n+        TWELVE(false,    \"56.0\", \"12\", Versions::checksrc12),\n+        THIRTEEN(false,  \"57.0\", \"13\", Versions::checksrc13),\n+        FOURTEEN(false,  \"58.0\", \"14\", Versions::checksrc14),\n+        FIFTEEN(false,   \"59.0\", \"15\", Versions::checksrc15),\n+        SIXTEEN(false,   \"60.0\", \"16\", Versions::checksrc16),\n@@ -91,1 +91,2 @@\n-        TWENTY(false,  \"64.0\", \"20\", Versions::checksrc20);\n+        TWENTY(false,    \"64.0\", \"20\", Versions::checksrc20),\n+        TWENTY_ONE(false,\"65.0\", \"21\", Versions::checksrc20);\n","filename":"test\/langtools\/tools\/javac\/versions\/Versions.java","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-requiredVersion=7.1+1\n+requiredVersion=7.1.1+1\n","filename":"test\/lib-test\/TEST.ROOT","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,2 +43,1 @@\n- * English text. {@code \/dev\/urandom} is used as entropy source so tool will\n- * not block because of entropy scarcity. An argument can be a normal string,\n+ * English text. An argument can be a normal string,\n@@ -61,3 +60,0 @@\n-        if (!Platform.isWindows()) {\n-            launcher.addVMArg(\"-Djava.security.egd=file:\/dev\/.\/urandom\");\n-        }\n","filename":"test\/lib\/jdk\/test\/lib\/SecurityTools.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -89,0 +89,2 @@\n+    public static final String NativeMemoryUsage = PREFIX + \"NativeMemoryUsage\";\n+    public static final String NativeMemoryUsageTotal = PREFIX + \"NativeMemoryUsageTotal\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -178,0 +178,1 @@\n+        beanCollectorTypes.put(\"G1 Concurrent GC\", false);\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/GCHelper.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -133,1 +132,1 @@\n-        mismatchSegmentLarge1.session().whileAlive(() -> {\n+        mismatchSegmentLarge1.scope().whileAlive(() -> {\n@@ -155,1 +154,1 @@\n-        mismatchSegmentLarge1.session().whileAlive(() -> {\n+        mismatchSegmentLarge1.scope().whileAlive(() -> {\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/BulkMismatchAcquire.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import static java.lang.foreign.ValueLayout.JAVA_INT_UNALIGNED;\n@@ -63,1 +64,1 @@\n-    final Arena arena = Arena.openConfined();\n+    final Arena arena = Arena.openShared();\n@@ -66,1 +67,1 @@\n-    final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, arena.session());\n+    final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, arena.scope());\n@@ -75,2 +76,2 @@\n-    final MemorySegment mismatchSegmentLarge1 = MemorySegment.allocateNative(SIZE_WITH_TAIL, arena.session());\n-    final MemorySegment mismatchSegmentLarge2 = MemorySegment.allocateNative(SIZE_WITH_TAIL, arena.session());;\n+    final MemorySegment mismatchSegmentLarge1 = MemorySegment.allocateNative(SIZE_WITH_TAIL, arena.scope());\n+    final MemorySegment mismatchSegmentLarge2 = MemorySegment.allocateNative(SIZE_WITH_TAIL, arena.scope());;\n@@ -81,2 +82,2 @@\n-    final MemorySegment mismatchSegmentSmall1 = MemorySegment.allocateNative(7, arena.session());;\n-    final MemorySegment mismatchSegmentSmall2 = MemorySegment.allocateNative(7, arena.session());;\n+    final MemorySegment mismatchSegmentSmall1 = MemorySegment.allocateNative(7, arena.scope());;\n+    final MemorySegment mismatchSegmentSmall2 = MemorySegment.allocateNative(7, arena.scope());;\n@@ -141,1 +142,1 @@\n-        MemorySegment.copy(ints, 0, segment, JAVA_BYTE, 0, ints.length);\n+        MemorySegment.copy(ints, 0, segment, JAVA_INT_UNALIGNED, 0, ints.length);\n@@ -147,1 +148,1 @@\n-        MemorySegment.copy(ints, 0, segment, JAVA_BYTE, 0, 10);\n+        MemorySegment.copy(ints, 0, segment, JAVA_INT_UNALIGNED, 0, 10);\n@@ -154,1 +155,1 @@\n-        MemorySegment.copy(ints, 0, segment, JAVA_BYTE, 0, 10);\n+        MemorySegment.copy(ints, 0, segment, JAVA_INT_UNALIGNED, 0, 10);\n@@ -179,1 +180,1 @@\n-        MemorySegment.copy(ints, 0, segment, JAVA_BYTE, 0, ints.length);\n+        MemorySegment.copy(ints, 0, segment, JAVA_INT_UNALIGNED, 0, ints.length);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/BulkOps.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -31,0 +30,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -84,2 +84,2 @@\n-    static final MemorySegment sharedPoint = MemorySegment.allocateNative(POINT_LAYOUT, Arena.openShared().session());\n-    static final MemorySegment confinedPoint = MemorySegment.allocateNative(POINT_LAYOUT, Arena.openConfined().session());\n+    static final MemorySegment sharedPoint = MemorySegment.allocateNative(POINT_LAYOUT, Arena.openShared().scope());\n+    static final MemorySegment confinedPoint = MemorySegment.allocateNative(POINT_LAYOUT, Arena.openConfined().scope());\n@@ -87,1 +87,1 @@\n-    static final MemorySegment point = MemorySegment.allocateNative(POINT_LAYOUT, MemorySession.implicit());\n+    static final MemorySegment point = MemorySegment.allocateNative(POINT_LAYOUT, SegmentScope.auto());\n@@ -89,1 +89,1 @@\n-    static final SegmentAllocator recycling_allocator = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(POINT_LAYOUT, MemorySession.implicit()));\n+    static final SegmentAllocator recycling_allocator = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(POINT_LAYOUT, SegmentScope.auto()));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadHelper.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -67,1 +67,1 @@\n-        return LINKER.upcallStub(BLANK, BLANK_DESC, MemorySession.implicit());\n+        return LINKER.upcallStub(BLANK, BLANK_DESC, SegmentScope.auto());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LinkUpcall.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -40,0 +39,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -72,1 +72,1 @@\n-    static final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, MemorySession.implicit());\n+    static final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, SegmentScope.auto());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverConstant.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -29,1 +30,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -64,1 +64,1 @@\n-    final SegmentAllocator recyclingAlloc = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(ALLOC_LAYOUT, arena.session()));\n+    final SegmentAllocator recyclingAlloc = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(ALLOC_LAYOUT, arena.scope()));\n@@ -138,1 +138,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, 4, MemorySession.implicit());\n+        MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, 4, SegmentScope.auto());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNew.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-        segment = MemorySegment.allocateNative(ALLOC_SIZE, arena.session());\n+        segment = MemorySegment.allocateNative(ALLOC_SIZE, arena.scope());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstant.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,2 +76,2 @@\n-        segmentIn = MemorySegment.allocateNative(ALLOC_SIZE, arena.session());\n-        segmentOut = MemorySegment.allocateNative(ALLOC_SIZE, arena.session());\n+        segmentIn = MemorySegment.allocateNative(ALLOC_SIZE, arena.scope());\n+        segmentOut = MemorySegment.allocateNative(ALLOC_SIZE, arena.scope());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantFP.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import java.lang.foreign.MemorySession;\n+\n@@ -40,0 +40,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -78,1 +79,1 @@\n-            MemorySegment s = MemorySegment.allocateNative(ALLOC_SIZE, 1, MemorySession.implicit());\n+            MemorySegment s = MemorySegment.allocateNative(ALLOC_SIZE, 1, SegmentScope.auto());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantHeap.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-        segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, ALLOC_SIZE, arena.session());\n+        segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, ALLOC_SIZE, arena.scope());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantMapped.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-        segment = MemorySegment.allocateNative(ALLOC_SIZE, CARRIER_SIZE, arena.session());\n+        segment = MemorySegment.allocateNative(ALLOC_SIZE, CARRIER_SIZE, arena.scope());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantShared.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import java.lang.foreign.MemorySession;\n+\n@@ -38,0 +38,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -72,1 +73,1 @@\n-            res += MemorySegment.ofAddress(i, i % 100, MemorySession.global()).address();\n+            res += MemorySegment.ofAddress(i, i % 100, SegmentScope.global()).address();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverOfAddress.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -73,2 +73,2 @@\n-        nativeSegment = MemorySegment.allocateNative(ALLOC_SIZE, 4, confinedArena.session());\n-        nativeSharedSegment = MemorySegment.allocateNative(ALLOC_SIZE, 4, sharedArena.session());\n+        nativeSegment = MemorySegment.allocateNative(ALLOC_SIZE, 4, confinedArena.scope());\n+        nativeSharedSegment = MemorySegment.allocateNative(ALLOC_SIZE, 4, sharedArena.scope());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverPollutedSegments.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        nativeSegment = MemorySegment.allocateNative(ALLOC_SIZE, arena.session());\n+        nativeSegment = MemorySegment.allocateNative(ALLOC_SIZE, arena.scope());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverSlice.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -41,0 +40,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -121,1 +121,1 @@\n-        return MemorySegment.allocateNative(ALLOC_SIZE, 4, MemorySession.implicit());\n+        return MemorySegment.allocateNative(ALLOC_SIZE, 4, SegmentScope.auto());\n@@ -127,1 +127,1 @@\n-        return MemorySegment.allocateNative(ALLOC_SIZE, 4, MemorySession.implicit());\n+        return MemorySegment.allocateNative(ALLOC_SIZE, 4, SegmentScope.auto());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/MemorySessionClose.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-        segment = MemorySegment.allocateNative(ALLOC_SIZE, CARRIER_SIZE, arena.session());\n+        segment = MemorySegment.allocateNative(ALLOC_SIZE, CARRIER_SIZE, arena.scope());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ParallelSum.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-    MemorySegment segment = MemorySegment.allocateNative(100, arena.session());\n+    MemorySegment segment = MemorySegment.allocateNative(100, arena.scope());\n@@ -90,1 +90,1 @@\n-        MemorySegment newSegment = MemorySegment.ofAddress(segment.address(), 100, arena.session());\n+        MemorySegment newSegment = MemorySegment.ofAddress(segment.address(), 100, arena.scope());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/PointerInvoke.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import java.lang.foreign.MemorySession;\n+\n@@ -39,0 +39,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -67,1 +68,1 @@\n-        INPUT_SEGMENT = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(INPUT.length, JAVA_INT), MemorySession.global());\n+        INPUT_SEGMENT = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(INPUT.length, JAVA_INT), SegmentScope.global());\n@@ -85,1 +86,1 @@\n-                    MemorySession.global()\n+                    SegmentScope.global()\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/QSort.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -63,1 +63,1 @@\n-    SegmentAllocator arenaAllocator = new RingAllocator(arena.session());\n+    SegmentAllocator arenaAllocator = new RingAllocator(arena.scope());\n@@ -84,1 +84,1 @@\n-        segmentAllocator = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(size + 1, arena.session()));\n+        segmentAllocator = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(size + 1, arena.scope()));\n@@ -151,1 +151,1 @@\n-        public RingAllocator(MemorySession session) {\n+        public RingAllocator(SegmentScope session) {\n@@ -162,1 +162,2 @@\n-            rem = segment.byteSize() - segment.segmentOffset(res);\n+            long lastOffset = segment.segmentOffset(res) + res.byteSize();\n+            rem = segment.byteSize() - lastOffset;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/StrLenTest.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.foreign.MemorySession;\n+\n@@ -40,0 +40,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -70,1 +71,1 @@\n-        srcSegmentImplicit = MemorySegment.allocateNative(size, MemorySession.implicit());\n+        srcSegmentImplicit = MemorySegment.allocateNative(size, SegmentScope.auto());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/TestLoadBytes.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -69,2 +70,2 @@\n-            this.inputSegment = MemorySegment.ofAddress(inputAddress, 8*SIZE, MemorySession.global());\n-            this.outputSegment = MemorySegment.ofAddress(outputAddress, 8*SIZE, MemorySession.global());\n+            this.inputSegment = MemorySegment.ofAddress(inputAddress, 8*SIZE, SegmentScope.global());\n+            this.outputSegment = MemorySegment.ofAddress(outputAddress, 8*SIZE, SegmentScope.global());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/UnrolledAccess.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.foreign.MemorySession;\n+\n@@ -38,0 +38,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -133,1 +134,1 @@\n-            fd, MemorySession.global()\n+            fd, SegmentScope.global()\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/Upcalls.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-                            .addVarg(C_LONG_LONG, 3L), arena.session());\n+                            .addVarg(C_LONG_LONG, 3L), arena.scope());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/VaList.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        data = MemorySegment.allocateNative(JAVA_INT, arena.session());\n+        data = MemorySegment.allocateNative(JAVA_INT, arena.scope());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/VarHandleExact.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-        this.segment = MemorySegment.allocateNative(LAYOUT, arena.session());\n+        this.segment = MemorySegment.allocateNative(LAYOUT, arena.scope());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/points\/support\/PanamaPoint.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.nio.ByteBuffer;\n@@ -52,1 +53,1 @@\n-    private static MethodHandle polyEngineInit, polyEngineUpdate, polyEngineFinal;\n+    private static MethodHandle polyEngineInit, polyEngineUpdate, polyEngineUpdateBuf, polyEngineFinal;\n@@ -71,0 +72,4 @@\n+            m = polyClazz.getDeclaredMethod(\"engineUpdate\", ByteBuffer.class);\n+            m.setAccessible(true);\n+            polyEngineUpdateBuf = lookup.unreflect(m);\n+\n@@ -86,1 +91,1 @@\n-    public byte[] digest() {\n+    public byte[] digestBytes() {\n@@ -97,0 +102,13 @@\n+\n+    @Benchmark\n+    public byte[] digestBuffer() {\n+        try {\n+            byte[] d = data[index];\n+            index = (index +1) % SET_SIZE;\n+            polyEngineInit.invoke(polyObj, new SecretKeySpec(d, 0, 32, \"Poly1305\"), null);\n+            polyEngineUpdateBuf.invoke(polyObj, ByteBuffer.wrap(d, 0, d.length));\n+            return (byte[])polyEngineFinal.invoke(polyObj);\n+        } catch (Throwable ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/full\/Poly1305DigestBench.java","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,217 @@\n+\/*\n+ * Copyright (c) 2022, red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+package org.openjdk.bench.jdk.incubator.concurrent;\n+\n+import jdk.incubator.concurrent.ScopedValue;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import static org.openjdk.bench.jdk.incubator.concurrent.ScopedValuesData.*;\n+\n+\/**\n+ * Tests ScopedValue\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@Warmup(iterations=4, time=1)\n+@Measurement(iterations=10, time=1)\n+@Threads(1)\n+@Fork(value = 1,\n+      jvmArgsPrepend = {\"-Djmh.executor.class=org.openjdk.bench.jdk.incubator.concurrent.ScopedValuesExecutorService\",\n+                        \"-Djmh.executor=CUSTOM\",\n+                        \"-Djmh.blackhole.mode=COMPILER\",\n+                        \"--add-modules=jdk.incubator.concurrent\",\n+                        \"--enable-preview\"})\n+@State(Scope.Thread)\n+@SuppressWarnings(\"preview\")\n+public class ScopedValues {\n+\n+    private static final Integer THE_ANSWER = 42;\n+\n+    \/\/ Test 1: make sure ScopedValue.get() is hoisted out of loops.\n+\n+    @Benchmark\n+    public void thousandAdds_ScopedValue(Blackhole bh) throws Exception {\n+        int result = 0;\n+        for (int i = 0; i < 1_000; i++) {\n+            result += ScopedValuesData.sl1.get();\n+        }\n+        bh.consume(result);\n+    }\n+\n+    @Benchmark\n+    public void thousandAdds_ThreadLocal(Blackhole bh) throws Exception {\n+        int result = 0;\n+        for (int i = 0; i < 1_000; i++) {\n+            result += ScopedValuesData.tl1.get();\n+        }\n+        bh.consume(result);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int thousandIsBoundQueries(Blackhole bh) throws Exception {\n+        var result = 0;\n+        for (int i = 0; i < 1_000; i++) {\n+            result += ScopedValuesData.sl1.isBound() ? 1 : 0;\n+        }\n+        return result;\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int thousandMaybeGets(Blackhole bh) throws Exception {\n+        int result = 0;\n+        for (int i = 0; i < 1_000; i++) {\n+            if (ScopedValuesData.sl1.isBound()) {\n+                result += ScopedValuesData.sl1.get();\n+            }\n+        }\n+        return result;\n+    }\n+\n+    \/\/ Test 2: stress the ScopedValue cache.\n+    \/\/ The idea here is to use a bunch of bound values cyclically, which\n+    \/\/ stresses the ScopedValue cache.\n+\n+    int combine(int n, int i1, int i2, int i3, int i4, int i5, int i6) {\n+        return n + ((i1 ^ i2 >>> 6) + (i3 << 7) + i4 - i5 | i6);\n+    }\n+\n+    @Benchmark\n+    public int sixValues_ScopedValue() throws Exception {\n+        int result = 0;\n+        for (int i = 0 ; i < 166; i++) {\n+            result = combine(result, sl1.get(), sl2.get(), sl3.get(), sl4.get(), sl5.get(), sl6.get());\n+        }\n+        return result;\n+    }\n+\n+    @Benchmark\n+    public int sixValues_ThreadLocal() throws Exception {\n+        int result = 0;\n+        for (int i = 0 ; i < 166; i++) {\n+            result = combine(result, tl1.get(), tl2.get(), tl3.get(), tl4.get(), tl5.get(), tl6.get());\n+        }\n+        return result;\n+    }\n+\n+    \/\/ Test 3: The cost of bind, then get\n+    \/\/ This is the worst case for ScopedValues because we have to create\n+    \/\/ a binding, link it in, then search the current bindings. In addition, we\n+    \/\/ create a cache entry for the bound value, then we immediately have to\n+    \/\/ destroy it.\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int CreateBindThenGetThenRemove_ScopedValue() throws Exception {\n+        return ScopedValue.where(sl1, THE_ANSWER).call(sl1::get);\n+    }\n+\n+\n+    \/\/ Create a Carrier ahead of time: might be slightly faster\n+    private static final ScopedValue.Carrier HOLD_42 = ScopedValue.where(sl1, 42);\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int bindThenGetThenRemove_ScopedValue() throws Exception {\n+        return HOLD_42.call(sl1::get);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int bindThenGetThenRemove_ThreadLocal() throws Exception {\n+        try {\n+            tl1.set(THE_ANSWER);\n+            return tl1.get();\n+        } finally {\n+            tl1.remove();\n+        }\n+    }\n+\n+    \/\/ This has no exact equivalent in ScopedValue, but it's provided here for\n+    \/\/ information.\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int bindThenGetNoRemove_ThreadLocal() throws Exception {\n+        tl1.set(THE_ANSWER);\n+        return tl1.get();\n+    }\n+\n+    \/\/ Test 4: The cost of binding, but not using any result\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public Object bind_ScopedValue() throws Exception {\n+        return HOLD_42.call(this::getClass);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public Object bind_ThreadLocal() throws Exception {\n+        try {\n+            tl1.set(THE_ANSWER);\n+            return this.getClass();\n+        } finally {\n+            tl1.remove();\n+        }\n+    }\n+\n+    \/\/ Simply set a ThreadLocal so that the caller can see it\n+    \/\/ This has no exact equivalent in ScopedValue, but it's provided here for\n+    \/\/ information.\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void setNoRemove_ThreadLocal() throws Exception {\n+        tl1.set(THE_ANSWER);\n+    }\n+\n+    \/\/ This is the closest I can think of to setNoRemove_ThreadLocal in that it\n+    \/\/ returns a value in a ScopedValue container. The container must already\n+    \/\/ be bound to an AtomicReference for this to work.\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void setNoRemove_ScopedValue() throws Exception {\n+        sl_atomicRef.get().setPlain(THE_ANSWER);\n+    }\n+\n+    \/\/ Test 5: A simple counter\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void counter_ScopedValue() {\n+        sl_atomicInt.get().setPlain(\n+                sl_atomicInt.get().getPlain() + 1);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void counter_ThreadLocal() {\n+        \/\/ Very slow:\n+        \/\/ tl1.set(tl1.get() + 1);\n+        var ctr = tl_atomicInt.get();\n+        ctr.setPlain(ctr.getPlain() + 1);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/concurrent\/ScopedValues.java","additions":217,"deletions":0,"binary":false,"changes":217,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.concurrent;\n+\n+import jdk.incubator.concurrent.ScopedValue;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+@SuppressWarnings(\"preview\")\n+public class ScopedValuesData {\n+\n+    static final ScopedValue<Integer> sl1 = ScopedValue.newInstance();\n+    static final ThreadLocal<Integer> tl1 = new ThreadLocal<>();\n+\n+    static final ScopedValue<Integer> sl2 = ScopedValue.newInstance();\n+    static final ScopedValue<Integer> sl3 = ScopedValue.newInstance();\n+    static final ScopedValue<Integer> sl4 = ScopedValue.newInstance();\n+    static final ScopedValue<Integer> sl5 = ScopedValue.newInstance();\n+    static final ScopedValue<Integer> sl6 = ScopedValue.newInstance();\n+    static final ScopedValue<AtomicInteger> sl_atomicInt = ScopedValue.newInstance();\n+\n+    static final ScopedValue<Integer> unbound = ScopedValue.newInstance();\n+\n+    static final ScopedValue<AtomicReference<Integer>> sl_atomicRef = ScopedValue.newInstance();\n+\n+    static final ThreadLocal<Integer> tl2 = new ThreadLocal<>();\n+    static final ThreadLocal<Integer> tl3 = new ThreadLocal<>();\n+    static final ThreadLocal<Integer> tl4 = new ThreadLocal<>();\n+    static final ThreadLocal<Integer> tl5 = new ThreadLocal<>();\n+    static final ThreadLocal<Integer> tl6 = new ThreadLocal<>();\n+    static final ThreadLocal<AtomicInteger> tl_atomicInt = new ThreadLocal<>();\n+\n+    static final ScopedValue.Carrier VALUES = ScopedValue\n+            .where(sl1, 42).where(sl2, 2).where(sl3, 3)\n+            .where(sl4, 4).where(sl5, 5).where(sl6, 6);\n+\n+    public static void run(Runnable action) {\n+        try {\n+            tl1.set(42); tl2.set(2); tl3.set(3); tl4.set(4); tl5.set(5); tl6.set(6);\n+            tl1.get();  \/\/ Create the ScopedValue cache as a side effect\n+            tl_atomicInt.set(new AtomicInteger());\n+            VALUES.where(sl_atomicInt, new AtomicInteger())\n+                  .where(sl_atomicRef, new AtomicReference<>())\n+                  .run(action);\n+        } finally {\n+            tl1.remove(); tl2.remove(); tl3.remove(); tl4.remove(); tl5.remove(); tl6.remove();\n+            tl_atomicInt.remove();\n+        }\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/concurrent\/ScopedValuesData.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+package org.openjdk.bench.jdk.incubator.concurrent;\n+\n+import java.util.concurrent.*;\n+\n+public class ScopedValuesExecutorService extends ThreadPoolExecutor {\n+    public ScopedValuesExecutorService(int corePoolSize, String prefix) {\n+        super(1, 1, 0, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>(),\n+              new AThreadFactory(), new ThreadPoolExecutor.AbortPolicy());\n+    }\n+}\n+\n+class AThreadFactory implements ThreadFactory {\n+    public Thread newThread(Runnable action) {\n+        return new Thread() {\n+            public void run() {\n+                ScopedValuesData.run(action);\n+            }\n+        };\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/concurrent\/ScopedValuesExecutorService.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -29,1 +29,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -72,2 +72,2 @@\n-    nativeIn = MemorySegment.allocateNative(size, MemorySession.implicit());\n-    nativeOut = MemorySegment.allocateNative(size, MemorySession.implicit());\n+    nativeIn = MemorySegment.allocateNative(size, SegmentScope.auto());\n+    nativeOut = MemorySegment.allocateNative(size, SegmentScope.auto());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/MemorySegmentVectorAccess.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -88,2 +88,2 @@\n-    srcSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), MemorySession.implicit());\n-    dstSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), MemorySession.implicit());\n+    srcSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), SegmentScope.auto());\n+    dstSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), SegmentScope.auto());\n@@ -167,2 +167,2 @@\n-      final var srcSegmentConfined = MemorySegment.ofAddress(srcSegment.address(), size, arena.session());\n-      final var dstSegmentConfined = MemorySegment.ofAddress(dstSegment.address(), size, arena.session());\n+      final var srcSegmentConfined = MemorySegment.ofAddress(srcSegment.address(), size, arena.scope());\n+      final var dstSegmentConfined = MemorySegment.ofAddress(dstSegment.address(), size, arena.scope());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreBytes.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentScope;\n@@ -93,2 +93,2 @@\n-    srcSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), MemorySession.implicit());\n-    dstSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), MemorySession.implicit());\n+    srcSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), SegmentScope.auto());\n+    dstSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), SegmentScope.auto());\n@@ -165,2 +165,2 @@\n-      final var srcSegmentConfined = MemorySegment.ofAddress(srcSegment.address(), size, arena.session());\n-      final var dstSegmentConfined = MemorySegment.ofAddress(dstSegment.address(), size, arena.session());\n+      final var srcSegmentConfined = MemorySegment.ofAddress(srcSegment.address(), size, arena.scope());\n+      final var dstSegmentConfined = MemorySegment.ofAddress(dstSegment.address(), size, arena.scope());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreShorts.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}