{"files":[{"patch":"@@ -1290,1 +1290,2 @@\n-    static void copy(MemorySegment srcSegment, long srcOffset, MemorySegment dstSegment, long dstOffset, long bytes) {\n+    static void copy(MemorySegment srcSegment, long srcOffset,\n+                     MemorySegment dstSegment, long dstOffset, long bytes) {\n@@ -1337,2 +1338,3 @@\n-    static void copy(MemorySegment srcSegment, ValueLayout srcElementLayout, long srcOffset, MemorySegment dstSegment,\n-                     ValueLayout dstElementLayout, long dstOffset, long elementCount) {\n+    static void copy(MemorySegment srcSegment, ValueLayout srcElementLayout, long srcOffset,\n+                     MemorySegment dstSegment, ValueLayout dstElementLayout, long dstOffset,\n+                     long elementCount) {\n@@ -1343,25 +1345,1 @@\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        AbstractMemorySegmentImpl dstImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        if (srcElementLayout.byteSize() != dstElementLayout.byteSize()) {\n-            throw new IllegalArgumentException(\"Source and destination layouts must have same size\");\n-        }\n-        Utils.checkElementAlignment(srcElementLayout, \"Source layout alignment greater than its size\");\n-        Utils.checkElementAlignment(dstElementLayout, \"Destination layout alignment greater than its size\");\n-        if (!srcImpl.isAlignedForElement(srcOffset, srcElementLayout)) {\n-            throw new IllegalArgumentException(\"Source segment incompatible with alignment constraints\");\n-        }\n-        if (!dstImpl.isAlignedForElement(dstOffset, dstElementLayout)) {\n-            throw new IllegalArgumentException(\"Destination segment incompatible with alignment constraints\");\n-        }\n-        long size = elementCount * srcElementLayout.byteSize();\n-        srcImpl.checkAccess(srcOffset, size, true);\n-        dstImpl.checkAccess(dstOffset, size, false);\n-        if (srcElementLayout.byteSize() == 1 || srcElementLayout.order() == dstElementLayout.order()) {\n-            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size);\n-        } else {\n-            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size, srcElementLayout.byteSize());\n-        }\n+        AbstractMemorySegmentImpl.copy(srcSegment, srcElementLayout, srcOffset, dstSegment, dstElementLayout, dstOffset, elementCount);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":6,"deletions":28,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n-        if (!(base instanceof byte[])) {\n+        if (!(base instanceof byte[] baseByte)) {\n@@ -89,1 +89,1 @@\n-        return nioAccess.newHeapByteBuffer((byte[])base, (int)offset - BYTE_ARR_BASE, (int) byteSize(), null);\n+        return nioAccess.newHeapByteBuffer(baseByte, (int)offset - BYTE_ARR_BASE, (int) byteSize(), null);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.lang.foreign.MemorySegment;\n@@ -75,4 +74,0 @@\n-    public MemorySegment segment() {\n-        return MappedMemorySegmentImpl.this;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -308,0 +308,36 @@\n+    @Test(dataProvider = \"fromArrays\")\n+    public void testAsByteBufferFromNonByteArray(MemorySegment segment) {\n+        if (!segment.array().map(a -> a instanceof byte[]).get()) {\n+            \/\/ This should not work as the segment is not backed by a byte array\n+            assertThrows(UnsupportedOperationException.class, segment::asByteBuffer);\n+        }\n+    }\n+\n+    @Test\n+    public void testMappedSegmentAsByteBuffer() throws Throwable {\n+        File f = new File(\"test4.out\");\n+        assert f.createNewFile();\n+        f.deleteOnExit();\n+\n+        for (var mapOption : List.of(FileChannel.MapMode.READ_WRITE, FileChannel.MapMode.READ_ONLY, FileChannel.MapMode.PRIVATE)) {\n+            for (var arena : List.of(Arena.ofConfined(), Arena.global())) {\n+                try (FileChannel fileChannel = FileChannel.open(f.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE)) {\n+                    \/\/write to channel\n+                    MemorySegment segment = fileChannel.map(mapOption, 0L, 32L, arena);\n+                    segment.force();\n+                    segment.load();\n+                    segment.isLoaded();\n+                    segment.unload();\n+                    ByteBuffer byteBuffer = segment.asByteBuffer();\n+                    assertEquals(byteBuffer.capacity(), segment.byteSize());\n+                    assertEquals(byteBuffer.isReadOnly(), segment.isReadOnly());\n+                    assertTrue(byteBuffer.isDirect());\n+                } finally {\n+                    if (arena.scope() != Arena.global().scope()) {\n+                        arena.close();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n@@ -983,1 +1019,1 @@\n-        private Consumer<MemorySegment> segmentOp;\n+        private final Consumer<MemorySegment> segmentOp;\n@@ -1022,0 +1058,15 @@\n+    @DataProvider(name = \"fromArrays\")\n+    public static Object[][] fromArrays() {\n+        int len = 16;\n+        return Stream.of(\n+                        MemorySegment.ofArray(new byte[len]),\n+                        MemorySegment.ofArray(new short[len]),\n+                        MemorySegment.ofArray(new char[len]),\n+                        MemorySegment.ofArray(new int[len]),\n+                        MemorySegment.ofArray(new long[len]),\n+                        MemorySegment.ofArray(new float[len]),\n+                        MemorySegment.ofArray(new double[len])\n+                )\n+                .map(s -> new Object[] { s })\n+                .toArray(Object[][]::new);\n+    }\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":53,"deletions":2,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @modules java.base\/jdk.internal.foreign\n@@ -33,0 +34,2 @@\n+import jdk.internal.foreign.MappedMemorySegmentImpl;\n+import jdk.internal.foreign.NativeMemorySegmentImpl;\n@@ -222,0 +225,21 @@\n+    @Test(dataProvider = \"arrayAllocations\")\n+    public <Z> void testPredicatesAndCommands(AllocationFactory allocationFactory, ValueLayout layout, AllocationFunction<Object, ValueLayout> allocationFunction, ToArrayHelper<Z> arrayHelper) {\n+        Z arr = arrayHelper.array();\n+        Arena[] arenas = {\n+                Arena.ofConfined(),\n+                Arena.ofShared()\n+        };\n+        for (Arena arena : arenas) {\n+            try (arena) {\n+                SegmentAllocator allocator = allocationFactory.allocator(100, arena);\n+                MemorySegment segment = allocationFunction.allocate(allocator, layout, arr);\n+                assertThrows(UnsupportedOperationException.class, segment::load);\n+                assertThrows(UnsupportedOperationException.class, segment::unload);\n+                assertThrows(UnsupportedOperationException.class, segment::isLoaded);\n+                assertThrows(UnsupportedOperationException.class, segment::force);\n+                assertEquals(segment.isMapped(), segment instanceof MappedMemorySegmentImpl);\n+                assertEquals(segment.isNative(), segment instanceof NativeMemorySegmentImpl);\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestSegmentAllocators.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"}]}