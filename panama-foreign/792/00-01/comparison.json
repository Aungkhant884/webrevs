{"files":[{"patch":"@@ -1290,1 +1290,2 @@\n-    static void copy(MemorySegment srcSegment, long srcOffset, MemorySegment dstSegment, long dstOffset, long bytes) {\n+    static void copy(MemorySegment srcSegment, long srcOffset,\n+                     MemorySegment dstSegment, long dstOffset, long bytes) {\n@@ -1337,2 +1338,3 @@\n-    static void copy(MemorySegment srcSegment, ValueLayout srcElementLayout, long srcOffset, MemorySegment dstSegment,\n-                     ValueLayout dstElementLayout, long dstOffset, long elementCount) {\n+    static void copy(MemorySegment srcSegment, ValueLayout srcElementLayout, long srcOffset,\n+                     MemorySegment dstSegment, ValueLayout dstElementLayout, long dstOffset,\n+                     long elementCount) {\n@@ -1343,25 +1345,1 @@\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        AbstractMemorySegmentImpl dstImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        if (srcElementLayout.byteSize() != dstElementLayout.byteSize()) {\n-            throw new IllegalArgumentException(\"Source and destination layouts must have same size\");\n-        }\n-        Utils.checkElementAlignment(srcElementLayout, \"Source layout alignment greater than its size\");\n-        Utils.checkElementAlignment(dstElementLayout, \"Destination layout alignment greater than its size\");\n-        if (!srcImpl.isAlignedForElement(srcOffset, srcElementLayout)) {\n-            throw new IllegalArgumentException(\"Source segment incompatible with alignment constraints\");\n-        }\n-        if (!dstImpl.isAlignedForElement(dstOffset, dstElementLayout)) {\n-            throw new IllegalArgumentException(\"Destination segment incompatible with alignment constraints\");\n-        }\n-        long size = elementCount * srcElementLayout.byteSize();\n-        srcImpl.checkAccess(srcOffset, size, true);\n-        dstImpl.checkAccess(dstOffset, size, false);\n-        if (srcElementLayout.byteSize() == 1 || srcElementLayout.order() == dstElementLayout.order()) {\n-            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size);\n-        } else {\n-            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size, srcElementLayout.byteSize());\n-        }\n+        AbstractMemorySegmentImpl.copy(srcSegment, srcElementLayout, srcOffset, dstSegment, dstElementLayout, dstOffset, elementCount);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":6,"deletions":28,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -564,0 +564,32 @@\n+    @ForceInline\n+    public static void copy(MemorySegment srcSegment, ValueLayout srcElementLayout, long srcOffset,\n+                            MemorySegment dstSegment, ValueLayout dstElementLayout, long dstOffset,\n+                            long elementCount) {\n+\n+        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n+        AbstractMemorySegmentImpl dstImpl = (AbstractMemorySegmentImpl)dstSegment;\n+        if (srcElementLayout.byteSize() != dstElementLayout.byteSize()) {\n+            throw new IllegalArgumentException(\"Source and destination layouts must have same size\");\n+        }\n+        Utils.checkElementAlignment(srcElementLayout, \"Source layout alignment greater than its size\");\n+        Utils.checkElementAlignment(dstElementLayout, \"Destination layout alignment greater than its size\");\n+        if (!srcImpl.isAlignedForElement(srcOffset, srcElementLayout)) {\n+            throw new IllegalArgumentException(\"Source segment incompatible with alignment constraints\");\n+        }\n+        if (!dstImpl.isAlignedForElement(dstOffset, dstElementLayout)) {\n+            throw new IllegalArgumentException(\"Destination segment incompatible with alignment constraints\");\n+        }\n+        long size = elementCount * srcElementLayout.byteSize();\n+        srcImpl.checkAccess(srcOffset, size, true);\n+        dstImpl.checkAccess(dstOffset, size, false);\n+        if (srcElementLayout.byteSize() == 1 || srcElementLayout.order() == dstElementLayout.order()) {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size);\n+        } else {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size, srcElementLayout.byteSize());\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -115,5 +115,0 @@\n-\n-        @Override\n-        ByteBuffer makeByteBuffer() {\n-            return ByteBuffer.allocateDirect(0);\n-        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -591,4 +591,0 @@\n-            ByteBuffer byteBuffer = segment.asByteBuffer();\n-            assertEquals(byteBuffer.capacity(), segment.byteSize());\n-            assertFalse(byteBuffer.isReadOnly());\n-            assertTrue(byteBuffer.isDirect());\n@@ -607,4 +603,0 @@\n-            ByteBuffer byteBuffer = segment.asByteBuffer();\n-            assertEquals(byteBuffer.capacity(), segment.byteSize());\n-            assertTrue(byteBuffer.isReadOnly());\n-            assertTrue(byteBuffer.isDirect());\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/foreign\/TestSegmentAllocators.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}