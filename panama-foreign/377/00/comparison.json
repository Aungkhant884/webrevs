{"files":[{"patch":"@@ -34,0 +34,1 @@\n+import jdk.internal.misc.ScopedMemoryAccess;\n@@ -90,0 +91,2 @@\n+    static ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n+\n@@ -176,1 +179,1 @@\n-        return MappedMemoryUtils.isLoaded(address, isSync, capacity());\n+        return SCOPED_MEMORY_ACCESS.isLoaded(scope(), address, isSync, capacity());\n@@ -194,1 +197,1 @@\n-            MappedMemoryUtils.load(address, isSync, capacity());\n+            SCOPED_MEMORY_ACCESS.load(scope(), address, isSync, capacity());\n@@ -283,1 +286,1 @@\n-            MappedMemoryUtils.force(fd, address, isSync, index, length);\n+            SCOPED_MEMORY_ACCESS.force(scope(), fd, address, isSync, index, length);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/MappedByteBuffer.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.io.FileDescriptor;\n@@ -34,0 +35,1 @@\n+import jdk.internal.access.SharedSecrets;\n@@ -238,0 +240,84 @@\n+\n+    @ForceInline\n+    public boolean isLoaded(Scope scope, long address, boolean isSync, long size) {\n+        try {\n+            return isLoadedInternal(scope, address, isSync, size);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    public boolean isLoadedInternal(Scope scope, long address, boolean isSync, long size) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return SharedSecrets.getJavaNioAccess().isLoaded(address, isSync, size);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public void load(Scope scope, long address, boolean isSync, long size) {\n+        try {\n+            loadInternal(scope, address, isSync, size);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    public void loadInternal(Scope scope, long address, boolean isSync, long size) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            SharedSecrets.getJavaNioAccess().load(address, isSync, size);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public void unload(Scope scope, long address, boolean isSync, long size) {\n+        try {\n+            unloadInternal(scope, address, isSync, size);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    public void unloadInternal(Scope scope, long address, boolean isSync, long size) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            SharedSecrets.getJavaNioAccess().unload(address, isSync, size);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public void force(Scope scope, FileDescriptor fd, long address, boolean isSync, long index, long length) {\n+        try {\n+            forceInternal(scope, fd, address, isSync, index, length);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    public void forceInternal(Scope scope, FileDescriptor fd, long address, boolean isSync, long index, long length) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            SharedSecrets.getJavaNioAccess().force(fd, address, isSync, index, length);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":86,"deletions":0,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -1,132 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.incubator.foreign;\n-\n-import java.nio.channels.FileChannel;\n-import java.nio.file.Path;\n-\n-\/**\n- * A mapped memory segment, that is, a memory segment backed by memory-mapped file.\n- *\n- * <p> Mapped memory segments are created via the {@link MemorySegment#mapFromPath(Path, long, long, FileChannel.MapMode)}.\n- * Mapped memory segments behave like ordinary segments, but provide additional capabilities to manipulate memory-mapped\n- * memory regions, such as {@link #force()} and {@link #load()}.\n- * <p>\n- * All implementations of this interface must be <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>;\n- * use of identity-sensitive operations (including reference equality ({@code ==}), identity hash code, or synchronization) on\n- * instances of {@code MemoryLayout} may have unpredictable results and should be avoided. The {@code equals} method should\n- * be used for comparisons.\n- * <p>\n- * Non-platform classes should not implement {@linkplain MappedMemorySegment} directly.\n- *\n- * <p> The content of a mapped memory segment can change at any time, for example\n- * if the content of the corresponding region of the mapped file is changed by\n- * this (or another) program.  Whether or not such changes occur, and when they\n- * occur, is operating-system dependent and therefore unspecified.\n- *\n- * All or part of a mapped memory segment may become\n- * inaccessible at any time, for example if the backing mapped file is truncated.  An\n- * attempt to access an inaccessible region of a mapped memory segment will not\n- * change the segment's content and will cause an unspecified exception to be\n- * thrown either at the time of the access or at some later time.  It is\n- * therefore strongly recommended that appropriate precautions be taken to\n- * avoid the manipulation of a mapped file by this (or another) program, except to read or write\n- * the file's content.\n- *\n- * @apiNote In the future, if the Java language permits, {@link MemorySegment}\n- * may become a {@code sealed} interface, which would prohibit subclassing except by\n- * explicitly permitted subtypes.\n- *\/\n-public interface MappedMemorySegment extends MemorySegment {\n-\n-    @Override\n-    MappedMemorySegment withAccessModes(int accessModes);\n-\n-    @Override\n-    MappedMemorySegment asSlice(long offset, long newSize);\n-\n-    \/**\n-     * Forces any changes made to this segment's content to be written to the\n-     * storage device containing the mapped file.\n-     *\n-     * <p> If the file mapped into this segment resides on a local storage\n-     * device then when this method returns it is guaranteed that all changes\n-     * made to the segment since it was created, or since this method was last\n-     * invoked, will have been written to that device.\n-     *\n-     * <p> If the file does not reside on a local device then no such guarantee\n-     * is made.\n-     *\n-     * <p> If this segment was not mapped in read\/write mode ({@link\n-     * java.nio.channels.FileChannel.MapMode#READ_WRITE}) then\n-     * invoking this method may have no effect. In particular, the\n-     * method has no effect for segments mapped in read-only or private\n-     * mapping modes. This method may or may not have an effect for\n-     * implementation-specific mapping modes.\n-     * <\/p>\n-     *\/\n-    void force();\n-\n-    \/**\n-     * Loads this segment's content into physical memory.\n-     *\n-     * <p> This method makes a best effort to ensure that, when it returns,\n-     * this segment's contents is resident in physical memory.  Invoking this\n-     * method may cause some number of page faults and I\/O operations to\n-     * occur. <\/p>\n-     *\/\n-    void load();\n-\n-    \/**\n-     * Unloads this segment's content from physical memory.\n-     *\n-     * <p> This method makes a best effort to ensure that this segment's contents are\n-     * are no longer resident in physical memory. Accessing this segment's contents\n-     * after invoking this method may cause some number of page faults and I\/O operations to\n-     * occur (as this segment's contents might need to be paged back in). <\/p>\n-     *\/\n-    void unload();\n-\n-    \/**\n-     * Tells whether or not this segment's content is resident in physical\n-     * memory.\n-     *\n-     * <p> A return value of {@code true} implies that it is highly likely\n-     * that all of the data in this segment is resident in physical memory and\n-     * may therefore be accessed without incurring any virtual-memory page\n-     * faults or I\/O operations.  A return value of {@code false} does not\n-     * necessarily imply that the segment's content is not resident in physical\n-     * memory.\n-     *\n-     * <p> The returned value is a hint, rather than a guarantee, because the\n-     * underlying operating system may have paged out some of the segment's data\n-     * by the time that an invocation of this method returns.  <\/p>\n-     *\n-     * @return  {@code true} if it is likely that this segment's content\n-     *          is resident in physical memory\n-     *\/\n-    boolean isLoaded();\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MappedMemorySegment.java","additions":0,"deletions":132,"binary":false,"changes":132,"status":"deleted"},{"patch":"@@ -29,0 +29,1 @@\n+import java.io.FileDescriptor;\n@@ -42,0 +43,1 @@\n+import java.util.Optional;\n@@ -43,1 +45,0 @@\n-import java.util.function.Consumer;\n@@ -78,2 +79,3 @@\n- * {@link MemorySegment#mapFromPath(Path, long, long, FileChannel.MapMode)}. Such memory segments are called <em>mapped memory segments<\/em>\n- * (see {@link MappedMemorySegment}).\n+ * {@link MemorySegment#mapFromPath(Path, long, long, FileChannel.MapMode)}. Such memory segments are called <em>mapped memory segments<\/em>;\n+ * mapped memory segments are associated with a {@link MemoryMapping} instance which can be obtained calling the\n+ * {@link #mapping()} method.\n@@ -183,1 +185,1 @@\n-    int sum = StreamSupport.stream(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT), true)\n+    int sum = StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT), true)\n@@ -216,2 +218,1 @@\n- * may become a {@code sealed} interface, which would prohibit subclassing except by\n- * {@link MappedMemorySegment} and other explicitly permitted subtypes.\n+ * may become a {@code sealed} interface, which would prohibit subclassing except by other explicitly permitted subtypes.\n@@ -236,1 +237,1 @@\n-     * Returns a spliterator for the given memory segment. The returned spliterator reports {@link Spliterator#SIZED},\n+     * Returns a spliterator for this given memory segment. The returned spliterator reports {@link Spliterator#SIZED},\n@@ -240,1 +241,1 @@\n-     * The returned spliterator splits the segment according to the specified sequence layout; that is,\n+     * The returned spliterator splits this segment according to the specified sequence layout; that is,\n@@ -246,1 +247,1 @@\n-     * The returned spliterator effectively allows to slice a segment into disjoint sub-segments, which can then\n+     * The returned spliterator effectively allows to slice this segment into disjoint sub-segments, which can then\n@@ -248,5 +249,1 @@\n-     * While closing the segment (see {@link #close()}) during pending concurrent execution will generally\n-     * fail with an exception, it is possible to close a segment when a spliterator has been obtained but no thread\n-     * is actively working on it using {@link Spliterator#tryAdvance(Consumer)}; in such cases, any subsequent call\n-     * to {@link Spliterator#tryAdvance(Consumer)} will fail with an exception.\n-     * @param segment the segment to be used for splitting.\n+     *\n@@ -254,1 +251,0 @@\n-     * @param <S> the memory segment type\n@@ -259,3 +255,1 @@\n-    static <S extends MemorySegment> Spliterator<S> spliterator(S segment, SequenceLayout layout) {\n-        return AbstractMemorySegmentImpl.spliterator(segment, layout);\n-    }\n+    Spliterator<MemorySegment> spliterator(SequenceLayout layout);\n@@ -399,1 +393,0 @@\n-     * thread (see {@link #spliterator(MemorySegment, SequenceLayout)}).\n@@ -805,0 +798,14 @@\n+     * <p>\n+     * The content of a mapped memory segment can change at any time, for example\n+     * if the content of the corresponding region of the mapped file is changed by\n+     * this (or another) program.  Whether or not such changes occur, and when they\n+     * occur, is operating-system dependent and therefore unspecified.\n+     * <p>\n+     * All or part of a mapped memory segment may become\n+     * inaccessible at any time, for example if the backing mapped file is truncated.  An\n+     * attempt to access an inaccessible region of a mapped memory segment will not\n+     * change the segment's content and will cause an unspecified exception to be\n+     * thrown either at the time of the access or at some later time.  It is\n+     * therefore strongly recommended that appropriate precautions be taken to\n+     * avoid the manipulation of a mapped file by this (or another) program, except to read or write\n+     * the file's content.\n@@ -813,1 +820,1 @@\n-     *                might affect the behavior of the returned memory mapped segment (see {@link MappedMemorySegment#force()}).\n+     *                might affect the behavior of the returned memory mapped segment (see {@link MemoryMapping#force()}).\n@@ -820,1 +827,1 @@\n-    static MappedMemorySegment mapFromPath(Path path, long bytesOffset, long bytesSize, FileChannel.MapMode mapMode) throws IOException {\n+    static MemorySegment mapFromPath(Path path, long bytesOffset, long bytesSize, FileChannel.MapMode mapMode) throws IOException {\n@@ -876,0 +883,116 @@\n+    \/\/ mapped segment support\n+\n+    \/**\n+     * A memory mapping represents an association between a mapped memory segment and the underlying file\n+     * descriptor associated with that segment. A memory mapping provides capabilities to manipulate memory-mapped\n+     * memory regions, such as {@link #force()} and {@link #load()}.\n+     * <p>\n+     * All implementations of this interface must be <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>;\n+     * use of identity-sensitive operations (including reference equality ({@code ==}), identity hash code, or synchronization) on\n+     * instances of {@code MemoryMapping} may have unpredictable results and should be avoided. The {@code equals} method should\n+     * be used for comparisons.\n+     * <p>\n+     * Non-platform classes should not implement {@linkplain MemoryMapping} directly.\n+     *\/\n+    interface MemoryMapping {\n+\n+        \/**\n+         * Obtains the memory segment associated with this memory mapping.\n+         * @return the memory segment associated with this memory mapping.\n+         * @throws IllegalStateException if this mapping's segment is not alive, or if this mapping's segment is confined\n+         * and this method is called from a thread other than the segment's owner thread.\n+         *\/\n+        MemorySegment segment();\n+\n+        \/**\n+         * Obtains the file descriptor associated with this memory mapping.\n+         * @return the file descriptor associated with this memory mapping.\n+         *\n+         * @throws IllegalStateException if this mapping's segment is not alive, or if this mapping's segment is confined\n+         * and this method is called from a thread other than the segment's owner thread.\n+         *\/\n+        FileDescriptor fileDescriptor();\n+\n+        \/**\n+         * Tells whether or not the contents of this mapping's segment is resident in physical\n+         * memory.\n+         *\n+         * <p> A return value of {@code true} implies that it is highly likely\n+         * that all of the data in this mapping's segment is resident in physical memory and\n+         * may therefore be accessed without incurring any virtual-memory page\n+         * faults or I\/O operations.  A return value of {@code false} does not\n+         * necessarily imply that the segment's content is not resident in physical\n+         * memory.\n+         *\n+         * <p> The returned value is a hint, rather than a guarantee, because the\n+         * underlying operating system may have paged out some of the segment's data\n+         * by the time that an invocation of this method returns.  <\/p>\n+         *\n+         * @return  {@code true} if it is likely that the contents of this mapping's segment\n+         *          is resident in physical memory\n+         *\n+         * @throws IllegalStateException if this mapping's segment is not alive, or if this mapping's segment is confined\n+         * and this method is called from a thread other than the segment's owner thread.\n+         *\/\n+        boolean isLoaded();\n+\n+        \/**\n+         * Loads the contents of this mapping's segment into physical memory.\n+         *\n+         * <p> This method makes a best effort to ensure that, when it returns,\n+         * this contents of this mapping's segment is resident in physical memory.  Invoking this\n+         * method may cause some number of page faults and I\/O operations to\n+         * occur. <\/p>\n+         *\n+         * @throws IllegalStateException if this mapping's segment is not alive, or if this mapping's segment is confined\n+         * and this method is called from a thread other than the segment's owner thread.\n+         *\/\n+        void load();\n+\n+        \/**\n+         * Unloads the contents of this mapping's segment from physical memory.\n+         *\n+         * <p> This method makes a best effort to ensure that the contents of this mapping's segment are\n+         * are no longer resident in physical memory. Accessing this segment's contents\n+         * after invoking this method may cause some number of page faults and I\/O operations to\n+         * occur (as this segment's contents might need to be paged back in). <\/p>\n+         *\n+         * @throws IllegalStateException if this mapping's segment is not alive, or if this mapping's segment is confined\n+         * and this method is called from a thread other than the segment's owner thread.\n+         *\/\n+        void unload();\n+\n+        \/**\n+         * Forces any changes made to the contents of this mapping's segment to be written to the\n+         * storage device described by this mapping's file descriptor.\n+         *\n+         * <p> If this mapping's file descriptor resides on a local storage\n+         * device then when this method returns it is guaranteed that all changes\n+         * made to the segment since it was created, or since this method was last\n+         * invoked, will have been written to that device.\n+         *\n+         * <p> If this mapping's file descriptor does not reside on a local device then no such guarantee\n+         * is made.\n+         *\n+         * <p> If this mapping's segment was not mapped in read\/write mode ({@link\n+         * java.nio.channels.FileChannel.MapMode#READ_WRITE}) then\n+         * invoking this method may have no effect. In particular, the\n+         * method has no effect for segments mapped in read-only or private\n+         * mapping modes. This method may or may not have an effect for\n+         * implementation-specific mapping modes.\n+         * <\/p>\n+         *\n+         * @throws IllegalStateException if this mapping's segment is not alive, or if this mapping's segment is confined\n+         * and this method is called from a thread other than the segment's owner thread.\n+         *\/\n+        void force();\n+    }\n+\n+    \/**\n+     * Obtain the memory mapping associated with this memory segment, assuming this segment is a mapped memory segment,\n+     * created using the {@link #mapFromPath(Path, long, long, FileChannel.MapMode)} factory, or a buffer segment\n+     * derived from a {@link java.nio.MappedByteBuffer} using the {@link #ofByteBuffer(ByteBuffer)} factory.\n+     * @return the memory mapping associated with this memory segment (if any).\n+     *\/\n+    Optional<MemoryMapping> mapping();\n+\n@@ -901,1 +1024,0 @@\n-     * (see {@link #spliterator(MemorySegment, SequenceLayout)}).\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":144,"deletions":22,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -42,5 +42,1 @@\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Random;\n-import java.util.Spliterator;\n+import java.util.*;\n@@ -115,4 +111,4 @@\n-    @SuppressWarnings(\"unchecked\")\n-    public static <S extends MemorySegment> Spliterator<S> spliterator(S segment, SequenceLayout sequenceLayout) {\n-        ((AbstractMemorySegmentImpl)segment).checkValidState();\n-        if (sequenceLayout.byteSize() != segment.byteSize()) {\n+    @Override\n+    public Spliterator<MemorySegment> spliterator(SequenceLayout sequenceLayout) {\n+        checkValidState();\n+        if (sequenceLayout.byteSize() != byteSize()) {\n@@ -121,2 +117,2 @@\n-        return (Spliterator<S>)new SegmentSplitter(sequenceLayout.elementLayout().byteSize(), sequenceLayout.elementCount().getAsLong(),\n-                (AbstractMemorySegmentImpl)segment.withAccessModes(segment.accessModes() & ~CLOSE));\n+        return new SegmentSplitter(sequenceLayout.elementLayout().byteSize(), sequenceLayout.elementCount().getAsLong(),\n+                withAccessModes(accessModes() & ~CLOSE));\n@@ -323,0 +319,5 @@\n+    @Override\n+    public Optional<MemoryMapping> mapping() {\n+        return Optional.empty();\n+    }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.incubator.foreign.MappedMemorySegment;\n+import jdk.incubator.foreign.MemorySegment;\n@@ -30,0 +30,1 @@\n+import jdk.internal.misc.ScopedMemoryAccess;\n@@ -32,0 +33,1 @@\n+import java.io.FileDescriptor;\n@@ -38,0 +40,1 @@\n+import java.util.Optional;\n@@ -45,1 +48,1 @@\n-public class MappedMemorySegmentImpl extends NativeMemorySegmentImpl implements MappedMemorySegment {\n+public class MappedMemorySegmentImpl extends NativeMemorySegmentImpl {\n@@ -49,0 +52,2 @@\n+    static ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n+\n@@ -78,7 +83,2 @@\n-    public void load() {\n-        nioAccess.load(min, unmapper.isSync(), length);\n-    }\n-\n-    @Override\n-    public void unload() {\n-        nioAccess.unload(min, unmapper.isSync(), length);\n+    public Optional<MemoryMapping> mapping() {\n+        return Optional.of(new MemoryMappingImpl());\n@@ -87,8 +87,31 @@\n-    @Override\n-    public boolean isLoaded() {\n-        return nioAccess.isLoaded(min, unmapper.isSync(), length);\n-    }\n-\n-    @Override\n-    public void force() {\n-        nioAccess.force(unmapper.fileDescriptor(), min, unmapper.isSync(), 0, length);\n+    class MemoryMappingImpl implements MemoryMapping {\n+\n+        @Override\n+        public FileDescriptor fileDescriptor() {\n+            return unmapper.fileDescriptor();\n+        }\n+\n+        @Override\n+        public MemorySegment segment() {\n+            return MappedMemorySegmentImpl.this;\n+        }\n+\n+        @Override\n+        public void load() {\n+            SCOPED_MEMORY_ACCESS.load(scope, min, unmapper.isSync(), length);\n+        }\n+\n+        @Override\n+        public void unload() {\n+            SCOPED_MEMORY_ACCESS.unload(scope, min, unmapper.isSync(), length);\n+        }\n+\n+        @Override\n+        public boolean isLoaded() {\n+            return SCOPED_MEMORY_ACCESS.isLoaded(scope, min, unmapper.isSync(), length);\n+        }\n+\n+        @Override\n+        public void force() {\n+            SCOPED_MEMORY_ACCESS.force(scope, unmapper.fileDescriptor(), min, unmapper.isSync(), 0, length);\n+        }\n@@ -99,1 +122,1 @@\n-    public static MappedMemorySegment makeMappedSegment(Path path, long bytesOffset, long bytesSize, FileChannel.MapMode mapMode) throws IOException {\n+    public static MemorySegment makeMappedSegment(Path path, long bytesOffset, long bytesSize, FileChannel.MapMode mapMode) throws IOException {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":41,"deletions":18,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.incubator.foreign.MappedMemorySegment;\n@@ -75,1 +74,0 @@\n-import jdk.internal.foreign.MemoryAddressImpl;\n@@ -230,1 +228,1 @@\n-        try (MappedMemorySegment segment = MemorySegment.mapFromPath(tempPath, 0L, 8, FileChannel.MapMode.READ_WRITE)) {\n+        try (MemorySegment segment = MemorySegment.mapFromPath(tempPath, 0L, 8, FileChannel.MapMode.READ_WRITE)) {\n@@ -235,1 +233,1 @@\n-        try (MappedMemorySegment segment = MemorySegment.mapFromPath(tempPath, 0L, 8, FileChannel.MapMode.READ_ONLY)) {\n+        try (MemorySegment segment = MemorySegment.mapFromPath(tempPath, 0L, 8, FileChannel.MapMode.READ_ONLY)) {\n@@ -248,1 +246,1 @@\n-        try (MappedMemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {\n+        try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {\n@@ -250,1 +248,1 @@\n-            segment.force();\n+            segment.mapping().ifPresent(MemoryMapping::force);\n@@ -259,0 +257,11 @@\n+    @Test(dataProvider = \"mappedOps\", expectedExceptions = IllegalStateException.class)\n+    public void testMappedSegmentOperations(MappedSegmentOp mappedBufferOp) throws Throwable {\n+        File f = new File(\"test3.out\");\n+        f.createNewFile();\n+        f.deleteOnExit();\n+\n+        MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, 8, FileChannel.MapMode.READ_WRITE);\n+        segment.close();\n+        mappedBufferOp.apply(segment);\n+    }\n+\n@@ -270,1 +279,1 @@\n-            try (MappedMemorySegment segment = MemorySegment.mapFromPath(f.toPath(), i, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {\n+            try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), i, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {\n@@ -272,1 +281,1 @@\n-                segment.force();\n+                segment.mapping().ifPresent(MemoryMapping::force);\n@@ -712,0 +721,28 @@\n+\n+    enum MappedSegmentOp {\n+        LOAD(m -> m.mapping().ifPresent(MemoryMapping::load)),\n+        UNLOAD(m -> m.mapping().ifPresent(MemoryMapping::unload)),\n+        IS_LOADED(m -> m.mapping().ifPresent(MemoryMapping::isLoaded)),\n+        FORCE(m -> m.mapping().ifPresent(MemoryMapping::force)),\n+        BUFFER_LOAD(m -> ((MappedByteBuffer)m.asByteBuffer()).load()),\n+        BUFFER_IS_LOADED(m -> ((MappedByteBuffer)m.asByteBuffer()).isLoaded()),\n+        BUFFER_FORCE(m -> ((MappedByteBuffer)m.asByteBuffer()).force());\n+\n+\n+        private Consumer<MemorySegment> segmentOp;\n+\n+        MappedSegmentOp(Consumer<MemorySegment> segmentOp) {\n+            this.segmentOp = segmentOp;\n+        }\n+\n+        void apply(MemorySegment segment) {\n+            segmentOp.accept(segment);\n+        }\n+    }\n+\n+    @DataProvider(name = \"mappedOps\")\n+    public static Object[][] mappedOps() {\n+        return Stream.of(MappedSegmentOp.values())\n+                .map(op -> new Object[] { op })\n+                .toArray(Object[][]::new);\n+    }\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":45,"deletions":8,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -331,0 +331,1 @@\n+                \"spliterator\",\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-            spliterators.add(MemorySegment.spliterator(s, layout));\n+            spliterators.add(s.spliterator(layout));\n","filename":"test\/jdk\/java\/foreign\/TestSharedAccess.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-        long parallelCounted = new SumSegmentCounted(null, MemorySegment.spliterator(segment, layout), threshold).invoke();\n+        long parallelCounted = new SumSegmentCounted(null, segment.spliterator(layout), threshold).invoke();\n@@ -75,1 +75,1 @@\n-        long parallelRecursive = new SumSegmentRecursive(MemorySegment.spliterator(segment, layout), threshold).invoke();\n+        long parallelRecursive = new SumSegmentRecursive(segment.spliterator(layout), threshold).invoke();\n@@ -78,1 +78,1 @@\n-        long streamParallel = StreamSupport.stream(MemorySegment.spliterator(segment, layout), true)\n+        long streamParallel = StreamSupport.stream(segment.spliterator(layout), true)\n@@ -96,1 +96,1 @@\n-        spliterator(segment.withAccessModes(MemorySegment.READ), layout)\n+        segment.withAccessModes(MemorySegment.READ).spliterator(layout)\n@@ -212,7 +212,7 @@\n-            () -> spliterator(mallocSegment.withAccessModes(ALL_ACCESS), layout), ALL_ACCESS,\n-            () -> spliterator(mallocSegment.withAccessModes(0), layout), 0,\n-            () -> spliterator(mallocSegment.withAccessModes(READ), layout), READ,\n-            () -> spliterator(mallocSegment.withAccessModes(CLOSE), layout), 0,\n-            () -> spliterator(mallocSegment.withAccessModes(READ|WRITE), layout), READ|WRITE,\n-            () -> spliterator(mallocSegment.withAccessModes(READ|WRITE| SHARE), layout), READ|WRITE| SHARE,\n-            () -> spliterator(mallocSegment.withAccessModes(READ|WRITE| SHARE |HANDOFF), layout), READ|WRITE| SHARE |HANDOFF\n+            () -> mallocSegment.withAccessModes(ALL_ACCESS).spliterator(layout), ALL_ACCESS,\n+            () -> mallocSegment.withAccessModes(0).spliterator(layout), 0,\n+            () -> mallocSegment.withAccessModes(READ).spliterator(layout), READ,\n+            () -> mallocSegment.withAccessModes(CLOSE).spliterator(layout), 0,\n+            () -> mallocSegment.withAccessModes(READ|WRITE).spliterator(layout), READ|WRITE,\n+            () -> mallocSegment.withAccessModes(READ|WRITE| SHARE).spliterator(layout), READ|WRITE| SHARE,\n+            () -> mallocSegment.withAccessModes(READ|WRITE| SHARE |HANDOFF).spliterator(layout), READ|WRITE| SHARE |HANDOFF\n","filename":"test\/jdk\/java\/foreign\/TestSpliterator.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"}]}