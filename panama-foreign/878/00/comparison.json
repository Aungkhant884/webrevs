{"files":[{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.reflect.Array;\n+import java.nio.ByteOrder;\n@@ -260,0 +260,32 @@\n+    \/**\n+     * Allocates a memory segment with the given layout and initializes it with the bytes in the provided\n+     * source memory segment.\n+     * @implSpec the default implementation for this method calls {@code this.allocate(elementLayout, elementCount)}.\n+     * @param elementLayout the value to be set on the newly allocated memory block.\n+     * @param source the source segment.\n+     * @param sourceElementLayout the element layout of the source segment.\n+     * @param sourceOffset the starting offset, in bytes, of the source segment.\n+     * @param srcElementCount the number of elements in the source segment to be copied.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if the element layouts have different sizes, if the source segment\/offset are\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the source\n+     * element layout, or if the source element layout alignment is greater than its size.\n+     * @throws IllegalStateException if the {@linkplain MemorySegment#scope() scope} associated with {@code source} is not\n+     * {@linkplain MemorySegment.Scope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code source.isAccessibleBy(T) == false}.\n+     * @throws IndexOutOfBoundsException if {@code elementCount * sourceElementLayout.byteSize()} overflows.\n+     * @throws IndexOutOfBoundsException if {@code sourceOffset > source.byteSize() - (elementCount * sourceElementLayout.byteSize())}.\n+     * @throws IndexOutOfBoundsException if either {@code sourceOffset} or {@code elementCount} are {@code < 0}.\n+     *\/\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout elementLayout, MemorySegment source,\n+                                       ValueLayout sourceElementLayout, long sourceOffset, long srcElementCount) {\n+        Objects.requireNonNull(source);\n+        Objects.requireNonNull(sourceElementLayout);\n+        Objects.requireNonNull(elementLayout);\n+        MemorySegment dest = allocateNoInit(elementLayout, srcElementCount);\n+        MemorySegment.copy(source, sourceElementLayout, sourceOffset, dest, elementLayout, 0, dest.byteSize());\n+        return dest;\n+    }\n+\n@@ -262,1 +294,6 @@\n-     * @implSpec the default implementation for this method calls {@code this.allocate(layout, array.length)}.\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   layout.withOrder(ByteOrder.nativeOrder()),\n+     *                   0, array.length)\n+     *}\n@@ -267,0 +304,1 @@\n+    @ForceInline\n@@ -268,1 +306,2 @@\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout);\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                elementLayout.withOrder(ByteOrder.nativeOrder()), 0, elements.length);\n@@ -273,1 +312,6 @@\n-     * @implSpec the default implementation for this method calls {@code this.allocate(layout, array.length)}.\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   layout.withOrder(ByteOrder.nativeOrder()),\n+     *                   0, array.length)\n+     *}\n@@ -278,0 +322,1 @@\n+    @ForceInline\n@@ -279,1 +324,2 @@\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout);\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                elementLayout.withOrder(ByteOrder.nativeOrder()), 0, elements.length);\n@@ -284,1 +330,6 @@\n-     * @implSpec the default implementation for this method calls {@code this.allocate(layout, array.length)}.\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   layout.withOrder(ByteOrder.nativeOrder()),\n+     *                   0, array.length)\n+     *}\n@@ -289,0 +340,1 @@\n+    @ForceInline\n@@ -290,1 +342,2 @@\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout);\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                elementLayout.withOrder(ByteOrder.nativeOrder()), 0, elements.length);\n@@ -295,1 +348,6 @@\n-     * @implSpec the default implementation for this method calls {@code this.allocate(layout, array.length)}.\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   layout.withOrder(ByteOrder.nativeOrder()),\n+     *                   0, array.length)\n+     *}\n@@ -300,0 +358,1 @@\n+    @ForceInline\n@@ -301,1 +360,2 @@\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout);\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                elementLayout.withOrder(ByteOrder.nativeOrder()), 0, elements.length);\n@@ -306,1 +366,6 @@\n-     * @implSpec the default implementation for this method calls {@code this.allocate(layout, array.length)}.\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   layout.withOrder(ByteOrder.nativeOrder()),\n+     *                   0, array.length)\n+     *}\n@@ -311,0 +376,1 @@\n+    @ForceInline\n@@ -312,1 +378,2 @@\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout);\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                elementLayout.withOrder(ByteOrder.nativeOrder()), 0, elements.length);\n@@ -317,1 +384,6 @@\n-     * @implSpec the default implementation for this method calls {@code this.allocate(layout, array.length)}.\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   layout.withOrder(ByteOrder.nativeOrder()),\n+     *                   0, array.length)\n+     *}\n@@ -322,0 +394,1 @@\n+    @ForceInline\n@@ -323,1 +396,2 @@\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout);\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                elementLayout.withOrder(ByteOrder.nativeOrder()), 0, elements.length);\n@@ -328,1 +402,6 @@\n-     * @implSpec the default implementation for this method calls {@code this.allocate(layout, array.length)}.\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   layout.withOrder(ByteOrder.nativeOrder()),\n+     *                   0, array.length)\n+     *}\n@@ -333,4 +412,0 @@\n-    default MemorySegment allocateFrom(ValueLayout.OfDouble elementLayout, double... elements) {\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout);\n-    }\n-\n@@ -338,5 +413,3 @@\n-    private MemorySegment copyArrayWithSwapIfNeeded(Object array, ValueLayout elementLayout) {\n-        int size = Array.getLength(Objects.requireNonNull(array));\n-        MemorySegment segment = allocateNoInit(Objects.requireNonNull(elementLayout), size);\n-        MemorySegment.copy(array, 0, segment, elementLayout, 0, size);\n-        return segment;\n+    default MemorySegment allocateFrom(ValueLayout.OfDouble elementLayout, double... elements) {\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                elementLayout.withOrder(ByteOrder.nativeOrder()), 0, elements.length);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":96,"deletions":23,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+public class AllocFromSliceTest extends CLayouts {\n+\n+    @Param({\"5\", \"20\", \"100\", \"500\", \"1000\"})\n+    public int size;\n+    public int start;\n+    public byte[] arr;\n+\n+    @Setup\n+    public void setup() {\n+        arr = new byte[1024];\n+        Random random = new Random(0);\n+        random.nextBytes(arr);\n+        start = random.nextInt(1024 - size);\n+    }\n+\n+    @Benchmark\n+    public MemorySegment alloc_confined() {\n+        Arena arena = Arena.ofConfined();\n+        MemorySegment segment = arena.allocate(size);\n+        MemorySegment.copy(arr, start, segment, C_CHAR, 0, size);\n+        arena.close();\n+        return segment;\n+    }\n+\n+    @Benchmark\n+    public MemorySegment alloc_confined_slice() {\n+        Arena arena = Arena.ofConfined();\n+        MemorySegment segment = arena.allocateFrom(C_CHAR, MemorySegment.ofArray(arr), C_CHAR, start, size);\n+        arena.close();\n+        return segment;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/AllocFromSliceTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"}]}