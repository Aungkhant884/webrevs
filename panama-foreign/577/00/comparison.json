{"files":[{"patch":"@@ -407,1 +407,0 @@\n-     * @param name the bitfields group declaration name.\n@@ -412,1 +411,1 @@\n-    static Declaration.Scoped bitfields(Position pos, String name, MemoryLayout layout, Declaration.Variable... bitfields) {\n+    static Declaration.Scoped bitfields(Position pos, MemoryLayout layout, Declaration.Variable... bitfields) {\n@@ -414,1 +413,1 @@\n-        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.BITFIELDS, layout, declList, name, pos);\n+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.BITFIELDS, layout, declList, \"\", pos);\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/incubator\/jextract\/Declaration.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.incubator.foreign.CLinker;\n@@ -32,1 +31,1 @@\n-import jdk.internal.jextract.impl.LayoutUtils;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -99,1 +98,1 @@\n-            Bool(\"_Bool\", CLinker.C_CHAR),\n+            Bool(\"_Bool\", ValueLayout.JAVA_BOOLEAN),\n@@ -103,1 +102,1 @@\n-            Char(\"char\", CLinker.C_CHAR),\n+            Char(\"char\", ValueLayout.JAVA_BYTE),\n@@ -111,1 +110,1 @@\n-            Short(\"short\", CLinker.C_SHORT),\n+            Short(\"short\", ValueLayout.JAVA_SHORT),\n@@ -115,1 +114,1 @@\n-            Int(\"int\", CLinker.C_INT),\n+            Int(\"int\", ValueLayout.JAVA_INT),\n@@ -119,1 +118,1 @@\n-            Long(\"long\", CLinker.C_LONG),\n+            Long(\"long\", TypeImpl.IS_WINDOWS ? ValueLayout.JAVA_INT : ValueLayout.JAVA_LONG),\n@@ -123,1 +122,1 @@\n-            LongLong(\"long long\", CLinker.C_LONG_LONG),\n+            LongLong(\"long long\", ValueLayout.JAVA_LONG),\n@@ -131,1 +130,1 @@\n-            Float(\"float\", CLinker.C_FLOAT),\n+            Float(\"float\", ValueLayout.JAVA_FLOAT),\n@@ -135,1 +134,1 @@\n-            Double(\"double\",CLinker.C_DOUBLE),\n+            Double(\"double\", ValueLayout.JAVA_DOUBLE),\n@@ -383,1 +382,1 @@\n-        return LayoutUtils.getLayout(t);\n+        return TypeImpl.getLayout(t);\n@@ -392,1 +391,1 @@\n-        return LayoutUtils.getDescriptor(function);\n+        return TypeImpl.getDescriptor(function);\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/incubator\/jextract\/Type.java","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -113,1 +114,1 @@\n-        return new Type(Index_h.clang_getCursorType(ResourceScope.newImplicitScope(), cursor));\n+        return new Type(Index_h.clang_getCursorType(ResourceScope.newConfinedScope(), cursor));\n@@ -117,1 +118,1 @@\n-        return new Type(Index_h.clang_getEnumDeclIntegerType(ResourceScope.newImplicitScope(), cursor));\n+        return new Type(Index_h.clang_getEnumDeclIntegerType(ResourceScope.newConfinedScope(), cursor));\n@@ -121,1 +122,1 @@\n-        return new Cursor(Index_h.clang_getCursorDefinition(ResourceScope.newImplicitScope(), cursor));\n+        return new Cursor(Index_h.clang_getCursorDefinition(ResourceScope.newConfinedScope(), cursor));\n@@ -125,1 +126,1 @@\n-        MemorySegment loc = Index_h.clang_getCursorLocation(ResourceScope.newImplicitScope(), cursor);\n+        MemorySegment loc = Index_h.clang_getCursorLocation(ResourceScope.newConfinedScope(), cursor);\n@@ -135,1 +136,1 @@\n-        MemorySegment range = Index_h.clang_getCursorExtent(ResourceScope.newImplicitScope(), cursor);\n+        MemorySegment range = Index_h.clang_getCursorExtent(ResourceScope.newConfinedScope(), cursor);\n@@ -147,1 +148,1 @@\n-        return new Cursor(Index_h.clang_Cursor_getArgument(ResourceScope.newImplicitScope(), cursor, idx));\n+        return new Cursor(Index_h.clang_Cursor_getArgument(ResourceScope.newConfinedScope(), cursor, idx));\n@@ -184,1 +185,1 @@\n-        return new Cursor(Index_h.clang_getCursorReferenced(ResourceScope.newImplicitScope(), cursor));\n+        return new Cursor(Index_h.clang_getCursorReferenced(ResourceScope.newConfinedScope(), cursor));\n@@ -189,2 +190,2 @@\n-        private static final MemoryAddress callback = CXCursorVisitor.allocate((c, p, d) -> {\n-            MemorySegment copy = MemorySegment.allocateNative(c.byteSize(), ResourceScope.newImplicitScope());\n+        private static final Addressable callback = CXCursorVisitor.allocate((c, p, d) -> {\n+            MemorySegment copy = MemorySegment.allocateNative(c.byteSize(), ResourceScope.newConfinedScope());\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/Cursor.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-        return new SourceLocation(Index_h.clang_getDiagnosticLocation(ResourceScope.newImplicitScope(), ptr));\n+        return new SourceLocation(Index_h.clang_getDiagnosticLocation(ResourceScope.newConfinedScope(), ptr));\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/Diagnostic.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -94,1 +95,1 @@\n-        return CLinker.toJavaString(value);\n+        return value.getUtf8String(0);\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/EvalResult.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -45,0 +44,2 @@\n+import static jdk.internal.clang.libclang.CLayouts.C_POINTER;\n+\n@@ -82,3 +83,0 @@\n-    private static final VarHandle VH_MemoryAddress =\n-            MemoryHandles.asAddressVarHandle(CLinker.C_POINTER.varHandle(long.class));\n-\n@@ -88,3 +86,2 @@\n-            SegmentAllocator allocator = SegmentAllocator.ofScope(scope);\n-            MemorySegment src = CLinker.toCString(file, scope);\n-            MemorySegment cargs = args.length == 0 ? null : allocator.allocateArray(CLinker.C_POINTER, args.length);\n+            MemorySegment src = scope.allocateUtf8String(file);\n+            MemorySegment cargs = args.length == 0 ? null : scope.allocateArray(C_POINTER, args.length);\n@@ -92,1 +89,1 @@\n-                MemoryAccess.setAddressAtIndex(cargs, i, CLinker.toCString(args[i], scope));\n+                cargs.set(C_POINTER, i * C_POINTER.byteSize(), scope.allocateUtf8String(args[i]));\n@@ -94,1 +91,1 @@\n-            MemorySegment outAddress = allocator.allocate(CLinker.C_POINTER);\n+            MemorySegment outAddress = scope.allocate(C_POINTER);\n@@ -104,1 +101,1 @@\n-            MemoryAddress tu = (MemoryAddress) VH_MemoryAddress.get(outAddress);\n+            MemoryAddress tu = outAddress.get(C_POINTER, 0);\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/Index.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -38,0 +39,3 @@\n+import static jdk.internal.clang.libclang.CLayouts.C_INT;\n+import static jdk.internal.clang.libclang.CLayouts.C_POINTER;\n+\n@@ -44,1 +48,1 @@\n-            CLinker.toCString(\"LIBCLANG_DISABLE_CRASH_RECOVERY=\" + CRASH_RECOVERY, ResourceScope.newImplicitScope());\n+            ResourceScope.newConfinedScope().allocateUtf8String(\"LIBCLANG_DISABLE_CRASH_RECOVERY=\" + CRASH_RECOVERY);\n@@ -51,1 +55,1 @@\n-                CLinker linker = CLinker.getInstance();\n+                CLinker linker = CLinker.systemCLinker();\n@@ -53,4 +57,3 @@\n-                MethodHandle PUT_ENV = linker.downcallHandle(CLinker.systemLookup().lookup(putenv).get(),\n-                                MethodType.methodType(int.class, MemoryAddress.class),\n-                                FunctionDescriptor.of(CLinker.C_INT, CLinker.C_POINTER));\n-                int res = (int) PUT_ENV.invokeExact(disableCrashRecovery.address());\n+                MethodHandle PUT_ENV = linker.downcallHandle(linker.lookup(putenv).get(),\n+                                FunctionDescriptor.of(C_INT, C_POINTER));\n+                int res = (int) PUT_ENV.invokeExact((Addressable)disableCrashRecovery);\n@@ -73,1 +76,1 @@\n-        String str = CLinker.toJavaString(buf);\n+        String str = buf.getUtf8String(0);\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/LibClang.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -40,0 +38,3 @@\n+import static jdk.internal.clang.libclang.CLayouts.C_INT;\n+import static jdk.internal.clang.libclang.CLayouts.C_POINTER;\n+\n@@ -57,4 +58,4 @@\n-             MemorySegment file = MemorySegment.allocateNative(CLinker.C_POINTER, scope);\n-             MemorySegment line = MemorySegment.allocateNative(CLinker.C_INT, scope);\n-             MemorySegment col = MemorySegment.allocateNative(CLinker.C_INT, scope);\n-             MemorySegment offset = MemorySegment.allocateNative(CLinker.C_INT, scope);\n+             MemorySegment file = MemorySegment.allocateNative(C_POINTER, scope);\n+             MemorySegment line = MemorySegment.allocateNative(C_INT, scope);\n+             MemorySegment col = MemorySegment.allocateNative(C_INT, scope);\n+             MemorySegment offset = MemorySegment.allocateNative(C_INT, scope);\n@@ -63,1 +64,1 @@\n-            MemoryAddress fname = MemoryAccess.getAddress(file);\n+            MemoryAddress fname = file.get(C_POINTER, 0);\n@@ -66,2 +67,2 @@\n-            return new Location(str, MemoryAccess.getInt(line),\n-                MemoryAccess.getInt(col), MemoryAccess.getInt(offset));\n+            return new Location(str, line.get(C_INT, 0),\n+                col.get(C_INT, 0), offset.get(C_INT, 0));\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/SourceLocation.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-        MemorySegment loc = Index_h.clang_getRangeStart(ResourceScope.newImplicitScope(), range);\n+        MemorySegment loc = Index_h.clang_getRangeStart(ResourceScope.newConfinedScope(), range);\n@@ -45,1 +45,1 @@\n-        MemorySegment loc = Index_h.clang_getRangeEnd(ResourceScope.newImplicitScope(), range);\n+        MemorySegment loc = Index_h.clang_getRangeEnd(ResourceScope.newConfinedScope(), range);\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/SourceRange.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -45,0 +44,3 @@\n+import static jdk.internal.clang.libclang.CLayouts.C_INT;\n+import static jdk.internal.clang.libclang.CLayouts.C_POINTER;\n+\n@@ -54,1 +56,1 @@\n-        return new Cursor(Index_h.clang_getTranslationUnitCursor(ResourceScope.newImplicitScope(), tu));\n+        return new Cursor(Index_h.clang_getTranslationUnitCursor(ResourceScope.newConfinedScope(), tu));\n@@ -70,1 +72,1 @@\n-            MemorySegment pathStr = CLinker.toCString(path.toAbsolutePath().toString(), scope);\n+            MemorySegment pathStr = scope.allocateUtf8String(path.toAbsolutePath().toString());\n@@ -91,1 +93,0 @@\n-            SegmentAllocator allocator = SegmentAllocator.ofScope(scope);\n@@ -94,1 +95,1 @@\n-                    allocator.allocateArray(CXUnsavedFile.$LAYOUT(), inMemoryFiles.length);\n+                    scope.allocateArray(CXUnsavedFile.$LAYOUT(), inMemoryFiles.length);\n@@ -97,3 +98,3 @@\n-                MemoryAccess.setAddress(start.asSlice(FILENAME_OFFSET), CLinker.toCString(inMemoryFiles[i].file, scope));\n-                MemoryAccess.setAddress(start.asSlice(CONTENTS_OFFSET), CLinker.toCString(inMemoryFiles[i].contents, scope));\n-                MemoryAccess.setLong(start.asSlice(LENGTH_OFFSET), inMemoryFiles[i].contents.length());\n+                start.set(C_POINTER, FILENAME_OFFSET, scope.allocateUtf8String(inMemoryFiles[i].file));\n+                start.set(C_POINTER, CONTENTS_OFFSET, scope.allocateUtf8String(inMemoryFiles[i].contents));\n+                start.set(C_INT, LENGTH_OFFSET, inMemoryFiles[i].contents.length());\n@@ -129,2 +130,2 @@\n-            MemorySegment p = MemorySegment.allocateNative(CLinker.C_POINTER, scope);\n-            MemorySegment pCnt = MemorySegment.allocateNative(CLinker.C_INT, scope);\n+            MemorySegment p = MemorySegment.allocateNative(C_POINTER, scope);\n+            MemorySegment pCnt = MemorySegment.allocateNative(C_INT, scope);\n@@ -132,1 +133,1 @@\n-            Tokens rv = new Tokens(MemoryAccess.getAddress(p), MemoryAccess.getInt(pCnt));\n+            Tokens rv = new Tokens(p.get(C_POINTER, 0), pCnt.get(C_INT, 0));\n@@ -168,1 +169,1 @@\n-            return p.asSegment(CXToken.$LAYOUT().byteSize(), ResourceScope.newImplicitScope());\n+            return MemorySegment.ofAddressNative(p, CXToken.$LAYOUT().byteSize(), ResourceScope.newConfinedScope());\n@@ -213,1 +214,1 @@\n-                ResourceScope.newImplicitScope(), tu, token));\n+                ResourceScope.newConfinedScope(), tu, token));\n@@ -217,1 +218,1 @@\n-            return new SourceRange(Index_h.clang_getTokenExtent(ResourceScope.newImplicitScope(),\n+            return new SourceRange(Index_h.clang_getTokenExtent(ResourceScope.newConfinedScope(),\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/TranslationUnit.java","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-        return new Type(Index_h.clang_getResultType(ResourceScope.newImplicitScope(), type));\n+        return new Type(Index_h.clang_getResultType(ResourceScope.newConfinedScope(), type));\n@@ -57,1 +57,1 @@\n-        return new Type(Index_h.clang_getArgType(ResourceScope.newImplicitScope(), type, idx));\n+        return new Type(Index_h.clang_getArgType(ResourceScope.newConfinedScope(), type, idx));\n@@ -89,1 +89,1 @@\n-        return new Type(Index_h.clang_getPointeeType(ResourceScope.newImplicitScope(), type));\n+        return new Type(Index_h.clang_getPointeeType(ResourceScope.newConfinedScope(), type));\n@@ -94,1 +94,1 @@\n-        return new Type(Index_h.clang_getElementType(ResourceScope.newImplicitScope(), type));\n+        return new Type(Index_h.clang_getElementType(ResourceScope.newConfinedScope(), type));\n@@ -104,1 +104,1 @@\n-            MemorySegment cfname = CLinker.toCString(fieldName, scope);\n+            MemorySegment cfname = scope.allocateUtf8String(fieldName);\n@@ -127,1 +127,1 @@\n-        return new Type(Index_h.clang_getCanonicalType(ResourceScope.newImplicitScope(), type));\n+        return new Type(Index_h.clang_getCanonicalType(ResourceScope.newConfinedScope(), type));\n@@ -178,1 +178,1 @@\n-        return new Cursor(Index_h.clang_getTypeDeclaration(ResourceScope.newImplicitScope(), type));\n+        return new Cursor(Index_h.clang_getTypeDeclaration(ResourceScope.newConfinedScope(), type));\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/Type.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,14 @@\n+package jdk.internal.clang.libclang;\n+\n+import jdk.incubator.foreign.ValueLayout;\n+\n+public class CLayouts {\n+    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n+    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n+    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;\n+    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;\n+    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;\n+    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;\n+    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;\n+    public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS;\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/CLayouts.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"added"},{"patch":"@@ -38,1 +38,1 @@\n-    static MemoryAddress allocate(CXCursorVisitor fi) {\n+    static Addressable allocate(CXCursorVisitor fi) {\n@@ -41,1 +41,1 @@\n-    static MemoryAddress allocate(CXCursorVisitor fi, ResourceScope scope) {\n+    static Addressable allocate(CXCursorVisitor fi, ResourceScope scope) {\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/CXCursorVisitor.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,3 @@\n+import static jdk.internal.clang.libclang.CLayouts.C_INT;\n+import static jdk.internal.clang.libclang.CLayouts.C_POINTER;\n+\n@@ -47,1 +50,1 @@\n-    static final VarHandle ptr_data$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"ptr_data\")));\n+    static final VarHandle ptr_data$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"ptr_data\"));\n@@ -65,1 +68,0 @@\n-    public static MemorySegment allocate(ResourceScope scope) { return allocate(SegmentAllocator.ofScope(scope)); }\n@@ -69,3 +71,0 @@\n-    public static MemorySegment allocateArray(int len, ResourceScope scope) {\n-        return allocateArray(len, SegmentAllocator.ofScope(scope));\n-    }\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/CXToken.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -35,0 +35,3 @@\n+import static jdk.internal.clang.libclang.CLayouts.C_INT;\n+import static jdk.internal.clang.libclang.CLayouts.C_POINTER;\n+\n@@ -45,1 +48,1 @@\n-    static final VarHandle kind$VH = $struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"kind\"));\n+    static final VarHandle kind$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"kind\"));\n@@ -66,1 +69,0 @@\n-    public static MemorySegment allocate(ResourceScope scope) { return allocate(SegmentAllocator.ofScope(scope)); }\n@@ -70,3 +72,0 @@\n-    public static MemorySegment allocateArray(int len, ResourceScope scope) {\n-        return allocateArray(len, SegmentAllocator.ofScope(scope));\n-    }\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/CXType.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -35,0 +35,3 @@\n+import static jdk.internal.clang.libclang.CLayouts.C_LONG_LONG;\n+import static jdk.internal.clang.libclang.CLayouts.C_POINTER;\n+\n@@ -45,1 +48,1 @@\n-    static final VarHandle Filename$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"Filename\")));\n+    static final VarHandle Filename$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"Filename\"));\n@@ -61,1 +64,1 @@\n-    static final VarHandle Contents$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"Contents\")));\n+    static final VarHandle Contents$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"Contents\"));\n@@ -77,1 +80,1 @@\n-    static final VarHandle Length$VH = $struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"Length\"));\n+    static final VarHandle Length$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"Length\"));\n@@ -95,1 +98,0 @@\n-    public static MemorySegment allocate(ResourceScope scope) { return allocate(SegmentAllocator.ofScope(scope)); }\n@@ -99,3 +101,0 @@\n-    public static MemorySegment allocateArray(int len, ResourceScope scope) {\n-        return allocateArray(len, SegmentAllocator.ofScope(scope));\n-    }\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/CXUnsavedFile.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-            mh$.invokeExact(index.address());\n+            mh$.invokeExact(index);\n@@ -145,1 +145,1 @@\n-            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, SFile.address());\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, SFile);\n@@ -150,3 +150,0 @@\n-    public static MemorySegment clang_getFileName ( ResourceScope scope,  Addressable SFile) {\n-        return clang_getFileName(SegmentAllocator.ofScope(scope), SFile.address());\n-    }\n@@ -164,3 +161,0 @@\n-    public static MemorySegment clang_getNullLocation ( ResourceScope scope) {\n-        return clang_getNullLocation(SegmentAllocator.ofScope(scope));\n-    }\n@@ -184,1 +178,1 @@\n-            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, tu.address(), file.address(), line, column);\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, tu, file, line, column);\n@@ -189,3 +183,0 @@\n-    public static MemorySegment clang_getLocation ( ResourceScope scope,  Addressable tu,  Addressable file,  int line,  int column) {\n-        return clang_getLocation(SegmentAllocator.ofScope(scope), tu.address(), file.address(), line, column);\n-    }\n@@ -198,1 +189,1 @@\n-            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, tu.address(), file.address(), offset);\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, tu, file, offset);\n@@ -203,3 +194,0 @@\n-    public static MemorySegment clang_getLocationForOffset ( ResourceScope scope,  Addressable tu,  Addressable file,  int offset) {\n-        return clang_getLocationForOffset(SegmentAllocator.ofScope(scope), tu.address(), file.address(), offset);\n-    }\n@@ -245,1 +233,1 @@\n-            mh$.invokeExact(location, file.address(), line.address(), column.address(), offset.address());\n+            mh$.invokeExact(location, file, line, column, offset);\n@@ -256,1 +244,1 @@\n-            mh$.invokeExact(location, file.address(), line.address(), column.address(), offset.address());\n+            mh$.invokeExact(location, file, line, column, offset);\n@@ -267,1 +255,1 @@\n-            mh$.invokeExact(location, file.address(), line.address(), column.address(), offset.address());\n+            mh$.invokeExact(location, file, line, column, offset);\n@@ -283,3 +271,0 @@\n-    public static MemorySegment clang_getRangeStart ( ResourceScope scope,  MemorySegment range) {\n-        return clang_getRangeStart(SegmentAllocator.ofScope(scope), range);\n-    }\n@@ -297,3 +282,0 @@\n-    public static MemorySegment clang_getRangeEnd ( ResourceScope scope,  MemorySegment range) {\n-        return clang_getRangeEnd(SegmentAllocator.ofScope(scope), range);\n-    }\n@@ -321,1 +303,1 @@\n-            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(D.address());\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(D);\n@@ -332,1 +314,1 @@\n-            return (int)mh$.invokeExact(Unit.address());\n+            return (int)mh$.invokeExact(Unit);\n@@ -343,1 +325,1 @@\n-            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(Unit.address(), Index);\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(Unit, Index);\n@@ -354,1 +336,1 @@\n-            mh$.invokeExact(Diagnostic.address());\n+            mh$.invokeExact(Diagnostic);\n@@ -383,1 +365,1 @@\n-            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, Diagnostic.address(), Options);\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, Diagnostic, Options);\n@@ -388,3 +370,0 @@\n-    public static MemorySegment clang_formatDiagnostic ( ResourceScope scope,  Addressable Diagnostic,  int Options) {\n-        return clang_formatDiagnostic(SegmentAllocator.ofScope(scope), Diagnostic.address(), Options);\n-    }\n@@ -408,1 +387,1 @@\n-            return (int)mh$.invokeExact(x0.address());\n+            return (int)mh$.invokeExact(x0);\n@@ -419,1 +398,1 @@\n-            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, x1.address());\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n@@ -424,3 +403,0 @@\n-    public static MemorySegment clang_getDiagnosticLocation ( ResourceScope scope,  Addressable x1) {\n-        return clang_getDiagnosticLocation(SegmentAllocator.ofScope(scope), x1.address());\n-    }\n@@ -433,1 +409,1 @@\n-            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, x1.address());\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n@@ -438,3 +414,0 @@\n-    public static MemorySegment clang_getDiagnosticSpelling ( ResourceScope scope,  Addressable x1) {\n-        return clang_getDiagnosticSpelling(SegmentAllocator.ofScope(scope), x1.address());\n-    }\n@@ -498,1 +471,1 @@\n-            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(CIdx.address(), source_filename.address(), command_line_args.address(), num_command_line_args, unsaved_files.address(), num_unsaved_files, options);\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(CIdx, source_filename, command_line_args, num_command_line_args, unsaved_files, num_unsaved_files, options);\n@@ -509,1 +482,1 @@\n-            return (int)mh$.invokeExact(CIdx.address(), source_filename.address(), command_line_args.address(), num_command_line_args, unsaved_files.address(), num_unsaved_files, options, out_TU.address());\n+            return (int)mh$.invokeExact(CIdx, source_filename, command_line_args, num_command_line_args, unsaved_files, num_unsaved_files, options, out_TU);\n@@ -535,1 +508,1 @@\n-            return (int)mh$.invokeExact(TU.address(), FileName.address(), options);\n+            return (int)mh$.invokeExact(TU, FileName, options);\n@@ -546,1 +519,1 @@\n-            mh$.invokeExact(x0.address());\n+            mh$.invokeExact(x0);\n@@ -560,1 +533,1 @@\n-            return (int)mh$.invokeExact(TU.address());\n+            return (int)mh$.invokeExact(TU);\n@@ -571,1 +544,1 @@\n-            return (int)mh$.invokeExact(TU.address(), num_unsaved_files, unsaved_files.address(), options);\n+            return (int)mh$.invokeExact(TU, num_unsaved_files, unsaved_files, options);\n@@ -1364,3 +1337,0 @@\n-    public static MemorySegment clang_getNullCursor ( ResourceScope scope) {\n-        return clang_getNullCursor(SegmentAllocator.ofScope(scope));\n-    }\n@@ -1373,1 +1343,1 @@\n-            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, x1.address());\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n@@ -1378,3 +1348,0 @@\n-    public static MemorySegment clang_getTranslationUnitCursor ( ResourceScope scope,  Addressable x1) {\n-        return clang_getTranslationUnitCursor(SegmentAllocator.ofScope(scope), x1.address());\n-    }\n@@ -1503,3 +1470,0 @@\n-    public static MemorySegment clang_getCursorLocation ( ResourceScope scope,  MemorySegment x1) {\n-        return clang_getCursorLocation(SegmentAllocator.ofScope(scope), x1);\n-    }\n@@ -1517,3 +1481,0 @@\n-    public static MemorySegment clang_getCursorExtent ( ResourceScope scope,  MemorySegment x1) {\n-        return clang_getCursorExtent(SegmentAllocator.ofScope(scope), x1);\n-    }\n@@ -1945,3 +1906,0 @@\n-    public static MemorySegment clang_getCursorType ( ResourceScope scope,  MemorySegment C) {\n-        return clang_getCursorType(SegmentAllocator.ofScope(scope), C);\n-    }\n@@ -1959,3 +1917,0 @@\n-    public static MemorySegment clang_getTypeSpelling ( ResourceScope scope,  MemorySegment CT) {\n-        return clang_getTypeSpelling(SegmentAllocator.ofScope(scope), CT);\n-    }\n@@ -1973,3 +1928,0 @@\n-    public static MemorySegment clang_getTypedefDeclUnderlyingType ( ResourceScope scope,  MemorySegment C) {\n-        return clang_getTypedefDeclUnderlyingType(SegmentAllocator.ofScope(scope), C);\n-    }\n@@ -1987,3 +1939,0 @@\n-    public static MemorySegment clang_getEnumDeclIntegerType ( ResourceScope scope,  MemorySegment C) {\n-        return clang_getEnumDeclIntegerType(SegmentAllocator.ofScope(scope), C);\n-    }\n@@ -2045,3 +1994,0 @@\n-    public static MemorySegment clang_Cursor_getArgument ( ResourceScope scope,  MemorySegment C,  int i) {\n-        return clang_Cursor_getArgument(SegmentAllocator.ofScope(scope), C, i);\n-    }\n@@ -2070,3 +2016,0 @@\n-    public static MemorySegment clang_getCanonicalType ( ResourceScope scope,  MemorySegment T) {\n-        return clang_getCanonicalType(SegmentAllocator.ofScope(scope), T);\n-    }\n@@ -2117,3 +2060,0 @@\n-    public static MemorySegment clang_getTypedefName ( ResourceScope scope,  MemorySegment CT) {\n-        return clang_getTypedefName(SegmentAllocator.ofScope(scope), CT);\n-    }\n@@ -2131,3 +2071,0 @@\n-    public static MemorySegment clang_getPointeeType ( ResourceScope scope,  MemorySegment T) {\n-        return clang_getPointeeType(SegmentAllocator.ofScope(scope), T);\n-    }\n@@ -2145,3 +2082,0 @@\n-    public static MemorySegment clang_getTypeDeclaration ( ResourceScope scope,  MemorySegment T) {\n-        return clang_getTypeDeclaration(SegmentAllocator.ofScope(scope), T);\n-    }\n@@ -2159,3 +2093,0 @@\n-    public static MemorySegment clang_getTypeKindSpelling ( ResourceScope scope,  int K) {\n-        return clang_getTypeKindSpelling(SegmentAllocator.ofScope(scope), K);\n-    }\n@@ -2184,3 +2115,0 @@\n-    public static MemorySegment clang_getResultType ( ResourceScope scope,  MemorySegment T) {\n-        return clang_getResultType(SegmentAllocator.ofScope(scope), T);\n-    }\n@@ -2209,3 +2137,0 @@\n-    public static MemorySegment clang_getArgType ( ResourceScope scope,  MemorySegment T,  int i) {\n-        return clang_getArgType(SegmentAllocator.ofScope(scope), T, i);\n-    }\n@@ -2234,3 +2159,0 @@\n-    public static MemorySegment clang_getCursorResultType ( ResourceScope scope,  MemorySegment C) {\n-        return clang_getCursorResultType(SegmentAllocator.ofScope(scope), C);\n-    }\n@@ -2248,3 +2170,0 @@\n-    public static MemorySegment clang_getElementType ( ResourceScope scope,  MemorySegment T) {\n-        return clang_getElementType(SegmentAllocator.ofScope(scope), T);\n-    }\n@@ -2273,3 +2192,0 @@\n-    public static MemorySegment clang_getArrayElementType ( ResourceScope scope,  MemorySegment T) {\n-        return clang_getArrayElementType(SegmentAllocator.ofScope(scope), T);\n-    }\n@@ -2334,1 +2250,1 @@\n-            return (long)mh$.invokeExact(T, S.address());\n+            return (long)mh$.invokeExact(T, S);\n@@ -2387,1 +2303,1 @@\n-            return (int)mh$.invokeExact(parent, visitor.address(), client_data.address());\n+            return (int)mh$.invokeExact(parent, visitor, client_data);\n@@ -2403,3 +2319,0 @@\n-    public static MemorySegment clang_getCursorUSR ( ResourceScope scope,  MemorySegment x1) {\n-        return clang_getCursorUSR(SegmentAllocator.ofScope(scope), x1);\n-    }\n@@ -2417,3 +2330,0 @@\n-    public static MemorySegment clang_getCursorSpelling ( ResourceScope scope,  MemorySegment x1) {\n-        return clang_getCursorSpelling(SegmentAllocator.ofScope(scope), x1);\n-    }\n@@ -2507,1 +2417,1 @@\n-            return (int)mh$.invokeExact(Policy.address(), Property);\n+            return (int)mh$.invokeExact(Policy, Property);\n@@ -2518,1 +2428,1 @@\n-            mh$.invokeExact(Policy.address(), Property, Value);\n+            mh$.invokeExact(Policy, Property, Value);\n@@ -2540,1 +2450,1 @@\n-            mh$.invokeExact(Policy.address());\n+            mh$.invokeExact(Policy);\n@@ -2551,1 +2461,1 @@\n-            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, Cursor, Policy.address());\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, Cursor, Policy);\n@@ -2556,3 +2466,0 @@\n-    public static MemorySegment clang_getCursorPrettyPrinted ( ResourceScope scope,  MemorySegment Cursor,  Addressable Policy) {\n-        return clang_getCursorPrettyPrinted(SegmentAllocator.ofScope(scope), Cursor, Policy.address());\n-    }\n@@ -2570,3 +2477,0 @@\n-    public static MemorySegment clang_getCursorDisplayName ( ResourceScope scope,  MemorySegment x1) {\n-        return clang_getCursorDisplayName(SegmentAllocator.ofScope(scope), x1);\n-    }\n@@ -2584,3 +2488,0 @@\n-    public static MemorySegment clang_getCursorReferenced ( ResourceScope scope,  MemorySegment x1) {\n-        return clang_getCursorReferenced(SegmentAllocator.ofScope(scope), x1);\n-    }\n@@ -2598,3 +2499,0 @@\n-    public static MemorySegment clang_getCursorDefinition ( ResourceScope scope,  MemorySegment x1) {\n-        return clang_getCursorDefinition(SegmentAllocator.ofScope(scope), x1);\n-    }\n@@ -2634,3 +2532,0 @@\n-    public static MemorySegment clang_Cursor_getMangling ( ResourceScope scope,  MemorySegment x1) {\n-        return clang_Cursor_getMangling(SegmentAllocator.ofScope(scope), x1);\n-    }\n@@ -2669,1 +2564,1 @@\n-            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, x1.address(), x2);\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, x1, x2);\n@@ -2674,3 +2569,0 @@\n-    public static MemorySegment clang_getTokenSpelling ( ResourceScope scope,  Addressable x1,  MemorySegment x2) {\n-        return clang_getTokenSpelling(SegmentAllocator.ofScope(scope), x1.address(), x2);\n-    }\n@@ -2683,1 +2575,1 @@\n-            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, x1.address(), x2);\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, x1, x2);\n@@ -2688,3 +2580,0 @@\n-    public static MemorySegment clang_getTokenLocation ( ResourceScope scope,  Addressable x1,  MemorySegment x2) {\n-        return clang_getTokenLocation(SegmentAllocator.ofScope(scope), x1.address(), x2);\n-    }\n@@ -2697,1 +2586,1 @@\n-            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, x1.address(), x2);\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, x1, x2);\n@@ -2702,3 +2591,0 @@\n-    public static MemorySegment clang_getTokenExtent ( ResourceScope scope,  Addressable x1,  MemorySegment x2) {\n-        return clang_getTokenExtent(SegmentAllocator.ofScope(scope), x1.address(), x2);\n-    }\n@@ -2711,1 +2597,1 @@\n-            mh$.invokeExact(TU.address(), Range, Tokens.address(), NumTokens.address());\n+            mh$.invokeExact(TU, Range, Tokens, NumTokens);\n@@ -2722,1 +2608,1 @@\n-            mh$.invokeExact(TU.address(), Tokens.address(), NumTokens);\n+            mh$.invokeExact(TU, Tokens, NumTokens);\n@@ -2738,3 +2624,0 @@\n-    public static MemorySegment clang_getCursorKindSpelling ( ResourceScope scope,  int Kind) {\n-        return clang_getCursorKindSpelling(SegmentAllocator.ofScope(scope), Kind);\n-    }\n@@ -2752,3 +2635,0 @@\n-    public static MemorySegment clang_getClangVersion ( ResourceScope scope) {\n-        return clang_getClangVersion(SegmentAllocator.ofScope(scope));\n-    }\n@@ -2783,1 +2663,1 @@\n-            return (int)mh$.invokeExact(E.address());\n+            return (int)mh$.invokeExact(E);\n@@ -2794,1 +2674,1 @@\n-            return (int)mh$.invokeExact(E.address());\n+            return (int)mh$.invokeExact(E);\n@@ -2805,1 +2685,1 @@\n-            return (long)mh$.invokeExact(E.address());\n+            return (long)mh$.invokeExact(E);\n@@ -2816,1 +2696,1 @@\n-            return (int)mh$.invokeExact(E.address());\n+            return (int)mh$.invokeExact(E);\n@@ -2827,1 +2707,1 @@\n-            return (long)mh$.invokeExact(E.address());\n+            return (long)mh$.invokeExact(E);\n@@ -2838,1 +2718,1 @@\n-            return (double)mh$.invokeExact(E.address());\n+            return (double)mh$.invokeExact(E);\n@@ -2849,1 +2729,1 @@\n-            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(E.address());\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(E);\n@@ -2860,1 +2740,1 @@\n-            mh$.invokeExact(E.address());\n+            mh$.invokeExact(E);\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/Index_h.java","additions":41,"deletions":161,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.GroupLayout;\n@@ -38,0 +39,2 @@\n+import jdk.incubator.foreign.ValueLayout;\n+\n@@ -49,0 +52,3 @@\n+import static jdk.internal.clang.libclang.CLayouts.C_DOUBLE;\n+import static jdk.internal.clang.libclang.CLayouts.C_LONG_LONG;\n+import static jdk.internal.clang.libclang.CLayouts.C_POINTER;\n@@ -52,1 +58,1 @@\n-    private final static CLinker LINKER = CLinker.getInstance();\n+    private final static CLinker LINKER = CLinker.systemCLinker();\n@@ -58,2 +64,1 @@\n-        SymbolLookup systemLookup = CLinker.systemLookup();\n-        return name -> loaderLookup.lookup(name).or(() -> systemLookup.lookup(name));\n+        return name -> loaderLookup.lookup(name).or(() -> LINKER.lookup(name));\n@@ -72,1 +77,1 @@\n-        return LOOKUP.lookup(name).map(s -> s.address().asSegment(layout.byteSize(), ResourceScope.newImplicitScope())).orElse(null);\n+        return LOOKUP.lookup(name).map(s -> MemorySegment.ofAddressNative(s.address(), layout.byteSize(), ResourceScope.newSharedScope())).orElse(null);\n@@ -78,1 +83,0 @@\n-                    MethodType mt = MethodType.fromMethodDescriptorString(desc, LOADER);\n@@ -80,2 +84,2 @@\n-                        VarargsInvoker.make(addr, mt, fdesc) :\n-                        LINKER.downcallHandle(addr, mt, fdesc);\n+                        VarargsInvoker.make(addr, fdesc) :\n+                        LINKER.downcallHandle(addr, fdesc);\n@@ -89,2 +93,1 @@\n-        MethodType mt = MethodType.fromMethodDescriptorString(desc, LOADER);\n-        return LINKER.downcallHandle(mt, fdesc);\n+        return LINKER.downcallHandle(fdesc);\n@@ -93,2 +96,2 @@\n-    static final <Z> MemoryAddress upcallStub(Class<Z> fi, Z z, FunctionDescriptor fdesc, String mtypeDesc) {\n-        return upcallStub(fi, z, fdesc, mtypeDesc, ResourceScope.newImplicitScope());\n+    static final <Z> UpcallStub upcallStub(Class<Z> fi, Z z, FunctionDescriptor fdesc, String mtypeDesc) {\n+        return upcallStub(fi, z, fdesc, mtypeDesc, ResourceScope.newConfinedScope());\n@@ -97,1 +100,1 @@\n-    static final <Z> MemoryAddress upcallStub(Class<Z> fi, Z z, FunctionDescriptor fdesc, String mtypeDesc, ResourceScope scope) {\n+    static final <Z> UpcallStub upcallStub(Class<Z> fi, Z z, FunctionDescriptor fdesc, String mtypeDesc, ResourceScope scope) {\n@@ -109,1 +112,1 @@\n-         return addr.asSegment(numElements * layout.byteSize(), scope);\n+         return MemorySegment.ofAddressNative(addr, numElements * layout.byteSize(), scope);\n@@ -117,1 +120,0 @@\n-        private final MethodType varargs;\n@@ -120,1 +122,1 @@\n-        private VarargsInvoker(Addressable symbol, MethodType type, FunctionDescriptor function) {\n+        private VarargsInvoker(Addressable symbol, FunctionDescriptor function) {\n@@ -122,1 +124,0 @@\n-            this.varargs = type;\n@@ -134,5 +135,10 @@\n-        static MethodHandle make(Addressable symbol, MethodType type, FunctionDescriptor function) {\n-            VarargsInvoker invoker = new VarargsInvoker(symbol, type, function);\n-            MethodHandle handle = INVOKE_MH.bindTo(invoker).asCollector(Object[].class, type.parameterCount());\n-            if (type.returnType().equals(MemorySegment.class)) {\n-                type = type.insertParameterTypes(0, SegmentAllocator.class);\n+        static MethodHandle make(Addressable symbol, FunctionDescriptor function) {\n+            VarargsInvoker invoker = new VarargsInvoker(symbol, function);\n+            MethodHandle handle = INVOKE_MH.bindTo(invoker).asCollector(Object[].class, function.argumentLayouts().size() + 1);\n+            MethodType mtype = MethodType.methodType(function.returnLayout().isPresent() ? carrier(function.returnLayout().get(), true) : void.class);\n+            for (MemoryLayout layout : function.argumentLayouts()) {\n+                mtype = mtype.appendParameterTypes(carrier(layout, false));\n+            }\n+            mtype = mtype.appendParameterTypes(Object[].class);\n+            if (mtype.returnType().equals(MemorySegment.class)) {\n+                mtype = mtype.insertParameterTypes(0, SegmentAllocator.class);\n@@ -142,1 +148,12 @@\n-            return handle.asType(type);\n+            return handle.asType(mtype);\n+        }\n+\n+        static Class<?> carrier(MemoryLayout layout, boolean ret) {\n+            if (layout instanceof ValueLayout valueLayout) {\n+                return (ret || valueLayout.carrier() != MemoryAddress.class) ?\n+                        valueLayout.carrier() : Addressable.class;\n+            } else if (layout instanceof GroupLayout) {\n+                return MemorySegment.class;\n+            } else {\n+                throw new AssertionError(\"Cannot get here!\");\n+            }\n@@ -158,1 +175,0 @@\n-                argTypes[pos] = varargs.parameterType(pos);\n@@ -164,2 +180,1 @@\n-                argTypes[pos] = normalize(o.getClass());\n-                argLayouts[pos] = variadicLayout(argTypes[pos]);\n+                argLayouts[pos] = variadicLayout(normalize(o.getClass()));\n@@ -170,1 +185,0 @@\n-            MethodType mt = MethodType.methodType(varargs.returnType(), argTypes);\n@@ -174,1 +188,4 @@\n-            MethodHandle mh = LINKER.downcallHandle(symbol, allocator, mt, f);\n+            MethodHandle mh = LINKER.downcallHandle(symbol, f);\n+            if (mh.type().returnType() == MemorySegment.class) {\n+                mh = mh.bindTo(allocator);\n+            }\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/RuntimeHelper.java","additions":44,"deletions":27,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+import static jdk.internal.clang.libclang.CLayouts.*;\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/constants$0.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+import static jdk.internal.clang.libclang.CLayouts.*;\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/constants$1.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import static jdk.internal.clang.libclang.CLayouts.*;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/constants$10.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import static jdk.internal.clang.libclang.CLayouts.*;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/constants$11.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import static jdk.internal.clang.libclang.CLayouts.*;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/constants$12.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import static jdk.internal.clang.libclang.CLayouts.*;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/constants$13.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import static jdk.internal.clang.libclang.CLayouts.*;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/constants$14.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import static jdk.internal.clang.libclang.CLayouts.*;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/constants$15.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import static jdk.internal.clang.libclang.CLayouts.*;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/constants$16.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import static jdk.internal.clang.libclang.CLayouts.*;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/constants$17.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import static jdk.internal.clang.libclang.CLayouts.*;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/constants$18.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import static jdk.internal.clang.libclang.CLayouts.*;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/constants$2.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import static jdk.internal.clang.libclang.CLayouts.*;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/constants$3.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import static jdk.internal.clang.libclang.CLayouts.*;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/constants$4.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import static jdk.internal.clang.libclang.CLayouts.*;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/constants$5.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import static jdk.internal.clang.libclang.CLayouts.*;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/constants$6.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import static jdk.internal.clang.libclang.CLayouts.*;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/constants$7.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import static jdk.internal.clang.libclang.CLayouts.*;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/constants$8.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import static jdk.internal.clang.libclang.CLayouts.*;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/constants$9.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -192,1 +192,1 @@\n-            append(\"import static jdk.incubator.foreign.CLinker.*;\\n\");\n+            append(\"import static jdk.incubator.foreign.ValueLayout.*;\\n\");\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/ClassSourceBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -198,1 +198,1 @@\n-            append(toplevel().headerClassName() + \".LIBRARIES, \\\"\" + nativeName + \"\\\"\");\n+            append(\"\\\"\" + nativeName + \"\\\"\");\n@@ -202,2 +202,0 @@\n-        append(\"\\\"\" + functionInfo.methodType().toMethodDescriptorString() + \"\\\",\\n\");\n-        indent();\n@@ -223,4 +221,0 @@\n-        boolean isAddr = typeName.contains(\"MemoryAddress\");\n-        if (isAddr) {\n-            typeName = \"long\";\n-        }\n@@ -230,3 +224,0 @@\n-        if (isAddr) {\n-            append(\"MemoryHandles.asAddressVarHandle(\");\n-        }\n@@ -234,1 +225,2 @@\n-        append(\".varHandle(\" + typeName + \".class\");\n+        append(\".varHandle(\");\n+        String prefix = \"\";\n@@ -237,1 +229,2 @@\n-                append(\", MemoryLayout.PathElement.groupElement(\\\"\" + prefixElementName + \"\\\")\");\n+                append(prefix + \"MemoryLayout.PathElement.groupElement(\\\"\" + prefixElementName + \"\\\")\");\n+                prefix = \", \";\n@@ -239,1 +232,1 @@\n-            append(\", MemoryLayout.PathElement.groupElement(\\\"\" + nativeName + \"\\\")\");\n+            append(prefix + \"MemoryLayout.PathElement.groupElement(\\\"\" + nativeName + \"\\\")\");\n@@ -242,3 +235,0 @@\n-        if (isAddr) {\n-            append(\")\");\n-        }\n@@ -255,1 +245,1 @@\n-        emitLayoutString(layout, false);\n+        emitLayoutString(layout);\n@@ -261,1 +251,1 @@\n-    private void emitLayoutString(MemoryLayout l, boolean inBitfield) {\n+    private void emitLayoutString(MemoryLayout l) {\n@@ -263,1 +253,1 @@\n-            append(typeToLayoutName(val, inBitfield));\n+            append(typeToLayoutName(val));\n@@ -269,1 +259,1 @@\n-            emitLayoutString(seq.elementLayout(), false);\n+            emitLayoutString(seq.elementLayout());\n@@ -279,1 +269,0 @@\n-            boolean isBitfield = LayoutUtils.isBitfields(group);\n@@ -283,1 +272,1 @@\n-                emitLayoutString(e, isBitfield);\n+                emitLayoutString(e);\n@@ -291,1 +280,1 @@\n-            \/\/ padding\n+            \/\/ padding (or unsupported)\n@@ -310,1 +299,1 @@\n-            emitLayoutString(desc.returnLayout().get(), false);\n+            emitLayoutString(desc.returnLayout().get());\n@@ -324,1 +313,1 @@\n-                emitLayoutString(e, false);\n+                emitLayoutString(e);\n@@ -343,1 +332,1 @@\n-        append(\" = CLinker.toCString(\\\"\");\n+        append(\" = ResourceScope.newSharedScope().allocateUtf8String(\\\"\");\n@@ -345,1 +334,1 @@\n-        append(\"\\\", ResourceScope.newImplicitScope());\\n\");\n+        append(\"\\\");\\n\");\n@@ -364,10 +353,2 @@\n-    private static String typeToLayoutName(ValueLayout vl, boolean inBitfields) {\n-        if (UnsupportedLayouts.isUnsupported(vl)) {\n-            return \"MemoryLayout.paddingLayout(\" + vl.bitSize() + \")\";\n-        } else if (inBitfields) {\n-            return \"MemoryLayout.valueLayout(\" + vl.bitSize() + \", ByteOrder.nativeOrder())\";\n-        } else {\n-            CLinker.TypeKind kind = (CLinker.TypeKind) vl.attribute(CLinker.TypeKind.ATTR_NAME).orElseThrow(\n-                    () -> new IllegalStateException(\"Unexpected value layout: could not determine ABI class\"));\n-            return \"C_\" + kind.name();\n-        }\n+    private static String typeToLayoutName(ValueLayout vl) {\n+        return Utils.layoutToConstant(vl);\n@@ -386,3 +367,1 @@\n-        append(toplevel().headerClassName() + \".LIBRARIES, \\\"\");\n-        append(nativeName);\n-        append(\"\\\", \");\n+        append(\"\\\"\" + nativeName + \"\\\", \");\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/ConstantBuilder.java","additions":19,"deletions":40,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -160,1 +160,1 @@\n-            this(type, LayoutUtils.getLayout(type), kind, name, pos, null);\n+            this(type, TypeImpl.getLayout(type), kind, name, pos, null);\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/DeclarationImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-            append(MEMBER_MODS + \" MemoryAddress allocate(\" + className() + \" fi) {\\n\");\n+            append(MEMBER_MODS + \" CLinker.UpcallStub allocate(\" + className() + \" fi) {\\n\");\n@@ -88,1 +88,1 @@\n-            append(MEMBER_MODS + \" MemoryAddress allocate(\" + className() + \" fi, ResourceScope scope) {\\n\");\n+            append(MEMBER_MODS + \" CLinker.UpcallStub allocate(\" + className() + \" fi, ResourceScope scope) {\\n\");\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/FunctionalInterfaceBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -48,1 +49,1 @@\n-    private static final String MEMBER_MODS = \"public static\";\n+    static final String MEMBER_MODS = \"public static\";\n@@ -92,4 +93,0 @@\n-            if (functionInfo.methodType().returnType().equals(MemorySegment.class)) {\n-                \/\/ emit scoped overload\n-                emitFunctionWrapperScopedOverload(javaName, functionInfo);\n-            }\n@@ -167,5 +164,1 @@\n-            if (methodType.parameterType(i).equals(MemoryAddress.class)) {\n-                pExprs.add(pName + \".address()\");\n-            } else {\n-                pExprs.add(pName);\n-            }\n+            pExprs.add(pName);\n@@ -188,25 +181,0 @@\n-    private void emitFunctionWrapperScopedOverload(String javaName, FunctionInfo functionInfo) {\n-        incrAlign();\n-        indent();\n-        append(MEMBER_MODS + \" \");\n-        List<String> paramNames = new ArrayList<>(functionInfo.parameterNames().get());\n-        paramNames.add(0, \"scope\");\n-        List<String> pExprs = emitFunctionWrapperDecl(javaName,\n-                functionInfo.methodType().insertParameterTypes(0, ResourceScope.class),\n-                functionInfo.isVarargs(),\n-                paramNames);\n-        String param = pExprs.remove(0);\n-        pExprs.add(0, \"SegmentAllocator.ofScope(\" + param + \")\");\n-        append(\" {\\n\");\n-        incrAlign();\n-        indent();\n-        if (!functionInfo.methodType().returnType().equals(void.class)) {\n-            append(\"return \");\n-        }\n-        append(javaName + \"(\" + String.join(\", \", pExprs) + \");\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n-    }\n-\n@@ -233,2 +201,3 @@\n-            append(\" ValueLayout \");\n-            append(uniqueNestedClassName(name));\n+            append(\" ValueLayout.\");\n+            append(primType.kind().layout().orElseThrow().getClass().getSimpleName());\n+            append(\" \" + uniqueNestedClassName(name));\n@@ -246,1 +215,1 @@\n-        append(\" ValueLayout \");\n+        append(\" ValueLayout.OfAddress \");\n@@ -248,1 +217,1 @@\n-        append(\" = C_POINTER;\\n\");\n+        append(\" = ValueLayout.ADDRESS;\\n\");\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/HeaderFileBuilder.java","additions":8,"deletions":39,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -1,230 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package jdk.internal.jextract.impl;\n-\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.GroupLayout;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.jextract.Type.Primitive;\n-import jdk.internal.clang.Cursor;\n-import jdk.internal.clang.Type;\n-\n-import java.util.Optional;\n-import java.util.function.Supplier;\n-\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n-\n-\/**\n- * General Layout utility functions\n- *\/\n-public final class LayoutUtils {\n-\n-    public static final String JEXTRACT_ANONYMOUS = \"jextract\/anonymous\";\n-    public static final String JEXTRACT_BITFIELDS = \"jextract\/bitfields\";\n-\n-    private LayoutUtils() {}\n-\n-    public static String getName(Type type) {\n-        Cursor c = type.getDeclarationCursor();\n-        if (c.isInvalid()) {\n-            return type.spelling();\n-        }\n-        return getName(c);\n-    }\n-\n-    public static String getName(Cursor cursor) {\n-        return cursor.spelling();\n-    }\n-\n-    public static MemoryLayout getLayout(Type t) {\n-        Supplier<UnsupportedOperationException> unsupported = () ->\n-                new UnsupportedOperationException(\"unsupported: \" + t.kind());\n-        switch(t.kind()) {\n-            case UChar, Char_U:\n-            case SChar, Char_S:\n-                return Primitive.Kind.Char.layout().orElseThrow(unsupported);\n-            case Short:\n-            case UShort:\n-                return Primitive.Kind.Short.layout().orElseThrow(unsupported);\n-            case Int:\n-            case UInt:\n-                return Primitive.Kind.Int.layout().orElseThrow(unsupported);\n-            case ULong:\n-            case Long:\n-                return Primitive.Kind.Long.layout().orElseThrow(unsupported);\n-            case ULongLong:\n-            case LongLong:\n-                return Primitive.Kind.LongLong.layout().orElseThrow(unsupported);\n-            case UInt128:\n-            case Int128:\n-                return Primitive.Kind.Int128.layout().orElseThrow(unsupported);\n-            case Enum:\n-                return valueLayoutForSize(t.size() * 8).layout().orElseThrow(unsupported);\n-            case Bool:\n-                return Primitive.Kind.Bool.layout().orElseThrow(unsupported);\n-            case Float:\n-                return Primitive.Kind.Float.layout().orElseThrow(unsupported);\n-            case Double:\n-                return Primitive.Kind.Double.layout().orElseThrow(unsupported);\n-            case LongDouble:\n-                return Primitive.Kind.LongDouble.layout().orElseThrow(unsupported);\n-            case Complex:\n-                throw new UnsupportedOperationException(\"unsupported: \" + t.kind());\n-            case Record:\n-                return getRecordLayout(t);\n-            case Vector:\n-                return MemoryLayout.sequenceLayout(t.getNumberOfElements(), getLayout(t.getElementType()));\n-            case ConstantArray:\n-                return MemoryLayout.sequenceLayout(t.getNumberOfElements(), getLayout(t.getElementType()));\n-            case IncompleteArray:\n-                return MemoryLayout.sequenceLayout(getLayout(t.getElementType()));\n-            case Unexposed:\n-                Type canonical = t.canonicalType();\n-                if (canonical.equalType(t)) {\n-                    throw new TypeMaker.TypeException(\"Unknown type with same canonical type: \" + t.spelling());\n-                }\n-                return getLayout(canonical);\n-            case Typedef:\n-            case Elaborated:\n-                return getLayout(t.canonicalType());\n-            case Pointer:\n-            case BlockPointer:\n-                return C_POINTER;\n-            default:\n-                throw new UnsupportedOperationException(\"unsupported: \" + t.kind());\n-        }\n-    }\n-\n-    public static Optional<MemoryLayout> getLayout(jdk.incubator.jextract.Type t) {\n-        try {\n-            return Optional.of(getLayoutInternal(t));\n-        } catch (Throwable ex) {\n-            return Optional.empty();\n-        }\n-    }\n-\n-    public static MemoryLayout getLayoutInternal(jdk.incubator.jextract.Type t) {\n-        return t.accept(layoutMaker, null);\n-    }\n-\n-    private static jdk.incubator.jextract.Type.Visitor<MemoryLayout, Void> layoutMaker = new jdk.incubator.jextract.Type.Visitor<>() {\n-        @Override\n-        public MemoryLayout visitPrimitive(jdk.incubator.jextract.Type.Primitive t, Void _ignored) {\n-            return t.kind().layout().orElseThrow(UnsupportedOperationException::new);\n-        }\n-\n-        @Override\n-        public MemoryLayout visitDelegated(jdk.incubator.jextract.Type.Delegated t, Void _ignored) {\n-            if (t.kind() == jdk.incubator.jextract.Type.Delegated.Kind.POINTER) {\n-                return C_POINTER;\n-            } else {\n-                return t.type().accept(this, null);\n-            }\n-        }\n-\n-        @Override\n-        public MemoryLayout visitFunction(jdk.incubator.jextract.Type.Function t, Void _ignored) {\n-            \/*\n-             * \/\/ pointer to function declared as function like this\n-             *\n-             * typedef void CB(int);\n-             * void func(CB cb);\n-             *\/\n-            return C_POINTER;\n-        }\n-\n-        @Override\n-        public MemoryLayout visitDeclared(jdk.incubator.jextract.Type.Declared t, Void _ignored) {\n-            return t.tree().layout().orElseThrow(UnsupportedOperationException::new);\n-        }\n-\n-        @Override\n-        public MemoryLayout visitArray(jdk.incubator.jextract.Type.Array t, Void _ignored) {\n-            MemoryLayout elem = t.elementType().accept(this, null);\n-            if (t.elementCount().isPresent()) {\n-                return MemoryLayout.sequenceLayout(t.elementCount().getAsLong(), elem);\n-            } else {\n-                return MemoryLayout.sequenceLayout(elem);\n-            }\n-        }\n-\n-        @Override\n-        public MemoryLayout visitType(jdk.incubator.jextract.Type t, Void _ignored) {\n-            throw new UnsupportedOperationException();\n-        }\n-    };\n-\n-    static MemoryLayout getRecordLayout(Type type) {\n-        return RecordLayoutComputer.compute(0, type, type);\n-    }\n-\n-    private static boolean isVoidType(jdk.incubator.jextract.Type type) {\n-        if (type instanceof jdk.incubator.jextract.Type.Primitive) {\n-            jdk.incubator.jextract.Type.Primitive pt = (jdk.incubator.jextract.Type.Primitive)type;\n-            return pt.kind() == jdk.incubator.jextract.Type.Primitive.Kind.Void;\n-        } else if (type instanceof jdk.incubator.jextract.Type.Delegated) {\n-            jdk.incubator.jextract.Type.Delegated dt = (jdk.incubator.jextract.Type.Delegated)type;\n-            return dt.kind() == jdk.incubator.jextract.Type.Delegated.Kind.TYPEDEF? isVoidType(dt.type()) : false;\n-        }\n-        return false;\n-    }\n-\n-    public static Optional<FunctionDescriptor> getDescriptor(jdk.incubator.jextract.Type.Function t) {\n-        try {\n-            MemoryLayout[] args = t.argumentTypes().stream()\n-                    .map(LayoutUtils::getLayoutInternal)\n-                    .toArray(MemoryLayout[]::new);\n-            jdk.incubator.jextract.Type retType = t.returnType();\n-            if (isVoidType(retType)) {\n-                return Optional.of(FunctionDescriptor.ofVoid(args));\n-            } else {\n-                return Optional.of(FunctionDescriptor.of(getLayoutInternal(retType), args));\n-            }\n-        } catch (Throwable ex) {\n-            return Optional.empty();\n-        }\n-    }\n-\n-    public static Primitive.Kind valueLayoutForSize(long size) {\n-        return switch ((int) size) {\n-            case 8 -> Primitive.Kind.Char;\n-            case 16 -> Primitive.Kind.Short;\n-            case 32 -> Primitive.Kind.Int;\n-            case 64 -> Primitive.Kind.LongLong;\n-            default -> throw new IllegalStateException(\"Cannot infer container layout\");\n-        };\n-    }\n-\n-    static boolean isBitfields(GroupLayout layout) {\n-        return layout.attribute(JEXTRACT_BITFIELDS).isPresent();\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    static <Z extends MemoryLayout> Z setBitfields(Z layout) {\n-        return (Z) layout.withAttribute(JEXTRACT_BITFIELDS, true);\n-    }\n-}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/LayoutUtils.java","additions":0,"deletions":230,"binary":false,"changes":230,"status":"deleted"},{"patch":"@@ -36,0 +36,1 @@\n+import java.io.File;\n@@ -114,2 +115,2 @@\n-        ToplevelBuilder toplevelBuilder = new ToplevelBuilder(pkgName, clsName, libraryNames.toArray(new String[0]));\n-        return new OutputFactory(pkgName, toplevelBuilder, includeHelper).generate(decl);\n+        ToplevelBuilder toplevelBuilder = new ToplevelBuilder(pkgName, clsName);\n+        return new OutputFactory(pkgName, toplevelBuilder, includeHelper).generate(decl, libraryNames.toArray(new String[0]));\n@@ -125,1 +126,1 @@\n-    JavaFileObject[] generate(Declaration.Scoped decl) {\n+    JavaFileObject[] generate(Declaration.Scoped decl, String[] libs) {\n@@ -136,1 +137,1 @@\n-            files.add(jfoFromString(pkgName,\"RuntimeHelper\", getRuntimeHelperSource()));\n+            files.add(jfoFromString(pkgName,\"RuntimeHelper\", getRuntimeHelperSource(libs)));\n@@ -145,1 +146,1 @@\n-    private String getRuntimeHelperSource() throws URISyntaxException, IOException {\n+    private String getRuntimeHelperSource(String[] libraries) throws URISyntaxException, IOException {\n@@ -147,1 +148,1 @@\n-        return (pkgName.isEmpty()? \"\" : \"package \" + pkgName + \";\\n\") +\n+        String template = (pkgName.isEmpty()? \"\" : \"package \" + pkgName + \";\\n\") +\n@@ -149,0 +150,14 @@\n+        List<String> loadLibrariesStr = new ArrayList<>();\n+        for (String lib : libraries) {\n+            String quotedLibName = quoteLibraryName(lib);\n+            if (quotedLibName.indexOf(File.separatorChar) != -1) {\n+                loadLibrariesStr.add(\"System.load(\\\"\" + quotedLibName + \"\\\");\");\n+            } else {\n+                loadLibrariesStr.add(\"System.loadLibrary(\\\"\" + quotedLibName + \"\\\");\");\n+            }\n+        }\n+        return template.replace(\"#LOAD_LIBRARIES#\", loadLibrariesStr.stream().collect(Collectors.joining(\" \")));\n+    }\n+\n+    private String quoteLibraryName(String lib) {\n+        return lib.replace(\"\\\\\", \"\\\\\\\\\"); \/\/ double up slashes\n@@ -215,37 +230,0 @@\n-    private static MemoryLayout isUnsupported(MemoryLayout layout) {\n-        if (layout instanceof ValueLayout) {\n-            if (UnsupportedLayouts.isUnsupported(layout)) {\n-                return layout;\n-            }\n-        } else if (layout instanceof GroupLayout) {\n-            GroupLayout gl = (GroupLayout)layout;\n-            for (MemoryLayout ml : gl.memberLayouts()) {\n-                MemoryLayout ul = isUnsupported(ml);\n-                if (ul != null) {\n-                    return ul;\n-                }\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n-    private static MemoryLayout isUnsupported(FunctionDescriptor desc) {\n-        MemoryLayout resultLayout = desc.returnLayout().orElse(null);\n-        if (resultLayout != null) {\n-            MemoryLayout ul = isUnsupported(resultLayout);\n-            if (ul != null) {\n-                return ul;\n-            }\n-        }\n-\n-        for (MemoryLayout argLayout : desc.argumentLayouts()) {\n-            MemoryLayout ul = isUnsupported(argLayout);\n-            if (ul != null) {\n-                return ul;\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n@@ -392,1 +370,1 @@\n-        if (type instanceof Type.Declared && ((Type.Declared) type).tree().name().isEmpty()) {\n+        if (type instanceof Type.Declared) {\n@@ -402,2 +380,2 @@\n-        MemoryLayout ul = isUnsupported(layout);\n-        if (ul != null) {\n+        String unsupportedType = UnsupportedLayouts.firstUnsupportedType(type);\n+        if (unsupportedType != null) {\n@@ -407,1 +385,1 @@\n-                    UnsupportedLayouts.getUnsupportedTypeName(ul));\n+                    unsupportedType);\n@@ -471,2 +449,2 @@\n-        MemoryLayout unsupportedLayout = isUnsupported(descriptor);\n-        if (unsupportedLayout != null) {\n+        String unsupportedType = UnsupportedLayouts.firstUnsupportedType(funcPtr);\n+        if (unsupportedType != null) {\n@@ -474,1 +452,1 @@\n-                    UnsupportedLayouts.getUnsupportedTypeName(unsupportedLayout));\n+                    unsupportedType);\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/OutputFactory.java","additions":28,"deletions":50,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Position;\n@@ -41,2 +43,0 @@\n-import static jdk.internal.jextract.impl.LayoutUtils.JEXTRACT_ANONYMOUS;\n-\n@@ -53,0 +53,1 @@\n+    final List<Declaration> fieldDecls;\n@@ -55,0 +56,2 @@\n+    final TypeMaker typeMaker;\n+\n@@ -57,1 +60,1 @@\n-    RecordLayoutComputer(Type parent, Type type) {\n+    RecordLayoutComputer(TypeMaker typeMaker, Type parent, Type type) {\n@@ -61,0 +64,1 @@\n+        this.fieldDecls = new ArrayList<>();\n@@ -62,0 +66,5 @@\n+        this.typeMaker = typeMaker;\n+    }\n+\n+    static jdk.incubator.jextract.Type compute(TypeMaker typeMaker, long offsetInParent, Type parent, Type type) {\n+        return computeInternal(typeMaker, offsetInParent, parent, type, null);\n@@ -64,1 +73,8 @@\n-    static MemoryLayout compute(long offsetInParent, Type parent, Type type) {\n+    private static jdk.incubator.jextract.Type computeAnonymous(TypeMaker typeMaker, long offsetInParent, Type parent, Type type, String name) {\n+        return computeInternal(typeMaker, offsetInParent, parent, type, name);\n+    }\n+\n+    static final jdk.incubator.jextract.Type.Declared ERRONEOUS = jdk.incubator.jextract.Type.declared(\n+            Declaration.struct(TreeMaker.CursorPosition.NO_POSITION, \"\", MemoryLayout.paddingLayout(64)));\n+\n+    private static jdk.incubator.jextract.Type computeInternal(TypeMaker typeMaker, long offsetInParent, Type parent, Type type, String name) {\n@@ -67,1 +83,1 @@\n-            return MemoryLayout.paddingLayout(64);\n+            return ERRONEOUS;\n@@ -71,2 +87,2 @@\n-        return isUnion? new UnionLayoutComputer(offsetInParent, parent, type).compute() :\n-                new StructLayoutComputer(offsetInParent, parent, type).compute();\n+        return isUnion? new UnionLayoutComputer(typeMaker, offsetInParent, parent, type).compute(name) :\n+                new StructLayoutComputer(typeMaker, offsetInParent, parent, type).compute(name);\n@@ -75,1 +91,1 @@\n-    final MemoryLayout compute() {\n+    final jdk.incubator.jextract.Type.Declared compute(String anonName) {\n@@ -96,1 +112,1 @@\n-        return finishLayout();\n+        return finishRecord(anonName);\n@@ -101,1 +117,15 @@\n-    abstract MemoryLayout finishLayout();\n+    abstract jdk.incubator.jextract.Type.Declared finishRecord(String anonName);\n+\n+    void addField(Declaration declaration) {\n+        fieldDecls.add(declaration);\n+        MemoryLayout layout = null;\n+        if (declaration instanceof Declaration.Scoped scoped) {\n+            layout = scoped.layout().orElse(null);\n+        } else if (declaration instanceof Declaration.Variable var) {\n+            layout = var.layout().orElse(null);\n+        }\n+        if (layout != null) {\n+            \/\/fieldLayouts.add(layout.name().isEmpty() ? layout.withName(declaration.name()) : layout);\n+            fieldLayouts.add(declaration.name().isEmpty() ? layout : layout.withName(declaration.name()));\n+        }\n+    }\n@@ -103,2 +133,2 @@\n-    void addFieldLayout(MemoryLayout MemoryLayout) {\n-        fieldLayouts.add(MemoryLayout);\n+    void addPadding(long bits) {\n+        fieldLayouts.add(MemoryLayout.paddingLayout(bits));\n@@ -107,7 +137,6 @@\n-    void addFieldLayout(long offset, Type parent, Cursor c) {\n-        MemoryLayout memoryLayout = c.isAnonymousStruct()\n-            ? compute(offset, parent, c.type())\n-                .withName(nextAnonymousName())\n-                .withAttribute(JEXTRACT_ANONYMOUS, true)\n-            : fieldLayout(c);\n-        addFieldLayout(memoryLayout);\n+    void addField(long offset, Type parent, Cursor c) {\n+        if (c.isAnonymousStruct()) {\n+            addField(((jdk.incubator.jextract.Type.Declared)computeAnonymous(typeMaker, offset, parent, c.type(), nextAnonymousName())).tree());\n+        } else {\n+            addField(field(c));\n+        }\n@@ -120,3 +149,3 @@\n-    MemoryLayout fieldLayout(Cursor c) {\n-        MemoryLayout l = LayoutUtils.getLayout(c.type());\n-        String name = LayoutUtils.getName(c);\n+    Declaration field(Cursor c) {\n+        jdk.incubator.jextract.Type type = typeMaker.makeType(c.type());\n+        String name = c.spelling();\n@@ -124,2 +153,4 @@\n-            MemoryLayout sublayout = MemoryLayout.valueLayout(c.getBitFieldWidth(), ByteOrder.nativeOrder());\n-            return sublayout.withName(name);\n+            MemoryLayout sublayout = MemoryLayout.paddingLayout(c.getBitFieldWidth());\n+            return Declaration.bitfield(new TreeMaker.CursorPosition(c), name, type, sublayout.withName(name));\n+        } else if (c.isAnonymousStruct() && type instanceof jdk.incubator.jextract.Type.Declared decl) {\n+            return decl.tree();\n@@ -127,1 +158,1 @@\n-            return l.withName(name);\n+            return Declaration.field(new TreeMaker.CursorPosition(c), name, type);\n@@ -138,2 +169,2 @@\n-    MemoryLayout bitfield(List<MemoryLayout> sublayouts) {\n-        return LayoutUtils.setBitfields(MemoryLayout.structLayout(sublayouts.toArray(new MemoryLayout[0])));\n+    Declaration.Scoped bitfield(List<MemoryLayout> sublayouts, Declaration.Variable... declarations) {\n+        return Declaration.bitfields(declarations[0].pos(), MemoryLayout.structLayout(sublayouts.toArray(new MemoryLayout[0])), declarations);\n@@ -153,0 +184,8 @@\n+\n+\/\/    public static String getName(Type type) {\n+\/\/        Cursor c = type.getDeclarationCursor();\n+\/\/        if (c.isInvalid()) {\n+\/\/            return type.spelling();\n+\/\/        }\n+\/\/        return c.spelling();\n+\/\/    }\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/RecordLayoutComputer.java","additions":66,"deletions":27,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -39,2 +39,0 @@\n-import static jdk.internal.jextract.impl.LayoutUtils.JEXTRACT_ANONYMOUS;\n-\n@@ -91,1 +89,0 @@\n-            emitScopeAllocate();\n@@ -93,1 +90,0 @@\n-            emitScopeAllocateArray();\n@@ -111,2 +107,1 @@\n-            GroupLayout parentLayout = (GroupLayout)((Declaration.Scoped)parent).layout().get();\n-            String anonName = findAnonymousStructName(parentLayout, layout);\n+            String anonName = layout.name().orElseThrow();\n@@ -128,15 +123,0 @@\n-    private String findAnonymousStructName(GroupLayout parentLayout, GroupLayout layout) {\n-        \/\/ nested anonymous struct or union\n-        for (MemoryLayout ml : parentLayout.memberLayouts()) {\n-            \/\/ look for anonymous structs\n-            if (ml.attribute(JEXTRACT_ANONYMOUS).isPresent()) {\n-                \/\/ it's enough to just compare the member layouts, since the member names\n-                \/\/ have to be unique within the parent layout (in C)\n-                if (((GroupLayout) ml).memberLayouts().equals(layout.memberLayouts())) {\n-                    return ml.name().orElseThrow();\n-                }\n-            }\n-        }\n-        throw new IllegalStateException(\"Could not find layout in parent\");\n-    }\n-\n@@ -249,8 +229,0 @@\n-    private void emitScopeAllocate() {\n-        incrAlign();\n-        indent();\n-        append(MEMBER_MODS);\n-        append(\" MemorySegment allocate(ResourceScope scope) { return allocate(SegmentAllocator.ofScope(scope)); }\\n\");\n-        decrAlign();\n-    }\n-\n@@ -265,14 +237,0 @@\n-    private void emitScopeAllocateArray() {\n-        incrAlign();\n-        indent();\n-        append(MEMBER_MODS);\n-        append(\" MemorySegment allocateArray(int len, ResourceScope scope) {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"return allocateArray(len, SegmentAllocator.ofScope(scope));\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n-    }\n-\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/StructBuilder.java","additions":1,"deletions":43,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import jdk.incubator.foreign.ValueLayout;\n+import jdk.incubator.jextract.Declaration;\n@@ -45,0 +45,1 @@\n+    private List<Declaration> bitfieldDecls;\n@@ -47,2 +48,2 @@\n-    StructLayoutComputer(long offsetInParent, Type parent, Type type) {\n-        super(parent, type);\n+    StructLayoutComputer(TypeMaker typeMaker, long offsetInParent, Type parent, Type type) {\n+        super(typeMaker, parent, type);\n@@ -53,3 +54,12 @@\n-    void addFieldLayout(MemoryLayout MemoryLayout) {\n-        if (bitfieldLayouts != null) {\n-            bitfieldLayouts.add(MemoryLayout);\n+    void addField(Declaration declaration) {\n+        if (bitfieldDecls != null) {\n+            bitfieldDecls.add(declaration);\n+            MemoryLayout layout = null;\n+            if (declaration instanceof Declaration.Scoped scoped) {\n+                layout = scoped.layout().orElse(null);\n+            } else if (declaration instanceof Declaration.Variable var) {\n+                layout = var.layout().orElse(null);\n+            }\n+            if (layout != null) {\n+                bitfieldLayouts.add(declaration.name().isEmpty() ? layout : layout.withName(declaration.name()));\n+            }\n@@ -57,1 +67,10 @@\n-            fieldLayouts.add(MemoryLayout);\n+            super.addField(declaration);\n+        }\n+    }\n+\n+    @Override\n+    void addPadding(long bits) {\n+        if (bitfieldDecls != null) {\n+            bitfieldLayouts.add(MemoryLayout.paddingLayout(bits));\n+        } else {\n+            super.addPadding(bits);\n@@ -68,1 +87,2 @@\n-        if (bitfieldLayouts == null) {\n+        if (bitfieldDecls == null) {\n+            bitfieldDecls = new ArrayList<>();\n@@ -78,1 +98,1 @@\n-            addFieldLayout(MemoryLayout.paddingLayout(expectedOffset - offset));\n+            addPadding(expectedOffset - offset);\n@@ -99,1 +119,1 @@\n-        addFieldLayout(offset, parent, c);\n+        addField(offset, parent, c);\n@@ -106,1 +126,1 @@\n-    MemoryLayout finishLayout() {\n+    jdk.incubator.jextract.Type.Declared finishRecord(String anonName) {\n@@ -110,1 +130,1 @@\n-            addFieldLayout(MemoryLayout.paddingLayout(expectedSize - actualSize));\n+            addPadding(expectedSize - actualSize);\n@@ -126,3 +146,6 @@\n-        String name = LayoutUtils.getName(cursor);\n-        return name.isEmpty() ?\n-                g : g.withName(name);\n+        if (!cursor.spelling().isEmpty()) {\n+            g = g.withName(cursor.spelling());\n+        } else if (anonName != null) {\n+            g = g.withName(anonName);\n+        }\n+        return jdk.incubator.jextract.Type.declared(Declaration.struct(new TreeMaker.CursorPosition(cursor), cursor.spelling(), g, fieldDecls.stream().toArray(Declaration[]::new)));\n@@ -133,3 +156,7 @@\n-        if (bitfieldLayouts != null) {\n-            fieldLayouts.add(bitfield(bitfieldLayouts));\n-            bitfieldLayouts = null;\n+        if (bitfieldDecls != null) {\n+            List<MemoryLayout> prevBitfieldLayouts = bitfieldLayouts;\n+            List<Declaration> prevBitfieldDecls = bitfieldDecls;\n+            bitfieldDecls = null;\n+            if (!prevBitfieldDecls.isEmpty()) {\n+                addField(bitfield(prevBitfieldLayouts, prevBitfieldDecls.toArray(new Declaration.Variable[0])));\n+            }\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/StructLayoutComputer.java","additions":45,"deletions":18,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-    private final String[] libraryNames;\n@@ -54,2 +53,1 @@\n-    ToplevelBuilder(String packageName, String headerClassName, String[] libraryNames) {\n-        this.libraryNames = libraryNames;\n+    ToplevelBuilder(String packageName, String headerClassName) {\n@@ -180,1 +178,0 @@\n-            emitLibraries(libraryNames);\n@@ -182,0 +179,10 @@\n+            \/\/ emit basic primitive types\n+            emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Bool), \"C_BOOL\");\n+            emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Char), \"C_CHAR\");\n+            emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Short), \"C_SHORT\");\n+            emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Int), \"C_INT\");\n+            emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Long), \"C_LONG\");\n+            emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.LongLong), \"C_LONG_LONG\");\n+            emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Float), \"C_FLOAT\");\n+            emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Double), \"C_DOUBLE\");\n+            emitPointerTypedef(\"C_POINTER\");\n@@ -200,28 +207,0 @@\n-\n-        private void emitLibraries(String[] libraryNames) {\n-            incrAlign();\n-            indent();\n-            append(\"static {\\n\");\n-            incrAlign();\n-            for (String lib : libraryNames) {\n-                String quotedLibName = quoteLibraryName(lib);\n-                indent();\n-                if (quotedLibName.indexOf(File.separatorChar) != -1) {\n-                    append(\"System.load(\\\"\" + quotedLibName + \"\\\");\");\n-                } else {\n-                    append(\"System.loadLibrary(\\\"\" + quotedLibName + \"\\\");\");\n-                }\n-                append(\"\\n\");\n-            }\n-            decrAlign();\n-            indent();\n-            append(\"}\\n\\n\");\n-            indent();\n-            append(\"static final \");\n-            append(\"SymbolLookup LIBRARIES = RuntimeHelper.lookup();\");\n-            decrAlign();\n-        }\n-\n-        private String quoteLibraryName(String lib) {\n-            return lib.replace(\"\\\\\", \"\\\\\\\\\"); \/\/ double up slashes\n-        }\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/ToplevelBuilder.java","additions":11,"deletions":32,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -32,2 +32,0 @@\n-import java.util.HashSet;\n-import java.util.Iterator;\n@@ -37,1 +35,0 @@\n-import java.util.Set;\n@@ -40,1 +37,0 @@\n-import jdk.incubator.foreign.GroupLayout;\n@@ -92,1 +88,1 @@\n-                return createScoped(c, Declaration.Scoped.Kind.ENUM, Declaration::enum_, Declaration::enum_);\n+                return createEnum(c, Declaration::enum_, Declaration::enum_);\n@@ -103,1 +99,1 @@\n-                return createScoped(c, Declaration.Scoped.Kind.STRUCT, Declaration::struct, Declaration::struct);\n+                return createRecord(c, Declaration.Scoped.Kind.STRUCT, Declaration::struct, Declaration::struct);\n@@ -105,1 +101,1 @@\n-                return createScoped(c, Declaration.Scoped.Kind.UNION, Declaration::union, Declaration::union);\n+                return createRecord(c, Declaration.Scoped.Kind.UNION, Declaration::union, Declaration::union);\n@@ -192,1 +188,21 @@\n-    public Declaration.Scoped createScoped(Cursor c, Declaration.Scoped.Kind scopeKind, ScopedFactoryLayout factoryLayout, ScopedFactoryNoLayout factoryNoLayout) {\n+    public Declaration.Scoped createRecord(Cursor c, Declaration.Scoped.Kind scopeKind, ScopedFactoryLayout factoryLayout, ScopedFactoryNoLayout factoryNoLayout) {\n+        Type.Declared t = (Type.Declared)RecordLayoutComputer.compute(typeMaker, 0, c.type(), c.type());\n+        List<Declaration> decls = filterNestedDeclarations(t.tree().members());\n+        if (c.isDefinition()) {\n+            \/\/just a declaration AND definition, we have a layout\n+            return factoryLayout.make(toPos(c), c.spelling(), t.tree().layout().get(), decls.toArray(new Declaration[0]));\n+        } else {\n+            \/\/just a declaration\n+            if (scopeKind == Declaration.Scoped.Kind.STRUCT ||\n+                    scopeKind == Declaration.Scoped.Kind.UNION ||\n+                    scopeKind == Declaration.Scoped.Kind.CLASS) {\n+                \/\/if there's a real definition somewhere else, skip this redundant declaration\n+                if (!c.getDefinition().isInvalid()) {\n+                    return null;\n+                }\n+            }\n+            return factoryNoLayout.make(toPos(c), c.spelling(), decls.toArray(new Declaration[0]));\n+        }\n+    }\n+\n+    public Declaration.Scoped createEnum(Cursor c, ScopedFactoryLayout factoryLayout, ScopedFactoryNoLayout factoryNoLayout) {\n@@ -204,12 +220,2 @@\n-            MemoryLayout layout = null;\n-            try {\n-                layout = LayoutUtils.getLayout(c.type());\n-            } catch (TypeMaker.TypeException ex) {\n-                System.err.println(ex);\n-                System.err.println(\"WARNING: generating empty struct: \" + c.spelling());\n-                return factoryNoLayout.make(toPos(c), c.spelling(), decls.toArray(new Declaration[0]));\n-            }\n-            List<Declaration> adaptedDecls = layout instanceof GroupLayout ?\n-                    collectBitfields(layout, decls) :\n-                    decls;\n-            return factoryLayout.make(toPos(c), c.spelling(), layout, adaptedDecls.toArray(new Declaration[0]));\n+            MemoryLayout layout = TypeMaker.valueLayoutForSize(c.type().size() * 8).layout().orElseThrow();\n+            return factoryLayout.make(toPos(c), c.spelling(), layout, decls.toArray(new Declaration[0]));\n@@ -218,8 +224,3 @@\n-            if (scopeKind == Declaration.Scoped.Kind.STRUCT ||\n-                    scopeKind == Declaration.Scoped.Kind.UNION ||\n-                    scopeKind == Declaration.Scoped.Kind.ENUM ||\n-                    scopeKind == Declaration.Scoped.Kind.CLASS) {\n-                \/\/if there's a real definition somewhere else, skip this redundant declaration\n-                if (!c.getDefinition().isInvalid()) {\n-                    return null;\n-                }\n+            \/\/if there's a real definition somewhere else, skip this redundant declaration\n+            if (!c.getDefinition().isInvalid()) {\n+                return null;\n@@ -235,0 +236,4 @@\n+    private static boolean isBitfield(Declaration d) {\n+        return d instanceof Declaration.Scoped && ((Declaration.Scoped)d).kind() == Declaration.Scoped.Kind.BITFIELDS;\n+    }\n+\n@@ -242,1 +247,1 @@\n-                .filter(d -> isEnum(d) || !d.name().isEmpty() || isAnonymousStruct(d))\n+                .filter(d -> isEnum(d) || !d.name().isEmpty() || isAnonymousStruct(d) || isBitfield(d))\n@@ -265,1 +270,1 @@\n-                    MemoryLayout.valueLayout(c.getBitFieldWidth(), ByteOrder.nativeOrder()));\n+                    MemoryLayout.paddingLayout(c.getBitFieldWidth()));\n@@ -279,52 +284,0 @@\n-    private static void collectNestedBitFields(Set<Declaration> out, Declaration.Scoped anonymousStruct) {\n-        for  (Declaration field : anonymousStruct.members()) {\n-            if (isAnonymousStruct(field)) {\n-                collectNestedBitFields(out, (Declaration.Scoped) field);\n-            } else if (field instanceof Declaration.Scoped\n-                       && ((Declaration.Scoped) field).kind() == Declaration.Scoped.Kind.BITFIELDS) {\n-                out.addAll(((Declaration.Scoped) field).members());\n-            }\n-        }\n-    }\n-\n-    private static Set<Declaration> nestedBitFields(List<Declaration> members) {\n-        Set<Declaration> res = new HashSet<>();\n-        for (Declaration member : members) {\n-            if (isAnonymousStruct(member)) {\n-                collectNestedBitFields(res, (Declaration.Scoped) member);\n-            }\n-        }\n-        return res;\n-    }\n-\n-    private List<Declaration> collectBitfields(MemoryLayout layout, List<Declaration> declarations) {\n-        Set<String> nestedBitfieldNames = nestedBitFields(declarations).stream()\n-                                                                       .map(Declaration::name)\n-                                                                       .collect(Collectors.toSet());\n-        List<Declaration> newDecls = new ArrayList<>();\n-        for (MemoryLayout e : ((GroupLayout)layout).memberLayouts()) {\n-            if (e instanceof GroupLayout contents && LayoutUtils.isBitfields(contents)) {\n-                List<Declaration.Variable> bfDecls = new ArrayList<>();\n-                outer: for (MemoryLayout bitfield : contents.memberLayouts()) {\n-                    if (bitfield.name().isPresent() && !nestedBitfieldNames.contains(bitfield.name().get())) {\n-                        Iterator<Declaration> declIt = declarations.iterator();\n-                        while (declIt.hasNext()) {\n-                            Declaration d = declIt.next();\n-                            if (d.name().equals(bitfield.name().get())) {\n-                                bfDecls.add((Declaration.Variable)d);\n-                                declIt.remove();\n-                                continue outer;\n-                            }\n-                        }\n-                        throw new IllegalStateException(\"No matching declaration found for bitfield: \" + bitfield);\n-                    }\n-                }\n-                if (!bfDecls.isEmpty()) {\n-                    newDecls.add(Declaration.bitfields(bfDecls.get(0).pos(), \"\", contents, bfDecls.toArray(new Declaration.Variable[0])));\n-                }\n-            }\n-        }\n-        newDecls.addAll(declarations);\n-        return newDecls;\n-    }\n-\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/TreeMaker.java","additions":35,"deletions":82,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+\n+import jdk.incubator.foreign.FunctionDescriptor;\n@@ -38,0 +40,2 @@\n+import static jdk.internal.clang.libclang.CLayouts.C_POINTER;\n+\n@@ -40,0 +44,2 @@\n+    public static final boolean IS_WINDOWS = System.getProperty(\"os.name\").startsWith(\"Windows\");\n+\n@@ -348,0 +354,88 @@\n+\n+    \/\/ Utilities to fetch layouts\/descriptor from types\n+\n+    public static Optional<MemoryLayout> getLayout(jdk.incubator.jextract.Type t) {\n+        try {\n+            return Optional.of(getLayoutInternal(t));\n+        } catch (Throwable ex) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    public static Optional<FunctionDescriptor> getDescriptor(Function t) {\n+        try {\n+            MemoryLayout[] args = t.argumentTypes().stream()\n+                    .map(TypeImpl::getLayoutInternal)\n+                    .toArray(MemoryLayout[]::new);\n+            Type retType = t.returnType();\n+            if (isVoidType(retType)) {\n+                return Optional.of(FunctionDescriptor.ofVoid(args));\n+            } else {\n+                return Optional.of(FunctionDescriptor.of(getLayoutInternal(retType), args));\n+            }\n+        } catch (Throwable ex) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private static boolean isVoidType(jdk.incubator.jextract.Type type) {\n+        if (type instanceof jdk.incubator.jextract.Type.Primitive) {\n+            jdk.incubator.jextract.Type.Primitive pt = (jdk.incubator.jextract.Type.Primitive)type;\n+            return pt.kind() == jdk.incubator.jextract.Type.Primitive.Kind.Void;\n+        } else if (type instanceof jdk.incubator.jextract.Type.Delegated) {\n+            jdk.incubator.jextract.Type.Delegated dt = (jdk.incubator.jextract.Type.Delegated)type;\n+            return dt.kind() == jdk.incubator.jextract.Type.Delegated.Kind.TYPEDEF? isVoidType(dt.type()) : false;\n+        }\n+        return false;\n+    }\n+\n+    public static MemoryLayout getLayoutInternal(jdk.incubator.jextract.Type t) {\n+        return t.accept(layoutMaker, null);\n+    }\n+\n+    private static jdk.incubator.jextract.Type.Visitor<MemoryLayout, Void> layoutMaker = new jdk.incubator.jextract.Type.Visitor<>() {\n+        @Override\n+        public MemoryLayout visitPrimitive(jdk.incubator.jextract.Type.Primitive t, Void _ignored) {\n+            return t.kind().layout().orElseThrow(UnsupportedOperationException::new);\n+        }\n+\n+        @Override\n+        public MemoryLayout visitDelegated(jdk.incubator.jextract.Type.Delegated t, Void _ignored) {\n+            if (t.kind() == jdk.incubator.jextract.Type.Delegated.Kind.POINTER) {\n+                return C_POINTER;\n+            } else {\n+                return t.type().accept(this, null);\n+            }\n+        }\n+\n+        @Override\n+        public MemoryLayout visitFunction(jdk.incubator.jextract.Type.Function t, Void _ignored) {\n+            \/*\n+             * \/\/ pointer to function declared as function like this\n+             *\n+             * typedef void CB(int);\n+             * void func(CB cb);\n+             *\/\n+            return C_POINTER;\n+        }\n+\n+        @Override\n+        public MemoryLayout visitDeclared(jdk.incubator.jextract.Type.Declared t, Void _ignored) {\n+            return t.tree().layout().orElseThrow(UnsupportedOperationException::new);\n+        }\n+\n+        @Override\n+        public MemoryLayout visitArray(jdk.incubator.jextract.Type.Array t, Void _ignored) {\n+            MemoryLayout elem = t.elementType().accept(this, null);\n+            if (t.elementCount().isPresent()) {\n+                return MemoryLayout.sequenceLayout(t.elementCount().getAsLong(), elem);\n+            } else {\n+                return MemoryLayout.sequenceLayout(elem);\n+            }\n+        }\n+\n+        @Override\n+        public MemoryLayout visitType(jdk.incubator.jextract.Type t, Void _ignored) {\n+            throw new UnsupportedOperationException();\n+        }\n+    };\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/TypeImpl.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.nio.ByteOrder;\n@@ -37,0 +38,2 @@\n+\n+import jdk.incubator.foreign.MemoryLayout;\n@@ -41,0 +44,1 @@\n+import jdk.internal.clang.Cursor;\n@@ -191,4 +195,0 @@\n-                if (treeMaker == null) {\n-                    \/\/ Macro evaluation, type is meaningless as this can only be pointer and we only care value\n-                    return Type.void_();\n-                }\n@@ -257,0 +257,10 @@\n+\n+    public static Primitive.Kind valueLayoutForSize(long size) {\n+        return switch ((int) size) {\n+            case 8 -> Primitive.Kind.Char;\n+            case 16 -> Primitive.Kind.Short;\n+            case 32 -> Primitive.Kind.Int;\n+            case 64 -> Primitive.Kind.LongLong;\n+            default -> throw new IllegalStateException(\"Cannot infer container layout\");\n+        };\n+    }\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/TypeMaker.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -60,11 +61,1 @@\n-        return switch (type) {\n-            case Bool -> \"C_BOOL\";\n-            case Char -> \"C_CHAR\";\n-            case Short -> \"C_SHORT\";\n-            case Int -> \"C_INT\";\n-            case Long -> \"C_LONG\";\n-            case LongLong -> \"C_LONG_LONG\";\n-            case Float -> \"C_FLOAT\";\n-            case Double -> \"C_DOUBLE\";\n-            default -> throw new RuntimeException(\"should not reach here: \" + type);\n-        };\n+        return Utils.layoutToConstant((ValueLayout)type.layout().orElseThrow());\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/TypeTranslator.java","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import jdk.incubator.foreign.ValueLayout;\n+import jdk.incubator.jextract.Declaration;\n@@ -36,1 +36,0 @@\n-import java.util.ArrayList;\n@@ -46,2 +45,2 @@\n-    UnionLayoutComputer(long offsetInParent, Type parent, Type type) {\n-        super(parent, type);\n+    UnionLayoutComputer(TypeMaker typeMaker, long offsetInParent, Type parent, Type type) {\n+        super(typeMaker, parent, type);\n@@ -58,1 +57,1 @@\n-        addFieldLayout(offset, parent, c);\n+        addField(offset, parent, c);\n@@ -68,1 +67,1 @@\n-    MemoryLayout fieldLayout(Cursor c) {\n+    Declaration field(Cursor c) {\n@@ -70,1 +69,2 @@\n-            return bitfield(List.of(super.fieldLayout(c)));\n+            Declaration.Variable var = (Declaration.Variable)super.field(c);\n+            return bitfield(List.of(var.layout().get()), var);\n@@ -72,1 +72,1 @@\n-            return super.fieldLayout(c);\n+            return super.field(c);\n@@ -88,1 +88,1 @@\n-    MemoryLayout finishLayout() {\n+    jdk.incubator.jextract.Type.Declared finishRecord(String anonName) {\n@@ -93,1 +93,1 @@\n-            addFieldLayout(MemoryLayout.paddingLayout(expectedSize));\n+            addPadding(expectedSize);\n@@ -100,3 +100,6 @@\n-        String name = LayoutUtils.getName(cursor);\n-        return name.isEmpty() ?\n-                g : g.withName(name);\n+        if (!cursor.spelling().isEmpty()) {\n+            g = g.withName(cursor.spelling());\n+        } else if (anonName != null) {\n+            g = g.withName(anonName);\n+        }\n+        return jdk.incubator.jextract.Type.declared(Declaration.union(new TreeMaker.CursorPosition(cursor), cursor.spelling(), g, fieldDecls.stream().toArray(Declaration[]::new)));\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/UnionLayoutComputer.java","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Type;\n+\n@@ -37,4 +40,1 @@\n-    private static final String ATTR_LAYOUT_KIND = \"jextract.abi.unsupported.layout.kind\";\n-\n-    public static final ValueLayout __INT128 = MemoryLayout.valueLayout(128, ByteOrder.nativeOrder()).\n-            withAttribute(ATTR_LAYOUT_KIND, \"__int128\");\n+    public static final MemoryLayout __INT128 = makeUnsupportedLayout(128, \"__int128\");\n@@ -42,2 +42,1 @@\n-    public static final ValueLayout LONG_DOUBLE = MemoryLayout.valueLayout(128, ByteOrder.nativeOrder()).\n-            withAttribute(ATTR_LAYOUT_KIND, \"long double\");\n+    public static final MemoryLayout LONG_DOUBLE = makeUnsupportedLayout(128, \"long double\");\n@@ -45,2 +44,1 @@\n-    public static final ValueLayout _FLOAT128 = MemoryLayout.valueLayout(128, ByteOrder.nativeOrder()).\n-            withAttribute(ATTR_LAYOUT_KIND, \"_float128\");\n+    public static final MemoryLayout _FLOAT128 = makeUnsupportedLayout(128, \"_float128\");\n@@ -48,2 +46,1 @@\n-    public static final ValueLayout __FP16 = MemoryLayout.valueLayout(16, ByteOrder.nativeOrder()).\n-            withAttribute(ATTR_LAYOUT_KIND, \"__fp16\");\n+    public static final MemoryLayout __FP16 = makeUnsupportedLayout(16, \"__fp16\");\n@@ -51,2 +48,1 @@\n-    public static final ValueLayout CHAR16 = MemoryLayout.valueLayout(16, ByteOrder.nativeOrder()).\n-            withAttribute(ATTR_LAYOUT_KIND, \"char16\");\n+    public static final MemoryLayout CHAR16 = makeUnsupportedLayout(16, \"char16\");\n@@ -54,2 +50,1 @@\n-    public static final ValueLayout WCHAR_T = MemoryLayout.valueLayout(16, ByteOrder.nativeOrder()).\n-            withAttribute(ATTR_LAYOUT_KIND, \"wchar_t\");\n+    public static final MemoryLayout WCHAR_T = makeUnsupportedLayout(16, \"wchar_t\");\n@@ -57,2 +52,2 @@\n-    static boolean isUnsupported(MemoryLayout vl) {\n-        return vl.attribute(ATTR_LAYOUT_KIND).isPresent();\n+    static String firstUnsupportedType(Type type) {\n+        return type.accept(unsupportedVisitor, null);\n@@ -61,3 +56,2 @@\n-    static String getUnsupportedTypeName(MemoryLayout vl) {\n-        return (String)\n-                vl.attribute(ATTR_LAYOUT_KIND).orElseThrow(IllegalArgumentException::new);\n+    private static MemoryLayout makeUnsupportedLayout(long size, String name) {\n+        return MemoryLayout.paddingLayout(size).withBitAlignment(size).withName(name);\n@@ -65,0 +59,61 @@\n+\n+    static Type.Visitor<String, Void> unsupportedVisitor = new Type.Visitor<>() {\n+        @Override\n+        public String visitPrimitive(Type.Primitive t, Void unused) {\n+            MemoryLayout layout = t.kind().layout().orElse(MemoryLayout.paddingLayout(64));\n+            if (layout.equals(__INT128) || layout.equals(LONG_DOUBLE) || layout.equals(_FLOAT128) || layout.equals(__FP16)) {\n+                return layout.name().get();\n+            } else {\n+                return null;\n+            }\n+        }\n+\n+        @Override\n+        public String visitFunction(Type.Function t, Void unused) {\n+            for (Type arg : t.argumentTypes()) {\n+                String unsupported = firstUnsupportedType(arg);\n+                if (unsupported != null) {\n+                    return unsupported;\n+                }\n+            }\n+            String unsupported = firstUnsupportedType(t.returnType());\n+            if (unsupported != null) {\n+                return unsupported;\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public String visitDeclared(Type.Declared t, Void unused) {\n+            for (Declaration d : t.tree().members()) {\n+                if (d instanceof Declaration.Variable) {\n+                    String unsupported = firstUnsupportedType(((Declaration.Variable) d).type());\n+                    if (unsupported != null) {\n+                        return unsupported;\n+                    }\n+                }\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public String visitDelegated(Type.Delegated t, Void unused) {\n+            return t.kind() == Type.Delegated.Kind.TYPEDEF ?\n+                    firstUnsupportedType(t.type()) :\n+                    null;\n+            \/\/in principle we should always do this:\n+            \/\/ return firstUnsupportedType(t.type());\n+            \/\/ but if we do that, we might end up with infinite recursion. Old code did not have that issue\n+            \/\/ as it was layout-based, but doing so it also missed unsupported pointer types (e.g. *long double)\n+        }\n+\n+        @Override\n+        public String visitArray(Type.Array t, Void unused) {\n+            return firstUnsupportedType(t.elementType());\n+        }\n+\n+        @Override\n+        public String visitType(Type t, Void unused) {\n+            return null;\n+        }\n+    };\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/UnsupportedLayouts.java","additions":74,"deletions":19,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.VaList;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -214,4 +217,0 @@\n-    static String getName(Type type) {\n-        return LayoutUtils.getName(type);\n-    }\n-\n@@ -332,0 +331,24 @@\n+\n+    public static String layoutToConstant(ValueLayout vl) {\n+        if (vl.carrier() == boolean.class) {\n+            return \"JAVA_BOOLEAN\";\n+        } else if (vl.carrier() == char.class) {\n+            return \"JAVA_CHAR\";\n+        } else if (vl.carrier() == byte.class) {\n+            return \"JAVA_BYTE\";\n+        } else if (vl.carrier() == short.class) {\n+            return \"JAVA_SHORT\";\n+        } else if (vl.carrier() == int.class) {\n+            return \"JAVA_INT\";\n+        } else if (vl.carrier() == float.class) {\n+            return \"JAVA_FLOAT\";\n+        } else if (vl.carrier() == long.class) {\n+            return \"JAVA_LONG\";\n+        } else if (vl.carrier() == double.class) {\n+            return \"JAVA_DOUBLE\";\n+        } else if (vl.carrier() == MemoryAddress.class) {\n+            return \"ADDRESS\";\n+        } else {\n+            return \"MemoryLayout.paddingLayout(\" + vl.bitSize() +  \")\";\n+        }\n+    }\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/Utils.java","additions":27,"deletions":4,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-                \"--release\", \"17\",\n+                \"--release\", \"18\",\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/Writer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,59 @@\n+\/\/ Generated by jextract\n+\n+import java.lang.invoke.VarHandle;\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryCopy;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import static jdk.incubator.foreign.CLinker.*;\n+\n+public class C-X {\n+    C-X() {}\n+\n+    public static MemorySegment allocate(SegmentAllocator allocator) {\n+        return allocator.allocate(LAYOUT);\n+    }\n+\n+    public static MemorySegment allocate(${CARRIER} val, SegmentAllocator allocator) {\n+        MemorySegment segment = allocator.allocate(LAYOUT);\n+        MemoryAccess.set${CAPITALIZED_CARRIER}AtOffset(segment, 0, val);\n+        return segment;\n+    }\n+\n+    public static MemorySegment allocateArray(long size, SegmentAllocator allocator) {\n+        return allocator.allocateArray(LAYOUT, size);\n+    }\n+\n+    public static MemorySegment allocateArray(${CARRIER}[] values, SegmentAllocator allocator) {\n+        MemorySegment segment = allocator.allocateArray(LAYOUT, values.length);\n+        MemoryCopy.copyFromArray(values, 0, values.length, segment, 0);\n+        return segment;\n+    }\n+    \n+    public static ${CARRIER} get(MemorySegment segment, long offset) {\n+        return MemoryAccess.get${CAPITALIZED_CARRIER}AtOffset(segment, offset);\n+    }\n+\n+    public static void set(MemorySegment segment, long offset, ${CARRIER} value) {\n+        MemoryAccess.set${CAPITALIZED_CARRIER}AtOffset(segment, offset, value);\n+    }\n+\n+    public static long sizeof() {\n+        return LAYOUT.byteSize();\n+    }\n+\n+    public static ${CARRIER}[] toJavaArray(MemorySegment seg) {\n+        var segSize = seg.byteSize();\n+        var elemSize = sizeof();\n+        if (segSize % elemSize != 0) {\n+            throw new UnsupportedOperationException(\"segment cannot contain integral number of elements\");\n+        }\n+        ${CARRIER}[] array = new ${CARRIER}[(int) (segSize \/ elemSize)];\n+        MemoryCopy.copyToArray(seg, 0, array, 0, array.length);\n+        return array;\n+    }\n+\n+    public static final MemoryLayout LAYOUT = ${LAYOUT};\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/resources\/C-X.java.template","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -6,0 +6,1 @@\n+import jdk.incubator.foreign.GroupLayout;\n@@ -12,0 +13,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -23,0 +25,1 @@\n+import static jdk.incubator.foreign.ValueLayout.*;\n@@ -25,0 +28,1 @@\n+\n@@ -26,1 +30,1 @@\n-    private final static CLinker LINKER = CLinker.getInstance();\n+    private final static CLinker LINKER = CLinker.systemCLinker();\n@@ -29,0 +33,1 @@\n+    private final static SymbolLookup SYMBOL_LOOKUP;\n@@ -30,1 +35,2 @@\n-    static SymbolLookup lookup() {\n+    static {\n+        #LOAD_LIBRARIES#\n@@ -32,2 +38,1 @@\n-        SymbolLookup systemLookup = CLinker.systemLookup();\n-        return name -> loaderLookup.lookup(name).or(() -> systemLookup.lookup(name));\n+        SYMBOL_LOOKUP = name -> loaderLookup.lookup(name).or(() -> LINKER.lookup(name));\n@@ -45,2 +50,2 @@\n-    static final MemorySegment lookupGlobalVariable(SymbolLookup LOOKUP, String name, MemoryLayout layout) {\n-        return LOOKUP.lookup(name).map(s -> s.address().asSegment(layout.byteSize(), ResourceScope.newImplicitScope())).orElse(null);\n+    static final MemorySegment lookupGlobalVariable(String name, MemoryLayout layout) {\n+        return SYMBOL_LOOKUP.lookup(name).map(addr -> MemorySegment.ofAddressNative(addr, layout.byteSize(), ResourceScope.newSharedScope())).orElse(null);\n@@ -49,2 +54,2 @@\n-    static final MethodHandle downcallHandle(SymbolLookup LOOKUP, String name, String desc, FunctionDescriptor fdesc, boolean variadic) {\n-        return LOOKUP.lookup(name).map(\n+    static final MethodHandle downcallHandle(String name, FunctionDescriptor fdesc, boolean variadic) {\n+        return SYMBOL_LOOKUP.lookup(name).map(\n@@ -52,1 +57,0 @@\n-                    MethodType mt = MethodType.fromMethodDescriptorString(desc, LOADER);\n@@ -54,2 +58,2 @@\n-                        VarargsInvoker.make(addr, mt, fdesc) :\n-                        LINKER.downcallHandle(addr, mt, fdesc);\n+                        VarargsInvoker.make(addr, fdesc) :\n+                        LINKER.downcallHandle(addr, fdesc);\n@@ -59,1 +63,1 @@\n-    static final MethodHandle downcallHandle(String desc, FunctionDescriptor fdesc, boolean variadic) {\n+    static final MethodHandle downcallHandle(FunctionDescriptor fdesc, boolean variadic) {\n@@ -63,2 +67,1 @@\n-        MethodType mt = MethodType.fromMethodDescriptorString(desc, LOADER);\n-        return LINKER.downcallHandle(mt, fdesc);\n+        return LINKER.downcallHandle(fdesc);\n@@ -67,2 +70,2 @@\n-    static final <Z> MemoryAddress upcallStub(Class<Z> fi, Z z, FunctionDescriptor fdesc, String mtypeDesc) {\n-        return upcallStub(fi, z, fdesc, mtypeDesc, ResourceScope.newImplicitScope());\n+    static final <Z> CLinker.UpcallStub upcallStub(Class<Z> fi, Z z, FunctionDescriptor fdesc, String mtypeDesc) {\n+        return upcallStub(fi, z, fdesc, mtypeDesc, ResourceScope.newConfinedScope());\n@@ -71,1 +74,1 @@\n-    static final <Z> MemoryAddress upcallStub(Class<Z> fi, Z z, FunctionDescriptor fdesc, String mtypeDesc, ResourceScope scope) {\n+    static final <Z> CLinker.UpcallStub upcallStub(Class<Z> fi, Z z, FunctionDescriptor fdesc, String mtypeDesc, ResourceScope scope) {\n@@ -83,1 +86,1 @@\n-         return addr.asSegment(numElements * layout.byteSize(), scope);\n+         return MemorySegment.ofAddressNative(addr, numElements * layout.byteSize(), scope);\n@@ -91,1 +94,0 @@\n-        private final MethodType varargs;\n@@ -94,1 +96,1 @@\n-        private VarargsInvoker(Addressable symbol, MethodType type, FunctionDescriptor function) {\n+        private VarargsInvoker(Addressable symbol, FunctionDescriptor function) {\n@@ -96,1 +98,0 @@\n-            this.varargs = type;\n@@ -108,5 +109,10 @@\n-        static MethodHandle make(Addressable symbol, MethodType type, FunctionDescriptor function) {\n-            VarargsInvoker invoker = new VarargsInvoker(symbol, type, function);\n-            MethodHandle handle = INVOKE_MH.bindTo(invoker).asCollector(Object[].class, type.parameterCount());\n-            if (type.returnType().equals(MemorySegment.class)) {\n-                type = type.insertParameterTypes(0, SegmentAllocator.class);\n+        static MethodHandle make(Addressable symbol, FunctionDescriptor function) {\n+            VarargsInvoker invoker = new VarargsInvoker(symbol, function);\n+            MethodHandle handle = INVOKE_MH.bindTo(invoker).asCollector(Object[].class, function.argumentLayouts().size() + 1);\n+            MethodType mtype = MethodType.methodType(function.returnLayout().isPresent() ? carrier(function.returnLayout().get(), true) : void.class);\n+            for (MemoryLayout layout : function.argumentLayouts()) {\n+                mtype = mtype.appendParameterTypes(carrier(layout, false));\n+            }\n+            mtype = mtype.appendParameterTypes(Object[].class);\n+            if (mtype.returnType().equals(MemorySegment.class)) {\n+                mtype = mtype.insertParameterTypes(0, SegmentAllocator.class);\n@@ -116,1 +122,12 @@\n-            return handle.asType(type);\n+            return handle.asType(mtype);\n+        }\n+\n+        static Class<?> carrier(MemoryLayout layout, boolean ret) {\n+            if (layout instanceof ValueLayout valueLayout) {\n+                return (ret || valueLayout.carrier() != MemoryAddress.class) ?\n+                        valueLayout.carrier() : Addressable.class;\n+            } else if (layout instanceof GroupLayout) {\n+                return MemorySegment.class;\n+            } else {\n+                throw new AssertionError(\"Cannot get here!\");\n+            }\n@@ -132,1 +149,0 @@\n-                argTypes[pos] = varargs.parameterType(pos);\n@@ -138,2 +154,1 @@\n-                argTypes[pos] = normalize(o.getClass());\n-                argLayouts[pos] = variadicLayout(argTypes[pos]);\n+                argLayouts[pos] = variadicLayout(normalize(o.getClass()));\n@@ -144,1 +159,0 @@\n-            MethodType mt = MethodType.methodType(varargs.returnType(), argTypes);\n@@ -148,1 +162,4 @@\n-            MethodHandle mh = LINKER.downcallHandle(symbol, allocator, mt, f);\n+            MethodHandle mh = LINKER.downcallHandle(symbol, f);\n+            if (mh.type().returnType() == MemorySegment.class) {\n+                mh = mh.bindTo(allocator);\n+            }\n@@ -207,1 +224,1 @@\n-                return C_LONG_LONG;\n+                return JAVA_LONG;\n@@ -209,1 +226,1 @@\n-                return C_DOUBLE;\n+                return JAVA_DOUBLE;\n@@ -211,1 +228,1 @@\n-                return C_POINTER;\n+                return ADDRESS;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/resources\/RuntimeHelper.java.template","additions":52,"deletions":35,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n","filename":"test\/jdk\/java\/jextract\/TestAttributes.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-        return actual -> assertEquals(CLinker.toJavaString(actual), expected);\n+        return actual -> assertEquals(actual.getUtf8String(0), expected);\n","filename":"test\/jdk\/tools\/jextract\/ConstantsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -56,0 +57,12 @@\n+    private static final boolean IS_WINDOWS = System.getProperty(\"os.name\").startsWith(\"Windows\");\n+\n+    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n+    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n+    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;\n+    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;\n+    public static final ValueLayout C_LONG = IS_WINDOWS ? ValueLayout.JAVA_INT : ValueLayout.JAVA_LONG;\n+    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;\n+    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;\n+    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;\n+    public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS;\n+\n","filename":"test\/jdk\/tools\/jextract\/JextractToolRunner.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -109,2 +109,2 @@\n-        checkField(pointLayout, \"i\", CLinker.C_INT);\n-        checkField(pointLayout, \"j\", CLinker.C_INT);\n+        checkField(pointLayout, \"i\", C_INT);\n+        checkField(pointLayout, \"j\", C_INT);\n@@ -117,3 +117,3 @@\n-        checkField(point3DLayout, \"i\", CLinker.C_INT);\n-        checkField(point3DLayout, \"j\", CLinker.C_INT);\n-        checkField(point3DLayout, \"k\", CLinker.C_INT);\n+        checkField(point3DLayout, \"i\", C_INT);\n+        checkField(point3DLayout, \"j\", C_INT);\n+        checkField(point3DLayout, \"k\", C_INT);\n","filename":"test\/jdk\/tools\/jextract\/RepeatedDeclsTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -57,3 +57,3 @@\n-            checkField(fooLayout, \"x\",  CLinker.C_INT);\n-            checkField(fooLayout, \"y\",  CLinker.C_INT);\n-            checkField(fooLayout, \"z\",  CLinker.C_INT);\n+            checkField(fooLayout, \"x\",  C_INT);\n+            checkField(fooLayout, \"y\",  C_INT);\n+            checkField(fooLayout, \"z\",  C_INT);\n@@ -69,2 +69,2 @@\n-            checkField(foo2Layout, \"i\",  CLinker.C_INT);\n-            checkField(foo2Layout, \"l\",  CLinker.C_LONG);\n+            checkField(foo2Layout, \"i\", C_INT);\n+            checkField(foo2Layout, \"l\", C_LONG);\n@@ -83,2 +83,2 @@\n-            checkField(barLayout, \"f1\",  CLinker.C_FLOAT);\n-            checkField(barLayout, \"f2\",  CLinker.C_FLOAT);\n+            checkField(barLayout, \"f1\",  C_FLOAT);\n+            checkField(barLayout, \"f2\",  C_FLOAT);\n@@ -94,2 +94,2 @@\n-            checkField(bar2Layout, \"f\",  CLinker.C_FLOAT);\n-            checkField(bar2Layout, \"d\",  CLinker.C_DOUBLE);\n+            checkField(bar2Layout, \"f\", C_FLOAT);\n+            checkField(bar2Layout, \"d\", C_DOUBLE);\n","filename":"test\/jdk\/tools\/jextract\/Test8240811.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -54,2 +54,2 @@\n-            checkField(intOrFloatLayout, \"i\",  CLinker.C_INT);\n-            checkField(intOrFloatLayout, \"f\", CLinker.C_FLOAT);\n+            checkField(intOrFloatLayout, \"i\",  C_INT);\n+            checkField(intOrFloatLayout, \"f\", C_FLOAT);\n","filename":"test\/jdk\/tools\/jextract\/UniondeclTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,2 +35,0 @@\n-import static jdk.incubator.foreign.CLinker.C_INT;\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n","filename":"test\/jdk\/tools\/jextract\/incompleteArray\/IncompleteArrayTest.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemorySegment;\n@@ -48,3 +48,2 @@\n-            var allocator = SegmentAllocator.ofScope(scope);\n-            var addr = allocator.allocate(C_INT, 12);\n-            assertEquals(MemoryAccess.getInt(addr), 12);\n+            var addr = scope.allocate(C_INT, 12);\n+            assertEquals(addr.get(C_INT, 0), 12);\n@@ -52,1 +51,1 @@\n-            assertEquals(MemoryAccess.getInt(addr), 144);\n+            assertEquals(addr.get(C_INT, 0), 144);\n@@ -54,2 +53,2 @@\n-            addr = allocator.allocate(C_DOUBLE, 12.0);\n-            assertEquals(MemoryAccess.getDouble(addr), 12.0, 0.1);\n+            addr = scope.allocate(C_DOUBLE, 12.0);\n+            assertEquals(addr.get(C_DOUBLE, 0), 12.0, 0.1);\n@@ -57,1 +56,1 @@\n-            assertEquals(MemoryAccess.getDouble(addr), 144.0, 0.1);\n+            assertEquals(addr.get(C_DOUBLE, 0), 144.0, 0.1);\n@@ -60,1 +59,1 @@\n-            addr = allocator.allocateArray(C_INT, intArray);\n+            addr = scope.allocateArray(C_INT, intArray);\n@@ -63,1 +62,1 @@\n-            int[] convertedArray = addr.toIntArray();\n+            int[] convertedArray = addr.toArray(C_INT);\n@@ -67,1 +66,1 @@\n-            addr = allocator.allocateArray(C_DOUBLE, dblArray);\n+            addr = scope.allocateArray(C_DOUBLE, dblArray);\n@@ -70,1 +69,1 @@\n-            double[] convertedDblArray = addr.toDoubleArray();\n+            double[] convertedDblArray = addr.toArray(C_DOUBLE);\n@@ -75,1 +74,1 @@\n-            assertEquals(toJavaString(name()), \"java\");\n+            assertEquals(name().getUtf8String(0), \"java\");\n@@ -77,4 +76,4 @@\n-            var dest = allocator.allocateArray(C_CHAR, 12);\n-            dest.copyFrom(toCString(\"hello \", scope));\n-            var src = toCString(\"world\", scope);\n-            assertEquals(toJavaString(concatenate(dest, src)), \"hello world\");\n+            var dest = scope.allocateArray(C_CHAR, 12);\n+            dest.copyFrom(scope.allocateUtf8String(\"hello \"));\n+            var src = scope.allocateUtf8String(\"world\");\n+            assertEquals(concatenate(dest, src).getUtf8String(0), \"hello world\");\n","filename":"test\/jdk\/tools\/jextract\/test8241925\/LibTest8241925Test.java","additions":16,"deletions":17,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -59,5 +58,4 @@\n-            var allocator = SegmentAllocator.ofScope(scope);\n-            var addr = allocator.allocate(mysize_t, 0L);\n-            assertEquals(MemoryAccess.getLong(addr), 0L);\n-            MemoryAccess.setLong(addr, 13455566L);\n-            assertEquals(MemoryAccess.getLong(addr), 13455566L);\n+            var addr = scope.allocate(mysize_t, 0L);\n+            assertEquals(addr.get(C_LONG_LONG, 0), 0L);\n+            addr.set(C_LONG_LONG, 0, 13455566L);\n+            assertEquals(addr.get(C_LONG_LONG, 0), 13455566L);\n","filename":"test\/jdk\/tools\/jextract\/test8244412\/LibTest8244412Test.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-                    toCString(\"%hhd %c %.2f %.2f %lld %lld %d %hd %d %d %lld %c\", scope), 12,\n+                    scope.allocateUtf8String(\"%hhd %c %.2f %.2f %lld %lld %d %hd %d %d %lld %c\"), 12,\n@@ -59,1 +59,1 @@\n-            String str = toJavaString(s);\n+            String str = s.getUtf8String(0);\n","filename":"test\/jdk\/tools\/jextract\/test8244959\/Test8244959.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-        int[] arr = seg.toIntArray();\n+        int[] arr = seg.toArray(C_INT);\n@@ -83,1 +83,1 @@\n-        byte[] barr = greeting.toByteArray();\n+        byte[] barr = greeting.toArray(C_CHAR);\n","filename":"test\/jdk\/tools\/jextract\/test8245003\/Test8245003.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -24,1 +24,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -26,0 +25,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -60,1 +60,1 @@\n-                var addr = argv.asSegment(C_POINTER.byteSize() * argc, scope);\n+                var addr = MemorySegment.ofAddressNative(argv, C_POINTER.byteSize() * argc, scope);\n@@ -62,4 +62,4 @@\n-                assertEquals(toJavaString(MemoryAccess.getAddressAtIndex(addr, 0)), \"java\");\n-                assertEquals(toJavaString(MemoryAccess.getAddressAtIndex(addr, 1)), \"python\");\n-                assertEquals(toJavaString(MemoryAccess.getAddressAtIndex(addr, 2)), \"javascript\");\n-                assertEquals(toJavaString(MemoryAccess.getAddressAtIndex(addr, 3)), \"c++\");\n+                assertEquals(addr.get(C_POINTER, 0).getUtf8String(0), \"java\");\n+                assertEquals(addr.get(C_POINTER, C_POINTER.byteSize() * 1).getUtf8String(0), \"python\");\n+                assertEquals(addr.get(C_POINTER, C_POINTER.byteSize() * 2).getUtf8String(0), \"javascript\");\n+                assertEquals(addr.get(C_POINTER, C_POINTER.byteSize() * 3).getUtf8String(0), \"c++\");\n@@ -77,1 +77,1 @@\n-            MemoryAccess.setAddress(addr, MemoryAddress.NULL);\n+            addr.set(C_POINTER, 0, MemoryAddress.NULL);\n@@ -79,1 +79,1 @@\n-            assertEquals(toJavaString(MemoryAccess.getAddress(addr)), \"hello world\");\n+            assertEquals(addr.get(C_POINTER, 0).getUtf8String(0), \"hello world\");\n","filename":"test\/jdk\/tools\/jextract\/test8246341\/LibTest8246341Test.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -69,1 +70,1 @@\n-            MemoryAddress callback = cosine_similarity$dot.allocate((a, b) -> {\n+            Addressable callback = cosine_similarity$dot.allocate((a, b) -> {\n","filename":"test\/jdk\/tools\/jextract\/test8246400\/LibTest8246400Test.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import jdk.incubator.foreign.VaList;\n@@ -57,4 +58,4 @@\n-                b.vargFromInt(C_INT, 12);\n-                b.vargFromDouble(C_DOUBLE, 5.5d);\n-                b.vargFromLong(C_LONG_LONG, -200L);\n-                b.vargFromLong(C_LONG_LONG, Long.MAX_VALUE);\n+                b.addVarg(C_INT, 12);\n+                b.addVarg(C_DOUBLE, 5.5d);\n+                b.addVarg(C_LONG_LONG, -200L);\n+                b.addVarg(C_LONG_LONG, Long.MAX_VALUE);\n@@ -62,2 +63,2 @@\n-            my_vsprintf(s, toCString(\"%hhd %.2f %lld %lld\", scope), vaList);\n-            String str = toJavaString(s);\n+            my_vsprintf(s, scope.allocateUtf8String(\"%hhd %.2f %lld %lld\"), vaList);\n+            String str = s.getUtf8String(0);\n","filename":"test\/jdk\/tools\/jextract\/test8252016\/Test8252016.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.incubator.foreign.CLinker;\n@@ -58,1 +57,0 @@\n-            var allocator = SegmentAllocator.ofScope(scope);\n@@ -60,1 +58,1 @@\n-            MemorySegment seg = allocator.allocateArray(CLinker.C_INT, array);\n+            MemorySegment seg = scope.allocateArray(C_INT, array);\n","filename":"test\/jdk\/tools\/jextract\/test8252121\/Test8252121.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-            CLinker.freeMemory(addr);\n+            freePoint(addr);\n","filename":"test\/jdk\/tools\/jextract\/test8253102\/LibTest8253102Test.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,4 @@\n+\n+EXPORT void freePoint(struct Point* ptr) {\n+    free(ptr);\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8253102\/libTest8253102.c","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+EXPORT void freePoint(struct Point*);\n+\n","filename":"test\/jdk\/tools\/jextract\/test8253102\/test8253102.h","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import static jdk.incubator.foreign.CLinker.toJavaString;\n@@ -50,2 +49,2 @@\n-        assertEquals(toJavaString(GREETING()), \"hello\\nworld\");\n-        assertEquals(toJavaString(GREETING2()), \"hello\\tworld\");\n+        assertEquals(GREETING().getUtf8String(0), \"hello\\nworld\");\n+        assertEquals(GREETING2().getUtf8String(0), \"hello\\tworld\");\n","filename":"test\/jdk\/tools\/jextract\/test8253390\/LibTest8253390Test.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.CLinker;\n@@ -29,0 +28,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -70,1 +70,1 @@\n-            var seg = getFoo().asSegment(Foo.sizeof(), scope);\n+            var seg = MemorySegment.ofAddressNative(getFoo(), Foo.sizeof(), scope);\n@@ -85,2 +85,2 @@\n-        checkField(g, \"i\", CLinker.C_INT);\n-        checkField(g, \"c\", CLinker.C_CHAR);\n+        checkField(g, \"i\", C_INT);\n+        checkField(g, \"c\", C_CHAR);\n","filename":"test\/jdk\/tools\/jextract\/test8257892\/LibUnsupportedTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n@@ -54,6 +56,0 @@\n-import static jdk.incubator.foreign.CLinker.C_CHAR;\n-import static jdk.incubator.foreign.CLinker.C_DOUBLE;\n-import static jdk.incubator.foreign.CLinker.C_FLOAT;\n-import static jdk.incubator.foreign.CLinker.C_INT;\n-import static jdk.incubator.foreign.CLinker.C_LONG_LONG;\n-import static jdk.incubator.foreign.CLinker.C_SHORT;\n@@ -65,1 +61,1 @@\n-    private static final VarHandle VH_bytes = MemoryLayout.sequenceLayout(C_CHAR).varHandle(byte.class, sequenceElement());\n+    private static final VarHandle VH_bytes = MemoryLayout.sequenceLayout(C_CHAR).varHandle(sequenceElement());\n@@ -220,1 +216,1 @@\n-        checkMethod(fiClass, \"allocate\", MemoryAddress.class, fiClass);\n+        checkMethod(fiClass, \"allocate\", CLinker.UpcallStub.class, fiClass);\n","filename":"test\/jdk\/tools\/jextract\/testClassGen\/TestClassGeneration.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -95,12 +95,12 @@\n-        checkField(g, \"sc\", CLinker.C_CHAR);\n-        checkField(g, \"uc\", CLinker.C_CHAR);\n-        checkField(g, \"s\",  CLinker.C_SHORT);\n-        checkField(g, \"us\", CLinker.C_SHORT);\n-        checkField(g, \"i\",  CLinker.C_INT);\n-        checkField(g, \"ui\", CLinker.C_INT);\n-        checkField(g, \"l\",  CLinker.C_LONG);\n-        checkField(g, \"ul\", CLinker.C_LONG);\n-        checkField(g, \"ll\", CLinker.C_LONG_LONG);\n-        checkField(g, \"ull\",CLinker.C_LONG_LONG);\n-        checkField(g, \"f\",  CLinker.C_FLOAT);\n-        checkField(g, \"d\",  CLinker.C_DOUBLE);\n+        checkField(g, \"sc\", C_CHAR);\n+        checkField(g, \"uc\", C_CHAR);\n+        checkField(g, \"s\",  C_SHORT);\n+        checkField(g, \"us\", C_SHORT);\n+        checkField(g, \"i\",  C_INT);\n+        checkField(g, \"ui\", C_INT);\n+        checkField(g, \"l\",  C_LONG);\n+        checkField(g, \"ul\", C_LONG);\n+        checkField(g, \"ll\", C_LONG_LONG);\n+        checkField(g, \"ull\",C_LONG_LONG);\n+        checkField(g, \"f\",  C_FLOAT);\n+        checkField(g, \"d\",  C_DOUBLE);\n","filename":"test\/jdk\/tools\/jextract\/testStruct\/LibStructTest.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"}]}