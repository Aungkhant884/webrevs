{"files":[{"patch":"@@ -1082,0 +1082,1 @@\n+<<<<<<< HEAD\n@@ -1083,0 +1084,4 @@\n+=======\n+    _method_Scoped,\n+    _method_HotSpotIntrinsicCandidate,\n+>>>>>>> b6d387e1715d891f845931f4c168a07a95c1144f\n@@ -2105,0 +2110,1 @@\n+<<<<<<< HEAD\n@@ -2106,0 +2112,8 @@\n+=======\n+    case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_misc_Scoped_signature): {\n+      if (_location != _in_method)  break;  \/\/ only allow for methods\n+      if (!privileged)              break;  \/\/ only allow in privileged code\n+      return _method_Scoped;\n+    }\n+    case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_HotSpotIntrinsicCandidate_signature): {\n+>>>>>>> b6d387e1715d891f845931f4c168a07a95c1144f\n@@ -2162,0 +2176,1 @@\n+<<<<<<< HEAD\n@@ -2163,0 +2178,5 @@\n+=======\n+  if (has_annotation(_method_Scoped))\n+    m->set_scoped(true);\n+  if (has_annotation(_method_HotSpotIntrinsicCandidate) && !m->is_synthetic())\n+>>>>>>> b6d387e1715d891f845931f4c168a07a95c1144f\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -132,0 +132,1 @@\n+  template(jdk_internal_misc_ScopedMemoryAccess_Scope_ScopedAccessError, \"jdk\/internal\/misc\/ScopedMemoryAccess$Scope$ScopedAccessError\") \\\n@@ -290,0 +291,1 @@\n+<<<<<<< HEAD\n@@ -291,0 +293,3 @@\n+=======\n+  template(jdk_internal_misc_Scoped_signature,    \"Ljdk\/internal\/misc\/ScopedMemoryAccess$Scoped;\") \\\n+>>>>>>> b6d387e1715d891f845931f4c168a07a95c1144f\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.util.function.BiFunction;\n@@ -40,0 +41,1 @@\n+import java.util.function.Function;\n@@ -84,1 +86,1 @@\n-    static void initBytes(MemoryAddress base, SequenceLayout seq, BiConsumer<MemoryAddress, Long> handleSetter) {\n+    static void initBytes(MemorySegment base, SequenceLayout seq, BiConsumer<MemorySegment, Long> handleSetter) {\n@@ -90,6 +92,6 @@\n-    static void checkBytes(MemoryAddress base, SequenceLayout layout) {\n-        long nBytes = layout.elementCount().getAsLong() * layout.elementLayout().byteSize();\n-        byte[] arr = base.segment().toByteArray();\n-        for (long i = 0 ; i < nBytes ; i++) {\n-            byte expected = (byte)byteHandle.get(base, i);\n-            byte found = arr[(int)i];\n+    static void checkBytes(MemorySegment base, SequenceLayout layout, Function<MemorySegment, Object> arrayFactory, BiFunction<MemorySegment, Long, Object> handleGetter) {\n+        int nelems = (int)layout.elementCount().getAsLong();\n+        Object arr = arrayFactory.apply(base);\n+        for (int i = 0; i < nelems; i++) {\n+            Object found = handleGetter.apply(base, (long) i);\n+            Object expected = java.lang.reflect.Array.get(arr, i);\n@@ -101,1 +103,1 @@\n-    public void testArrays(Consumer<MemoryAddress> init, SequenceLayout layout) {\n+    public void testArrays(Consumer<MemorySegment> init, Consumer<MemorySegment> checker, MemoryLayout layout) {\n@@ -103,2 +105,2 @@\n-            init.accept(segment.baseAddress());\n-            checkBytes(segment.baseAddress(), layout);\n+            init.accept(segment);\n+            checker.accept(segment);\n@@ -108,0 +110,1 @@\n+<<<<<<< HEAD\n@@ -112,0 +115,9 @@\n+=======\n+    @Test(dataProvider = \"elemLayouts\",\n+          expectedExceptions = UnsupportedOperationException.class)\n+    public void testTooBigForArray(MemoryLayout layout, Function<MemorySegment, Object> arrayFactory) {\n+        MemoryLayout seq = MemoryLayout.ofSequence((Integer.MAX_VALUE * layout.byteSize()) + 1, layout);\n+        \/\/do not really allocate here, as it's way too much memory\n+        try (MemorySegment segment = MemoryAddress.NULL.asSegmentRestricted(seq.byteSize())) {\n+            arrayFactory.apply(segment);\n+>>>>>>> b6d387e1715d891f845931f4c168a07a95c1144f\n@@ -115,3 +127,13 @@\n-    @Test(expectedExceptions = IllegalStateException.class)\n-    public void testArrayFromClosedSegment() {\n-        MemorySegment segment = MemorySegment.allocateNative(8);\n+    @Test(dataProvider = \"elemLayouts\",\n+          expectedExceptions = UnsupportedOperationException.class)\n+    public void testBadSize(MemoryLayout layout, Function<MemorySegment, Object> arrayFactory) {\n+        if (layout.byteSize() == 1) throw new UnsupportedOperationException(); \/\/make it fail\n+        try (MemorySegment segment = MemorySegment.allocateNative(layout.byteSize() + 1)) {\n+            arrayFactory.apply(segment);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"elemLayouts\",\n+            expectedExceptions = IllegalStateException.class)\n+    public void testArrayFromClosedSegment(MemoryLayout layout, Function<MemorySegment, Object> arrayFactory) {\n+        MemorySegment segment = MemorySegment.allocateNative(layout);\n@@ -119,1 +141,1 @@\n-        segment.toByteArray();\n+        arrayFactory.apply(segment);\n@@ -122,5 +144,6 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testArrayFromHeapSegmentWithoutAccess() {\n-        MemorySegment segment = MemorySegment.ofArray(new byte[8]);\n-        segment = segment.withAccessModes(segment.accessModes() & ~READ);\n-        segment.toByteArray();\n+    @Test(dataProvider = \"elemLayouts\",\n+          expectedExceptions = UnsupportedOperationException.class)\n+    public void testArrayFromHeapSegmentWithoutAccess(MemoryLayout layout, Function<MemorySegment, Object> arrayFactory) {\n+        MemorySegment segment = MemorySegment.ofArray(new byte[(int)layout.byteSize()]);\n+        segment = segment.withAccessModes(MemorySegment.ALL_ACCESS & ~READ);\n+        arrayFactory.apply(segment);\n@@ -129,5 +152,6 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testArrayFromNativeSegmentWithoutAccess() {\n-        MemorySegment segment = MemorySegment.allocateNative(8);\n-        segment = segment.withAccessModes(segment.accessModes() & ~READ);\n-        segment.toByteArray();\n+    @Test(dataProvider = \"elemLayouts\",\n+            expectedExceptions = UnsupportedOperationException.class)\n+    public void testArrayFromNativeSegmentWithoutAccess(MemoryLayout layout, Function<MemorySegment, Object> arrayFactory) {\n+        try (MemorySegment segment = MemorySegment.allocateNative(layout).withAccessModes(MemorySegment.ALL_ACCESS & ~READ)) {\n+            arrayFactory.apply(segment);\n+        }\n@@ -138,1 +162,1 @@\n-        Consumer<MemoryAddress> byteInitializer =\n+        Consumer<MemorySegment> byteInitializer =\n@@ -140,1 +164,1 @@\n-        Consumer<MemoryAddress> charInitializer =\n+        Consumer<MemorySegment> charInitializer =\n@@ -142,1 +166,1 @@\n-        Consumer<MemoryAddress> shortInitializer =\n+        Consumer<MemorySegment> shortInitializer =\n@@ -144,1 +168,1 @@\n-        Consumer<MemoryAddress> intInitializer =\n+        Consumer<MemorySegment> intInitializer =\n@@ -146,1 +170,1 @@\n-        Consumer<MemoryAddress> floatInitializer =\n+        Consumer<MemorySegment> floatInitializer =\n@@ -148,1 +172,1 @@\n-        Consumer<MemoryAddress> longInitializer =\n+        Consumer<MemorySegment> longInitializer =\n@@ -150,1 +174,1 @@\n-        Consumer<MemoryAddress> doubleInitializer =\n+        Consumer<MemorySegment> doubleInitializer =\n@@ -153,0 +177,15 @@\n+        Consumer<MemorySegment> byteChecker =\n+                (base) -> checkBytes(base, bytes, MemorySegment::toByteArray, (addr, pos) -> (byte)byteHandle.get(addr, pos));\n+        Consumer<MemorySegment> shortChecker =\n+                (base) -> checkBytes(base, shorts, MemorySegment::toShortArray, (addr, pos) -> (short)shortHandle.get(addr, pos));\n+        Consumer<MemorySegment> charChecker =\n+                (base) -> checkBytes(base, chars, MemorySegment::toCharArray, (addr, pos) -> (char)charHandle.get(addr, pos));\n+        Consumer<MemorySegment> intChecker =\n+                (base) -> checkBytes(base, ints, MemorySegment::toIntArray, (addr, pos) -> (int)intHandle.get(addr, pos));\n+        Consumer<MemorySegment> floatChecker =\n+                (base) -> checkBytes(base, floats, MemorySegment::toFloatArray, (addr, pos) -> (float)floatHandle.get(addr, pos));\n+        Consumer<MemorySegment> longChecker =\n+                (base) -> checkBytes(base, longs, MemorySegment::toLongArray, (addr, pos) -> (long)longHandle.get(addr, pos));\n+        Consumer<MemorySegment> doubleChecker =\n+                (base) -> checkBytes(base, doubles, MemorySegment::toDoubleArray, (addr, pos) -> (double)doubleHandle.get(addr, pos));\n+\n@@ -154,7 +193,20 @@\n-                {byteInitializer, bytes},\n-                {charInitializer, chars},\n-                {shortInitializer, shorts},\n-                {intInitializer, ints},\n-                {floatInitializer, floats},\n-                {longInitializer, longs},\n-                {doubleInitializer, doubles}\n+                {byteInitializer, byteChecker, bytes},\n+                {charInitializer, charChecker, chars},\n+                {shortInitializer, shortChecker, shorts},\n+                {intInitializer, intChecker, ints},\n+                {floatInitializer, floatChecker, floats},\n+                {longInitializer, longChecker, longs},\n+                {doubleInitializer, doubleChecker, doubles}\n+        };\n+    }\n+\n+    @DataProvider(name = \"elemLayouts\")\n+    public Object[][] elemLayouts() {\n+        return new Object[][] {\n+                { MemoryLayouts.JAVA_BYTE, (Function<MemorySegment, Object>) MemorySegment::toByteArray },\n+                { MemoryLayouts.JAVA_SHORT, (Function<MemorySegment, Object>) MemorySegment::toShortArray },\n+                { MemoryLayouts.JAVA_CHAR, (Function<MemorySegment, Object>) MemorySegment::toCharArray },\n+                { MemoryLayouts.JAVA_INT, (Function<MemorySegment, Object>) MemorySegment::toIntArray },\n+                { MemoryLayouts.JAVA_FLOAT, (Function<MemorySegment, Object>) MemorySegment::toFloatArray },\n+                { MemoryLayouts.JAVA_LONG, (Function<MemorySegment, Object>) MemorySegment::toLongArray },\n+                { MemoryLayouts.JAVA_DOUBLE, (Function<MemorySegment, Object>) MemorySegment::toDoubleArray }\n","filename":"test\/jdk\/java\/foreign\/TestArrays.java","additions":90,"deletions":38,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -7,3 +7,1 @@\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n+ * published by the Free Software Foundation.\n@@ -30,0 +28,1 @@\n+<<<<<<< HEAD\n@@ -31,0 +30,3 @@\n+=======\n+ * @run testng\/othervm -XX:MaxDirectMemorySize=3000000000 TestByteBuffer\n+>>>>>>> b6d387e1715d891f845931f4c168a07a95c1144f\n@@ -35,0 +37,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -137,10 +140,1 @@\n-    static VarHandle byteHandle = bytes.varHandle(byte.class, PathElement.sequenceElement());\n-    static VarHandle charHandle = chars.varHandle(char.class, PathElement.sequenceElement());\n-    static VarHandle shortHandle = shorts.varHandle(short.class, PathElement.sequenceElement());\n-    static VarHandle intHandle = ints.varHandle(int.class, PathElement.sequenceElement());\n-    static VarHandle floatHandle = floats.varHandle(float.class, PathElement.sequenceElement());\n-    static VarHandle longHandle = longs.varHandle(long.class, PathElement.sequenceElement());\n-    static VarHandle doubleHandle = doubles.varHandle(double.class, PathElement.sequenceElement());\n-\n-\n-    static void initTuples(MemoryAddress base, long count) {\n+    static void initTuples(MemorySegment base, long count) {\n@@ -153,1 +147,1 @@\n-    static void checkTuples(MemoryAddress base, ByteBuffer bb, long count) {\n+    static void checkTuples(MemorySegment base, ByteBuffer bb, long count) {\n@@ -163,1 +157,1 @@\n-    static void initBytes(MemoryAddress base, SequenceLayout seq, BiConsumer<MemoryAddress, Long> handleSetter) {\n+    static void initBytes(MemorySegment base, SequenceLayout seq, BiConsumer<MemorySegment, Long> handleSetter) {\n@@ -169,1 +163,1 @@\n-    static <Z extends Buffer> void checkBytes(MemoryAddress base, SequenceLayout layout,\n+    static <Z extends Buffer> void checkBytes(MemorySegment base, SequenceLayout layout,\n@@ -171,1 +165,1 @@\n-                                              BiFunction<MemoryAddress, Long, Object> handleExtractor,\n+                                              BiFunction<MemorySegment, Long, Object> handleExtractor,\n@@ -177,1 +171,1 @@\n-            MemorySegment resizedSegment = base.segment().asSlice(i * elemSize, limit * elemSize);\n+            MemorySegment resizedSegment = base.asSlice(i * elemSize, limit * elemSize);\n@@ -181,1 +175,1 @@\n-                Object handleValue = handleExtractor.apply(resizedSegment.baseAddress(), j - i);\n+                Object handleValue = handleExtractor.apply(resizedSegment, j - i);\n@@ -197,2 +191,1 @@\n-            MemoryAddress base = segment.baseAddress();\n-            initTuples(base, tuples.elementCount().getAsLong());\n+            initTuples(segment, tuples.elementCount().getAsLong());\n@@ -201,1 +194,1 @@\n-            checkTuples(base, bb, tuples.elementCount().getAsLong());\n+            checkTuples(segment, bb, tuples.elementCount().getAsLong());\n@@ -209,2 +202,1 @@\n-        MemoryAddress base = region.baseAddress();\n-        initTuples(base, tuples.elementCount().getAsLong());\n+        initTuples(region, tuples.elementCount().getAsLong());\n@@ -213,1 +205,1 @@\n-        checkTuples(base, bb, tuples.elementCount().getAsLong());\n+        checkTuples(region, bb, tuples.elementCount().getAsLong());\n@@ -226,2 +218,1 @@\n-                MemoryAddress base = segment.baseAddress();\n-                initTuples(base, tuples.elementCount().getAsLong());\n+                initTuples(segment, tuples.elementCount().getAsLong());\n@@ -236,2 +227,1 @@\n-                MemoryAddress base = segment.baseAddress();\n-                checkTuples(base, mbb, tuples.elementCount().getAsLong());\n+                checkTuples(segment, mbb, tuples.elementCount().getAsLong());\n@@ -263,2 +253,1 @@\n-            MemoryAddress base = segment.baseAddress();\n-            initTuples(base, tuples.elementCount().getAsLong());\n+            initTuples(segment, tuples.elementCount().getAsLong());\n@@ -270,2 +259,1 @@\n-            MemoryAddress base = segment.baseAddress();\n-            checkTuples(base, segment.asByteBuffer(), tuples.elementCount().getAsLong());\n+            checkTuples(segment, segment.asByteBuffer(), tuples.elementCount().getAsLong());\n@@ -287,2 +275,1 @@\n-                MemoryAddress base = segment.baseAddress();\n-                initTuples(base, 1);\n+                initTuples(segment, 1);\n@@ -297,2 +284,1 @@\n-                MemoryAddress base = segment.baseAddress();\n-                checkTuples(base, segment.asByteBuffer(), 1);\n+                checkTuples(segment, segment.asByteBuffer(), 1);\n@@ -326,1 +312,0 @@\n-            MemoryAddress base = segment.baseAddress();\n@@ -331,2 +316,3 @@\n-            if (!e.getKey().getName().contains(\"get\") &&\n-                            !e.getKey().getName().contains(\"put\")) {\n+            if ((!e.getKey().getName().contains(\"get\") &&\n+                            !e.getKey().getName().contains(\"put\"))\n+                            || e.getValue().length > 2) { \/\/ skip bulk ops\n@@ -392,1 +378,0 @@\n-            MemoryAddress base = segment.baseAddress();\n@@ -396,1 +381,1 @@\n-            assertEquals(directBuffer.address(), ((MemoryAddressImpl)base).unsafeGetOffset());\n+            assertEquals(directBuffer.address(), segment.address().toRawLongValue());\n@@ -403,1 +388,1 @@\n-    public void testResizeOffheap(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {\n+    public void testResizeOffheap(Consumer<MemorySegment> checker, Consumer<MemorySegment> initializer, SequenceLayout seq) {\n@@ -405,3 +390,2 @@\n-            MemoryAddress base = segment.baseAddress();\n-            initializer.accept(base);\n-            checker.accept(base);\n+            initializer.accept(segment);\n+            checker.accept(segment);\n@@ -412,1 +396,1 @@\n-    public void testResizeHeap(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {\n+    public void testResizeHeap(Consumer<MemorySegment> checker, Consumer<MemorySegment> initializer, SequenceLayout seq) {\n@@ -415,1 +399,1 @@\n-        MemoryAddress base = MemorySegment.ofArray(new byte[capacity]).baseAddress();\n+        MemorySegment base = MemorySegment.ofArray(new byte[capacity]);\n@@ -421,1 +405,1 @@\n-    public void testResizeBuffer(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {\n+    public void testResizeBuffer(Consumer<MemorySegment> checker, Consumer<MemorySegment> initializer, SequenceLayout seq) {\n@@ -424,1 +408,1 @@\n-        MemoryAddress base = MemorySegment.ofByteBuffer(ByteBuffer.wrap(new byte[capacity])).baseAddress();\n+        MemorySegment base = MemorySegment.ofByteBuffer(ByteBuffer.wrap(new byte[capacity]));\n@@ -430,1 +414,1 @@\n-    public void testResizeRoundtripHeap(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {\n+    public void testResizeRoundtripHeap(Consumer<MemorySegment> checker, Consumer<MemorySegment> initializer, SequenceLayout seq) {\n@@ -435,3 +419,2 @@\n-        MemoryAddress first = segment.baseAddress();\n-        initializer.accept(first);\n-        MemoryAddress second = MemorySegment.ofByteBuffer(segment.asByteBuffer()).baseAddress();\n+        initializer.accept(segment);\n+        MemorySegment second = MemorySegment.ofByteBuffer(segment.asByteBuffer());\n@@ -442,1 +425,1 @@\n-    public void testResizeRoundtripNative(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {\n+    public void testResizeRoundtripNative(Consumer<MemorySegment> checker, Consumer<MemorySegment> initializer, SequenceLayout seq) {\n@@ -444,3 +427,2 @@\n-            MemoryAddress first = segment.baseAddress();\n-            initializer.accept(first);\n-            MemoryAddress second = MemorySegment.ofByteBuffer(segment.asByteBuffer()).baseAddress();\n+            initializer.accept(segment);\n+            MemorySegment second = MemorySegment.ofByteBuffer(segment.asByteBuffer());\n@@ -494,1 +476,1 @@\n-    public void testCopyHeapToNative(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {\n+    public void testCopyHeapToNative(Consumer<MemorySegment> checker, Consumer<MemorySegment> initializer, SequenceLayout seq) {\n@@ -499,1 +481,1 @@\n-            initializer.accept(heapArray.baseAddress());\n+            initializer.accept(heapArray);\n@@ -501,1 +483,1 @@\n-            checker.accept(nativeArray.baseAddress());\n+            checker.accept(nativeArray);\n@@ -506,1 +488,1 @@\n-    public void testCopyNativeToHeap(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {\n+    public void testCopyNativeToHeap(Consumer<MemorySegment> checker, Consumer<MemorySegment> initializer, SequenceLayout seq) {\n@@ -511,1 +493,1 @@\n-            initializer.accept(nativeArray.baseAddress());\n+            initializer.accept(nativeArray);\n@@ -513,1 +495,1 @@\n-            checker.accept(heapArray.baseAddress());\n+            checker.accept(heapArray);\n@@ -565,1 +547,1 @@\n-        intHandle.set(s2.baseAddress(), 0L, 10); \/\/ Dead access!\n+        MemoryAccess.setInt(s2, 10); \/\/ Dead access!\n@@ -625,29 +607,29 @@\n-        Consumer<MemoryAddress> byteInitializer =\n-                (base) -> initBytes(base, bytes, (addr, pos) -> byteHandle.set(addr, pos, (byte)(long)pos));\n-        Consumer<MemoryAddress> charInitializer =\n-                (base) -> initBytes(base, chars, (addr, pos) -> charHandle.set(addr, pos, (char)(long)pos));\n-        Consumer<MemoryAddress> shortInitializer =\n-                (base) -> initBytes(base, shorts, (addr, pos) -> shortHandle.set(addr, pos, (short)(long)pos));\n-        Consumer<MemoryAddress> intInitializer =\n-                (base) -> initBytes(base, ints, (addr, pos) -> intHandle.set(addr, pos, (int)(long)pos));\n-        Consumer<MemoryAddress> floatInitializer =\n-                (base) -> initBytes(base, floats, (addr, pos) -> floatHandle.set(addr, pos, (float)(long)pos));\n-        Consumer<MemoryAddress> longInitializer =\n-                (base) -> initBytes(base, longs, (addr, pos) -> longHandle.set(addr, pos, (long)pos));\n-        Consumer<MemoryAddress> doubleInitializer =\n-                (base) -> initBytes(base, doubles, (addr, pos) -> doubleHandle.set(addr, pos, (double)(long)pos));\n-\n-        Consumer<MemoryAddress> byteChecker =\n-                (base) -> checkBytes(base, bytes, Function.identity(), byteHandle::get, ByteBuffer::get);\n-        Consumer<MemoryAddress> charChecker =\n-                (base) -> checkBytes(base, chars, ByteBuffer::asCharBuffer, charHandle::get, CharBuffer::get);\n-        Consumer<MemoryAddress> shortChecker =\n-                (base) -> checkBytes(base, shorts, ByteBuffer::asShortBuffer, shortHandle::get, ShortBuffer::get);\n-        Consumer<MemoryAddress> intChecker =\n-                (base) -> checkBytes(base, ints, ByteBuffer::asIntBuffer, intHandle::get, IntBuffer::get);\n-        Consumer<MemoryAddress> floatChecker =\n-                (base) -> checkBytes(base, floats, ByteBuffer::asFloatBuffer, floatHandle::get, FloatBuffer::get);\n-        Consumer<MemoryAddress> longChecker =\n-                (base) -> checkBytes(base, longs, ByteBuffer::asLongBuffer, longHandle::get, LongBuffer::get);\n-        Consumer<MemoryAddress> doubleChecker =\n-                (base) -> checkBytes(base, doubles, ByteBuffer::asDoubleBuffer, doubleHandle::get, DoubleBuffer::get);\n+        Consumer<MemorySegment> byteInitializer =\n+                (base) -> initBytes(base, bytes, (addr, pos) -> MemoryAccess.setByteAtIndex_BE(addr, pos, (byte)(long)pos));\n+        Consumer<MemorySegment> charInitializer =\n+                (base) -> initBytes(base, chars, (addr, pos) -> MemoryAccess.setCharAtIndex_BE(addr, pos, (char)(long)pos));\n+        Consumer<MemorySegment> shortInitializer =\n+                (base) -> initBytes(base, shorts, (addr, pos) -> MemoryAccess.setShortAtIndex_BE(addr, pos, (short)(long)pos));\n+        Consumer<MemorySegment> intInitializer =\n+                (base) -> initBytes(base, ints, (addr, pos) -> MemoryAccess.setIntAtIndex_BE(addr, pos, (int)(long)pos));\n+        Consumer<MemorySegment> floatInitializer =\n+                (base) -> initBytes(base, floats, (addr, pos) -> MemoryAccess.setFloatAtIndex_BE(addr, pos, (float)(long)pos));\n+        Consumer<MemorySegment> longInitializer =\n+                (base) -> initBytes(base, longs, (addr, pos) -> MemoryAccess.setLongAtIndex_BE(addr, pos, (long)pos));\n+        Consumer<MemorySegment> doubleInitializer =\n+                (base) -> initBytes(base, doubles, (addr, pos) -> MemoryAccess.setDoubleAtIndex_BE(addr, pos, (double)(long)pos));\n+\n+        Consumer<MemorySegment> byteChecker =\n+                (base) -> checkBytes(base, bytes, Function.identity(), MemoryAccess::getByteAtIndex_BE, ByteBuffer::get);\n+        Consumer<MemorySegment> charChecker =\n+                (base) -> checkBytes(base, chars, ByteBuffer::asCharBuffer, MemoryAccess::getCharAtIndex_BE, CharBuffer::get);\n+        Consumer<MemorySegment> shortChecker =\n+                (base) -> checkBytes(base, shorts, ByteBuffer::asShortBuffer, MemoryAccess::getShortAtIndex_BE, ShortBuffer::get);\n+        Consumer<MemorySegment> intChecker =\n+                (base) -> checkBytes(base, ints, ByteBuffer::asIntBuffer, MemoryAccess::getIntAtIndex_BE, IntBuffer::get);\n+        Consumer<MemorySegment> floatChecker =\n+                (base) -> checkBytes(base, floats, ByteBuffer::asFloatBuffer, MemoryAccess::getFloatAtIndex_BE, FloatBuffer::get);\n+        Consumer<MemorySegment> longChecker =\n+                (base) -> checkBytes(base, longs, ByteBuffer::asLongBuffer, MemoryAccess::getLongAtIndex_BE, LongBuffer::get);\n+        Consumer<MemorySegment> doubleChecker =\n+                (base) -> checkBytes(base, doubles, ByteBuffer::asDoubleBuffer, MemoryAccess::getDoubleAtIndex_BE, DoubleBuffer::get);\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":76,"deletions":94,"binary":false,"changes":170,"status":"modified"}]}