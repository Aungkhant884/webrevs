{"files":[{"patch":"@@ -55,0 +55,1 @@\n+import jdk.internal.javac.PreviewFeature;\n@@ -59,0 +60,1 @@\n+import jdk.internal.module.ModuleBootstrap;\n@@ -259,1 +261,1 @@\n-    Module implAddEnableNativeAccess() {\n+    synchronized Module implAddEnableNativeAccess() {\n@@ -265,1 +267,4 @@\n-     * Update all unnamed modules to allow access to restricted methods.\n+     * Returns {@code true} if this module can access\n+     * <a href=\"foreign\/package-summary.html#restricted\"><em>restricted<\/em><\/a> methods.\n+     *\n+     * @return {@code true} if this module can access <em>restricted<\/em> methods.\n@@ -267,2 +272,6 @@\n-    static void implAddEnableNativeAccessAllUnnamed() {\n-        ALL_UNNAMED_MODULE.enableNativeAccess = true;\n+    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n+    public boolean isNativeAccessEnabled() {\n+        Module target = enableNativeAccessHolder();\n+        synchronized(target) {\n+            return target.enableNativeAccess;\n+        }\n@@ -271,0 +280,41 @@\n+    \/\/ Returns the Module object holds the enableNativeAccess\n+    \/\/ flag for this module.\n+    private Module enableNativeAccessHolder() {\n+        return isNamed()? this : ALL_UNNAMED_MODULE;\n+    }\n+\n+    \/\/ This is invoked from Reflection.ensureNativeAccess\n+    void ensureNativeAccess(Class<?> owner, String methodName) {\n+        \/\/ The target module whose enableNativeAccess flag is ensured\n+        Module target = enableNativeAccessHolder();\n+        \/\/ racy read of the enable native access flag\n+        boolean isNativeAccessEnabled = target.enableNativeAccess;\n+        if (!isNativeAccessEnabled) {\n+            synchronized(target) {\n+                \/\/ safe read of the enableNativeAccess of the target module\n+                isNativeAccessEnabled = target.enableNativeAccess;\n+                \/\/ check again with the safely read flag\n+                if (isNativeAccessEnabled) {\n+                   return;\n+                } else if (ModuleBootstrap.hasEnableNativeAccessFlag()) {\n+                   throw new IllegalCallerException(\"Illegal native access from: \" + this);\n+                } else {\n+                    \/\/ warn and set flag, so that only one warning is reported per module\n+                    String cls = owner.getName();\n+                    String mtd = cls + \"::\" + methodName;\n+                    String mod = isNamed() ? \"module \" + getName() : \"the unnamed module\";\n+                    String modflag = isNamed() ? getName() : \"ALL-UNNAMED\";\n+                    System.err.printf(\"\"\"\n+                        WARNING: A restricted method in %s has been called\n+                        WARNING: %s has been called by %s\n+                        WARNING: Use --enable-native-access=%s to avoid a warning for this module\n+                        %n\"\"\", cls, mtd, mod, modflag);\n+\n+                    \/\/ set the flag\n+                    target.enableNativeAccess = true;\n+                }\n+            }\n+        }\n+    }\n+\n+\n@@ -272,1 +322,1 @@\n-     * Returns true if module m can access restricted methods.\n+     * Update all unnamed modules to allow access to restricted methods.\n@@ -274,4 +324,4 @@\n-    boolean implIsEnableNativeAccess() {\n-        return isNamed() ?\n-                enableNativeAccess :\n-                ALL_UNNAMED_MODULE.enableNativeAccess;\n+    static void implAddEnableNativeAccessAllUnnamed() {\n+        synchronized (ALL_UNNAMED_MODULE) {\n+            ALL_UNNAMED_MODULE.enableNativeAccess = true;\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Module.java","additions":59,"deletions":9,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import jdk.internal.javac.PreviewFeature;\n@@ -52,0 +53,2 @@\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n@@ -55,1 +58,0 @@\n-\n@@ -300,0 +302,26 @@\n+\n+        \/***\n+         * Enables <a href=\"foreign\/package-summary.html#restricted\">native access<\/a>\n+         * for a module in the layer if the caller module already has native access.\n+         *\n+         * <p> This method is <a href=\"foreign\/package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+         * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+         * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain\n+         * from depending on restricted methods, and use safe and supported functionalities,\n+         * where possible.\n+         *\n+         * @param target the module that's given native access\n+         *\n+         * @return This controller\n+         *\n+         * @throws IllegalCallerException If the caller module doesn't have native access.\n+         *\/\n+         @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n+         @CallerSensitive\n+         public Controller enableNativeAccess(Module target) {\n+             ensureInLayer(target);\n+             Reflection.ensureNativeAccess(Reflection.getCallerClass(), Module.class,\n+                 \"enableNativeAccess\");\n+             target.implAddEnableNativeAccess();\n+             return this;\n+         }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ModuleLayer.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2437,2 +2437,2 @@\n-            public boolean isEnableNativeAccess(Module m) {\n-                return m.implIsEnableNativeAccess();\n+            public void ensureNativeAccess(Module m, Class<?> owner, String methodName) {\n+                m.ensureNativeAccess(owner, methodName);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -276,1 +276,2 @@\n-     * Returns true if module m can access restricted methods.\n+     * Ensure that the given module has native access. If not, warn\n+     * and set native access depending on the configuration.\n@@ -278,1 +279,1 @@\n-    boolean isEnableNativeAccess(Module m);\n+    void ensureNativeAccess(Module m, Class<?> owner, String methodName);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -118,27 +118,1 @@\n-        boolean isNativeAccessEnabled = SharedSecrets.getJavaLangAccess().isEnableNativeAccess(module);\n-        if (!isNativeAccessEnabled) {\n-            synchronized(module) {\n-                isNativeAccessEnabled = SharedSecrets.getJavaLangAccess().isEnableNativeAccess(module);\n-                if (isNativeAccessEnabled) {\n-                    \/\/ some other thread got to it, do nothing\n-                } else if (ModuleBootstrap.hasEnableNativeAccessFlag()) {\n-                    throw new IllegalCallerException(\"Illegal native access from: \" + module);\n-                } else {\n-                    \/\/ warn and set flag, so that only one warning is reported per module\n-                    String cls = owner.getName();\n-                    String mtd = cls + \"::\" + methodName;\n-                    String mod = module.isNamed() ? \"module \" + module.getName() : \"the unnamed module\";\n-                    String modflag = module.isNamed() ? module.getName() : \"ALL-UNNAMED\";\n-                    System.err.printf(\"\"\"\n-                            WARNING: A restricted method in %s has been called\n-                            WARNING: %s has been called by %s\n-                            WARNING: Use --enable-native-access=%s to avoid a warning for this module\n-                            %n\"\"\", cls, mtd, mod, modflag);\n-                    if (module.isNamed()) {\n-                        SharedSecrets.getJavaLangAccess().addEnableNativeAccess(module);\n-                    } else {\n-                        SharedSecrets.getJavaLangAccess().addEnableNativeAccessAllUnnamed();\n-                    }\n-                }\n-            }\n-        }\n+        SharedSecrets.getJavaLangAccess().ensureNativeAccess(module, owner, methodName);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/Reflection.java","additions":1,"deletions":27,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.lang.Module;\n+import java.lang.ModuleLayer;\n+import java.lang.module.ModuleFinder;\n+import java.lang.module.ModuleReference;\n+import java.io.File;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Stream;\n+import java.util.stream.Collectors;\n+\n+\/\/ This class creates a dynamic module layer and loads the\n+\/\/ panama_module in it. enableNativeAccess on that dynamic\n+\/\/ module is called depending on the command line option.\n+\/\/\n+\/\/ Usage:\n+\/\/   java --enable-native-access=ALL-UNNAMED NativeAccessDynamicMain <module-path> <mod\/class> <true|false> [main-args]\n+public class NativeAccessDynamicMain {\n+    public static void main(String[] args) throws Exception {\n+        String modulePath = args[0];\n+        String moduleAndClsName = args[1];\n+        boolean enableNativeAccess = Boolean.parseBoolean(args[2]);\n+        String[] mainArgs = args.length > 2? Arrays.copyOfRange(args, 3, args.length) : new String[0];\n+\n+        int idx = moduleAndClsName.indexOf('\/');\n+        String moduleName = moduleAndClsName.substring(0, idx);\n+        String className = moduleAndClsName.substring(idx+1);\n+\n+        Path[] paths = Stream.of(modulePath.split(File.pathSeparator))\n+            .map(Paths::get)\n+            .toArray(Path[]::new);\n+        ModuleFinder mf = ModuleFinder.of(paths);\n+        var mrefs = mf.findAll();\n+        if (mrefs.isEmpty()) {\n+            throw new RuntimeException(\"No modules module path: \" + modulePath);\n+        }\n+\n+        var rootMods = mrefs.stream().\n+            map(mr->mr.descriptor().name()).\n+            collect(Collectors.toSet());\n+\n+        ModuleLayer boot = ModuleLayer.boot();\n+        var conf = boot.configuration().\n+            resolve(mf, ModuleFinder.of(), rootMods);\n+        String firstMod = rootMods.iterator().next();\n+        URLClassLoader cl = new URLClassLoader(new URL[] { paths[0].toFile().toURL() });\n+        ModuleLayer.Controller controller = boot.defineModulesWithOneLoader(conf, List.of(boot), cl);\n+        ModuleLayer layer = controller.layer();\n+        Module mod = layer.findModule(firstMod).get();\n+\n+        \/\/ conditionally grant native access to the dynamic module created\n+        if (enableNativeAccess) {\n+            controller.enableNativeAccess(mod);\n+        }\n+        Class mainCls = Class.forName(mod, className);\n+        var main = mainCls.getMethod(\"main\", String[].class);\n+        main.invoke(null, (Object)mainArgs);\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/NativeAccessDynamicMain.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires !vm.musl\n+ *\n+ * @library \/test\/lib\n+ * @build TestEnableNativeAccessDynamic\n+ *        panama_module\/*\n+          NativeAccessDynamicMain\n+ * @run testng\/othervm\/timeout=180 TestEnableNativeAccessDynamic\n+ * @summary Test for dynamically setting --enable-native-access flag for a module\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+@Test\n+public class TestEnableNativeAccessDynamic {\n+\n+    static final String MODULE_PATH = System.getProperty(\"jdk.module.path\");\n+\n+    static final String PANAMA_MAIN = \"panama_module\/org.openjdk.foreigntest.PanamaMainDirect\";\n+    static final String PANAMA_REFLECTION = \"panama_module\/org.openjdk.foreigntest.PanamaMainReflection\";\n+    static final String PANAMA_INVOKE = \"panama_module\/org.openjdk.foreigntest.PanamaMainInvoke\";\n+    static final String PANAMA_JNI = \"panama_module\/org.openjdk.foreigntest.PanamaMainJNI\";\n+\n+    \/**\n+     * Represents the expected result of a test.\n+     *\/\n+    static final class Result {\n+        private final boolean success;\n+        private final List<String> expectedOutput = new ArrayList<>();\n+        private final List<String> notExpectedOutput = new ArrayList<>();\n+\n+        Result(boolean success) {\n+            this.success = success;\n+        }\n+\n+        Result expect(String msg) {\n+            expectedOutput.add(msg);\n+            return this;\n+        }\n+\n+        Result doNotExpect(String msg) {\n+            notExpectedOutput.add(msg);\n+            return this;\n+        }\n+\n+        boolean shouldSucceed() {\n+            return success;\n+        }\n+\n+        Stream<String> expectedOutput() {\n+            return expectedOutput.stream();\n+        }\n+\n+        Stream<String> notExpectedOutput() {\n+            return notExpectedOutput.stream();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String s = (success) ? \"success\" : \"failure\";\n+            for (String msg : expectedOutput) {\n+                s += \"\/\" + msg;\n+            }\n+            return s;\n+        }\n+    }\n+\n+    static Result success() {\n+        return new Result(true);\n+    }\n+\n+    static Result successNoWarning() {\n+        return success().doNotExpect(\"WARNING\");\n+    }\n+\n+    static Result failWithError(String expectedOutput) {\n+        return new Result(false).expect(expectedOutput);\n+    }\n+\n+    @DataProvider(name = \"succeedCases\")\n+    public Object[][] succeedCases() {\n+        return new Object[][] {\n+                { \"panama_enable_native_access\", PANAMA_MAIN, successNoWarning() },\n+                { \"panama_enable_native_access_reflection\", PANAMA_REFLECTION, successNoWarning() },\n+                { \"panama_enable_native_access_invoke\", PANAMA_INVOKE, successNoWarning() },\n+        };\n+    }\n+\n+    @DataProvider(name = \"failureCases\")\n+    public Object[][] failureCases() {\n+        String errMsg = \"Illegal native access from: module panama_module\";\n+        return new Object[][] {\n+                { \"panama_enable_native_access_fail\", PANAMA_MAIN, failWithError(errMsg) },\n+                { \"panama_enable_native_access_fail_reflection\", PANAMA_REFLECTION, failWithError(errMsg) },\n+                { \"panama_enable_native_access_fail_invoke\", PANAMA_INVOKE, failWithError(errMsg) },\n+        };\n+    }\n+\n+    \/**\n+     * Checks an expected result with the output captured by the given\n+     * OutputAnalyzer.\n+     *\/\n+    void checkResult(Result expectedResult, OutputAnalyzer outputAnalyzer) {\n+        expectedResult.expectedOutput().forEach(outputAnalyzer::shouldContain);\n+        expectedResult.notExpectedOutput().forEach(outputAnalyzer::shouldNotContain);\n+        int exitValue = outputAnalyzer.getExitValue();\n+        if (expectedResult.shouldSucceed()) {\n+            assertTrue(exitValue == 0);\n+        } else {\n+            assertTrue(exitValue != 0);\n+        }\n+    }\n+\n+    \/**\n+     * Runs the test to execute the given test action. The VM is run with the\n+     * given VM options and the output checked to see that it matches the\n+     * expected result.\n+     *\/\n+    OutputAnalyzer run(String action, String moduleAndCls, boolean enableNativeAccess,\n+            Result expectedResult, boolean panamaModuleInBootLayer) throws Exception\n+    {\n+        List<String> list = new ArrayList<>();\n+        list.add(\"--enable-preview\");\n+        if (panamaModuleInBootLayer) {\n+            list.addAll(List.of(\"-p\", MODULE_PATH));\n+            list.add(\"--add-modules=panama_module\");\n+            list.add(\"--enable-native-access=panama_module\");\n+        } else {\n+            list.add(\"--enable-native-access=ALL-UNNAMED\");\n+        }\n+        list.addAll(List.of(\"NativeAccessDynamicMain\", MODULE_PATH,\n+                moduleAndCls, Boolean.toString(enableNativeAccess), action));\n+        String[] opts = list.toArray(String[]::new);\n+        OutputAnalyzer outputAnalyzer = ProcessTools\n+                .executeTestJava(opts)\n+                .outputTo(System.out)\n+                .errorTo(System.out);\n+        checkResult(expectedResult, outputAnalyzer);\n+        return outputAnalyzer;\n+    }\n+\n+    @Test(dataProvider = \"succeedCases\")\n+    public void testSucceed(String action, String moduleAndCls,\n+            Result expectedResult) throws Exception {\n+        run(action, moduleAndCls, true, expectedResult, false);\n+    }\n+\n+    @Test(dataProvider = \"failureCases\")\n+    public void testFailures(String action, String moduleAndCls,\n+            Result expectedResult) throws Exception {\n+        run(action, moduleAndCls, false, expectedResult, false);\n+    }\n+\n+    \/\/ make sure that having a same named module in boot layer with native access\n+    \/\/ does not influence same named dynamic module.\n+    @Test(dataProvider = \"failureCases\")\n+    public void testFailuresWithPanamaModuleInBootLayer(String action, String moduleAndCls,\n+            Result expectedResult) throws Exception {\n+        run(action, moduleAndCls, false, expectedResult, true);\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/TestEnableNativeAccessDynamic.java","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+public class LoopOverOfAddress extends JavaLayouts {\n+\n+    static final int ITERATIONS = 1_000_000;\n+\n+    @Benchmark\n+    public int segment_loop_addr() {\n+        int res = 0;\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            res += MemorySegment.ofAddress(i % 100).address();\n+        }\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public int segment_loop_addr_size() {\n+        int res = 0;\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            res += MemorySegment.ofAddress(i, i % 100).address();\n+        }\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public int segment_loop_addr_size_session() {\n+        int res = 0;\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            res += MemorySegment.ofAddress(i, i % 100, MemorySession.global()).address();\n+        }\n+        return res;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverOfAddress.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"}]}