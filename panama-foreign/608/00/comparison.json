{"files":[{"patch":"@@ -75,44 +75,0 @@\n-const BufferLayout ForeignGlobals::parse_buffer_layout_impl(jobject jlayout) const {\n-  oop layout_oop = JNIHandles::resolve_non_null(jlayout);\n-  BufferLayout layout;\n-\n-  layout.stack_args_bytes = layout_oop->long_field(BL.stack_args_bytes_offset);\n-  layout.stack_args = layout_oop->long_field(BL.stack_args_offset);\n-  layout.arguments_next_pc = layout_oop->long_field(BL.arguments_next_pc_offset);\n-\n-  typeArrayOop input_offsets = oop_cast<typeArrayOop>(layout_oop->obj_field(BL.input_type_offsets_offset));\n-  layout.arguments_integer = (size_t) input_offsets->long_at(INTEGER_TYPE);\n-  layout.arguments_vector = (size_t) input_offsets->long_at(VECTOR_TYPE);\n-\n-  typeArrayOop output_offsets = oop_cast<typeArrayOop>(layout_oop->obj_field(BL.output_type_offsets_offset));\n-  layout.returns_integer = (size_t) output_offsets->long_at(INTEGER_TYPE);\n-  layout.returns_vector = (size_t) output_offsets->long_at(VECTOR_TYPE);\n-\n-  layout.buffer_size = layout_oop->long_field(BL.size_offset);\n-\n-  return layout;\n-}\n-\n-const CallRegs ForeignGlobals::parse_call_regs_impl(jobject jconv) const {\n-  oop conv_oop = JNIHandles::resolve_non_null(jconv);\n-  objArrayOop arg_regs_oop = oop_cast<objArrayOop>(conv_oop->obj_field(CallConvOffsets.arg_regs_offset));\n-  objArrayOop ret_regs_oop = oop_cast<objArrayOop>(conv_oop->obj_field(CallConvOffsets.ret_regs_offset));\n-\n-  CallRegs result;\n-  result._args_length = arg_regs_oop->length();\n-  result._arg_regs = NEW_RESOURCE_ARRAY(VMReg, result._args_length);\n-\n-  result._rets_length = ret_regs_oop->length();\n-  result._ret_regs = NEW_RESOURCE_ARRAY(VMReg, result._rets_length);\n-\n-  for (int i = 0; i < result._args_length; i++) {\n-    result._arg_regs[i] = parse_vmstorage(arg_regs_oop->obj_at(i));\n-  }\n-\n-  for (int i = 0; i < result._rets_length; i++) {\n-    result._ret_regs[i] = parse_vmstorage(ret_regs_oop->obj_at(i));\n-  }\n-\n-  return result;\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/foreign_globals_aarch64.cpp","additions":0,"deletions":44,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -52,11 +52,0 @@\n-struct BufferLayout {\n-  size_t stack_args_bytes;\n-  size_t stack_args;\n-  size_t arguments_vector;\n-  size_t arguments_integer;\n-  size_t arguments_next_pc;\n-  size_t returns_vector;\n-  size_t returns_integer;\n-  size_t buffer_size;\n-};\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/foreign_globals_aarch64.hpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -40,71 +40,0 @@\n-\/\/ 1. Create buffer according to layout\n-\/\/ 2. Load registers & stack args into buffer\n-\/\/ 3. Call upcall helper with upcall handler instance & buffer pointer (C++ ABI)\n-\/\/ 4. Load return value from buffer into foreign ABI registers\n-\/\/ 5. Return\n-address ProgrammableUpcallHandler::generate_upcall_stub(jobject rec, jobject jabi, jobject jlayout) {\n-  ResourceMark rm;\n-  const ABIDescriptor abi = ForeignGlobals::parse_abi_descriptor(jabi);\n-  const BufferLayout layout = ForeignGlobals::parse_buffer_layout(jlayout);\n-\n-  CodeBuffer buffer(\"upcall_stub\", 1024, upcall_stub_size);\n-\n-  MacroAssembler* _masm = new MacroAssembler(&buffer);\n-\n-  \/\/ stub code\n-  __ enter();\n-\n-  \/\/ save pointer to JNI receiver handle into constant segment\n-  Address rec_adr = InternalAddress(__ address_constant((address)rec));\n-\n-  assert(abi._stack_alignment_bytes % 16 == 0, \"stack must be 16 byte aligned\");\n-\n-  __ sub(sp, sp, (int) align_up(layout.buffer_size, abi._stack_alignment_bytes));\n-\n-  \/\/ TODO: This stub only uses registers which are caller-save in the\n-  \/\/       standard C ABI. If this is called from a different ABI then\n-  \/\/       we need to save registers here according to abi.is_volatile_reg.\n-\n-  for (int i = 0; i < abi._integer_argument_registers.length(); i++) {\n-    Register reg = abi._integer_argument_registers.at(i);\n-    ssize_t offset = layout.arguments_integer + i * sizeof(uintptr_t);\n-    __ str(reg, Address(sp, offset));\n-  }\n-\n-  for (int i = 0; i < abi._vector_argument_registers.length(); i++) {\n-    FloatRegister reg = abi._vector_argument_registers.at(i);\n-    ssize_t offset = layout.arguments_vector + i * float_reg_size;\n-    __ strq(reg, Address(sp, offset));\n-  }\n-\n-  \/\/ Capture prev stack pointer (stack arguments base)\n-  __ add(rscratch1, rfp, 16);   \/\/ Skip saved FP and LR\n-  __ str(rscratch1, Address(sp, layout.stack_args));\n-\n-  \/\/ Call upcall helper\n-  __ ldr(c_rarg0, rec_adr);\n-  __ mov(c_rarg1, sp);\n-  __ movptr(rscratch1, CAST_FROM_FN_PTR(uint64_t, ProgrammableUpcallHandler::attach_thread_and_do_upcall));\n-  __ blr(rscratch1);\n-\n-  for (int i = 0; i < abi._integer_return_registers.length(); i++) {\n-    ssize_t offs = layout.returns_integer + i * sizeof(uintptr_t);\n-    __ ldr(abi._integer_return_registers.at(i), Address(sp, offs));\n-  }\n-\n-  for (int i = 0; i < abi._vector_return_registers.length(); i++) {\n-    FloatRegister reg = abi._vector_return_registers.at(i);\n-    ssize_t offs = layout.returns_vector + i * float_reg_size;\n-    __ ldrq(reg, Address(sp, offs));\n-  }\n-\n-  __ leave();\n-  __ ret(lr);\n-\n-  __ flush();\n-\n-  BufferBlob* blob = BufferBlob::create(\"upcall_stub\", &buffer);\n-\n-  return blob->code_begin();\n-}\n-\n@@ -189,1 +118,6 @@\n-address ProgrammableUpcallHandler::generate_optimized_upcall_stub(jobject receiver, Method* entry, jobject jabi, jobject jconv) {\n+address ProgrammableUpcallHandler::generate_optimized_upcall_stub(jobject receiver, Method* entry,\n+                                                                  BasicType* in_sig_bt, int total_in_args,\n+                                                                  BasicType* out_sig_bt, int total_out_args,\n+                                                                  BasicType ret_type,\n+                                                                  jobject jabi, jobject jconv,\n+                                                                  bool needs_return_buffer, int ret_buf_size) {\n@@ -193,1 +127,0 @@\n-  assert(call_regs._rets_length <= 1, \"no multi reg returns\");\n@@ -196,22 +129,0 @@\n-  assert(entry->is_static(), \"static only\");\n-  \/\/ Fill in the signature array, for the calling-convention call.\n-  const int total_out_args = entry->size_of_parameters();\n-  assert(total_out_args > 0, \"receiver arg\");\n-\n-  BasicType* out_sig_bt = NEW_RESOURCE_ARRAY(BasicType, total_out_args);\n-  BasicType ret_type;\n-  {\n-    int i = 0;\n-    SignatureStream ss(entry->signature());\n-    for (; !ss.at_return_type(); ss.next()) {\n-      out_sig_bt[i++] = ss.type();  \/\/ Collect remaining bits of signature\n-      if (ss.type() == T_LONG || ss.type() == T_DOUBLE)\n-        out_sig_bt[i++] = T_VOID;   \/\/ Longs & doubles take 2 Java slots\n-    }\n-    assert(i == total_out_args, \"\");\n-    ret_type = ss.type();\n-  }\n-  \/\/ skip receiver\n-  BasicType* in_sig_bt = out_sig_bt + 1;\n-  int total_in_args = total_out_args - 1;\n-\n@@ -254,0 +165,6 @@\n+  int ret_buf_offset = -1;\n+  if (needs_return_buffer) {\n+    ret_buf_offset = frame_bottom_offset;\n+    frame_bottom_offset += ret_buf_size;\n+  }\n+\n@@ -262,0 +179,3 @@\n+  \/\/      | (optional)          |\n+  \/\/      | ret_buf             |\n+  \/\/      |---------------------| = ret_buf_offset\n@@ -306,0 +226,4 @@\n+  if (needs_return_buffer) {\n+    assert(ret_buf_offset != -1, \"no return buffer allocated\");\n+    __ lea(abi._ret_buf_addr_reg, Address(sp, ret_buf_offset));\n+  }\n@@ -321,0 +245,45 @@\n+    \/\/ return value shuffle\n+  if (!needs_return_buffer) {\n+#ifdef ASSERT\n+    if (call_regs._rets_length == 1) { \/\/ 0 or 1\n+      VMReg j_expected_result_reg;\n+      switch (ret_type) {\n+        case T_BOOLEAN:\n+        case T_BYTE:\n+        case T_SHORT:\n+        case T_CHAR:\n+        case T_INT:\n+        case T_LONG:\n+        j_expected_result_reg = r0->as_VMReg();\n+        break;\n+        case T_FLOAT:\n+        case T_DOUBLE:\n+          j_expected_result_reg = v0->as_VMReg();\n+          break;\n+        default:\n+          fatal(\"unexpected return type: %s\", type2name(ret_type));\n+      }\n+      \/\/ No need to move for now, since CallArranger can pick a return type\n+      \/\/ that goes in the same reg for both CCs. But, at least assert they are the same\n+      assert(call_regs._ret_regs[0] == j_expected_result_reg,\n+      \"unexpected result register: %s != %s\", call_regs._ret_regs[0]->name(), j_expected_result_reg->name());\n+    }\n+#endif\n+  } else {\n+    assert(ret_buf_offset != -1, \"no return buffer allocated\");\n+    __ lea(rscratch1, Address(sp, ret_buf_offset));\n+    int offset = 0;\n+    for (int i = 0; i < call_regs._rets_length; i++) {\n+      VMReg reg = call_regs._ret_regs[i];\n+      if (reg->is_Register()) {\n+        __ ldr(reg->as_Register(), Address(rscratch1, offset));\n+        offset += 8;\n+      } else if (reg->is_FloatRegister()) {\n+        __ ldrd(reg->as_FloatRegister(), Address(rscratch1, offset));\n+        offset += 16; \/\/ needs to match VECTOR_REG_SIZE in AArch64Architecture (Java)\n+      } else {\n+        ShouldNotReachHere();\n+      }\n+    }\n+  }\n+\n@@ -334,27 +303,0 @@\n-  \/\/ return value shuffle\n-#ifdef ASSERT\n-  if (call_regs._rets_length == 1) { \/\/ 0 or 1\n-    VMReg j_expected_result_reg;\n-    switch (ret_type) {\n-      case T_BOOLEAN:\n-      case T_BYTE:\n-      case T_SHORT:\n-      case T_CHAR:\n-      case T_INT:\n-      case T_LONG:\n-       j_expected_result_reg = r0->as_VMReg();\n-       break;\n-      case T_FLOAT:\n-      case T_DOUBLE:\n-        j_expected_result_reg = v0->as_VMReg();\n-        break;\n-      default:\n-        fatal(\"unexpected return type: %s\", type2name(ret_type));\n-    }\n-    \/\/ No need to move for now, since CallArranger can pick a return type\n-    \/\/ that goes in the same reg for both CCs. But, at least assert they are the same\n-    assert(call_regs._ret_regs[0] == j_expected_result_reg,\n-     \"unexpected result register: %s != %s\", call_regs._ret_regs[0]->name(), j_expected_result_reg->name());\n-  }\n-#endif\n-\n@@ -389,1 +331,6 @@\n-  OptimizedEntryBlob* blob = OptimizedEntryBlob::create(name, &buffer, exception_handler_offset, receiver, in_ByteSize(frame_data_offset));\n+  OptimizedEntryBlob* blob\n+    = OptimizedEntryBlob::create(name,\n+                                 &buffer,\n+                                 exception_handler_offset,\n+                                 receiver,\n+                                 in_ByteSize(frame_data_offset));\n@@ -397,4 +344,0 @@\n-\n-bool ProgrammableUpcallHandler::supports_optimized_upcalls() {\n-  return true;\n-}\n","filename":"src\/hotspot\/cpu\/aarch64\/universalUpcallHandler_aarch64.cpp","additions":70,"deletions":127,"binary":false,"changes":197,"status":"modified"},{"patch":"@@ -33,5 +33,0 @@\n-const BufferLayout ForeignGlobals::parse_buffer_layout_impl(jobject jlayout) const {\n-  Unimplemented();\n-  return {};\n-}\n-\n","filename":"src\/hotspot\/cpu\/arm\/foreign_globals_arm.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-class BufferLayout {};\n","filename":"src\/hotspot\/cpu\/arm\/foreign_globals_arm.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,6 +28,6 @@\n-address ProgrammableUpcallHandler::generate_upcall_stub(jobject rec, jobject jabi, jobject jlayout) {\n-  Unimplemented();\n-  return nullptr;\n-}\n-\n-address ProgrammableUpcallHandler::generate_optimized_upcall_stub(jobject mh, Method* entry, jobject jabi, jobject jconv) {\n+address ProgrammableUpcallHandler::generate_optimized_upcall_stub(jobject receiver, Method* entry,\n+                                                                  BasicType* in_sig_bt, int total_in_args,\n+                                                                  BasicType* out_sig_bt, int total_out_args,\n+                                                                  BasicType ret_type,\n+                                                                  jobject jabi, jobject jconv,\n+                                                                  bool needs_return_buffer, int ret_buf_size) {\n@@ -37,4 +37,0 @@\n-\n-bool ProgrammableUpcallHandler::supports_optimized_upcalls() {\n-  return false;\n-}\n","filename":"src\/hotspot\/cpu\/arm\/universalUpcallHandle_arm.cpp","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -35,5 +35,0 @@\n-const BufferLayout ForeignGlobals::parse_buffer_layout_impl(jobject jlayout) const {\n-  Unimplemented();\n-  return {};\n-}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/foreign_globals_ppc.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-class BufferLayout {};\n","filename":"src\/hotspot\/cpu\/ppc\/foreign_globals_ppc.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,6 +29,6 @@\n-address ProgrammableUpcallHandler::generate_upcall_stub(jobject rec, jobject jabi, jobject jlayout) {\n-  Unimplemented();\n-  return nullptr;\n-}\n-\n-address ProgrammableUpcallHandler::generate_optimized_upcall_stub(jobject mh, Method* entry, jobject jabi, jobject jconv) {\n+address ProgrammableUpcallHandler::generate_optimized_upcall_stub(jobject receiver, Method* entry,\n+                                                                  BasicType* in_sig_bt, int total_in_args,\n+                                                                  BasicType* out_sig_bt, int total_out_args,\n+                                                                  BasicType ret_type,\n+                                                                  jobject jabi, jobject jconv,\n+                                                                  bool needs_return_buffer, int ret_buf_size) {\n@@ -38,4 +38,0 @@\n-\n-bool ProgrammableUpcallHandler::supports_optimized_upcalls() {\n-  return false;\n-}\n","filename":"src\/hotspot\/cpu\/ppc\/universalUpcallHandle_ppc.cpp","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -33,5 +33,0 @@\n-const BufferLayout ForeignGlobals::parse_buffer_layout_impl(jobject jlayout) const {\n-  Unimplemented();\n-  return {};\n-}\n-\n","filename":"src\/hotspot\/cpu\/s390\/foreign_globals_s390.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-class BufferLayout {};\n","filename":"src\/hotspot\/cpu\/s390\/foreign_globals_s390.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,6 +28,6 @@\n-address ProgrammableUpcallHandler::generate_upcall_stub(jobject rec, jobject jabi, jobject jlayout) {\n-  Unimplemented();\n-  return nullptr;\n-}\n-\n-address ProgrammableUpcallHandler::generate_optimized_upcall_stub(jobject mh, Method* entry, jobject jabi, jobject jconv) {\n+address ProgrammableUpcallHandler::generate_optimized_upcall_stub(jobject receiver, Method* entry,\n+                                                                  BasicType* in_sig_bt, int total_in_args,\n+                                                                  BasicType* out_sig_bt, int total_out_args,\n+                                                                  BasicType ret_type,\n+                                                                  jobject jabi, jobject jconv,\n+                                                                  bool needs_return_buffer, int ret_buf_size) {\n@@ -37,4 +37,0 @@\n-\n-bool ProgrammableUpcallHandler::supports_optimized_upcalls() {\n-  return false;\n-}\n","filename":"src\/hotspot\/cpu\/s390\/universalUpcallHandle_s390.cpp","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"runtime\/jniHandles.hpp\"\n@@ -29,1 +28,0 @@\n-#include \"prims\/foreign_globals.hpp\"\n@@ -74,45 +72,0 @@\n-const BufferLayout ForeignGlobals::parse_buffer_layout_impl(jobject jlayout) const {\n-  oop layout_oop = JNIHandles::resolve_non_null(jlayout);\n-  BufferLayout layout;\n-\n-  layout.stack_args_bytes = layout_oop->long_field(BL.stack_args_bytes_offset);\n-  layout.stack_args = layout_oop->long_field(BL.stack_args_offset);\n-  layout.arguments_next_pc = layout_oop->long_field(BL.arguments_next_pc_offset);\n-\n-  typeArrayOop input_offsets = oop_cast<typeArrayOop>(layout_oop->obj_field(BL.input_type_offsets_offset));\n-  layout.arguments_integer = (size_t) input_offsets->long_at(INTEGER_TYPE);\n-  layout.arguments_vector = (size_t) input_offsets->long_at(VECTOR_TYPE);\n-\n-  typeArrayOop output_offsets = oop_cast<typeArrayOop>(layout_oop->obj_field(BL.output_type_offsets_offset));\n-  layout.returns_integer = (size_t) output_offsets->long_at(INTEGER_TYPE);\n-  layout.returns_vector = (size_t) output_offsets->long_at(VECTOR_TYPE);\n-  layout.returns_x87 = (size_t) output_offsets->long_at(X87_TYPE);\n-\n-  layout.buffer_size = layout_oop->long_field(BL.size_offset);\n-\n-  return layout;\n-}\n-\n-const CallRegs ForeignGlobals::parse_call_regs_impl(jobject jconv) const {\n-  oop conv_oop = JNIHandles::resolve_non_null(jconv);\n-  objArrayOop arg_regs_oop = oop_cast<objArrayOop>(conv_oop->obj_field(CallConvOffsets.arg_regs_offset));\n-  objArrayOop ret_regs_oop = oop_cast<objArrayOop>(conv_oop->obj_field(CallConvOffsets.ret_regs_offset));\n-\n-  CallRegs result;\n-  result._args_length = arg_regs_oop->length();\n-  result._arg_regs = NEW_RESOURCE_ARRAY(VMReg, result._args_length);\n-\n-  result._rets_length = ret_regs_oop->length();\n-  result._ret_regs = NEW_RESOURCE_ARRAY(VMReg, result._rets_length);\n-\n-  for (int i = 0; i < result._args_length; i++) {\n-    result._arg_regs[i] = parse_vmstorage(arg_regs_oop->obj_at(i));\n-  }\n-\n-  for (int i = 0; i < result._rets_length; i++) {\n-    result._ret_regs[i] = parse_vmstorage(ret_regs_oop->obj_at(i));\n-  }\n-\n-  return result;\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/foreign_globals_x86.cpp","additions":0,"deletions":47,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -54,12 +54,0 @@\n-struct BufferLayout {\n-  size_t stack_args_bytes;\n-  size_t stack_args;\n-  size_t arguments_vector;\n-  size_t arguments_integer;\n-  size_t arguments_next_pc;\n-  size_t returns_vector;\n-  size_t returns_integer;\n-  size_t returns_x87;\n-  size_t buffer_size;\n-};\n-\n","filename":"src\/hotspot\/cpu\/x86\/foreign_globals_x86.hpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,6 +27,6 @@\n-address ProgrammableUpcallHandler::generate_upcall_stub(jobject rec, jobject jabi, jobject jlayout) {\n-  Unimplemented();\n-  return nullptr;\n-}\n-\n-address ProgrammableUpcallHandler::generate_optimized_upcall_stub(jobject mh, Method* entry, jobject jabi, jobject jconv) {\n+address ProgrammableUpcallHandler::generate_optimized_upcall_stub(jobject receiver, Method* entry,\n+                                                                  BasicType* in_sig_bt, int total_in_args,\n+                                                                  BasicType* out_sig_bt, int total_out_args,\n+                                                                  BasicType ret_type,\n+                                                                  jobject jabi, jobject jconv,\n+                                                                  bool needs_return_buffer, int ret_buf_size) {\n@@ -36,4 +36,0 @@\n-\n-bool ProgrammableUpcallHandler::supports_optimized_upcalls() {\n-  return false;\n-}\n","filename":"src\/hotspot\/cpu\/x86\/universalUpcallHandler_x86_32.cpp","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -42,113 +42,0 @@\n-\/\/ 1. Create buffer according to layout\n-\/\/ 2. Load registers & stack args into buffer\n-\/\/ 3. Call upcall helper with upcall handler instance & buffer pointer (C++ ABI)\n-\/\/ 4. Load return value from buffer into foreign ABI registers\n-\/\/ 5. Return\n-address ProgrammableUpcallHandler::generate_upcall_stub(jobject rec, jobject jabi, jobject jlayout) {\n-  ResourceMark rm;\n-  const ABIDescriptor abi = ForeignGlobals::parse_abi_descriptor(jabi);\n-  const BufferLayout layout = ForeignGlobals::parse_buffer_layout(jlayout);\n-\n-  CodeBuffer buffer(\"upcall_stub\", 1024, upcall_stub_size);\n-\n-  MacroAssembler* _masm = new MacroAssembler(&buffer);\n-  int stack_alignment_C = 16; \/\/ bytes\n-  int register_size = sizeof(uintptr_t);\n-  int buffer_alignment = xmm_reg_size;\n-\n-  \/\/ stub code\n-  __ enter();\n-\n-  \/\/ save pointer to JNI receiver handle into constant segment\n-  Address rec_adr = __ as_Address(InternalAddress(__ address_constant((address)rec)));\n-\n-  __ subptr(rsp, (int) align_up(layout.buffer_size, buffer_alignment));\n-\n-  Register used[] = { c_rarg0, c_rarg1, rax, rbx, rdi, rsi, r12, r13, r14, r15 };\n-  GrowableArray<Register> preserved;\n-  \/\/ TODO need to preserve anything killed by the upcall that is non-volatile, needs XMM regs as well, probably\n-  for (size_t i = 0; i < sizeof(used)\/sizeof(Register); i++) {\n-    Register reg = used[i];\n-    if (!abi.is_volatile_reg(reg)) {\n-      preserved.push(reg);\n-    }\n-  }\n-\n-  int preserved_size = align_up(preserved.length() * register_size, stack_alignment_C); \/\/ includes register alignment\n-  int buffer_offset = preserved_size; \/\/ offset from rsp\n-\n-  __ subptr(rsp, preserved_size);\n-  for (int i = 0; i < preserved.length(); i++) {\n-    __ movptr(Address(rsp, i * register_size), preserved.at(i));\n-  }\n-\n-  for (int i = 0; i < abi._integer_argument_registers.length(); i++) {\n-    size_t offs = buffer_offset + layout.arguments_integer + i * sizeof(uintptr_t);\n-    __ movptr(Address(rsp, (int)offs), abi._integer_argument_registers.at(i));\n-  }\n-\n-  for (int i = 0; i < abi._vector_argument_registers.length(); i++) {\n-    XMMRegister reg = abi._vector_argument_registers.at(i);\n-    size_t offs = buffer_offset + layout.arguments_vector + i * xmm_reg_size;\n-    __ movdqu(Address(rsp, (int)offs), reg);\n-  }\n-\n-  \/\/ Capture prev stack pointer (stack arguments base)\n-#ifndef _WIN64\n-  __ lea(rax, Address(rbp, 16)); \/\/ skip frame+return address\n-#else\n-  __ lea(rax, Address(rbp, 16 + 32)); \/\/ also skip shadow space\n-#endif\n-  __ movptr(Address(rsp, buffer_offset + (int) layout.stack_args), rax);\n-#ifndef PRODUCT\n-  __ movptr(Address(rsp, buffer_offset + (int) layout.stack_args_bytes), -1); \/\/ unknown\n-#endif\n-\n-  \/\/ Call upcall helper\n-\n-  __ movptr(c_rarg0, rec_adr);\n-  __ lea(c_rarg1, Address(rsp, buffer_offset));\n-\n-#ifdef _WIN64\n-  __ block_comment(\"allocate shadow space for argument register spill\");\n-  __ subptr(rsp, 32);\n-#endif\n-\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ProgrammableUpcallHandler::attach_thread_and_do_upcall)));\n-\n-#ifdef _WIN64\n-  __ block_comment(\"pop shadow space\");\n-  __ addptr(rsp, 32);\n-#endif\n-\n-  for (int i = 0; i < abi._integer_return_registers.length(); i++) {\n-    size_t offs = buffer_offset + layout.returns_integer + i * sizeof(uintptr_t);\n-    __ movptr(abi._integer_return_registers.at(i), Address(rsp, (int)offs));\n-  }\n-\n-  for (int i = 0; i < abi._vector_return_registers.length(); i++) {\n-    XMMRegister reg = abi._vector_return_registers.at(i);\n-    size_t offs = buffer_offset + layout.returns_vector + i * xmm_reg_size;\n-    __ movdqu(reg, Address(rsp, (int)offs));\n-  }\n-\n-  for (size_t i = abi._X87_return_registers_noof; i > 0 ; i--) {\n-      ssize_t offs = buffer_offset + layout.returns_x87 + (i - 1) * (sizeof(long double));\n-      __ fld_x (Address(rsp, (int)offs));\n-  }\n-\n-  \/\/ Restore preserved registers\n-  for (int i = 0; i < preserved.length(); i++) {\n-    __ movptr(preserved.at(i), Address(rsp, i * register_size));\n-  }\n-\n-  __ leave();\n-  __ ret(0);\n-\n-  _masm->flush();\n-\n-  BufferBlob* blob = BufferBlob::create(\"upcall_stub\", &buffer);\n-\n-  return blob->code_begin();\n-}\n-\n@@ -284,2 +171,6 @@\n-address ProgrammableUpcallHandler::generate_optimized_upcall_stub(jobject receiver, Method* entry, jobject jabi, jobject jconv) {\n-  ResourceMark rm;\n+address ProgrammableUpcallHandler::generate_optimized_upcall_stub(jobject receiver, Method* entry,\n+                                                                  BasicType* in_sig_bt, int total_in_args,\n+                                                                  BasicType* out_sig_bt, int total_out_args,\n+                                                                  BasicType ret_type,\n+                                                                  jobject jabi, jobject jconv,\n+                                                                  bool needs_return_buffer, int ret_buf_size) {\n@@ -288,1 +179,0 @@\n-  assert(call_regs._rets_length <= 1, \"no multi reg returns\");\n@@ -291,25 +181,0 @@\n-  int register_size = sizeof(uintptr_t);\n-  int buffer_alignment = xmm_reg_size;\n-\n-  assert(entry->is_static(), \"static only\");\n-  \/\/ Fill in the signature array, for the calling-convention call.\n-  const int total_out_args = entry->size_of_parameters();\n-  assert(total_out_args > 0, \"receiver arg\");\n-\n-  BasicType* out_sig_bt = NEW_RESOURCE_ARRAY(BasicType, total_out_args);\n-  BasicType ret_type;\n-  {\n-    int i = 0;\n-    SignatureStream ss(entry->signature());\n-    for (; !ss.at_return_type(); ss.next()) {\n-      out_sig_bt[i++] = ss.type();  \/\/ Collect remaining bits of signature\n-      if (ss.type() == T_LONG || ss.type() == T_DOUBLE)\n-        out_sig_bt[i++] = T_VOID;   \/\/ Longs & doubles take 2 Java slots\n-    }\n-    assert(i == total_out_args, \"\");\n-    ret_type = ss.type();\n-  }\n-  \/\/ skip receiver\n-  BasicType* in_sig_bt = out_sig_bt + 1;\n-  int total_in_args = total_out_args - 1;\n-\n@@ -352,0 +217,6 @@\n+  int ret_buf_offset = -1;\n+  if (needs_return_buffer) {\n+    ret_buf_offset = frame_bottom_offset;\n+    frame_bottom_offset += ret_buf_size;\n+  }\n+\n@@ -360,0 +231,3 @@\n+  \/\/      | (optional)          |\n+  \/\/      | ret_buf             |\n+  \/\/      |---------------------| = ret_buf_offset\n@@ -409,0 +283,4 @@\n+  if (needs_return_buffer) {\n+    assert(ret_buf_offset != -1, \"no return buffer allocated\");\n+    __ lea(abi._ret_buf_addr_reg, Address(rsp, ret_buf_offset));\n+  }\n@@ -423,0 +301,45 @@\n+  \/\/ return value shuffle\n+  if (!needs_return_buffer) {\n+#ifdef ASSERT\n+    if (call_regs._rets_length == 1) { \/\/ 0 or 1\n+      VMReg j_expected_result_reg;\n+      switch (ret_type) {\n+        case T_BOOLEAN:\n+        case T_BYTE:\n+        case T_SHORT:\n+        case T_CHAR:\n+        case T_INT:\n+        case T_LONG:\n+        j_expected_result_reg = rax->as_VMReg();\n+        break;\n+        case T_FLOAT:\n+        case T_DOUBLE:\n+          j_expected_result_reg = xmm0->as_VMReg();\n+          break;\n+        default:\n+          fatal(\"unexpected return type: %s\", type2name(ret_type));\n+      }\n+      \/\/ No need to move for now, since CallArranger can pick a return type\n+      \/\/ that goes in the same reg for both CCs. But, at least assert they are the same\n+      assert(call_regs._ret_regs[0] == j_expected_result_reg,\n+      \"unexpected result register: %s != %s\", call_regs._ret_regs[0]->name(), j_expected_result_reg->name());\n+    }\n+#endif\n+  } else {\n+    assert(ret_buf_offset != -1, \"no return buffer allocated\");\n+    __ lea(rscratch1, Address(rsp, ret_buf_offset));\n+    int offset = 0;\n+    for (int i = 0; i < call_regs._rets_length; i++) {\n+      VMReg reg = call_regs._ret_regs[i];\n+      if (reg->is_Register()) {\n+        __ movptr(reg->as_Register(), Address(rscratch1, offset));\n+        offset += 8;\n+      } else if (reg->is_XMMRegister()) {\n+        __ movdqu(reg->as_XMMRegister(), Address(rscratch1, offset));\n+        offset += 16;\n+      } else {\n+        ShouldNotReachHere();\n+      }\n+    }\n+  }\n+\n@@ -437,27 +360,0 @@\n-  \/\/ return value shuffle\n-#ifdef ASSERT\n-  if (call_regs._rets_length == 1) { \/\/ 0 or 1\n-    VMReg j_expected_result_reg;\n-    switch (ret_type) {\n-      case T_BOOLEAN:\n-      case T_BYTE:\n-      case T_SHORT:\n-      case T_CHAR:\n-      case T_INT:\n-      case T_LONG:\n-       j_expected_result_reg = rax->as_VMReg();\n-       break;\n-      case T_FLOAT:\n-      case T_DOUBLE:\n-        j_expected_result_reg = xmm0->as_VMReg();\n-        break;\n-      default:\n-        fatal(\"unexpected return type: %s\", type2name(ret_type));\n-    }\n-    \/\/ No need to move for now, since CallArranger can pick a return type\n-    \/\/ that goes in the same reg for both CCs. But, at least assert they are the same\n-    assert(call_regs._ret_regs[0] == j_expected_result_reg,\n-     \"unexpected result register: %s != %s\", call_regs._ret_regs[0]->name(), j_expected_result_reg->name());\n-  }\n-#endif\n-\n@@ -498,1 +394,6 @@\n-  OptimizedEntryBlob* blob = OptimizedEntryBlob::create(name, &buffer, exception_handler_offset, receiver, in_ByteSize(frame_data_offset));\n+  OptimizedEntryBlob* blob\n+    = OptimizedEntryBlob::create(name,\n+                                 &buffer,\n+                                 exception_handler_offset,\n+                                 receiver,\n+                                 in_ByteSize(frame_data_offset));\n@@ -502,1 +403,0 @@\n-    Disassembler::decode(blob, tty);\n@@ -508,4 +408,0 @@\n-\n-bool ProgrammableUpcallHandler::supports_optimized_upcalls() {\n-  return true;\n-}\n","filename":"src\/hotspot\/cpu\/x86\/universalUpcallHandler_x86_64.cpp","additions":70,"deletions":174,"binary":false,"changes":244,"status":"modified"},{"patch":"@@ -33,5 +33,0 @@\n-const BufferLayout ForeignGlobals::parse_buffer_layout_impl(jobject jlayout) const {\n-  ShouldNotCallThis();\n-  return {};\n-}\n-\n","filename":"src\/hotspot\/cpu\/zero\/foreign_globals_zero.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-class BufferLayout {};\n","filename":"src\/hotspot\/cpu\/zero\/foreign_globals_zero.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,6 @@\n-address ProgrammableUpcallHandler::generate_upcall_stub(jobject rec, jobject jabi, jobject jlayout) {\n+address ProgrammableUpcallHandler::generate_optimized_upcall_stub(jobject receiver, Method* entry,\n+                                                                  BasicType* in_sig_bt, int total_in_args,\n+                                                                  BasicType* out_sig_bt, int total_out_args,\n+                                                                  BasicType ret_type,\n+                                                                  jobject jabi, jobject jconv,\n+                                                                  bool needs_return_buffer, int ret_buf_size) {\n@@ -31,9 +36,0 @@\n-\n-address ProgrammableUpcallHandler::generate_optimized_upcall_stub(jobject mh, Method* entry, jobject jabi, jobject jconv) {\n-  ShouldNotCallThis();\n-  return nullptr;\n-}\n-\n-bool ProgrammableUpcallHandler::supports_optimized_upcalls() {\n-  return false;\n-}\n","filename":"src\/hotspot\/cpu\/zero\/universalUpcallHandle_zero.cpp","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -754,0 +754,6 @@\n+\n+void OptimizedEntryBlob::free(OptimizedEntryBlob* blob) {\n+  assert(blob != nullptr, \"caller must check for NULL\");\n+  JNIHandles::destroy_global(blob->receiver());\n+  BufferBlob::free(blob);\n+}\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -769,0 +769,2 @@\n+  static void free(OptimizedEntryBlob* blob);\n+\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"runtime\/fieldDescriptor.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"runtime\/jniHandles.inline.hpp\"\n@@ -59,3 +59,0 @@\n-const BufferLayout ForeignGlobals::parse_buffer_layout(jobject jlayout) {\n-  return instance().parse_buffer_layout_impl(jlayout);\n-}\n@@ -90,9 +87,0 @@\n-  \/\/ BufferLayout\n-  InstanceKlass* k_BL = find_InstanceKlass(FOREIGN_ABI \"BufferLayout\", current_thread);\n-  BL.size_offset = field_offset(k_BL, \"size\", vmSymbols::long_signature());\n-  BL.arguments_next_pc_offset = field_offset(k_BL, \"arguments_next_pc\", vmSymbols::long_signature());\n-  BL.stack_args_bytes_offset = field_offset(k_BL, \"stack_args_bytes\", vmSymbols::long_signature());\n-  BL.stack_args_offset = field_offset(k_BL, \"stack_args\", vmSymbols::long_signature());\n-  BL.input_type_offsets_offset = field_offset(k_BL, \"input_type_offsets\", vmSymbols::long_array_signature());\n-  BL.output_type_offsets_offset = field_offset(k_BL, \"output_type_offsets\", vmSymbols::long_array_signature());\n-\n@@ -107,0 +95,23 @@\n+const CallRegs ForeignGlobals::parse_call_regs_impl(jobject jconv) const {\n+  oop conv_oop = JNIHandles::resolve_non_null(jconv);\n+  objArrayOop arg_regs_oop = oop_cast<objArrayOop>(conv_oop->obj_field(CallConvOffsets.arg_regs_offset));\n+  objArrayOop ret_regs_oop = oop_cast<objArrayOop>(conv_oop->obj_field(CallConvOffsets.ret_regs_offset));\n+\n+  CallRegs result;\n+  result._args_length = arg_regs_oop->length();\n+  result._arg_regs = NEW_RESOURCE_ARRAY(VMReg, result._args_length);\n+\n+  result._rets_length = ret_regs_oop->length();\n+  result._ret_regs = NEW_RESOURCE_ARRAY(VMReg, result._rets_length);\n+\n+  for (int i = 0; i < result._args_length; i++) {\n+    result._arg_regs[i] = parse_vmstorage(arg_regs_oop->obj_at(i));\n+  }\n+\n+  for (int i = 0; i < result._rets_length; i++) {\n+    result._ret_regs[i] = parse_vmstorage(ret_regs_oop->obj_at(i));\n+  }\n+\n+  return result;\n+}\n+\n","filename":"src\/hotspot\/share\/prims\/foreign_globals.cpp","additions":24,"deletions":13,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -65,9 +65,0 @@\n-  struct {\n-    int size_offset;\n-    int arguments_next_pc_offset;\n-    int stack_args_bytes_offset;\n-    int stack_args_offset;\n-    int input_type_offsets_offset;\n-    int output_type_offsets_offset;\n-  } BL;\n-\n@@ -87,1 +78,0 @@\n-  const BufferLayout parse_buffer_layout_impl(jobject jlayout) const;\n@@ -93,1 +83,0 @@\n-  static const BufferLayout parse_buffer_layout(jobject jlayout);\n","filename":"src\/hotspot\/share\/prims\/foreign_globals.hpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -39,15 +40,0 @@\n-void ProgrammableUpcallHandler::upcall_helper(JavaThread* thread, jobject rec, address buff) {\n-  JavaThread* THREAD = thread; \/\/ For exception macros.\n-  ThreadInVMfromNative tiv(THREAD);\n-  const UpcallMethod& upcall_method = instance().upcall_method;\n-\n-  ResourceMark rm(THREAD);\n-  JavaValue result(T_VOID);\n-  JavaCallArguments args(2); \/\/ long = 2 slots\n-\n-  args.push_jobject(rec);\n-  args.push_long((jlong) buff);\n-\n-  JavaCalls::call_static(&result, upcall_method.klass, upcall_method.name, upcall_method.sig, &args, CATCH);\n-}\n-\n@@ -137,35 +123,0 @@\n-void ProgrammableUpcallHandler::attach_thread_and_do_upcall(jobject rec, address buff) {\n-  bool should_detach = false;\n-  JavaThread* thread = maybe_attach_and_get_thread(&should_detach);\n-\n-  {\n-    MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, thread));\n-    upcall_helper(thread, rec, buff);\n-  }\n-\n-  if (should_detach) {\n-    detach_current_thread();\n-  }\n-}\n-\n-const ProgrammableUpcallHandler& ProgrammableUpcallHandler::instance() {\n-  static ProgrammableUpcallHandler handler;\n-  return handler;\n-}\n-\n-ProgrammableUpcallHandler::ProgrammableUpcallHandler() {\n-  JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n-  ResourceMark rm(THREAD);\n-  Symbol* sym = SymbolTable::new_symbol(FOREIGN_ABI \"ProgrammableUpcallHandler\");\n-  Klass* k = SystemDictionary::resolve_or_null(sym, Handle(), Handle(), CATCH);\n-  k->initialize(CATCH);\n-\n-  upcall_method.klass = k;\n-  upcall_method.name = SymbolTable::new_symbol(\"invoke\");\n-  upcall_method.sig = SymbolTable::new_symbol(\"(Ljava\/lang\/invoke\/MethodHandle;J)V\");\n-\n-  assert(upcall_method.klass->lookup_method(upcall_method.name, upcall_method.sig) != nullptr,\n-    \"Could not find upcall method: %s.%s%s\", upcall_method.klass->external_name(),\n-    upcall_method.name->as_C_string(), upcall_method.sig->as_C_string());\n-}\n-\n@@ -180,7 +131,3 @@\n-JVM_ENTRY(jlong, PUH_AllocateUpcallStub(JNIEnv *env, jclass unused, jobject rec, jobject abi, jobject buffer_layout))\n-  Handle receiver(THREAD, JNIHandles::resolve(rec));\n-  jobject global_rec = JNIHandles::make_global(receiver);\n-  return (jlong) ProgrammableUpcallHandler::generate_upcall_stub(global_rec, abi, buffer_layout);\n-JNI_END\n-\n-JVM_ENTRY(jlong, PUH_AllocateOptimizedUpcallStub(JNIEnv *env, jclass unused, jobject mh, jobject abi, jobject conv))\n+JVM_ENTRY(jlong, PUH_AllocateOptimizedUpcallStub(JNIEnv *env, jclass unused, jobject mh, jobject abi, jobject conv,\n+                                                 jboolean needs_return_buffer, jlong ret_buf_size))\n+  ResourceMark rm(THREAD);\n@@ -198,2 +145,21 @@\n-  return (jlong) ProgrammableUpcallHandler::generate_optimized_upcall_stub(mh_j, entry, abi, conv);\n-JVM_END\n+  assert(entry->is_static(), \"static only\");\n+  \/\/ Fill in the signature array, for the calling-convention call.\n+  const int total_out_args = entry->size_of_parameters();\n+  assert(total_out_args > 0, \"receiver arg\");\n+\n+  BasicType* out_sig_bt = NEW_RESOURCE_ARRAY(BasicType, total_out_args);\n+  BasicType ret_type;\n+  {\n+    int i = 0;\n+    SignatureStream ss(entry->signature());\n+    for (; !ss.at_return_type(); ss.next()) {\n+      out_sig_bt[i++] = ss.type();  \/\/ Collect remaining bits of signature\n+      if (ss.type() == T_LONG || ss.type() == T_DOUBLE)\n+        out_sig_bt[i++] = T_VOID;   \/\/ Longs & doubles take 2 Java slots\n+    }\n+    assert(i == total_out_args, \"\");\n+    ret_type = ss.type();\n+  }\n+  \/\/ skip receiver\n+  BasicType* in_sig_bt = out_sig_bt + 1;\n+  int total_in_args = total_out_args - 1;\n@@ -201,2 +167,2 @@\n-JVM_ENTRY(jboolean, PUH_SupportsOptimizedUpcalls(JNIEnv *env, jclass unused))\n-  return (jboolean) ProgrammableUpcallHandler::supports_optimized_upcalls();\n+  return (jlong) ProgrammableUpcallHandler::generate_optimized_upcall_stub(\n+    mh_j, entry, in_sig_bt, total_in_args, out_sig_bt, total_out_args, ret_type, abi, conv, needs_return_buffer, checked_cast<int>(ret_buf_size));\n@@ -209,3 +175,1 @@\n-  {CC \"allocateUpcallStub\", CC \"(\" \"Ljava\/lang\/invoke\/MethodHandle;\" \"L\" FOREIGN_ABI \"ABIDescriptor;\" \"L\" FOREIGN_ABI \"BufferLayout;\" \")J\", FN_PTR(PUH_AllocateUpcallStub)},\n-  {CC \"allocateOptimizedUpcallStub\", CC \"(\" \"Ljava\/lang\/invoke\/MethodHandle;\" \"L\" FOREIGN_ABI \"ABIDescriptor;\" \"L\" FOREIGN_ABI \"ProgrammableUpcallHandler$CallRegs;\" \")J\", FN_PTR(PUH_AllocateOptimizedUpcallStub)},\n-  {CC \"supportsOptimizedUpcalls\", CC \"()Z\", FN_PTR(PUH_SupportsOptimizedUpcalls)},\n+  {CC \"allocateOptimizedUpcallStub\", CC \"(\" \"Ljava\/lang\/invoke\/MethodHandle;\" \"L\" FOREIGN_ABI \"ABIDescriptor;\" \"L\" FOREIGN_ABI \"ProgrammableUpcallHandler$CallRegs;\" \"ZJ)J\", FN_PTR(PUH_AllocateOptimizedUpcallStub)},\n","filename":"src\/hotspot\/share\/prims\/universalUpcallHandler.cpp","additions":28,"deletions":64,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -35,15 +35,0 @@\n-  static constexpr CodeBuffer::csize_t upcall_stub_size = 1024;\n-\n-  struct UpcallMethod {\n-    Klass* klass;\n-    Symbol* name;\n-    Symbol* sig;\n-  } upcall_method;\n-\n-  ProgrammableUpcallHandler();\n-\n-  static const ProgrammableUpcallHandler& instance();\n-\n-  static void upcall_helper(JavaThread* thread, jobject rec, address buff);\n-  static void attach_thread_and_do_upcall(jobject rec, address buff);\n-\n@@ -57,3 +42,6 @@\n-  static address generate_optimized_upcall_stub(jobject mh, Method* entry, jobject jabi, jobject jconv);\n-  static address generate_upcall_stub(jobject rec, jobject abi, jobject buffer_layout);\n-  static bool supports_optimized_upcalls();\n+  static address generate_optimized_upcall_stub(jobject mh, Method* entry,\n+                                                BasicType* in_sig_bt, int total_in_args,\n+                                                BasicType* out_sig_bt, int total_out_args,\n+                                                BasicType ret_type,\n+                                                jobject jabi, jobject jconv,\n+                                                bool needs_return_buffer, int ret_buf_size);\n","filename":"src\/hotspot\/share\/prims\/universalUpcallHandler.hpp","additions":6,"deletions":18,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -25,2 +25,1 @@\n-#include \"runtime\/jniHandles.inline.hpp\"\n-#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"code\/codeBlob.hpp\"\n@@ -28,1 +27,1 @@\n-#include \"runtime\/vmOperations.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n@@ -31,3 +30,1 @@\n-  \/\/acquire code cache lock\n-  MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n-  \/\/find code blob\n+  \/\/ safe to call 'find_blob' without code cache lock, because stub is always alive\n@@ -35,1 +32,1 @@\n-  if (cb == NULL) {\n+  if (cb == nullptr) {\n@@ -38,11 +35,1 @@\n-  \/\/free global JNI handle\n-  jobject handle = NULL;\n-  if (cb->is_optimized_entry_blob()) {\n-    handle = ((OptimizedEntryBlob*)cb)->receiver();\n-  } else {\n-    jobject* handle_ptr = (jobject*)(void*)cb->content_begin();\n-    handle = *handle_ptr;\n-  }\n-  JNIHandles::destroy_global(handle);\n-  \/\/free code blob\n-  CodeCache::free(cb);\n+  OptimizedEntryBlob::free(cb->as_optimized_entry_blob());\n","filename":"src\/hotspot\/share\/prims\/upcallStubs.cpp","additions":5,"deletions":18,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -401,0 +401,4 @@\n+    public static ToSegment toSegment(long byteSize) {\n+        return new ToSegment(byteSize);\n+    }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,152 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-package jdk.internal.foreign.abi;\n-\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ValueLayout;\n-import jdk.internal.foreign.MemoryAddressImpl;\n-\n-import java.io.PrintStream;\n-import java.lang.invoke.VarHandle;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-class BufferLayout {\n-    static final VarHandle VH_LONG = ValueLayout.JAVA_LONG.varHandle();\n-\n-    final long size;\n-    final long arguments_next_pc;\n-    final long stack_args_bytes;\n-    final long stack_args;\n-\n-    \/\/ read by JNI\n-    final long[] input_type_offsets;\n-    final long[] output_type_offsets;\n-\n-    private final Map<jdk.internal.foreign.abi.VMStorage, Long> argOffsets;\n-    private final Map<jdk.internal.foreign.abi.VMStorage, Long> retOffsets;\n-\n-    private BufferLayout(long size, long arguments_next_pc, long stack_args_bytes, long stack_args,\n-                         long[] input_type_offsets, long[] output_type_offsets,\n-                         Map<jdk.internal.foreign.abi.VMStorage, Long> argOffsets, Map<jdk.internal.foreign.abi.VMStorage, Long> retOffsets) {\n-        this.size = size;\n-        this.arguments_next_pc = arguments_next_pc;\n-        this.stack_args_bytes = stack_args_bytes;\n-        this.stack_args = stack_args;\n-        this.input_type_offsets = input_type_offsets;\n-        this.output_type_offsets = output_type_offsets;\n-        this.argOffsets = argOffsets;\n-        this.retOffsets = retOffsets;\n-    }\n-\n-    static BufferLayout of(ABIDescriptor abi) {\n-        long offset = 0;\n-\n-        offset = SharedUtils.alignUp(offset, 8);\n-        long arguments_next_pc = offset;\n-        offset += 8;\n-\n-        offset = SharedUtils.alignUp(offset, 8);\n-        long stack_args_bytes = offset;\n-        offset += 8;\n-\n-        offset = SharedUtils.alignUp(offset, 8);\n-        long stack_args = offset;\n-        offset += 8;\n-\n-        Map<jdk.internal.foreign.abi.VMStorage, Long> argOffsets = new HashMap<>();\n-        long[] input_type_offsets = new long[abi.inputStorage.length];\n-        for (int i = 0; i < abi.inputStorage.length; i++) {\n-            long size = abi.arch.typeSize(i);\n-            offset = SharedUtils.alignUp(offset, size);\n-            input_type_offsets[i] = offset;\n-            for (jdk.internal.foreign.abi.VMStorage store : abi.inputStorage[i]) {\n-                argOffsets.put(store, offset);\n-                offset += size;\n-            }\n-        }\n-\n-        Map<jdk.internal.foreign.abi.VMStorage, Long> retOffsets = new HashMap<>();\n-        long[] output_type_offsets = new long[abi.outputStorage.length];\n-        for (int i = 0; i < abi.outputStorage.length; i++) {\n-            long size = abi.arch.typeSize(i);\n-            offset = SharedUtils.alignUp(offset, size);\n-            output_type_offsets[i] = offset;\n-            for (jdk.internal.foreign.abi.VMStorage store : abi.outputStorage[i]) {\n-                retOffsets.put(store, offset);\n-                offset += size;\n-            }\n-        }\n-\n-        return new BufferLayout(offset, arguments_next_pc, stack_args_bytes, stack_args,\n-                input_type_offsets, output_type_offsets, argOffsets, retOffsets);\n-    }\n-\n-    long argOffset(jdk.internal.foreign.abi.VMStorage storage) {\n-        return argOffsets.get(storage);\n-    }\n-\n-    long retOffset(jdk.internal.foreign.abi.VMStorage storage) {\n-        return retOffsets.get(storage);\n-    }\n-\n-    private static String getLongString(MemorySegment buffer, long offset) {\n-        return Long.toHexString((long) VH_LONG.get(buffer.asSlice(offset)));\n-    }\n-\n-    private void dumpValues(jdk.internal.foreign.abi.Architecture arch, MemorySegment buff, PrintStream stream,\n-                                   Map<jdk.internal.foreign.abi.VMStorage, Long> offsets) {\n-        for (var entry : offsets.entrySet()) {\n-            VMStorage storage = entry.getKey();\n-            stream.print(storage.name());\n-            stream.print(\"={ \");\n-            MemorySegment start = buff.asSlice(entry.getValue());\n-            for (int i = 0; i < arch.typeSize(storage.type()) \/ 8; i += 8) {\n-                stream.print(getLongString(start, i));\n-                stream.print(\" \");\n-            }\n-            stream.println(\"}\");\n-        }\n-        long stack_ptr = (long) VH_LONG.get(buff.asSlice(stack_args));\n-        long stack_bytes = (long) VH_LONG.get(buff.asSlice(stack_args_bytes));\n-        MemorySegment stackArgs = MemoryAddressImpl.ofLongUnchecked(stack_ptr, stack_bytes);\n-        stream.println(\"Stack {\");\n-        for (int i = 0; i < stack_bytes \/ 8; i += 8) {\n-            stream.printf(\"    @%d: %s%n\", i, getLongString(stackArgs, i));\n-        }\n-        stream.println(\"}\");\n-    }\n-\n-    void dump(Architecture arch, MemorySegment buff, PrintStream stream) {\n-        stream.println(\"Next PC: \" + getLongString(buff, arguments_next_pc));\n-        stream.println(\"Stack args bytes: \" + getLongString(buff, stack_args_bytes));\n-        stream.println(\"Stack args ptr: \" + getLongString(buff, stack_args));\n-\n-        stream.println(\"Arguments:\");\n-        dumpValues(arch, buff, stream, argOffsets);\n-        stream.println(\"Returns:\");\n-        dumpValues(arch, buff, stream, retOffsets);\n-    }\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/BufferLayout.java","additions":0,"deletions":152,"binary":false,"changes":152,"status":"deleted"},{"patch":"@@ -110,0 +110,5 @@\n+        } else if (needsReturnBuffer) { \/\/ forUpcall == true\n+            addArgumentBinding(0, MemorySegment.class, ValueLayout.ADDRESS, List.of(\n+                Binding.vmLoad(abi.retBufAddrStorage(), long.class),\n+                Binding.boxAddress(),\n+                Binding.toSegment(returnBufferSize)));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequenceBuilder.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,1 +28,2 @@\n-import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryHandles;\n+import jdk.incubator.foreign.MemoryLayout;\n@@ -33,1 +34,0 @@\n-import jdk.internal.foreign.MemoryAddressImpl;\n@@ -40,0 +40,1 @@\n+import java.nio.ByteOrder;\n@@ -46,0 +47,1 @@\n+import static java.lang.invoke.MethodHandles.collectArguments;\n@@ -47,0 +49,1 @@\n+import static java.lang.invoke.MethodHandles.empty;\n@@ -48,1 +51,0 @@\n-import static java.lang.invoke.MethodHandles.filterReturnValue;\n@@ -56,5 +58,0 @@\n-\/**\n- * This class implements upcall invocation from native code through a so called 'universal adapter'. A universal upcall adapter\n- * takes an array of storage pointers, which describes the state of the CPU at the time of the upcall. This can be used\n- * by the Java code to fetch the upcall arguments and to store the results to the desired location, as per system ABI.\n- *\/\n@@ -66,4 +63,0 @@\n-    private static final boolean USE_INTRINSICS = Boolean.parseBoolean(\n-        GetPropertyAction.privilegedGetProperty(\"jdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS\", \"true\"));\n-\n-    private static final VarHandle VH_LONG = ValueLayout.JAVA_LONG.varHandle();\n@@ -71,1 +64,0 @@\n-    private static final MethodHandle MH_invokeMoves;\n@@ -77,3 +69,0 @@\n-            MH_invokeMoves = lookup.findStatic(ProgrammableUpcallHandler.class, \"invokeMoves\",\n-                    methodType(void.class, MemoryAddress.class, MethodHandle.class,\n-                               Binding.VMLoad[].class, Binding.VMStore[].class, ABIDescriptor.class, BufferLayout.class));\n@@ -81,2 +70,1 @@\n-                    methodType(Object.class, Object[].class, MethodHandle.class, Map.class, Map.class,\n-                            CallingSequence.class, long.class));\n+                    methodType(Object.class, Object[].class, InvocationData.class));\n@@ -92,7 +80,1 @@\n-        boolean isSimple = !(retMoves.length > 1);\n-\n-        Class<?> llReturn = !isSimple\n-            ? Object[].class\n-            : retMoves.length == 1\n-                ? retMoves[0].type()\n-                : void.class;\n+        Class<?> llReturn = retMoves.length == 1 ? retMoves[0].type() : void.class;\n@@ -100,1 +82,1 @@\n-        MethodType llType = MethodType.methodType(llReturn, llParams);\n+        MethodType llType = methodType(llReturn, llParams);\n@@ -103,2 +85,2 @@\n-        if (USE_SPEC && isSimple) {\n-            doBindings = specializedBindingHandle(target, callingSequence, llReturn, callingSequence.allocationSize());\n+        if (USE_SPEC) {\n+            doBindings = specializedBindingHandle(target, callingSequence, llReturn, abi);\n@@ -109,3 +91,7 @@\n-            target = target.asSpreader(Object[].class, callingSequence.methodType().parameterCount());\n-            doBindings = insertArguments(MH_invokeInterpBindings, 1, target, argIndices, retIndices, callingSequence,\n-                    callingSequence.allocationSize());\n+            int spreaderCount = callingSequence.methodType().parameterCount();\n+            if (callingSequence.needsReturnBuffer()) {\n+                spreaderCount--; \/\/ return buffer is dropped from the argument list\n+            }\n+            target = target.asSpreader(Object[].class, spreaderCount);\n+            InvocationData invData = new InvocationData(target, argIndices, retIndices, callingSequence, retMoves, abi);\n+            doBindings = insertArguments(MH_invokeInterpBindings, 1, invData);\n@@ -116,14 +102,7 @@\n-        long entryPoint;\n-        if (USE_INTRINSICS && isSimple && supportsOptimizedUpcalls()) {\n-            checkPrimitive(doBindings.type());\n-            doBindings = insertArguments(exactInvoker(doBindings.type()), 0, doBindings);\n-            VMStorage[] args = Arrays.stream(argMoves).map(Binding.Move::storage).toArray(VMStorage[]::new);\n-            VMStorage[] rets = Arrays.stream(retMoves).map(Binding.Move::storage).toArray(VMStorage[]::new);\n-            CallRegs conv = new CallRegs(args, rets);\n-            entryPoint = allocateOptimizedUpcallStub(doBindings, abi, conv);\n-        } else {\n-            BufferLayout layout = BufferLayout.of(abi);\n-            MethodHandle doBindingsErased = doBindings.asSpreader(Object[].class, doBindings.type().parameterCount());\n-            MethodHandle invokeMoves = insertArguments(MH_invokeMoves, 1, doBindingsErased, argMoves, retMoves, abi, layout);\n-            entryPoint = allocateUpcallStub(invokeMoves, abi, layout);\n-        }\n+        checkPrimitive(doBindings.type());\n+        doBindings = insertArguments(exactInvoker(doBindings.type()), 0, doBindings);\n+        VMStorage[] args = Arrays.stream(argMoves).map(Binding.Move::storage).toArray(VMStorage[]::new);\n+        VMStorage[] rets = Arrays.stream(retMoves).map(Binding.Move::storage).toArray(VMStorage[]::new);\n+        CallRegs conv = new CallRegs(args, rets);\n+        long entryPoint = allocateOptimizedUpcallStub(doBindings, abi, conv,\n+                callingSequence.needsReturnBuffer(), callingSequence.returnBufferSize());\n@@ -158,1 +137,1 @@\n-                                                         Class<?> llReturn, long allocationSize) {\n+                                                         Class<?> llReturn, ABIDescriptor abi) {\n@@ -163,0 +142,32 @@\n+        \/\/ we handle returns first since IMR adds an extra parameter that needs to be specialized as well\n+        if (llReturn != void.class || callingSequence.needsReturnBuffer()) {\n+            int retAllocatorPos = -1; \/\/ assumed not needed\n+            int retInsertPos;\n+            MethodHandle filter;\n+            if (callingSequence.needsReturnBuffer()) {\n+                retInsertPos = 1;\n+                filter = empty(methodType(void.class, MemorySegment.class));\n+            } else {\n+                retInsertPos = 0;\n+                filter = identity(llReturn);\n+            }\n+            long retBufWriteOffset = callingSequence.returnBufferSize();\n+            List<Binding> bindings = callingSequence.returnBindings();\n+            for (int j = bindings.size() - 1; j >= 0; j--) {\n+                Binding binding = bindings.get(j);\n+                if (callingSequence.needsReturnBuffer() && binding.tag() == Binding.Tag.VM_STORE) {\n+                    Binding.VMStore store = (Binding.VMStore) binding;\n+                    ValueLayout layout = MemoryLayout.valueLayout(store.type(), ByteOrder.nativeOrder()).withBitAlignment(8);\n+                    \/\/ since we iterate the bindings in reverse, we have to compute the offset in reverse as well\n+                    retBufWriteOffset -= abi.arch.typeSize(store.storage().type());\n+                    MethodHandle storeHandle = MemoryHandles.insertCoordinates(MemoryHandles.varHandle(layout), 1, retBufWriteOffset)\n+                            .toMethodHandle(VarHandle.AccessMode.SET);\n+                    filter = collectArguments(filter, retInsertPos, storeHandle);\n+                    filter = mergeArguments(filter, retInsertPos - 1, retInsertPos);\n+                } else {\n+                    filter = binding.specialize(filter, retInsertPos, retAllocatorPos);\n+                }\n+            }\n+            specializedHandle = collectArguments(filter, retInsertPos, specializedHandle);\n+        }\n+\n@@ -182,13 +193,1 @@\n-        if (llReturn != void.class) {\n-            int retAllocatorPos = -1; \/\/ assumed not needed\n-            int retInsertPos = 0;\n-            MethodHandle filter = identity(llReturn);\n-            List<Binding> bindings = callingSequence.returnBindings();\n-            for (int j = bindings.size() - 1; j >= 0; j--) {\n-                Binding binding = bindings.get(j);\n-                filter = binding.specialize(filter, retInsertPos, retAllocatorPos);\n-            }\n-            specializedHandle = filterReturnValue(specializedHandle, filter);\n-        }\n-\n-        specializedHandle = SharedUtils.wrapWithAllocator(specializedHandle, argAllocatorPos, allocationSize, true);\n+        specializedHandle = SharedUtils.wrapWithAllocator(specializedHandle, argAllocatorPos, callingSequence.allocationSize(), true);\n@@ -199,43 +198,6 @@\n-    public static void invoke(MethodHandle mh, long address) throws Throwable {\n-        mh.invokeExact(MemoryAddress.ofLong(address));\n-    }\n-\n-    private static void invokeMoves(MemoryAddress buffer, MethodHandle leaf,\n-                                    Binding.VMLoad[] argBindings, Binding.VMStore[] returnBindings,\n-                                    ABIDescriptor abi, BufferLayout layout) throws Throwable {\n-        MemorySegment bufferBase = MemoryAddressImpl.ofLongUnchecked(buffer.toRawLongValue(), layout.size);\n-\n-        if (DEBUG) {\n-            System.err.println(\"Buffer state before:\");\n-            layout.dump(abi.arch, bufferBase, System.err);\n-        }\n-\n-        MemorySegment stackArgsBase = MemoryAddressImpl.ofLongUnchecked((long)VH_LONG.get(bufferBase.asSlice(layout.stack_args)));\n-        Object[] moves = new Object[argBindings.length];\n-        for (int i = 0; i < moves.length; i++) {\n-            Binding.VMLoad binding = argBindings[i];\n-            VMStorage storage = binding.storage();\n-            MemorySegment ptr = abi.arch.isStackType(storage.type())\n-                ? stackArgsBase.asSlice(storage.index() * abi.arch.typeSize(abi.arch.stackType()))\n-                : bufferBase.asSlice(layout.argOffset(storage));\n-            moves[i] = SharedUtils.read(ptr, binding.type());\n-        }\n-\n-        \/\/ invokeInterpBindings, and then actual target\n-        Object o = leaf.invoke(moves);\n-\n-        if (o == null) {\n-            \/\/ nop\n-        } else if (o instanceof Object[] returns) {\n-            for (int i = 0; i < returnBindings.length; i++) {\n-                Binding.VMStore binding = returnBindings[i];\n-                VMStorage storage = binding.storage();\n-                MemorySegment ptr = bufferBase.asSlice(layout.retOffset(storage));\n-                SharedUtils.writeOverSized(ptr, binding.type(), returns[i]);\n-            }\n-        } else { \/\/ single Object\n-            Binding.VMStore binding = returnBindings[0];\n-            VMStorage storage = binding.storage();\n-            MemorySegment ptr = bufferBase.asSlice(layout.retOffset(storage));\n-            SharedUtils.writeOverSized(ptr, binding.type(), o);\n-        }\n+    private record InvocationData(MethodHandle leaf,\n+                                  Map<VMStorage, Integer> argIndexMap,\n+                                  Map<VMStorage, Integer> retIndexMap,\n+                                  CallingSequence callingSequence,\n+                                  Binding.VMStore[] retMoves,\n+                                  ABIDescriptor abi) {}\n@@ -243,13 +205,3 @@\n-        if (DEBUG) {\n-            System.err.println(\"Buffer state after:\");\n-            layout.dump(abi.arch, bufferBase, System.err);\n-        }\n-    }\n-\n-    private static Object invokeInterpBindings(Object[] moves, MethodHandle leaf,\n-                                               Map<VMStorage, Integer> argIndexMap,\n-                                               Map<VMStorage, Integer> retIndexMap,\n-                                               CallingSequence callingSequence,\n-                                               long allocationSize) throws Throwable {\n-        Binding.Context allocator = allocationSize != 0\n-                ? Binding.Context.ofBoundedAllocator(allocationSize)\n+    private static Object invokeInterpBindings(Object[] lowLevelArgs, InvocationData invData) throws Throwable {\n+        Binding.Context allocator = invData.callingSequence.allocationSize() != 0\n+                ? Binding.Context.ofBoundedAllocator(invData.callingSequence.allocationSize())\n@@ -259,4 +211,13 @@\n-            Object[] args = new Object[callingSequence.methodType().parameterCount()];\n-            for (int i = 0; i < args.length; i++) {\n-                args[i] = BindingInterpreter.box(callingSequence.argumentBindings(i),\n-                        (storage, type) -> moves[argIndexMap.get(storage)], allocator);\n+            Object[] highLevelArgs = new Object[invData.callingSequence.methodType().parameterCount()];\n+            for (int i = 0; i < highLevelArgs.length; i++) {\n+                highLevelArgs[i] = BindingInterpreter.box(invData.callingSequence.argumentBindings(i),\n+                        (storage, type) -> lowLevelArgs[invData.argIndexMap.get(storage)], allocator);\n+            }\n+\n+            MemorySegment returnBuffer = null;\n+            if (invData.callingSequence.needsReturnBuffer()) {\n+                \/\/ this one is for us\n+                returnBuffer = (MemorySegment) highLevelArgs[0];\n+                Object[] newArgs = new Object[highLevelArgs.length - 1];\n+                System.arraycopy(highLevelArgs, 1, newArgs, 0, newArgs.length);\n+                highLevelArgs = newArgs;\n@@ -267,1 +228,1 @@\n-                System.err.println(Arrays.toString(args).indent(2));\n+                System.err.println(Arrays.toString(highLevelArgs).indent(2));\n@@ -271,1 +232,1 @@\n-            Object o = leaf.invoke(args);\n+            Object o = invData.leaf.invoke(highLevelArgs);\n@@ -278,4 +239,4 @@\n-            Object[] returnMoves = new Object[retIndexMap.size()];\n-            if (leaf.type().returnType() != void.class) {\n-                BindingInterpreter.unbox(o, callingSequence.returnBindings(),\n-                        (storage, type, value) -> returnMoves[retIndexMap.get(storage)] = value, null);\n+            Object[] returnValues = new Object[invData.retIndexMap.size()];\n+            if (invData.leaf.type().returnType() != void.class) {\n+                BindingInterpreter.unbox(o, invData.callingSequence.returnBindings(),\n+                        (storage, type, value) -> returnValues[invData.retIndexMap.get(storage)] = value, null);\n@@ -284,1 +245,1 @@\n-            if (returnMoves.length == 0) {\n+            if (returnValues.length == 0) {\n@@ -286,2 +247,2 @@\n-            } else if (returnMoves.length == 1) {\n-                return returnMoves[0];\n+            } else if (returnValues.length == 1) {\n+                return returnValues[0];\n@@ -289,1 +250,16 @@\n-                return returnMoves;\n+                assert invData.callingSequence.needsReturnBuffer();\n+\n+                Binding.VMStore[] retMoves = invData.callingSequence.returnBindings().stream()\n+                        .filter(Binding.VMStore.class::isInstance)\n+                        .map(Binding.VMStore.class::cast)\n+                        .toArray(Binding.VMStore[]::new);\n+\n+                assert returnValues.length == retMoves.length;\n+                int retBufWriteOffset = 0;\n+                for (int i = 0; i < retMoves.length; i++) {\n+                    Binding.VMStore store = retMoves[i];\n+                    Object value = returnValues[i];\n+                    SharedUtils.writeOverSized(returnBuffer.asSlice(retBufWriteOffset), store.type(), value);\n+                    retBufWriteOffset += invData.abi.arch.typeSize(store.storage().type());\n+                }\n+                return null;\n@@ -300,3 +276,2 @@\n-    static native long allocateOptimizedUpcallStub(MethodHandle mh, ABIDescriptor abi, CallRegs conv);\n-    static native long allocateUpcallStub(MethodHandle mh, ABIDescriptor abi, BufferLayout layout);\n-    static native boolean supportsOptimizedUpcalls();\n+    static native long allocateOptimizedUpcallStub(MethodHandle mh, ABIDescriptor abi, CallRegs conv,\n+                                                   boolean needsReturnBuffer, long returnBufferSize);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler.java","additions":107,"deletions":132,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-        r11  \/\/ imr addr reg\n+        r11  \/\/ ret buf addr reg\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-        r11  \/\/ imr addr reg\n+        r11  \/\/ ret buf addr reg\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}