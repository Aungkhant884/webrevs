{"files":[{"patch":"@@ -218,1 +218,1 @@\n-            MH_COPY_BUFFER = lookup.findStatic(Binding.class, \"copyBuffer\",\n+            MH_COPY_BUFFER = lookup.findStatic(Binding.Copy.class, \"copyBuffer\",\n@@ -220,1 +220,1 @@\n-            MH_ALLOCATE_BUFFER = lookup.findStatic(Binding.class, \"allocateBuffer\",\n+            MH_ALLOCATE_BUFFER = lookup.findStatic(Binding.Allocate.class, \"allocateBuffer\",\n@@ -222,1 +222,1 @@\n-            MH_TO_SEGMENT = lookup.findStatic(Binding.class, \"toSegment\",\n+            MH_TO_SEGMENT = lookup.findStatic(Binding.ToSegment.class, \"toSegment\",\n@@ -291,16 +291,0 @@\n-    private static MemorySegment copyBuffer(MemorySegment operand, long size, long alignment,\n-                                            SharedUtils.Allocator allocator) {\n-        MemorySegment copy = allocator.allocate(size, alignment);\n-        copy.copyFrom(operand.asSlice(0, size));\n-        return copy;\n-    }\n-\n-    private static MemorySegment allocateBuffer(long size, long allignment, SharedUtils.Allocator allocator) {\n-        return allocator.allocate(size, allignment);\n-    }\n-\n-    \/\/ FIXME should register with scope\n-    private static MemorySegment toSegment(MemoryAddress operand, long size) {\n-        return MemoryAddressImpl.ofLongUnchecked(operand.toRawLongValue(), size);\n-    }\n-\n@@ -317,1 +301,1 @@\n-    public static BuffferStore bufferStore(long offset, Class<?> type) {\n+    public static BufferStore bufferStore(long offset, Class<?> type) {\n@@ -320,1 +304,1 @@\n-        return new BuffferStore(offset, type);\n+        return new BufferStore(offset, type);\n@@ -591,2 +575,2 @@\n-    public static class BuffferStore extends Dereference {\n-        private BuffferStore(long offset, Class<?> type) {\n+    public static class BufferStore extends Dereference {\n+        private BufferStore(long offset, Class<?> type) {\n@@ -622,1 +606,1 @@\n-            return \"BuffferStore{\" +\n+            return \"BufferStore{\" +\n@@ -689,0 +673,7 @@\n+        private static MemorySegment copyBuffer(MemorySegment operand, long size, long alignment,\n+                                                    SharedUtils.Allocator allocator) {\n+            MemorySegment copy = allocator.allocate(size, alignment);\n+            copy.copyFrom(operand.asSlice(0, size));\n+            return copy;\n+        }\n+\n@@ -717,1 +708,1 @@\n-            MemorySegment copy = Binding.copyBuffer(operand, size, alignment, allocator);\n+            MemorySegment copy = copyBuffer(operand, size, alignment, allocator);\n@@ -758,0 +749,4 @@\n+        private static MemorySegment allocateBuffer(long size, long allignment, SharedUtils.Allocator allocator) {\n+            return allocator.allocate(size, allignment);\n+        }\n+\n@@ -783,1 +778,1 @@\n-            stack.push(Binding.allocateBuffer(size, alignment, allocator));\n+            stack.push(allocateBuffer(size, alignment, allocator));\n@@ -928,0 +923,5 @@\n+        \/\/ FIXME should register with scope\n+        private static MemorySegment toSegment(MemoryAddress operand, long size) {\n+            return MemoryAddressImpl.ofLongUnchecked(operand.toRawLongValue(), size);\n+        }\n+\n@@ -939,1 +939,1 @@\n-            MemorySegment segment = Binding.toSegment(operand, size);\n+            MemorySegment segment = toSegment(operand, size);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":27,"deletions":27,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.EnumSet;\n@@ -34,0 +35,3 @@\n+import java.util.Set;\n+\n+import static jdk.internal.foreign.abi.Binding.Tag.*;\n@@ -88,0 +92,14 @@\n+    private static final Set<Binding.Tag> unboxTags = EnumSet.of(\n+        VM_STORE,\n+        \/\/VM_LOAD,\n+        \/\/BUFFER_STORE,\n+        BUFFER_LOAD,\n+        COPY_BUFFER,\n+        \/\/ALLOC_BUFFER,\n+        \/\/BOX_ADDRESS,\n+        UNBOX_ADDRESS,\n+        BASE_ADDRESS,\n+        \/\/TO_SEGMENT,\n+        DUP\n+    );\n+\n@@ -93,4 +111,1 @@\n-            if (b.tag() == Binding.Tag.VM_LOAD\n-                    || b.tag() == Binding.Tag.ALLOC_BUFFER\n-                    || b.tag() == Binding.Tag.BUFFER_STORE\n-                    || b.tag() == Binding.Tag.BOX_ADDRESS)\n+            if (!unboxTags.contains(b.tag()))\n@@ -106,1 +121,15 @@\n-    private static void verifyBoxBindings(Class<?> expectedReturnType, List<Binding> bindings) {\n+    private static final Set<Binding.Tag> boxTags = EnumSet.of(\n+        \/\/VM_STORE,\n+        VM_LOAD,\n+        BUFFER_STORE,\n+        \/\/BUFFER_LOAD,\n+        COPY_BUFFER,\n+        ALLOC_BUFFER,\n+        BOX_ADDRESS,\n+        \/\/UNBOX_ADDRESS,\n+        \/\/BASE_ADDRESS,\n+        TO_SEGMENT,\n+        DUP\n+    );\n+\n+    private static void verifyBoxBindings(Class<?> expectedOutType, List<Binding> bindings) {\n@@ -110,3 +139,1 @@\n-            if (b.tag() == Binding.Tag.VM_STORE\n-                    || b.tag() == Binding.Tag.BUFFER_LOAD\n-                    || b.tag() == Binding.Tag.UNBOX_ADDRESS)\n+            if (!boxTags.contains(b.tag()))\n@@ -121,2 +148,2 @@\n-        Class<?> actualReturnType = stack.pop();\n-        SharedUtils.checkType(actualReturnType, expectedReturnType);\n+        Class<?> actualOutType = stack.pop();\n+        SharedUtils.checkType(actualOutType, expectedOutType);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequenceBuilder.java","additions":37,"deletions":10,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+import static jdk.internal.foreign.abi.SharedUtils.Allocator.THROWING_ALLOCATOR;\n@@ -343,4 +344,4 @@\n-        boolean hasBufferCopies = bufferCopySize != 0;\n-        NativeScope scope = hasBufferCopies ? NativeScope.boundedScope(bufferCopySize) : null;\n-        SharedUtils.Allocator unboxAllocator = hasBufferCopies ? SharedUtils.Allocator.ofScope(scope) : null;\n-        try {\n+        SharedUtils.Allocator unboxAllocator = bufferCopySize != 0\n+                ? SharedUtils.Allocator.ofScope(NativeScope.boundedScope(bufferCopySize))\n+                : THROWING_ALLOCATOR;\n+        try (unboxAllocator) {\n@@ -371,4 +372,0 @@\n-        } finally {\n-            if (scope != null) {\n-                scope.close();\n-            }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableInvoker.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -368,1 +368,3 @@\n-    public interface Allocator {\n+    public interface Allocator extends AutoCloseable {\n+        Allocator THROWING_ALLOCATOR = (size, align) -> { throw new UnsupportedOperationException(\"Null allocator\"); };\n+\n@@ -377,0 +379,3 @@\n+        @Override\n+        default void close() {}\n+\n@@ -380,1 +385,11 @@\n-            return scope::allocate;\n+            return new Allocator() {\n+                @Override\n+                public MemorySegment allocate(long size, long align) {\n+                    return scope.allocate(size, align);\n+                }\n+\n+                @Override\n+                public void close() {\n+                    scope.close();\n+                }\n+            };\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"}]}