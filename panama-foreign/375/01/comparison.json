{"files":[{"patch":"@@ -29,1 +29,0 @@\n-import jdk.incubator.foreign.NativeScope;\n@@ -38,1 +37,0 @@\n-import java.util.Map;\n@@ -43,1 +41,0 @@\n-import java.util.concurrent.ConcurrentHashMap;\n@@ -75,1 +72,1 @@\n- * 0: MOVE(rcx, int.class) \/\/ move an 'int' into the RCX register\n+ * 0: VM_STORE(rcx, int.class) \/\/ move an 'int' into the RCX register\n@@ -85,2 +82,2 @@\n- * 0: CONVERT_ADDRESS \/\/ the 'MemoryAddress' is converted into a 'long'\n- *    MOVE(rcx, long.class) \/\/ the 'long' is moved into the RCX register\n+ * 0: UNBOX_ADDRESS \/\/ the 'MemoryAddress' is converted into a 'long'\n+ *    VM_STORE(rcx, long.class) \/\/ the 'long' is moved into the RCX register\n@@ -99,2 +96,2 @@\n- * 0: MOVE(rax, long) \/\/ load a 'long' from the RAX register\n- *    CONVERT_ADDRESS \/\/ convert the 'long' into a 'MemoryAddress'\n+ * 0: VM_LOAD(rax, long) \/\/ load a 'long' from the RAX register\n+ *    BOX_ADDRESS \/\/ convert the 'long' into a 'MemoryAddress'\n@@ -112,2 +109,2 @@\n- * 0: DEREFERENCE(0, long.class) \/\/ From the struct's memory region, load a 'long' from offset '0'\n- *    MOVE(rcx, long.class) \/\/ and copy that into the RCX register\n+ * 0: BUFFER_LOAD(0, long.class) \/\/ From the struct's memory region, load a 'long' from offset '0'\n+ *    VM_STORE(rcx, long.class) \/\/ and copy that into the RCX register\n@@ -132,2 +129,2 @@\n- *    CONVERT_ADDRESS \/\/ converts the base address to a 'long'\n- *    MOVE(rcx, long.class) \/\/ moves the 'long' into the RCX register\n+ *    UNBOX_ADDRESS \/\/ converts the base address to a 'long'\n+ *    VM_STORE(rcx, long.class) \/\/ moves the 'long' into the RCX register\n@@ -142,4 +139,4 @@\n- *    DEREFERENCE(0, long.class) \/\/ loads a 'long' from offset '0'\n- *    MOVE(rdx, long.class) \/\/ moves the long into the RDX register\n- *    DEREFERENCE(8, long.class) \/\/ loads a 'long' from offset '8'\n- *    MOVE(rcx, long.class) \/\/ moves the long into the RCX register\n+ *    BUFFER_LOAD(0, long.class) \/\/ loads a 'long' from offset '0'\n+ *    VM_STORE(rdx, long.class) \/\/ moves the long into the RDX register\n+ *    BUFFER_LOAD(8, long.class) \/\/ loads a 'long' from offset '8'\n+ *    VM_STORE(rcx, long.class) \/\/ moves the long into the RCX register\n@@ -165,2 +162,2 @@\n- *    MOVE(rax, long.class) \/\/ loads a 'long' from rax\n- *    DEREFERENCE(0, long.class) \/\/ stores a 'long' at offset 0\n+ *    VM_LOAD(rax, long.class) \/\/ loads a 'long' from rax\n+ *    BUFFER_STORE(0, long.class) \/\/ stores a 'long' at offset 0\n@@ -180,2 +177,2 @@\n- * 0: CONVERT_ADDRESS \/\/ unbox the MemoryAddress synthetic argument\n- *    MOVE(rcx, long.class) \/\/ moves the 'long' into the RCX register\n+ * 0: UNBOX_ADDRESS \/\/ unbox the MemoryAddress synthetic argument\n+ *    VM_STORE(rcx, long.class) \/\/ moves the 'long' into the RCX register\n@@ -193,1 +190,1 @@\n- * 0: MOVE(rcx, int.class) \/\/ moves the 'int dummy' into the RCX register\n+ * 0: VM_STORE(rcx, int.class) \/\/ moves the 'int dummy' into the RCX register\n@@ -196,2 +193,2 @@\n- *    MOVE(rdx, float.class) \/\/ move one copy into the RDX register\n- *    MOVE(xmm1, float.class) \/\/ moves the other copy into the xmm2 register\n+ *    VM_STORE(rdx, float.class) \/\/ move one copy into the RDX register\n+ *    VM_STORE(xmm1, float.class) \/\/ moves the other copy into the xmm2 register\n@@ -210,0 +207,1 @@\n+    private static final MethodHandle MH_TO_SEGMENT;\n@@ -220,4 +218,6 @@\n-            MH_COPY_BUFFER = lookup.findStatic(Binding.class, \"copyBuffer\",\n-                    methodType(MemorySegment.class, MemorySegment.class, long.class, long.class, NativeScope.class));\n-            MH_ALLOCATE_BUFFER = lookup.findStatic(MemorySegment.class, \"allocateNative\",\n-                    methodType(MemorySegment.class, long.class, long.class));\n+            MH_COPY_BUFFER = lookup.findStatic(Binding.Copy.class, \"copyBuffer\",\n+                    methodType(MemorySegment.class, MemorySegment.class, long.class, long.class, SharedUtils.Allocator.class));\n+            MH_ALLOCATE_BUFFER = lookup.findStatic(Binding.Allocate.class, \"allocateBuffer\",\n+                    methodType(MemorySegment.class, long.class, long.class, SharedUtils.Allocator.class));\n+            MH_TO_SEGMENT = lookup.findStatic(Binding.ToSegment.class, \"toSegment\",\n+                    methodType(MemorySegment.class, MemoryAddress.class, long.class));\n@@ -230,2 +230,4 @@\n-        MOVE,\n-        DEREFERENCE,\n+        VM_STORE,\n+        VM_LOAD,\n+        BUFFER_STORE,\n+        BUFFER_LOAD,\n@@ -234,1 +236,2 @@\n-        CONVERT_ADDRESS,\n+        BOX_ADDRESS,\n+        UNBOX_ADDRESS,\n@@ -236,0 +239,1 @@\n+        TO_SEGMENT,\n@@ -249,2 +253,1 @@\n-    public abstract void verifyUnbox(Deque<Class<?>> stack);\n-    public abstract void verifyBox(Deque<Class<?>> stack);\n+    public abstract void verify(Deque<Class<?>> stack);\n@@ -252,2 +255,2 @@\n-    public abstract void unbox(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope);\n-    public abstract void box(Deque<Object> stack, BindingInterpreter.LoadFunc loadFunc);\n+    public abstract void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n+                                   BindingInterpreter.LoadFunc loadFunc, SharedUtils.Allocator allocator);\n@@ -255,2 +258,1 @@\n-    public abstract MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos);\n-    public abstract MethodHandle specializeBox(MethodHandle returnFilter);\n+    public abstract MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos);\n@@ -284,4 +286,3 @@\n-    private static MemorySegment copyBuffer(MemorySegment operand, long size, long alignment, NativeScope allocator) {\n-        MemorySegment copy = allocator.allocate(size, alignment);\n-        copy.copyFrom(operand.asSlice(0, size));\n-        return copy;\n+    private static void checkOffset(long offset) {\n+        if (offset < 0)\n+            throw new IllegalArgumentException(\"Negative offset: \" + offset);\n@@ -290,1 +291,1 @@\n-    public static Move move(VMStorage storage, Class<?> type) {\n+    public static VMStore vmStore(VMStorage storage, Class<?> type) {\n@@ -292,1 +293,1 @@\n-        return new Move(storage, type);\n+        return new VMStore(storage, type);\n@@ -295,1 +296,1 @@\n-    public static Dereference dereference(long offset, Class<?> type) {\n+    public static VMLoad vmLoad(VMStorage storage, Class<?> type) {\n@@ -297,3 +298,13 @@\n-        if (offset < 0)\n-            throw new IllegalArgumentException(\"Negative offset: \" + offset);\n-        return new Dereference(offset, type);\n+        return new VMLoad(storage, type);\n+    }\n+\n+    public static BufferStore bufferStore(long offset, Class<?> type) {\n+        checkType(type);\n+        checkOffset(offset);\n+        return new BufferStore(offset, type);\n+    }\n+\n+    public static BufferLoad bufferLoad(long offset, Class<?> type) {\n+        checkType(type);\n+        checkOffset(offset);\n+        return new BufferLoad(offset, type);\n@@ -310,2 +321,6 @@\n-    public static ConvertAddress convertAddress() {\n-        return ConvertAddress.INSTANCE;\n+    public static BoxAddress boxAddress() {\n+        return BoxAddress.INSTANCE;\n+    }\n+\n+    public static UnboxAddress unboxAddress() {\n+        return UnboxAddress.INSTANCE;\n@@ -318,0 +333,4 @@\n+    public static ToSegment toSegment(MemoryLayout layout) {\n+        return new ToSegment(layout.byteSize());\n+    }\n+\n@@ -327,0 +346,13 @@\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+        Binding binding = (Binding) o;\n+        return tag == binding.tag;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(tag);\n+    }\n+\n@@ -333,2 +365,2 @@\n-        public Binding.Builder move(VMStorage storage, Class<?> type) {\n-            bindings.add(Binding.move(storage, type));\n+        public Binding.Builder vmStore(VMStorage storage, Class<?> type) {\n+            bindings.add(Binding.vmStore(storage, type));\n@@ -338,2 +370,12 @@\n-        public Binding.Builder dereference(long offset, Class<?> type) {\n-            bindings.add(Binding.dereference(offset, type));\n+        public Binding.Builder vmLoad(VMStorage storage, Class<?> type) {\n+            bindings.add(Binding.vmLoad(storage, type));\n+            return this;\n+        }\n+\n+        public Binding.Builder bufferStore(long offset, Class<?> type) {\n+            bindings.add(Binding.bufferStore(offset, type));\n+            return this;\n+        }\n+\n+        public Binding.Builder bufferLoad(long offset, Class<?> type) {\n+            bindings.add(Binding.bufferLoad(offset, type));\n@@ -353,2 +395,7 @@\n-        public Binding.Builder convertAddress() {\n-            bindings.add(Binding.convertAddress());\n+        public Binding.Builder boxAddress() {\n+            bindings.add(Binding.boxAddress());\n+            return this;\n+        }\n+\n+        public Binding.Builder unboxAddress() {\n+            bindings.add(Binding.unboxAddress());\n@@ -363,0 +410,5 @@\n+        public Binding.Builder toSegment(MemoryLayout layout) {\n+            bindings.add(Binding.toSegment(layout));\n+            return this;\n+        }\n+\n@@ -373,7 +425,1 @@\n-    \/**\n-     * MOVE([storage location], [type])\n-     *   When unboxing: pops a [type] from the operand stack, and moves it to [storage location]\n-     *   When boxing: loads a [type] from [storage location], and pushes it onto the operand stack\n-     * The [type] must be one of byte, short, char, int, long, float, or double\n-     *\/\n-    public static class Move extends Binding {\n+    static abstract class Move extends Binding {\n@@ -383,2 +429,2 @@\n-        private Move(VMStorage storage, Class<?> type) {\n-            super(Tag.MOVE);\n+        private Move(Tag tag, VMStorage storage, Class<?> type) {\n+            super(tag);\n@@ -397,9 +443,0 @@\n-        @Override\n-        public String toString() {\n-            return \"Move{\" +\n-                    \"tag=\" + tag() +\n-                    \", storage=\" + storage +\n-                    \", type=\" + type +\n-                    '}';\n-        }\n-\n@@ -410,0 +447,1 @@\n+            if (!super.equals(o)) return false;\n@@ -411,2 +449,2 @@\n-            return storage.equals(move.storage) &&\n-                    type.equals(move.type);\n+            return Objects.equals(storage, move.storage) &&\n+                    Objects.equals(type, move.type);\n@@ -417,1 +455,12 @@\n-            return Objects.hash(tag(), storage, type);\n+            return Objects.hash(super.hashCode(), storage, type);\n+        }\n+    }\n+\n+    \/**\n+     * VM_STORE([storage location], [type])\n+     * Pops a [type] from the operand stack, and moves it to [storage location]\n+     * The [type] must be one of byte, short, char, int, long, float, or double\n+     *\/\n+    public static class VMStore extends Move {\n+        private VMStore(VMStorage storage, Class<?> type) {\n+            super(Tag.VM_STORE, storage, type);\n@@ -421,1 +470,1 @@\n-        public void verifyUnbox(Deque<Class<?>> stack) {\n+        public void verify(Deque<Class<?>> stack) {\n@@ -423,1 +472,1 @@\n-            Class<?> expectedType = type;\n+            Class<?> expectedType = type();\n@@ -428,2 +477,27 @@\n-        public void verifyBox(Deque<Class<?>> stack) {\n-            stack.push(type);\n+        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n+                              BindingInterpreter.LoadFunc loadFunc, SharedUtils.Allocator allocator) {\n+            storeFunc.store(storage(), type(), stack.pop());\n+        }\n+\n+        @Override\n+        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n+            return specializedHandle; \/\/ no-op\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"VMStore{\" +\n+                    \"storage=\" + storage() +\n+                    \", type=\" + type() +\n+                    '}';\n+        }\n+    }\n+\n+    \/**\n+     * VM_LOAD([storage location], [type])\n+     * Loads a [type] from [storage location], and pushes it onto the operand stack.\n+     * The [type] must be one of byte, short, char, int, long, float, or double\n+     *\/\n+    public static class VMLoad extends Move {\n+        private VMLoad(VMStorage storage, Class<?> type) {\n+            super(Tag.VM_LOAD, storage, type);\n@@ -433,2 +507,2 @@\n-        public void unbox(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {\n-            storeFunc.store(storage, type, stack.pop());\n+        public void verify(Deque<Class<?>> stack) {\n+            stack.push(type());\n@@ -438,2 +512,3 @@\n-        public void box(Deque<Object> stack, BindingInterpreter.LoadFunc loadFunc) {\n-            stack.push(loadFunc.load(storage, type));\n+        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n+                              BindingInterpreter.LoadFunc loadFunc, SharedUtils.Allocator allocator) {\n+            stack.push(loadFunc.load(storage(), type()));\n@@ -443,1 +518,1 @@\n-        public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {\n+        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n@@ -448,2 +523,5 @@\n-        public MethodHandle specializeBox(MethodHandle returnFilter) {\n-            return returnFilter; \/\/ no-op\n+        public String toString() {\n+            return \"VMLoad{\" +\n+                    \"storage=\" + storage() +\n+                    \", type=\" + type() +\n+                    '}';\n@@ -453,9 +531,1 @@\n-    \/**\n-     * DEREFERENCE([offset into memory region], [type])\n-     *   When unboxing: pops a MemorySegment from the operand stack,\n-     *     loads a [type] from [offset into memory region] from it, and pushes it onto the operand stack\n-     *   When boxing: pops a [type], and then a MemorySegment from the operand stack,\n-     *     and then stores [type] to [offset into memory region] of the MemorySegment\n-     * The [type] must be one of byte, short, char, int, long, float, or double\n-     *\/\n-    public static class Dereference extends Binding {\n+    private static abstract class Dereference extends Binding {\n@@ -465,2 +535,2 @@\n-        private Dereference(long offset, Class<?> type) {\n-            super(Tag.DEREFERENCE);\n+        private Dereference(Tag tag, long offset, Class<?> type) {\n+            super(tag);\n@@ -479,9 +549,0 @@\n-        @Override\n-        public String toString() {\n-            return \"Dereference{\" +\n-                    \"tag=\" + tag() +\n-                    \", offset=\" + offset +\n-                    \", type=\" + type +\n-                    '}';\n-        }\n-\n@@ -492,0 +553,1 @@\n+            if (!super.equals(o)) return false;\n@@ -494,1 +556,1 @@\n-                    type.equals(that.type);\n+                    Objects.equals(type, that.type);\n@@ -499,1 +561,1 @@\n-            return Objects.hash(tag(), offset, type);\n+            return Objects.hash(super.hashCode(), offset, type);\n@@ -502,6 +564,14 @@\n-        @Override\n-        public void verifyUnbox(Deque<Class<?>> stack) {\n-            Class<?> actualType = stack.pop();\n-            SharedUtils.checkType(actualType, MemorySegment.class);\n-            Class<?> newType = type;\n-            stack.push(newType);\n+        public VarHandle varHandle() {\n+            return MemoryHandles.insertCoordinates(MemoryHandles.varHandle(type, ByteOrder.nativeOrder()), 1, offset);\n+        }\n+    }\n+\n+    \/**\n+     * BUFFER_STORE([offset into memory region], [type])\n+     * Pops a MemorySegment from the operand stack, loads a [type] from\n+     * [offset into memory region] from it, and pushes it onto the operand stack.\n+     * The [type] must be one of byte, short, char, int, long, float, or double\n+     *\/\n+    public static class BufferStore extends Dereference {\n+        private BufferStore(long offset, Class<?> type) {\n+            super(Tag.BUFFER_STORE, offset, type);\n@@ -511,1 +581,1 @@\n-        public void verifyBox(Deque<Class<?>> stack) {\n+        public void verify(Deque<Class<?>> stack) {\n@@ -513,1 +583,1 @@\n-            SharedUtils.checkType(storeType, type);\n+            SharedUtils.checkType(storeType, type());\n@@ -519,1 +589,3 @@\n-        public void unbox(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {\n+        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n+                              BindingInterpreter.LoadFunc loadFunc, SharedUtils.Allocator allocator) {\n+            Object value = stack.pop();\n@@ -521,2 +593,2 @@\n-            MemorySegment readAddress = operand.asSlice(offset);\n-            stack.push(SharedUtils.read(readAddress, type));\n+            MemorySegment writeAddress = operand.asSlice(offset());\n+            SharedUtils.write(writeAddress, type(), value);\n@@ -526,5 +598,4 @@\n-        public void box(Deque<Object> stack, BindingInterpreter.LoadFunc loadFunc) {\n-            Object value = stack.pop();\n-            MemorySegment operand = (MemorySegment) stack.pop();\n-            MemorySegment writeAddress = operand.asSlice(offset);\n-            SharedUtils.write(writeAddress, type, value);\n+        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n+            MethodHandle setter = varHandle().toMethodHandle(VarHandle.AccessMode.SET);\n+            setter = setter.asType(methodType(void.class, MemorySegment.class, type()));\n+            return collectArguments(specializedHandle, insertPos + 1, setter);\n@@ -533,2 +604,26 @@\n-        private VarHandle varHandle() {\n-            return MemoryHandles.insertCoordinates(MemoryHandles.varHandle(type, ByteOrder.nativeOrder()), 1, offset);\n+        @Override\n+        public String toString() {\n+            return \"BufferStore{\" +\n+                    \"offset=\" + offset() +\n+                    \", type=\" + type() +\n+                    '}';\n+        }\n+    }\n+\n+    \/**\n+     * BUFFER_LOAD([offset into memory region], [type])\n+     * Pops a [type], and then a MemorySegment from the operand stack,\n+     * and then stores [type] to [offset into memory region] of the MemorySegment.\n+     * The [type] must be one of byte, short, char, int, long, float, or double\n+     *\/\n+    public static class BufferLoad extends Dereference {\n+        private BufferLoad(long offset, Class<?> type) {\n+            super(Tag.BUFFER_LOAD, offset, type);\n+        }\n+\n+        @Override\n+        public void verify(Deque<Class<?>> stack) {\n+            Class<?> actualType = stack.pop();\n+            SharedUtils.checkType(actualType, MemorySegment.class);\n+            Class<?> newType = type();\n+            stack.push(newType);\n@@ -538,1 +633,9 @@\n-        public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {\n+        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n+                              BindingInterpreter.LoadFunc loadFunc, SharedUtils.Allocator allocator) {\n+            MemorySegment operand = (MemorySegment) stack.pop();\n+            MemorySegment readAddress = operand.asSlice(offset());\n+            stack.push(SharedUtils.read(readAddress, type()));\n+        }\n+\n+        @Override\n+        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n@@ -541,1 +644,1 @@\n-                    .asType(methodType(type, MemorySegment.class));\n+                    .asType(methodType(type(), MemorySegment.class));\n@@ -546,4 +649,5 @@\n-        public MethodHandle specializeBox(MethodHandle returnFilter) {\n-            MethodHandle setter = varHandle().toMethodHandle(VarHandle.AccessMode.SET);\n-            setter = setter.asType(methodType(void.class, MemorySegment.class, type));\n-            return collectArguments(returnFilter, returnFilter.type().parameterCount(), setter);\n+        public String toString() {\n+            return \"BufferLoad{\" +\n+                    \"offset=\" + offset() +\n+                    \", type=\" + type() +\n+                    '}';\n@@ -569,0 +673,7 @@\n+        private static MemorySegment copyBuffer(MemorySegment operand, long size, long alignment,\n+                                                    SharedUtils.Allocator allocator) {\n+            MemorySegment copy = allocator.allocate(size, alignment);\n+            copy.copyFrom(operand.asSlice(0, size));\n+            return copy;\n+        }\n+\n@@ -587,15 +698,1 @@\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (o == null || getClass() != o.getClass()) return false;\n-            Copy copy = (Copy) o;\n-            return size == copy.size &&\n-                    alignment == copy.alignment;\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return Objects.hash(tag(), size, alignment);\n-        }\n-\n-        @Override\n-        public void verifyUnbox(Deque<Class<?>> stack) {\n+        public void verify(Deque<Class<?>> stack) {\n@@ -608,8 +705,2 @@\n-        public void verifyBox(Deque<Class<?>> stack) {\n-            Class<?> actualType = stack.pop();\n-            SharedUtils.checkType(actualType, MemoryAddress.class);\n-            stack.push(MemorySegment.class);\n-        }\n-\n-        @Override\n-        public void unbox(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {\n+        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n+                              BindingInterpreter.LoadFunc loadFunc, SharedUtils.Allocator allocator) {\n@@ -617,2 +708,1 @@\n-            MemorySegment copy = scope.allocate(size, alignment);\n-            copy.copyFrom(operand.asSlice(0, size));\n+            MemorySegment copy = copyBuffer(operand, size, alignment, allocator);\n@@ -623,6 +713,4 @@\n-        public void box(Deque<Object> stack, BindingInterpreter.LoadFunc loadFunc) {\n-            MemoryAddress operand = (MemoryAddress) stack.pop();\n-            MemorySegment segment = MemoryAddressImpl.ofLongUnchecked(operand.toRawLongValue(), size);\n-            MemorySegment copy = MemorySegment.allocateNative(size, alignment);\n-            copy.copyFrom(segment);\n-            stack.push(copy); \/\/ leaked\n+        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n+            MethodHandle filter = insertArguments(MH_COPY_BUFFER, 1, size, alignment);\n+            specializedHandle = collectArguments(specializedHandle, insertPos, filter);\n+            return mergeArguments(specializedHandle, allocatorPos, insertPos + 1);\n@@ -632,4 +720,7 @@\n-        public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {\n-            MethodHandle filter = insertArguments(MH_COPY_BUFFER, 1, size, alignment);\n-            specializedHandle = collectArguments(specializedHandle, insertPos, filter);\n-            return mergeArguments(specializedHandle, 0, insertPos + 1);\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            if (!super.equals(o)) return false;\n+            Copy copy = (Copy) o;\n+            return size == copy.size &&\n+                    alignment == copy.alignment;\n@@ -639,2 +730,2 @@\n-        public MethodHandle specializeBox(MethodHandle returnFilter) {\n-            throw new UnsupportedOperationException();\n+        public int hashCode() {\n+            return Objects.hash(super.hashCode(), size, alignment);\n@@ -658,0 +749,4 @@\n+        private static MemorySegment allocateBuffer(long size, long allignment, SharedUtils.Allocator allocator) {\n+            return allocator.allocate(size, allignment);\n+        }\n+\n@@ -676,20 +771,1 @@\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (o == null || getClass() != o.getClass()) return false;\n-            Allocate that = (Allocate) o;\n-            return size == that.size &&\n-                    alignment == that.alignment;\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return Objects.hash(tag(), size, alignment);\n-        }\n-\n-        @Override\n-        public void verifyUnbox(Deque<Class<?>> stack) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        @Override\n-        public void verifyBox(Deque<Class<?>> stack) {\n+        public void verify(Deque<Class<?>> stack) {\n@@ -700,2 +776,3 @@\n-        public void unbox(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {\n-            throw new UnsupportedOperationException();\n+        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n+                              BindingInterpreter.LoadFunc loadFunc, SharedUtils.Allocator allocator) {\n+            stack.push(allocateBuffer(size, alignment, allocator));\n@@ -705,2 +782,4 @@\n-        public void box(Deque<Object> stack, BindingInterpreter.LoadFunc loadFunc) {\n-            stack.push(MemorySegment.allocateNative(size, alignment));\n+        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n+            MethodHandle allocateBuffer = insertArguments(MH_ALLOCATE_BUFFER, 0, size, alignment);\n+            specializedHandle = collectArguments(specializedHandle, insertPos, allocateBuffer);\n+            return mergeArguments(specializedHandle, allocatorPos, insertPos);\n@@ -710,2 +789,7 @@\n-        public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {\n-            throw new UnsupportedOperationException();\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            if (!super.equals(o)) return false;\n+            Allocate allocate = (Allocate) o;\n+            return size == allocate.size &&\n+                    alignment == allocate.alignment;\n@@ -715,2 +799,2 @@\n-        public MethodHandle specializeBox(MethodHandle returnFilter) {\n-            return collectArguments(returnFilter, 0, insertArguments(MH_ALLOCATE_BUFFER, 0, size, alignment));\n+        public int hashCode() {\n+            return Objects.hash(super.hashCode(), size, alignment);\n@@ -721,5 +805,3 @@\n-     * CONVERT_ADDRESS()\n-     *   When unboxing: pops a 'MemoryAddress' from the operand stack, converts it to a 'long',\n-     *     and pushes that onto the operand stack\n-     *   When boxing: pops a 'long' from the operand stack, converts it to a 'MemoryAddress',\n-     *     and pushes that onto the operand stack\n+     * UNBOX_ADDRESS()\n+     * Pops a 'MemoryAddress' from the operand stack, converts it to a 'long',\n+     *     and pushes that onto the operand stack.\n@@ -727,4 +809,4 @@\n-    public static class ConvertAddress extends Binding {\n-        private static final ConvertAddress INSTANCE = new ConvertAddress();\n-        private ConvertAddress() {\n-            super(Tag.CONVERT_ADDRESS);\n+    public static class UnboxAddress extends Binding {\n+        private static final UnboxAddress INSTANCE = new UnboxAddress();\n+        private UnboxAddress() {\n+            super(Tag.UNBOX_ADDRESS);\n@@ -734,4 +816,4 @@\n-        public String toString() {\n-            return \"BoxAddress{\" +\n-                    \"tag=\" + tag() +\n-                    \"}\";\n+        public void verify(Deque<Class<?>> stack) {\n+            Class<?> actualType = stack.pop();\n+            SharedUtils.checkType(actualType, MemoryAddress.class);\n+            stack.push(long.class);\n@@ -741,2 +823,3 @@\n-        public int hashCode() {\n-            return tag().hashCode();\n+        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n+                              BindingInterpreter.LoadFunc loadFunc, SharedUtils.Allocator allocator) {\n+            stack.push(((MemoryAddress)stack.pop()).toRawLongValue());\n@@ -746,3 +829,2 @@\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            return o != null && getClass() == o.getClass();\n+        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n+            return filterArguments(specializedHandle, insertPos, MH_UNBOX_ADDRESS);\n@@ -752,4 +834,14 @@\n-        public void verifyUnbox(Deque<Class<?>> stack) {\n-            Class<?> actualType = stack.pop();\n-            SharedUtils.checkType(actualType, MemoryAddress.class);\n-            stack.push(long.class);\n+        public String toString() {\n+            return \"UnboxAddress{}\";\n+        }\n+    }\n+\n+    \/**\n+     * Box_ADDRESS()\n+     * Pops a 'long' from the operand stack, converts it to a 'MemoryAddress',\n+     *     and pushes that onto the operand stack.\n+     *\/\n+    public static class BoxAddress extends Binding {\n+        private static final BoxAddress INSTANCE = new BoxAddress();\n+        private BoxAddress() {\n+            super(Tag.BOX_ADDRESS);\n@@ -759,1 +851,1 @@\n-        public void verifyBox(Deque<Class<?>> stack) {\n+        public void verify(Deque<Class<?>> stack) {\n@@ -766,6 +858,2 @@\n-        public void unbox(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {\n-            stack.push(((MemoryAddress)stack.pop()).toRawLongValue());\n-        }\n-\n-        @Override\n-        public void box(Deque<Object> stack, BindingInterpreter.LoadFunc loadFunc) {\n+        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n+                              BindingInterpreter.LoadFunc loadFunc, SharedUtils.Allocator allocator) {\n@@ -776,2 +864,2 @@\n-        public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {\n-            return filterArguments(specializedHandle, insertPos, MH_UNBOX_ADDRESS);\n+        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n+            return filterArguments(specializedHandle, insertPos, MH_BOX_ADDRESS);\n@@ -781,2 +869,2 @@\n-        public MethodHandle specializeBox(MethodHandle returnFilter) {\n-            return filterArguments(returnFilter, 0, MH_BOX_ADDRESS);\n+        public String toString() {\n+            return \"BoxAddress{}\";\n@@ -798,4 +886,4 @@\n-        public String toString() {\n-            return \"BaseAddress{\" +\n-                    \"tag=\" + tag() +\n-                    \"}\";\n+        public void verify(Deque<Class<?>> stack) {\n+            Class<?> actualType = stack.pop();\n+            SharedUtils.checkType(actualType, MemorySegment.class);\n+            stack.push(MemoryAddress.class);\n@@ -805,2 +893,3 @@\n-        public int hashCode() {\n-            return tag().hashCode();\n+        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n+                              BindingInterpreter.LoadFunc loadFunc, SharedUtils.Allocator allocator) {\n+            stack.push(((MemorySegment) stack.pop()).address());\n@@ -810,3 +899,2 @@\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            return o != null && getClass() == o.getClass();\n+        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n+            return filterArguments(specializedHandle, insertPos, MH_BASE_ADDRESS);\n@@ -816,4 +904,22 @@\n-        public void verifyUnbox(Deque<Class<?>> stack) {\n-            Class<?> actualType = stack.pop();\n-            SharedUtils.checkType(actualType, MemorySegment.class);\n-            stack.push(MemoryAddress.class);\n+        public String toString() {\n+            return \"BaseAddress{}\";\n+        }\n+    }\n+\n+    \/**\n+     * BASE_ADDRESS([size])\n+     *   Pops a MemoryAddress from the operand stack, and takes the converts it to a MemorySegment\n+     *   with the given size, and pushes that onto the operand stack\n+     *\/\n+    public static class ToSegment extends Binding {\n+        private final long size;\n+        \/\/ FIXME alignment?\n+\n+        public ToSegment(long size) {\n+            super(Tag.TO_SEGMENT);\n+            this.size = size;\n+        }\n+\n+        \/\/ FIXME should register with scope\n+        private static MemorySegment toSegment(MemoryAddress operand, long size) {\n+            return MemoryAddressImpl.ofLongUnchecked(operand.toRawLongValue(), size);\n@@ -823,1 +929,1 @@\n-        public void verifyBox(Deque<Class<?>> stack) {\n+        public void verify(Deque<Class<?>> stack) {\n@@ -825,2 +931,2 @@\n-            SharedUtils.checkType(actualType, MemorySegment.class);\n-            stack.push(MemoryAddress.class);\n+            SharedUtils.checkType(actualType, MemoryAddress.class);\n+            stack.push(MemorySegment.class);\n@@ -830,2 +936,5 @@\n-        public void unbox(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {\n-            stack.push(((MemorySegment) stack.pop()).address());\n+        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n+                              BindingInterpreter.LoadFunc loadFunc, SharedUtils.Allocator allocator) {\n+            MemoryAddress operand = (MemoryAddress) stack.pop();\n+            MemorySegment segment = toSegment(operand, size);\n+            stack.push(segment);\n@@ -835,2 +944,3 @@\n-        public void box(Deque<Object> stack, BindingInterpreter.LoadFunc loadFunc) {\n-            stack.push(((MemorySegment) stack.pop()).address());\n+        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n+            MethodHandle toSegmentHandle = insertArguments(MH_TO_SEGMENT, 1, size);\n+            return filterArguments(specializedHandle, insertPos, toSegmentHandle);\n@@ -840,2 +950,4 @@\n-        public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {\n-            return filterArguments(specializedHandle, insertPos, MH_BASE_ADDRESS);\n+        public String toString() {\n+            return \"ToSegemnt{\" +\n+                    \"size=\" + size +\n+                    '}';\n@@ -845,2 +957,11 @@\n-        public MethodHandle specializeBox(MethodHandle returnFilter) {\n-            throw new UnsupportedOperationException();\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            if (!super.equals(o)) return false;\n+            ToSegment toSegemnt = (ToSegment) o;\n+            return size == toSegemnt.size;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(super.hashCode(), size);\n@@ -862,24 +983,1 @@\n-        public String toString() {\n-            return \"Dup{\" +\n-                    \"tag=\" + tag() +\n-                    \"}\";\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return tag().hashCode();\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            return o != null && getClass() == o.getClass();\n-        }\n-\n-        @Override\n-        public void verifyUnbox(Deque<Class<?>> stack) {\n-            stack.push(stack.peekLast());\n-        }\n-\n-        @Override\n-        public void verifyBox(Deque<Class<?>> stack) {\n+        public void verify(Deque<Class<?>> stack) {\n@@ -890,6 +988,2 @@\n-        public void unbox(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {\n-            stack.push(stack.peekLast());\n-        }\n-\n-        @Override\n-        public void box(Deque<Object> stack, BindingInterpreter.LoadFunc loadFunc) {\n+        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n+                              BindingInterpreter.LoadFunc loadFunc, SharedUtils.Allocator allocator) {\n@@ -903,4 +997,4 @@\n-         * 2. DEREFERENCE(0, int.class)\n-         * 3. MOVE  (ignored)\n-         * 4. DEREFERENCE(4, int.class)\n-         * 5. MOVE  (ignored)\n+         * 2. BUFFER_LOAD(0, int.class)\n+         * 3. VM_STORE  (ignored)\n+         * 4. BUFFER_LOAD(4, int.class)\n+         * 5. VM_STORE  (ignored)\n@@ -918,1 +1012,1 @@\n-        public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {\n+        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n@@ -922,17 +1016,0 @@\n-        \/*\n-         * Fixes up Y-shaped data graphs (produced by DEREFERENCE):\n-         *\n-         * 1. ALLOCATE_BUFFER(4, 4)\n-         * 2. DUP\n-         * 3. MOVE  (ignored)\n-         * 4. DEREFERNCE(0, int.class)\n-         *\n-         * (specialized in reverse!)\n-         *\n-         * input: (MemorySegment) -> MemorySegment (identity function of high-level return)\n-         * 4. (MemorySegment, MemorySegment, int) -> MemorySegment\n-         * 3. (MemorySegment, MemorySegment, int) -> MemorySegment\n-         * 2. (MemorySegment, int) -> MemorySegment\n-         * 1. (int) -> MemorySegment\n-         *\n-         *\/\n@@ -940,3 +1017,8 @@\n-        public MethodHandle specializeBox(MethodHandle returnFilter) {\n-            \/\/ assumes shape like: (MS, ..., MS, T) R\n-            return mergeArguments(returnFilter, 0, returnFilter.type().parameterCount() - 2);\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            return o != null && getClass() == o.getClass();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Dup{}\";\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":391,"deletions":309,"binary":false,"changes":700,"status":"modified"},{"patch":"@@ -25,2 +25,0 @@\n-import jdk.incubator.foreign.NativeScope;\n-\n@@ -33,1 +31,1 @@\n-    static void unbox(Object arg, List<Binding> bindings, StoreFunc storeFunc, NativeScope scope) {\n+    static void unbox(Object arg, List<Binding> bindings, StoreFunc storeFunc, SharedUtils.Allocator allocator) {\n@@ -35,0 +33,1 @@\n+\n@@ -37,1 +36,1 @@\n-            b.unbox(stack, storeFunc, scope);\n+            b.interpret(stack, storeFunc, null, allocator);\n@@ -41,1 +40,1 @@\n-    static Object box(List<Binding> bindings, LoadFunc loadFunc) {\n+    static Object box(List<Binding> bindings, LoadFunc loadFunc, SharedUtils.Allocator allocator) {\n@@ -44,1 +43,1 @@\n-            b.box(stack, loadFunc);\n+            b.interpret(stack, null, loadFunc, allocator);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingInterpreter.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -49,5 +49,2 @@\n-    public Stream<Binding.Move> argMoveBindings() {\n-        return argumentBindings.stream()\n-                .flatMap(List::stream)\n-                .filter(Binding.Move.class::isInstance)\n-                .map(Binding.Move.class::cast);\n+    public Stream<Binding> argBindings() {\n+        return argumentBindings.stream().flatMap(List::stream);\n@@ -56,5 +53,2 @@\n-    public Stream<Binding.Move> retMoveBindings() {\n-        return returnBindings()\n-            .stream()\n-            .filter(Binding.Move.class::isInstance)\n-            .map(Binding.Move.class::cast);\n+    public Stream<Binding> retBindings() {\n+        return returnBindings().stream();\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequence.java","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.EnumSet;\n@@ -34,0 +35,3 @@\n+import java.util.Set;\n+\n+import static jdk.internal.foreign.abi.Binding.Tag.*;\n@@ -88,0 +92,14 @@\n+    private static final Set<Binding.Tag> unboxTags = EnumSet.of(\n+        VM_STORE,\n+        \/\/VM_LOAD,\n+        \/\/BUFFER_STORE,\n+        BUFFER_LOAD,\n+        COPY_BUFFER,\n+        \/\/ALLOC_BUFFER,\n+        \/\/BOX_ADDRESS,\n+        UNBOX_ADDRESS,\n+        BASE_ADDRESS,\n+        \/\/TO_SEGMENT,\n+        DUP\n+    );\n+\n@@ -93,1 +111,3 @@\n-            b.verifyUnbox(stack);\n+            if (!unboxTags.contains(b.tag()))\n+                throw new IllegalArgumentException(\"Unexpected operator: \" + b);\n+            b.verify(stack);\n@@ -101,1 +121,15 @@\n-    private static void verifyBoxBindings(Class<?> expectedReturnType, List<Binding> bindings) {\n+    private static final Set<Binding.Tag> boxTags = EnumSet.of(\n+        \/\/VM_STORE,\n+        VM_LOAD,\n+        BUFFER_STORE,\n+        \/\/BUFFER_LOAD,\n+        COPY_BUFFER,\n+        ALLOC_BUFFER,\n+        BOX_ADDRESS,\n+        \/\/UNBOX_ADDRESS,\n+        \/\/BASE_ADDRESS,\n+        TO_SEGMENT,\n+        DUP\n+    );\n+\n+    private static void verifyBoxBindings(Class<?> expectedOutType, List<Binding> bindings) {\n@@ -105,1 +139,3 @@\n-            b.verifyBox(stack);\n+            if (!boxTags.contains(b.tag()))\n+                throw new IllegalArgumentException(\"Unexpected operator: \" + b);\n+            b.verify(stack);\n@@ -112,2 +148,2 @@\n-        Class<?> actualReturnType = stack.pop();\n-        SharedUtils.checkType(actualReturnType, expectedReturnType);\n+        Class<?> actualOutType = stack.pop();\n+        SharedUtils.checkType(actualOutType, expectedOutType);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequenceBuilder.java","additions":41,"deletions":5,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryHandles;\n@@ -33,1 +31,0 @@\n-import jdk.internal.foreign.MemoryAddressImpl;\n@@ -43,1 +40,0 @@\n-import java.nio.ByteOrder;\n@@ -50,0 +46,1 @@\n+import java.util.stream.Stream;\n@@ -54,0 +51,1 @@\n+import static java.lang.invoke.MethodHandles.filterArguments;\n@@ -58,0 +56,2 @@\n+import static jdk.internal.foreign.abi.SharedUtils.Allocator.THROWING_ALLOCATOR;\n+import static jdk.internal.foreign.abi.SharedUtils.DEFAULT_ALLOCATOR;\n@@ -80,2 +80,3 @@\n-    private static final MethodHandle MH_MAKE_ALLOCATOR;\n-    private static final MethodHandle MH_CLOSE_ALLOCATOR;\n+    private static final MethodHandle MH_MAKE_SCOPE;\n+    private static final MethodHandle MH_CLOSE_SCOPE;\n+    private static final MethodHandle MH_WRAP_SCOPE;\n@@ -89,1 +90,1 @@\n-                    methodType(Object.class, Object[].class, Binding.Move[].class, Binding.Move[].class));\n+                    methodType(Object.class, Object[].class, Binding.VMStore[].class, Binding.VMLoad[].class));\n@@ -92,1 +93,1 @@\n-            MH_MAKE_ALLOCATOR = lookup.findStatic(NativeScope.class, \"boundedScope\",\n+            MH_MAKE_SCOPE = lookup.findStatic(NativeScope.class, \"boundedScope\",\n@@ -94,1 +95,1 @@\n-            MH_CLOSE_ALLOCATOR = lookup.findVirtual(NativeScope.class, \"close\",\n+            MH_CLOSE_SCOPE = lookup.findVirtual(NativeScope.class, \"close\",\n@@ -96,0 +97,2 @@\n+            MH_WRAP_SCOPE = lookup.findStatic(SharedUtils.Allocator.class, \"ofScope\",\n+                    methodType(SharedUtils.Allocator.class, NativeScope.class));\n@@ -120,2 +123,2 @@\n-        this.stackArgsBytes = callingSequence.argMoveBindings()\n-                .map(Binding.Move::storage)\n+        this.stackArgsBytes = argMoveBindingsStream(callingSequence)\n+                .map(Binding.VMStore::storage)\n@@ -147,2 +150,2 @@\n-        Binding.Move[] argMoves = callingSequence.argMoveBindings().toArray(Binding.Move[]::new);\n-        Class<?>[] argMoveTypes = Arrays.stream(argMoves).map(Binding.Move::type).toArray(Class<?>[]::new);\n+        Binding.VMStore[] argMoves = argMoveBindingsStream(callingSequence).toArray(Binding.VMStore[]::new);\n+        Class<?>[] argMoveTypes = Arrays.stream(argMoves).map(Binding.VMStore::type).toArray(Class<?>[]::new);\n@@ -150,1 +153,1 @@\n-        Binding.Move[] retMoves = callingSequence.retMoveBindings().toArray(Binding.Move[]::new);\n+        Binding.VMLoad[] retMoves = retMoveBindings(callingSequence);\n@@ -193,0 +196,14 @@\n+    private Stream<Binding.VMStore> argMoveBindingsStream(CallingSequence callingSequence) {\n+        return callingSequence.argBindings()\n+                .filter(Binding.VMStore.class::isInstance)\n+                .map(Binding.VMStore.class::cast);\n+    }\n+\n+    private Binding.VMLoad[] retMoveBindings(CallingSequence callingSequence) {\n+        return callingSequence.retBindings()\n+                .filter(Binding.VMLoad.class::isInstance)\n+                .map(Binding.VMLoad.class::cast)\n+                .toArray(Binding.VMLoad[]::new);\n+    }\n+\n+\n@@ -203,1 +220,2 @@\n-        int insertPos = -1;\n+        int argInsertPos = -1;\n+        int argAllocatorPos = -1;\n@@ -205,2 +223,3 @@\n-            specializedHandle = dropArguments(specializedHandle, 0, NativeScope.class);\n-            insertPos++;\n+            argAllocatorPos = 0;\n+            specializedHandle = dropArguments(specializedHandle, argAllocatorPos, SharedUtils.Allocator.class);\n+            argInsertPos++;\n@@ -210,1 +229,1 @@\n-            insertPos += bindings.stream().filter(Binding.Move.class::isInstance).count() + 1;\n+            argInsertPos += bindings.stream().filter(Binding.VMStore.class::isInstance).count() + 1;\n@@ -214,2 +233,2 @@\n-                if (binding.tag() == Binding.Tag.MOVE) {\n-                    insertPos--;\n+                if (binding.tag() == Binding.Tag.VM_STORE) {\n+                    argInsertPos--;\n@@ -217,1 +236,1 @@\n-                    specializedHandle = binding.specializeUnbox(specializedHandle, insertPos);\n+                    specializedHandle = binding.specialize(specializedHandle, argInsertPos, argAllocatorPos);\n@@ -224,0 +243,3 @@\n+            int retAllocatorPos = 0;\n+            int retInsertPos = 1;\n+            returnFilter = dropArguments(returnFilter, retAllocatorPos, SharedUtils.Allocator.class);\n@@ -227,1 +249,1 @@\n-                returnFilter = binding.specializeBox(returnFilter);\n+                returnFilter = binding.specialize(returnFilter, retInsertPos, retAllocatorPos);\n@@ -229,0 +251,1 @@\n+            returnFilter = insertArguments(returnFilter, retAllocatorPos, DEFAULT_ALLOCATOR);\n@@ -236,1 +259,1 @@\n-                ? collectArguments(empty(methodType(void.class, Throwable.class)), 1, MH_CLOSE_ALLOCATOR)\n+                ? collectArguments(empty(methodType(void.class, Throwable.class)), 1, MH_CLOSE_SCOPE)\n@@ -239,1 +262,3 @@\n-                                   2, MH_CLOSE_ALLOCATOR);\n+                                   2, MH_CLOSE_SCOPE);\n+            \/\/ Handle takes a SharedUtils.Allocator, so need to wrap our NativeScope\n+            specializedHandle = filterArguments(specializedHandle, argAllocatorPos, MH_WRAP_SCOPE);\n@@ -241,1 +266,2 @@\n-            specializedHandle = collectArguments(specializedHandle, 0, insertArguments(MH_MAKE_ALLOCATOR, 0, bufferCopySize));\n+            MethodHandle makeScopeHandle = insertArguments(MH_MAKE_SCOPE, 0, bufferCopySize);\n+            specializedHandle = collectArguments(specializedHandle, argAllocatorPos, makeScopeHandle);\n@@ -246,9 +272,1 @@\n-    private static long toRawLongValue(MemoryAddress address) {\n-        return address.toRawLongValue(); \/\/ Workaround for JDK-8239083\n-    }\n-\n-    private static MemoryAddress ofLong(long address) {\n-        return MemoryAddress.ofLong(address); \/\/ Workaround for JDK-8239083\n-    }\n-\n-    private Map<VMStorage, Integer> indexMap(Binding.Move[] moves) {\n+    private static Map<VMStorage, Integer> indexMap(Binding.Move[] moves) {\n@@ -269,1 +287,1 @@\n-    Object invokeMoves(Object[] args, Binding.Move[] argBindings, Binding.Move[] returnBindings) {\n+    Object invokeMoves(Object[] args, Binding.VMStore[] argBindings, Binding.VMLoad[] returnBindings) {\n@@ -281,1 +299,1 @@\n-                Binding.Move binding = argBindings[i];\n+                Binding.VMStore binding = argBindings[i];\n@@ -304,1 +322,1 @@\n-                Binding.Move move = returnBindings[0];\n+                Binding.VMLoad move = returnBindings[0];\n@@ -310,1 +328,1 @@\n-                    Binding.Move move = returnBindings[i];\n+                    Binding.VMLoad move = returnBindings[i];\n@@ -326,2 +344,4 @@\n-        NativeScope scope = bufferCopySize != 0 ? NativeScope.boundedScope(bufferCopySize) : null;\n-        try {\n+        SharedUtils.Allocator unboxAllocator = bufferCopySize != 0\n+                ? SharedUtils.Allocator.ofScope(NativeScope.boundedScope(bufferCopySize))\n+                : THROWING_ALLOCATOR;\n+        try (unboxAllocator) {\n@@ -335,1 +355,1 @@\n-                        }, scope);\n+                        }, unboxAllocator);\n@@ -347,1 +367,1 @@\n-                        (storage, type) -> oArr[retIndexMap.get(storage)]);\n+                        (storage, type) -> oArr[retIndexMap.get(storage)], DEFAULT_ALLOCATOR);\n@@ -349,5 +369,2 @@\n-                return BindingInterpreter.box(callingSequence.returnBindings(), (storage, type) -> o);\n-            }\n-        } finally {\n-            if (scope != null) {\n-                scope.close();\n+                return BindingInterpreter.box(callingSequence.returnBindings(), (storage, type) -> o,\n+                        DEFAULT_ALLOCATOR);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableInvoker.java","additions":64,"deletions":47,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import static jdk.internal.foreign.abi.SharedUtils.DEFAULT_ALLOCATOR;\n@@ -101,1 +102,1 @@\n-                        });\n+                        }, DEFAULT_ALLOCATOR);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -68,0 +68,2 @@\n+    static final Allocator DEFAULT_ALLOCATOR = MemorySegment::allocateNative;\n+\n@@ -366,1 +368,3 @@\n-    public interface Allocator {\n+    public interface Allocator extends AutoCloseable {\n+        Allocator THROWING_ALLOCATOR = (size, align) -> { throw new UnsupportedOperationException(\"Null allocator\"); };\n+\n@@ -375,0 +379,3 @@\n+        @Override\n+        default void close() {}\n+\n@@ -378,1 +385,11 @@\n-            return scope::allocate;\n+            return new Allocator() {\n+                @Override\n+                public MemorySegment allocate(long size, long align) {\n+                    return scope.allocate(size, align);\n+                }\n+\n+                @Override\n+                public void close() {\n+                    scope.close();\n+                }\n+            };\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -234,2 +234,2 @@\n-                bindings.dereference(offset, type)\n-                        .move(storage, type);\n+                bindings.bufferLoad(offset, type)\n+                        .vmStore(storage, type);\n@@ -253,2 +253,2 @@\n-                        .move(storage, type)\n-                        .dereference(offset, type);\n+                        .vmLoad(storage, type)\n+                        .bufferStore(offset, type);\n@@ -272,2 +272,2 @@\n-                .convertAddress()\n-                .move(INDIRECT_RESULT, long.class)\n+                .unboxAddress()\n+                .vmStore(INDIRECT_RESULT, long.class)\n@@ -296,2 +296,2 @@\n-                            bindings.dereference(offset, type)\n-                                    .move(storage, type);\n+                            bindings.bufferLoad(offset, type)\n+                                    .vmStore(storage, type);\n@@ -309,1 +309,1 @@\n-                            .convertAddress();\n+                            .unboxAddress();\n@@ -312,1 +312,1 @@\n-                    bindings.move(storage, long.class);\n+                    bindings.vmStore(storage, long.class);\n@@ -329,2 +329,2 @@\n-                            bindings.dereference(offset, type)\n-                                    .move(storage, type);\n+                            bindings.bufferLoad(offset, type)\n+                                    .vmStore(storage, type);\n@@ -339,1 +339,1 @@\n-                    bindings.convertAddress();\n+                    bindings.unboxAddress();\n@@ -342,1 +342,1 @@\n-                    bindings.move(storage, long.class);\n+                    bindings.vmStore(storage, long.class);\n@@ -348,1 +348,1 @@\n-                    bindings.move(storage, carrier);\n+                    bindings.vmStore(storage, carrier);\n@@ -354,1 +354,1 @@\n-                    bindings.move(storage, carrier);\n+                    bindings.vmStore(storage, carrier);\n@@ -372,2 +372,2 @@\n-                .move(INDIRECT_RESULT, long.class)\n-                .convertAddress()\n+                .vmLoad(INDIRECT_RESULT, long.class)\n+                .boxAddress()\n@@ -395,2 +395,2 @@\n-                            bindings.move(storage, type)\n-                                    .dereference(offset, type);\n+                            bindings.vmLoad(storage, type)\n+                                    .bufferStore(offset, type);\n@@ -407,2 +407,3 @@\n-                    bindings.move(storage, long.class)\n-                            .convertAddress();\n+                    bindings.vmLoad(storage, long.class)\n+                            .boxAddress()\n+                            .toSegment(layout);\n@@ -427,2 +428,2 @@\n-                                    .move(storage, type)\n-                                    .dereference(offset, type);\n+                                    .vmLoad(storage, type)\n+                                    .bufferStore(offset, type);\n@@ -439,2 +440,2 @@\n-                    bindings.move(storage, long.class)\n-                            .convertAddress();\n+                    bindings.vmLoad(storage, long.class)\n+                            .boxAddress();\n@@ -446,1 +447,1 @@\n-                    bindings.move(storage, carrier);\n+                    bindings.vmLoad(storage, carrier);\n@@ -452,1 +453,1 @@\n-                    bindings.move(storage, carrier);\n+                    bindings.vmLoad(storage, carrier);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":29,"deletions":28,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-                    List.of(move(rax, long.class)));\n+                    List.of(vmStore(rax, long.class)));\n@@ -277,2 +277,2 @@\n-                        bindings.dereference(offset, type)\n-                                .move(storage, type);\n+                        bindings.bufferLoad(offset, type)\n+                                .vmStore(storage, type);\n@@ -284,1 +284,1 @@\n-                    bindings.convertAddress();\n+                    bindings.unboxAddress();\n@@ -286,1 +286,1 @@\n-                    bindings.move(storage, long.class);\n+                    bindings.vmStore(storage, long.class);\n@@ -291,1 +291,1 @@\n-                    bindings.move(storage, carrier);\n+                    bindings.vmStore(storage, carrier);\n@@ -296,1 +296,1 @@\n-                    bindings.move(storage, carrier);\n+                    bindings.vmStore(storage, carrier);\n@@ -328,2 +328,2 @@\n-                        bindings.move(storage, type)\n-                                .dereference(offset, type);\n+                        bindings.vmLoad(storage, type)\n+                                .bufferStore(offset, type);\n@@ -336,2 +336,2 @@\n-                    bindings.move(storage, long.class)\n-                            .convertAddress();\n+                    bindings.vmLoad(storage, long.class)\n+                            .boxAddress();\n@@ -342,1 +342,1 @@\n-                    bindings.move(storage, carrier);\n+                    bindings.vmLoad(storage, carrier);\n@@ -347,1 +347,1 @@\n-                    bindings.move(storage, carrier);\n+                    bindings.vmLoad(storage, carrier);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -207,2 +207,2 @@\n-                    bindings.dereference(0, type)\n-                            .move(storage, type);\n+                    bindings.bufferLoad(0, type)\n+                            .vmStore(storage, type);\n@@ -215,1 +215,1 @@\n-                            .convertAddress();\n+                            .unboxAddress();\n@@ -217,1 +217,1 @@\n-                    bindings.move(storage, long.class);\n+                    bindings.vmStore(storage, long.class);\n@@ -221,1 +221,1 @@\n-                    bindings.convertAddress();\n+                    bindings.unboxAddress();\n@@ -223,1 +223,1 @@\n-                    bindings.move(storage, long.class);\n+                    bindings.vmStore(storage, long.class);\n@@ -228,1 +228,1 @@\n-                    bindings.move(storage, carrier);\n+                    bindings.vmStore(storage, carrier);\n@@ -233,1 +233,1 @@\n-                    bindings.move(storage, carrier);\n+                    bindings.vmStore(storage, carrier);\n@@ -241,1 +241,1 @@\n-                                .move(extraStorage, carrier);\n+                                .vmStore(extraStorage, carrier);\n@@ -244,1 +244,1 @@\n-                    bindings.move(storage, carrier);\n+                    bindings.vmStore(storage, carrier);\n@@ -272,2 +272,2 @@\n-                    bindings.move(storage, type)\n-                            .dereference(0, type);\n+                    bindings.vmLoad(storage, type)\n+                            .bufferStore(0, type);\n@@ -279,2 +279,3 @@\n-                    bindings.move(storage, long.class)\n-                            .convertAddress();\n+                    bindings.vmLoad(storage, long.class)\n+                            .boxAddress()\n+                            .toSegment(layout);\n@@ -288,2 +289,2 @@\n-                    bindings.move(storage, long.class)\n-                            .convertAddress();\n+                    bindings.vmLoad(storage, long.class)\n+                            .boxAddress();\n@@ -294,1 +295,1 @@\n-                    bindings.move(storage, carrier);\n+                    bindings.vmLoad(storage, carrier);\n@@ -299,1 +300,1 @@\n-                    bindings.move(storage, carrier);\n+                    bindings.vmLoad(storage, carrier);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":19,"deletions":18,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-        return kind(layout).isIntergral();\n+        return kind(layout).isIntegral();\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -89,10 +89,10 @@\n-            { move(r0, int.class) },\n-            { move(r1, int.class) },\n-            { move(r2, int.class) },\n-            { move(r3, int.class) },\n-            { move(r4, int.class) },\n-            { move(r5, int.class) },\n-            { move(r6, int.class) },\n-            { move(r7, int.class) },\n-            { move(stackStorage(0), int.class) },\n-            { move(stackStorage(1), int.class) },\n+            { vmStore(r0, int.class) },\n+            { vmStore(r1, int.class) },\n+            { vmStore(r2, int.class) },\n+            { vmStore(r3, int.class) },\n+            { vmStore(r4, int.class) },\n+            { vmStore(r5, int.class) },\n+            { vmStore(r6, int.class) },\n+            { vmStore(r7, int.class) },\n+            { vmStore(stackStorage(0), int.class) },\n+            { vmStore(stackStorage(1), int.class) },\n@@ -118,4 +118,4 @@\n-            { move(r0, int.class) },\n-            { move(r1, int.class) },\n-            { move(v0, float.class) },\n-            { move(v1, float.class) },\n+            { vmStore(r0, int.class) },\n+            { vmStore(r1, int.class) },\n+            { vmStore(v0, float.class) },\n+            { vmStore(v1, float.class) },\n@@ -153,1 +153,1 @@\n-                    dereference(0, long.class), move(r0, long.class),\n+                    bufferLoad(0, long.class), vmStore(r0, long.class),\n@@ -155,1 +155,1 @@\n-                    dereference(8, long.class), move(r1, long.class),\n+                    bufferLoad(8, long.class), vmStore(r1, long.class),\n@@ -161,2 +161,2 @@\n-                convertAddress(),\n-                move(r0, long.class)\n+                unboxAddress(),\n+                vmStore(r0, long.class)\n@@ -168,1 +168,1 @@\n-                    dereference(0, long.class), move(r0, long.class),\n+                    bufferLoad(0, long.class), vmStore(r0, long.class),\n@@ -170,1 +170,1 @@\n-                    dereference(8, long.class), move(r1, long.class),\n+                    bufferLoad(8, long.class), vmStore(r1, long.class),\n@@ -177,1 +177,1 @@\n-                dereference(0, long.class), move(r0, long.class),\n+                bufferLoad(0, long.class), vmStore(r0, long.class),\n@@ -179,1 +179,1 @@\n-                dereference(8, long.class), move(r1, long.class),\n+                bufferLoad(8, long.class), vmStore(r1, long.class),\n@@ -202,2 +202,2 @@\n-                convertAddress(),\n-                move(r0, long.class)\n+                unboxAddress(),\n+                vmStore(r0, long.class)\n@@ -208,2 +208,2 @@\n-                convertAddress(),\n-                move(r1, long.class)\n+                unboxAddress(),\n+                vmStore(r1, long.class)\n@@ -211,1 +211,1 @@\n-            { move(r2, int.class) }\n+            { vmStore(r2, int.class) }\n@@ -232,2 +232,2 @@\n-                convertAddress(),\n-                move(r8, long.class)\n+                unboxAddress(),\n+                vmStore(r8, long.class)\n@@ -258,2 +258,2 @@\n-            move(r0, long.class),\n-            dereference(0, long.class),\n+            vmLoad(r0, long.class),\n+            bufferStore(0, long.class),\n@@ -261,2 +261,2 @@\n-            move(r1, long.class),\n-            dereference(8, long.class),\n+            vmLoad(r1, long.class),\n+            bufferStore(8, long.class),\n@@ -280,2 +280,2 @@\n-            { move(v0, float.class) },\n-            { move(r0, int.class) },\n+            { vmStore(v0, float.class) },\n+            { vmStore(r0, int.class) },\n@@ -284,4 +284,4 @@\n-                dereference(0, int.class),\n-                move(v1, int.class),\n-                dereference(4, int.class),\n-                move(v2, int.class)\n+                bufferLoad(0, int.class),\n+                vmStore(v1, int.class),\n+                bufferLoad(4, int.class),\n+                vmStore(v2, int.class)\n@@ -294,2 +294,2 @@\n-            move(v0, int.class),\n-            dereference(0, int.class),\n+            vmLoad(v0, int.class),\n+            bufferStore(0, int.class),\n@@ -297,2 +297,2 @@\n-            move(v1, int.class),\n-            dereference(4, int.class),\n+            vmLoad(v1, int.class),\n+            bufferStore(4, int.class),\n@@ -318,2 +318,2 @@\n-                dereference(0, int.class),\n-                move(v0, int.class),\n+                bufferLoad(0, int.class),\n+                vmStore(v0, int.class),\n@@ -321,4 +321,4 @@\n-                dereference(4, int.class),\n-                move(v1, int.class),\n-                dereference(8, int.class),\n-                move(v2, int.class)\n+                bufferLoad(4, int.class),\n+                vmStore(v1, int.class),\n+                bufferLoad(8, int.class),\n+                vmStore(v2, int.class)\n@@ -328,2 +328,2 @@\n-                dereference(0, int.class),\n-                move(v3, int.class),\n+                bufferLoad(0, int.class),\n+                vmStore(v3, int.class),\n@@ -331,4 +331,4 @@\n-                dereference(4, int.class),\n-                move(v4, int.class),\n-                dereference(8, int.class),\n-                move(v5, int.class)\n+                bufferLoad(4, int.class),\n+                vmStore(v4, int.class),\n+                bufferLoad(8, int.class),\n+                vmStore(v5, int.class)\n@@ -338,4 +338,4 @@\n-                dereference(0, long.class),\n-                move(stackStorage(0), long.class),\n-                dereference(8, int.class),\n-                move(stackStorage(1), int.class),\n+                bufferLoad(0, long.class),\n+                vmStore(stackStorage(0), long.class),\n+                bufferLoad(8, int.class),\n+                vmStore(stackStorage(1), int.class),\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestAarch64CallArranger.java","additions":59,"deletions":59,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-            { move(rax, long.class) }\n+            { vmStore(rax, long.class) }\n@@ -95,3 +95,3 @@\n-                { dup(), dereference(0, long.class), move(rdi, long.class),\n-                  dereference(8, int.class), move(rsi, int.class)},\n-                { move(rax, long.class) },\n+                { dup(), bufferLoad(0, long.class), vmStore(rdi, long.class),\n+                  bufferLoad(8, int.class), vmStore(rsi, int.class)},\n+                { vmStore(rax, long.class) },\n@@ -125,3 +125,3 @@\n-                { dup(), dereference(0, long.class), move(rdi, long.class),\n-                        dereference(8, long.class), move(rsi, long.class)},\n-                { move(rax, long.class) },\n+                { dup(), bufferLoad(0, long.class), vmStore(rdi, long.class),\n+                        bufferLoad(8, long.class), vmStore(rsi, long.class)},\n+                { vmStore(rax, long.class) },\n@@ -154,3 +154,3 @@\n-                { dup(), dereference(0, long.class), move(stackStorage(0), long.class),\n-                        dereference(8, long.class), move(stackStorage(1), long.class)},\n-                { move(rax, long.class) },\n+                { dup(), bufferLoad(0, long.class), vmStore(stackStorage(0), long.class),\n+                        bufferLoad(8, long.class), vmStore(stackStorage(1), long.class)},\n+                { vmStore(rax, long.class) },\n@@ -183,3 +183,3 @@\n-                { dup(), dereference(0, long.class), move(stackStorage(0), long.class),\n-                        dereference(8, int.class), move(stackStorage(1), int.class)},\n-                { move(rax, long.class) },\n+                { dup(), bufferLoad(0, long.class), vmStore(stackStorage(0), long.class),\n+                        bufferLoad(8, int.class), vmStore(stackStorage(1), int.class)},\n+                { vmStore(rax, long.class) },\n@@ -207,7 +207,7 @@\n-            { move(rdi, int.class) },\n-            { move(rsi, int.class) },\n-            { move(rdx, int.class) },\n-            { move(rcx, int.class) },\n-            { move(r8, int.class) },\n-            { move(r9, int.class) },\n-            { move(rax, long.class) },\n+            { vmStore(rdi, int.class) },\n+            { vmStore(rsi, int.class) },\n+            { vmStore(rdx, int.class) },\n+            { vmStore(rcx, int.class) },\n+            { vmStore(r8, int.class) },\n+            { vmStore(r9, int.class) },\n+            { vmStore(rax, long.class) },\n@@ -237,9 +237,9 @@\n-            { move(xmm0, double.class) },\n-            { move(xmm1, double.class) },\n-            { move(xmm2, double.class) },\n-            { move(xmm3, double.class) },\n-            { move(xmm4, double.class) },\n-            { move(xmm5, double.class) },\n-            { move(xmm6, double.class) },\n-            { move(xmm7, double.class) },\n-            { move(rax, long.class) },\n+            { vmStore(xmm0, double.class) },\n+            { vmStore(xmm1, double.class) },\n+            { vmStore(xmm2, double.class) },\n+            { vmStore(xmm3, double.class) },\n+            { vmStore(xmm4, double.class) },\n+            { vmStore(xmm5, double.class) },\n+            { vmStore(xmm6, double.class) },\n+            { vmStore(xmm7, double.class) },\n+            { vmStore(rax, long.class) },\n@@ -271,19 +271,19 @@\n-            { move(rdi, long.class) },\n-            { move(rsi, long.class) },\n-            { move(rdx, long.class) },\n-            { move(rcx, long.class) },\n-            { move(r8, long.class) },\n-            { move(r9, long.class) },\n-            { move(stackStorage(0), long.class) },\n-            { move(stackStorage(1), long.class) },\n-            { move(xmm0, float.class) },\n-            { move(xmm1, float.class) },\n-            { move(xmm2, float.class) },\n-            { move(xmm3, float.class) },\n-            { move(xmm4, float.class) },\n-            { move(xmm5, float.class) },\n-            { move(xmm6, float.class) },\n-            { move(xmm7, float.class) },\n-            { move(stackStorage(2), float.class) },\n-            { move(stackStorage(3), float.class) },\n-            { move(rax, long.class) },\n+            { vmStore(rdi, long.class) },\n+            { vmStore(rsi, long.class) },\n+            { vmStore(rdx, long.class) },\n+            { vmStore(rcx, long.class) },\n+            { vmStore(r8, long.class) },\n+            { vmStore(r9, long.class) },\n+            { vmStore(stackStorage(0), long.class) },\n+            { vmStore(stackStorage(1), long.class) },\n+            { vmStore(xmm0, float.class) },\n+            { vmStore(xmm1, float.class) },\n+            { vmStore(xmm2, float.class) },\n+            { vmStore(xmm3, float.class) },\n+            { vmStore(xmm4, float.class) },\n+            { vmStore(xmm5, float.class) },\n+            { vmStore(xmm6, float.class) },\n+            { vmStore(xmm7, float.class) },\n+            { vmStore(stackStorage(2), float.class) },\n+            { vmStore(stackStorage(3), float.class) },\n+            { vmStore(rax, long.class) },\n@@ -327,2 +327,2 @@\n-            { move(rdi, int.class) },\n-            { move(rsi, int.class) },\n+            { vmStore(rdi, int.class) },\n+            { vmStore(rsi, int.class) },\n@@ -331,2 +331,2 @@\n-                dereference(0, long.class), move(rdx, long.class),\n-                dereference(8, long.class), move(xmm0, long.class)\n+                bufferLoad(0, long.class), vmStore(rdx, long.class),\n+                bufferLoad(8, long.class), vmStore(xmm0, long.class)\n@@ -334,8 +334,8 @@\n-            { move(rcx, int.class) },\n-            { move(r8, int.class) },\n-            { move(xmm1, double.class) },\n-            { move(xmm2, double.class) },\n-            { move(r9, int.class) },\n-            { move(stackStorage(0), int.class) },\n-            { move(stackStorage(1), int.class) },\n-            { move(rax, long.class) },\n+            { vmStore(rcx, int.class) },\n+            { vmStore(r8, int.class) },\n+            { vmStore(xmm1, double.class) },\n+            { vmStore(xmm2, double.class) },\n+            { vmStore(r9, int.class) },\n+            { vmStore(stackStorage(0), int.class) },\n+            { vmStore(stackStorage(1), int.class) },\n+            { vmStore(rax, long.class) },\n@@ -369,2 +369,2 @@\n-            { convertAddress(), move(rdi, long.class) },\n-            { move(rax, long.class) },\n+            { unboxAddress(), vmStore(rdi, long.class) },\n+            { vmStore(rax, long.class) },\n@@ -391,1 +391,1 @@\n-            { move(rax, long.class) },\n+            { vmStore(rax, long.class) },\n@@ -404,1 +404,1 @@\n-                    dereference(0, long.class), move(rdi, long.class)\n+                    bufferLoad(0, long.class), vmStore(rdi, long.class)\n@@ -409,2 +409,2 @@\n-                    dereference(0, long.class), move(rdi, long.class),\n-                    dereference(8, long.class), move(rsi, long.class)\n+                    bufferLoad(0, long.class), vmStore(rdi, long.class),\n+                    bufferLoad(8, long.class), vmStore(rsi, long.class)\n@@ -415,1 +415,1 @@\n-                    dereference(0, long.class), move(stackStorage(0), long.class),\n+                    bufferLoad(0, long.class), vmStore(stackStorage(0), long.class),\n@@ -417,2 +417,2 @@\n-                    dereference(8, long.class), move(stackStorage(1), long.class),\n-                    dereference(16, long.class), move(stackStorage(2), long.class)\n+                    bufferLoad(8, long.class), vmStore(stackStorage(1), long.class),\n+                    bufferLoad(16, long.class), vmStore(stackStorage(2), long.class)\n@@ -423,1 +423,1 @@\n-                    dereference(0, long.class), move(stackStorage(0), long.class),\n+                    bufferLoad(0, long.class), vmStore(stackStorage(0), long.class),\n@@ -425,1 +425,1 @@\n-                    dereference(8, long.class), move(stackStorage(1), long.class),\n+                    bufferLoad(8, long.class), vmStore(stackStorage(1), long.class),\n@@ -427,2 +427,2 @@\n-                    dereference(16, long.class), move(stackStorage(2), long.class),\n-                    dereference(24, long.class), move(stackStorage(3), long.class)\n+                    bufferLoad(16, long.class), vmStore(stackStorage(2), long.class),\n+                    bufferLoad(24, long.class), vmStore(stackStorage(3), long.class)\n@@ -448,1 +448,1 @@\n-            { move(rax, long.class) }\n+            { vmStore(rax, long.class) }\n@@ -454,2 +454,2 @@\n-            move(rax, long.class),\n-            dereference(0, long.class),\n+            vmLoad(rax, long.class),\n+            bufferStore(0, long.class),\n@@ -457,2 +457,2 @@\n-            move(rdx, long.class),\n-            dereference(8, long.class)\n+            vmLoad(rdx, long.class),\n+            bufferStore(8, long.class)\n@@ -478,2 +478,2 @@\n-            { convertAddress(), move(rdi, long.class) },\n-            { move(rax, long.class) }\n+            { unboxAddress(), vmStore(rdi, long.class) },\n+            { vmStore(rax, long.class) }\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestSysVCallArranger.java","additions":80,"deletions":80,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -81,4 +81,4 @@\n-            { move(rcx, int.class) },\n-            { move(rdx, int.class) },\n-            { move(r8, int.class) },\n-            { move(r9, int.class) }\n+            { vmStore(rcx, int.class) },\n+            { vmStore(rdx, int.class) },\n+            { vmStore(r8, int.class) },\n+            { vmStore(r9, int.class) }\n@@ -102,4 +102,4 @@\n-            { move(xmm0, double.class) },\n-            { move(xmm1, double.class) },\n-            { move(xmm2, double.class) },\n-            { move(xmm3, double.class) }\n+            { vmStore(xmm0, double.class) },\n+            { vmStore(xmm1, double.class) },\n+            { vmStore(xmm2, double.class) },\n+            { vmStore(xmm3, double.class) }\n@@ -125,8 +125,8 @@\n-            { move(rcx, long.class) },\n-            { move(rdx, long.class) },\n-            { move(xmm2, float.class) },\n-            { move(xmm3, float.class) },\n-            { move(stackStorage(0), long.class) },\n-            { move(stackStorage(1), long.class) },\n-            { move(stackStorage(2), float.class) },\n-            { move(stackStorage(3), float.class) }\n+            { vmStore(rcx, long.class) },\n+            { vmStore(rdx, long.class) },\n+            { vmStore(xmm2, float.class) },\n+            { vmStore(xmm3, float.class) },\n+            { vmStore(stackStorage(0), long.class) },\n+            { vmStore(stackStorage(1), long.class) },\n+            { vmStore(stackStorage(2), float.class) },\n+            { vmStore(stackStorage(3), float.class) }\n@@ -155,2 +155,2 @@\n-            { move(rcx, int.class) },\n-            { move(rdx, int.class) },\n+            { vmStore(rcx, int.class) },\n+            { vmStore(rdx, int.class) },\n@@ -160,2 +160,2 @@\n-                convertAddress(),\n-                move(r8, long.class)\n+                unboxAddress(),\n+                vmStore(r8, long.class)\n@@ -163,8 +163,8 @@\n-            { move(r9, int.class) },\n-            { move(stackStorage(0), int.class) },\n-            { move(stackStorage(1), double.class) },\n-            { move(stackStorage(2), double.class) },\n-            { move(stackStorage(3), double.class) },\n-            { move(stackStorage(4), int.class) },\n-            { move(stackStorage(5), int.class) },\n-            { move(stackStorage(6), int.class) }\n+            { vmStore(r9, int.class) },\n+            { vmStore(stackStorage(0), int.class) },\n+            { vmStore(stackStorage(1), double.class) },\n+            { vmStore(stackStorage(2), double.class) },\n+            { vmStore(stackStorage(3), double.class) },\n+            { vmStore(stackStorage(4), int.class) },\n+            { vmStore(stackStorage(5), int.class) },\n+            { vmStore(stackStorage(6), int.class) }\n@@ -190,5 +190,5 @@\n-            { move(rcx, int.class) },\n-            { move(xmm1, double.class) },\n-            { move(r8, int.class) },\n-            { dup(), move(r9, double.class), move(xmm3, double.class) },\n-            { move(stackStorage(0), double.class) },\n+            { vmStore(rcx, int.class) },\n+            { vmStore(xmm1, double.class) },\n+            { vmStore(r8, int.class) },\n+            { dup(), vmStore(r9, double.class), vmStore(xmm3, double.class) },\n+            { vmStore(stackStorage(0), double.class) },\n@@ -223,1 +223,1 @@\n-            { dereference(0, long.class), move(rcx, long.class) }\n+            { bufferLoad(0, long.class), vmStore(rcx, long.class) }\n@@ -255,2 +255,2 @@\n-                convertAddress(),\n-                move(rcx, long.class)\n+                unboxAddress(),\n+                vmStore(rcx, long.class)\n@@ -283,1 +283,1 @@\n-            { convertAddress(), move(rcx, long.class) }\n+            { unboxAddress(), vmStore(rcx, long.class) }\n@@ -307,2 +307,2 @@\n-                move(rax, long.class),\n-                dereference(0, long.class) });\n+                vmLoad(rax, long.class),\n+                bufferStore(0, long.class) });\n@@ -325,1 +325,1 @@\n-            { convertAddress(), move(rcx, long.class) }\n+            { unboxAddress(), vmStore(rcx, long.class) }\n@@ -353,16 +353,16 @@\n-            { copy(struct), baseAddress(), convertAddress(), move(rcx, long.class) },\n-            { move(rdx, int.class) },\n-            { move(xmm2, double.class) },\n-            { convertAddress(), move(r9, long.class) },\n-            { copy(struct), baseAddress(), convertAddress(), move(stackStorage(0), long.class) },\n-            { move(stackStorage(1), int.class) },\n-            { move(stackStorage(2), double.class) },\n-            { convertAddress(), move(stackStorage(3), long.class) },\n-            { copy(struct), baseAddress(), convertAddress(), move(stackStorage(4), long.class) },\n-            { move(stackStorage(5), int.class) },\n-            { move(stackStorage(6), double.class) },\n-            { convertAddress(), move(stackStorage(7), long.class) },\n-            { copy(struct), baseAddress(), convertAddress(), move(stackStorage(8), long.class) },\n-            { move(stackStorage(9), int.class) },\n-            { move(stackStorage(10), double.class) },\n-            { convertAddress(), move(stackStorage(11), long.class) },\n+            { copy(struct), baseAddress(), unboxAddress(), vmStore(rcx, long.class) },\n+            { vmStore(rdx, int.class) },\n+            { vmStore(xmm2, double.class) },\n+            { unboxAddress(), vmStore(r9, long.class) },\n+            { copy(struct), baseAddress(), unboxAddress(), vmStore(stackStorage(0), long.class) },\n+            { vmStore(stackStorage(1), int.class) },\n+            { vmStore(stackStorage(2), double.class) },\n+            { unboxAddress(), vmStore(stackStorage(3), long.class) },\n+            { copy(struct), baseAddress(), unboxAddress(), vmStore(stackStorage(4), long.class) },\n+            { vmStore(stackStorage(5), int.class) },\n+            { vmStore(stackStorage(6), double.class) },\n+            { unboxAddress(), vmStore(stackStorage(7), long.class) },\n+            { copy(struct), baseAddress(), unboxAddress(), vmStore(stackStorage(8), long.class) },\n+            { vmStore(stackStorage(9), int.class) },\n+            { vmStore(stackStorage(10), double.class) },\n+            { unboxAddress(), vmStore(stackStorage(11), long.class) },\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestWindowsCallArranger.java","additions":56,"deletions":56,"binary":false,"changes":112,"status":"modified"}]}