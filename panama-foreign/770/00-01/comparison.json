{"files":[{"patch":"@@ -36,0 +36,1 @@\n+import java.lang.foreign.GroupLayout;\n@@ -82,2 +83,0 @@\n-        List<TypeClass> aTypes = function.argumentLayouts().stream().map(TypeClass::classify).toList();\n-        TypeClass rType = function.returnLayout().map(TypeClass::classify).orElse(TypeClass.VOID);\n@@ -90,1 +89,1 @@\n-                rType, function.argumentLayouts(), aTypes, capturedStateMask);\n+                function.argumentLayouts(), capturedStateMask);\n@@ -111,2 +110,0 @@\n-        List<TypeClass> aTypes = function.argumentLayouts().stream().map(TypeClass::classify).toList();\n-        TypeClass rType = function.returnLayout().map(TypeClass::classify).orElse(TypeClass.VOID);\n@@ -115,2 +112,2 @@\n-        UpcallData invData = new UpcallData(target, function.returnLayout().orElse(null), rType,\n-                function.argumentLayouts(), aTypes);\n+        UpcallData invData = new UpcallData(target, function.returnLayout().orElse(null),\n+                function.argumentLayouts());\n@@ -136,2 +133,1 @@\n-    private record DowncallData(MemorySegment cif, MemoryLayout returnLayout, TypeClass rType,\n-                                List<MemoryLayout> argLayouts, List<TypeClass> aTypes,\n+    private record DowncallData(MemorySegment cif, MemoryLayout returnLayout, List<MemoryLayout> argLayouts,\n@@ -164,1 +160,1 @@\n-                writeValue(invData.aTypes().get(i), arg, layout, argSeg, addr -> {\n+                writeValue(arg, layout, argSeg, addr -> {\n@@ -173,2 +169,2 @@\n-            if (invData.rType != TypeClass.VOID) {\n-                retSeg = (invData.rType() == TypeClass.SEGMENT ? returnAllocator : arena).allocate(invData.returnLayout);\n+            if (invData.returnLayout() != null) {\n+                retSeg = (invData.returnLayout() instanceof GroupLayout ? returnAllocator : arena).allocate(invData.returnLayout);\n@@ -181,1 +177,1 @@\n-            return readValue(retSeg, invData.rType(), invData.returnLayout());\n+            return readValue(retSeg, invData.returnLayout());\n@@ -189,2 +185,1 @@\n-    private record UpcallData(MethodHandle target, MemoryLayout returnLayout, TypeClass rType,\n-                              List<MemoryLayout> argLayouts, List<TypeClass> aTypes) {}\n+    private record UpcallData(MethodHandle target, MemoryLayout returnLayout, List<MemoryLayout> argLayouts) {}\n@@ -198,1 +193,1 @@\n-            MemorySegment retSeg = data.rType() != TypeClass.VOID\n+            MemorySegment retSeg = retLayout != null\n@@ -205,1 +200,0 @@\n-                TypeClass argType = data.aTypes().get(i);\n@@ -208,1 +202,1 @@\n-                args[i] = readValue(argPtr, argType, argLayout);\n+                args[i] = readValue(argPtr, argLayout);\n@@ -213,1 +207,1 @@\n-            writeValue(data.rType(), result, data.returnLayout(), retSeg);\n+            writeValue(result, data.returnLayout(), retSeg);\n@@ -218,2 +212,2 @@\n-    private static void writeValue(TypeClass type, Object arg, MemoryLayout layout, MemorySegment argSeg) {\n-        writeValue(type, arg, layout, argSeg, addr -> {});\n+    private static void writeValue(Object arg, MemoryLayout layout, MemorySegment argSeg) {\n+        writeValue(arg, layout, argSeg, addr -> {});\n@@ -222,1 +216,1 @@\n-    private static void writeValue(TypeClass type, Object arg, MemoryLayout layout, MemorySegment argSeg,\n+    private static void writeValue(Object arg, MemoryLayout layout, MemorySegment argSeg,\n@@ -224,16 +218,24 @@\n-        switch (type) {\n-            case BOOLEAN -> argSeg.set((ValueLayout.OfBoolean) layout, 0, (Boolean) arg);\n-            case BYTE -> argSeg.set((ValueLayout.OfByte) layout, 0, (Byte) arg);\n-            case CHAR -> argSeg.set((ValueLayout.OfChar) layout, 0, (Character) arg);\n-            case SHORT -> argSeg.set((ValueLayout.OfShort) layout, 0, (Short) arg);\n-            case INT -> argSeg.set((ValueLayout.OfInt) layout, 0, (Integer) arg);\n-            case LONG -> argSeg.set((ValueLayout.OfLong) layout, 0, (Long) arg);\n-            case FLOAT -> argSeg.set((ValueLayout.OfFloat) layout, 0, (Float) arg);\n-            case DOUBLE -> argSeg.set((ValueLayout.OfDouble) layout, 0, (Double) arg);\n-            case ADDRESS -> {\n-                MemorySegment addrArg = (MemorySegment) arg;\n-                acquireCallback.accept(addrArg);\n-                argSeg.set((ValueLayout.OfAddress) layout, 0, addrArg);\n-            }\n-            case SEGMENT -> argSeg.copyFrom((MemorySegment) arg); \/\/ by-value struct\n-            case VOID -> {}\n+        if (layout instanceof ValueLayout.OfBoolean bl) {\n+            argSeg.set(bl, 0, (Boolean) arg);\n+        } else if (layout instanceof ValueLayout.OfByte bl) {\n+            argSeg.set(bl, 0, (Byte) arg);\n+        } else if (layout instanceof ValueLayout.OfShort sl) {\n+            argSeg.set(sl, 0, (Short) arg);\n+        } else if (layout instanceof ValueLayout.OfChar cl) {\n+            argSeg.set(cl, 0, (Character) arg);\n+        } else if (layout instanceof ValueLayout.OfInt il) {\n+            argSeg.set(il, 0, (Integer) arg);\n+        } else if (layout instanceof ValueLayout.OfLong ll) {\n+            argSeg.set(ll, 0, (Long) arg);\n+        } else if (layout instanceof ValueLayout.OfFloat fl) {\n+            argSeg.set(fl, 0, (Float) arg);\n+        } else if (layout instanceof ValueLayout.OfDouble dl) {\n+            argSeg.set(dl, 0, (Double) arg);\n+        } else if (layout instanceof ValueLayout.OfAddress al) {\n+            MemorySegment addrArg = (MemorySegment) arg;\n+            acquireCallback.accept(addrArg);\n+            argSeg.set(al, 0, addrArg);\n+        } else if (layout instanceof GroupLayout) {\n+            argSeg.copyFrom((MemorySegment) arg); \/\/ by-value struct\n+        } else {\n+            assert layout == null;\n@@ -243,14 +245,24 @@\n-    private static Object readValue(MemorySegment seg, TypeClass type, MemoryLayout layout) {\n-        return switch (type) {\n-            case BOOLEAN -> seg.get((ValueLayout.OfBoolean) layout, 0);\n-            case BYTE -> seg.get((ValueLayout.OfByte) layout, 0);\n-            case CHAR -> seg.get((ValueLayout.OfChar) layout, 0);\n-            case SHORT -> seg.get((ValueLayout.OfShort) layout, 0);\n-            case INT -> seg.get((ValueLayout.OfInt) layout, 0);\n-            case LONG -> seg.get((ValueLayout.OfLong) layout, 0);\n-            case FLOAT -> seg.get((ValueLayout.OfFloat) layout, 0);\n-            case DOUBLE -> seg.get((ValueLayout.OfDouble) layout, 0);\n-            case ADDRESS -> seg.get((ValueLayout.OfAddress) layout, 0);\n-            case SEGMENT -> seg;\n-            case VOID -> null;\n-        };\n+    private static Object readValue(MemorySegment seg, MemoryLayout layout) {\n+        if (layout instanceof ValueLayout.OfBoolean bl) {\n+            return seg.get(bl, 0);\n+        } else if (layout instanceof ValueLayout.OfByte bl) {\n+            return seg.get(bl, 0);\n+        } else if (layout instanceof ValueLayout.OfShort sl) {\n+            return seg.get(sl, 0);\n+        } else if (layout instanceof ValueLayout.OfChar cl) {\n+            return seg.get(cl, 0);\n+        } else if (layout instanceof ValueLayout.OfInt il) {\n+            return seg.get(il, 0);\n+        } else if (layout instanceof ValueLayout.OfLong ll) {\n+            return seg.get(ll, 0);\n+        } else if (layout instanceof ValueLayout.OfFloat fl) {\n+            return seg.get(fl, 0);\n+        } else if (layout instanceof ValueLayout.OfDouble dl) {\n+            return seg.get(dl, 0);\n+        } else if (layout instanceof ValueLayout.OfAddress al) {\n+            return seg.get(al, 0);\n+        } else if (layout instanceof GroupLayout) {\n+            return seg;\n+        }\n+        assert layout == null;\n+        return null;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FallbackLinker.java","additions":64,"deletions":52,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -1,68 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.foreign.abi.fallback;\n-\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.ValueLayout;\n-\n-enum TypeClass {\n-    BOOLEAN,\n-    BYTE,\n-    CHAR,\n-    SHORT,\n-    INT,\n-    LONG,\n-    FLOAT,\n-    DOUBLE,\n-    ADDRESS,\n-    SEGMENT,\n-    VOID;\n-\n-    static TypeClass classify(MemoryLayout layout) {\n-        if (layout instanceof ValueLayout.OfBoolean) {\n-            return BOOLEAN;\n-        } else if (layout instanceof ValueLayout.OfByte) {\n-            return BYTE;\n-        } else if (layout instanceof ValueLayout.OfShort) {\n-            return SHORT;\n-        } else if (layout instanceof ValueLayout.OfChar) {\n-            return CHAR;\n-        } else if (layout instanceof ValueLayout.OfInt) {\n-            return INT;\n-        } else if (layout instanceof ValueLayout.OfLong) {\n-            return LONG;\n-        } else if (layout instanceof ValueLayout.OfFloat) {\n-            return FLOAT;\n-        } else if (layout instanceof ValueLayout.OfDouble) {\n-            return DOUBLE;\n-        } else if (layout instanceof ValueLayout.OfAddress) {\n-            return ADDRESS;\n-        } else if (layout instanceof GroupLayout) {\n-            return SEGMENT;\n-        }\n-        throw new IllegalArgumentException(\"Can not classify layout: \" + layout);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/TypeClass.java","additions":0,"deletions":68,"binary":false,"changes":68,"status":"deleted"}]}