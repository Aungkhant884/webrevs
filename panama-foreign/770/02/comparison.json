{"files":[{"patch":"@@ -221,0 +221,4 @@\n+# Fallback linker\n+# This needs to go before 'LIB_DETERMINE_DEPENDENCIES'\n+JDKOPT_SETUP_FALLBACK_LINKER\n+\n","filename":"make\/autoconf\/configure.ac","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -867,0 +867,19 @@\n+\n+################################################################################\n+#\n+# fallback linker\n+#\n+AC_DEFUN_ONCE([JDKOPT_SETUP_FALLBACK_LINKER],\n+[\n+  FALLBACK_LINKER_DEFAULT=false\n+\n+  if HOTSPOT_CHECK_JVM_VARIANT(zero); then\n+    FALLBACK_LINKER_DEFAULT=true\n+  fi\n+\n+  UTIL_ARG_ENABLE(NAME: fallback-linker, DEFAULT: $FALLBACK_LINKER_DEFAULT,\n+      RESULT: ENABLE_FALLBACK_LINKER,\n+      DESC: [enable libffi-based fallback implementation of java.lang.foreign.Linker],\n+      CHECKING_MSG: [if fallback linker enabled])\n+  AC_SUBST(ENABLE_FALLBACK_LINKER)\n+])\n","filename":"make\/autoconf\/jdk-options.m4","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-  if HOTSPOT_CHECK_JVM_VARIANT(zero); then\n+  if HOTSPOT_CHECK_JVM_VARIANT(zero) || test \"x$ENABLE_FALLBACK_LINKER\" = \"xtrue\"; then\n","filename":"make\/autoconf\/libraries.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -410,0 +410,3 @@\n+# Fallback linker\n+ENABLE_FALLBACK_LINKER:=@ENABLE_FALLBACK_LINKER@\n+\n","filename":"make\/autoconf\/spec.gmk.in","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+JVM_IsForeignLinkerSupported\n","filename":"make\/data\/hotspot-symbols\/symbols-shared","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -220,0 +220,15 @@\n+\n+################################################################################\n+# Create fallback linker lib\n+\n+ifeq ($(ENABLE_FALLBACK_LINKER), true)\n+  $(eval $(call SetupJdkLibrary, BUILD_LIBFALLBACKLINKER, \\\n+      NAME := fallbackLinker, \\\n+      CFLAGS := $(CFLAGS_JDKLIB) $(LIBFFI_CFLAGS), \\\n+      LDFLAGS := $(LDFLAGS_JDKLIB) \\\n+                 $(call SET_SHARED_LIBRARY_ORIGIN), \\\n+      LIBS := $(LIBFFI_LIBS), \\\n+  ))\n+\n+  TARGETS += $(BUILD_LIBFALLBACKLINKER)\n+endif\n","filename":"make\/modules\/java.base\/Lib.gmk","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -36,0 +36,4 @@\n+bool ForeignGlobals::has_port() {\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/foreignGlobals_aarch64.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,4 @@\n+bool ForeignGlobals::has_port() {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/foreignGlobals_arm.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,4 @@\n+bool ForeignGlobals::has_port() {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/foreignGlobals_ppc.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,4 @@\n+bool ForeignGlobals::has_port() {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/foreignGlobals_riscv.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,4 @@\n+bool ForeignGlobals::has_port() {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/foreignGlobals_s390.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,4 @@\n+bool ForeignGlobals::has_port() {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/foreignGlobals_x86_32.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,4 @@\n+bool ForeignGlobals::has_port() {\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/foreignGlobals_x86_64.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,4 @@\n+bool ForeignGlobals::has_port() {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/zero\/foreignGlobals_zero.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#ifndef FFI_GO_CLOSURES\n+#ifdef __APPLE__\n","filename":"src\/hotspot\/cpu\/zero\/globalDefinitions_zero.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -177,0 +177,3 @@\n+JNIEXPORT jboolean JNICALL\n+JVM_IsForeignLinkerSupported(void);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -79,0 +79,2 @@\n+  static bool has_port();\n+\n","filename":"src\/hotspot\/share\/prims\/foreignGlobals.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+#include \"prims\/foreignGlobals.hpp\"\n@@ -3477,0 +3478,4 @@\n+JVM_LEAF(jboolean, JVM_IsForeignLinkerSupported(void))\n+  return ForeignGlobals::has_port() ? JNI_TRUE : JNI_FALSE;\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import jdk.internal.foreign.abi.fallback.FallbackLinker;\n+import jdk.internal.vm.ForeignLinkerSupport;\n+\n@@ -36,1 +39,3 @@\n-    WIN_AARCH_64;\n+    WIN_AARCH_64,\n+    FALLBACK,\n+    UNSUPPORTED;\n@@ -38,4 +43,1 @@\n-    private static final CABI ABI;\n-    private static final String ARCH;\n-    private static final String OS;\n-    private static final long ADDRESS_SIZE;\n+    private static final CABI CURRENT = computeCurrent();\n@@ -43,20 +45,28 @@\n-    static {\n-        ARCH = privilegedGetProperty(\"os.arch\");\n-        OS = privilegedGetProperty(\"os.name\");\n-        ADDRESS_SIZE = ADDRESS.bitSize();\n-        \/\/ might be running in a 32-bit VM on a 64-bit platform.\n-        \/\/ addressSize will be correctly 32\n-        if ((ARCH.equals(\"amd64\") || ARCH.equals(\"x86_64\")) && ADDRESS_SIZE == 64) {\n-            if (OS.startsWith(\"Windows\")) {\n-                ABI = WIN_64;\n-            } else {\n-                ABI = SYS_V;\n-            }\n-        } else if (ARCH.equals(\"aarch64\")) {\n-            if (OS.startsWith(\"Mac\")) {\n-                ABI = MAC_OS_AARCH_64;\n-            } else if (OS.startsWith(\"Windows\")) {\n-                ABI = WIN_AARCH_64;\n-            } else {\n-                \/\/ The Linux ABI follows the standard AAPCS ABI\n-                ABI = LINUX_AARCH_64;\n+    private static CABI computeCurrent() {\n+        String abi = privilegedGetProperty(\"jdk.internal.foreign.CABI\");\n+        if (abi != null) {\n+            return CABI.valueOf(abi);\n+        }\n+\n+        if (ForeignLinkerSupport.isSupported()) {\n+            \/\/ figure out the ABI based on the platform\n+            String arch = privilegedGetProperty(\"os.arch\");\n+            String os = privilegedGetProperty(\"os.name\");\n+            long addressSize = ADDRESS.bitSize();\n+            \/\/ might be running in a 32-bit VM on a 64-bit platform.\n+            \/\/ addressSize will be correctly 32\n+            if ((arch.equals(\"amd64\") || arch.equals(\"x86_64\")) && addressSize == 64) {\n+                if (os.startsWith(\"Windows\")) {\n+                    return WIN_64;\n+                } else {\n+                    return SYS_V;\n+                }\n+            } else if (arch.equals(\"aarch64\")) {\n+                if (os.startsWith(\"Mac\")) {\n+                    return MAC_OS_AARCH_64;\n+                } else if (os.startsWith(\"Windows\")) {\n+                    return WIN_AARCH_64;\n+                } else {\n+                    \/\/ The Linux ABI follows the standard AAPCS ABI\n+                    return LINUX_AARCH_64;\n+                }\n@@ -64,3 +74,2 @@\n-        } else {\n-            \/\/ unsupported\n-            ABI = null;\n+        } else if (FallbackLinker.isSupported()) {\n+            return FALLBACK; \/\/ fallback linker\n@@ -68,0 +77,2 @@\n+\n+        return UNSUPPORTED;\n@@ -71,5 +82,1 @@\n-        if (ABI == null) {\n-            throw new UnsupportedOperationException(\n-                    \"Unsupported os, arch, or address size: \" + OS + \", \" + ARCH + \", \" + ADDRESS_SIZE);\n-        }\n-        return ABI;\n+        return CURRENT;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/CABI.java","additions":41,"deletions":34,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import static sun.security.action.GetPropertyAction.privilegedGetProperty;\n@@ -45,0 +46,2 @@\n+    private static final boolean IS_WINDOWS = privilegedGetProperty(\"os.name\").startsWith(\"Windows\");\n+\n@@ -60,4 +63,5 @@\n-            return switch (CABI.current()) {\n-                case SYS_V, LINUX_AARCH_64, MAC_OS_AARCH_64 -> libLookup(libs -> libs.load(jdkLibraryPath(\"syslookup\")));\n-                case WIN_64, WIN_AARCH_64 -> makeWindowsLookup(); \/\/ out of line to workaround javac crash\n-            };\n+            if (IS_WINDOWS) {\n+                return makeWindowsLookup();\n+            } else {\n+                return libLookup(libs -> libs.load(jdkLibraryPath(\"syslookup\")));\n+            }\n@@ -121,4 +125,1 @@\n-        String lib = switch (CABI.current()) {\n-            case SYS_V, LINUX_AARCH_64, MAC_OS_AARCH_64 -> \"lib\";\n-            case WIN_64, WIN_AARCH_64 -> \"bin\";\n-        };\n+        String lib = IS_WINDOWS ? \"bin\" : \"lib\";\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.foreign.StructLayout;\n@@ -37,0 +38,2 @@\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -205,0 +208,36 @@\n+\n+    private static long computePadding(long offset, long align) {\n+        boolean isAligned = offset == 0 || offset % align == 0;\n+        if (isAligned) {\n+            return 0;\n+        } else {\n+            long gap = offset % align;\n+            return align - gap;\n+        }\n+    }\n+\n+    \/**\n+     * {@return return a struct layout constructed from the given elements, with padding computed automatically}\n+     *\n+     * @param elements the structs' fields\n+     *\/\n+    public static StructLayout computePaddedStructLayout(MemoryLayout... elements) {\n+        long offset = 0L;\n+        List<MemoryLayout> layouts = new ArrayList<>();\n+        long align = 0;\n+        for (MemoryLayout l : elements) {\n+            long padding = computePadding(offset, l.bitAlignment());\n+            if (padding != 0) {\n+                layouts.add(MemoryLayout.paddingLayout(padding));\n+                offset += padding;\n+            }\n+            layouts.add(l);\n+            align = Math.max(align, l.bitAlignment());\n+            offset += l.bitSize();\n+        }\n+        long padding = computePadding(offset, align);\n+        if (padding != 0) {\n+            layouts.add(MemoryLayout.paddingLayout(padding));\n+        }\n+        return MemoryLayout.structLayout(layouts.toArray(MemoryLayout[]::new));\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.abi.fallback.FallbackLinker;\n@@ -47,1 +48,3 @@\n-                                                                      SysVx64Linker, WindowsAArch64Linker, Windowsx64Linker {\n+                                                                      SysVx64Linker, WindowsAArch64Linker,\n+                                                                      Windowsx64Linker, FallbackLinker {\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-    private static final MethodHandle MH_CHECK_SYMBOL;\n@@ -61,2 +60,0 @@\n-            MH_CHECK_SYMBOL = lookup.findStatic(SharedUtils.class, \"checkSymbol\",\n-                    methodType(void.class, MemorySegment.class));\n@@ -114,1 +111,1 @@\n-        handle = foldArguments(handle, 1, MH_CHECK_SYMBOL);\n+        handle = foldArguments(handle, 1, SharedUtils.MH_CHECK_SYMBOL);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/DowncallLinker.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.internal.foreign.abi.fallback.FallbackLinker;\n@@ -43,1 +44,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -54,1 +54,0 @@\n-import java.util.NoSuchElementException;\n@@ -56,1 +55,0 @@\n-import java.util.function.Consumer;\n@@ -75,0 +73,1 @@\n+    public static final MethodHandle MH_CHECK_SYMBOL;\n@@ -85,0 +84,2 @@\n+            MH_CHECK_SYMBOL = lookup.findStatic(SharedUtils.class, \"checkSymbol\",\n+                    methodType(void.class, MemorySegment.class));\n@@ -191,0 +192,2 @@\n+            case FALLBACK -> FallbackLinker.getInstance();\n+            case UNSUPPORTED -> throw new UnsupportedOperationException(\"Platform does not support native linker\");\n@@ -242,1 +245,1 @@\n-    static MethodHandle swapArguments(MethodHandle mh, int firstArg, int secondArg) {\n+    public static MethodHandle swapArguments(MethodHandle mh, int firstArg, int secondArg) {\n@@ -260,1 +263,1 @@\n-    static void handleUncaughtException(Throwable t) {\n+    public static void handleUncaughtException(Throwable t) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi.fallback;\n+\n+\/**\n+ * enum which maps the {@code ffi_abi} enum\n+ *\/\n+enum FFIABI {\n+    DEFAULT(LibFallback.DEFAULT_ABI);\n+\n+    private final int value;\n+\n+    FFIABI(int abi) {\n+        this.value = abi;\n+    }\n+\n+    int value() {\n+        return value;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FFIABI.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi.fallback;\n+\n+\/**\n+ * See doc: <a href=\"https:\/\/github.com\/libffi\/libffi\/blob\/7611bb4cfe90884b55ad225e0166136a1d2cf22b\/doc\/libffi.texi#L159\"><\/a>\n+ * <p>\n+ * typedef enum {\n+ *   FFI_OK = 0,\n+ *   FFI_BAD_TYPEDEF,\n+ *   FFI_BAD_ABI,\n+ *   FFI_BAD_ARGTYPE\n+ * } ffi_status;\n+ *\/\n+enum FFIStatus {\n+    FFI_OK,\n+    FFI_BAD_TYPEDEF,\n+    FFI_BAD_ABI,\n+    FFI_BAD_ARGTYPE;\n+\n+    static FFIStatus of(int code) {\n+        return switch (code) {\n+            case 0 -> FFI_OK;\n+            case 1 -> FFI_BAD_TYPEDEF;\n+            case 2 -> FFI_BAD_ABI;\n+            case 3 -> FFI_BAD_ARGTYPE;\n+            default -> throw new IllegalArgumentException(\"Unknown status code: \" + code);\n+        };\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FFIStatus.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi.fallback;\n+\n+import jdk.internal.foreign.Utils;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.PaddingLayout;\n+import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.StructLayout;\n+import java.lang.foreign.UnionLayout;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.VarHandle;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Predicate;\n+\n+import static java.lang.foreign.ValueLayout.ADDRESS;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n+\n+\/**\n+ * typedef struct _ffi_type\n+ * {\n+ *   size_t size;\n+ *   unsigned short alignment;\n+ *   unsigned short type;\n+ *   struct _ffi_type **elements;\n+ * } ffi_type;\n+ *\/\n+class FFIType {\n+    private static final ValueLayout SIZE_T = switch ((int) ADDRESS.bitSize()) {\n+            case 64 -> JAVA_LONG;\n+            case 32 -> JAVA_INT;\n+            default -> throw new IllegalStateException(\"Address size not supported: \" + ADDRESS.byteSize());\n+        };\n+    private static final ValueLayout UNSIGNED_SHORT = JAVA_SHORT;\n+    private static final StructLayout LAYOUT = Utils.computePaddedStructLayout(\n+            SIZE_T, UNSIGNED_SHORT, UNSIGNED_SHORT.withName(\"type\"), ADDRESS.withName(\"elements\"));\n+\n+    private static final VarHandle VH_TYPE = LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"type\"));\n+    private static final VarHandle VH_ELEMENTS = LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"elements\"));\n+    private static final VarHandle VH_SIZE_T_ARRAY = SIZE_T.arrayElementVarHandle();\n+\n+    private static MemorySegment make(List<MemoryLayout> elements, FFIABI abi, SegmentScope scope) {\n+        MemorySegment elementsSeg = MemorySegment.allocateNative((elements.size() + 1) * ADDRESS.byteSize(), scope);\n+        int i = 0;\n+        for (; i < elements.size(); i++) {\n+            MemoryLayout elementLayout = elements.get(i);\n+            MemorySegment elementType = toFFIType(elementLayout, abi, scope);\n+            elementsSeg.setAtIndex(ADDRESS, i, elementType);\n+        }\n+        \/\/ elements array is null-terminated\n+        elementsSeg.setAtIndex(ADDRESS, i, MemorySegment.NULL);\n+\n+        MemorySegment ffiType = MemorySegment.allocateNative(LAYOUT, scope);\n+        VH_TYPE.set(ffiType, LibFallback.STRUCT_TAG);\n+        VH_ELEMENTS.set(ffiType, elementsSeg);\n+\n+        return ffiType;\n+    }\n+\n+    private static final Map<Class<?>, MemorySegment> CARRIER_TO_TYPE = Map.of(\n+        boolean.class, LibFallback.UINT8_TYPE,\n+        byte.class, LibFallback.SINT8_TYPE,\n+        short.class, LibFallback.SINT16_TYPE,\n+        char.class, LibFallback.UINT16_TYPE,\n+        int.class, LibFallback.SINT32_TYPE,\n+        long.class, LibFallback.SINT64_TYPE,\n+        float.class, LibFallback.FLOAT_TYPE,\n+        double.class, LibFallback.DOUBLE_TYPE,\n+        MemorySegment.class, LibFallback.POINTER_TYPE\n+    );\n+\n+    static MemorySegment toFFIType(MemoryLayout layout, FFIABI abi, SegmentScope scope) {\n+        if (layout instanceof GroupLayout grpl) {\n+            if (grpl instanceof StructLayout) {\n+                \/\/ libffi doesn't want our padding\n+                List<MemoryLayout> filteredLayouts = grpl.memberLayouts().stream()\n+                        .filter(Predicate.not(PaddingLayout.class::isInstance))\n+                        .toList();\n+                MemorySegment structType = make(filteredLayouts, abi, scope);\n+                verifyStructType(grpl, filteredLayouts, structType, abi);\n+                return structType;\n+            }\n+            assert grpl instanceof UnionLayout;\n+            throw new UnsupportedOperationException(\"No unions (TODO)\");\n+        } else if (layout instanceof SequenceLayout sl) {\n+            List<MemoryLayout> elements = Collections.nCopies(Math.toIntExact(sl.elementCount()), sl.elementLayout());\n+            return make(elements, abi, scope);\n+        }\n+        return Objects.requireNonNull(CARRIER_TO_TYPE.get(((ValueLayout) layout).carrier()));\n+    }\n+\n+    \/\/ verify layout against what libffi sets\n+    private static void verifyStructType(GroupLayout grpl, List<MemoryLayout> filteredLayouts, MemorySegment structType,\n+                                         FFIABI abi) {\n+        try (Arena verifyArena = Arena.openConfined()) {\n+            MemorySegment offsetsOut = verifyArena.allocate(SIZE_T.byteSize() * filteredLayouts.size());\n+            LibFallback.getStructOffsets(structType, offsetsOut, abi);\n+            for (int i = 0; i < filteredLayouts.size(); i++) {\n+                MemoryLayout element = filteredLayouts.get(i);\n+                final int finalI = i;\n+                element.name().ifPresent(name -> {\n+                    long layoutOffset = grpl.byteOffset(MemoryLayout.PathElement.groupElement(name));\n+                    long ffiOffset = (long) VH_SIZE_T_ARRAY.get(offsetsOut, finalI);\n+                    if (ffiOffset != layoutOffset) {\n+                        throw new IllegalArgumentException(\"Invalid group layout.\" +\n+                                \" Offset of '\" + name + \"': \" + layoutOffset + \" != \" + ffiOffset);\n+                    }\n+                });\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FFIType.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,270 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi.fallback;\n+\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n+import jdk.internal.foreign.MemorySessionImpl;\n+import jdk.internal.foreign.abi.AbstractLinker;\n+import jdk.internal.foreign.abi.CapturableState;\n+import jdk.internal.foreign.abi.LinkerOptions;\n+import jdk.internal.foreign.abi.SharedUtils;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.ref.Reference;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+import static java.lang.foreign.ValueLayout.ADDRESS;\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+import static java.lang.invoke.MethodHandles.foldArguments;\n+\n+public final class FallbackLinker extends AbstractLinker {\n+\n+    private static final MethodHandle MH_DO_DOWNCALL;\n+    private static final MethodHandle MH_DO_UPCALL;\n+\n+    static {\n+        try {\n+            MH_DO_DOWNCALL = MethodHandles.lookup().findStatic(FallbackLinker.class, \"doDowncall\",\n+                    MethodType.methodType(Object.class, SegmentAllocator.class, Object[].class, FallbackLinker.DowncallData.class));\n+            MH_DO_UPCALL = MethodHandles.lookup().findStatic(FallbackLinker.class, \"doUpcall\",\n+                    MethodType.methodType(void.class, MemorySegment.class, MemorySegment.class, UpcallData.class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+\n+    public static FallbackLinker getInstance() {\n+        class Holder {\n+            static final FallbackLinker INSTANCE = new FallbackLinker();\n+        }\n+        return Holder.INSTANCE;\n+    }\n+\n+    public static boolean isSupported() {\n+        return LibFallback.SUPPORTED;\n+    }\n+\n+    @Override\n+    protected MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function, LinkerOptions options) {\n+        MemorySegment cif = makeCif(inferredMethodType, function, FFIABI.DEFAULT, SegmentScope.auto());\n+\n+        int capturedStateMask = options.capturedCallState()\n+                .mapToInt(CapturableState::mask)\n+                .reduce(0, (a, b) -> a | b);\n+        DowncallData invData = new DowncallData(cif, function.returnLayout().orElse(null),\n+                function.argumentLayouts(), capturedStateMask);\n+\n+        MethodHandle target = MethodHandles.insertArguments(MH_DO_DOWNCALL, 2, invData);\n+\n+        int leadingArguments = 1; \/\/ address\n+        MethodType type = inferredMethodType.insertParameterTypes(0, SegmentAllocator.class, MemorySegment.class);\n+        if (capturedStateMask != 0) {\n+            leadingArguments++;\n+            type = type.insertParameterTypes(2, MemorySegment.class);\n+        }\n+        target = target.asCollector(1, Object[].class, inferredMethodType.parameterCount() + leadingArguments);\n+        target = target.asType(type);\n+        target = foldArguments(target, 1, SharedUtils.MH_CHECK_SYMBOL);\n+        target = SharedUtils.swapArguments(target, 0, 1); \/\/ normalize parameter order\n+\n+        return target;\n+    }\n+\n+    @Override\n+    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function,\n+                                          SegmentScope scope) {\n+        MemorySegment cif = makeCif(targetType, function, FFIABI.DEFAULT, scope);\n+\n+        UpcallData invData = new UpcallData(target, function.returnLayout().orElse(null),\n+                function.argumentLayouts());\n+\n+        MethodHandle doUpcallMH = MethodHandles.insertArguments(MH_DO_UPCALL, 2, invData);\n+        return LibFallback.createClosure(cif, doUpcallMH, scope);\n+    }\n+\n+    private static MemorySegment makeCif(MethodType methodType, FunctionDescriptor function, FFIABI abi, SegmentScope scope) {\n+        MemorySegment argTypes = MemorySegment.allocateNative(function.argumentLayouts().size() * ADDRESS.byteSize(), scope);\n+        List<MemoryLayout> argLayouts = function.argumentLayouts();\n+        for (int i = 0; i < argLayouts.size(); i++) {\n+            MemoryLayout layout = argLayouts.get(i);\n+            argTypes.setAtIndex(ADDRESS, i, FFIType.toFFIType(layout, abi, scope));\n+        }\n+\n+        MemorySegment returnType = methodType.returnType() != void.class\n+                ? FFIType.toFFIType(function.returnLayout().orElseThrow(), abi, scope)\n+                : LibFallback.VOID_TYPE;\n+        return LibFallback.prepCif(returnType, argLayouts.size(), argTypes, abi, scope);\n+    }\n+\n+    private record DowncallData(MemorySegment cif, MemoryLayout returnLayout, List<MemoryLayout> argLayouts,\n+                                int capturedStateMask) {}\n+\n+    private static Object doDowncall(SegmentAllocator returnAllocator, Object[] args, DowncallData invData) {\n+        List<MemorySessionImpl> acquiredSessions = new ArrayList<>();\n+        try (Arena arena = Arena.openConfined()) {\n+            int argStart = 0;\n+\n+            MemorySegment target = (MemorySegment) args[argStart++];\n+            MemorySessionImpl targetImpl = ((AbstractMemorySegmentImpl) target).sessionImpl();\n+            targetImpl.acquire0();\n+            acquiredSessions.add(targetImpl);\n+\n+            MemorySegment capturedState = null;\n+            if (invData.capturedStateMask() != 0) {\n+                capturedState = (MemorySegment) args[argStart++];\n+                MemorySessionImpl capturedStateImpl = ((AbstractMemorySegmentImpl) capturedState).sessionImpl();\n+                capturedStateImpl.acquire0();\n+                acquiredSessions.add(capturedStateImpl);\n+            }\n+\n+            List<MemoryLayout> argLayouts = invData.argLayouts();\n+            MemorySegment argPtrs = arena.allocate(argLayouts.size() * ADDRESS.byteSize());\n+            for (int i = 0; i < argLayouts.size(); i++) {\n+                Object arg = args[argStart + i];\n+                MemoryLayout layout = argLayouts.get(i);\n+                MemorySegment argSeg = arena.allocate(layout);\n+                writeValue(arg, layout, argSeg, addr -> {\n+                    MemorySessionImpl sessionImpl = ((AbstractMemorySegmentImpl) addr).sessionImpl();\n+                    sessionImpl.acquire0();\n+                    acquiredSessions.add(sessionImpl);\n+                });\n+                argPtrs.setAtIndex(ADDRESS, i, argSeg);\n+            }\n+\n+            MemorySegment retSeg = null;\n+            if (invData.returnLayout() != null) {\n+                retSeg = (invData.returnLayout() instanceof GroupLayout ? returnAllocator : arena).allocate(invData.returnLayout);\n+            }\n+\n+            LibFallback.doDowncall(invData.cif, target, retSeg, argPtrs, capturedState, invData.capturedStateMask());\n+\n+            Reference.reachabilityFence(invData.cif());\n+\n+            return readValue(retSeg, invData.returnLayout());\n+        } finally {\n+            for (MemorySessionImpl session : acquiredSessions) {\n+                session.release0();\n+            }\n+        }\n+    }\n+\n+    private record UpcallData(MethodHandle target, MemoryLayout returnLayout, List<MemoryLayout> argLayouts) {}\n+\n+    private static void doUpcall(MemorySegment retPtr, MemorySegment argPtrs, UpcallData data) throws Throwable {\n+        List<MemoryLayout> argLayouts = data.argLayouts();\n+        int numArgs = argLayouts.size();\n+        MemoryLayout retLayout = data.returnLayout();\n+        try (Arena upcallArena = Arena.openConfined()) {\n+            MemorySegment argsSeg = MemorySegment.ofAddress(argPtrs.address(), numArgs * ADDRESS.byteSize(), upcallArena.scope());\n+            MemorySegment retSeg = retLayout != null\n+                ? MemorySegment.ofAddress(retPtr.address(), retLayout.byteSize(), upcallArena.scope())\n+                : null;\n+\n+            Object[] args = new Object[numArgs];\n+            for (int i = 0; i < numArgs; i++) {\n+                MemoryLayout argLayout = argLayouts.get(i);\n+                MemorySegment argPtr = MemorySegment.ofAddress(argsSeg.getAtIndex(JAVA_LONG, i), argLayout.byteSize(), upcallArena.scope());\n+\n+                args[i] = readValue(argPtr, argLayout);\n+            }\n+\n+            Object result = data.target().invokeWithArguments(args);\n+\n+            writeValue(result, data.returnLayout(), retSeg);\n+        }\n+    }\n+\n+    \/\/ where\n+    private static void writeValue(Object arg, MemoryLayout layout, MemorySegment argSeg) {\n+        writeValue(arg, layout, argSeg, addr -> {});\n+    }\n+\n+    private static void writeValue(Object arg, MemoryLayout layout, MemorySegment argSeg,\n+                                   Consumer<MemorySegment> acquireCallback) {\n+        if (layout instanceof ValueLayout.OfBoolean bl) {\n+            argSeg.set(bl, 0, (Boolean) arg);\n+        } else if (layout instanceof ValueLayout.OfByte bl) {\n+            argSeg.set(bl, 0, (Byte) arg);\n+        } else if (layout instanceof ValueLayout.OfShort sl) {\n+            argSeg.set(sl, 0, (Short) arg);\n+        } else if (layout instanceof ValueLayout.OfChar cl) {\n+            argSeg.set(cl, 0, (Character) arg);\n+        } else if (layout instanceof ValueLayout.OfInt il) {\n+            argSeg.set(il, 0, (Integer) arg);\n+        } else if (layout instanceof ValueLayout.OfLong ll) {\n+            argSeg.set(ll, 0, (Long) arg);\n+        } else if (layout instanceof ValueLayout.OfFloat fl) {\n+            argSeg.set(fl, 0, (Float) arg);\n+        } else if (layout instanceof ValueLayout.OfDouble dl) {\n+            argSeg.set(dl, 0, (Double) arg);\n+        } else if (layout instanceof ValueLayout.OfAddress al) {\n+            MemorySegment addrArg = (MemorySegment) arg;\n+            acquireCallback.accept(addrArg);\n+            argSeg.set(al, 0, addrArg);\n+        } else if (layout instanceof GroupLayout) {\n+            argSeg.copyFrom((MemorySegment) arg); \/\/ by-value struct\n+        } else {\n+            assert layout == null;\n+        }\n+    }\n+\n+    private static Object readValue(MemorySegment seg, MemoryLayout layout) {\n+        if (layout instanceof ValueLayout.OfBoolean bl) {\n+            return seg.get(bl, 0);\n+        } else if (layout instanceof ValueLayout.OfByte bl) {\n+            return seg.get(bl, 0);\n+        } else if (layout instanceof ValueLayout.OfShort sl) {\n+            return seg.get(sl, 0);\n+        } else if (layout instanceof ValueLayout.OfChar cl) {\n+            return seg.get(cl, 0);\n+        } else if (layout instanceof ValueLayout.OfInt il) {\n+            return seg.get(il, 0);\n+        } else if (layout instanceof ValueLayout.OfLong ll) {\n+            return seg.get(ll, 0);\n+        } else if (layout instanceof ValueLayout.OfFloat fl) {\n+            return seg.get(fl, 0);\n+        } else if (layout instanceof ValueLayout.OfDouble dl) {\n+            return seg.get(dl, 0);\n+        } else if (layout instanceof ValueLayout.OfAddress al) {\n+            return seg.get(al, 0);\n+        } else if (layout instanceof GroupLayout) {\n+            return seg;\n+        }\n+        assert layout == null;\n+        return null;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FallbackLinker.java","additions":270,"deletions":0,"binary":false,"changes":270,"status":"added"},{"patch":"@@ -0,0 +1,197 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi.fallback;\n+\n+import jdk.internal.foreign.abi.SharedUtils;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentScope;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+\n+class LibFallback {\n+    static final boolean SUPPORTED = tryLoadLibrary();\n+\n+    private static boolean tryLoadLibrary() {\n+        try {\n+            System.loadLibrary(\"fallbackLinker\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            return false;\n+        }\n+        init();\n+        return true;\n+    }\n+\n+    static final int DEFAULT_ABI = ffi_default_abi();\n+\n+    static final MemorySegment UINT8_TYPE = MemorySegment.ofAddress(ffi_type_uint8());\n+    static final MemorySegment SINT8_TYPE = MemorySegment.ofAddress(ffi_type_sint8());\n+    static final MemorySegment UINT16_TYPE = MemorySegment.ofAddress(ffi_type_uint16());\n+    static final MemorySegment SINT16_TYPE = MemorySegment.ofAddress(ffi_type_sint16());\n+    static final MemorySegment SINT32_TYPE = MemorySegment.ofAddress(ffi_type_sint32());\n+    static final MemorySegment SINT64_TYPE = MemorySegment.ofAddress(ffi_type_sint64());\n+    static final MemorySegment FLOAT_TYPE = MemorySegment.ofAddress(ffi_type_float());\n+    static final MemorySegment DOUBLE_TYPE = MemorySegment.ofAddress(ffi_type_double());\n+    static final MemorySegment POINTER_TYPE = MemorySegment.ofAddress(ffi_type_pointer());\n+\n+    static final MemorySegment VOID_TYPE = MemorySegment.ofAddress(ffi_type_void());\n+    static final short STRUCT_TAG = ffi_type_struct();\n+\n+    private static final long SIZEOF_CIF = sizeofCif();\n+\n+    private static final MethodType UPCALL_TARGET_TYPE = MethodType.methodType(void.class, MemorySegment.class, MemorySegment.class);\n+\n+    \/**\n+     * Do a libffi based downcall. This method wraps the {@code ffi_call} function\n+     *\n+     * @param cif a pointer to a {@code ffi_cif} struct\n+     * @param target the address of the target function\n+     * @param retPtr a pointer to a buffer into which the return value shall be written, or {@code null} if the target\n+     *               function does not return a value\n+     * @param argPtrs a pointer to an array of pointers, which each point to an argument value\n+     * @param capturedState a pointer to a buffer into which captured state is written, or {@code null} if no state is\n+     *                      to be captured\n+     * @param capturedStateMask the bit mask indicating which state to capture\n+     *\n+     * @see jdk.internal.foreign.abi.CapturableState\n+     *\/\n+    static void doDowncall(MemorySegment cif, MemorySegment target, MemorySegment retPtr, MemorySegment argPtrs,\n+                                  MemorySegment capturedState, int capturedStateMask) {\n+            doDowncall(cif.address(), target.address(),\n+                    retPtr == null ? 0 : retPtr.address(), argPtrs.address(),\n+                    capturedState == null ? 0 : capturedState.address(), capturedStateMask);\n+    }\n+\n+    \/**\n+     * Wrapper for {@code ffi_prep_cif}\n+     *\n+     * @param returnType a pointer to an @{code ffi_type} describing the return type\n+     * @param numArgs the number of arguments\n+     * @param paramTypes a pointer to an array of pointers, which each point to an {@code ffi_type} describing a\n+     *                parameter type\n+     * @param abi the abi to be used\n+     * @param scope the scope into which to allocate the returned {@code ffi_cif} struct\n+     * @return a pointer to a prepared {@code ffi_cif} struct\n+     *\n+     * @throws IllegalStateException if the call to {@code ffi_prep_cif} returns a non-zero status code\n+     *\/\n+    static MemorySegment prepCif(MemorySegment returnType, int numArgs, MemorySegment paramTypes, FFIABI abi,\n+                                         SegmentScope scope) throws IllegalStateException {\n+        MemorySegment cif = MemorySegment.allocateNative(SIZEOF_CIF, scope);\n+        checkStatus(ffi_prep_cif(cif.address(), abi.value(), numArgs, returnType.address(), paramTypes.address()));\n+        return cif;\n+    }\n+\n+    \/**\n+     * Create an upcallStub-style closure. This method wraps the {@code ffi_closure_alloc}\n+     * and {@code ffi_prep_closure_loc} functions.\n+     * <p>\n+     * The closure will end up calling into {@link #doUpcall(long, long, MethodHandle)}\n+     * <p>\n+     * The target method handle should have the type {@code (MemorySegment, MemorySegment) -> void}. The first\n+     * argument is a pointer to the buffer into which the native return value should be written. The second argument\n+     * is a pointer to an array of pointers, which each point to a native argument value.\n+     *\n+     * @param cif a pointer to a {@code ffi_cif} struct\n+     * @param target a method handle that points to the target function\n+     * @param scope the scope to which to attach the created upcall stub\n+     * @return the created upcall stub\n+     *\n+     * @throws IllegalStateException if the call to {@code ffi_prep_closure_loc} returns a non-zero status code\n+     * @throws IllegalArgumentException if {@code target} does not have the right type\n+     *\/\n+    static MemorySegment createClosure(MemorySegment cif, MethodHandle target, SegmentScope scope)\n+            throws IllegalStateException, IllegalArgumentException {\n+        if (target.type() != UPCALL_TARGET_TYPE) {\n+            throw new IllegalArgumentException(\"Target handle has wrong type: \" + target.type() + \" != \" + UPCALL_TARGET_TYPE);\n+        }\n+\n+        long[] ptrs = new long[3];\n+        checkStatus(createClosure(cif.address(), target, ptrs));\n+        long closurePtr = ptrs[0];\n+        long execPtr = ptrs[1];\n+        long globalTarget = ptrs[2];\n+\n+        return MemorySegment.ofAddress(execPtr, 0, scope, () -> freeClosure(closurePtr, globalTarget));\n+    }\n+\n+    \/\/ the target function for a closure call\n+    private static void doUpcall(long retPtr, long argPtrs, MethodHandle target) {\n+        try {\n+            target.invokeExact(MemorySegment.ofAddress(retPtr), MemorySegment.ofAddress(argPtrs));\n+        } catch (Throwable t) {\n+            SharedUtils.handleUncaughtException(t);\n+        }\n+    }\n+\n+    \/**\n+     * Wrapper for {@code ffi_get_struct_offsets}\n+     *\n+     * @param structType a pointer to an {@code ffi_type} representing a struct\n+     * @param offsetsOut a pointer to an array of {@code size_t}, with one element for each element of the struct.\n+     *                   This is an 'out' parameter that will be filled in by this call\n+     * @param abi the abi to be used\n+     *\n+     * @throws IllegalStateException if the call to {@code ffi_get_struct_offsets} returns a non-zero status code\n+     *\/\n+    static void getStructOffsets(MemorySegment structType, MemorySegment offsetsOut, FFIABI abi)\n+            throws IllegalStateException  {\n+        checkStatus(ffi_get_struct_offsets(abi.value(), structType.address(), offsetsOut.address()));\n+    }\n+\n+    private static void checkStatus(int code) {\n+        FFIStatus status = FFIStatus.of(code);\n+        if (status != FFIStatus.FFI_OK) {\n+            throw new IllegalStateException(\"libffi call failed with status: \" + status);\n+        }\n+    }\n+\n+    private static native void init();\n+\n+    private static native long sizeofCif();\n+\n+    private static native int createClosure(long cif, Object userData, long[] ptrs);\n+    private static native void freeClosure(long closureAddress, long globalTarget);\n+    private static native void doDowncall(long cif, long fn, long rvalue, long avalues, long capturedState, int capturedStateMask);\n+\n+    private static native int ffi_prep_cif(long cif, int abi, int nargs, long rtype, long atypes);\n+    private static native int ffi_get_struct_offsets(int abi, long type, long offsets);\n+\n+    private static native int ffi_default_abi();\n+    private static native short ffi_type_struct();\n+\n+    private static native long ffi_type_void();\n+    private static native long ffi_type_uint8();\n+    private static native long ffi_type_sint8();\n+    private static native long ffi_type_uint16();\n+    private static native long ffi_type_sint16();\n+    private static native long ffi_type_uint32();\n+    private static native long ffi_type_sint32();\n+    private static native long ffi_type_uint64();\n+    private static native long ffi_type_sint64();\n+    private static native long ffi_type_float();\n+    private static native long ffi_type_double();\n+    private static native long ffi_type_pointer();\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/LibFallback.java","additions":197,"deletions":0,"binary":false,"changes":197,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.vm;\n+\n+\/**\n+ * Defines a static method to test if the VM has support for the foreign java.lang.foreign.Linker.\n+ *\/\n+public class ForeignLinkerSupport {\n+    private static final boolean SUPPORTED = isSupported0();\n+\n+    private ForeignLinkerSupport() {\n+    }\n+\n+    \/**\n+     * Return true if the VM has support for the foreign Linker.\n+     *\/\n+    public static boolean isSupported() {\n+        return SUPPORTED;\n+    }\n+\n+    \/**\n+     * Ensures that VM has support for the foreign Linker.\n+     * @throws UnsupportedOperationException if not supported\n+     *\/\n+    public static void ensureSupported() {\n+        if (!isSupported()) {\n+            throw new UnsupportedOperationException(\"VM does not support linker\");\n+        }\n+    }\n+\n+    private static native boolean isSupported0();\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ForeignLinkerSupport.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,203 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jdk_internal_foreign_abi_fallback_LibFallback.h\"\n+\n+#include <ffi.h>\n+\n+#include <errno.h>\n+#ifdef _WIN64\n+#include <Windows.h>\n+#include <Winsock2.h>\n+#endif\n+\n+#include \"jlong.h\"\n+\n+static JavaVM* VM;\n+static jclass LibFallback_class;\n+static jmethodID LibFallback_doUpcall_ID;\n+static const char* LibFallback_doUpcall_sig = \"(JJLjava\/lang\/invoke\/MethodHandle;)V\";\n+\n+JNIEXPORT void JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_init(JNIEnv* env, jclass cls) {\n+  (*env)->GetJavaVM(env, &VM);\n+  LibFallback_class = (*env)->FindClass(env, \"jdk\/internal\/foreign\/abi\/fallback\/LibFallback\");\n+  LibFallback_doUpcall_ID = (*env)->GetStaticMethodID(env,\n+    LibFallback_class, \"doUpcall\", LibFallback_doUpcall_sig);\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_sizeofCif(JNIEnv* env, jclass cls) {\n+  return sizeof(ffi_cif);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1prep_1cif(JNIEnv* env, jclass cls, jlong cif, jint abi, jint nargs, jlong rtype, jlong atypes) {\n+  return ffi_prep_cif(jlong_to_ptr(cif), (ffi_abi) abi, (unsigned int) nargs, jlong_to_ptr(rtype), jlong_to_ptr(atypes));\n+}\n+JNIEXPORT jint JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1get_1struct_1offsets(JNIEnv* env, jclass cls, jint abi, jlong type, jlong offsets) {\n+  return ffi_get_struct_offsets((ffi_abi) abi, jlong_to_ptr(type), jlong_to_ptr(offsets));\n+}\n+\n+static void do_capture_state(int32_t* value_ptr, int captured_state_mask) {\n+    \/\/ keep in synch with jdk.internal.foreign.abi.CapturableState\n+  enum PreservableValues {\n+    NONE = 0,\n+    GET_LAST_ERROR = 1,\n+    WSA_GET_LAST_ERROR = 1 << 1,\n+    ERRNO = 1 << 2\n+  };\n+#ifdef _WIN64\n+  if (captured_state_mask & GET_LAST_ERROR) {\n+    *value_ptr = GetLastError();\n+    value_ptr++;\n+  }\n+  if (captured_state_mask & WSA_GET_LAST_ERROR) {\n+    *value_ptr = WSAGetLastError();\n+    value_ptr++;\n+  }\n+#endif\n+  if (captured_state_mask & ERRNO) {\n+    *value_ptr = errno;\n+  }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_doDowncall(JNIEnv* env, jclass cls, jlong cif, jlong fn, jlong rvalue, jlong avalues, jlong jcaptured_state, jint captured_state_mask) {\n+  ffi_call(jlong_to_ptr(cif), jlong_to_ptr(fn), jlong_to_ptr(rvalue), jlong_to_ptr(avalues));\n+\n+  if (captured_state_mask != 0) {\n+    int32_t* captured_state = jlong_to_ptr(jcaptured_state);\n+    do_capture_state(captured_state, captured_state_mask);\n+  }\n+}\n+\n+static void do_upcall(ffi_cif* cif, void* ret, void** args, void* user_data) {\n+  \/\/ attach thread\n+  JNIEnv* env;\n+  jint result = (*VM)->AttachCurrentThreadAsDaemon(VM, (void**) &env, NULL);\n+\n+  \/\/ call into doUpcall in LibFallback\n+  jobject upcall_data = (jobject) user_data;\n+  (*env)->CallStaticVoidMethod(env, LibFallback_class, LibFallback_doUpcall_ID,\n+    ptr_to_jlong(ret), ptr_to_jlong(args), upcall_data);\n+\n+  \/\/ always detach for now\n+  (*VM)->DetachCurrentThread(VM);\n+}\n+\n+static void free_closure(JNIEnv* env, void* closure, jobject upcall_data) {\n+  ffi_closure_free(closure);\n+  (*env)->DeleteGlobalRef(env, upcall_data);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_createClosure(JNIEnv* env, jclass cls, jlong cif, jobject upcall_data, jlongArray jptrs) {\n+  void* code;\n+  void* closure = ffi_closure_alloc(sizeof(ffi_closure), &code);\n+\n+  jobject global_upcall_data = (*env)->NewGlobalRef(env, upcall_data);\n+\n+  ffi_status status = ffi_prep_closure_loc(closure, jlong_to_ptr(cif), &do_upcall, (void*) global_upcall_data, code);\n+\n+  if (status != FFI_OK) {\n+    free_closure(env,closure, global_upcall_data);\n+    return status;\n+  }\n+\n+  jlong* ptrs = (*env)->GetLongArrayElements(env, jptrs, NULL);\n+  ptrs[0] = ptr_to_jlong(closure);\n+  ptrs[1] = ptr_to_jlong(code);\n+  ptrs[2] = ptr_to_jlong(global_upcall_data);\n+  (*env)->ReleaseLongArrayElements(env, jptrs, ptrs, JNI_COMMIT);\n+\n+  return status;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_freeClosure(JNIEnv* env, jclass cls, jlong closure, jlong upcall_data) {\n+  free_closure(env, jlong_to_ptr(closure), jlong_to_ptr(upcall_data));\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1default_1abi(JNIEnv* env, jclass cls) {\n+  return (jint) FFI_DEFAULT_ABI;\n+}\n+\n+JNIEXPORT jshort JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1type_1struct(JNIEnv* env, jclass cls) {\n+  return (jshort) FFI_TYPE_STRUCT;\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1type_1void(JNIEnv* env, jclass cls) {\n+  return ptr_to_jlong(&ffi_type_void);\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1type_1uint8(JNIEnv* env, jclass cls) {\n+  return ptr_to_jlong(&ffi_type_uint8);\n+}\n+JNIEXPORT jlong JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1type_1sint8(JNIEnv* env, jclass cls) {\n+  return ptr_to_jlong(&ffi_type_sint8);\n+}\n+JNIEXPORT jlong JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1type_1uint16(JNIEnv* env, jclass cls) {\n+  return ptr_to_jlong(&ffi_type_uint16);\n+}\n+JNIEXPORT jlong JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1type_1sint16(JNIEnv* env, jclass cls) {\n+  return ptr_to_jlong(&ffi_type_sint16);\n+}\n+JNIEXPORT jlong JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1type_1uint32(JNIEnv* env, jclass cls) {\n+  return ptr_to_jlong(&ffi_type_uint32);\n+}\n+JNIEXPORT jlong JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1type_1sint32(JNIEnv* env, jclass cls) {\n+  return ptr_to_jlong(&ffi_type_sint32);\n+}\n+JNIEXPORT jlong JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1type_1uint64(JNIEnv* env, jclass cls) {\n+  return ptr_to_jlong(&ffi_type_uint64);\n+}\n+JNIEXPORT jlong JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1type_1sint64(JNIEnv* env, jclass cls) {\n+  return ptr_to_jlong(&ffi_type_sint64);\n+}\n+JNIEXPORT jlong JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1type_1float(JNIEnv* env, jclass cls) {\n+  return ptr_to_jlong(&ffi_type_float);\n+}\n+JNIEXPORT jlong JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1type_1double(JNIEnv* env, jclass cls) {\n+  return ptr_to_jlong(&ffi_type_double);\n+}\n+JNIEXPORT jlong JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1type_1pointer(JNIEnv* env, jclass cls) {\n+  return ptr_to_jlong(&ffi_type_pointer);\n+}\n","filename":"src\/java.base\/share\/native\/libfallbackLinker\/fallbackLinker.c","additions":203,"deletions":0,"binary":false,"changes":203,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"jvm.h\"\n+\n+#include \"jdk_internal_vm_ForeignLinkerSupport.h\"\n+\n+JNIEXPORT jboolean JNICALL\n+Java_jdk_internal_vm_ForeignLinkerSupport_isSupported0(JNIEnv *env, jclass cls) {\n+    return JVM_IsForeignLinkerSupported();\n+}\n","filename":"src\/java.base\/share\/native\/libjava\/ForeignLinkerSupport.c","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng\/othervm -Dos.arch=unknown -Dos.name=unknown --enable-native-access=ALL-UNNAMED TestUnsupportedLinker\n+ * @run testng\/othervm -Djdk.internal.foreign.CABI=UNSUPPORTED --enable-native-access=ALL-UNNAMED TestUnsupportedLinker\n","filename":"test\/jdk\/java\/foreign\/TestUnsupportedLinker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}