{"files":[{"patch":"@@ -1778,10 +1778,0 @@\n-int MachCallNativeNode::ret_addr_offset() {\n-  \/\/ This is implemented using aarch64_enc_java_to_runtime as above.\n-  CodeBlob *cb = CodeCache::find_blob(_entry_point);\n-  if (cb) {\n-    return 1 * NativeInstruction::instruction_size;\n-  } else {\n-    return 6 * NativeInstruction::instruction_size;\n-  }\n-}\n-\n@@ -16542,15 +16532,0 @@\n-instruct CallNativeDirect(method meth)\n-%{\n-  match(CallNative);\n-\n-  effect(USE meth);\n-\n-  ins_cost(CALL_COST);\n-\n-  format %{ \"CALL, native $meth\" %}\n-\n-  ins_encode( aarch64_enc_java_to_runtime(meth) );\n-\n-  ins_pipe(pipe_class_call);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -450,5 +450,0 @@\n-\n-int MachCallNativeNode::ret_addr_offset() {\n-  Unimplemented();\n-  return -1;\n-}\n","filename":"src\/hotspot\/cpu\/arm\/arm_32.ad","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1128,5 +1128,0 @@\n-int MachCallNativeNode::ret_addr_offset() {\n-  Unimplemented();\n-  return -1;\n-}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -642,5 +642,0 @@\n-int MachCallNativeNode::ret_addr_offset() {\n-  Unimplemented();\n-  return -1;\n-}\n-\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -326,5 +326,0 @@\n-int MachCallNativeNode::ret_addr_offset() {\n-  ShouldNotCallThis();\n-  return -1;\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -477,6 +477,0 @@\n-\n-int MachCallNativeNode::ret_addr_offset() {\n-  int offset = 13; \/\/ movq r10,#addr; callq (r10)\n-  offset += clear_avx_size();\n-  return offset;\n-}\n@@ -13106,12 +13100,0 @@\n-\/\/\n-instruct CallNativeDirect(method meth)\n-%{\n-  match(CallNative);\n-  effect(USE meth);\n-\n-  ins_cost(300);\n-  format %{ \"call_native \" %}\n-  ins_encode(clear_avx, Java_To_Runtime(meth));\n-  ins_pipe(pipe_slow);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -424,2 +424,0 @@\n-  if(_matrule->find_type(\"CallNative\",idx))       return Form::JAVA_NATIVE;\n-  idx = 0;\n@@ -1146,3 +1144,0 @@\n-  else if( is_ideal_call() == Form::JAVA_NATIVE ) {\n-    return \"MachCallNativeNode\";\n-  }\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -4191,1 +4191,2 @@\n-    break; \/\/ TODO: NYI\n+    print_inlining(callee, \"Native call\", \/*success*\/ false);\n+    break;\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -246,1 +246,0 @@\n-    bool is_opt_native = false;\n@@ -250,1 +249,1 @@\n-                             reexecute, rethrow_exception, is_method_handle_invoke, is_opt_native, return_oop,\n+                             reexecute, rethrow_exception, is_method_handle_invoke, return_oop,\n","filename":"src\/hotspot\/share\/c1\/c1_IR.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-class     ciNativeEntryPoint;\n@@ -101,1 +100,0 @@\n-friend class ciNativeEntryPoint;       \\\n","filename":"src\/hotspot\/share\/ci\/ciClassList.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,88 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"ci\/ciClassList.hpp\"\n-#include \"ci\/ciNativeEntryPoint.hpp\"\n-#include \"ci\/ciUtilities.inline.hpp\"\n-#include \"ci\/ciArray.hpp\"\n-#include \"classfile\/javaClasses.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"memory\/allocation.hpp\"\n-\n-VMReg* getVMRegArray(ciArray* array) {\n-  assert(array->element_basic_type() == T_LONG, \"Unexpected type\");\n-\n-  VMReg* out = NEW_ARENA_ARRAY(CURRENT_ENV->arena(), VMReg, array->length());\n-\n-  for (int i = 0; i < array->length(); i++) {\n-    ciConstant con = array->element_value(i);\n-    VMReg reg = VMRegImpl::as_VMReg(con.as_long());\n-    out[i] = reg;\n-  }\n-\n-  return out;\n-}\n-\n-ciNativeEntryPoint::ciNativeEntryPoint(instanceHandle h_i) : ciInstance(h_i), _name(NULL) {\n-  \/\/ Copy name\n-  oop name_str = jdk_internal_invoke_NativeEntryPoint::name(get_oop());\n-  if (name_str != NULL) {\n-    char* temp_name = java_lang_String::as_quoted_ascii(name_str);\n-    size_t len = strlen(temp_name) + 1;\n-    char* name = (char*)CURRENT_ENV->arena()->Amalloc(len);\n-    strncpy(name, temp_name, len);\n-    _name = name;\n-  }\n-\n-  _arg_moves = getVMRegArray(CURRENT_ENV->get_object(jdk_internal_invoke_NativeEntryPoint::argMoves(get_oop()))->as_array());\n-  _ret_moves = getVMRegArray(CURRENT_ENV->get_object(jdk_internal_invoke_NativeEntryPoint::returnMoves(get_oop()))->as_array());\n-}\n-\n-jint ciNativeEntryPoint::shadow_space() const {\n-  VM_ENTRY_MARK;\n-  return jdk_internal_invoke_NativeEntryPoint::shadow_space(get_oop());\n-}\n-\n-VMReg* ciNativeEntryPoint::argMoves() const {\n-  return _arg_moves;\n-}\n-\n-VMReg* ciNativeEntryPoint::returnMoves() const {\n-  return _ret_moves;\n-}\n-\n-jboolean ciNativeEntryPoint::need_transition() const {\n-  VM_ENTRY_MARK;\n-  return jdk_internal_invoke_NativeEntryPoint::need_transition(get_oop());\n-}\n-\n-ciMethodType* ciNativeEntryPoint::method_type() const {\n-  VM_ENTRY_MARK;\n-  return CURRENT_ENV->get_object(jdk_internal_invoke_NativeEntryPoint::method_type(get_oop()))->as_method_type();\n-}\n-\n-const char* ciNativeEntryPoint::name() {\n-  return _name;\n-}\n","filename":"src\/hotspot\/share\/ci\/ciNativeEntryPoint.cpp","additions":0,"deletions":88,"binary":false,"changes":88,"status":"deleted"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_VM_CI_CINATIVEENTRYPOINT_HPP\n-#define SHARE_VM_CI_CINATIVEENTRYPOINT_HPP\n-\n-#include \"ci\/ciInstance.hpp\"\n-#include \"ci\/ciMethodType.hpp\"\n-\n-#include \"code\/vmreg.hpp\"\n-\n-\/\/ ciNativeEntryPoint\n-\/\/\n-\/\/ The class represents a java.lang.invoke.NativeEntryPoint object.\n-class ciNativeEntryPoint : public ciInstance {\n-private:\n-  const char* _name;\n-  VMReg* _arg_moves;\n-  VMReg* _ret_moves;\n-public:\n-  ciNativeEntryPoint(instanceHandle h_i);\n-\n-  \/\/ What kind of ciObject is this?\n-  bool is_native_entry_point() const { return true; }\n-\n-  jint           shadow_space() const;\n-  VMReg*         argMoves() const;\n-  VMReg*        returnMoves() const;\n-  jboolean       need_transition() const;\n-  ciMethodType*  method_type() const;\n-  const char*    name();\n-};\n-\n-#endif \/\/ SHARE_VM_CI_CINATIVEENTRYPOINT_HPP\n","filename":"src\/hotspot\/share\/ci\/ciNativeEntryPoint.hpp","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -163,4 +163,0 @@\n-  ciNativeEntryPoint* as_native_entry_point() {\n-    assert(is_native_entry_point(), \"bad cast\");\n-    return (ciNativeEntryPoint*)this;\n-  }\n","filename":"src\/hotspot\/share\/ci\/ciObject.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"ci\/ciNativeEntryPoint.hpp\"\n@@ -347,2 +346,0 @@\n-    else if (jdk_internal_invoke_NativeEntryPoint::is_instance(o))\n-      return new (arena()) ciNativeEntryPoint(h_i);\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3861,4 +3861,0 @@\n-int jdk_internal_invoke_NativeEntryPoint::_shadow_space_offset;\n-int jdk_internal_invoke_NativeEntryPoint::_argMoves_offset;\n-int jdk_internal_invoke_NativeEntryPoint::_returnMoves_offset;\n-int jdk_internal_invoke_NativeEntryPoint::_need_transition_offset;\n@@ -3866,1 +3862,0 @@\n-int jdk_internal_invoke_NativeEntryPoint::_name_offset;\n@@ -3870,4 +3865,0 @@\n-  macro(_shadow_space_offset,    k, \"shadowSpace\",    int_signature, false); \\\n-  macro(_argMoves_offset,        k, \"argMoves\",       long_array_signature, false); \\\n-  macro(_returnMoves_offset,     k, \"returnMoves\",    long_array_signature, false); \\\n-  macro(_need_transition_offset, k, \"needTransition\", bool_signature, false); \\\n@@ -3875,1 +3866,0 @@\n-  macro(_name_offset,            k, \"name\",           string_signature, false); \\\n@@ -3893,16 +3883,0 @@\n-jint jdk_internal_invoke_NativeEntryPoint::shadow_space(oop entry) {\n-  return entry->int_field(_shadow_space_offset);\n-}\n-\n-oop jdk_internal_invoke_NativeEntryPoint::argMoves(oop entry) {\n-  return entry->obj_field(_argMoves_offset);\n-}\n-\n-oop jdk_internal_invoke_NativeEntryPoint::returnMoves(oop entry) {\n-  return entry->obj_field(_returnMoves_offset);\n-}\n-\n-jboolean jdk_internal_invoke_NativeEntryPoint::need_transition(oop entry) {\n-  return entry->bool_field(_need_transition_offset);\n-}\n-\n@@ -3913,4 +3887,0 @@\n-oop jdk_internal_invoke_NativeEntryPoint::name(oop entry) {\n-  return entry->obj_field(_name_offset);\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1045,4 +1045,0 @@\n-  static int _shadow_space_offset;\n-  static int _argMoves_offset;\n-  static int _returnMoves_offset;\n-  static int _need_transition_offset;\n@@ -1050,1 +1046,0 @@\n-  static int _name_offset;\n@@ -1059,4 +1054,0 @@\n-  static jint       shadow_space(oop entry);\n-  static oop        argMoves(oop entry);\n-  static oop        returnMoves(oop entry);\n-  static jboolean   need_transition(oop entry);\n@@ -1064,1 +1055,0 @@\n-  static oop        name(oop entry);\n@@ -1075,4 +1065,0 @@\n-  static int shadow_space_offset_in_bytes()    { return _shadow_space_offset;    }\n-  static int argMoves_offset_in_bytes()        { return _argMoves_offset;        }\n-  static int returnMoves_offset_in_bytes()     { return _returnMoves_offset;     }\n-  static int need_transition_offset_in_bytes() { return _need_transition_offset; }\n@@ -1080,1 +1066,0 @@\n-  static int name_offset_in_bytes()            { return _name_offset;            }\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -363,1 +363,0 @@\n-    if (ssd.is_optimized_linkToNative()) return; \/\/ call was replaced\n","filename":"src\/hotspot\/share\/code\/compiledMethod.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -291,1 +291,0 @@\n-                                              bool        is_optimized_linkToNative,\n@@ -310,1 +309,0 @@\n-  last_pd->set_is_optimized_linkToNative(is_optimized_linkToNative);\n","filename":"src\/hotspot\/share\/code\/debugInfoRec.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -109,1 +109,0 @@\n-                      bool        is_optimized_linkToNative = false,\n","filename":"src\/hotspot\/share\/code\/debugInfoRec.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -47,2 +47,1 @@\n-    PCDESC_arg_escape                = 1 << 5,\n-    PCDESC_is_optimized_linkToNative = 1 << 6\n+    PCDESC_arg_escape                = 1 << 5\n@@ -92,3 +91,0 @@\n-  bool     is_optimized_linkToNative()     const { return (_flags & PCDESC_is_optimized_linkToNative) != 0;     }\n-  void set_is_optimized_linkToNative(bool z)     { set_flag(PCDESC_is_optimized_linkToNative, z); }\n-\n","filename":"src\/hotspot\/share\/code\/pcDesc.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-  bool _is_optimized_linkToNative;\n@@ -49,1 +48,0 @@\n-    _is_optimized_linkToNative = pc_desc->is_optimized_linkToNative();\n@@ -58,1 +56,0 @@\n-  bool is_optimized_linkToNative() { return _is_optimized_linkToNative; }\n","filename":"src\/hotspot\/share\/code\/scopeDesc.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1064,1 +1064,0 @@\n-  const bool is_opt_native         = false;\n@@ -1067,1 +1066,1 @@\n-  _debug_recorder->describe_scope(pc_offset, method, NULL, bci, reexecute, throw_exception, is_mh_invoke, is_opt_native, return_oop,\n+  _debug_recorder->describe_scope(pc_offset, method, NULL, bci, reexecute, throw_exception, is_mh_invoke, return_oop,\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-#include \"ci\/ciNativeEntryPoint.hpp\"\n@@ -1069,25 +1068,0 @@\n-class NativeCallGenerator : public CallGenerator {\n-private:\n-  address _call_addr;\n-  ciNativeEntryPoint* _nep;\n-public:\n-  NativeCallGenerator(ciMethod* m, address call_addr, ciNativeEntryPoint* nep)\n-   : CallGenerator(m), _call_addr(call_addr), _nep(nep) {}\n-\n-  virtual JVMState* generate(JVMState* jvms);\n-};\n-\n-JVMState* NativeCallGenerator::generate(JVMState* jvms) {\n-  GraphKit kit(jvms);\n-\n-  Node* call = kit.make_native_call(_call_addr, tf(), method()->arg_size(), _nep); \/\/ -fallback, - nep\n-  if (call == NULL) return NULL;\n-\n-  kit.C->print_inlining_update(this);\n-  if (kit.C->log() != NULL) {\n-    kit.C->log()->elem(\"l2n_intrinsification_success bci='%d' entry_point='\" INTPTR_FORMAT \"'\", jvms->bci(), p2i(_call_addr));\n-  }\n-\n-  return kit.transfer_exceptions_into_jvms();\n-}\n-\n@@ -1220,24 +1194,2 @@\n-    {\n-      Node* addr_n = kit.argument(0); \/\/ target address\n-      Node* nep_n = kit.argument(callee->arg_size() - 1); \/\/ NativeEntryPoint\n-      \/\/ This check needs to be kept in sync with the one in CallStaticJavaNode::Ideal\n-      if (addr_n->Opcode() == Op_ConL && nep_n->Opcode() == Op_ConP) {\n-        input_not_const = false;\n-\n-        const TypeOopPtr* nep_t = nep_n->bottom_type()->is_oopptr();\n-        ciNativeEntryPoint* nep = nep_t->const_oop()->as_native_entry_point();\n-\n-        if (!nep->need_transition()) {\n-          const TypeLong* addr_t = addr_n->bottom_type()->is_long();\n-          address addr = (address) addr_t->get_con();\n-\n-          return new NativeCallGenerator(callee, addr, nep);\n-        } else {\n-          print_inlining_failure(C, callee, jvms->depth() - 1, jvms->bci(),\n-                        \"Not inlining non-trivial call\");\n-        }\n-      } else {\n-        print_inlining_failure(C, callee, jvms->depth() - 1, jvms->bci(),\n-                               \"NativeEntryPoint or address not constant\");\n-      }\n-    }\n+    print_inlining_failure(C, callee, jvms->depth() - 1, jvms->bci(),\n+                           \"native call\");\n@@ -1253,1 +1205,0 @@\n-\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":2,"deletions":51,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"ci\/ciNativeEntryPoint.hpp\"\n@@ -1087,7 +1086,1 @@\n-      Node* nep_node = in(TypeFunc::Parms + callee->arg_size() - 1);\n-      if (nep_node->Opcode() == Op_ConP \/* NEP *\/\n-          && in(TypeFunc::Parms + 0)->Opcode() == Op_ConL \/* address *\/\n-          && !nep_node->bottom_type()->is_oopptr()->const_oop()->as_native_entry_point()->need_transition()) {\n-        phase->C->prepend_late_inline(cg);\n-        set_generator(NULL);\n-      }\n+      \/\/ never retry\n@@ -1229,65 +1222,0 @@\n-\/\/=============================================================================\n-uint CallNativeNode::size_of() const { return sizeof(*this); }\n-bool CallNativeNode::cmp( const Node &n ) const {\n-  CallNativeNode &call = (CallNativeNode&)n;\n-  return CallNode::cmp(call) && !strcmp(_name,call._name)\n-    && _arg_regs == call._arg_regs && _ret_regs == call._ret_regs;\n-}\n-Node* CallNativeNode::match(const ProjNode *proj, const Matcher *matcher) {\n-  switch (proj->_con) {\n-    case TypeFunc::Control:\n-    case TypeFunc::I_O:\n-    case TypeFunc::Memory:\n-      return new MachProjNode(this,proj->_con,RegMask::Empty,MachProjNode::unmatched_proj);\n-    case TypeFunc::ReturnAdr:\n-    case TypeFunc::FramePtr:\n-      ShouldNotReachHere();\n-    case TypeFunc::Parms: {\n-      const Type* field_at_con = tf()->range()->field_at(proj->_con);\n-      const BasicType bt = field_at_con->basic_type();\n-      OptoReg::Name optoreg = OptoReg::as_OptoReg(_ret_regs.at(proj->_con - TypeFunc::Parms));\n-      OptoRegPair regs;\n-      if (bt == T_DOUBLE || bt == T_LONG) {\n-        regs.set2(optoreg);\n-      } else {\n-        regs.set1(optoreg);\n-      }\n-      RegMask rm = RegMask(regs.first());\n-      if(OptoReg::is_valid(regs.second()))\n-        rm.Insert(regs.second());\n-      return new MachProjNode(this, proj->_con, rm, field_at_con->ideal_reg());\n-    }\n-    case TypeFunc::Parms + 1: {\n-      assert(tf()->range()->field_at(proj->_con) == Type::HALF, \"Expected HALF\");\n-      assert(_ret_regs.at(proj->_con - TypeFunc::Parms) == VMRegImpl::Bad(), \"Unexpected register for Type::HALF\");\n-      \/\/ 2nd half of doubles and longs\n-      return new MachProjNode(this, proj->_con, RegMask::Empty, (uint) OptoReg::Bad);\n-    }\n-    default:\n-      ShouldNotReachHere();\n-  }\n-  return NULL;\n-}\n-#ifndef PRODUCT\n-void CallNativeNode::print_regs(const GrowableArray<VMReg>& regs, outputStream* st) {\n-  st->print(\"{ \");\n-  for (int i = 0; i < regs.length(); i++) {\n-    regs.at(i)->print_on(st);\n-    if (i < regs.length() - 1) {\n-      st->print(\", \");\n-    }\n-  }\n-  st->print(\" } \");\n-}\n-\n-void CallNativeNode::dump_spec(outputStream *st) const {\n-  st->print(\"# \");\n-  st->print(\"%s \", _name);\n-  st->print(\"_arg_regs: \");\n-  print_regs(_arg_regs, st);\n-  st->print(\"_ret_regs: \");\n-  print_regs(_ret_regs, st);\n-  CallNode::dump_spec(st);\n-}\n-#endif\n-\n@@ -1314,34 +1242,0 @@\n-void CallNativeNode::calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const {\n-  assert((tf()->domain()->cnt() - TypeFunc::Parms) == argcnt, \"arg counts must match!\");\n-#ifdef ASSERT\n-  for (uint i = 0; i < argcnt; i++) {\n-    assert(tf()->domain()->field_at(TypeFunc::Parms + i)->basic_type() == sig_bt[i], \"types must match!\");\n-  }\n-#endif\n-  for (uint i = 0; i < argcnt; i++) {\n-    switch (sig_bt[i]) {\n-      case T_BOOLEAN:\n-      case T_CHAR:\n-      case T_BYTE:\n-      case T_SHORT:\n-      case T_INT:\n-      case T_FLOAT:\n-        parm_regs[i].set1(_arg_regs.at(i));\n-        break;\n-      case T_LONG:\n-      case T_DOUBLE:\n-        assert((i + 1) < argcnt && sig_bt[i + 1] == T_VOID, \"expecting half\");\n-        parm_regs[i].set2(_arg_regs.at(i));\n-        break;\n-      case T_VOID: \/\/ Halves of longs and doubles\n-        assert(i != 0 && (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), \"expecting half\");\n-        assert(_arg_regs.at(i) == VMRegImpl::Bad(), \"expecting bad reg\");\n-        parm_regs[i].set_bad();\n-        break;\n-      default:\n-        ShouldNotReachHere();\n-        break;\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":1,"deletions":107,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-class     CallNativeNode;\n@@ -826,33 +825,0 @@\n-\n-\/\/------------------------------CallNativeNode-----------------------------------\n-\/\/ Make a direct call into a foreign function with an arbitrary ABI\n-\/\/ safepoints\n-class CallNativeNode : public CallNode {\n-  friend class MachCallNativeNode;\n-  virtual bool cmp( const Node &n ) const;\n-  virtual uint size_of() const;\n-  static void print_regs(const GrowableArray<VMReg>& regs, outputStream* st);\n-public:\n-  GrowableArray<VMReg> _arg_regs;\n-  GrowableArray<VMReg> _ret_regs;\n-  const int _shadow_space_bytes;\n-\n-  CallNativeNode(const TypeFunc* tf, address addr, const char* name,\n-                 const TypePtr* adr_type,\n-                 const GrowableArray<VMReg>& arg_regs,\n-                 const GrowableArray<VMReg>& ret_regs,\n-                 int shadow_space_bytes)\n-    : CallNode(tf, addr, adr_type), _arg_regs(arg_regs),\n-      _ret_regs(ret_regs), _shadow_space_bytes(shadow_space_bytes)\n-  {\n-    init_class_id(Class_CallNative);\n-    _name = name;\n-  }\n-  virtual int   Opcode() const;\n-  virtual bool  guaranteed_safepoint()  { return false; }\n-  virtual Node* match(const ProjNode *proj, const Matcher *m);\n-  virtual void  calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const;\n-#ifndef PRODUCT\n-  virtual void  dump_spec(outputStream *st) const;\n-#endif\n-};\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":0,"deletions":34,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -64,1 +64,0 @@\n-macro(CallNative)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3049,1 +3049,0 @@\n-  case Op_CallNative:\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"ci\/ciNativeEntryPoint.hpp\"\n@@ -2593,100 +2592,0 @@\n-\/\/-----------------------------make_native_call-------------------------------\n-Node* GraphKit::make_native_call(address call_addr, const TypeFunc* call_type, uint nargs, ciNativeEntryPoint* nep) {\n-  assert(!nep->need_transition(), \"only trivial calls\");\n-\n-  \/\/ Select just the actual call args to pass on\n-  \/\/ [long addr, HALF addr, ... args , NativeEntryPoint nep]\n-  \/\/                      |          |\n-  \/\/                      V          V\n-  \/\/                      [ ... args ]\n-  uint n_filtered_args = nargs - 3; \/\/ -addr (2), -nep;\n-  ResourceMark rm;\n-  Node** argument_nodes = NEW_RESOURCE_ARRAY(Node*, n_filtered_args);\n-  const Type** arg_types = TypeTuple::fields(n_filtered_args);\n-  GrowableArray<VMReg> arg_regs(C->comp_arena(), n_filtered_args, n_filtered_args, VMRegImpl::Bad());\n-\n-  VMReg* argRegs = nep->argMoves();\n-  {\n-    for (uint vm_arg_pos = 0, java_arg_read_pos = 0;\n-        vm_arg_pos < n_filtered_args; vm_arg_pos++) {\n-      uint vm_unfiltered_arg_pos = vm_arg_pos + 2; \/\/ +2 to skip addr (2 since long)\n-      Node* node = argument(vm_unfiltered_arg_pos);\n-      const Type* type = call_type->domain()->field_at(TypeFunc::Parms + vm_unfiltered_arg_pos);\n-      VMReg reg = type == Type::HALF\n-        ? VMRegImpl::Bad()\n-        : argRegs[java_arg_read_pos++];\n-\n-      argument_nodes[vm_arg_pos] = node;\n-      arg_types[TypeFunc::Parms + vm_arg_pos] = type;\n-      arg_regs.at_put(vm_arg_pos, reg);\n-    }\n-  }\n-\n-  uint n_returns = call_type->range()->cnt() - TypeFunc::Parms;\n-  GrowableArray<VMReg> ret_regs(C->comp_arena(), n_returns, n_returns, VMRegImpl::Bad());\n-  const Type** ret_types = TypeTuple::fields(n_returns);\n-\n-  VMReg* retRegs = nep->returnMoves();\n-  {\n-    for (uint vm_ret_pos = 0, java_ret_read_pos = 0;\n-        vm_ret_pos < n_returns; vm_ret_pos++) { \/\/ 0 or 1\n-      const Type* type = call_type->range()->field_at(TypeFunc::Parms + vm_ret_pos);\n-      VMReg reg = type == Type::HALF\n-        ? VMRegImpl::Bad()\n-        : retRegs[java_ret_read_pos++];\n-\n-      ret_regs.at_put(vm_ret_pos, reg);\n-      ret_types[TypeFunc::Parms + vm_ret_pos] = type;\n-    }\n-  }\n-\n-  const TypeFunc* new_call_type = TypeFunc::make(\n-    TypeTuple::make(TypeFunc::Parms + n_filtered_args, arg_types),\n-    TypeTuple::make(TypeFunc::Parms + n_returns, ret_types)\n-  );\n-\n-  CallNode* call = new CallNativeNode(new_call_type, call_addr, nep->name(), TypePtr::BOTTOM,\n-                            arg_regs,\n-                            ret_regs,\n-                            nep->shadow_space());\n-\n-  assert(call != nullptr, \"'call' was not set\");\n-\n-  set_predefined_input_for_runtime_call(call);\n-\n-  for (uint i = 0; i < n_filtered_args; i++) {\n-    call->init_req(i + TypeFunc::Parms, argument_nodes[i]);\n-  }\n-\n-  Node* c = gvn().transform(call);\n-  assert(c == call, \"cannot disappear\");\n-\n-  set_predefined_output_for_runtime_call(call);\n-\n-  Node* ret;\n-  if (method() == NULL || method()->return_type()->basic_type() == T_VOID) {\n-    ret = top();\n-  } else {\n-    ret =  gvn().transform(new ProjNode(call, TypeFunc::Parms));\n-    \/\/ Unpack native results if needed\n-    \/\/ Need this method type since it's unerased\n-    switch (nep->method_type()->rtype()->basic_type()) {\n-      case T_CHAR:\n-        ret = _gvn.transform(new AndINode(ret, _gvn.intcon(0xFFFF)));\n-        break;\n-      case T_BYTE:\n-        ret = sign_extend_byte(ret);\n-        break;\n-      case T_SHORT:\n-        ret = sign_extend_short(ret);\n-        break;\n-      default: \/\/ do nothing\n-        break;\n-    }\n-  }\n-\n-  push_node(method()->return_type()->basic_type(), ret);\n-\n-  return call;\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":0,"deletions":101,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -810,2 +810,0 @@\n-  Node* make_native_call(address call_addr, const TypeFunc* call_type, uint nargs, ciNativeEntryPoint* nep);\n-\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -884,6 +884,0 @@\n-    case Op_CallNative:\n-      \/\/ We use the c reg save policy here since Foreign Linker\n-      \/\/ only supports the C ABI currently.\n-      \/\/ TODO compute actual save policy based on nep->abi\n-      save_policy = _matcher._c_reg_save_policy;\n-      break;\n@@ -909,2 +903,1 @@\n-  bool exclude_soe = op == Op_CallRuntime\n-    || (op == Op_CallNative && mcall->guaranteed_safepoint());\n+  bool exclude_soe = op == Op_CallRuntime;\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -823,17 +823,0 @@\n-uint MachCallNativeNode::size_of() const { return sizeof(*this); }\n-bool MachCallNativeNode::cmp( const Node &n ) const {\n-  MachCallNativeNode &call = (MachCallNativeNode&)n;\n-  return MachCallNode::cmp(call) && !strcmp(_name,call._name)\n-    && _arg_regs == call._arg_regs && _ret_regs == call._ret_regs;\n-}\n-#ifndef PRODUCT\n-void MachCallNativeNode::dump_spec(outputStream *st) const {\n-  st->print(\"%s \",_name);\n-  st->print(\"_arg_regs: \");\n-  CallNativeNode::print_regs(_arg_regs, st);\n-  st->print(\"_ret_regs: \");\n-  CallNativeNode::print_regs(_ret_regs, st);\n-  MachCallNode::dump_spec(st);\n-}\n-#endif\n-\/\/=============================================================================\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-class MachCallNativeNode;\n@@ -1022,19 +1021,0 @@\n-class MachCallNativeNode: public MachCallNode {\n-  virtual bool cmp( const Node &n ) const;\n-  virtual uint size_of() const;\n-  void print_regs(const GrowableArray<VMReg>& regs, outputStream* st) const;\n-public:\n-  const char *_name;\n-  GrowableArray<VMReg> _arg_regs;\n-  GrowableArray<VMReg> _ret_regs;\n-\n-  MachCallNativeNode() : MachCallNode() {\n-    init_class_id(Class_MachCallNative);\n-  }\n-\n-  virtual int ret_addr_offset();\n-#ifndef PRODUCT\n-  virtual void dump_spec(outputStream *st) const;\n-#endif\n-};\n-\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1309,7 +1309,0 @@\n-    else if( mcall->is_MachCallNative() ) {\n-      MachCallNativeNode* mach_call_native = mcall->as_MachCallNative();\n-      CallNativeNode* call_native = call->as_CallNative();\n-      mach_call_native->_name = call_native->_name;\n-      mach_call_native->_arg_regs = call_native->_arg_regs;\n-      mach_call_native->_ret_regs = call_native->_ret_regs;\n-    }\n@@ -1350,2 +1343,0 @@\n-  if( call != NULL && call->is_CallNative() )\n-    out_arg_limit_per_call = OptoReg::add(out_arg_limit_per_call, call->as_CallNative()->_shadow_space_bytes);\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-class CallNativeNode;\n@@ -107,1 +106,0 @@\n-class MachCallNativeNode;\n@@ -655,1 +653,0 @@\n-          DEFINE_CLASS_ID(CallNative,       Call, 5)\n@@ -681,1 +678,0 @@\n-            DEFINE_CLASS_ID(MachCallNative,       MachCall, 2)\n@@ -853,1 +849,0 @@\n-  DEFINE_CLASS_QUERY(CallNative)\n@@ -899,1 +894,0 @@\n-  DEFINE_CLASS_QUERY(MachCallNative)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1006,1 +1006,0 @@\n-  bool is_opt_native = false;\n@@ -1025,2 +1024,0 @@\n-    } else if (mcall->is_MachCallNative()) {\n-      is_opt_native = true;\n@@ -1156,1 +1153,0 @@\n-      is_opt_native,\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -64,0 +64,4 @@\n+VMReg ForeignGlobals::parse_vmstorage(oop storage) {\n+  return instance().parse_vmstorage_impl(storage);\n+}\n+\n@@ -118,1 +122,1 @@\n-VMReg ForeignGlobals::parse_vmstorage(oop storage) const {\n+VMReg ForeignGlobals::parse_vmstorage_impl(oop storage) const {\n","filename":"src\/hotspot\/share\/prims\/foreign_globals.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -79,2 +79,1 @@\n-\n-  VMReg parse_vmstorage(oop storage) const;\n+  VMReg parse_vmstorage_impl(oop storage) const;\n@@ -84,1 +83,0 @@\n-\n@@ -86,0 +84,1 @@\n+  static VMReg parse_vmstorage(oop storage);\n","filename":"src\/hotspot\/share\/prims\/foreign_globals.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -37,4 +37,0 @@\n-JNI_LEAF(jlong, NEP_vmStorageToVMReg(JNIEnv* env, jclass _unused, jint type, jint index))\n-  return ForeignGlobals::vmstorage_to_vmreg(type, index)->value();\n-JNI_END\n-\n@@ -42,1 +38,1 @@\n-                                 jlongArray arg_moves, jlongArray ret_moves, jboolean needs_return_buffer))\n+                                 jobjectArray arg_moves, jobjectArray ret_moves, jboolean needs_return_buffer))\n@@ -47,2 +43,2 @@\n-  typeArrayOop arg_moves_oop = oop_cast<typeArrayOop>(JNIHandles::resolve(arg_moves));\n-  typeArrayOop ret_moves_oop = oop_cast<typeArrayOop>(JNIHandles::resolve(ret_moves));\n+  objArrayOop arg_moves_oop = oop_cast<objArrayOop>(JNIHandles::resolve(arg_moves));\n+  objArrayOop ret_moves_oop = oop_cast<objArrayOop>(JNIHandles::resolve(ret_moves));\n@@ -59,1 +55,1 @@\n-    input_regs.push(VMRegImpl::as_VMReg(arg_moves_oop->long_at(i)));\n+    input_regs.push(ForeignGlobals::parse_vmstorage(arg_moves_oop->obj_at(i)));\n@@ -77,1 +73,1 @@\n-    output_regs.push(VMRegImpl::as_VMReg(ret_moves_oop->long_at(i)));\n+    output_regs.push(ForeignGlobals::parse_vmstorage(ret_moves_oop->obj_at(i)));\n@@ -116,2 +112,1 @@\n-  {CC \"vmStorageToVMReg\", CC \"(II)J\", FN_PTR(NEP_vmStorageToVMReg)},\n-  {CC \"makeInvoker\", CC \"(Ljava\/lang\/invoke\/MethodType;Ljdk\/internal\/invoke\/ABIDescriptorProxy;[J[JZ)J\", FN_PTR(NEP_makeInvoker)},\n+  {CC \"makeInvoker\", CC \"(Ljava\/lang\/invoke\/MethodType;Ljdk\/internal\/invoke\/ABIDescriptorProxy;[Ljdk\/internal\/invoke\/VMStorageProxy;[Ljdk\/internal\/invoke\/VMStorageProxy;Z)J\", FN_PTR(NEP_makeInvoker)},\n","filename":"src\/hotspot\/share\/prims\/nativeEntryPoint.cpp","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-friend class CallNativeDirectNode;\n","filename":"src\/hotspot\/share\/runtime\/javaFrameAnchor.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1496,1 +1496,0 @@\n-  declare_c2_type(CallNativeNode, CallNode)                               \\\n@@ -1615,1 +1614,0 @@\n-  declare_c2_type(MachCallNativeNode, MachCallNode)                       \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.util.Objects;\n@@ -36,2 +35,1 @@\n- * This class describes a native call, including arguments\/return shuffle moves, PC entry point and\n- * various other info which are relevant when the call will be intrinsified by C2.\n+ * This class describes a 'native invoker', which is used as an appendix argument to linkToNative calls.\n@@ -44,10 +42,1 @@\n-    private final int shadowSpace;\n-\n-    \/\/ encoded as VMRegImpl*\n-    private final long[] argMoves;\n-    private final long[] returnMoves;\n-\n-    private final boolean needTransition;\n-    private final MethodType methodType; \/\/ C2 sees erased version (byte -> int), so need this explicitly\n-    private final String name;\n-\n+    private final MethodType methodType;\n@@ -57,2 +46,3 @@\n-    private record CacheKey(MethodType mt, int shadowSpaceBytes,\n-                            List<VMStorageProxy> argMoves, List<VMStorageProxy> retMoves) {}\n+    private record CacheKey(MethodType methodType, ABIDescriptorProxy abi,\n+                            List<VMStorageProxy> argMoves, List<VMStorageProxy> retMoves,\n+                            boolean needsReturnBuffer) {}\n@@ -60,6 +50,1 @@\n-    private NativeEntryPoint(int shadowSpace, long[] argMoves, long[] returnMoves,\n-                     boolean needTransition, MethodType methodType, String name, long invoker) {\n-        this.shadowSpace = shadowSpace;\n-        this.argMoves = Objects.requireNonNull(argMoves);\n-        this.returnMoves = Objects.requireNonNull(returnMoves);\n-        this.needTransition = needTransition;\n+    private NativeEntryPoint(MethodType methodType, long invoker) {\n@@ -67,1 +52,0 @@\n-        this.name = name;\n@@ -71,1 +55,1 @@\n-    public static NativeEntryPoint make(String name, ABIDescriptorProxy abi,\n+    public static NativeEntryPoint make(ABIDescriptorProxy abi,\n@@ -73,1 +57,1 @@\n-                                        boolean needTransition, MethodType methodType, boolean needsReturnBuffer) {\n+                                        MethodType methodType, boolean needsReturnBuffer) {\n@@ -79,5 +63,1 @@\n-        assert (!needsReturnBuffer || methodType.parameterType(1) == long.class) : \"IMR address expected\";\n-\n-        int shadowSpaceBytes = abi.shadowSpaceBytes();\n-        long[] encArgMoves = encodeVMStorages(argMoves);\n-        long[] encRetMoves = encodeVMStorages(returnMoves);\n+        assert (!needsReturnBuffer || methodType.parameterType(1) == long.class) : \"return buffer address expected\";\n@@ -85,2 +65,1 @@\n-        CacheKey key = new CacheKey(methodType, abi.shadowSpaceBytes(),\n-                Arrays.asList(argMoves), Arrays.asList(returnMoves));\n+        CacheKey key = new CacheKey(methodType, abi, Arrays.asList(argMoves), Arrays.asList(returnMoves), needsReturnBuffer);\n@@ -88,1 +67,1 @@\n-            makeInvoker(methodType, abi, encArgMoves, encRetMoves, needsReturnBuffer));\n+            makeInvoker(methodType, abi, argMoves, returnMoves, needsReturnBuffer));\n@@ -90,2 +69,1 @@\n-        return new NativeEntryPoint(shadowSpaceBytes, encArgMoves, encRetMoves,\n-                needTransition, methodType, name, invoker);\n+        return new NativeEntryPoint(methodType, invoker);\n@@ -94,11 +72,3 @@\n-    private static long[] encodeVMStorages(VMStorageProxy[] moves) {\n-        long[] out = new long[moves.length];\n-        for (int i = 0; i < moves.length; i++) {\n-            out[i] = vmStorageToVMReg(moves[i].type(), moves[i].index());\n-        }\n-        return out;\n-    }\n-\n-    private static native long vmStorageToVMReg(int type, int index);\n-\n-    private static native long makeInvoker(MethodType methodType, ABIDescriptorProxy abi, long[] encArgMoves, long[] encRetMoves, boolean needsReturnBuffer);\n+    private static native long makeInvoker(MethodType methodType, ABIDescriptorProxy abi,\n+                                           VMStorageProxy[] encArgMoves, VMStorageProxy[] encRetMoves,\n+                                           boolean needsReturnBuffer);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/invoke\/NativeEntryPoint.java","additions":15,"deletions":45,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-    private final boolean isTrivial;\n@@ -45,1 +44,1 @@\n-                           boolean isTrivial, boolean needsReturnBuffer, long returnBufferSize, long allocationSize,\n+                           boolean needsReturnBuffer, long returnBufferSize, long allocationSize,\n@@ -49,1 +48,0 @@\n-        this.isTrivial = isTrivial;\n@@ -99,4 +97,0 @@\n-    public boolean isTrivial() {\n-        return isTrivial;\n-    }\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequence.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-    private boolean isTrivial;\n@@ -86,5 +85,0 @@\n-    public CallingSequenceBuilder setTrivial(boolean isTrivial) {\n-        this.isTrivial = isTrivial;\n-        return this;\n-    }\n-\n@@ -116,1 +110,1 @@\n-        return new CallingSequence(mt, desc, isTrivial, needsReturnBuffer, returnBufferSize, allocationSize, inputBindings, outputBindings);\n+        return new CallingSequence(mt, desc, needsReturnBuffer, returnBufferSize, allocationSize, inputBindings, outputBindings);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequenceBuilder.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -108,1 +108,0 @@\n-            \"native_invoker_\" + leafType.descriptorString(),\n@@ -112,1 +111,0 @@\n-            !callingSequence.isTrivial(),\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableInvoker.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -624,4 +624,0 @@\n-    public static boolean isTrivial(FunctionDescriptor cDesc) {\n-        return false; \/\/ FIXME: use system property?\n-    }\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -145,2 +145,0 @@\n-        csb.setTrivial(SharedUtils.isTrivial(cDesc));\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -120,2 +120,0 @@\n-        csb.setTrivial(SharedUtils.isTrivial(cDesc));\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -121,2 +121,0 @@\n-        csb.csb.setTrivial(SharedUtils.isTrivial(cDesc));\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}