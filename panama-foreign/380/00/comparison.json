{"files":[{"patch":"@@ -223,1 +223,1 @@\n-                    methodType(MemorySegment.class, MemoryAddress.class, long.class));\n+                    methodType(MemorySegment.class, MemoryAddress.class, long.class, SharedUtils.Allocator.class));\n@@ -840,1 +840,1 @@\n-     * Box_ADDRESS()\n+     * BOX_ADDRESS()\n@@ -910,2 +910,2 @@\n-     * BASE_ADDRESS([size])\n-     *   Pops a MemoryAddress from the operand stack, and takes the converts it to a MemorySegment\n+     * TO_SEGMENT([size])\n+     *   Pops a MemoryAddress from the operand stack, and converts it to a MemorySegment\n@@ -924,2 +924,3 @@\n-        private static MemorySegment toSegment(MemoryAddress operand, long size) {\n-            return MemoryAddressImpl.ofLongUnchecked(operand.toRawLongValue(), size);\n+        private static MemorySegment toSegment(MemoryAddress operand, long size, SharedUtils.Allocator allocator) {\n+            MemorySegment ms = MemoryAddressImpl.ofLongUnchecked(operand.toRawLongValue(), size);\n+            return allocator.handoff(ms);\n@@ -939,1 +940,1 @@\n-            MemorySegment segment = toSegment(operand, size);\n+            MemorySegment segment = toSegment(operand, size, allocator);\n@@ -946,1 +947,2 @@\n-            return filterArguments(specializedHandle, insertPos, toSegmentHandle);\n+            specializedHandle = filterArguments(specializedHandle, insertPos, toSegmentHandle);\n+            return Binding.mergeArguments(specializedHandle, allocatorPos, insertPos + 1);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.incubator.foreign.NativeScope;\n@@ -85,1 +86,2 @@\n-        try {\n+        try (NativeScope scope = NativeScope.unboundedScope()) { \/\/ TODO exact size\n+            SharedUtils.Allocator allocator = SharedUtils.Allocator.ofScope(scope);\n@@ -102,1 +104,1 @@\n-                        }, DEFAULT_ALLOCATOR);\n+                        }, allocator);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -382,0 +382,4 @@\n+        default MemorySegment handoff(MemorySegment ms) {\n+            return ms;\n+        }\n+\n@@ -391,0 +395,5 @@\n+                @Override\n+                public MemorySegment handoff(MemorySegment ms) {\n+                    return ms.handoff(scope);\n+                }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -410,3 +410,0 @@\n-                    \/\/ ASSERT SCOPE OF BOXED ADDRESS HERE\n-                    \/\/ caveat. buffer should instead go out of scope after call\n-                    bindings.copy(layout);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -282,3 +282,0 @@\n-                    \/\/ ASSERT SCOPE OF BOXED ADDRESS HERE\n-                    \/\/ caveat. buffer should instead go out of scope after call\n-                    bindings.copy(layout);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -341,1 +341,3 @@\n-            Cursor cursor = new Cursor(c);\n+            MemorySegment copy = MemorySegment.allocateNative(c.byteSize());\n+            copy.copyFrom(c);\n+            Cursor cursor = new Cursor(copy);\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/Cursor.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -88,1 +88,2 @@\n-            PASS_AND_SAVE = MethodHandles.lookup().findStatic(TestUpcall.class, \"passAndSave\", MethodType.methodType(Object.class, Object[].class, AtomicReference.class));\n+            PASS_AND_SAVE = MethodHandles.lookup().findStatic(TestUpcall.class, \"passAndSave\",\n+                    MethodType.methodType(Object.class, Object[].class, AtomicReference.class, List.class));\n@@ -158,1 +159,1 @@\n-        MethodHandle mh = insertArguments(PASS_AND_SAVE, 1, box);\n+        MethodHandle mh = insertArguments(PASS_AND_SAVE, 1, box, segments);\n@@ -196,1 +197,10 @@\n-    static Object passAndSave(Object[] o, AtomicReference<Object[]> ref) {\n+    static Object passAndSave(Object[] o, AtomicReference<Object[]> ref, List<MemorySegment> copies) {\n+        for (int i = 0; i < o.length; i++) {\n+            if (o[i] instanceof MemorySegment) {\n+                MemorySegment ms = (MemorySegment) o[i];\n+                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize());\n+                copy.copyFrom(ms);\n+                o[i] = copy;\n+                copies.add(copy);\n+            }\n+        }\n","filename":"test\/jdk\/java\/foreign\/TestUpcall.java","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-                    MethodType.methodType(void.class, Object[].class, AtomicReference.class));\n+                    MethodType.methodType(void.class, Object[].class, AtomicReference.class, List.class));\n@@ -107,1 +107,10 @@\n-    static void passAndSave(Object[] o, AtomicReference<Object[]> ref) {\n+    static void passAndSave(Object[] o, AtomicReference<Object[]> ref, List<MemorySegment> copies) {\n+        for (int i = 0; i < o.length; i++) {\n+            if (o[i] instanceof MemorySegment) {\n+                MemorySegment ms = (MemorySegment) o[i];\n+                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize());\n+                copy.copyFrom(ms);\n+                o[i] = copy;\n+                copies.add(copy);\n+            }\n+        }\n@@ -114,0 +123,1 @@\n+        List<MemorySegment> segments = new ArrayList<>();\n@@ -115,1 +125,1 @@\n-        MethodHandle target = MethodHandles.insertArguments(MH_passAndSave, 1, capturedArgs)\n+        MethodHandle target = MethodHandles.insertArguments(MH_passAndSave, 1, capturedArgs, segments)\n@@ -119,1 +129,0 @@\n-            List<MemorySegment> segments = new ArrayList<>();\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"}]}