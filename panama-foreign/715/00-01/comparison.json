{"files":[{"patch":"@@ -53,1 +53,1 @@\n-     * through the provided {@linkplain MemoryLayout layout} using the provided {@linkplain ValueLayoutRenderer renderer}.\n+     * through the provided {@linkplain MemoryLayout layout} using the provided {@code renderer}.\n@@ -86,1 +86,1 @@\n-                                         ValueLayoutRenderer renderer) {\n+                                         BiFunction<ValueLayout, Object, String> renderer) {\n@@ -94,2 +94,2 @@\n-     * An interface that can be used to specify custom rendering of value\n-     * layouts via the {@link MemoryInspection#inspect(MemorySegment, MemoryLayout, ValueLayoutRenderer)} method.\n+     * {@return a standard value layout renderer that will render numeric values into decimal form and where\n+     * other value types are rendered to a reasonable \"natural\" form}\n@@ -97,1 +97,1 @@\n-     * The render methods take two parameters:\n+     * More specifically, values types are rendered as follows:\n@@ -99,2 +99,5 @@\n-     *     <li>layout: This can be used to select different formatting for different paths<\/li>\n-     *     <li>value: The actual value<\/li>\n+     *     <li>Numeric values are rendered in decimal form (e.g 1 or 1.2).<\/li>\n+     *     <li>Boolean values are rendered as {@code true} or {@code false}.<\/li>\n+     *     <li>Character values are rendered as {@code char}.<\/li>\n+     *     <li>Address values are rendered in hexadecimal form e.g. {@code 0x0000000000000000} (on 64-bit platforms) or\n+     *     {@code 0x00000000} (on 32-bit platforms)<\/li>\n@@ -102,5 +105,0 @@\n-     * <p>\n-     * The {@linkplain ValueLayoutRenderer#standard() standard() } value layout renderer is path\n-     * agnostic and will thus render all layouts of the same type the same way.\n-     *\n-     * @see MemoryInspection#inspect(MemorySegment, MemoryLayout, ValueLayoutRenderer)\n@@ -108,134 +106,2 @@\n-    public interface ValueLayoutRenderer {\n-        \/**\n-         * Renders the provided {@code booleanLayout} and {@code value} to a String.\n-         *\n-         * @param booleanLayout the layout to render\n-         * @param value         the value to render\n-         * @return rendered String\n-         *\/\n-        default String render(ValueLayout.OfBoolean booleanLayout, boolean value) {\n-            requireNonNull(booleanLayout);\n-            return Boolean.toString(value);\n-        }\n-\n-        \/**\n-         * Renders the provided {@code byteLayout} and {@code value} to a String.\n-         *\n-         * @param byteLayout the layout to render\n-         * @param value         the value to render\n-         * @return rendered String\n-         *\/\n-        default String render(ValueLayout.OfByte byteLayout, byte value) {\n-            requireNonNull(byteLayout);\n-            return Byte.toString(value);\n-        }\n-\n-        \/**\n-         * Renders the provided {@code charLayout} and {@code value} to a String.\n-         *\n-         * @param charLayout the layout to render\n-         * @param value      the value to render\n-         * @return rendered String\n-         *\/\n-        default String render(ValueLayout.OfChar charLayout, char value) {\n-            requireNonNull(charLayout);\n-            return Character.toString(value);\n-        }\n-\n-        \/**\n-         * Renders the provided {@code shortLayout} and {@code value} to a String.\n-         *\n-         * @param shortLayout the layout to render\n-         * @param value       the value to render\n-         * @return rendered String\n-         *\/\n-        default String render(ValueLayout.OfShort shortLayout, short value) {\n-            requireNonNull(shortLayout);\n-            return Short.toString(value);\n-        }\n-\n-        \/**\n-         * Renders the provided {@code intLayout} and {@code value} to a String.\n-         *\n-         * @param intLayout the layout to render\n-         * @param value     the value to render\n-         * @return rendered String\n-         *\/\n-        default String render(ValueLayout.OfInt intLayout, int value) {\n-            requireNonNull(intLayout);\n-            return Integer.toString(value);\n-        }\n-\n-        \/**\n-         * Renders the provided {@code longLayout} and {@code value} to a String.\n-         *\n-         * @param longLayout the layout to render\n-         * @param value      the value to render\n-         * @return rendered String\n-         *\/\n-        default String render(ValueLayout.OfLong longLayout, long value) {\n-            requireNonNull(longLayout);\n-            return Long.toString(value);\n-        }\n-\n-        \/**\n-         * Renders the provided {@code floatLayout} and {@code value} to a String.\n-         *\n-         * @param floatLayout the layout to render\n-         * @param value       the value to render\n-         * @return rendered String\n-         *\/\n-        default String render(ValueLayout.OfFloat floatLayout, float value) {\n-            requireNonNull(floatLayout);\n-            return Float.toString(value);\n-        }\n-\n-        \/**\n-         * Renders the provided {@code doubleLayout} and {@code value} to a String.\n-         *\n-         * @param doubleLayout the layout to render\n-         * @param value        the value to render\n-         * @return rendered String\n-         *\/\n-        default String render(ValueLayout.OfDouble doubleLayout, double value) {\n-            requireNonNull(doubleLayout);\n-            return Double.toString(value);\n-        }\n-\n-        \/**\n-         * Renders the provided {@code addressLayout} and {@code value} to a String.\n-         *\n-         * @param addressLayout the layout to render\n-         * @param value         the value to render\n-         * @return rendered String\n-         *\/\n-        default String render(ValueLayout.OfAddress addressLayout, MemorySegment value) {\n-            requireNonNull(addressLayout);\n-            return String.format(\"0x%0\" + (ValueLayout.ADDRESS.byteSize() * 2) + \"X\", value.address());\n-        }\n-\n-        \/**\n-         * {@return a standard value layout renderer that will render numeric values into decimal form and where\n-         * other value types are rendered to a reasonable \"natural\" form}\n-         * <p>\n-         * More specifically, values types are rendered as follows:\n-         * <ul>\n-         *     <li>Numeric values are rendered in decimal form (e.g 1 or 1.2).<\/li>\n-         *     <li>Boolean values are rendered as {@code true} or {@code false}.<\/li>\n-         *     <li>Character values are rendered as {@code char}.<\/li>\n-         *     <li>Address values are rendered in hexadecimal form e.g. {@code 0x0000000000000000} (on 64-bit platforms) or\n-         *     {@code 0x00000000} (on 32-bit platforms)<\/li>\n-         * <\/ul>\n-         *\/\n-        static ValueLayoutRenderer standard() {\n-            return STANDARD_VALUE_LAYOUT_RENDERER;\n-        }\n-\n-        \/**\n-         * {@return a value layout renderer that will render all value layout types via the provided {@code renderer}}\n-         *\/\n-        static ValueLayoutRenderer of(BiFunction<ValueLayout, Object, String> renderer) {\n-            requireNonNull(renderer);\n-            return new SingleFunctionValueLayoutRenderer(renderer);\n-        }\n-\n+    public static BiFunction<ValueLayout, Object, String> standardRenderer() {\n+        return STANDARD_VALUE_LAYOUT_RENDERER;\n@@ -243,1 +109,2 @@\n-}\n\\ No newline at end of file\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemoryInspection.java","additions":14,"deletions":147,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    static final MemoryInspection.ValueLayoutRenderer STANDARD_VALUE_LAYOUT_RENDERER = new StandardValueLayoutRenderer();\n+    static final BiFunction<ValueLayout, Object, String> STANDARD_VALUE_LAYOUT_RENDERER = new StandardValueLayoutRenderer();\n@@ -54,1 +54,1 @@\n-                                  MemoryInspection.ValueLayoutRenderer renderer) {\n+                                  BiFunction<ValueLayout, Object, String> renderer) {\n@@ -66,1 +66,1 @@\n-                                  MemoryInspection.ValueLayoutRenderer renderer,\n+                                  BiFunction<ValueLayout, Object, String> renderer,\n@@ -74,1 +74,1 @@\n-            action.accept(renderValueLayout(state, ofBoolean, renderer.render(ofBoolean, segment.get(ofBoolean, state.indexAndAdd(ofBoolean))), suffix));\n+            action.accept(renderValueLayout(state, ofBoolean, renderer.apply(ofBoolean, segment.get(ofBoolean, state.indexAndAdd(ofBoolean))), suffix));\n@@ -78,1 +78,1 @@\n-            action.accept(renderValueLayout(state, ofByte, renderer.render(ofByte, segment.get(ofByte, state.indexAndAdd(ofByte))), suffix));\n+            action.accept(renderValueLayout(state, ofByte, renderer.apply(ofByte, segment.get(ofByte, state.indexAndAdd(ofByte))), suffix));\n@@ -82,1 +82,1 @@\n-            action.accept(renderValueLayout(state, ofShort, renderer.render(ofShort, segment.get(ofShort, state.indexAndAdd(ofShort))), suffix));\n+            action.accept(renderValueLayout(state, ofShort, renderer.apply(ofShort, segment.get(ofShort, state.indexAndAdd(ofShort))), suffix));\n@@ -86,1 +86,1 @@\n-            action.accept(renderValueLayout(state, ofInt, renderer.render(ofInt, segment.get(ofInt, state.indexAndAdd(ofInt))), suffix));\n+            action.accept(renderValueLayout(state, ofInt, renderer.apply(ofInt, segment.get(ofInt, state.indexAndAdd(ofInt))), suffix));\n@@ -90,1 +90,1 @@\n-            action.accept(renderValueLayout(state, ofLong, renderer.render(ofLong, segment.get(ofLong, state.indexAndAdd(ofLong))), suffix));\n+            action.accept(renderValueLayout(state, ofLong, renderer.apply(ofLong, segment.get(ofLong, state.indexAndAdd(ofLong))), suffix));\n@@ -94,1 +94,1 @@\n-            action.accept(renderValueLayout(state, ofFloat, renderer.render(ofFloat, segment.get(ofFloat, state.indexAndAdd(ofFloat))), suffix));\n+            action.accept(renderValueLayout(state, ofFloat, renderer.apply(ofFloat, segment.get(ofFloat, state.indexAndAdd(ofFloat))), suffix));\n@@ -98,1 +98,1 @@\n-            action.accept(renderValueLayout(state, ofDouble, renderer.render(ofDouble, segment.get(ofDouble, state.indexAndAdd(ofDouble))), suffix));\n+            action.accept(renderValueLayout(state, ofDouble, renderer.apply(ofDouble, segment.get(ofDouble, state.indexAndAdd(ofDouble))), suffix));\n@@ -102,1 +102,1 @@\n-            action.accept(renderValueLayout(state, ofChar, renderer.render(ofChar, segment.get(ofChar, state.indexAndAdd(ofChar))), suffix));\n+            action.accept(renderValueLayout(state, ofChar, renderer.apply(ofChar, segment.get(ofChar, state.indexAndAdd(ofChar))), suffix));\n@@ -106,1 +106,1 @@\n-            action.accept(renderValueLayout(state, ofAddress, renderer.render(ofAddress, segment.get(ofAddress, state.indexAndAdd(ofAddress))), suffix));\n+            action.accept(renderValueLayout(state, ofAddress, renderer.apply(ofAddress, segment.get(ofAddress, state.indexAndAdd(ofAddress))), suffix));\n@@ -221,18 +221,1 @@\n-    private static final class StandardValueLayoutRenderer implements MemoryInspection.ValueLayoutRenderer {\n-        @Override\n-        public String toString() {\n-            return singletonToString(StandardValueLayoutRenderer.class);\n-        }\n-    }\n-\n-    private static String singletonToString(Class<?> implementingClass) {\n-        return \"The \" + implementingClass.getName() + \" singleton\";\n-    }\n-\n-    static final class SingleFunctionValueLayoutRenderer implements MemoryInspection.ValueLayoutRenderer {\n-\n-        private final BiFunction<ValueLayout, Object, String> renderer;\n-\n-        public SingleFunctionValueLayoutRenderer(BiFunction<ValueLayout, Object, String> renderer) {\n-            this.renderer = renderer;\n-        }\n+    private static final class StandardValueLayoutRenderer implements BiFunction<ValueLayout, Object, String> {\n@@ -241,18 +224,3 @@\n-        public String render(ValueLayout.OfBoolean booleanLayout, boolean value) {\n-            return renderer.apply(booleanLayout, value);\n-        }\n-\n-        @Override\n-        public String render(ValueLayout.OfByte byteLayout, byte value) {\n-            return renderer.apply(byteLayout, value);\n-        }\n-\n-        @Override\n-        public String render(ValueLayout.OfChar charLayout, char value) {\n-            return renderer.apply(charLayout, value);\n-        }\n-\n-        @Override\n-        public String render(ValueLayout.OfShort shortLayout, short value) {\n-            return renderer.apply(shortLayout, value);\n-        }\n+        public String apply(ValueLayout layout, Object o) {\n+            requireNonNull(layout);\n+            requireNonNull(o);\n@@ -260,4 +228,1 @@\n-        @Override\n-        public String render(ValueLayout.OfInt intLayout, int value) {\n-            return renderer.apply(intLayout, value);\n-        }\n+            \/\/ TODO: Replace with \"patterns in switch statement\" once this becomes available.\n@@ -265,18 +230,28 @@\n-        @Override\n-        public String render(ValueLayout.OfLong longLayout, long value) {\n-            return renderer.apply(longLayout, value);\n-        }\n-\n-        @Override\n-        public String render(ValueLayout.OfFloat floatLayout, float value) {\n-            return renderer.apply(floatLayout, value);\n-        }\n-\n-        @Override\n-        public String render(ValueLayout.OfDouble doubleLayout, double value) {\n-            return renderer.apply(doubleLayout, value);\n-        }\n-\n-        @Override\n-        public String render(ValueLayout.OfAddress addressLayout, MemorySegment value) {\n-            return renderer.apply(addressLayout, value);\n+            if (layout instanceof ValueLayout.OfBoolean ofBoolean && o instanceof Boolean b) {\n+                return Boolean.toString(b);\n+            }\n+            if (layout instanceof ValueLayout.OfByte ofByte && o instanceof Byte b) {\n+                return Byte.toString(b);\n+            }\n+            if (layout instanceof ValueLayout.OfShort ofShort && o instanceof Short s) {\n+                return Short.toString(s);\n+            }\n+            if (layout instanceof ValueLayout.OfInt ofInt && o instanceof Integer i) {\n+                return Integer.toString(i);\n+            }\n+            if (layout instanceof ValueLayout.OfLong ofLong && o instanceof Long l) {\n+                return Long.toString(l);\n+            }\n+            if (layout instanceof ValueLayout.OfFloat ofFloat && o instanceof Float f) {\n+                return Float.toString(f);\n+            }\n+            if (layout instanceof ValueLayout.OfDouble ofDouble && o instanceof Double d) {\n+                return Double.toString(d);\n+            }\n+            if (layout instanceof ValueLayout.OfChar ofChar && o instanceof Character c) {\n+                return Character.toString(c);\n+            }\n+            if (layout instanceof ValueLayout.OfAddress ofAddress && o instanceof MemorySegment m) {\n+                return String.format(\"0x%0\" + (ValueLayout.ADDRESS.byteSize() * 2) + \"X\", m.address());\n+            }\n+            throw new UnsupportedOperationException(\"layout \" + layout + \" for \" + o.getClass().getName() + \" not supported\");\n@@ -287,3 +262,1 @@\n-            return \"SingleFunctionValueLayoutRenderer{\" +\n-                    \"renderer=\" + renderer +\n-                    '}';\n+            return singletonToString(StandardValueLayoutRenderer.class);\n@@ -293,1 +266,5 @@\n-}\n\\ No newline at end of file\n+    private static String singletonToString(Class<?> implementingClass) {\n+        return \"The \" + implementingClass.getName() + \" singleton\";\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemoryInspectionUtil.java","additions":51,"deletions":74,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.invoke.MethodHandle;\n@@ -34,0 +35,1 @@\n+import java.util.HexFormat;\n@@ -35,0 +37,1 @@\n+import java.util.function.BiFunction;\n@@ -69,1 +72,1 @@\n-            var actual = testWithFreshMemorySegment(ti.layout().byteSize(), s -> jdk.internal.foreign.MemoryInspection.inspect(s, ti.layout(), jdk.internal.foreign.MemoryInspection.ValueLayoutRenderer.standard()))\n+            var actual = testWithFreshMemorySegment(ti.layout().byteSize(), s -> jdk.internal.foreign.MemoryInspection.inspect(s, ti.layout(), jdk.internal.foreign.MemoryInspection.standardRenderer()))\n@@ -88,1 +91,1 @@\n-            return jdk.internal.foreign.MemoryInspection.inspect(segment, Point.LAYOUT, jdk.internal.foreign.MemoryInspection.ValueLayoutRenderer.standard())\n+            return jdk.internal.foreign.MemoryInspection.inspect(segment, Point.LAYOUT, jdk.internal.foreign.MemoryInspection.standardRenderer())\n@@ -108,1 +111,2 @@\n-            return MemoryInspection.inspect(segment, Point.LAYOUT, new jdk.internal.foreign.MemoryInspection.ValueLayoutRenderer() {\n+            return MemoryInspection.inspect(segment, Point.LAYOUT, new BiFunction<ValueLayout, Object, String>() {\n+\n@@ -110,2 +114,2 @@\n-                        public String render(ValueLayout.OfInt intLayout, int value) {\n-                            return String.format(\"0x%04x\", value);\n+                        public String apply(ValueLayout layout, Object o) {\n+                            return String.format(\"0x%04x\", (int)o);\n@@ -157,1 +161,1 @@\n-                jdk.internal.foreign.MemoryInspection.inspect(segment, layout, jdk.internal.foreign.MemoryInspection.ValueLayoutRenderer.standard()))\n+                jdk.internal.foreign.MemoryInspection.inspect(segment, layout, jdk.internal.foreign.MemoryInspection.standardRenderer()))\n@@ -174,0 +178,3 @@\n+        var xh = sequenceLayout.varHandle(PathElement.sequenceElement(), PathElement.groupElement(\"x\"));\n+        var yh = sequenceLayout.varHandle(PathElement.sequenceElement(), PathElement.groupElement(\"y\"));\n+\n@@ -177,1 +184,1 @@\n-                        x=0,\n+                        x=1,\n@@ -181,2 +188,2 @@\n-                        x=0,\n-                        y=0\n+                        x=1,\n+                        y=1\n@@ -185,2 +192,2 @@\n-                        x=0,\n-                        y=0\n+                        x=1,\n+                        y=2\n@@ -189,2 +196,2 @@\n-                        x=0,\n-                        y=0\n+                        x=1,\n+                        y=3\n@@ -193,4 +200,9 @@\n-        var actual = testWithFreshMemorySegment(Integer.BYTES * 2 * arraySize, segment ->\n-                jdk.internal.foreign.MemoryInspection.inspect(segment, sequenceLayout, jdk.internal.foreign.MemoryInspection.ValueLayoutRenderer.standard()))\n-                .collect(joining(System.lineSeparator()));\n-\n+        var actual = testWithFreshMemorySegment(Integer.BYTES * 2 * arraySize, segment -> {\n+            for (long i = 0; i < sequenceLayout.elementCount(); i++) {\n+                xh.set(segment, i, 1);\n+                yh.set(segment, i, (int) i);\n+            }\n+\n+            return jdk.internal.foreign.MemoryInspection.inspect(segment, sequenceLayout, jdk.internal.foreign.MemoryInspection.standardRenderer())\n+                .collect(joining(System.lineSeparator()));}\n+        );\n@@ -220,2 +232,2 @@\n-                        x=0,\n-                        y=0,\n+                        x=1,\n+                        y=2,\n@@ -225,3 +237,3 @@\n-                        x=0,\n-                        y=0,\n-                        z=0\n+                        x=1,\n+                        y=2,\n+                        z=3\n@@ -230,3 +242,7 @@\n-        var actual = testWithFreshMemorySegment(Integer.BYTES * 3, segment ->\n-                MemoryInspection.inspect(segment, union, MemoryInspection.ValueLayoutRenderer.standard()))\n-                .collect(joining(System.lineSeparator()));\n+        var actual = testWithFreshMemorySegment(Integer.BYTES * 3, segment -> {\n+            u0.varHandle(PathElement.groupElement(\"x\")).set(segment, 1);\n+            u1.varHandle(PathElement.groupElement(\"y\")).set(segment, 2);\n+            u1.varHandle(PathElement.groupElement(\"z\")).set(segment, 3);\n+            return jdk.internal.foreign.MemoryInspection.inspect(segment, union, jdk.internal.foreign.MemoryInspection.standardRenderer())\n+                    .collect(joining(System.lineSeparator()));\n+        });\n@@ -288,1 +304,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/jdk\/java\/foreign\/TestMemoryInspection.java","additions":42,"deletions":26,"binary":false,"changes":68,"status":"modified"}]}