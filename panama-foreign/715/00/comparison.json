{"files":[{"patch":"@@ -0,0 +1,243 @@\n+\/*\n+ *  Copyright (c) 2022, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.foreign;\n+\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.nio.Buffer;\n+import java.util.function.BiFunction;\n+import java.util.stream.Stream;\n+\n+import static java.util.Objects.requireNonNull;\n+import static jdk.internal.foreign.MemoryInspectionUtil.*;\n+\n+\/**\n+ * Class that supports inspection of MemorySegments through MemoryLayouts.\n+ * <p>\n+ * Memory abstractions such as ByteBuffers and byte arrays can be inspected via wrapping methods\n+ * such as {@link MemorySegment#ofArray(byte[])} and {@link MemorySegment#ofBuffer(Buffer)}.\n+ *\n+ * @author Per Minborg\n+ * @since 20\n+ *\/\n+public final class MemoryInspection {\n+\n+    \/\/ Suppresses default constructor, ensuring non-instantiability.\n+    private MemoryInspection() {\n+    }\n+\n+    \/**\n+     * Returns a human-readable view of the provided {@linkplain MemorySegment memory} viewed\n+     * through the provided {@linkplain MemoryLayout layout} using the provided {@linkplain ValueLayoutRenderer renderer}.\n+     * <p>\n+     * The exact format of the returned view is unspecified and should not\n+     * be acted upon programmatically.\n+     * <p>\n+     * As an example, a MemorySegment viewed though the following memory layout\n+     * {@snippet lang = java:\n+     * var layout = MemoryLayout.structLayout(\n+     *         ValueLayout.JAVA_INT.withName(\"x\"),\n+     *         ValueLayout.JAVA_INT.withName(\"y\")\n+     * ).withName(\"Point\");\n+     *\n+     * MemoryInspection.inspect(segment, layout, ValueLayoutRenderer.standard())\n+     *     .forEach(System.out::println);\n+     *\n+     *}\n+     * might be rendered to something like this:\n+     * {@snippet lang = text:\n+     * Point {\n+     *   x=1,\n+     *   y=2\n+     * }\n+     *}\n+     * <p>\n+     * This method is intended to view memory segments through small and medium-sized memory layouts.\n+     *\n+     * @param segment  to be viewed\n+     * @param layout   to use as a layout when viewing the memory segment\n+     * @param renderer to apply when rendering value layouts\n+     * @return a view of the memory abstraction viewed through the memory layout\n+     *\/\n+    public static Stream<String> inspect(MemorySegment segment,\n+                                         MemoryLayout layout,\n+                                         ValueLayoutRenderer renderer) {\n+        requireNonNull(segment);\n+        requireNonNull(layout);\n+        requireNonNull(renderer);\n+        return MemoryInspectionUtil.inspect(segment, layout, renderer);\n+    }\n+\n+    \/**\n+     * An interface that can be used to specify custom rendering of value\n+     * layouts via the {@link MemoryInspection#inspect(MemorySegment, MemoryLayout, ValueLayoutRenderer)} method.\n+     * <p>\n+     * The render methods take two parameters:\n+     * <ul>\n+     *     <li>layout: This can be used to select different formatting for different paths<\/li>\n+     *     <li>value: The actual value<\/li>\n+     * <\/ul>\n+     * <p>\n+     * The {@linkplain ValueLayoutRenderer#standard() standard() } value layout renderer is path\n+     * agnostic and will thus render all layouts of the same type the same way.\n+     *\n+     * @see MemoryInspection#inspect(MemorySegment, MemoryLayout, ValueLayoutRenderer)\n+     *\/\n+    public interface ValueLayoutRenderer {\n+        \/**\n+         * Renders the provided {@code booleanLayout} and {@code value} to a String.\n+         *\n+         * @param booleanLayout the layout to render\n+         * @param value         the value to render\n+         * @return rendered String\n+         *\/\n+        default String render(ValueLayout.OfBoolean booleanLayout, boolean value) {\n+            requireNonNull(booleanLayout);\n+            return Boolean.toString(value);\n+        }\n+\n+        \/**\n+         * Renders the provided {@code byteLayout} and {@code value} to a String.\n+         *\n+         * @param byteLayout the layout to render\n+         * @param value         the value to render\n+         * @return rendered String\n+         *\/\n+        default String render(ValueLayout.OfByte byteLayout, byte value) {\n+            requireNonNull(byteLayout);\n+            return Byte.toString(value);\n+        }\n+\n+        \/**\n+         * Renders the provided {@code charLayout} and {@code value} to a String.\n+         *\n+         * @param charLayout the layout to render\n+         * @param value      the value to render\n+         * @return rendered String\n+         *\/\n+        default String render(ValueLayout.OfChar charLayout, char value) {\n+            requireNonNull(charLayout);\n+            return Character.toString(value);\n+        }\n+\n+        \/**\n+         * Renders the provided {@code shortLayout} and {@code value} to a String.\n+         *\n+         * @param shortLayout the layout to render\n+         * @param value       the value to render\n+         * @return rendered String\n+         *\/\n+        default String render(ValueLayout.OfShort shortLayout, short value) {\n+            requireNonNull(shortLayout);\n+            return Short.toString(value);\n+        }\n+\n+        \/**\n+         * Renders the provided {@code intLayout} and {@code value} to a String.\n+         *\n+         * @param intLayout the layout to render\n+         * @param value     the value to render\n+         * @return rendered String\n+         *\/\n+        default String render(ValueLayout.OfInt intLayout, int value) {\n+            requireNonNull(intLayout);\n+            return Integer.toString(value);\n+        }\n+\n+        \/**\n+         * Renders the provided {@code longLayout} and {@code value} to a String.\n+         *\n+         * @param longLayout the layout to render\n+         * @param value      the value to render\n+         * @return rendered String\n+         *\/\n+        default String render(ValueLayout.OfLong longLayout, long value) {\n+            requireNonNull(longLayout);\n+            return Long.toString(value);\n+        }\n+\n+        \/**\n+         * Renders the provided {@code floatLayout} and {@code value} to a String.\n+         *\n+         * @param floatLayout the layout to render\n+         * @param value       the value to render\n+         * @return rendered String\n+         *\/\n+        default String render(ValueLayout.OfFloat floatLayout, float value) {\n+            requireNonNull(floatLayout);\n+            return Float.toString(value);\n+        }\n+\n+        \/**\n+         * Renders the provided {@code doubleLayout} and {@code value} to a String.\n+         *\n+         * @param doubleLayout the layout to render\n+         * @param value        the value to render\n+         * @return rendered String\n+         *\/\n+        default String render(ValueLayout.OfDouble doubleLayout, double value) {\n+            requireNonNull(doubleLayout);\n+            return Double.toString(value);\n+        }\n+\n+        \/**\n+         * Renders the provided {@code addressLayout} and {@code value} to a String.\n+         *\n+         * @param addressLayout the layout to render\n+         * @param value         the value to render\n+         * @return rendered String\n+         *\/\n+        default String render(ValueLayout.OfAddress addressLayout, MemorySegment value) {\n+            requireNonNull(addressLayout);\n+            return String.format(\"0x%0\" + (ValueLayout.ADDRESS.byteSize() * 2) + \"X\", value.address());\n+        }\n+\n+        \/**\n+         * {@return a standard value layout renderer that will render numeric values into decimal form and where\n+         * other value types are rendered to a reasonable \"natural\" form}\n+         * <p>\n+         * More specifically, values types are rendered as follows:\n+         * <ul>\n+         *     <li>Numeric values are rendered in decimal form (e.g 1 or 1.2).<\/li>\n+         *     <li>Boolean values are rendered as {@code true} or {@code false}.<\/li>\n+         *     <li>Character values are rendered as {@code char}.<\/li>\n+         *     <li>Address values are rendered in hexadecimal form e.g. {@code 0x0000000000000000} (on 64-bit platforms) or\n+         *     {@code 0x00000000} (on 32-bit platforms)<\/li>\n+         * <\/ul>\n+         *\/\n+        static ValueLayoutRenderer standard() {\n+            return STANDARD_VALUE_LAYOUT_RENDERER;\n+        }\n+\n+        \/**\n+         * {@return a value layout renderer that will render all value layout types via the provided {@code renderer}}\n+         *\/\n+        static ValueLayoutRenderer of(BiFunction<ValueLayout, Object, String> renderer) {\n+            requireNonNull(renderer);\n+            return new SingleFunctionValueLayoutRenderer(renderer);\n+        }\n+\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemoryInspection.java","additions":243,"deletions":0,"binary":false,"changes":243,"status":"added"},{"patch":"@@ -0,0 +1,293 @@\n+\/*\n+ *  Copyright (c) 2022, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.PaddingLayout;\n+import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.StructLayout;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.foreign.UnionLayout;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+\/**\n+ * Internal class to support inspection MemorySegments into various formats.\n+ *\/\n+final class MemoryInspectionUtil {\n+\n+    static final MemoryInspection.ValueLayoutRenderer STANDARD_VALUE_LAYOUT_RENDERER = new StandardValueLayoutRenderer();\n+\n+    \/\/ Suppresses default constructor, ensuring non-instantiability.\n+    private MemoryInspectionUtil() {\n+    }\n+\n+    static Stream<String> inspect(MemorySegment segment,\n+                                  MemoryLayout layout,\n+                                  MemoryInspection.ValueLayoutRenderer renderer) {\n+        requireNonNull(segment);\n+        requireNonNull(layout);\n+        requireNonNull(renderer);\n+\n+        final var builder = Stream.<String>builder();\n+        toString0(segment, layout, renderer, builder::add, new ViewState(), \"\");\n+        return builder.build();\n+    }\n+\n+    private static void toString0(MemorySegment segment,\n+                                  MemoryLayout layout,\n+                                  MemoryInspection.ValueLayoutRenderer renderer,\n+                                  Consumer<String> action,\n+                                  ViewState state,\n+                                  String suffix) {\n+\n+        \/\/ TODO: Replace with \"patterns in switch statement\" once this becomes available.\n+\n+        if (layout instanceof ValueLayout.OfBoolean ofBoolean) {\n+            action.accept(renderValueLayout(state, ofBoolean, renderer.render(ofBoolean, segment.get(ofBoolean, state.indexAndAdd(ofBoolean))), suffix));\n+            return;\n+        }\n+        if (layout instanceof ValueLayout.OfByte ofByte) {\n+            action.accept(renderValueLayout(state, ofByte, renderer.render(ofByte, segment.get(ofByte, state.indexAndAdd(ofByte))), suffix));\n+            return;\n+        }\n+        if (layout instanceof ValueLayout.OfShort ofShort) {\n+            action.accept(renderValueLayout(state, ofShort, renderer.render(ofShort, segment.get(ofShort, state.indexAndAdd(ofShort))), suffix));\n+            return;\n+        }\n+        if (layout instanceof ValueLayout.OfInt ofInt) {\n+            action.accept(renderValueLayout(state, ofInt, renderer.render(ofInt, segment.get(ofInt, state.indexAndAdd(ofInt))), suffix));\n+            return;\n+        }\n+        if (layout instanceof ValueLayout.OfLong ofLong) {\n+            action.accept(renderValueLayout(state, ofLong, renderer.render(ofLong, segment.get(ofLong, state.indexAndAdd(ofLong))), suffix));\n+            return;\n+        }\n+        if (layout instanceof ValueLayout.OfFloat ofFloat) {\n+            action.accept(renderValueLayout(state, ofFloat, renderer.render(ofFloat, segment.get(ofFloat, state.indexAndAdd(ofFloat))), suffix));\n+            return;\n+        }\n+        if (layout instanceof ValueLayout.OfDouble ofDouble) {\n+            action.accept(renderValueLayout(state, ofDouble, renderer.render(ofDouble, segment.get(ofDouble, state.indexAndAdd(ofDouble))), suffix));\n+            return;\n+        }\n+        if (layout instanceof ValueLayout.OfChar ofChar) {\n+            action.accept(renderValueLayout(state, ofChar, renderer.render(ofChar, segment.get(ofChar, state.indexAndAdd(ofChar))), suffix));\n+            return;\n+        }\n+        if (layout instanceof ValueLayout.OfAddress ofAddress) {\n+            action.accept(renderValueLayout(state, ofAddress, renderer.render(ofAddress, segment.get(ofAddress, state.indexAndAdd(ofAddress))), suffix));\n+            return;\n+        }\n+        if (layout instanceof PaddingLayout paddingLayout) {\n+            action.accept(state.indentSpaces() + paddingLayout.bitSize() + \" padding bits\");\n+            state.indexAndAdd(paddingLayout);\n+            return;\n+        }\n+        if (layout instanceof GroupLayout groupLayout) {\n+\n+            \/* Strictly, we should provide all permutations of unions.\n+             * So, if we have a union U =  (A|B),(C|D) then we should present:\n+             * (A,C), (A,D), (B,C) and (B,D)\n+             *\/\n+\n+            final var separator = groupLayout instanceof StructLayout\n+                    ? \",\"  \/\/ Struct separator\n+                    : \"|\"; \/\/ Union separator\n+\n+            action.accept(indentedLabel(state, groupLayout) + \" {\");\n+            state.incrementIndent();\n+            final var members = groupLayout.memberLayouts();\n+            final long initialIndex = state.index();\n+            long maxIndex = initialIndex;\n+            for (int i = 0; i < members.size(); i++) {\n+                if (groupLayout instanceof UnionLayout) {\n+                    \/\/ If it is a union, we need to reset the index for each member\n+                    state.index(initialIndex);\n+                    \/\/ We record the max index used for any union member so we can leave off from there\n+                    maxIndex = Math.max(maxIndex, state.index());\n+                }\n+                toString0(segment, members.get(i), renderer, action, state, (i != (members.size() - 1)) ? separator : \"\");\n+                if (groupLayout instanceof UnionLayout) {\n+                    \/\/ This is the best we can do.\n+                    state.index(maxIndex);\n+                }\n+            }\n+            state.decrementIndent();\n+            action.accept(state.indentSpaces() + \"}\" + suffix);\n+            return;\n+        }\n+        if (layout instanceof SequenceLayout sequenceLayout) {\n+            action.accept(indentedLabel(state, sequenceLayout) + \" [\");\n+            state.incrementIndent();\n+            final long elementCount = sequenceLayout.elementCount();\n+            for (long i = 0; i < elementCount; i++) {\n+                toString0(segment, sequenceLayout.elementLayout(), renderer, action, state, (i != (elementCount - 1L)) ? \",\" : \"\");\n+            }\n+            state.decrementIndent();\n+            action.accept(state.indentSpaces() + \"]\" + suffix);\n+            return;\n+        }\n+        action.accept(state.indentSpaces() + \"Unknown layout: \" + layout + \" at index \" + state.index());\n+        state.indexAndAdd(layout);\n+    }\n+\n+    static String renderValueLayout(ViewState state,\n+                                    ValueLayout layout,\n+                                    String value,\n+                                    String suffix) {\n+        return indentedLabel(state, layout) + \"=\" + value + suffix;\n+    }\n+\n+    static String indentedLabel(ViewState state,\n+                                MemoryLayout layout) {\n+        return state.indentSpaces() + layout.name()\n+                .orElseGet(layout::toString);\n+    }\n+\n+    static final class ViewState {\n+\n+        private static final int SPACES_PER_INDENT = 4;\n+\n+        \/\/ Holding a non-static indents allows simple thread-safe use\n+        private final StringBuilder indents = new StringBuilder();\n+\n+        private int indent;\n+        private long index;\n+\n+        void incrementIndent() {\n+            indent++;\n+        }\n+\n+        void decrementIndent() {\n+            indent--;\n+        }\n+\n+        String indentSpaces() {\n+            final int spaces = indent * SPACES_PER_INDENT;\n+            while (indents.length() < spaces) {\n+                \/\/ Expand as needed\n+                indents.append(\" \");\n+            }\n+            return indents.substring(0, spaces);\n+        }\n+\n+        long index() {\n+            return index;\n+        }\n+\n+        void index(long index) {\n+            this.index = index;\n+        }\n+\n+        long indexAndAdd(long delta) {\n+            final long val = index;\n+            index += delta;\n+            return val;\n+        }\n+\n+        long indexAndAdd(MemoryLayout layout) {\n+            return indexAndAdd(layout.byteSize());\n+        }\n+    }\n+\n+    private static final class StandardValueLayoutRenderer implements MemoryInspection.ValueLayoutRenderer {\n+        @Override\n+        public String toString() {\n+            return singletonToString(StandardValueLayoutRenderer.class);\n+        }\n+    }\n+\n+    private static String singletonToString(Class<?> implementingClass) {\n+        return \"The \" + implementingClass.getName() + \" singleton\";\n+    }\n+\n+    static final class SingleFunctionValueLayoutRenderer implements MemoryInspection.ValueLayoutRenderer {\n+\n+        private final BiFunction<ValueLayout, Object, String> renderer;\n+\n+        public SingleFunctionValueLayoutRenderer(BiFunction<ValueLayout, Object, String> renderer) {\n+            this.renderer = renderer;\n+        }\n+\n+        @Override\n+        public String render(ValueLayout.OfBoolean booleanLayout, boolean value) {\n+            return renderer.apply(booleanLayout, value);\n+        }\n+\n+        @Override\n+        public String render(ValueLayout.OfByte byteLayout, byte value) {\n+            return renderer.apply(byteLayout, value);\n+        }\n+\n+        @Override\n+        public String render(ValueLayout.OfChar charLayout, char value) {\n+            return renderer.apply(charLayout, value);\n+        }\n+\n+        @Override\n+        public String render(ValueLayout.OfShort shortLayout, short value) {\n+            return renderer.apply(shortLayout, value);\n+        }\n+\n+        @Override\n+        public String render(ValueLayout.OfInt intLayout, int value) {\n+            return renderer.apply(intLayout, value);\n+        }\n+\n+        @Override\n+        public String render(ValueLayout.OfLong longLayout, long value) {\n+            return renderer.apply(longLayout, value);\n+        }\n+\n+        @Override\n+        public String render(ValueLayout.OfFloat floatLayout, float value) {\n+            return renderer.apply(floatLayout, value);\n+        }\n+\n+        @Override\n+        public String render(ValueLayout.OfDouble doubleLayout, double value) {\n+            return renderer.apply(doubleLayout, value);\n+        }\n+\n+        @Override\n+        public String render(ValueLayout.OfAddress addressLayout, MemorySegment value) {\n+            return renderer.apply(addressLayout, value);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"SingleFunctionValueLayoutRenderer{\" +\n+                    \"renderer=\" + renderer +\n+                    '}';\n+        }\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemoryInspectionUtil.java","additions":293,"deletions":0,"binary":false,"changes":293,"status":"added"},{"patch":"@@ -0,0 +1,288 @@\n+\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.foreign\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestMemoryInspection\n+ *\/\n+\n+import java.lang.foreign.*;\n+import java.lang.invoke.VarHandle;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.foreign.MemoryInspection;\n+import org.testng.annotations.*;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static java.util.stream.Collectors.joining;\n+import static org.testng.Assert.*;\n+import static java.util.Objects.requireNonNull;\n+\n+@Test\n+public class TestMemoryInspection {\n+\n+    private static final String EXPECT_ADDRESS = \"0x\" + \"00\".repeat((int) ValueLayout.ADDRESS.byteSize());\n+\n+    @Test\n+    public void valueLayouts() {\n+\n+        record TestInput(ValueLayout layout, String stringValue) {\n+        }\n+\n+        List.of(\n+                new TestInput(ValueLayout.JAVA_BYTE, \"0\"),\n+                new TestInput(ValueLayout.JAVA_SHORT, \"0\"),\n+                new TestInput(ValueLayout.JAVA_INT, \"0\"),\n+                new TestInput(ValueLayout.JAVA_LONG, \"0\"),\n+                new TestInput(ValueLayout.JAVA_FLOAT, \"0.0\"),\n+                new TestInput(ValueLayout.JAVA_DOUBLE, \"0.0\"),\n+                new TestInput(ValueLayout.JAVA_CHAR, \"\" + (char) 0),\n+                new TestInput(JAVA_BOOLEAN, \"false\"),\n+                new TestInput(ValueLayout.ADDRESS, EXPECT_ADDRESS)\n+        ).forEach(ti -> {\n+            var expect = ti.layout() + \"=\" + ti.stringValue();\n+            var actual = testWithFreshMemorySegment(ti.layout().byteSize(), s -> jdk.internal.foreign.MemoryInspection.inspect(s, ti.layout(), jdk.internal.foreign.MemoryInspection.ValueLayoutRenderer.standard()))\n+                    .collect(joining(System.lineSeparator()));\n+            assertEquals(actual, expect);\n+        });\n+    }\n+\n+    @Test\n+    public void point() {\n+\n+        var expect = platformLineSeparated(\"\"\"\n+                Point {\n+                    x=1,\n+                    y=2\n+                }\"\"\");\n+\n+        var actual = testWithFreshMemorySegment(Integer.BYTES * 2, segment -> {\n+            final Point point = new Point(segment);\n+            point.x(1);\n+            point.y(2);\n+            return jdk.internal.foreign.MemoryInspection.inspect(segment, Point.LAYOUT, jdk.internal.foreign.MemoryInspection.ValueLayoutRenderer.standard())\n+                    .collect(joining(System.lineSeparator()));\n+        });\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+    @Test\n+    public void pointCustomRenderer() {\n+\n+        var expect = platformLineSeparated(\"\"\"\n+                Point {\n+                    x=0x0001,\n+                    y=0x0002\n+                }\"\"\");\n+\n+        var actual = testWithFreshMemorySegment(Integer.BYTES * 2, segment -> {\n+            final Point point = new Point(segment);\n+            point.x(1);\n+            point.y(2);\n+            return MemoryInspection.inspect(segment, Point.LAYOUT, new jdk.internal.foreign.MemoryInspection.ValueLayoutRenderer() {\n+                        @Override\n+                        public String render(ValueLayout.OfInt intLayout, int value) {\n+                            return String.format(\"0x%04x\", value);\n+                        }\n+                    })\n+                    .collect(joining(System.lineSeparator()));\n+        });\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+    @Test\n+    public void standardCustomRenderer() {\n+\n+        MemoryLayout layout = MemoryLayout.structLayout(\n+                \/\/ These are in bit alignment order (descending) for all platforms\n+                \/\/ in order for each element to be aligned to its type's bit alignment.\n+                Stream.of(\n+                                JAVA_LONG,\n+                                JAVA_DOUBLE,\n+                                ADDRESS,\n+                                JAVA_INT,\n+                                JAVA_FLOAT,\n+                                JAVA_SHORT,\n+                                JAVA_CHAR,\n+                                JAVA_BOOLEAN,\n+                                JAVA_BYTE\n+                        )\n+                        .map(vl -> vl.withName(vl.carrier().getSimpleName()))\n+                        .toArray(MemoryLayout[]::new)\n+        ).withName(\"struct\");\n+\n+        System.out.println(\"layout = \" + layout);\n+        var expect = platformLineSeparated(\"\"\"\n+                struct {\n+                    long=0,\n+                    double=0.0,\n+                    MemorySegment=$1,\n+                    int=0,\n+                    float=0.0,\n+                    short=0,\n+                    char=\\u0000,\n+                    boolean=false,\n+                    byte=0\n+                }\"\"\").replace(\"$1\", EXPECT_ADDRESS);\n+\n+\n+        var actual = testWithFreshMemorySegment(layout.byteSize(), segment ->\n+                jdk.internal.foreign.MemoryInspection.inspect(segment, layout, jdk.internal.foreign.MemoryInspection.ValueLayoutRenderer.standard()))\n+                .collect(joining(System.lineSeparator()));\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+\n+    @Test\n+    public void sequence() {\n+        final int arraySize = 4;\n+        var sequenceLayout = MemoryLayout.sequenceLayout(arraySize,\n+                MemoryLayout.structLayout(\n+                        ValueLayout.JAVA_INT.withName(\"x\"),\n+                        ValueLayout.JAVA_INT.withName(\"y\")\n+                ).withName(\"Point\")\n+        ).withName(\"PointArrayOfElements\");\n+\n+        var expect = platformLineSeparated(\"\"\"\n+                PointArrayOfElements [\n+                    Point {\n+                        x=0,\n+                        y=0\n+                    },\n+                    Point {\n+                        x=0,\n+                        y=0\n+                    },\n+                    Point {\n+                        x=0,\n+                        y=0\n+                    },\n+                    Point {\n+                        x=0,\n+                        y=0\n+                    }\n+                ]\"\"\");\n+        var actual = testWithFreshMemorySegment(Integer.BYTES * 2 * arraySize, segment ->\n+                jdk.internal.foreign.MemoryInspection.inspect(segment, sequenceLayout, jdk.internal.foreign.MemoryInspection.ValueLayoutRenderer.standard()))\n+                .collect(joining(System.lineSeparator()));\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+\n+    @Test\n+    public void union() {\n+        var u0 = MemoryLayout.structLayout(\n+                ValueLayout.JAVA_INT.withName(\"x\"),\n+                ValueLayout.JAVA_INT.withName(\"y\"),\n+                MemoryLayout.paddingLayout(Integer.SIZE)\n+        ).withName(\"Point\");\n+\n+        var u1 = MemoryLayout.structLayout(\n+                ValueLayout.JAVA_INT.withName(\"x\"),\n+                ValueLayout.JAVA_INT.withName(\"y\"),\n+                ValueLayout.JAVA_INT.withName(\"z\")\n+        ).withName(\"3D-Point\");\n+\n+        var union = MemoryLayout.unionLayout(u0, u1).withName(\"Union\");\n+\n+        var expect = platformLineSeparated(\"\"\"\n+                Union {\n+                    Point {\n+                        x=0,\n+                        y=0,\n+                        32 padding bits\n+                    }|\n+                    3D-Point {\n+                        x=0,\n+                        y=0,\n+                        z=0\n+                    }\n+                }\"\"\");\n+        var actual = testWithFreshMemorySegment(Integer.BYTES * 3, segment ->\n+                MemoryInspection.inspect(segment, union, MemoryInspection.ValueLayoutRenderer.standard()))\n+                .collect(joining(System.lineSeparator()));\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+    static final class Point {\n+\n+        static final MemoryLayout LAYOUT = MemoryLayout.structLayout(\n+                ValueLayout.JAVA_INT.withName(\"x\"),\n+                ValueLayout.JAVA_INT.withName(\"y\")\n+        ).withName(\"Point\");\n+\n+        static final VarHandle xVH = LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"x\"));\n+        static final VarHandle yVH = LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"y\"));\n+\n+        private final MemorySegment memorySegment;\n+\n+        Point(MemorySegment memorySegment) {\n+            this.memorySegment = requireNonNull(memorySegment);\n+        }\n+\n+        int x() {\n+            return (int) xVH.get(memorySegment);\n+        }\n+\n+        int y() {\n+            return (int) yVH.get(memorySegment);\n+        }\n+\n+        void x(int x) {\n+            xVH.set(memorySegment, x);\n+        }\n+\n+        void y(int y) {\n+            yVH.set(memorySegment, y);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Point {x=\" + x() + \", y=\" + y() + \"}\";\n+        }\n+    }\n+\n+    private static String platformLineSeparated(String s) {\n+        return s.lines()\n+                .collect(joining(System.lineSeparator()));\n+    }\n+\n+    private static <T> T testWithFreshMemorySegment(long size,\n+                                                    Function<MemorySegment, T> mapper) {\n+        try (final MemorySession session = MemorySession.openConfined()) {\n+            var segment = session.allocate(size);\n+            return mapper.apply(segment);\n+        }\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/foreign\/TestMemoryInspection.java","additions":288,"deletions":0,"binary":false,"changes":288,"status":"added"}]}