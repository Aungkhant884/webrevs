{"files":[{"patch":"@@ -46,0 +46,1 @@\n+import static java.lang.constant.ConstantDescs.BSM_GET_STATIC_FINAL;\n@@ -152,1 +153,1 @@\n-    <T> DynamicConstantDesc<T> decorateLayoutConstant(DynamicConstantDesc<T> desc) {\n+    protected <T> DynamicConstantDesc<T> decorateLayoutConstant(DynamicConstantDesc<T> desc) {\n@@ -165,1 +166,1 @@\n-    boolean hasNaturalAlignment() {\n+    protected boolean hasNaturalAlignment() {\n@@ -195,4 +196,0 @@\n-    static final DirectMethodHandleDesc BSM_GET_STATIC_FINAL\n-            = ConstantDescs.ofConstantBootstrap(ConstantDescs.CD_ConstantBootstraps, \"getStaticFinal\",\n-            ConstantDescs.CD_Object, ConstantDescs.CD_Class);\n-\n@@ -217,4 +214,0 @@\n-    static final ConstantDesc TRUE = DynamicConstantDesc.ofNamed(BSM_GET_STATIC_FINAL, \"TRUE\", ConstantDescs.CD_Boolean, ConstantDescs.CD_Boolean);\n-\n-    static final ConstantDesc FALSE = DynamicConstantDesc.ofNamed(BSM_GET_STATIC_FINAL, \"FALSE\", ConstantDescs.CD_Boolean, ConstantDescs.CD_Boolean);\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/AbstractLayout.java","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -174,1 +174,1 @@\n-    GroupLayout dup(long alignment, Map<String, Constable> attributes) {\n+    protected GroupLayout dup(long alignment, Map<String, Constable> attributes) {\n@@ -179,1 +179,1 @@\n-    boolean hasNaturalAlignment() {\n+    protected boolean hasNaturalAlignment() {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/GroupLayout.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -255,1 +255,1 @@\n-    SequenceLayout dup(long alignment, Map<String, Constable> attributes) {\n+    protected SequenceLayout dup(long alignment, Map<String, Constable> attributes) {\n@@ -260,1 +260,1 @@\n-    boolean hasNaturalAlignment() {\n+    protected boolean hasNaturalAlignment() {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SequenceLayout.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-public final class ValueLayout extends AbstractLayout implements MemoryLayout {\n+public class ValueLayout extends AbstractLayout implements MemoryLayout {\n@@ -55,1 +55,1 @@\n-    ValueLayout(ByteOrder order, long size) {\n+    protected ValueLayout(ByteOrder order, long size) {\n@@ -59,1 +59,1 @@\n-    ValueLayout(ByteOrder order, long size, long alignment, Map<String, Constable> attributes) {\n+    protected ValueLayout(ByteOrder order, long size, long alignment, Map<String, Constable> attributes) {\n@@ -113,1 +113,1 @@\n-    ValueLayout dup(long alignment, Map<String, Constable> attributes) {\n+    protected ValueLayout dup(long alignment, Map<String, Constable> attributes) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/ValueLayout.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package jdk.internal.foreign;\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.ValueLayout;\n+\n+import java.lang.constant.Constable;\n+import java.lang.constant.DynamicConstantDesc;\n+import java.nio.ByteOrder;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static java.lang.constant.ConstantDescs.BSM_GET_STATIC_FINAL;\n+\n+public class CValueLayout extends ValueLayout {\n+\n+    public enum Kind {\n+        CHAR(findBSM(\"C_CHAR\"), true),\n+        SHORT(findBSM(\"C_SHORT\"), true),\n+        INT(findBSM(\"C_INT\"), true),\n+        LONG(findBSM(\"C_LONG\"), true),\n+        LONGLONG(findBSM(\"C_LONGLONG\"), true),\n+        FLOAT(findBSM(\"C_FLOAT\"), false),\n+        DOUBLE(findBSM(\"C_DOUBLE\"), false),\n+        LONGDOUBLE(findBSM(\"C_LONGDOUBLE\"), false),\n+        POINTER(findBSM(\"C_POINTER\"), false);\n+\n+        private final DynamicConstantDesc<ValueLayout> bsm;\n+        private final boolean isIntegral;\n+\n+        Kind(DynamicConstantDesc<ValueLayout> bsm, boolean isIntegral) {\n+            this.bsm = bsm;\n+            this.isIntegral = isIntegral;\n+        }\n+\n+        public DynamicConstantDesc<ValueLayout> bsm() {\n+            return bsm;\n+        }\n+\n+        public boolean isIntergral() {\n+            return isIntegral;\n+        }\n+\n+        public boolean isPointer() {\n+            return this == POINTER;\n+        }\n+\n+        private static DynamicConstantDesc<ValueLayout> findBSM(String fieldName) {\n+            return DynamicConstantDesc.ofNamed(\n+                BSM_GET_STATIC_FINAL,\n+                fieldName,\n+                ValueLayout.class.describeConstable().orElseThrow(),\n+                CLinker.class.describeConstable().orElseThrow()\n+            );\n+        }\n+    }\n+\n+    private final Kind kind;\n+\n+    private CValueLayout(Kind kind, ByteOrder order, long size, long alignment, Map<String, Constable> attributes) {\n+        super(order, size, alignment, attributes);\n+        this.kind = kind;\n+    }\n+\n+    static CValueLayout ofChar(ByteOrder order, long bitSize) {\n+        return new CValueLayout(Kind.CHAR, order, bitSize, bitSize, Map.of());\n+    }\n+\n+    static CValueLayout ofShort(ByteOrder order, long bitSize) {\n+        return new CValueLayout(Kind.SHORT, order, bitSize, bitSize, Map.of());\n+    }\n+\n+    static CValueLayout ofInt(ByteOrder order, long bitSize) {\n+        return new CValueLayout(Kind.INT, order, bitSize, bitSize, Map.of());\n+    }\n+\n+    static CValueLayout ofLong(ByteOrder order, long bitSize) {\n+        return new CValueLayout(Kind.LONG, order, bitSize, bitSize, Map.of());\n+    }\n+\n+    static CValueLayout ofLongLong(ByteOrder order, long bitSize) {\n+        return new CValueLayout(Kind.LONGLONG, order, bitSize, bitSize, Map.of());\n+    }\n+\n+    static CValueLayout ofFloat(ByteOrder order, long bitSize) {\n+        return new CValueLayout(Kind.FLOAT, order, bitSize, bitSize, Map.of());\n+    }\n+\n+    static CValueLayout ofDouble(ByteOrder order, long bitSize) {\n+        return new CValueLayout(Kind.DOUBLE, order, bitSize, bitSize, Map.of());\n+    }\n+\n+    static CValueLayout ofLongDouble(ByteOrder order, long bitSize) {\n+        return new CValueLayout(Kind.LONGDOUBLE, order, bitSize, bitSize, Map.of());\n+    }\n+\n+    static CValueLayout ofPointer(ByteOrder order, long bitSize) {\n+        return new CValueLayout(Kind.POINTER, order, bitSize, bitSize, Map.of());\n+    }\n+\n+    public Kind kind() {\n+        return kind;\n+    }\n+\n+    @Override\n+    public CValueLayout withOrder(ByteOrder order) {\n+        return (CValueLayout) super.withOrder(order);\n+    }\n+\n+    @Override\n+    public CValueLayout withName(String name) {\n+        return (CValueLayout) super.withName(name);\n+    }\n+\n+    @Override\n+    public CValueLayout withBitAlignment(long alignmentBits) {\n+        return (CValueLayout) super.withBitAlignment(alignmentBits);\n+    }\n+\n+    @Override\n+    public CValueLayout withAttribute(String name, Constable value) {\n+        return (CValueLayout) super.withAttribute(name, value);\n+    }\n+\n+    @Override\n+    protected CValueLayout dup(long alignment, Map<String, Constable> attributes) {\n+        return new CValueLayout(kind, order(), bitSize(), alignment, attributes);\n+    }\n+\n+    @Override\n+    public Optional<DynamicConstantDesc<ValueLayout>> describeConstable() {\n+        return Optional.of(decorateLayoutConstant(kind.bsm()));\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/CValueLayout.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.GroupLayout;\n@@ -30,1 +29,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -33,1 +31,2 @@\n-import java.nio.ByteOrder;\n+import static java.nio.ByteOrder.LITTLE_ENDIAN;\n+import static jdk.incubator.foreign.MemoryLayouts.ADDRESS;\n@@ -59,22 +58,0 @@\n-        \/**\n-         * The name of the layout attribute (see {@link MemoryLayout#attributes()} used for ABI classification. The\n-         * attribute value must be an enum constant from {@link ArgumentClass}.\n-         *\/\n-        public final static String CLASS_ATTRIBUTE_NAME = \"abi\/sysv\/class\";\n-\n-        \/**\n-         * Constants used for ABI classification. They are referred to by the layout attribute {@link #CLASS_ATTRIBUTE_NAME}.\n-         *\/\n-        public enum ArgumentClass {\n-            \/** Classification constant for integral values *\/\n-            INTEGER,\n-            \/** Classification constant for floating point values *\/\n-            SSE,\n-            \/** Classification constant for x87 floating point values *\/\n-            X87,\n-            \/** Classification constant for {@code complex long double} values *\/\n-            COMPLEX_87,\n-            \/** Classification constant for machine pointer values *\/\n-            POINTER;\n-        }\n-\n@@ -84,2 +61,1 @@\n-        public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n+        public static final ValueLayout C_CHAR = CValueLayout.ofChar(LITTLE_ENDIAN, 8);\n@@ -90,2 +66,1 @@\n-        public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n+        public static final ValueLayout C_SHORT = CValueLayout.ofShort(LITTLE_ENDIAN, 16);\n@@ -96,2 +71,1 @@\n-        public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n+        public static final ValueLayout C_INT = CValueLayout.ofInt(LITTLE_ENDIAN, 32);\n@@ -102,2 +76,1 @@\n-        public static final ValueLayout C_LONG = MemoryLayouts.BITS_64_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n+        public static final ValueLayout C_LONG = CValueLayout.ofLong(LITTLE_ENDIAN, 64);\n@@ -108,2 +81,1 @@\n-        public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n+        public static final ValueLayout C_LONGLONG = CValueLayout.ofLongLong(LITTLE_ENDIAN, 64);\n@@ -114,2 +86,1 @@\n-        public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.SSE);\n+        public static final ValueLayout C_FLOAT = CValueLayout.ofFloat(LITTLE_ENDIAN, 32);\n@@ -120,2 +91,1 @@\n-        public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.SSE);\n+        public static final ValueLayout C_DOUBLE = CValueLayout.ofDouble(LITTLE_ENDIAN, 64);\n@@ -126,8 +96,1 @@\n-        public static final ValueLayout C_LONGDOUBLE = MemoryLayout.ofValueBits(128, ByteOrder.LITTLE_ENDIAN)\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.X87);\n-\n-        \/**\n-         * The {@code complex long double} native type.\n-         *\/\n-        public static final GroupLayout C_COMPLEX_LONGDOUBLE = MemoryLayout.ofStruct(C_LONGDOUBLE, C_LONGDOUBLE)\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.COMPLEX_87);\n+        public static final ValueLayout C_LONGDOUBLE = CValueLayout.ofLongDouble(LITTLE_ENDIAN, 128);\n@@ -138,2 +101,1 @@\n-        public static final ValueLayout C_POINTER = MemoryLayouts.ADDRESS\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);\n+        public static final ValueLayout C_POINTER = CValueLayout.ofPointer(LITTLE_ENDIAN, ADDRESS.bitSize());\n@@ -162,18 +124,0 @@\n-        \/**\n-         * The name of the layout attribute (see {@link MemoryLayout#attributes()} used for ABI classification. The\n-         * attribute value must be an enum constant from {@link ArgumentClass}.\n-         *\/\n-        public final static String CLASS_ATTRIBUTE_NAME = \"abi\/windows\/class\";\n-\n-        \/**\n-         * Constants used for ABI classification. They are referred to by the layout attribute {@link #CLASS_ATTRIBUTE_NAME}.\n-         *\/\n-        public enum ArgumentClass {\n-            \/** Classification constant for integral values *\/\n-            INTEGER,\n-            \/** Classification constant for floating point values *\/\n-            FLOAT,\n-            \/** Classification constant for machine pointer values *\/\n-            POINTER;\n-        }\n-\n@@ -183,2 +127,1 @@\n-        public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n+        public static final ValueLayout C_CHAR = CValueLayout.ofChar(LITTLE_ENDIAN, 8);\n@@ -189,2 +132,1 @@\n-        public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n+        public static final ValueLayout C_SHORT = CValueLayout.ofShort(LITTLE_ENDIAN, 16);\n@@ -195,3 +137,1 @@\n-        public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n-\n+        public static final ValueLayout C_INT = CValueLayout.ofInt(LITTLE_ENDIAN, 32);\n@@ -201,2 +141,1 @@\n-        public static final ValueLayout C_LONG = MemoryLayouts.BITS_32_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n+        public static final ValueLayout C_LONG = CValueLayout.ofLong(LITTLE_ENDIAN, 32);\n@@ -207,2 +146,1 @@\n-        public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n+        public static final ValueLayout C_LONGLONG = CValueLayout.ofLongLong(LITTLE_ENDIAN, 64);\n@@ -213,2 +151,1 @@\n-        public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);\n+        public static final ValueLayout C_FLOAT = CValueLayout.ofFloat(LITTLE_ENDIAN, 32);\n@@ -219,2 +156,1 @@\n-        public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);\n+        public static final ValueLayout C_DOUBLE = CValueLayout.ofDouble(LITTLE_ENDIAN, 64);\n@@ -225,2 +161,1 @@\n-        public static final ValueLayout C_LONGDOUBLE = MemoryLayouts.BITS_64_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);\n+        public static final ValueLayout C_LONGDOUBLE = CValueLayout.ofLongDouble(LITTLE_ENDIAN, 64);\n@@ -231,2 +166,1 @@\n-        public static final ValueLayout C_POINTER = MemoryLayouts.ADDRESS\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);\n+        public static final ValueLayout C_POINTER = CValueLayout.ofPointer(LITTLE_ENDIAN, ADDRESS.bitSize());\n@@ -259,18 +193,0 @@\n-        \/**\n-         * The name of the layout attribute (see {@link MemoryLayout#attributes()} used for ABI classification. The\n-         * attribute value must be an enum constant from {@link ArgumentClass}.\n-         *\/\n-        public static final String CLASS_ATTRIBUTE_NAME = \"abi\/aarch64\/class\";\n-\n-        \/**\n-         * Constants used for ABI classification. They are referred to by the layout attribute {@link #CLASS_ATTRIBUTE_NAME}.\n-         *\/\n-        public enum ArgumentClass {\n-            \/** Classification constant for machine integral values *\/\n-            INTEGER,\n-            \/** Classification constant for machine floating point values *\/\n-            VECTOR,\n-            \/** Classification constant for machine pointer values *\/\n-            POINTER;\n-        }\n-\n@@ -280,2 +196,1 @@\n-        public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n+        public static final ValueLayout C_CHAR = CValueLayout.ofChar(LITTLE_ENDIAN, 8);\n@@ -286,2 +201,1 @@\n-        public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n+        public static final ValueLayout C_SHORT = CValueLayout.ofShort(LITTLE_ENDIAN, 16);\n@@ -292,2 +206,1 @@\n-        public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n+        public static final ValueLayout C_INT = CValueLayout.ofInt(LITTLE_ENDIAN, 32);\n@@ -298,2 +211,1 @@\n-        public static final ValueLayout C_LONG = MemoryLayouts.BITS_64_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n+        public static final ValueLayout C_LONG = CValueLayout.ofLong(LITTLE_ENDIAN, 64);\n@@ -304,2 +216,1 @@\n-        public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n+        public static final ValueLayout C_LONGLONG = CValueLayout.ofLongLong(LITTLE_ENDIAN, 64);\n@@ -310,2 +221,1 @@\n-        public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);\n+        public static final ValueLayout C_FLOAT = CValueLayout.ofFloat(LITTLE_ENDIAN, 32);\n@@ -316,2 +226,1 @@\n-        public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);\n+        public static final ValueLayout C_DOUBLE = CValueLayout.ofDouble(LITTLE_ENDIAN, 64);\n@@ -322,2 +231,1 @@\n-        public static final ValueLayout C_LONGDOUBLE = MemoryLayout.ofValueBits(128, ByteOrder.LITTLE_ENDIAN)\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);\n+        public static final ValueLayout C_LONGDOUBLE = CValueLayout.ofLongDouble(LITTLE_ENDIAN, 128);\n@@ -328,2 +236,1 @@\n-        public static final ValueLayout C_POINTER = MemoryLayouts.ADDRESS\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);\n+        public static final ValueLayout C_POINTER = CValueLayout.ofPointer(LITTLE_ENDIAN, ADDRESS.bitSize());\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/PlatformLayouts.java","additions":29,"deletions":122,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -89,4 +89,0 @@\n-    static AArch64.ArgumentClass argumentClassFor(MemoryLayout layout) {\n-        return (AArch64.ArgumentClass)layout.attribute(AArch64.CLASS_ATTRIBUTE_NAME).get();\n-    }\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64Linker.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,4 +32,1 @@\n-import jdk.internal.foreign.PlatformLayouts;\n-\n-import static jdk.internal.foreign.PlatformLayouts.*;\n-import static jdk.internal.foreign.abi.aarch64.AArch64Linker.argumentClassFor;\n+import jdk.internal.foreign.CValueLayout;\n@@ -48,3 +45,1 @@\n-        AArch64.ArgumentClass clazz = argumentClassFor(type);\n-        if (clazz == null) {\n-            \/\/padding not allowed here\n+        if (!(type instanceof CValueLayout)) {\n@@ -54,8 +49,5 @@\n-        if (clazz == AArch64.ArgumentClass.INTEGER) {\n-            return INTEGER;\n-        } else if(clazz == AArch64.ArgumentClass.POINTER) {\n-            return POINTER;\n-        } else if (clazz == AArch64.ArgumentClass.VECTOR) {\n-            return FLOAT;\n-        }\n-        throw new IllegalArgumentException(\"Unknown ABI class: \" + clazz);\n+        return switch (((CValueLayout) type).kind()) {\n+            case CHAR, SHORT, INT, LONG, LONGLONG -> INTEGER;\n+            case POINTER -> POINTER;\n+            case FLOAT, DOUBLE, LONGDOUBLE -> FLOAT;\n+        };\n@@ -83,2 +75,2 @@\n-        AArch64.ArgumentClass baseArgClass = argumentClassFor(baseType);\n-        if (baseArgClass != AArch64.ArgumentClass.VECTOR)\n+        TypeClass baseArgClass = classifyValueType((ValueLayout) baseType);\n+        if (baseArgClass != FLOAT)\n@@ -91,1 +83,1 @@\n-            AArch64.ArgumentClass argClass = argumentClassFor(elem);\n+            TypeClass argClass = classifyValueType((ValueLayout) elem);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/TypeClass.java","additions":10,"deletions":18,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -100,14 +100,0 @@\n-    static Optional<ArgumentClassImpl> argumentClassFor(MemoryLayout layout) {\n-        @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n-        Optional<SysV.ArgumentClass> argClassOpt =\n-                (Optional<SysV.ArgumentClass>)(Optional)layout.attribute(SysV.CLASS_ATTRIBUTE_NAME);\n-        return argClassOpt.map(argClass -> switch (argClass) {\n-            case INTEGER -> ArgumentClassImpl.INTEGER;\n-            case SSE -> ArgumentClassImpl.SSE;\n-            case X87 -> ArgumentClassImpl.X87;\n-            case COMPLEX_87 -> ArgumentClassImpl.COMPLEX_X87;\n-            case POINTER -> ArgumentClassImpl.POINTER;\n-            default -> null;\n-        });\n-    }\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.foreign.CValueLayout;\n@@ -38,2 +39,0 @@\n-import static jdk.internal.foreign.abi.x64.sysv.SysVx64Linker.argumentClassFor;\n-\n@@ -58,8 +57,7 @@\n-        ArgumentClassImpl argClass = classifyValueType(layout);\n-        switch (argClass) {\n-            case POINTER: kind = Kind.POINTER; break;\n-            case INTEGER: kind = Kind.INTEGER; break;\n-            case SSE: kind = Kind.FLOAT; break;\n-            default:\n-                throw new IllegalStateException();\n-        }\n+        ArgumentClassImpl argClass = argumentClassFor(layout);\n+        kind = switch (argClass) {\n+            case POINTER -> Kind.POINTER;\n+            case INTEGER -> Kind.INTEGER;\n+            case SSE -> Kind.FLOAT;\n+            default -> throw new IllegalStateException(\"Unexpected argument class: \" + argClass);\n+        };\n@@ -111,4 +109,3 @@\n-    \/\/ TODO: handle '__int128' and 'long double'\n-    private static ArgumentClassImpl classifyValueType(ValueLayout type) {\n-        if (type.byteSize() > 8) {\n-            throw new IllegalStateException(\"\");\n+    private static ArgumentClassImpl argumentClassFor(MemoryLayout layout) {\n+        if (!(layout instanceof CValueLayout)) {\n+            throw new IllegalStateException(\"Unexpected value layout: could not determine ABI class\");\n@@ -116,3 +113,7 @@\n-        ArgumentClassImpl clazz = SysVx64Linker.argumentClassFor(type)\n-                .orElseThrow(() -> new IllegalStateException(\"Unexpected value layout: could not determine ABI class\"));\n-        return clazz;\n+\n+        return switch (((CValueLayout) layout).kind()) {\n+            case CHAR, SHORT, INT, LONG, LONGLONG -> ArgumentClassImpl.INTEGER;\n+            case FLOAT, DOUBLE -> ArgumentClassImpl.SSE;\n+            case LONGDOUBLE -> ArgumentClassImpl.X87;\n+            case POINTER -> ArgumentClassImpl.POINTER;\n+        };\n@@ -123,6 +124,0 @@\n-        if (argumentClassFor(type)\n-                .filter(argClass -> argClass == ArgumentClassImpl.COMPLEX_X87)\n-                .isPresent()) {\n-            return COMPLEX_X87_CLASSES;\n-        }\n-\n@@ -233,1 +228,1 @@\n-                    classifyValueType((ValueLayout)l) :\n+                    argumentClassFor(l) :\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/TypeClass.java","additions":19,"deletions":24,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.incubator.foreign.SequenceLayout;\n@@ -31,1 +30,1 @@\n-import jdk.internal.foreign.PlatformLayouts;\n+import jdk.internal.foreign.CValueLayout;\n@@ -33,1 +32,0 @@\n-import static jdk.internal.foreign.PlatformLayouts.*;\n@@ -44,1 +42,0 @@\n-\n@@ -46,3 +43,1 @@\n-        Win64.ArgumentClass clazz = Windowsx64Linker.argumentClassFor(type);\n-        if (clazz == null) {\n-            \/\/padding not allowed here\n+        if (!(type instanceof CValueLayout)) {\n@@ -61,8 +56,9 @@\n-        if (clazz == Win64.ArgumentClass.INTEGER) {\n-            return INTEGER;\n-        } else if(clazz == Win64.ArgumentClass.POINTER) {\n-            return POINTER;\n-        } else if (clazz == Win64.ArgumentClass.FLOAT) {\n-            if (type.attribute(VARARGS_ATTRIBUTE_NAME)\n-                    .map(Boolean.class::cast).orElse(false)) {\n-                return VARARG_FLOAT;\n+        return switch (((CValueLayout) type).kind()) {\n+            case CHAR, SHORT, INT, LONG, LONGLONG -> INTEGER;\n+            case POINTER -> POINTER;\n+            case FLOAT, DOUBLE, LONGDOUBLE -> {\n+                 if (type.attribute(VARARGS_ATTRIBUTE_NAME)\n+                        .map(Boolean.class::cast).orElse(false)) {\n+                    yield VARARG_FLOAT;\n+                }\n+                yield FLOAT;\n@@ -70,3 +66,1 @@\n-            return FLOAT;\n-        }\n-        throw new IllegalArgumentException(\"Unknown ABI class: \" + clazz);\n+        };\n@@ -95,2 +89,0 @@\n-        } else if (type instanceof SequenceLayout) {\n-            return INTEGER;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/TypeClass.java","additions":12,"deletions":20,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -101,4 +101,0 @@\n-    static Win64.ArgumentClass argumentClassFor(MemoryLayout layout) {\n-        return (Win64.ArgumentClass)layout.attribute(Win64.CLASS_ATTRIBUTE_NAME).get();\n-    }\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,3 +26,1 @@\n-import jdk.internal.foreign.CABI;\n-\n-import static jdk.internal.foreign.PlatformLayouts.*;\n+import jdk.internal.foreign.CValueLayout;\n@@ -32,2 +30,0 @@\n-    public static final CABI ABI = CABI.current();\n-\n@@ -35,5 +31,1 @@\n-        return switch (ABI) {\n-            case SysV -> layout.attribute(SysV.CLASS_ATTRIBUTE_NAME).get() == SysV.ArgumentClass.INTEGER;\n-            case Win64 -> layout.attribute(Win64.CLASS_ATTRIBUTE_NAME).get() == Win64.ArgumentClass.INTEGER;\n-            case AArch64 -> layout.attribute(AArch64.CLASS_ATTRIBUTE_NAME).get() == AArch64.ArgumentClass.INTEGER;\n-        };\n+        return ((CValueLayout) layout).kind().isIntergral();\n@@ -43,5 +35,1 @@\n-        return switch (ABI) {\n-            case SysV -> layout.attribute(SysV.CLASS_ATTRIBUTE_NAME).get() == SysV.ArgumentClass.POINTER;\n-            case Win64 -> layout.attribute(Win64.CLASS_ATTRIBUTE_NAME).get() == Win64.ArgumentClass.POINTER;\n-            case AArch64 -> layout.attribute(AArch64.CLASS_ATTRIBUTE_NAME).get() == AArch64.ArgumentClass.POINTER;\n-        };\n+        return ((CValueLayout) layout).kind().isPointer();\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":3,"deletions":15,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ *\n+ * @run testng TestCondy\n+ *\/\n+\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryLayout;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.constant.Constable;\n+import java.lang.constant.ConstantDesc;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static jdk.incubator.foreign.CLinker.*;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestCondy {\n+\n+    @Test(dataProvider = \"constables\")\n+    public void testPublicResolve(Constable constable) throws ReflectiveOperationException {\n+        ConstantDesc desc = constable.describeConstable().orElseThrow();\n+        Object result = desc.resolveConstantDesc(MethodHandles.publicLookup());\n+        assertEquals(result, constable);\n+    }\n+\n+\n+    private static final MemoryLayout[] constants = {\n+        C_CHAR,\n+        C_SHORT,\n+        C_INT,\n+        C_LONG,\n+        C_LONGLONG,\n+        C_FLOAT,\n+        C_DOUBLE,\n+        C_LONGDOUBLE,\n+        C_POINTER\n+    };\n+\n+    @DataProvider\n+    public static Object[][] constables() {\n+        List<Constable> testValues = new ArrayList<>();\n+\n+        testValues.addAll(Arrays.asList(constants));\n+\n+        testValues.add(MemoryLayout.ofStruct(constants));\n+        testValues.add(MemoryLayout.ofUnion(constants));\n+\n+        for (MemoryLayout ml : constants) {\n+            testValues.add(MemoryLayout.ofSequence(ml));\n+            testValues.add(MemoryLayout.ofSequence(10, ml));\n+        }\n+\n+        testValues.add(FunctionDescriptor.ofVoid(constants));\n+        testValues.add(FunctionDescriptor.of(C_CHAR, constants));\n+\n+        return testValues.stream().map(e -> new Object[] { e }).toArray(Object[][]::new);\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestCondy.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"}]}