{"files":[{"patch":"@@ -53,2 +53,2 @@\n-    static IllegalStateException newIllegalStateExceptionForMisalignedAccess(long address) {\n-        return new IllegalStateException(\"Misaligned access at address: \" + address);\n+    static IllegalArgumentException newIllegalArgumentExceptionForMisalignedAccess(long address) {\n+        return new IllegalArgumentException(\"Misaligned access at address: \" + address);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemoryAccessVarHandleBase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-            throw MemoryAccessVarHandleBase.newIllegalStateExceptionForMisalignedAccess(address);\n+            throw MemoryAccessVarHandleBase.newIllegalArgumentExceptionForMisalignedAccess(address);\n@@ -118,0 +118,1 @@\n+        long maxAlignMask = bb.maxAlignMask();\n@@ -120,2 +121,2 @@\n-            if ((base & alignmentMask) != 0) {\n-                throw MemoryAccessVarHandleBase.newIllegalStateExceptionForMisalignedAccess(address);\n+            if (((base | maxAlignMask) & alignmentMask) != 0) {\n+                throw MemoryAccessVarHandleBase.newIllegalArgumentExceptionForMisalignedAccess(address);\n@@ -124,2 +125,2 @@\n-            if ((address & alignmentMask) != 0) {\n-                throw MemoryAccessVarHandleBase.newIllegalStateExceptionForMisalignedAccess(address);\n+            if (((address | maxAlignMask) & alignmentMask) != 0) {\n+                throw MemoryAccessVarHandleBase.newIllegalArgumentExceptionForMisalignedAccess(address);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleMemoryAccess.java.template","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+    public abstract long maxAlignMask();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/foreign\/MemorySegmentProxy.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -175,0 +175,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -193,0 +195,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -211,0 +215,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -229,0 +235,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -247,0 +255,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -265,0 +275,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -283,0 +295,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -301,0 +315,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -319,0 +335,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -337,0 +355,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -355,0 +375,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -373,0 +395,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -391,0 +415,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -409,0 +435,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -427,0 +455,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -445,0 +475,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -463,0 +495,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -481,0 +515,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -499,0 +535,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -517,0 +555,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -535,0 +575,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -553,0 +595,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -571,0 +615,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -589,0 +635,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -607,0 +655,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -625,0 +675,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -643,0 +695,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -661,0 +715,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -679,0 +735,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -697,0 +755,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -715,0 +775,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -733,0 +795,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAddress.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -142,0 +142,34 @@\n+ * <h2 id=\"segment-alignment\">Alignment<\/h2>\n+ *\n+ * When dereferencing a memory segment using a layout, the runtime must check that the segment address being dereferenced\n+ * matches the layout's {@linkplain MemoryLayout#byteAlignment() alignment constraints}. If the segment being\n+ * dereferenced is a native segment, then it has a concrete {@linkplain #address() base address}, which can\n+ * be used to perform the alignment check. The pseudo-function below demonstrates this:\n+ *\n+ * <blockquote><pre>{@code\n+boolean isAligned(MemorySegment segment, long offset, MemoryLayout layout) {\n+   return ((segment.address().toRawLongValue() + offset) % layout.byteAlignment()) == 0\n+}\n+ * }<\/pre><\/blockquote>\n+ *\n+ * If, however, the segment being dereferenced is a heap segment, the above function will not work: a heap\n+ * segment's base address is <em>virtualized<\/em> and, as such, cannot be used to construct an alignment check. Instead,\n+ * heap segments are assumed to produce addresses which are never more aligned than the element size of the Java array from which\n+ * they have originated from. Let {@code H} be a heap segment, and {@code AT} be the type of the Java array\n+ * backing {@code H} and {@code A} be the alignment of the addresses produced by {@code H}; then:\n+ *\n+ * <ul>\n+ *     <li>if {@code AT = boolean[]}, then {@code A = 1}\n+ *     <li>if {@code AT = byte[]}, then {@code A = 1}\n+ *     <li>if {@code AT = short[]}, then {@code A = 2}\n+ *     <li>if {@code AT = char[]}, then {@code A = 2}\n+ *     <li>if {@code AT = int[]}, then {@code A = 4}\n+ *     <li>if {@code AT = float[]}, then {@code A = 4}\n+ *     <li>if {@code AT = long[]}, then {@code A = 8}\n+ *     <li>if {@code AT = double[]}, then {@code A = 8}\n+ * <\/ul>\n+ *\n+ * Note that the above definition is conservative: it might be possible, for instance, that a heap segment\n+ * constructed from a {@code byte[]} might have a subset of addresses {@code S} which happen to be 8-byte aligned. But determining\n+ * which segment addresses belong to {@code S} requires reasoning about details which are ultimately implementation-dependent.\n+ *\n@@ -229,1 +263,3 @@\n-     * {@code elementLayout} size is greater than zero.\n+     * {@code elementLayout} size is greater than zero, if this segment is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n+     * or if the {@code elementLayout} alignment is greater than its size.\n@@ -243,1 +279,3 @@\n-     * {@code elementLayout} size is greater than zero.\n+     * {@code elementLayout} size is greater than zero, if this segment is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n+     * or if the {@code elementLayout} alignment is greater than its size.\n@@ -984,3 +1022,3 @@\n-     * @throws IllegalArgumentException if the element layouts have different sizes, if the source offset is incompatible\n-     * with the alignment constraints in the source element layout, or if the destination offset is incompatible with the\n-     * alignment constraints in the destination element layout.\n+     * @throws IllegalArgumentException if the element layouts have different sizes, if the source (resp. destination) segment\/offset are\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the source\n+     * (resp. destination) element layout, or if the source (resp. destination) element layout alignment is greater than its size.\n@@ -1005,1 +1043,4 @@\n-            throw new IllegalArgumentException(\"Source and destination layouts must have same sizes\");\n+            throw new IllegalArgumentException(\"Source and destination layouts must have same size\");\n+        }\n+        if (srcElementLayout.byteAlignment() > srcElementLayout.byteSize()) {\n+            throw new IllegalArgumentException(\"Source layout alignment greater than its size\");\n@@ -1007,1 +1048,4 @@\n-        if (srcOffset % srcElementLayout.byteAlignment() != 0) {\n+        if (dstElementLayout.byteAlignment() > dstElementLayout.byteSize()) {\n+            throw new IllegalArgumentException(\"Destination layout alignment greater than its size\");\n+        }\n+        if (!srcImpl.isAlignedForElement(srcOffset, srcElementLayout)) {\n@@ -1010,1 +1054,1 @@\n-        if (dstOffset % dstElementLayout.byteAlignment() != 0) {\n+        if (!dstImpl.isAlignedForElement(dstOffset, dstElementLayout)) {\n@@ -1036,0 +1080,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -1069,0 +1115,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -1102,0 +1150,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -1135,0 +1185,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -1168,0 +1220,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -1201,0 +1255,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -1234,0 +1290,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -1267,0 +1325,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -1300,0 +1360,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -1333,0 +1395,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -1366,0 +1430,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -1368,0 +1434,1 @@\n+     * @throws UnsupportedOperationException if this segment is {@linkplain #isReadOnly() read-only}.\n@@ -1399,0 +1466,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -1432,0 +1501,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -1465,0 +1536,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -1498,0 +1571,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -1531,0 +1606,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -1568,1 +1645,3 @@\n-     * or if the destination array component type does not match the carrier of the source element layout.\n+     * if the destination array component type does not match the carrier of the source element layout, if the source\n+     * segment\/offset are <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the source element layout,\n+     * or if the destination element layout alignment is greater than its size.\n@@ -1584,0 +1663,6 @@\n+        if (srcLayout.byteAlignment() > srcLayout.byteSize()) {\n+            throw new IllegalArgumentException(\"Source layout alignment greater than its size\");\n+        }\n+        if (!srcImpl.isAlignedForElement(srcOffset, srcLayout)) {\n+            throw new IllegalArgumentException(\"Source segment incompatible with alignment constraints\");\n+        }\n@@ -1609,1 +1694,3 @@\n-     * or if the source array component type does not match the carrier of the destination element layout.\n+     * if the source array component type does not match the carrier of the destination element layout, if the destination\n+     * segment\/offset are <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the destination element layout,\n+     * or if the destination element layout alignment is greater than its size.\n@@ -1626,0 +1713,6 @@\n+        if (dstLayout.byteAlignment() > dstLayout.byteSize()) {\n+            throw new IllegalArgumentException(\"Destination layout alignment greater than its size\");\n+        }\n+        if (!destImpl.isAlignedForElement(dstOffset, dstLayout)) {\n+            throw new IllegalArgumentException(\"Target segment incompatible with alignment constraints\");\n+        }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":103,"deletions":10,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -127,2 +127,8 @@\n-        if (byteSize() % elementLayout.byteSize() != 0) {\n-            throw new IllegalArgumentException(\"Segment size is no a multiple of layout size\");\n+        if (elementLayout.byteAlignment() > elementLayout.byteSize()) {\n+            throw new IllegalArgumentException(\"Element layout alignment greater than its size\");\n+        }\n+        if (!isAlignedForElement(0, elementLayout)) {\n+            throw new IllegalArgumentException(\"Incompatible alignment constraints\");\n+        }\n+        if (!Utils.isAligned(byteSize(), elementLayout.byteSize())) {\n+            throw new IllegalArgumentException(\"Segment size is not a multiple of layout size\");\n@@ -386,0 +392,5 @@\n+    @ForceInline\n+    public final boolean isAlignedForElement(long offset, MemoryLayout layout) {\n+        return (((unsafeGetOffset() + offset) | maxAlignMask()) & (layout.byteAlignment() - 1)) == 0;\n+    }\n+\n@@ -387,1 +398,1 @@\n-        if (length % elemSize != 0) {\n+        if (!Utils.isAligned(length, elemSize)) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -50,0 +50,5 @@\n+    private static final long MAX_ALIGN_1 = 1;\n+    private static final long MAX_ALIGN_2 = 2;\n+    private static final long MAX_ALIGN_4 = 4;\n+    private static final long MAX_ALIGN_8 = 8;\n+\n@@ -103,0 +108,5 @@\n+\n+        @Override\n+        public long maxAlignMask() {\n+            return MAX_ALIGN_1;\n+        }\n@@ -126,0 +136,5 @@\n+\n+        @Override\n+        public long maxAlignMask() {\n+            return MAX_ALIGN_2;\n+        }\n@@ -149,0 +164,5 @@\n+\n+        @Override\n+        public long maxAlignMask() {\n+            return MAX_ALIGN_2;\n+        }\n@@ -172,0 +192,5 @@\n+\n+        @Override\n+        public long maxAlignMask() {\n+            return MAX_ALIGN_4;\n+        }\n@@ -195,0 +220,5 @@\n+\n+        @Override\n+        public long maxAlignMask() {\n+            return MAX_ALIGN_8;\n+        }\n@@ -218,0 +248,5 @@\n+\n+        @Override\n+        public long maxAlignMask() {\n+            return MAX_ALIGN_4;\n+        }\n@@ -241,0 +276,5 @@\n+\n+        @Override\n+        public long maxAlignMask() {\n+            return MAX_ALIGN_8;\n+        }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -285,1 +285,1 @@\n-        if (path.offset % alignment != 0) {\n+        if (!Utils.isAligned(path.offset, alignment)) {\n@@ -289,1 +289,1 @@\n-            if (stride % alignment != 0) {\n+            if (!Utils.isAligned(stride, alignment)) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -95,0 +95,5 @@\n+    @Override\n+    public long maxAlignMask() {\n+        return 0;\n+    }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-        if (bits % 8 == 0) {\n+        if (Utils.isAligned(bits, 8)) {\n@@ -176,0 +176,5 @@\n+\n+    @ForceInline\n+    public static boolean isAligned(long offset, long align) {\n+        return (offset & (align - 1)) == 0;\n+    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestHeapAlignment\n+ *\/\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import static org.testng.Assert.fail;\n+\n+public class TestHeapAlignment {\n+\n+    @Test(dataProvider = \"layouts\")\n+    public void testHeapAlignment(MemorySegment segment, int align, Object val, Object arr, ValueLayout layout, Function<Object, MemorySegment> segmentFactory) {\n+        assertAligned(align, layout, () -> layout.varHandle().get(segment));\n+        assertAligned(align, layout, () -> layout.varHandle().set(segment, val));\n+        MemoryLayout seq = MemoryLayout.sequenceLayout(10, layout);\n+        assertAligned(align, layout, () -> seq.varHandle(MemoryLayout.PathElement.sequenceElement()).get(segment, 0L));\n+        assertAligned(align, layout, () -> seq.varHandle(MemoryLayout.PathElement.sequenceElement()).set(segment, 0L, val));\n+        assertAligned(align, layout, () -> segment.spliterator(layout));\n+        if (arr != null) {\n+            assertAligned(align, layout, () -> MemorySegment.copy(arr, 0, segment, layout, 0, 1));\n+            assertAligned(align, layout, () -> MemorySegment.copy(arr, 0, segment, layout, 0, 1));\n+            assertAligned(align, layout, () -> {\n+                MemorySegment other = segmentFactory.apply(arr);\n+                MemorySegment.copy(other, layout, 0, segment, layout, 0, 1);\n+            });\n+            assertAligned(align, layout, () -> {\n+                MemorySegment other = segmentFactory.apply(arr);\n+                MemorySegment.copy(segment, layout, 0, other, layout, 0, 1);\n+            });\n+        }\n+    }\n+\n+    static void assertAligned(int align, ValueLayout layout, Runnable runnable) {\n+        boolean shouldFail = layout.byteAlignment() > align && align != -1;\n+        try {\n+            runnable.run();\n+            if (shouldFail) {\n+                fail(\"Should not get here!\");\n+            }\n+        } catch (IllegalArgumentException ex) {\n+            if (!shouldFail) {\n+                fail(\"Should not get here!\");\n+            } else if (!ex.getMessage().contains(\"alignment\") && !ex.getMessage().contains(\"Misaligned\")) {\n+                fail(\"Unexpected exception: \" + ex);\n+            }\n+        } catch (Throwable ex) {\n+            if (!shouldFail) {\n+                fail(\"Should not get here!\");\n+            } else {\n+                fail(\"Unexpected exception\" + ex);\n+            }\n+        }\n+    }\n+\n+    static final ValueLayout.OfChar JAVA_CHAR_ALIGNED = ValueLayout.JAVA_CHAR.withBitAlignment(16);\n+    static final ValueLayout.OfShort JAVA_SHORT_ALIGNED = ValueLayout.JAVA_SHORT.withBitAlignment(16);\n+    static final ValueLayout.OfInt JAVA_INT_ALIGNED = ValueLayout.JAVA_INT.withBitAlignment(32);\n+    static final ValueLayout.OfFloat JAVA_FLOAT_ALIGNED = ValueLayout.JAVA_FLOAT.withBitAlignment(32);\n+    static final ValueLayout.OfLong JAVA_LONG_ALIGNED = ValueLayout.JAVA_LONG.withBitAlignment(64);\n+    static final ValueLayout.OfDouble JAVA_DOUBLE_ALIGNED = ValueLayout.JAVA_DOUBLE.withBitAlignment(64);\n+    static final ValueLayout.OfAddress ADDRESS_ALIGNED = ValueLayout.ADDRESS.withBitAlignment(ValueLayout.ADDRESS.bitSize());\n+\n+    record SegmentsAndAlignment(MemorySegment segment, int align) {\n+        static SegmentsAndAlignment[] HEAP_SEGMENTS_AND_ALIGNMENTS = {\n+                new SegmentsAndAlignment(MemorySegment.ofArray(new byte[8]), 1),\n+                new SegmentsAndAlignment(MemorySegment.ofArray(new short[4]), 2),\n+                new SegmentsAndAlignment(MemorySegment.ofArray(new char[4]), 2),\n+                new SegmentsAndAlignment(MemorySegment.ofArray(new int[2]), 4),\n+                new SegmentsAndAlignment(MemorySegment.ofArray(new float[2]), 4),\n+                new SegmentsAndAlignment(MemorySegment.ofArray(new long[1]), 8),\n+                new SegmentsAndAlignment(MemorySegment.ofArray(new double[1]), 8),\n+                new SegmentsAndAlignment(MemorySegment.allocateNative(8, ResourceScope.newImplicitScope()), -1),\n+        };\n+    }\n+\n+    @DataProvider\n+    public static Object[][] layouts() {\n+        List<Object[]> layouts = new ArrayList<>();\n+        for (SegmentsAndAlignment testCase : SegmentsAndAlignment.HEAP_SEGMENTS_AND_ALIGNMENTS) {\n+            layouts.add(new Object[] { testCase.segment, testCase.align, (byte) 42, new byte[]{42}, ValueLayout.JAVA_BYTE, (Function<byte[], MemorySegment>)MemorySegment::ofArray });\n+            layouts.add(new Object[] { testCase.segment, testCase.align, true, null, ValueLayout.JAVA_BOOLEAN, null });\n+            layouts.add(new Object[] { testCase.segment, testCase.align, (char) 42, new char[]{42}, JAVA_CHAR_ALIGNED, (Function<char[], MemorySegment>)MemorySegment::ofArray });\n+            layouts.add(new Object[] { testCase.segment, testCase.align, (short) 42, new short[]{42}, JAVA_SHORT_ALIGNED, (Function<short[], MemorySegment>)MemorySegment::ofArray });\n+            layouts.add(new Object[] { testCase.segment, testCase.align, 42, new int[]{42}, JAVA_INT_ALIGNED, (Function<int[], MemorySegment>)MemorySegment::ofArray });\n+            layouts.add(new Object[] { testCase.segment, testCase.align, 42f, new float[]{42}, JAVA_FLOAT_ALIGNED, (Function<float[], MemorySegment>)MemorySegment::ofArray });\n+            layouts.add(new Object[] { testCase.segment, testCase.align, 42L, new long[]{42}, JAVA_LONG_ALIGNED, (Function<long[], MemorySegment>)MemorySegment::ofArray });\n+            layouts.add(new Object[] { testCase.segment, testCase.align, 42d, new double[]{42}, JAVA_DOUBLE_ALIGNED, (Function<double[], MemorySegment>)MemorySegment::ofArray });\n+            layouts.add(new Object[] { testCase.segment, testCase.align, MemoryAddress.ofLong(42), null, ADDRESS_ALIGNED, null });\n+        }\n+        return layouts.toArray(new Object[0][]);\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestHeapAlignment.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -77,1 +77,1 @@\n-        } catch (IllegalStateException ex) {\n+        } catch (IllegalArgumentException ex) {\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAlignment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-    @Test(expectedExceptions = IllegalStateException.class)\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n","filename":"test\/jdk\/java\/foreign\/TestVarHandleCombinators.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -64,0 +65,4 @@\n+\n+    static final ValueLayout.OfInt JAVA_INT_ALIGNED = JAVA_INT.withBitAlignment(32);\n+    static final VarHandle VH_int_aligned = MemoryLayout.sequenceLayout(JAVA_INT_ALIGNED).varHandle(sequenceElement());\n+\n@@ -128,0 +133,9 @@\n+    @Benchmark\n+    public int segment_loop_aligned() {\n+        int sum = 0;\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            sum += (int) VH_int_aligned.get(segment, (long) i);\n+        }\n+        return sum;\n+    }\n+\n@@ -148,0 +162,9 @@\n+    @Benchmark\n+    public int segment_loop_instance_aligned() {\n+        int res = 0;\n+        for (int i = 0; i < ELEM_SIZE; i ++) {\n+            res += segment.get(JAVA_INT_ALIGNED, i * CARRIER_SIZE);\n+        }\n+        return res;\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstant.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -69,1 +70,6 @@\n-    MemorySegment segment;\n+\n+    static final ValueLayout.OfInt JAVA_INT_ALIGNED = JAVA_INT.withBitAlignment(32);\n+    static final VarHandle VH_int_aligned = MemoryLayout.sequenceLayout(JAVA_INT_ALIGNED).varHandle(sequenceElement());\n+    static final int UNSAFE_INT_BASE = unsafe.arrayBaseOffset(int[].class);\n+\n+    MemorySegment segment, alignedSegment;\n@@ -71,0 +77,1 @@\n+    int[] alignedBase;\n@@ -98,0 +105,4 @@\n+        alignedBase = new int[ELEM_SIZE];\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            unsafe.putInt(base, UNSAFE_INT_BASE + (i * CARRIER_SIZE) , i);\n+        }\n@@ -99,0 +110,1 @@\n+        alignedSegment = MemorySegment.ofArray(alignedBase);\n@@ -138,0 +150,9 @@\n+    @Benchmark\n+    public int segment_loop_aligned() {\n+        int sum = 0;\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            sum += (int) VH_int_aligned.get(alignedSegment, (long) i);\n+        }\n+        return sum;\n+    }\n+\n@@ -147,0 +168,9 @@\n+    @Benchmark\n+    public int segment_loop_instance_aligned() {\n+        int res = 0;\n+        for (int i = 0; i < ELEM_SIZE; i ++) {\n+            res += alignedSegment.get(JAVA_INT_ALIGNED, i * CARRIER_SIZE);\n+        }\n+        return res;\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantHeap.java","additions":31,"deletions":1,"binary":false,"changes":32,"status":"modified"}]}