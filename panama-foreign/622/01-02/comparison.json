{"files":[{"patch":"@@ -119,1 +119,1 @@\n-        if (skipAlignmentMaskCheck && maxAlignMask == 0) {\n+        if (skipAlignmentMaskCheck) {\n@@ -121,1 +121,1 @@\n-            if ((base & alignmentMask) != 0) {\n+            if (((base | maxAlignMask) & alignmentMask) != 0) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleMemoryAccess.java.template","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.MemoryLayout;\n@@ -50,0 +51,3 @@\n+        MemoryLayout seq = MemoryLayout.sequenceLayout(10, layout);\n+        assertAligned(align, layout, () -> seq.varHandle(MemoryLayout.PathElement.sequenceElement()).get(segment, 0L));\n+        assertAligned(align, layout, () -> seq.varHandle(MemoryLayout.PathElement.sequenceElement()).set(segment, 0L, val));\n","filename":"test\/jdk\/java\/foreign\/TestHeapAlignment.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,0 +65,4 @@\n+\n+    static final ValueLayout.OfInt JAVA_INT_ALIGNED = JAVA_INT.withBitAlignment(32);\n+    static final VarHandle VH_int_aligned = MemoryLayout.sequenceLayout(JAVA_INT_ALIGNED).varHandle(sequenceElement());\n+\n@@ -129,0 +133,9 @@\n+    @Benchmark\n+    public int segment_loop_aligned() {\n+        int sum = 0;\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            sum += (int) VH_int_aligned.get(segment, (long) i);\n+        }\n+        return sum;\n+    }\n+\n@@ -149,2 +162,0 @@\n-    static final ValueLayout.OfInt JAVA_INT_ALIGNED = JAVA_INT.withBitAlignment(32);\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstant.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -70,1 +70,6 @@\n-    MemorySegment segment;\n+\n+    static final ValueLayout.OfInt JAVA_INT_ALIGNED = JAVA_INT.withBitAlignment(32);\n+    static final VarHandle VH_int_aligned = MemoryLayout.sequenceLayout(JAVA_INT_ALIGNED).varHandle(sequenceElement());\n+    static final int UNSAFE_INT_BASE = unsafe.arrayBaseOffset(int[].class);\n+\n+    MemorySegment segment, alignedSegment;\n@@ -72,0 +77,1 @@\n+    int[] alignedBase;\n@@ -99,0 +105,4 @@\n+        alignedBase = new int[ELEM_SIZE];\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            unsafe.putInt(base, UNSAFE_INT_BASE + (i * CARRIER_SIZE) , i);\n+        }\n@@ -100,0 +110,1 @@\n+        alignedSegment = MemorySegment.ofArray(alignedBase);\n@@ -139,0 +150,9 @@\n+    @Benchmark\n+    public int segment_loop_aligned() {\n+        int sum = 0;\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            sum += (int) VH_int_aligned.get(alignedSegment, (long) i);\n+        }\n+        return sum;\n+    }\n+\n@@ -148,2 +168,0 @@\n-    static final ValueLayout.OfInt JAVA_INT_ALIGNED = JAVA_INT.withBitAlignment(32);\n-\n@@ -154,1 +172,1 @@\n-            res += segment.get(JAVA_INT_ALIGNED, i * CARRIER_SIZE);\n+            res += alignedSegment.get(JAVA_INT_ALIGNED, i * CARRIER_SIZE);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantHeap.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"}]}