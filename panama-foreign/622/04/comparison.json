{"files":[{"patch":"@@ -53,2 +53,2 @@\n-    static IllegalStateException newIllegalStateExceptionForMisalignedAccess(long address) {\n-        return new IllegalStateException(\"Misaligned access at address: \" + address);\n+    static IllegalArgumentException newIllegalArgumentExceptionForMisalignedAccess(long address) {\n+        return new IllegalArgumentException(\"Misaligned access at address: \" + address);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemoryAccessVarHandleBase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-            throw MemoryAccessVarHandleBase.newIllegalStateExceptionForMisalignedAccess(address);\n+            throw MemoryAccessVarHandleBase.newIllegalArgumentExceptionForMisalignedAccess(address);\n@@ -118,0 +118,1 @@\n+        long maxAlignMask = bb.maxAlignMask();\n@@ -120,2 +121,2 @@\n-            if ((base & alignmentMask) != 0) {\n-                throw MemoryAccessVarHandleBase.newIllegalStateExceptionForMisalignedAccess(address);\n+            if (((base | maxAlignMask) & alignmentMask) != 0) {\n+                throw MemoryAccessVarHandleBase.newIllegalArgumentExceptionForMisalignedAccess(address);\n@@ -124,2 +125,2 @@\n-            if ((address & alignmentMask) != 0) {\n-                throw MemoryAccessVarHandleBase.newIllegalStateExceptionForMisalignedAccess(address);\n+            if (((address | maxAlignMask) & alignmentMask) != 0) {\n+                throw MemoryAccessVarHandleBase.newIllegalArgumentExceptionForMisalignedAccess(address);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleMemoryAccess.java.template","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+    public abstract long maxAlignMask();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/foreign\/MemorySegmentProxy.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -175,0 +175,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -193,0 +195,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -211,0 +215,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -229,0 +235,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -247,0 +255,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -265,0 +275,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -283,0 +295,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -301,0 +315,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -319,0 +335,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -337,0 +355,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -355,0 +375,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -373,0 +395,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -391,0 +415,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -409,0 +435,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -427,0 +455,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -445,0 +475,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -463,0 +495,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -481,0 +515,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -499,0 +535,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -517,0 +555,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -535,0 +575,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -553,0 +595,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -571,0 +615,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -589,0 +635,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -607,0 +655,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -625,0 +675,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -643,0 +695,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -661,0 +715,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -679,0 +735,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -697,0 +755,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -715,0 +775,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -733,0 +795,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAddress.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -142,0 +142,50 @@\n+ * <h2 id=\"segment-alignment\">Alignment<\/h2>\n+ *\n+ * When dereferencing a memory segment using a layout, the runtime must check that the segment address being dereferenced\n+ * matches the layout's {@linkplain MemoryLayout#byteAlignment() alignment constraints}. If the segment being\n+ * dereferenced is a native segment, then it has a concrete {@linkplain #address() base address}, which can\n+ * be used to perform the alignment check. The pseudo-function below demonstrates this:\n+ *\n+ * <blockquote><pre>{@code\n+boolean isAligned(MemorySegment segment, long offset, MemoryLayout layout) {\n+   return ((segment.address().toRawLongValue() + offset) % layout.byteAlignment()) == 0\n+}\n+ * }<\/pre><\/blockquote>\n+ *\n+ * If, however, the segment being dereferenced is a heap segment, the above function will not work: a heap\n+ * segment's base address is <em>virtualized<\/em> and, as such, cannot be used to construct an alignment check. Instead,\n+ * heap segments are assumed to produce addresses which are never more aligned than the element size of the Java array from which\n+ * they have originated from, as shown in the following table:\n+ *\n+ * <blockquote><table class=\"plain\">\n+ * <caption style=\"display:none\">Array type of an array backing a segment and its address alignment<\/caption>\n+ * <thead>\n+ * <tr>\n+ *     <th scope=\"col\">Array type<\/th>\n+ *     <th scope=\"col\">Alignment<\/th>\n+ * <\/tr>\n+ * <\/thead>\n+ * <tbody>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code boolean[]}<\/th>\n+ *     <td style=\"text-align:center;\">{@code 1}<\/td><\/tr>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code byte[]}<\/th>\n+ *     <td style=\"text-align:center;\">{@code 1}<\/td><\/tr>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code char[]}<\/th>\n+ *     <td style=\"text-align:center;\">{@code 2}<\/td><\/tr>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code short[]}<\/th>\n+ *     <td style=\"text-align:center;\">{@code 2}<\/td><\/tr>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code int[]}<\/th>\n+ *     <td style=\"text-align:center;\">{@code 4}<\/td><\/tr>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code float[]}<\/th>\n+ *     <td style=\"text-align:center;\">{@code 4}<\/td><\/tr>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code long[]}<\/th>\n+ *     <td style=\"text-align:center;\">{@code 8}<\/td><\/tr>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code double[]}<\/th>\n+ *     <td style=\"text-align:center;\">{@code 8}<\/td><\/tr>\n+ * <\/tbody>\n+ * <\/table><\/blockquote>\n+ *\n+ * Note that the above definition is conservative: it might be possible, for instance, that a heap segment\n+ * constructed from a {@code byte[]} might have a subset of addresses {@code S} which happen to be 8-byte aligned. But determining\n+ * which segment addresses belong to {@code S} requires reasoning about details which are ultimately implementation-dependent.\n+ *\n@@ -229,1 +279,3 @@\n-     * {@code elementLayout} size is greater than zero.\n+     * {@code elementLayout} size is greater than zero, if this segment is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n+     * or if the {@code elementLayout} alignment is greater than its size.\n@@ -243,1 +295,3 @@\n-     * {@code elementLayout} size is greater than zero.\n+     * {@code elementLayout} size is greater than zero, if this segment is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n+     * or if the {@code elementLayout} alignment is greater than its size.\n@@ -984,3 +1038,3 @@\n-     * @throws IllegalArgumentException if the element layouts have different sizes, if the source offset is incompatible\n-     * with the alignment constraints in the source element layout, or if the destination offset is incompatible with the\n-     * alignment constraints in the destination element layout.\n+     * @throws IllegalArgumentException if the element layouts have different sizes, if the source (resp. destination) segment\/offset are\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the source\n+     * (resp. destination) element layout, or if the source (resp. destination) element layout alignment is greater than its size.\n@@ -1005,1 +1059,1 @@\n-            throw new IllegalArgumentException(\"Source and destination layouts must have same sizes\");\n+            throw new IllegalArgumentException(\"Source and destination layouts must have same size\");\n@@ -1007,1 +1061,3 @@\n-        if (srcOffset % srcElementLayout.byteAlignment() != 0) {\n+        Utils.checkNotHyperAligned(srcElementLayout, \"Source layout alignment greater than its size\");\n+        Utils.checkNotHyperAligned(dstElementLayout, \"Destination layout alignment greater than its size\");\n+        if (!srcImpl.isAlignedForElement(srcOffset, srcElementLayout)) {\n@@ -1010,1 +1066,1 @@\n-        if (dstOffset % dstElementLayout.byteAlignment() != 0) {\n+        if (!dstImpl.isAlignedForElement(dstOffset, dstElementLayout)) {\n@@ -1036,0 +1092,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -1069,0 +1127,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -1102,0 +1162,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -1135,0 +1197,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -1168,0 +1232,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -1201,0 +1267,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -1234,0 +1302,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -1267,0 +1337,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -1300,0 +1372,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -1333,0 +1407,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -1338,0 +1414,1 @@\n+        Utils.checkNotHyperAligned(layout, \"Layout alignment greater than its size\");\n@@ -1354,0 +1431,1 @@\n+        Utils.checkNotHyperAligned(layout, \"Layout alignment greater than its size\");\n@@ -1366,0 +1444,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -1368,0 +1448,1 @@\n+     * @throws UnsupportedOperationException if this segment is {@linkplain #isReadOnly() read-only}.\n@@ -1371,0 +1452,1 @@\n+        Utils.checkNotHyperAligned(layout, \"Layout alignment greater than its size\");\n@@ -1387,0 +1469,1 @@\n+        Utils.checkNotHyperAligned(layout, \"Layout alignment greater than its size\");\n@@ -1399,0 +1482,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -1404,0 +1489,1 @@\n+        Utils.checkNotHyperAligned(layout, \"Layout alignment greater than its size\");\n@@ -1420,0 +1506,1 @@\n+        Utils.checkNotHyperAligned(layout, \"Layout alignment greater than its size\");\n@@ -1432,0 +1519,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -1437,0 +1526,1 @@\n+        Utils.checkNotHyperAligned(layout, \"Layout alignment greater than its size\");\n@@ -1453,0 +1543,1 @@\n+        Utils.checkNotHyperAligned(layout, \"Layout alignment greater than its size\");\n@@ -1465,0 +1556,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -1470,0 +1563,1 @@\n+        Utils.checkNotHyperAligned(layout, \"Layout alignment greater than its size\");\n@@ -1486,0 +1580,1 @@\n+        Utils.checkNotHyperAligned(layout, \"Layout alignment greater than its size\");\n@@ -1498,0 +1593,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -1503,0 +1600,1 @@\n+        Utils.checkNotHyperAligned(layout, \"Layout alignment greater than its size\");\n@@ -1519,0 +1617,1 @@\n+        Utils.checkNotHyperAligned(layout, \"Layout alignment greater than its size\");\n@@ -1531,0 +1630,2 @@\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n@@ -1536,0 +1637,1 @@\n+        Utils.checkNotHyperAligned(layout, \"Layout alignment greater than its size\");\n@@ -1552,0 +1654,1 @@\n+        Utils.checkNotHyperAligned(layout, \"Layout alignment greater than its size\");\n@@ -1568,1 +1671,3 @@\n-     * or if the destination array component type does not match the carrier of the source element layout.\n+     * if the destination array component type does not match the carrier of the source element layout, if the source\n+     * segment\/offset are <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the source element layout,\n+     * or if the destination element layout alignment is greater than its size.\n@@ -1584,0 +1689,4 @@\n+        Utils.checkNotHyperAligned(srcLayout, \"Source layout alignment greater than its size\");\n+        if (!srcImpl.isAlignedForElement(srcOffset, srcLayout)) {\n+            throw new IllegalArgumentException(\"Source segment incompatible with alignment constraints\");\n+        }\n@@ -1609,1 +1718,3 @@\n-     * or if the source array component type does not match the carrier of the destination element layout.\n+     * if the source array component type does not match the carrier of the destination element layout, if the destination\n+     * segment\/offset are <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the destination element layout,\n+     * or if the destination element layout alignment is greater than its size.\n@@ -1626,0 +1737,4 @@\n+        Utils.checkNotHyperAligned(dstLayout, \"Source layout alignment greater than its size\");\n+        if (!destImpl.isAlignedForElement(dstOffset, dstLayout)) {\n+            throw new IllegalArgumentException(\"Target segment incompatible with alignment constraints\");\n+        }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":125,"deletions":10,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -127,2 +127,6 @@\n-        if (byteSize() % elementLayout.byteSize() != 0) {\n-            throw new IllegalArgumentException(\"Segment size is no a multiple of layout size\");\n+        Utils.checkNotHyperAligned(elementLayout, \"Element layout alignment greater than its size\");\n+        if (!isAlignedForElement(0, elementLayout)) {\n+            throw new IllegalArgumentException(\"Incompatible alignment constraints\");\n+        }\n+        if (!Utils.isAligned(byteSize(), elementLayout.byteSize())) {\n+            throw new IllegalArgumentException(\"Segment size is not a multiple of layout size\");\n@@ -386,0 +390,5 @@\n+    @ForceInline\n+    public final boolean isAlignedForElement(long offset, MemoryLayout layout) {\n+        return (((unsafeGetOffset() + offset) | maxAlignMask()) & (layout.byteAlignment() - 1)) == 0;\n+    }\n+\n@@ -387,1 +396,1 @@\n-        if (length % elemSize != 0) {\n+        if (!Utils.isAligned(length, elemSize)) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -50,0 +50,5 @@\n+    private static final long MAX_ALIGN_1 = 1;\n+    private static final long MAX_ALIGN_2 = 2;\n+    private static final long MAX_ALIGN_4 = 4;\n+    private static final long MAX_ALIGN_8 = 8;\n+\n@@ -103,0 +108,5 @@\n+\n+        @Override\n+        public long maxAlignMask() {\n+            return MAX_ALIGN_1;\n+        }\n@@ -126,0 +136,5 @@\n+\n+        @Override\n+        public long maxAlignMask() {\n+            return MAX_ALIGN_2;\n+        }\n@@ -149,0 +164,5 @@\n+\n+        @Override\n+        public long maxAlignMask() {\n+            return MAX_ALIGN_2;\n+        }\n@@ -172,0 +192,5 @@\n+\n+        @Override\n+        public long maxAlignMask() {\n+            return MAX_ALIGN_4;\n+        }\n@@ -195,0 +220,5 @@\n+\n+        @Override\n+        public long maxAlignMask() {\n+            return MAX_ALIGN_8;\n+        }\n@@ -218,0 +248,5 @@\n+\n+        @Override\n+        public long maxAlignMask() {\n+            return MAX_ALIGN_4;\n+        }\n@@ -241,0 +276,5 @@\n+\n+        @Override\n+        public long maxAlignMask() {\n+            return MAX_ALIGN_8;\n+        }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -285,1 +285,1 @@\n-        if (path.offset % alignment != 0) {\n+        if (!Utils.isAligned(path.offset, alignment)) {\n@@ -289,1 +289,1 @@\n-            if (stride % alignment != 0) {\n+            if (!Utils.isAligned(stride, alignment)) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -270,0 +270,1 @@\n+        Utils.checkNotHyperAligned(layout, \"Layout alignment greater than its size\");\n@@ -278,0 +279,1 @@\n+        Utils.checkNotHyperAligned(layout, \"Layout alignment greater than its size\");\n@@ -286,0 +288,1 @@\n+        Utils.checkNotHyperAligned(layout, \"Layout alignment greater than its size\");\n@@ -294,0 +297,1 @@\n+        Utils.checkNotHyperAligned(layout, \"Layout alignment greater than its size\");\n@@ -302,0 +306,1 @@\n+        Utils.checkNotHyperAligned(layout, \"Layout alignment greater than its size\");\n@@ -310,0 +315,1 @@\n+        Utils.checkNotHyperAligned(layout, \"Layout alignment greater than its size\");\n@@ -318,0 +324,1 @@\n+        Utils.checkNotHyperAligned(layout, \"Layout alignment greater than its size\");\n@@ -326,0 +333,1 @@\n+        Utils.checkNotHyperAligned(layout, \"Layout alignment greater than its size\");\n@@ -334,0 +342,1 @@\n+        Utils.checkNotHyperAligned(layout, \"Layout alignment greater than its size\");\n@@ -342,0 +351,1 @@\n+        Utils.checkNotHyperAligned(layout, \"Layout alignment greater than its size\");\n@@ -350,0 +360,1 @@\n+        Utils.checkNotHyperAligned(layout, \"Layout alignment greater than its size\");\n@@ -358,0 +369,1 @@\n+        Utils.checkNotHyperAligned(layout, \"Layout alignment greater than its size\");\n@@ -366,0 +378,1 @@\n+        Utils.checkNotHyperAligned(layout, \"Layout alignment greater than its size\");\n@@ -374,0 +387,1 @@\n+        Utils.checkNotHyperAligned(layout, \"Layout alignment greater than its size\");\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryAddressImpl.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -95,0 +95,5 @@\n+    @Override\n+    public long maxAlignMask() {\n+        return 0;\n+    }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-        if (bits % 8 == 0) {\n+        if (Utils.isAligned(bits, 8)) {\n@@ -176,0 +176,12 @@\n+\n+    @ForceInline\n+    public static boolean isAligned(long offset, long align) {\n+        return (offset & (align - 1)) == 0;\n+    }\n+\n+    @ForceInline\n+    public static void checkNotHyperAligned(MemoryLayout layout, String msg) {\n+        if (layout.byteAlignment() > layout.byteSize()) {\n+            throw new IllegalArgumentException(msg);\n+        }\n+    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -256,0 +256,12 @@\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testHyperAlignedSrc() {\n+        MemorySegment segment = MemorySegment.ofArray(new byte[] {1, 2, 3, 4});\n+        MemorySegment.copy(new byte[] { 1, 2, 3, 4 }, 0, segment, JAVA_BYTE.withBitAlignment(16), 0, 4);\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testHyperAlignedDst() {\n+        MemorySegment segment = MemorySegment.ofArray(new byte[] {1, 2, 3, 4});\n+        MemorySegment.copy(segment, JAVA_BYTE.withBitAlignment(16), 0, new byte[] { 1, 2, 3, 4 }, 0, 4);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestArrayCopy.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestHeapAlignment\n+ *\/\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import static org.testng.Assert.fail;\n+\n+public class TestHeapAlignment {\n+\n+    @Test(dataProvider = \"layouts\")\n+    public void testHeapAlignment(MemorySegment segment, int align, Object val, Object arr, ValueLayout layout, Function<Object, MemorySegment> segmentFactory) {\n+        assertAligned(align, layout, () -> layout.varHandle().get(segment));\n+        assertAligned(align, layout, () -> layout.varHandle().set(segment, val));\n+        MemoryLayout seq = MemoryLayout.sequenceLayout(10, layout);\n+        assertAligned(align, layout, () -> seq.varHandle(MemoryLayout.PathElement.sequenceElement()).get(segment, 0L));\n+        assertAligned(align, layout, () -> seq.varHandle(MemoryLayout.PathElement.sequenceElement()).set(segment, 0L, val));\n+        assertAligned(align, layout, () -> segment.spliterator(layout));\n+        if (arr != null) {\n+            assertAligned(align, layout, () -> MemorySegment.copy(arr, 0, segment, layout, 0, 1));\n+            assertAligned(align, layout, () -> MemorySegment.copy(segment, layout, 0, arr, 0, 1));\n+            assertAligned(align, layout, () -> {\n+                MemorySegment other = segmentFactory.apply(arr);\n+                MemorySegment.copy(other, layout, 0, segment, layout, 0, 1);\n+            });\n+            MemorySegment other = segmentFactory.apply(arr);\n+            assertAligned(align, layout, () -> {\n+                MemorySegment.copy(segment, layout, 0, other, layout, 0, 1);\n+            });\n+            assertAligned(align, layout, () -> {\n+                MemorySegment.copy(other, layout, 0, segment, layout, 0, 1);\n+            });\n+        }\n+    }\n+\n+    static void assertAligned(int align, ValueLayout layout, Runnable runnable) {\n+        boolean shouldFail = layout.byteAlignment() > align && align != -1;\n+        try {\n+            runnable.run();\n+            if (shouldFail) {\n+                fail(\"Should not get here!\");\n+            }\n+        } catch (IllegalArgumentException ex) {\n+            if (!shouldFail) {\n+                fail(\"Should not get here!\");\n+            } else if (!ex.getMessage().contains(\"alignment\") && !ex.getMessage().contains(\"Misaligned\")) {\n+                fail(\"Unexpected exception: \" + ex);\n+            }\n+        }\n+    }\n+\n+    static final ValueLayout.OfChar JAVA_CHAR_ALIGNED = ValueLayout.JAVA_CHAR.withBitAlignment(16);\n+    static final ValueLayout.OfShort JAVA_SHORT_ALIGNED = ValueLayout.JAVA_SHORT.withBitAlignment(16);\n+    static final ValueLayout.OfInt JAVA_INT_ALIGNED = ValueLayout.JAVA_INT.withBitAlignment(32);\n+    static final ValueLayout.OfFloat JAVA_FLOAT_ALIGNED = ValueLayout.JAVA_FLOAT.withBitAlignment(32);\n+    static final ValueLayout.OfLong JAVA_LONG_ALIGNED = ValueLayout.JAVA_LONG.withBitAlignment(64);\n+    static final ValueLayout.OfDouble JAVA_DOUBLE_ALIGNED = ValueLayout.JAVA_DOUBLE.withBitAlignment(64);\n+    static final ValueLayout.OfAddress ADDRESS_ALIGNED = ValueLayout.ADDRESS.withBitAlignment(ValueLayout.ADDRESS.bitSize());\n+\n+    enum SegmentAndAlignment {\n+        HEAP_BYTE(MemorySegment.ofArray(new byte[8]), 1),\n+        HEAP_SHORT(MemorySegment.ofArray(new short[4]), 2),\n+        HEAP_CHAR(MemorySegment.ofArray(new char[4]), 2),\n+        HEAP_INT(MemorySegment.ofArray(new int[2]), 4),\n+        HEAP_FLOAT(MemorySegment.ofArray(new float[2]), 4),\n+        HEAP_LONG(MemorySegment.ofArray(new long[1]), 8),\n+        HEAP_DOUBLE(MemorySegment.ofArray(new double[1]), 8),\n+        NATIVE(MemorySegment.allocateNative(8, ResourceScope.newImplicitScope()), -1);\n+\n+        final MemorySegment segment;\n+        final int align;\n+\n+        SegmentAndAlignment(MemorySegment segment, int align) {\n+            this.segment = segment;\n+            this.align = align;\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] layouts() {\n+        List<Object[]> layouts = new ArrayList<>();\n+        for (SegmentAndAlignment testCase : SegmentAndAlignment.values()) {\n+            layouts.add(new Object[] { testCase.segment, testCase.align, (byte) 42, new byte[]{42}, ValueLayout.JAVA_BYTE, (Function<byte[], MemorySegment>)MemorySegment::ofArray });\n+            layouts.add(new Object[] { testCase.segment, testCase.align, true, null, ValueLayout.JAVA_BOOLEAN, null });\n+            layouts.add(new Object[] { testCase.segment, testCase.align, (char) 42, new char[]{42}, JAVA_CHAR_ALIGNED, (Function<char[], MemorySegment>)MemorySegment::ofArray });\n+            layouts.add(new Object[] { testCase.segment, testCase.align, (short) 42, new short[]{42}, JAVA_SHORT_ALIGNED, (Function<short[], MemorySegment>)MemorySegment::ofArray });\n+            layouts.add(new Object[] { testCase.segment, testCase.align, 42, new int[]{42}, JAVA_INT_ALIGNED, (Function<int[], MemorySegment>)MemorySegment::ofArray });\n+            layouts.add(new Object[] { testCase.segment, testCase.align, 42f, new float[]{42}, JAVA_FLOAT_ALIGNED, (Function<float[], MemorySegment>)MemorySegment::ofArray });\n+            layouts.add(new Object[] { testCase.segment, testCase.align, 42L, new long[]{42}, JAVA_LONG_ALIGNED, (Function<long[], MemorySegment>)MemorySegment::ofArray });\n+            layouts.add(new Object[] { testCase.segment, testCase.align, 42d, new double[]{42}, JAVA_DOUBLE_ALIGNED, (Function<double[], MemorySegment>)MemorySegment::ofArray });\n+            layouts.add(new Object[] { testCase.segment, testCase.align, MemoryAddress.ofLong(42), null, ADDRESS_ALIGNED, null });\n+        }\n+        return layouts.toArray(new Object[0][]);\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestHeapAlignment.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -38,0 +38,1 @@\n+import org.testng.SkipException;\n@@ -43,1 +44,1 @@\n-    static class Accessor<T, X, L> {\n+    static class Accessor<T, X, L extends ValueLayout> {\n@@ -93,1 +94,22 @@\n-        static <L, X> Accessor<MemorySegment, X, L> ofSegment(L layout, X value,\n+        @SuppressWarnings(\"unchecked\")\n+        void testHyperAligned() {\n+            try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+                MemorySegment segment = MemorySegment.allocateNative(64, scope);\n+                T t = transform.apply(segment);\n+                L alignedLayout = (L)layout.withBitAlignment(layout.byteSize() * 8 * 2);\n+                try {\n+                    segmentSetter.set(t, alignedLayout, 0, value);\n+                    fail();\n+                } catch (IllegalArgumentException exception) {\n+                    assertTrue(exception.getMessage().contains(\"greater\"));\n+                }\n+                try {\n+                    segmentGetter.get(t, alignedLayout, 0);\n+                    fail();\n+                } catch (IllegalArgumentException exception) {\n+                    assertTrue(exception.getMessage().contains(\"greater\"));\n+                }\n+            }\n+        }\n+\n+        static <L extends ValueLayout, X> Accessor<MemorySegment, X, L> ofSegment(L layout, X value,\n@@ -99,1 +121,1 @@\n-        static <L, X> Accessor<MemoryAddress, X, L> ofAddress(L layout, X value,\n+        static <L extends ValueLayout, X> Accessor<MemoryAddress, X, L> ofAddress(L layout, X value,\n@@ -116,0 +138,18 @@\n+    @Test(dataProvider = \"segmentAccessors\")\n+    public void testSegmentAccessHyper(String testName, Accessor<?, ?, ?> accessor) {\n+        if (testName.contains(\"index\")) {\n+            accessor.testHyperAligned();\n+        } else {\n+            throw new SkipException(\"Skipping\");\n+        }\n+    }\n+\n+    @Test(dataProvider = \"addressAccessors\")\n+    public void testAddressAccessHyper(String testName, Accessor<?, ?, ?> accessor) {\n+        if (testName.contains(\"index\")) {\n+            accessor.testHyperAligned();\n+        } else {\n+            throw new SkipException(\"Skipping\");\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccessInstance.java","additions":43,"deletions":3,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-        } catch (IllegalStateException ex) {\n+        } catch (IllegalArgumentException ex) {\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAlignment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n@@ -84,2 +85,4 @@\n-    interface Getter<X> {\n-        X get(MemorySegment segment, ValueLayout layout, long index);\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testHyperAlignedSrc() {\n+        MemorySegment segment = MemorySegment.ofArray(new byte[] {1, 2, 3, 4});\n+        MemorySegment.copy(segment, 0, segment, JAVA_BYTE.withBitAlignment(16), 0, 4);\n@@ -88,2 +91,4 @@\n-    interface Setter<X> {\n-        void set(MemorySegment segment, ValueLayout layout, long index, X val);\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testHyperAlignedDst() {\n+        MemorySegment segment = MemorySegment.ofArray(new byte[] {1, 2, 3, 4});\n+        MemorySegment.copy(segment, JAVA_BYTE.withBitAlignment(16), 0, segment, 0, 4);\n","filename":"test\/jdk\/java\/foreign\/TestSegmentCopy.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -130,0 +130,5 @@\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testHyperAligned() {\n+        MemorySegment.ofArray(new byte[8]).elements(MemoryLayout.sequenceLayout(2, ValueLayout.JAVA_INT.withBitAlignment(64)));\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestSpliterator.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-    @Test(expectedExceptions = IllegalStateException.class)\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n","filename":"test\/jdk\/java\/foreign\/TestVarHandleCombinators.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -64,0 +65,4 @@\n+\n+    static final ValueLayout.OfInt JAVA_INT_ALIGNED = JAVA_INT.withBitAlignment(32);\n+    static final VarHandle VH_int_aligned = MemoryLayout.sequenceLayout(JAVA_INT_ALIGNED).varHandle(sequenceElement());\n+\n@@ -128,0 +133,9 @@\n+    @Benchmark\n+    public int segment_loop_aligned() {\n+        int sum = 0;\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            sum += (int) VH_int_aligned.get(segment, (long) i);\n+        }\n+        return sum;\n+    }\n+\n@@ -148,0 +162,9 @@\n+    @Benchmark\n+    public int segment_loop_instance_aligned() {\n+        int res = 0;\n+        for (int i = 0; i < ELEM_SIZE; i ++) {\n+            res += segment.get(JAVA_INT_ALIGNED, i * CARRIER_SIZE);\n+        }\n+        return res;\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstant.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -69,1 +70,6 @@\n-    MemorySegment segment;\n+\n+    static final ValueLayout.OfInt JAVA_INT_ALIGNED = JAVA_INT.withBitAlignment(32);\n+    static final VarHandle VH_int_aligned = MemoryLayout.sequenceLayout(JAVA_INT_ALIGNED).varHandle(sequenceElement());\n+    static final int UNSAFE_INT_BASE = unsafe.arrayBaseOffset(int[].class);\n+\n+    MemorySegment segment, alignedSegment;\n@@ -71,0 +77,1 @@\n+    int[] alignedBase;\n@@ -98,0 +105,4 @@\n+        alignedBase = new int[ELEM_SIZE];\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            unsafe.putInt(base, UNSAFE_INT_BASE + (i * CARRIER_SIZE) , i);\n+        }\n@@ -99,0 +110,1 @@\n+        alignedSegment = MemorySegment.ofArray(alignedBase);\n@@ -138,0 +150,9 @@\n+    @Benchmark\n+    public int segment_loop_aligned() {\n+        int sum = 0;\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            sum += (int) VH_int_aligned.get(alignedSegment, (long) i);\n+        }\n+        return sum;\n+    }\n+\n@@ -147,0 +168,9 @@\n+    @Benchmark\n+    public int segment_loop_instance_aligned() {\n+        int res = 0;\n+        for (int i = 0; i < ELEM_SIZE; i ++) {\n+            res += alignedSegment.get(JAVA_INT_ALIGNED, i * CARRIER_SIZE);\n+        }\n+        return res;\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantHeap.java","additions":31,"deletions":1,"binary":false,"changes":32,"status":"modified"}]}