{"files":[{"patch":"@@ -36,0 +36,1 @@\n+import java.lang.foreign.ValueLayout.OfAddress;\n@@ -117,2 +118,2 @@\n- * However, if the return layout is an {@linkplain ValueLayout.OfAddress#asUnbounded() unbounded} address layout,\n- * then the size of the returned segment is {@code Long.MAX_VALUE}.\n+ * However, if the return address layout has a {@linkplain OfAddress#targetLayout()} {@code T}, then the size of the returned segment\n+ * is set to {@code T.byteSize()}.\n@@ -130,3 +131,3 @@\n- * Under normal conditions, the size of this segment argument is {@code 0}. However, if the layout associated with\n- * the upcall stub argument is an {@linkplain ValueLayout.OfAddress#asUnbounded() unbounded} address layout,\n- * then the size of the segment argument is {@code Long.MAX_VALUE}.\n+ * Under normal conditions, the size of this segment argument is {@code 0}.\n+ * However, if the address layout has a {@linkplain OfAddress#targetLayout()} {@code T}, then the size of the\n+ * segment argument is set to {@code T.byteSize()}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.foreign.ValueLayout.OfAddress;\n@@ -363,3 +364,5 @@\n- * To access native zero-length memory segments, clients have two options, both of which are <em>unsafe<\/em>. Clients\n- * can {@linkplain java.lang.foreign.MemorySegment#ofAddress(long, long, SegmentScope) obtain}\n- * a <em>new<\/em> native segment, with new spatial and temporal bounds, as follows:\n+ * To access native zero-length memory segments, clients have several options, all of which are <em>unsafe<\/em>.\n+ * <p>\n+ * First, clients can unsafely resize a zero-length memory segment by {@linkplain #asUnbounded() obtaining} a\n+ * memory segment with same base address as the zero-length memory segment, but with maximal size (i.e. {@link Long#MAX_VALUE}).\n+ * This segment can then be resized as needed, so that the resulting segment can then be accessed directly, as follows:\n@@ -368,4 +371,4 @@\n- * SegmentScope scope = ... \/\/ obtains a scope\n- * MemorySegment foreign = someSegment.get(ValueLayout.ADDRESS, 0); \/\/ wrap address into segment (size = 0)\n- * MemorySegment segment = MemorySegment.ofAddress(foreign.address(), 4, scope); \/\/ create new segment (size = 4)\n- * int x = segment.get(ValueLayout.JAVA_INT, 0); \/\/ok\n+ * MemorySegment foreign = someSegment.get(ValueLayout.ADDRESS, 0); \/\/ wrap address into segment (size = 0) *\n+ * foreign = foreign.asUnbounded() \/\/ size = Long.MAX_VALUE\n+ *                  .asSlice(0, JAVA_INT); \/\/ size = 4\n+ * int x = foreign.get(ValueLayout.JAVA_INT, 0); \/\/ok\n@@ -374,4 +377,5 @@\n- * Alternatively, clients can obtain an {@linkplain java.lang.foreign.ValueLayout.OfAddress#asUnbounded() unbounded}\n- * address value layout. When an access operation, or a function descriptor that is passed to a downcall method handle,\n- * uses an unbounded address value layouts, the runtime will wrap any corresponding raw addresses with native segments\n- * with <em>maximal<\/em> size (i.e. {@linkplain java.lang.Long#MAX_VALUE}). As such, these segments can be accessed directly, as follows:\n+ * Alternatively, if the size of the foreign segment is known statically, clients can associate a\n+ * {@linkplain OfAddress#withTargetLayout(MemoryLayout) target layout} with the address layout used to obtain the\n+ * segment. When an access operation, or a function descriptor that is passed to a downcall method handle,\n+ * uses an address value layout with target layout {@code T}, the runtime will wrap any corresponding raw addresses\n+ * with native segments with size set to {@code T.byteSize()}:\n@@ -380,1 +384,11 @@\n- * MemorySegment foreign = someSegment.get(ValueLayout.ADDRESS.asUnbounded(), 0); \/\/ wrap address into segment (size = Long.MAX_VALUE)\n+ * MemorySegment foreign = someSegment.get(ValueLayout.ADDRESS.withTargetLayout(JAVA_INT), 0); \/\/ wrap address into segment (size = 4)\n+ * int x = foreign.get(ValueLayout.JAVA_INT, 0); \/\/ok\n+ *}\n+ *\n+ * Finally, clients can {@linkplain java.lang.foreign.MemorySegment#ofAddress(long, long, SegmentScope) obtain}\n+ * a <em>new<\/em> native segment, with new spatial and temporal bounds, as follows:\n+ *\n+ * {@snippet lang = java:\n+ * SegmentScope scope = ... \/\/ obtains a scope\n+ * MemorySegment foreign = someSegment.get(ValueLayout.ADDRESS, 0); \/\/ wrap address into segment (size = 0)\n+ * foreign = MemorySegment.ofAddress(foreign.address(), 4, scope); \/\/ create new segment (size = 4)\n@@ -384,1 +398,2 @@\n- * Both {@link #ofAddress(long, long, SegmentScope)} and {@link ValueLayout.OfAddress#asUnbounded()} are\n+ * All of {@link #asUnbounded()}, {@link ValueLayout.OfAddress#withTargetLayout(MemoryLayout)}\n+ * and {@link #ofAddress(long, long, SegmentScope)} are\n@@ -386,1 +401,1 @@\n- * for instance, sizing a segment incorrectly could result in a VM crash when attempting to access the memory segment.\n+ * for instance, resizing a segment incorrectly could result in a VM crash when attempting to access the memory segment.\n@@ -390,1 +405,2 @@\n- * segment unsafely, to match the size of the struct (so that out-of-bounds access will be detected by the API).\n+ * segment unsafely, to match the size of the struct (so that out-of-bounds access will be detected by the API). If the\n+ * size is known statically, using an address layout with the correct target layout might be preferable.\n@@ -464,0 +480,5 @@\n+     * <p>\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * asSlice(offset, layout.byteSize(), 1);\n+     * }\n@@ -465,1 +486,1 @@\n-     * @see #asSlice(long)\n+     * @see #asSlice(long, long, long)\n@@ -474,0 +495,38 @@\n+    \/**\n+     * Returns a slice of this memory segment, at the given offset, with the provided alignment constraint.\n+     * The returned segment's address is the address of this segment plus the given offset; its size is specified by the given argument.\n+     *\n+     * @param offset The new segment base offset (relative to the address of this segment), specified in bytes.\n+     * @param newSize The new segment size, specified in bytes.\n+     * @param byteAlignment The alignment constraint (in bytes) of the returned slice.\n+     * @return a slice of this memory segment.\n+     * @throws IndexOutOfBoundsException if {@code offset < 0}, {@code offset > byteSize()}, {@code newSize < 0}, or {@code newSize > byteSize() - offset}\n+     * @throws IllegalArgumentException if this segment cannot be accessed at {@code offset} under\n+     * the provided alignment constraint.\n+     *\/\n+    MemorySegment asSlice(long offset, long newSize, long byteAlignment);\n+\n+    \/**\n+     * Returns a slice of this memory segment with the given layout, at the given offset. The returned segment's address is the address\n+     * of this segment plus the given offset; its size is the same as the size of the provided layout.\n+     * <p>\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * asSlice(offset, layout.byteSize(), layout.byteAlignment());\n+     * }\n+     *\n+     * @see #asSlice(long, long, long)\n+     *\n+     * @param offset The new segment base offset (relative to the address of this segment), specified in bytes.\n+     * @param layout The layout of the segment slice.\n+     * @throws IndexOutOfBoundsException if {@code offset < 0}, {@code offset > layout.byteSize()},\n+     * {@code newSize < 0}, or {@code newSize > layout.byteSize() - offset}\n+     * @throws IllegalArgumentException if this segment cannot be accessed at {@code offset} under\n+     * the alignment constraint specified by {@code layout}.\n+     * @return a slice of this memory segment.\n+     *\/\n+    default MemorySegment asSlice(long offset, MemoryLayout layout) {\n+        Objects.requireNonNull(layout);\n+        return asSlice(offset, layout.byteSize(), layout.byteAlignment());\n+    }\n+\n@@ -493,0 +552,22 @@\n+    \/**\n+     * Returns a new memory segment that has the same address and lifecycle as this segment, but with <em>unbounded<\/em> size.\n+     * That is, the byte size of the returned segment is set to {@link Long#MAX_VALUE}. This method\n+     * can be used, in combination with other slicing methods, to resize zero-length memory segments:\n+     * {@snippet lang=java :\n+     * MemorySegment zeroLengthSegment = ... \/\/ (size = 0)\n+     * MemorySegment intSegment = zeroLengthSegment.asUnbounded() \/\/ (size = Long.MAX_VALUE)\n+     *                                             .asSlice(0, ValueLayout.JAVA_INT) \/\/ (size = 0)\n+     * }\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @return a new memory segment with unbounded size.\n+     * @throws UnsupportedOperationException if this segment is not a {@linkplain #isNative() native} segment.\n+     * @throws IllegalCallerException If the caller is in a module that does not have native access enabled.\n+     *\/\n+    @CallerSensitive\n+    MemorySegment asUnbounded();\n+\n@@ -1702,3 +1783,3 @@\n-     * the size of the returned segment is {@code 0}. However, if the provided layout is an\n-     * {@linkplain ValueLayout.OfAddress#asUnbounded() unbounded} address layout, then the size of the returned\n-     * segment is {@code Long.MAX_VALUE}.\n+     * the size of the returned segment is {@code 0}. However, if the provided address layout has a\n+     * {@linkplain OfAddress#targetLayout()} {@code T}, then the size of the returned segment\n+     * is set to {@code T.byteSize()}.\n@@ -1714,0 +1795,3 @@\n+     * @throws IllegalArgumentException if provided address layout has a {@linkplain OfAddress#targetLayout() target layout}\n+     * {@code T}, and the address of the returned segment\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in {@code T}.\n@@ -2041,3 +2125,3 @@\n-     * the size of the returned segment is {@code 0}. However, if the provided layout is an\n-     * {@linkplain ValueLayout.OfAddress#asUnbounded() unbounded} address layout, then the size of the returned\n-     * segment is {@code Long.MAX_VALUE}.\n+     * the size of the returned segment is {@code 0}. However, if the provided address layout has a\n+     * {@linkplain OfAddress#targetLayout()} {@code T}, then the size of the returned segment\n+     * is set to {@code T.byteSize()}.\n@@ -2056,0 +2140,3 @@\n+     * @throws IllegalArgumentException if provided address layout has a {@linkplain OfAddress#targetLayout() target layout}\n+     * {@code T}, and the address of the returned segment\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in {@code T}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":109,"deletions":22,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -366,2 +366,2 @@\n-     * new allocation request will return a new slice starting at the segment offset {@code 0} (alignment\n-     * constraints are ignored by this allocator), hence the name <em>prefix allocator<\/em>.\n+     * new allocation request will return a new slice starting at the segment offset {@code 0}, hence the name\n+     * <em>prefix allocator<\/em>.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Optional;\n@@ -389,1 +390,3 @@\n-     * A value layout whose carrier is {@code MemorySegment.class}.\n+     * A value layout whose carrier is {@code MemorySegment.class}. An address layout may optionally feature\n+     * a {@linkplain #targetLayout() target layout}. The target layout indicates the layout of the region\n+     * of memory pointed to by the address described by this layout.\n@@ -417,4 +420,14 @@\n-         * Returns an <em>unbounded<\/em> address layout with the same carrier, alignment constraint, name and order as this address layout,\n-         * but with the specified pointee layout. An unbounded address layout allow raw addresses to be accessed\n-         * as {@linkplain MemorySegment memory segments} whose size is set to {@link Long#MAX_VALUE}. As such,\n-         * these segments can be used in subsequent access operations.\n+         * Returns an address layout with the same carrier, alignment constraint, name and order as this address layout,\n+         * but associated with the specified target layout. The returned address layout allows raw addresses to be accessed\n+         * as {@linkplain MemorySegment memory segments} whose size is set to the size of the specified layout. Moreover,\n+         * if the accessed raw address is not compatible with the alignment constraint in the provided layout,\n+         * {@linkplain IllegalArgumentException} will be thrown.\n+         * @apiNote\n+         * This method can also be used to create an address layout which, when used, creates native memory\n+         * segments with maximal size (e.g. {@linkplain Long#MAX_VALUE}. This can be done by using a target sequence\n+         * layout with unspecified size, as follows:\n+         * {@snippet lang=java :\n+         * ValueLayout.OfAddress addressLayout = ...\n+         * ValueLayout.OfAddress unboundedLayout = addressLayout.withTargetLayout(\n+         *         MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE));\n+         * }\n@@ -427,1 +440,2 @@\n-         * @return an unbounded address layout with same characteristics as this layout.\n+         * @param layout the target layout.\n+         * @return an address layout with same characteristics as this layout, but with the provided target layout.\n@@ -429,1 +443,1 @@\n-         * @see #isUnbounded()\n+         * @see #targetLayout()\n@@ -432,1 +446,1 @@\n-        OfAddress asUnbounded();\n+        OfAddress withTargetLayout(MemoryLayout layout);\n@@ -435,1 +449,1 @@\n-         * {@return {@code true}, if this address layout is an {@linkplain #asUnbounded() unbounded address layout}}.\n+         * {@return the target layout associated with this address layout (if any)}.\n@@ -437,1 +451,1 @@\n-        boolean isUnbounded();\n+        Optional<MemoryLayout> targetLayout();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":24,"deletions":10,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -55,0 +55,2 @@\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n@@ -115,0 +117,17 @@\n+    @Override\n+    public MemorySegment asSlice(long offset, long newSize, long byteAlignment) {\n+        checkBounds(offset, newSize);\n+        if (!isAlignedForElement(offset, byteAlignment)) {\n+            throw new IllegalArgumentException(\"Target offset incompatible with alignment constraints\");\n+        }\n+        return asSliceNoCheck(offset, newSize);\n+    }\n+\n+    @Override\n+    @CallerSensitive\n+    public AbstractMemorySegmentImpl asUnbounded() {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemorySegment.class, \"asUnbounded\");\n+        if (!isNative()) throw new UnsupportedOperationException(\"Not a native segment\");\n+        return asSliceNoCheck(0, Long.MAX_VALUE);\n+    }\n+\n@@ -151,1 +170,1 @@\n-        return asSlice(0, byteSize);\n+        return asSlice(0, byteSize, byteAlignment);\n@@ -328,1 +347,6 @@\n-        return (((unsafeGetOffset() + offset) | maxAlignMask()) & (layout.byteAlignment() - 1)) == 0;\n+        return isAlignedForElement(offset, layout.byteAlignment());\n+    }\n+\n+    @ForceInline\n+    public final boolean isAlignedForElement(long offset, long byteAlignment) {\n+        return (((unsafeGetOffset() + offset) | maxAlignMask()) & (byteAlignment - 1)) == 0;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.foreign.MemoryLayout;\n@@ -87,1 +88,2 @@\n-        public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64).asUnbounded();\n+        public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64)\n+                .withTargetLayout(MemoryLayout.sequenceLayout(C_CHAR));\n@@ -146,1 +148,2 @@\n-        public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64).asUnbounded();\n+        public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64)\n+                .withTargetLayout(MemoryLayout.sequenceLayout(C_CHAR));\n@@ -206,1 +209,2 @@\n-        public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64).asUnbounded();\n+        public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64)\n+                .withTargetLayout(MemoryLayout.sequenceLayout(C_CHAR));\n@@ -262,1 +266,2 @@\n-        public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64).asUnbounded();\n+        public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64)\n+                .withTargetLayout(MemoryLayout.sequenceLayout(C_CHAR));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/PlatformLayouts.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-        MemorySegment slice = segment.asSlice(start, byteSize);\n+        MemorySegment slice = segment.asSlice(start, byteSize, byteAlignment);\n@@ -53,1 +53,1 @@\n-        Utils.checkAllocationSizeAndAlign(byteSize, byteAlignment, maxAlign);\n+        Utils.checkAllocationSizeAndAlign(byteSize, byteAlignment);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SlicingAllocator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -58,2 +59,1 @@\n-    private static final MethodHandle LONG_TO_ADDRESS_SAFE;\n-    private static final MethodHandle LONG_TO_ADDRESS_UNSAFE;\n+    private static final MethodHandle LONG_TO_ADDRESS;\n@@ -74,4 +74,2 @@\n-            LONG_TO_ADDRESS_SAFE = lookup.findStatic(Utils.class, \"longToAddressSafe\",\n-                    MethodType.methodType(MemorySegment.class, long.class));\n-            LONG_TO_ADDRESS_UNSAFE = lookup.findStatic(Utils.class, \"longToAddressUnsafe\",\n-                    MethodType.methodType(MemorySegment.class, long.class));\n+            LONG_TO_ADDRESS = lookup.findStatic(Utils.class, \"longToAddress\",\n+                    MethodType.methodType(MemorySegment.class, long.class, long.class, long.class));\n@@ -130,1 +128,1 @@\n-        } else if (layout instanceof ValueLayout.OfAddress addressLayout) {\n+        } else if (layout instanceof ValueLayout.OfAddress) {\n@@ -132,3 +130,3 @@\n-                    MethodHandles.explicitCastArguments(ADDRESS_TO_LONG, MethodType.methodType(baseCarrier, MemorySegment.class)),\n-                    MethodHandles.explicitCastArguments(addressLayout.isUnbounded() ?\n-                            LONG_TO_ADDRESS_UNSAFE : LONG_TO_ADDRESS_SAFE, MethodType.methodType(MemorySegment.class, baseCarrier)));\n+                    ADDRESS_TO_LONG,\n+                    MethodHandles.insertArguments(LONG_TO_ADDRESS, 1,\n+                            pointeeSize(layout), pointeeAlign(layout)));\n@@ -148,2 +146,5 @@\n-    private static MemorySegment longToAddressSafe(long addr) {\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(addr, 0);\n+    public static MemorySegment longToAddress(long addr, long size, long align) {\n+        if (!isAligned(addr, align)) {\n+            throw new IllegalArgumentException(\"Invalid alignment constraint for address: \" + addr);\n+        }\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(addr, size);\n@@ -153,2 +154,5 @@\n-    private static MemorySegment longToAddressUnsafe(long addr) {\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(addr, Long.MAX_VALUE);\n+    public static MemorySegment longToAddress(long addr, long size, long align, SegmentScope scope) {\n+        if (!isAligned(addr, align)) {\n+            throw new IllegalArgumentException(\"Invalid alignment constraint for address: \" + addr);\n+        }\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(addr, size, scope);\n@@ -183,1 +187,1 @@\n-            return addressLayout.isUnbounded() ? Long.MAX_VALUE : 0L;\n+            return addressLayout.targetLayout().map(MemoryLayout::byteSize).orElse(0L);\n@@ -189,4 +193,5 @@\n-    public static void checkAllocationSizeAndAlign(long byteSize, long byteAlignment, long maxAlignment) {\n-        checkAllocationSizeAndAlign(byteSize, byteAlignment);\n-        if (maxAlignment != 0 && byteAlignment > maxAlignment) {\n-            throw new IllegalArgumentException(\"Invalid alignment constraint : \" + byteAlignment + \" > \" + maxAlignment);\n+    public static long pointeeAlign(MemoryLayout layout) {\n+        if (layout instanceof ValueLayout.OfAddress addressLayout) {\n+            return addressLayout.targetLayout().map(MemoryLayout::byteAlignment).orElse(1L);\n+        } else {\n+            throw new UnsupportedOperationException();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":24,"deletions":19,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -350,2 +350,2 @@\n-    static BoxAddress boxAddressRaw(long size) {\n-        return new BoxAddress(size, false);\n+    static BoxAddress boxAddressRaw(long size, long align) {\n+        return new BoxAddress(size, align, false);\n@@ -355,1 +355,1 @@\n-        return new BoxAddress(layout.byteSize(), true);\n+        return new BoxAddress(layout.byteSize(), layout.byteAlignment(), true);\n@@ -359,1 +359,1 @@\n-        return new BoxAddress(byteSize, true);\n+        return new BoxAddress(byteSize, 1, true);\n@@ -451,2 +451,2 @@\n-        public Binding.Builder boxAddressRaw(long size) {\n-            bindings.add(Binding.boxAddressRaw(size));\n+        public Binding.Builder boxAddressRaw(long size, long align) {\n+            bindings.add(Binding.boxAddressRaw(size, align));\n@@ -684,1 +684,1 @@\n-    record BoxAddress(long size, boolean needsScope) implements Binding {\n+    record BoxAddress(long size, long align, boolean needsScope) implements Binding {\n@@ -701,3 +701,5 @@\n-            SegmentScope scope = needsScope ?\n-                    context.scope() : SegmentScope.global();\n-            stack.push(NativeMemorySegmentImpl.makeNativeSegmentUnchecked((long) stack.pop(), size, scope));\n+            if (needsScope) {\n+                stack.push(Utils.longToAddress((long) stack.pop(), size, align, context.scope));\n+            } else {\n+                stack.push(Utils.longToAddress((long) stack.pop(), size, align));\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -90,2 +90,2 @@\n-    private static final String OF_LONG_DESC = methodType(MemorySegment.class, long.class, long.class).descriptorString();\n-    private static final String OF_LONG_UNCHECKED_DESC = methodType(MemorySegment.class, long.class, long.class, SegmentScope.class).descriptorString();\n+    private static final String LONG_TO_ADDRESS_NO_SCOPE_DESC = methodType(MemorySegment.class, long.class, long.class, long.class).descriptorString();\n+    private static final String LONG_TO_ADDRESS_SCOPE_DESC = methodType(MemorySegment.class, long.class, long.class, long.class, SegmentScope.class).descriptorString();\n@@ -582,0 +582,1 @@\n+        emitConst(boxAddress.align());\n@@ -584,1 +585,1 @@\n-            emitInvokeStatic(NativeMemorySegmentImpl.class, \"makeNativeSegmentUnchecked\", OF_LONG_UNCHECKED_DESC);\n+            emitInvokeStatic(Utils.class, \"longToAddress\", LONG_TO_ADDRESS_SCOPE_DESC);\n@@ -586,1 +587,1 @@\n-            emitInvokeStatic(NativeMemorySegmentImpl.class, \"makeNativeSegmentUnchecked\", OF_LONG_DESC);\n+            emitInvokeStatic(Utils.class, \"longToAddress\", LONG_TO_ADDRESS_NO_SCOPE_DESC);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -459,1 +459,1 @@\n-                .boxAddressRaw(Long.MAX_VALUE)\n+                .boxAddressRaw(Long.MAX_VALUE, 1)\n@@ -490,1 +490,1 @@\n-                            .boxAddressRaw(Utils.pointeeSize(layout));\n+                            .boxAddressRaw(Utils.pointeeSize(layout), Utils.pointeeAlign(layout));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -399,1 +399,1 @@\n-                            .boxAddressRaw(Utils.pointeeSize(layout));\n+                            .boxAddressRaw(Utils.pointeeSize(layout), Utils.pointeeAlign(layout));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/LinuxRISCV64CallArranger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -321,1 +321,1 @@\n-                            .boxAddressRaw(Utils.pointeeSize(layout));\n+                            .boxAddressRaw(Utils.pointeeSize(layout), Utils.pointeeAlign(layout));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -281,1 +281,1 @@\n-                            .boxAddressRaw(Utils.pointeeSize(layout));\n+                            .boxAddressRaw(Utils.pointeeSize(layout), Utils.pointeeAlign(layout));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -179,0 +179,1 @@\n+        boolean max = (Long.MAX_VALUE \/ elementLayout.bitSize()) == elemCount;\n@@ -180,1 +181,1 @@\n-                elemCount, elementLayout));\n+                max ? \"*\" : elemCount, elementLayout));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/SequenceLayoutImpl.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -101,2 +101,2 @@\n-        public final String toString() {\n-            char descriptor = carrier == MemorySegment.class ? 'A' : carrier.descriptorString().charAt(0);\n+        public String toString() {\n+            char descriptor = carrier.descriptorString().charAt(0);\n@@ -406,1 +406,1 @@\n-        private final boolean isUnbounded;\n+        private final MemoryLayout targetLayout;\n@@ -410,1 +410,1 @@\n-            this.isUnbounded = false; \/\/ safe\n+            this.targetLayout = null;\n@@ -413,1 +413,1 @@\n-        private OfAddressImpl(ByteOrder order, long size, long bitAlignment, boolean isUnbounded, Optional<String> name) {\n+        private OfAddressImpl(ByteOrder order, long size, long bitAlignment, MemoryLayout targetLayout, Optional<String> name) {\n@@ -415,1 +415,1 @@\n-            this.isUnbounded = isUnbounded;\n+            this.targetLayout = targetLayout;\n@@ -420,1 +420,1 @@\n-            return new OfAddressImpl(order(), bitSize(), alignment, isUnbounded, name);\n+            return new OfAddressImpl(order(), bitSize(), alignment, targetLayout, name);\n@@ -426,1 +426,1 @@\n-            return new OfAddressImpl(order, bitSize(), bitAlignment(), isUnbounded, name());\n+            return new OfAddressImpl(order, bitSize(), bitAlignment(), targetLayout, name());\n@@ -432,1 +432,1 @@\n-                    ((OfAddressImpl) other).isUnbounded == this.isUnbounded;\n+                    Objects.equals(((OfAddressImpl)other).targetLayout, this.targetLayout);\n@@ -437,1 +437,1 @@\n-            return Objects.hash(super.hashCode(), isUnbounded);\n+            return Objects.hash(super.hashCode(), targetLayout);\n@@ -442,3 +442,4 @@\n-        public OfAddress asUnbounded() {\n-            Reflection.ensureNativeAccess(Reflection.getCallerClass(), OfAddress.class, \"asUnbounded\");\n-            return new OfAddressImpl(order(), bitSize(), bitAlignment(), true, name());\n+        public OfAddress withTargetLayout(MemoryLayout layout) {\n+            Reflection.ensureNativeAccess(Reflection.getCallerClass(), OfAddress.class, \"withTargetLayout\");\n+            Objects.requireNonNull(layout);\n+            return new OfAddressImpl(order(), bitSize(), bitAlignment(), layout, name());\n@@ -448,2 +449,2 @@\n-        public boolean isUnbounded() {\n-            return isUnbounded;\n+        public Optional<MemoryLayout> targetLayout() {\n+            return Optional.ofNullable(targetLayout);\n@@ -455,0 +456,13 @@\n+\n+        @Override\n+        public String toString() {\n+            char descriptor = 'A';\n+            if (order() == ByteOrder.LITTLE_ENDIAN) {\n+                descriptor = Character.toLowerCase(descriptor);\n+            }\n+            String str = decorateLayoutString(String.format(\"%s%d\", descriptor, bitSize()));\n+            if (targetLayout != null) {\n+                str += \":\" + targetLayout;\n+            }\n+            return str;\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/ValueLayouts.java","additions":29,"deletions":15,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -126,3 +126,4 @@\n-        assertFalse(v.isUnbounded());\n-        OfAddress v2 = v.asUnbounded();\n-        assertTrue(v2.isUnbounded());\n+        assertFalse(v.targetLayout().isPresent());\n+        OfAddress v2 = v.withTargetLayout(JAVA_INT);\n+        assertTrue(v2.targetLayout().isPresent());\n+        assertEquals(v2.targetLayout().get(), JAVA_INT);\n","filename":"test\/jdk\/java\/foreign\/MemoryLayoutTypeRetentionTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -87,1 +87,2 @@\n-    public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64).asUnbounded();\n+    public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64)\n+            .withTargetLayout(MemoryLayout.sequenceLayout(C_CHAR));\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -152,1 +152,1 @@\n-                FunctionDescriptor.of(C_POINTER, C_POINTER));\n+                FunctionDescriptor.of(C_POINTER.withTargetLayout(Tm.LAYOUT), C_POINTER));\n@@ -157,1 +157,2 @@\n-        final static FunctionDescriptor qsortComparFunction = FunctionDescriptor.of(C_INT, C_POINTER, C_POINTER);\n+        final static FunctionDescriptor qsortComparFunction = FunctionDescriptor.of(C_INT,\n+                C_POINTER.withTargetLayout(C_INT), C_POINTER.withTargetLayout(C_INT));\n@@ -225,1 +226,12 @@\n-            static final long SIZE = 56;\n+            static final MemoryLayout LAYOUT = MemoryLayout.structLayout(\n+                    C_INT.withName(\"sec\"),\n+                    C_INT.withName(\"min\"),\n+                    C_INT.withName(\"hour\"),\n+                    C_INT.withName(\"mday\"),\n+                    C_INT.withName(\"mon\"),\n+                    C_INT.withName(\"year\"),\n+                    C_INT.withName(\"wday\"),\n+                    C_INT.withName(\"yday\"),\n+                    C_BOOL.withName(\"isdst\"),\n+                    MemoryLayout.paddingLayout(24)\n+            );\n@@ -228,1 +240,1 @@\n-                this.base = addr.asSlice(0, SIZE);\n+                this.base = addr;\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,201 @@\n+\/*\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @library ..\/ \/test\/lib\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestAddressDereference\n+ *\/\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SymbolLookup;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.testng.annotations.*;\n+\n+import static org.testng.Assert.*;\n+\n+public class TestAddressDereference extends UpcallTestHelper {\n+\n+    static final Linker LINKER = Linker.nativeLinker();\n+    static final MemorySegment GET_ADDR_SYM;\n+    static final MethodHandle GET_ADDR_CB_HANDLE, TEST_ARG_HANDLE;\n+\n+    static {\n+        System.loadLibrary(\"AddressDereference\");\n+        GET_ADDR_SYM = SymbolLookup.loaderLookup().find(\"get_addr\").get();\n+        GET_ADDR_CB_HANDLE = LINKER.downcallHandle(\n+                SymbolLookup.loaderLookup().find(\"get_addr_cb\").get(),\n+                FunctionDescriptor.ofVoid(ValueLayout.ADDRESS, ValueLayout.ADDRESS));\n+        try {\n+            TEST_ARG_HANDLE = MethodHandles.lookup().findStatic(TestAddressDereference.class, \"testArg\",\n+                    MethodType.methodType(void.class, MemorySegment.class, long.class));\n+        } catch (Throwable ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"layoutsAndAlignments\")\n+    public void testGetAddress(long alignment, ValueLayout layout) {\n+        boolean badAlign = layout.byteAlignment() > alignment;\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment segment = arena.allocate(ValueLayout.ADDRESS);\n+            segment.set(ValueLayout.ADDRESS, 0, MemorySegment.ofAddress(alignment));\n+            MemorySegment deref = segment.get(ValueLayout.ADDRESS.withTargetLayout(layout), 0);\n+            assertFalse(badAlign);\n+            assertEquals(deref.byteSize(), layout.byteSize());\n+        } catch (IllegalArgumentException ex) {\n+            assertTrue(badAlign);\n+            assertTrue(ex.getMessage().contains(\"alignment constraint for address\"));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"layoutsAndAlignments\")\n+    public void testGetAddressIndex(long alignment, ValueLayout layout) {\n+        boolean badAlign = layout.byteAlignment() > alignment;\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment segment = arena.allocate(ValueLayout.ADDRESS);\n+            segment.set(ValueLayout.ADDRESS, 0, MemorySegment.ofAddress(alignment));\n+            MemorySegment deref = segment.getAtIndex(ValueLayout.ADDRESS.withTargetLayout(layout), 0);\n+            assertFalse(badAlign);\n+            assertEquals(deref.byteSize(), layout.byteSize());\n+        } catch (IllegalArgumentException ex) {\n+            assertTrue(badAlign);\n+            assertTrue(ex.getMessage().contains(\"alignment constraint for address\"));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"layoutsAndAlignments\")\n+    public void testNativeReturn(long alignment, ValueLayout layout) throws Throwable {\n+        boolean badAlign = layout.byteAlignment() > alignment;\n+        try {\n+            MethodHandle get_addr_handle = LINKER.downcallHandle(GET_ADDR_SYM,\n+                    FunctionDescriptor.of(ValueLayout.ADDRESS.withTargetLayout(layout), ValueLayout.ADDRESS));\n+            MemorySegment deref = (MemorySegment)get_addr_handle.invokeExact(MemorySegment.ofAddress(alignment));\n+            assertFalse(badAlign);\n+            assertEquals(deref.byteSize(), layout.byteSize());\n+        } catch (IllegalArgumentException ex) {\n+            assertTrue(badAlign);\n+            assertTrue(ex.getMessage().contains(\"alignment constraint for address\"));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"layoutsAndAlignments\")\n+    public void testNativeUpcallArgPos(long alignment, ValueLayout layout) throws Throwable {\n+        boolean badAlign = layout.byteAlignment() > alignment;\n+        if (badAlign) return; \/\/ this will crash the JVM (exception occurs when going into the upcall stub)\n+        try (Arena arena = Arena.openConfined()) {\n+            FunctionDescriptor testDesc = FunctionDescriptor.ofVoid(ValueLayout.ADDRESS.withTargetLayout(layout));\n+            MethodHandle upcallHandle = MethodHandles.insertArguments(TEST_ARG_HANDLE, 1, layout.byteSize());\n+            MemorySegment testStub = LINKER.upcallStub(upcallHandle, testDesc, arena.scope());\n+            GET_ADDR_CB_HANDLE.invokeExact(MemorySegment.ofAddress(alignment), testStub);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"layoutsAndAlignments\")\n+    public void testNativeUpcallArgNeg(long alignment, ValueLayout layout) throws Throwable {\n+        boolean badAlign = layout.byteAlignment() > alignment;\n+        if (!badAlign) return;\n+        runInNewProcess(UpcallTestRunner.class, true,\n+                new String[] {Long.toString(alignment), layout.toString() })\n+                .assertStdErrContains(\"alignment constraint for address\");\n+    }\n+\n+    public static class UpcallTestRunner {\n+        public static void main(String[] args) throws Throwable {\n+            long alignment = parseAlignment(args[0]);\n+            ValueLayout layout = parseLayout(args[1]);\n+            try (Arena arena = Arena.openConfined()) {\n+                FunctionDescriptor testDesc = FunctionDescriptor.ofVoid(ValueLayout.ADDRESS.withTargetLayout(layout));\n+                MethodHandle upcallHandle = MethodHandles.insertArguments(TEST_ARG_HANDLE, 1, layout.byteSize());\n+                MemorySegment testStub = LINKER.upcallStub(upcallHandle, testDesc, arena.scope());\n+                GET_ADDR_CB_HANDLE.invokeExact(MemorySegment.ofAddress(alignment), testStub);\n+            }\n+        }\n+\n+        static long parseAlignment(String s) {\n+            return Long.parseLong(s);\n+        }\n+\n+        static ValueLayout parseLayout(String s) {\n+            return LayoutKind.parse(s).layout;\n+        }\n+    }\n+\n+    static void testArg(MemorySegment deref, long expectedSize) {\n+        assertEquals(deref.byteSize(), expectedSize);\n+    }\n+\n+    @DataProvider(name = \"layoutsAndAlignments\")\n+    static Object[][] layoutsAndAlignments() {\n+        List<Object[]> layoutsAndAlignments = new ArrayList<>();\n+        for (LayoutKind lk : LayoutKind.values()) {\n+            for (int align : new int[]{ 1, 2, 4, 8 }) {\n+                layoutsAndAlignments.add(new Object[] { align, lk.layout });\n+            }\n+        }\n+        return layoutsAndAlignments.toArray(Object[][]::new);\n+    }\n+\n+    enum LayoutKind {\n+        BOOL(ValueLayout.JAVA_BOOLEAN),\n+        CHAR(ValueLayout.JAVA_CHAR),\n+        SHORT(ValueLayout.JAVA_SHORT),\n+        INT(ValueLayout.JAVA_INT),\n+        FLOAT(ValueLayout.JAVA_FLOAT),\n+        LONG(ValueLayout.JAVA_LONG),\n+        DOUBLE(ValueLayout.JAVA_DOUBLE),\n+        ADDRESS(ValueLayout.ADDRESS);\n+\n+\n+        final ValueLayout layout;\n+\n+        LayoutKind(ValueLayout segment) {\n+            this.layout = segment;\n+        }\n+\n+        static LayoutKind parse(String layoutString) {\n+            return switch (layoutString.charAt(0)) {\n+                case 'A','a' -> ADDRESS;\n+                case 'z','Z' -> BOOL;\n+                case 'c','C' -> CHAR;\n+                case 's','S' -> SHORT;\n+                case 'i','I' -> INT;\n+                case 'f','F' -> FLOAT;\n+                case 'j','J' -> LONG;\n+                case 'd','D' -> DOUBLE;\n+                default -> throw new AssertionError(\"Invalid layout string: \" + layoutString);\n+            };\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestAddressDereference.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"},{"patch":"@@ -50,2 +50,2 @@\n-        if (layout instanceof ValueLayout.OfAddress addressLayout && addressLayout.isUnbounded()) {\n-            newLayout = ((ValueLayout.OfAddress)newLayout).asUnbounded();\n+        if (layout instanceof ValueLayout.OfAddress addressLayout && addressLayout.targetLayout().isPresent()) {\n+            newLayout = ((ValueLayout.OfAddress)newLayout).withTargetLayout(addressLayout.targetLayout().get());\n","filename":"test\/jdk\/java\/foreign\/TestLayoutEquality.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-    public void testNULLReturn_unbounded() throws Throwable {\n+    public void testNULLReturn_target() throws Throwable {\n@@ -69,1 +69,1 @@\n-                FunctionDescriptor.of(ValueLayout.ADDRESS.asUnbounded()));\n+                FunctionDescriptor.of(ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)));\n","filename":"test\/jdk\/java\/foreign\/TestNULLAddress.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -30,0 +31,2 @@\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -82,0 +85,67 @@\n+    @Test(expectedExceptions = IndexOutOfBoundsException.class)\n+    public void testSliceNegativeOffset() {\n+        MemorySegment.ofArray(new byte[100]).asSlice(-1);\n+    }\n+\n+    @Test(expectedExceptions = IndexOutOfBoundsException.class)\n+    public void testSliceNegativeOffsetGoodSize() {\n+        MemorySegment.ofArray(new byte[100]).asSlice(-1, 10);\n+    }\n+\n+    @Test(expectedExceptions = IndexOutOfBoundsException.class)\n+    public void testSliceGoodOffsetNegativeSize() {\n+        MemorySegment.ofArray(new byte[100]).asSlice(10, -1);\n+    }\n+\n+    @Test(expectedExceptions = IndexOutOfBoundsException.class)\n+    public void testSliceNegativeOffsetGoodLayout() {\n+        MemorySegment.ofArray(new byte[100]).asSlice(-1, ValueLayout.JAVA_INT);\n+    }\n+\n+    @Test(expectedExceptions = IndexOutOfBoundsException.class)\n+    public void testSliceOffsetTooBig() {\n+        MemorySegment.ofArray(new byte[100]).asSlice(120);\n+    }\n+\n+    @Test(expectedExceptions = IndexOutOfBoundsException.class)\n+    public void testSliceOffsetTooBigSizeGood() {\n+        MemorySegment.ofArray(new byte[100]).asSlice(120, 0);\n+    }\n+\n+    @Test(expectedExceptions = IndexOutOfBoundsException.class)\n+    public void testSliceOffsetOkSizeTooBig() {\n+        MemorySegment.ofArray(new byte[100]).asSlice(0, 120);\n+    }\n+\n+    @Test(expectedExceptions = IndexOutOfBoundsException.class)\n+    public void testSliceLayoutTooBig() {\n+        MemorySegment.ofArray(new byte[100])\n+                .asSlice(0, MemoryLayout.sequenceLayout(120, ValueLayout.JAVA_BYTE));\n+    }\n+\n+    @Test\n+    public void testUnboundedSlice() {\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment segment = arena.allocate(MemoryLayout.sequenceLayout(2, ValueLayout.JAVA_INT)); \/\/ size = 8\n+            MemorySegment slice = segment.asSlice(0, ValueLayout.JAVA_INT); \/\/ size = 4\n+            assertThrows(IndexOutOfBoundsException.class, () -> slice.getAtIndex(ValueLayout.JAVA_INT, 1));\n+            MemorySegment unbounded = slice.asUnbounded();\n+            assertEquals(unbounded.byteSize(), Long.MAX_VALUE);\n+            unbounded = unbounded.asSlice(0, MemoryLayout.sequenceLayout(2, ValueLayout.JAVA_INT)); \/\/ size = 8\n+            assertEquals(unbounded.byteSize(), segment.byteSize());\n+            assertEquals(segment.getAtIndex(ValueLayout.JAVA_INT, 1), unbounded.getAtIndex(ValueLayout.JAVA_INT, 1));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"segmentsAndLayouts\")\n+    public void testSliceAlignment(MemorySegment segment, long alignment, ValueLayout layout) {\n+        boolean badAlign = layout.byteAlignment() > alignment;\n+        try {\n+            segment.asSlice(0, layout);\n+            assertFalse(badAlign);\n+        } catch (IllegalArgumentException ex) {\n+            assertTrue(badAlign);\n+            assertTrue(ex.getMessage().contains(\"incompatible with alignment constraints\"));\n+        }\n+    }\n+\n@@ -101,0 +171,52 @@\n+\n+    @DataProvider(name = \"segmentsAndLayouts\")\n+    static Object[][] segmentsAndLayouts() {\n+        List<Object[]> segmentsAndLayouts = new ArrayList<>();\n+        for (SegmentKind sk : SegmentKind.values()) {\n+            for (LayoutKind lk : LayoutKind.values()) {\n+                for (int align : new int[]{ 1, 2, 4, 8 }) {\n+                    if (align > sk.maxAlign) break;\n+                    segmentsAndLayouts.add(new Object[] { sk.segment.asSlice(align), align, lk.layout });\n+                }\n+            }\n+        }\n+        return segmentsAndLayouts.toArray(Object[][]::new);\n+    }\n+\n+    enum SegmentKind {\n+        NATIVE(MemorySegment.allocateNative(100, SegmentScope.auto()), 8),\n+        BYTE_ARRAY(MemorySegment.ofArray(new byte[100]), 1),\n+        CHAR_ARRAY(MemorySegment.ofArray(new char[100]), 2),\n+        SHORT_ARRAY(MemorySegment.ofArray(new short[100]), 2),\n+        INT_ARRAY(MemorySegment.ofArray(new int[100]), 4),\n+        FLOAT_ARRAY(MemorySegment.ofArray(new float[100]), 4),\n+        LONG_ARRAY(MemorySegment.ofArray(new long[100]), 8),\n+        DOUBLE_ARRAY(MemorySegment.ofArray(new double[100]), 8);\n+\n+\n+        final MemorySegment segment;\n+        final int maxAlign;\n+\n+        SegmentKind(MemorySegment segment, int maxAlign) {\n+            this.segment = segment;\n+            this.maxAlign = maxAlign;\n+        }\n+    }\n+\n+    enum LayoutKind {\n+        BOOL(ValueLayout.JAVA_BOOLEAN),\n+        CHAR(ValueLayout.JAVA_CHAR),\n+        SHORT(ValueLayout.JAVA_SHORT),\n+        INT(ValueLayout.JAVA_INT),\n+        FLOAT(ValueLayout.JAVA_FLOAT),\n+        LONG(ValueLayout.JAVA_LONG),\n+        DOUBLE(ValueLayout.JAVA_DOUBLE),\n+        ADDRESS(ValueLayout.ADDRESS);\n+\n+\n+        final ValueLayout layout;\n+\n+        LayoutKind(ValueLayout segment) {\n+            this.layout = segment;\n+        }\n+    }\n","filename":"test\/jdk\/java\/foreign\/TestSlices.java","additions":123,"deletions":1,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT void* get_addr(void* align) {\n+    return align;\n+}\n+\n+EXPORT void get_addr_cb(void* align, void (*cb)(void*)) {\n+    cb(align);\n+}\n","filename":"test\/jdk\/java\/foreign\/libAddressDereference.c","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.foreign.MemoryLayout;\n@@ -69,1 +70,2 @@\n-    public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.asUnbounded();\n+    public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS\n+            .withTargetLayout(MemoryLayout.sequenceLayout(C_CHAR));\n@@ -74,1 +76,1 @@\n-            LINKER.defaultLookup().find(\"free\").get(), FunctionDescriptor.ofVoid(ValueLayout.ADDRESS));\n+            LINKER.defaultLookup().find(\"free\").get(), FunctionDescriptor.ofVoid(C_POINTER));\n@@ -77,1 +79,1 @@\n-            LINKER.defaultLookup().find(\"malloc\").get(), FunctionDescriptor.of(ValueLayout.ADDRESS.asUnbounded(), ValueLayout.JAVA_LONG));\n+            LINKER.defaultLookup().find(\"malloc\").get(), FunctionDescriptor.of(C_POINTER, ValueLayout.JAVA_LONG));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CLayouts.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -41,1 +41,2 @@\n-    private static final ValueLayout.OfAddress UNSAFE_ADDRESS = ValueLayout.ADDRESS.asUnbounded();\n+    private static final ValueLayout.OfAddress UNSAFE_ADDRESS = ValueLayout.ADDRESS\n+            .withTargetLayout(MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/pointers\/NativeType.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.lang.foreign.MemoryLayout;\n@@ -60,1 +61,2 @@\n-    public static final ValueLayout.OfAddress UNSAFE_ADDRESS = ValueLayout.ADDRESS.asUnbounded();\n+    public static final ValueLayout.OfAddress UNSAFE_ADDRESS = ValueLayout.ADDRESS\n+            .withTargetLayout(MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/pointers\/PointerBench.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}