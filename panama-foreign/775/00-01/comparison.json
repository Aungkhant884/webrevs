{"files":[{"patch":"@@ -569,3 +569,1 @@\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     * @throws IllegalCallerException If the caller is in a module that does not have native access enabled.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -399,1 +399,1 @@\n-                            .boxAddress(layout);\n+                            .boxAddressRaw(Utils.pointeeSize(layout), Utils.pointeeAlign(layout));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/LinuxRISCV64CallArranger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n+ * @library ..\/ \/test\/lib\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n@@ -47,1 +48,1 @@\n-public class TestAddressDereference {\n+public class TestAddressDereference extends UpcallTestHelper {\n@@ -113,1 +114,1 @@\n-    public void testNativeUpcallArg(long alignment, ValueLayout layout) throws Throwable {\n+    public void testNativeUpcallArgPos(long alignment, ValueLayout layout) throws Throwable {\n@@ -124,0 +125,30 @@\n+    @Test(dataProvider = \"layoutsAndAlignments\")\n+    public void testNativeUpcallArgNeg(long alignment, ValueLayout layout) throws Throwable {\n+        boolean badAlign = layout.byteAlignment() > alignment;\n+        if (!badAlign) return;\n+        runInNewProcess(UpcallTestRunner.class, true,\n+                new String[] {Long.toString(alignment), layout.toString() })\n+                .assertStdErrContains(\"alignment constraint for address\");\n+    }\n+\n+    public static class UpcallTestRunner {\n+        public static void main(String[] args) throws Throwable {\n+            long alignment = parseAlignment(args[0]);\n+            ValueLayout layout = parseLayout(args[1]);\n+            try (Arena arena = Arena.openConfined()) {\n+                FunctionDescriptor testDesc = FunctionDescriptor.ofVoid(ValueLayout.ADDRESS.withTargetLayout(layout));\n+                MethodHandle upcallHandle = MethodHandles.insertArguments(TEST_ARG_HANDLE, 1, layout.byteSize());\n+                MemorySegment testStub = LINKER.upcallStub(upcallHandle, testDesc, arena.scope());\n+                GET_ADDR_CB_HANDLE.invokeExact(MemorySegment.ofAddress(alignment), testStub);\n+            }\n+        }\n+\n+        static long parseAlignment(String s) {\n+            return Long.parseLong(s);\n+        }\n+\n+        static ValueLayout parseLayout(String s) {\n+            return LayoutKind.parse(s).layout;\n+        }\n+    }\n+\n@@ -155,0 +186,14 @@\n+\n+        static LayoutKind parse(String layoutString) {\n+            return switch (layoutString.charAt(0)) {\n+                case 'A','a' -> ADDRESS;\n+                case 'z','Z' -> BOOL;\n+                case 'c','C' -> CHAR;\n+                case 's','S' -> SHORT;\n+                case 'i','I' -> INT;\n+                case 'f','F' -> FLOAT;\n+                case 'j','J' -> LONG;\n+                case 'd','D' -> DOUBLE;\n+                default -> throw new AssertionError(\"Invalid layout string: \" + layoutString);\n+            };\n+        }\n","filename":"test\/jdk\/java\/foreign\/TestAddressDereference.java","additions":48,"deletions":3,"binary":false,"changes":51,"status":"modified"}]}