{"files":[{"patch":"@@ -254,1 +254,1 @@\n-        emitLayoutString(layout);\n+        emitLayoutString(layout, false);\n@@ -260,1 +260,1 @@\n-    private void emitLayoutString(MemoryLayout l) {\n+    private void emitLayoutString(MemoryLayout l, boolean inBitfield) {\n@@ -262,1 +262,1 @@\n-            append(typeToLayoutName(val));\n+            append(typeToLayoutName(val, inBitfield));\n@@ -268,1 +268,1 @@\n-            emitLayoutString(seq.elementLayout());\n+            emitLayoutString(seq.elementLayout(), false);\n@@ -278,0 +278,1 @@\n+            boolean isBitfield = LayoutUtils.isBitfields(group);\n@@ -281,1 +282,1 @@\n-                emitLayoutString(e);\n+                emitLayoutString(e, isBitfield);\n@@ -308,1 +309,1 @@\n-            emitLayoutString(desc.returnLayout().get());\n+            emitLayoutString(desc.returnLayout().get(), false);\n@@ -322,1 +323,1 @@\n-                emitLayoutString(e);\n+                emitLayoutString(e, false);\n@@ -362,1 +363,1 @@\n-    private static String typeToLayoutName(ValueLayout vl) {\n+    private static String typeToLayoutName(ValueLayout vl, boolean inBitfields) {\n@@ -365,0 +366,15 @@\n+        } else if (inBitfields) {\n+            return \"MemoryLayout.ofValueBits(\" + vl.bitSize() + \", ByteOrder.nativeOrder())\";\n+        } else {\n+            CLinker.TypeKind kind = (CLinker.TypeKind) vl.attribute(CLinker.TypeKind.ATTR_NAME).orElseThrow(\n+                    () -> new IllegalStateException(\"Unexpected value layout: could not determine ABI class\"));\n+            return switch (kind) {\n+                case CHAR -> \"C_CHAR\";\n+                case SHORT -> \"C_SHORT\";\n+                case INT -> \"C_INT\";\n+                case LONG -> \"C_LONG\";\n+                case LONG_LONG -> \"C_LONG_LONG\";\n+                case FLOAT -> \"C_FLOAT\";\n+                case DOUBLE -> \"C_DOUBLE\";\n+                case POINTER -> \"C_POINTER\";\n+            };\n@@ -366,13 +382,0 @@\n-\n-        CLinker.TypeKind kind = (CLinker.TypeKind)vl.attribute(CLinker.TypeKind.ATTR_NAME).orElseThrow(\n-                () -> new IllegalStateException(\"Unexpected value layout: could not determine ABI class\"));\n-        return switch (kind) {\n-            case CHAR -> \"C_CHAR\";\n-            case SHORT -> \"C_SHORT\";\n-            case INT -> \"C_INT\";\n-            case LONG -> \"C_LONG\";\n-            case LONG_LONG -> \"C_LONG_LONG\";\n-            case FLOAT -> \"C_FLOAT\";\n-            case DOUBLE -> \"C_DOUBLE\";\n-            case POINTER -> \"C_POINTER\";\n-        };\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/ConstantBuilder.java","additions":24,"deletions":21,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -224,0 +224,1 @@\n+        append(\"import java.nio.ByteOrder;\\n\");\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/JavaSourceBuilder.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.incubator.foreign.GroupLayout;\n@@ -46,0 +47,1 @@\n+    public static final String JEXTRACT_BITFIELDS = \"jextract\/bitfields\";\n@@ -219,0 +221,9 @@\n+\n+    static boolean isBitfields(GroupLayout layout) {\n+        return layout.attribute(JEXTRACT_BITFIELDS).isPresent();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    static <Z extends MemoryLayout> Z setBitfields(Z layout) {\n+        return (Z) layout.withAttribute(JEXTRACT_BITFIELDS, true);\n+    }\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/LayoutUtils.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-                            decls.add(treeMaker.createTree(c));\n+                            decls.add(decl);\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/Parser.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.incubator.foreign.GroupLayout;\n@@ -31,1 +30,0 @@\n-import jdk.incubator.foreign.ValueLayout;\n@@ -140,7 +138,2 @@\n-    ValueLayout bitfield(ValueLayout container, List<MemoryLayout> sublayouts) {\n-        return Utils.addContents(container, MemoryLayout.ofStruct(sublayouts.toArray(new MemoryLayout[0])));\n-    }\n-\n-    ValueLayout bitfield(long containerSize, List<MemoryLayout> sublayouts) {\n-        return bitfield((ValueLayout)LayoutUtils.valueLayoutForSize(containerSize)\n-                        .layout().orElseThrow(() -> new IllegalStateException(\"Unsupported size: \" + containerSize)), sublayouts);\n+    MemoryLayout bitfield(List<MemoryLayout> sublayouts) {\n+        return LayoutUtils.setBitfields(MemoryLayout.ofStruct(sublayouts.toArray(new MemoryLayout[0])));\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/RecordLayoutComputer.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-            fieldLayouts.addAll(convertBitfields(bitfieldLayouts));\n+            fieldLayouts.add(bitfield(bitfieldLayouts));\n@@ -138,57 +138,0 @@\n-\n-    private List<MemoryLayout> convertBitfields(List<MemoryLayout> layouts) {\n-        long offset = 0L;\n-        List<MemoryLayout> newFields = new ArrayList<>();\n-        List<MemoryLayout> pendingFields = new ArrayList<>();\n-        for (MemoryLayout l : layouts) {\n-            offset += l.bitSize();\n-            if (offset > MAX_STORAGE_SIZE) {\n-                throw new IllegalStateException(\"Crossing storage unit boundaries\");\n-            }\n-            pendingFields.add(l);\n-            long storageSize = storageSize(offset);\n-            if (!pendingFields.isEmpty() && storageSize != -1) {\n-                \/\/emit new\n-                newFields.add(bitfield(storageSize, pendingFields));\n-                pendingFields.clear();\n-                offset = 0L;\n-            }\n-        }\n-        if (!pendingFields.isEmpty()) {\n-            long storageSize = nextStorageSize(offset);\n-            \/\/emit new\n-            newFields.add(bitfield(storageSize, pendingFields));\n-            pendingFields.clear();\n-        }\n-        return newFields;\n-    }\n-\n-    static int[] STORAGE_SIZES = { 64, 32, 16, 8 };\n-    static int[] ALIGN_SIZES = { 8, 16, 32, 64 };\n-    static int MAX_STORAGE_SIZE = 64;\n-\n-    private long storageSize(long size) {\n-        \/\/ offset should be < MAX_STORAGE_SIZE\n-        for (int s : STORAGE_SIZES) {\n-            if (size == s) {\n-                return s;\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    private long nextStorageSize(long size) {\n-        \/\/ offset should be < MAX_STORAGE_SIZE\n-        for (int s : ALIGN_SIZES) {\n-            long alignedSize = alignUp(size, s);\n-            long storageSize = storageSize(alignedSize);\n-            if (storageSize != -1) {\n-                return storageSize;\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    private static long alignUp(long n, long alignment) {\n-        return (n + alignment - 1) & -alignment;\n-    }\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/StructLayoutComputer.java","additions":1,"deletions":58,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.util.Optional;\n@@ -302,2 +301,1 @@\n-            Optional<GroupLayout> contents = Utils.getContents(e);\n-            if (contents.isPresent()) {\n+            if (e instanceof GroupLayout contents && LayoutUtils.isBitfields(contents)) {\n@@ -305,1 +303,1 @@\n-                outer: for (MemoryLayout bitfield : contents.get().memberLayouts()) {\n+                outer: for (MemoryLayout bitfield : contents.memberLayouts()) {\n@@ -320,1 +318,1 @@\n-                    newDecls.add(Declaration.bitfields(bfDecls.get(0).pos(), \"\", contents.get(), bfDecls.toArray(new Declaration.Variable[0])));\n+                    newDecls.add(Declaration.bitfields(bfDecls.get(0).pos(), \"\", contents, bfDecls.toArray(new Declaration.Variable[0])));\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/TreeMaker.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.ArrayList;\n@@ -69,2 +70,1 @@\n-            MemoryLayout layout = LayoutUtils.getLayout(c.type());\n-            return bitfield((ValueLayout) layout, List.of(super.fieldLayout(c)));\n+            return bitfield(List.of(super.fieldLayout(c)));\n@@ -80,0 +80,4 @@\n+        } else if (c.isBitField()) {\n+            return c.getBitFieldWidth();\n+        } else {\n+            return c.type().size() * 8;\n@@ -81,1 +85,0 @@\n-        return c.type().size() * 8;\n@@ -86,1 +89,1 @@\n-        \/\/ size mismatch indicates anonymous bitfield used for padding\n+        \/\/ size mismatch indicates use of bitfields in union\n@@ -89,0 +92,1 @@\n+            \/\/ emit an extra padding of expected size to make sure union layout size is computed correctly\n@@ -90,0 +94,2 @@\n+        } else if (actualSize > expectedSize) {\n+            throw new AssertionError(\"Invalid union size - expected: \" + expectedSize + \"; found: \" + actualSize);\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/UnionLayoutComputer.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import jdk.incubator.foreign.GroupLayout;\n-import jdk.incubator.foreign.MemoryLayout;\n@@ -35,1 +33,0 @@\n-import jdk.internal.clang.TypeKind;\n@@ -41,1 +38,0 @@\n-import java.lang.reflect.Method;\n@@ -47,1 +43,0 @@\n-import java.util.HashMap;\n@@ -50,1 +45,0 @@\n-import java.util.stream.Collectors;\n@@ -325,9 +319,0 @@\n-\n-    static Optional<GroupLayout> getContents(MemoryLayout layout) {\n-        return layout.attribute(\"contents\").map(GroupLayout.class::cast);\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    static <Z extends MemoryLayout> Z addContents(Z layout, GroupLayout contents) {\n-        return (Z) layout.withAttribute(\"contents\", contents);\n-    }\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/Utils.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @requires os.family != \"windows\"\n@@ -34,3 +33,0 @@\n- * Not running on Windows since MSVC will not cross storage unit boundaries.\n- * Resulting struct on SysV is 16 bytes, but 24 on MSx64\n- *\n@@ -68,3 +64,1 @@\n-                getInputFilePath(\"badBitfields.h\").toString())\n-            .checkFailure()\n-            .checkContainsOutput(\"Crossing storage unit boundaries\");\n+                getInputFilePath(\"badBitfields.h\").toString()).checkSuccess();\n","filename":"test\/jdk\/tools\/jextract\/BadBitfieldTest.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"}]}