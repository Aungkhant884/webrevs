{"files":[{"patch":"@@ -70,1 +70,1 @@\n-  abi._imr_addr_reg = parse_vmstorage(abi_oop->obj_field(ABI.imrAddrStorage_offset))->as_Register();\n+  abi._ret_buf_addr_reg = parse_vmstorage(abi_oop->obj_field(ABI.retBufAddrStorage_offset))->as_Register();\n","filename":"src\/hotspot\/cpu\/aarch64\/foreign_globals_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-  Register _imr_addr_reg;\n+  Register _ret_buf_addr_reg;\n","filename":"src\/hotspot\/cpu\/aarch64\/foreign_globals_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-  bool _is_imr;\n+  bool _needs_return_buffer;\n@@ -60,1 +60,1 @@\n-                         bool is_imr)\n+                         bool needs_return_buffer)\n@@ -68,1 +68,1 @@\n-     _is_imr(is_imr),\n+     _needs_return_buffer(needs_return_buffer),\n@@ -97,1 +97,1 @@\n-                                                      bool is_imr) {\n+                                                      bool needs_return_buffer) {\n@@ -100,1 +100,1 @@\n-  NativeInvokerGenerator g(&code, signature, num_args, ret_bt, abi, input_registers, output_registers, is_imr);\n+  NativeInvokerGenerator g(&code, signature, num_args, ret_bt, abi, input_registers, output_registers, needs_return_buffer);\n@@ -149,1 +149,1 @@\n-  if (_is_imr) {\n+  if (_needs_return_buffer) {\n@@ -155,2 +155,2 @@\n-  int imr_addr_sp_offset = -1;\n-  if (_is_imr) {\n+  int ret_buf_addr_sp_offset = -1;\n+  if (_needs_return_buffer) {\n@@ -158,1 +158,1 @@\n-     imr_addr_sp_offset = allocated_frame_size - 8;\n+     ret_buf_addr_sp_offset = allocated_frame_size - 8;\n@@ -164,1 +164,1 @@\n-  if (!_is_imr) {\n+  if (!_needs_return_buffer) {\n@@ -198,3 +198,3 @@\n-  if (_is_imr) {\n-    assert(imr_addr_sp_offset != -1, \"no imr addr spill\");\n-    __ str(_abi._imr_addr_reg, Address(sp, imr_addr_sp_offset));\n+  if (_needs_return_buffer) {\n+    assert(ret_buf_addr_sp_offset != -1, \"no return buffer addr spill\");\n+    __ str(_abi._ret_buf_addr_reg, Address(sp, ret_buf_addr_sp_offset));\n@@ -207,1 +207,1 @@\n-  if (!_is_imr) {\n+  if (!_needs_return_buffer) {\n@@ -224,2 +224,2 @@\n-    assert(imr_addr_sp_offset != -1, \"no imr addr spill\");\n-    __ ldr(tmp1, Address(sp, imr_addr_sp_offset));\n+    assert(ret_buf_addr_sp_offset != -1, \"no return buffer addr spill\");\n+    __ ldr(tmp1, Address(sp, ret_buf_addr_sp_offset));\n@@ -283,1 +283,1 @@\n-  if (!_is_imr) {\n+  if (!_needs_return_buffer) {\n@@ -293,1 +293,1 @@\n-  if (!_is_imr) {\n+  if (!_needs_return_buffer) {\n@@ -305,1 +305,1 @@\n-  if (!_is_imr) {\n+  if (!_needs_return_buffer) {\n@@ -311,1 +311,1 @@\n-  if (!_is_imr) {\n+  if (!_needs_return_buffer) {\n","filename":"src\/hotspot\/cpu\/aarch64\/universalNativeInvoker_aarch64.cpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-                                                      bool is_imr) {\n+                                                      bool needs_return_buffer) {\n","filename":"src\/hotspot\/cpu\/arm\/universalNativeInvoker_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-                                                      bool is_imr) {\n+                                                      bool needs_return_buffer) {\n","filename":"src\/hotspot\/cpu\/ppc\/universalNativeInvoker_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-                                                      bool is_imr) {\n+                                                      bool needs_return_buffer) {\n","filename":"src\/hotspot\/cpu\/s390\/universalNativeInvoker_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-  abi._imr_addr_reg = parse_vmstorage(abi_oop->obj_field(ABI.imrAddrStorage_offset))->as_Register();\n+  abi._ret_buf_addr_reg = parse_vmstorage(abi_oop->obj_field(ABI.retBufAddrStorage_offset))->as_Register();\n","filename":"src\/hotspot\/cpu\/x86\/foreign_globals_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-  Register _imr_addr_reg;\n+  Register _ret_buf_addr_reg;\n","filename":"src\/hotspot\/cpu\/x86\/foreign_globals_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-                                                      bool is_imr) {\n+                                                      bool needs_return_buffer) {\n","filename":"src\/hotspot\/cpu\/x86\/universalNativeInvoker_x86_32.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-  bool _is_imr;\n+  bool _needs_return_buffer;\n@@ -59,1 +59,1 @@\n-                         bool is_imr)\n+                         bool needs_return_buffer)\n@@ -67,1 +67,1 @@\n-     _is_imr(is_imr),\n+     _needs_return_buffer(needs_return_buffer),\n@@ -96,1 +96,1 @@\n-                                                      bool is_imr) {\n+                                                      bool needs_return_buffer) {\n@@ -99,1 +99,1 @@\n-  NativeInvokerGenerator g(&code, signature, num_args, ret_bt, abi, input_registers, output_registers, is_imr);\n+  NativeInvokerGenerator g(&code, signature, num_args, ret_bt, abi, input_registers, output_registers, needs_return_buffer);\n@@ -146,1 +146,1 @@\n-  if (_is_imr) {\n+  if (_needs_return_buffer) {\n@@ -152,2 +152,2 @@\n-  int imr_addr_rsp_offset = -1;\n-  if (_is_imr) {\n+  int ret_buf_addr_rsp_offset = -1;\n+  if (_needs_return_buffer) {\n@@ -155,1 +155,1 @@\n-    imr_addr_rsp_offset = allocated_frame_size - 8;\n+    ret_buf_addr_rsp_offset = allocated_frame_size - 8;\n@@ -158,2 +158,2 @@\n-  \/\/ in the not IMR case we need to spill the return value around our slowpath calls\n-  \/\/ in the IMR case this SHOULD be unused.\n+  \/\/ when we don't use a return buffer we need to spill the return value around our slowpath calls\n+  \/\/ when we use a return buffer case this SHOULD be unused.\n@@ -163,1 +163,1 @@\n-  if (!_is_imr) {\n+  if (!_needs_return_buffer) {\n@@ -198,4 +198,4 @@\n-  if (_is_imr) {\n-    \/\/ spill our imr address\n-    assert(imr_addr_rsp_offset != -1, \"no imr addr spill\");\n-    __ movptr(Address(rsp, imr_addr_rsp_offset), _abi._imr_addr_reg);\n+  if (_needs_return_buffer) {\n+    \/\/ spill our return buffer address\n+    assert(ret_buf_addr_rsp_offset != -1, \"no return buffer addr spill\");\n+    __ movptr(Address(rsp, ret_buf_addr_rsp_offset), _abi._ret_buf_addr_reg);\n@@ -208,1 +208,1 @@\n-  if (!_is_imr) {\n+  if (!_needs_return_buffer) {\n@@ -226,2 +226,2 @@\n-    assert(imr_addr_rsp_offset != -1, \"no imr addr spill\");\n-    __ movptr(rscratch1, Address(rsp, imr_addr_rsp_offset));\n+    assert(ret_buf_addr_rsp_offset != -1, \"no return buffer addr spill\");\n+    __ movptr(rscratch1, Address(rsp, ret_buf_addr_rsp_offset));\n@@ -284,1 +284,1 @@\n-  if(!_is_imr) {\n+  if(!_needs_return_buffer) {\n@@ -296,1 +296,1 @@\n-  if(!_is_imr) {\n+  if(!_needs_return_buffer) {\n@@ -309,1 +309,1 @@\n-  if(!_is_imr) {\n+  if(!_needs_return_buffer) {\n@@ -320,1 +320,1 @@\n-  if(!_is_imr) {\n+  if(!_needs_return_buffer) {\n","filename":"src\/hotspot\/cpu\/x86\/universalNativeInvoker_x86_64.cpp","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-                                                      bool is_imr) {\n+                                                      bool needs_return_buffer) {\n","filename":"src\/hotspot\/cpu\/zero\/universalNativeInvoker_zero.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-  ABI.imrAddrStorage_offset = field_offset(k_ABI, \"imrAddrStorage\", symVMS);\n+  ABI.retBufAddrStorage_offset = field_offset(k_ABI, \"retBufAddrStorage\", symVMS);\n","filename":"src\/hotspot\/share\/prims\/foreign_globals.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    int imrAddrStorage_offset;\n+    int retBufAddrStorage_offset;\n","filename":"src\/hotspot\/share\/prims\/foreign_globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-                                 jlongArray arg_moves, jlongArray ret_moves, jboolean is_imr))\n+                                 jlongArray arg_moves, jlongArray ret_moves, jboolean needs_return_buffer))\n@@ -109,1 +109,1 @@\n-    basic_type, pslots, ret_bt, abi, input_regs, output_regs, is_imr)->code_begin();\n+    basic_type, pslots, ret_bt, abi, input_regs, output_regs, needs_return_buffer)->code_begin();\n","filename":"src\/hotspot\/share\/prims\/nativeEntryPoint.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-                                          bool is_imr);\n+                                          bool needs_return_buffer);\n","filename":"src\/hotspot\/share\/prims\/universalNativeInvoker.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -126,2 +126,2 @@\n-    public FunctionDescriptor withAppendedArgumentLayouts(MemoryLayout... addedLayouts) {\n-        return withInsertedArgumentLayouts(argLayouts.length, addedLayouts);\n+    public FunctionDescriptor appendArgumentLayouts(MemoryLayout... addedLayouts) {\n+        return insertArgumentLayouts(argLayouts.length, addedLayouts);\n@@ -138,1 +138,1 @@\n-    public FunctionDescriptor withInsertedArgumentLayouts(int index, MemoryLayout... addedLayouts) {\n+    public FunctionDescriptor insertArgumentLayouts(int index, MemoryLayout... addedLayouts) {\n@@ -245,1 +245,6 @@\n-        public FunctionDescriptor withAppendedArgumentLayouts(MemoryLayout... addedLayouts) {\n+        public FunctionDescriptor appendArgumentLayouts(MemoryLayout... addedLayouts) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public FunctionDescriptor insertArgumentLayouts(int index, MemoryLayout... addedLayouts) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/FunctionDescriptor.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-    final VMStorage imrAddrStorage;\n+    final VMStorage retBufAddrStorage;\n@@ -45,1 +45,1 @@\n-                         VMStorage targetAddrStorage, VMStorage imrAddrStorage) {\n+                         VMStorage targetAddrStorage, VMStorage retBufAddrStorage) {\n@@ -53,1 +53,1 @@\n-        this.imrAddrStorage = imrAddrStorage;\n+        this.retBufAddrStorage = retBufAddrStorage;\n@@ -65,2 +65,2 @@\n-    public VMStorage imrAddrStorage() {\n-        return imrAddrStorage;\n+    public VMStorage retBufAddrStorage() {\n+        return retBufAddrStorage;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ABIDescriptor.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -37,8 +37,2 @@\n-\n-    \/\/ is IMR (In Memory Return).\n-    \/\/ Note that this is implementation-level IMR used to\n-    \/\/ support multi-register returns. A particular ABI\n-    \/\/ might add it's own IMR on top of this as well\n-    \/\/ (see SharedUtils::adaptDowncallForIMR & SharedUtils::adaptUpcallForIMR)\n-    private final boolean isImr;\n-    private final long imrSize;\n+    private final boolean needsReturnBuffer;\n+    private final long returnBufferSize;\n@@ -51,1 +45,1 @@\n-                           boolean isTrivial, boolean isImr, long imrSize, long allocationSize,\n+                           boolean isTrivial, boolean needsReturnBuffer, long returnBufferSize, long allocationSize,\n@@ -56,2 +50,2 @@\n-        this.isImr = isImr;\n-        this.imrSize = imrSize;\n+        this.needsReturnBuffer = needsReturnBuffer;\n+        this.returnBufferSize = returnBufferSize;\n@@ -109,2 +103,2 @@\n-    public boolean isImr() {\n-        return isImr;\n+    public boolean needsReturnBuffer() {\n+        return needsReturnBuffer;\n@@ -113,2 +107,2 @@\n-    public long imrSize() {\n-        return imrSize;\n+    public long returnBufferSize() {\n+        return returnBufferSize;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequence.java","additions":9,"deletions":15,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-        desc = desc.withInsertedArgumentLayouts(index, layout);\n+        desc = desc.insertArgumentLayouts(index, layout);\n@@ -91,1 +91,1 @@\n-    private boolean isImr() {\n+    private boolean needsReturnBuffer() {\n@@ -98,3 +98,3 @@\n-        boolean isImr = isImr();\n-        long imrSize = isImr ? computeImrSize() : 0;\n-        long allocationSize = computeAllocationSize() + imrSize;\n+        boolean needsReturnBuffer = needsReturnBuffer();\n+        long returnBufferSize = needsReturnBuffer ? computeReturnBuferSize() : 0;\n+        long allocationSize = computeAllocationSize() + returnBufferSize;\n@@ -105,1 +105,1 @@\n-            if (isImr) {\n+            if (needsReturnBuffer) {\n@@ -108,1 +108,1 @@\n-                    Binding.vmStore(abi.imrAddrStorage(), long.class)));\n+                    Binding.vmStore(abi.retBufAddrStorage(), long.class)));\n@@ -111,1 +111,1 @@\n-        return new CallingSequence(mt, desc, isTrivial, isImr, imrSize, allocationSize, inputBindings, outputBindings);\n+        return new CallingSequence(mt, desc, isTrivial, needsReturnBuffer, returnBufferSize, allocationSize, inputBindings, outputBindings);\n@@ -132,1 +132,1 @@\n-    private long computeImrSize() {\n+    private long computeReturnBuferSize() {\n@@ -134,1 +134,1 @@\n-                .filter(Binding.Move.class ::isInstance)\n+                .filter(Binding.Move.class::isInstance)\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequenceBuilder.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-    private static final MethodHandle MH_ALLOCATE_IMR_SEGMENT;\n+    private static final MethodHandle MH_ALLOCATE_RETURN_BUFFER;\n@@ -81,1 +81,1 @@\n-            MH_ALLOCATE_IMR_SEGMENT = lookup.findStatic(ProgrammableInvoker.class, \"allocateIMRSegment\",\n+            MH_ALLOCATE_RETURN_BUFFER = lookup.findStatic(ProgrammableInvoker.class, \"allocateReturnBuffer\",\n@@ -114,1 +114,1 @@\n-            callingSequence.isImr()\n+            callingSequence.needsReturnBuffer()\n@@ -127,2 +127,2 @@\n-            if (callingSequence.isImr()) {\n-                \/\/ IMR segment is supplied by invokeInterpBindings\n+            if (callingSequence.needsReturnBuffer()) {\n+                \/\/ Return buffer is supplied by invokeInterpBindings\n@@ -146,1 +146,1 @@\n-    private static MemorySegment allocateIMRSegment(Binding.Context context, long size) {\n+    private static MemorySegment allocateReturnBuffer(Binding.Context context, long size) {\n@@ -202,2 +202,2 @@\n-            int retImrSegPos = -1;\n-            long imrReadOffset = -1;\n+            int retBufPos = -1;\n+            long retBufReadOffset = -1;\n@@ -206,3 +206,3 @@\n-            if (callingSequence.isImr()) {\n-                retImrSegPos = 0;\n-                imrReadOffset = callingSequence.imrSize();\n+            if (callingSequence.needsReturnBuffer()) {\n+                retBufPos = 0;\n+                retBufReadOffset = callingSequence.returnBufferSize();\n@@ -211,1 +211,1 @@\n-                returnFilter = dropArguments(returnFilter, retImrSegPos, MemorySegment.class);\n+                returnFilter = dropArguments(returnFilter, retBufPos, MemorySegment.class);\n@@ -217,2 +217,2 @@\n-                if (callingSequence.isImr() && binding.tag() == Binding.Tag.VM_LOAD) {\n-                    \/\/ spacial case this, since we need to update imrReadOffset as well\n+                if (callingSequence.needsReturnBuffer() && binding.tag() == Binding.Tag.VM_LOAD) {\n+                    \/\/ spacial case this, since we need to update retBufReadOffset as well\n@@ -222,2 +222,2 @@\n-                    imrReadOffset -= abi.arch.typeSize(load.storage().type());\n-                    MethodHandle loadHandle = MemoryHandles.insertCoordinates(MemoryHandles.varHandle(layout), 1, imrReadOffset)\n+                    retBufReadOffset -= abi.arch.typeSize(load.storage().type());\n+                    MethodHandle loadHandle = MemoryHandles.insertCoordinates(MemoryHandles.varHandle(layout), 1, retBufReadOffset)\n@@ -229,1 +229,1 @@\n-                    returnFilter = SharedUtils.mergeArguments(returnFilter, retImrSegPos, retInsertPos);\n+                    returnFilter = SharedUtils.mergeArguments(returnFilter, retBufPos, retInsertPos);\n@@ -232,1 +232,1 @@\n-                    retInsertPos -= 2; \/\/ set insert pos back the the first MS (later DUP binding will merge the 2 MS)\n+                    retInsertPos -= 2; \/\/ set insert pos back to the first MS (later DUP binding will merge the 2 MS)\n@@ -235,1 +235,1 @@\n-                    if (callingSequence.isImr() && binding.tag() == Binding.Tag.BUFFER_STORE) {\n+                    if (callingSequence.needsReturnBuffer() && binding.tag() == Binding.Tag.BUFFER_STORE) {\n@@ -246,1 +246,1 @@\n-            if (callingSequence.isImr()) {\n+            if (callingSequence.needsReturnBuffer()) {\n@@ -248,1 +248,1 @@\n-                specializedHandle = SharedUtils.mergeArguments(specializedHandle, retImrSegPos, retImrSegPos + 3);\n+                specializedHandle = SharedUtils.mergeArguments(specializedHandle, retBufPos, retBufPos + 3);\n@@ -250,2 +250,2 @@\n-                \/\/ allocate the IMR memory segment from the binding context, and then merge the 2 allocator args\n-                MethodHandle imrAllocHandle = MethodHandles.insertArguments(MH_ALLOCATE_IMR_SEGMENT, 1, callingSequence.imrSize());\n+                \/\/ allocate the return buffer from the binding context, and then merge the 2 allocator args\n+                MethodHandle retBufAllocHandle = MethodHandles.insertArguments(MH_ALLOCATE_RETURN_BUFFER, 1, callingSequence.returnBufferSize());\n@@ -253,1 +253,1 @@\n-                specializedHandle = MethodHandles.filterArguments(specializedHandle, retImrSegPos, imrAllocHandle);\n+                specializedHandle = MethodHandles.filterArguments(specializedHandle, retBufPos, retBufAllocHandle);\n@@ -255,1 +255,1 @@\n-                specializedHandle = SharedUtils.mergeArguments(specializedHandle, argContextPos + 1, retImrSegPos); \/\/ +1 to skip return context\n+                specializedHandle = SharedUtils.mergeArguments(specializedHandle, argContextPos + 1, retBufPos); \/\/ +1 to skip return context\n@@ -277,1 +277,1 @@\n-            MemorySegment imrSegment = null;\n+            MemorySegment returnBuffer = null;\n@@ -281,2 +281,2 @@\n-            if (callingSequence.isImr()) {\n-                \/\/ in case of IMR, we supply the segment (argument array does not contain it)\n+            if (callingSequence.needsReturnBuffer()) {\n+                \/\/ we supply the return buffer (argument array does not contain it)\n@@ -284,2 +284,2 @@\n-                imrSegment = unboxContext.allocator().allocate(callingSequence.imrSize());\n-                prefixedArgs[0] = imrSegment;\n+                returnBuffer = unboxContext.allocator().allocate(callingSequence.returnBufferSize());\n+                prefixedArgs[0] = returnBuffer;\n@@ -302,1 +302,1 @@\n-                if (!callingSequence.isImr()) {\n+                if (!callingSequence.needsReturnBuffer()) {\n@@ -305,1 +305,1 @@\n-                MemorySegment finalImrSegment = imrSegment;\n+                MemorySegment finalReturnBuffer = returnBuffer;\n@@ -308,1 +308,1 @@\n-                            int imrReadOffset = 0;\n+                            int retBufReadOffset = 0;\n@@ -311,2 +311,2 @@\n-                                Object result1 = SharedUtils.read(finalImrSegment.asSlice(imrReadOffset), type);\n-                                imrReadOffset += abi.arch.typeSize(storage.type());\n+                                Object result1 = SharedUtils.read(finalReturnBuffer.asSlice(retBufReadOffset), type);\n+                                retBufReadOffset += abi.arch.typeSize(storage.type());\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableInvoker.java","additions":35,"deletions":35,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -152,1 +152,1 @@\n-                                       VMStorage targetAddrStorage, VMStorage imrAddrStorage) {\n+                                       VMStorage targetAddrStorage, VMStorage retBufAddrStorage) {\n@@ -169,1 +169,1 @@\n-                targetAddrStorage, imrAddrStorage);\n+                targetAddrStorage, retBufAddrStorage);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64Architecture.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-        r10  \/\/ imr addr reg\n+        r10  \/\/ return buffer addr reg\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-                                       VMStorage targetAddrStorage, VMStorage imrAddrStorage) {\n+                                       VMStorage targetAddrStorage, VMStorage retBufAddrStorage) {\n@@ -156,1 +156,1 @@\n-                targetAddrStorage, imrAddrStorage);\n+                targetAddrStorage, retBufAddrStorage);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/X86_64Architecture.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import java.lang.constant.Constable;\n@@ -38,1 +37,0 @@\n-import java.util.stream.Collectors;\n@@ -70,1 +68,1 @@\n-        fd = fd.withAppendedArgumentLayouts(C_POINTER);\n+        fd = fd.appendArgumentLayouts(C_POINTER);\n","filename":"test\/jdk\/java\/foreign\/TestFunctionDescriptor.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-        assertEquals(callingSequence.functionDesc(), fd.withInsertedArgumentLayouts(0, ADDRESS));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -90,1 +90,1 @@\n-        assertEquals(callingSequence.functionDesc(), fd.withInsertedArgumentLayouts(0, ADDRESS));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -120,1 +120,1 @@\n-        assertEquals(callingSequence.functionDesc(), fd.withInsertedArgumentLayouts(0, ADDRESS));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -142,1 +142,1 @@\n-        assertEquals(callingSequence.functionDesc(), fd.withInsertedArgumentLayouts(0, ADDRESS));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -202,1 +202,1 @@\n-        assertEquals(callingSequence.functionDesc(), fd.withInsertedArgumentLayouts(0, ADDRESS));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -257,1 +257,1 @@\n-        assertEquals(callingSequence.functionDesc(), fd.withInsertedArgumentLayouts(0, ADDRESS, ADDRESS));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS, ADDRESS));\n@@ -286,1 +286,1 @@\n-        assertEquals(callingSequence.functionDesc(), fd.withInsertedArgumentLayouts(0, ADDRESS, ADDRESS));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS, ADDRESS));\n@@ -324,1 +324,1 @@\n-        assertEquals(callingSequence.functionDesc(), fd.withInsertedArgumentLayouts(0, ADDRESS));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -378,1 +378,1 @@\n-        assertEquals(callingSequence.functionDesc(), fd.withInsertedArgumentLayouts(0, ADDRESS));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -401,0 +401,1 @@\n+        FunctionDescriptor fdExpected = FunctionDescriptor.ofVoid(ADDRESS, C_INT).asVariadic(C_INT, C_FLOAT);\n@@ -405,2 +406,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fdExpected);\n@@ -410,0 +411,1 @@\n+            { unboxAddress(NativeSymbol.class), vmStore(r9, long.class) },\n@@ -422,0 +424,1 @@\n+        FunctionDescriptor fdExpected = FunctionDescriptor.ofVoid(ADDRESS, C_INT).asVariadic(C_INT, C_FLOAT);\n@@ -426,2 +429,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fdExpected);\n@@ -431,0 +434,1 @@\n+            { unboxAddress(NativeSymbol.class), vmStore(r9, long.class) },\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestAarch64CallArranger.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        assertEquals(callingSequence.functionDesc(), fd.withAppendedArgumentLayouts(C_LONG).withInsertedArgumentLayouts(0, ADDRESS));\n+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG).insertArgumentLayouts(0, ADDRESS));\n@@ -95,1 +95,1 @@\n-        assertEquals(callingSequence.functionDesc(), fd.withAppendedArgumentLayouts(C_LONG).withInsertedArgumentLayouts(0, ADDRESS));\n+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG).insertArgumentLayouts(0, ADDRESS));\n@@ -126,1 +126,1 @@\n-        assertEquals(callingSequence.functionDesc(), fd.withAppendedArgumentLayouts(C_LONG).withInsertedArgumentLayouts(0, ADDRESS));\n+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG).insertArgumentLayouts(0, ADDRESS));\n@@ -156,1 +156,1 @@\n-        assertEquals(callingSequence.functionDesc(), fd.withAppendedArgumentLayouts(C_LONG).withInsertedArgumentLayouts(0, ADDRESS));\n+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG).insertArgumentLayouts(0, ADDRESS));\n@@ -186,1 +186,1 @@\n-        assertEquals(callingSequence.functionDesc(), fd.withAppendedArgumentLayouts(C_LONG).withInsertedArgumentLayouts(0, ADDRESS));\n+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG).insertArgumentLayouts(0, ADDRESS));\n@@ -211,1 +211,1 @@\n-        assertEquals(callingSequence.functionDesc(), fd.withAppendedArgumentLayouts(C_LONG).withInsertedArgumentLayouts(0, ADDRESS));\n+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG).insertArgumentLayouts(0, ADDRESS));\n@@ -242,1 +242,1 @@\n-        assertEquals(callingSequence.functionDesc(), fd.withAppendedArgumentLayouts(C_LONG).withInsertedArgumentLayouts(0, ADDRESS));\n+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG).insertArgumentLayouts(0, ADDRESS));\n@@ -277,1 +277,1 @@\n-        assertEquals(callingSequence.functionDesc(), fd.withAppendedArgumentLayouts(C_LONG).withInsertedArgumentLayouts(0, ADDRESS));\n+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG).insertArgumentLayouts(0, ADDRESS));\n@@ -334,1 +334,1 @@\n-        assertEquals(callingSequence.functionDesc(), fd.withAppendedArgumentLayouts(C_LONG).withInsertedArgumentLayouts(0, ADDRESS));\n+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG).insertArgumentLayouts(0, ADDRESS));\n@@ -377,1 +377,1 @@\n-        assertEquals(callingSequence.functionDesc(), fd.withAppendedArgumentLayouts(C_LONG).withInsertedArgumentLayouts(0, ADDRESS));\n+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG).insertArgumentLayouts(0, ADDRESS));\n@@ -399,1 +399,1 @@\n-        assertEquals(callingSequence.functionDesc(), fd.withAppendedArgumentLayouts(C_LONG).withInsertedArgumentLayouts(0, ADDRESS));\n+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG).insertArgumentLayouts(0, ADDRESS));\n@@ -458,1 +458,1 @@\n-        assertEquals(callingSequence.functionDesc(), fd.withAppendedArgumentLayouts(C_LONG).withInsertedArgumentLayouts(0, ADDRESS, ADDRESS));\n+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG).insertArgumentLayouts(0, ADDRESS, ADDRESS));\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestSysVCallArranger.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-        assertEquals(callingSequence.functionDesc(), fd.withInsertedArgumentLayouts(0, ADDRESS));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -82,1 +82,1 @@\n-        assertEquals(callingSequence.functionDesc(), fd.withInsertedArgumentLayouts(0, ADDRESS));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -104,1 +104,1 @@\n-        assertEquals(callingSequence.functionDesc(), fd.withInsertedArgumentLayouts(0, ADDRESS));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -128,1 +128,1 @@\n-        assertEquals(callingSequence.functionDesc(), fd.withInsertedArgumentLayouts(0, ADDRESS));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -159,1 +159,1 @@\n-        assertEquals(callingSequence.functionDesc(), fd.withInsertedArgumentLayouts(0, ADDRESS));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -189,0 +189,2 @@\n+        FunctionDescriptor fdExpected = FunctionDescriptor.ofVoid(\n+                ADDRESS, C_INT, C_DOUBLE).asVariadic(C_INT, C_DOUBLE, C_DOUBLE);\n@@ -194,1 +196,1 @@\n-        assertEquals(callingSequence.functionDesc(), fd.withInsertedArgumentLayouts(0, ADDRESS));\n+        assertEquals(callingSequence.functionDesc(), fdExpected);\n@@ -228,1 +230,1 @@\n-        assertEquals(callingSequence.functionDesc(), fd.withInsertedArgumentLayouts(0, ADDRESS));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -258,1 +260,1 @@\n-        assertEquals(callingSequence.functionDesc(), fd.withInsertedArgumentLayouts(0, ADDRESS));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -289,1 +291,1 @@\n-        assertEquals(callingSequence.functionDesc(), fd.withInsertedArgumentLayouts(0, ADDRESS));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -310,1 +312,1 @@\n-        assertEquals(callingSequence.functionDesc(), fd.withInsertedArgumentLayouts(0, ADDRESS));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -363,1 +365,1 @@\n-        assertEquals(callingSequence.functionDesc(), fd.withInsertedArgumentLayouts(0, ADDRESS));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestWindowsCallArranger.java","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-public class Upcalls extends CLayouts {\n+public class Upcalls extends org.openjdk.bench.jdk.incubator.foreign.CLayouts {\n@@ -74,4 +74,4 @@\n-        cb_blank_jni = JNICB.makeCB(className, \"blank\", \"()V\");\n-        cb_identity_jni = JNICB.makeCB(className, \"identity\", \"(I)I\");\n-        cb_args5_jni = JNICB.makeCB(className, \"args5\", \"(JDJDJ)V\");\n-        cb_args10_jni = JNICB.makeCB(className, \"args10\", \"(JDJDJDJDJD)V\");\n+        cb_blank_jni = org.openjdk.bench.jdk.incubator.foreign.JNICB.makeCB(className, \"blank\", \"()V\");\n+        cb_identity_jni = org.openjdk.bench.jdk.incubator.foreign.JNICB.makeCB(className, \"identity\", \"(I)I\");\n+        cb_args5_jni = org.openjdk.bench.jdk.incubator.foreign.JNICB.makeCB(className, \"args5\", \"(JDJDJ)V\");\n+        cb_args10_jni = org.openjdk.bench.jdk.incubator.foreign.JNICB.makeCB(className, \"args10\", \"(JDJDJDJDJD)V\");\n@@ -127,1 +127,1 @@\n-                baseDesc.withAppendedArgumentLayouts(C_POINTER)\n+                baseDesc.appendArgumentLayouts(C_POINTER)\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/Upcalls.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"}]}