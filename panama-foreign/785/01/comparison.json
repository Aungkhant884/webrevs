{"files":[{"patch":"@@ -222,0 +222,3 @@\n+# LeakSanitizer\n+JDKOPT_SETUP_LEAK_SANITIZER\n+\n","filename":"make\/autoconf\/configure.ac","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -443,0 +443,33 @@\n+###############################################################################\n+#\n+# LeakSanitizer\n+#\n+AC_DEFUN_ONCE([JDKOPT_SETUP_LEAK_SANITIZER],\n+[\n+  UTIL_ARG_ENABLE(NAME: lsan, DEFAULT: false, RESULT: LSAN_ENABLED,\n+      DESC: [enable LeakSanitizer],\n+      CHECK_AVAILABLE: [\n+        AC_MSG_CHECKING([if LeakSanitizer (lsan) is available])\n+        if test \"x$TOOLCHAIN_TYPE\" = \"xgcc\" ||\n+            test \"x$TOOLCHAIN_TYPE\" = \"xclang\"; then\n+          AC_MSG_RESULT([yes])\n+        else\n+          AC_MSG_RESULT([no])\n+          AVAILABLE=false\n+        fi\n+      ],\n+      IF_ENABLED: [\n+        LSAN_CFLAGS=\"-fsanitize=leak -fno-omit-frame-pointer -DLEAK_SANITIZER\"\n+        LSAN_LDFLAGS=\"-fsanitize=leak\"\n+        JVM_CFLAGS=\"$JVM_CFLAGS $LSAN_CFLAGS\"\n+        JVM_LDFLAGS=\"$JVM_LDFLAGS $LSAN_LDFLAGS\"\n+        CFLAGS_JDKLIB=\"$CFLAGS_JDKLIB $LSAN_CFLAGS\"\n+        CFLAGS_JDKEXE=\"$CFLAGS_JDKEXE $LSAN_CFLAGS\"\n+        CXXFLAGS_JDKLIB=\"$CXXFLAGS_JDKLIB $LSAN_CFLAGS\"\n+        CXXFLAGS_JDKEXE=\"$CXXFLAGS_JDKEXE $LSAN_CFLAGS\"\n+        LDFLAGS_JDKLIB=\"$LDFLAGS_JDKLIB $LSAN_LDFLAGS\"\n+        LDFLAGS_JDKEXE=\"$LDFLAGS_JDKEXE $LSAN_LDFLAGS\"\n+      ])\n+  AC_SUBST(LSAN_ENABLED)\n+])\n+\n","filename":"make\/autoconf\/jdk-options.m4","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -454,0 +454,3 @@\n+# LeakSanitizer\n+LSAN_ENABLED:=@LSAN_ENABLED@\n+\n","filename":"make\/autoconf\/spec.gmk.in","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -153,0 +153,4 @@\n+  ifeq ($(LSAN_ENABLED), true)\n+    $1_EXTRA_FILES += $(TOPDIR)\/make\/data\/lsan\/lsan_default_options.c\n+  endif\n+\n","filename":"make\/common\/modules\/LauncherCommon.gmk","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -851,18 +851,0 @@\n-    \/\/ Define the reference implementation profiles. These are basically the same\n-    \/\/ as the open profiles, but upload artifacts to a different location.\n-    common.main_profile_names.forEach(function (name) {\n-        var riName = name + \"-ri\";\n-        var riDebugName = riName + common.debug_suffix;\n-        var openName = name + common.open_suffix;\n-        var openDebugName = openName + common.debug_suffix;\n-        profiles[riName] = clone(profiles[openName]);\n-        profiles[riDebugName] = clone(profiles[openDebugName]);\n-        \/\/ Rewrite all remote dirs to \"bundles\/openjdk\/BCL\/...\"\n-        for (artifactName in profiles[riName].artifacts) {\n-            var artifact = profiles[riName].artifacts[artifactName];\n-            artifact.remote = replaceAll(\n-                \"\\\/GPL\\\/\", \"\/BCL\/\",\n-                (artifact.remote != null ? artifact.remote : artifact.local));\n-        }\n-    });\n-\n","filename":"make\/conf\/jib-profiles.js","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Google and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,5 @@\n-#ifndef LEAK_SANITIZER\n+#ifdef LEAK_SANITIZER\n+    \"leak_check_at_exit=0,\"\n+#else\n+    \/\/ ASan bundles LSan, however we only support LSan when it is explicitly requested during\n+    \/\/ configuration. Thus we disable it to match if it was not requested.\n@@ -56,1 +60,5 @@\n-    \"handle_segv=0\";\n+    \"print_suppressions=0,\"\n+    \"handle_segv=0,\"\n+    \/\/ See https:\/\/github.com\/google\/sanitizers\/issues\/1322. Hopefully this is resolved\n+    \/\/ at some point and we can remove this option.\n+    \"intercept_tls_get_addr=0\";\n","filename":"make\/data\/asan\/asan_default_options.c","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Google and\/or its affiliates. All rights reserved.\n","filename":"make\/data\/asan\/asan_default_options.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2023, Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef LEAK_SANITIZER\n+#error \"Build misconfigured, preprocessor macro LEAK_SANITIZER should be defined\"\n+#endif\n+\n+#ifndef __has_attribute\n+#define __has_attribute(x) 0\n+#endif\n+\n+#if (defined(__GNUC__) && !defined(__clang__)) || __has_attribute(visibility)\n+#define ATTRIBUTE_DEFAULT_VISIBILITY __attribute__((visibility(\"default\")))\n+#else\n+#define ATTRIBUTE_DEFAULT_VISIBILITY\n+#endif\n+\n+#if (defined(__GNUC__) && !defined(__clang__)) || __has_attribute(used)\n+#define ATTRIBUTE_USED __attribute__((used))\n+#else\n+#define ATTRIBUTE_USED\n+#endif\n+\n+\/\/ Override weak symbol exposed by LSan to override default options. This is called by LSan\n+\/\/ extremely early during library loading, before main is called.  We need to override the default\n+\/\/ options because LSan will perform leak checking at program exit. Unfortunately Hotspot does not\n+\/\/ shutdown cleanly at the moment and some leaks occur, we want to ignore these. Instead we\n+\/\/ explicitly perform leak checking early during JVM shutdown.\n+ATTRIBUTE_DEFAULT_VISIBILITY ATTRIBUTE_USED const char* __lsan_default_options() {\n+  return\n+    \"print_suppressions=0,\"\n+    \"leak_check_at_exit=0,\"\n+    \/\/ See https:\/\/github.com\/google\/sanitizers\/issues\/1322. Hopefully this is resolved\n+    \/\/ at some point and we can remove this option.\n+    \"intercept_tls_get_addr=0\";\n+}\n+\n+\/\/ Override weak symbol exposed by LSan to override default suppressions. This is called by LSan\n+\/\/ extremely early during library loading, before main is called.\n+ATTRIBUTE_DEFAULT_VISIBILITY ATTRIBUTE_USED const char* __lsan_default_suppressions() {\n+  return\n+    \/\/ Remove after JDK-8297688 is resolved.\n+    \"leak:^JLI_MemAlloc$\\n\"\n+    \"leak:^JLI_StringDup$\\n\";\n+}\n","filename":"make\/data\/lsan\/lsan_default_options.c","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Google and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \".\/asan_default_options.c\"\n+#include \".\/lsan_default_options.c\"\n","filename":"make\/data\/lsan\/lsan_default_options.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"make\/data\/asan\/asan_default_options.cpp","status":"copied"},{"patch":"@@ -35,0 +35,4 @@\n+ifeq ($(LSAN_ENABLED), true)\n+  GTEST_LAUNCHER_SRC += $(TOPDIR)\/make\/data\/lsan\/lsan_default_options.cpp\n+endif\n+\n","filename":"make\/hotspot\/lib\/CompileGtest.gmk","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1524,1 +1524,7 @@\n-  BUILD_HOTSPOT_JTREG_EXTRA_FILES := $(TOPDIR)\/make\/data\/asan\/asan_default_options.c\n+  BUILD_HOTSPOT_JTREG_EXTRA_FILES += $(TOPDIR)\/make\/data\/asan\/asan_default_options.c\n+endif\n+\n+ifeq ($(LSAN_ENABLED), true)\n+  # Any executable which launches the JVM and uses a custom launcher needs to explicitly link in the\n+  # default LSan options.\n+  BUILD_HOTSPOT_JTREG_EXTRA_FILES += $(TOPDIR)\/make\/data\/lsan\/lsan_default_options.c\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -138,1 +138,7 @@\n-  BUILD_JDK_JTREG_EXTRA_FILES := $(TOPDIR)\/make\/data\/asan\/asan_default_options.c\n+  BUILD_JDK_JTREG_EXTRA_FILES += $(TOPDIR)\/make\/data\/asan\/asan_default_options.c\n+endif\n+\n+ifeq ($(LSAN_ENABLED), true)\n+  # Any executable which launches the JVM and uses a custom launcher needs to explicitly link in the\n+  # default LSan options.\n+  BUILD_JDK_JTREG_EXTRA_FILES += $(TOPDIR)\/make\/data\/lsan\/lsan_default_options.c\n","filename":"make\/test\/JtregNativeJdk.gmk","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -14059,0 +14059,25 @@\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct bits_reverse_I(iRegINoSp dst, iRegIorL2I src)\n+%{\n+  match(Set dst (ReverseI src));\n+  ins_cost(INSN_COST);\n+  format %{ \"rbitw  $dst, $src\" %}\n+  ins_encode %{\n+    __ rbitw($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct bits_reverse_L(iRegLNoSp dst, iRegL src)\n+%{\n+  match(Set dst (ReverseL src));\n+  ins_cost(INSN_COST);\n+  format %{ \"rbit  $dst, $src\" %}\n+  ins_encode %{\n+    __ rbit($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -618,1 +618,16 @@\n-\n+dnl\n+define(`BITS_REVERSE', `\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct bits_reverse_$1(iReg$1NoSp dst, iReg$1`'ORL2I($1) src)\n+%{\n+  match(Set dst (Reverse$1 src));\n+  ins_cost(INSN_COST);\n+  format %{ \"$2  $dst, $src\" %}\n+  ins_encode %{\n+    __ $2($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+')dnl\n+BITS_REVERSE(I, rbitw)\n+BITS_REVERSE(L, rbit)\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_ad.m4","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -5692,0 +5692,12 @@\n+instruct vmask_gen_sub(pReg pd, iRegL src1, iRegL src2, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set pd (VectorMaskGen (SubL src1 src2)));\n+  effect(KILL cr);\n+  format %{ \"vmask_gen_sub $pd, $src2, $src1\\t# KILL cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_whilelo($pd$$PRegister, __ elemType_to_regVariant(bt), $src2$$Register, $src1$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -4075,0 +4075,12 @@\n+instruct vmask_gen_sub(pReg pd, iRegL src1, iRegL src2, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set pd (VectorMaskGen (SubL src1 src2)));\n+  effect(KILL cr);\n+  format %{ \"vmask_gen_sub $pd, $src2, $src1\\t# KILL cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_whilelo($pd$$PRegister, __ elemType_to_regVariant(bt), $src2$$Register, $src1$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-  ands(hdr, hdr, aligned_mask - os::vm_page_size());\n+  ands(hdr, hdr, aligned_mask - (int)os::vm_page_size());\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+#define __ masm.\n+\n@@ -52,1 +54,0 @@\n-  bool p_succeeded = true;\n@@ -54,10 +55,1 @@\n-    masm.set_code_section(cb->stubs());\n-    if (!is_aligned(masm.offset(), wordSize)) {\n-      if (cb->stubs()->maybe_expand_to_ensure_remaining(NativeInstruction::instruction_size) && cb->blob() == NULL) {\n-        ciEnv::current()->record_failure(\"CodeCache is full\");\n-        p_succeeded = false;\n-        return p_succeeded;\n-      }\n-      masm.align(wordSize);\n-    }\n-\n+    assert(cb->stubs()->remaining() >= MacroAssembler::max_trampoline_stub_size(), \"pre-allocated trampolines\");\n@@ -66,4 +58,2 @@\n-    for (; !it.is_empty(); offset = *it.next()) {\n-      masm.relocate(trampoline_stub_Relocation::spec(cb->insts()->start() + offset));\n-    }\n-    masm.set_code_section(cb->insts());\n+    address stub = __ emit_trampoline_stub(offset, dest);\n+    assert(stub, \"pre-allocated trampolines\");\n@@ -71,4 +61,5 @@\n-    address stub = masm.emit_trampoline_stub(offset, dest);\n-    if (stub == nullptr) {\n-      ciEnv::current()->record_failure(\"CodeCache is full\");\n-      p_succeeded = false;\n+    address reloc_pc = cb->stubs()->end() - NativeCallTrampolineStub::instruction_size;\n+    while (!it.is_empty()) {\n+      offset = *it.next();\n+      address caller_pc = cb->insts()->start() + offset;\n+      cb->stubs()->relocate(reloc_pc, trampoline_stub_Relocation::spec(caller_pc));\n@@ -76,2 +67,1 @@\n-\n-    return p_succeeded;\n+    return true;\n@@ -80,1 +70,6 @@\n-  requests->iterate(emit);\n+  assert(requests->number_of_entries() >= 1, \"at least one\");\n+  const int total_requested_size = MacroAssembler::max_trampoline_stub_size() * requests->number_of_entries();\n+  if (cb->stubs()->maybe_expand_to_ensure_remaining(total_requested_size) && cb->blob() == NULL) {\n+    ciEnv::current()->record_failure(\"CodeCache is full\");\n+    return false;\n+  }\n@@ -82,1 +77,2 @@\n-  return p_succeeded;\n+  requests->iterate(emit);\n+  return true;\n@@ -85,0 +81,2 @@\n+#undef __\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/codeBuffer_aarch64.cpp","additions":21,"deletions":23,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,2 +74,1 @@\n-  \/\/ isb; movk; movz; movz; movk; movz; movz; br\n-  return 8 * NativeInstruction::instruction_size;\n+  return MacroAssembler::static_call_stub_size();\n@@ -82,1 +81,1 @@\n-  return 3 * NativeInstruction::instruction_size + wordSize;\n+  return MacroAssembler::max_trampoline_stub_size();\n","filename":"src\/hotspot\/cpu\/aarch64\/compiledIC_aarch64.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -805,1 +805,1 @@\n-    ands(swap_reg, swap_reg, (uint64_t)(7 - os::vm_page_size()));\n+    ands(swap_reg, swap_reg, (uint64_t)(7 - (int)os::vm_page_size()));\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -929,2 +929,1 @@\n-  address stub = start_a_stub(NativeInstruction::instruction_size\n-                   + NativeCallTrampolineStub::instruction_size);\n+  address stub = start_a_stub(max_trampoline_stub_size());\n@@ -962,0 +961,5 @@\n+int MacroAssembler::max_trampoline_stub_size() {\n+  \/\/ Max stub size: alignment nop, TrampolineStub.\n+  return NativeInstruction::instruction_size + NativeCallTrampolineStub::instruction_size;\n+}\n+\n@@ -974,0 +978,5 @@\n+int MacroAssembler::static_call_stub_size() {\n+  \/\/ isb; movk; movz; movz; movk; movz; movz; br\n+  return 8 * NativeInstruction::instruction_size;\n+}\n+\n@@ -4571,1 +4580,1 @@\n-  mov(rscratch1, os::vm_page_size());\n+  mov(rscratch1, (int)os::vm_page_size());\n@@ -4573,1 +4582,1 @@\n-  lea(tmp, Address(tmp, -os::vm_page_size()));\n+  lea(tmp, Address(tmp, -(int)os::vm_page_size()));\n@@ -4584,1 +4593,1 @@\n-  for (int i = 0; i < (int)(StackOverflow::stack_shadow_zone_size() \/ os::vm_page_size()) - 1; i++) {\n+  for (int i = 0; i < (int)(StackOverflow::stack_shadow_zone_size() \/ (int)os::vm_page_size()) - 1; i++) {\n@@ -4587,1 +4596,1 @@\n-    lea(tmp, Address(tmp, -os::vm_page_size()));\n+    lea(tmp, Address(tmp, -(int)os::vm_page_size()));\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -641,0 +641,1 @@\n+  static int max_trampoline_stub_size();\n@@ -642,0 +643,1 @@\n+  static int static_call_stub_size();\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1801,1 +1801,1 @@\n-      __ ands(swap_reg, swap_reg, 3 - os::vm_page_size());\n+      __ ands(swap_reg, swap_reg, 3 - (int)os::vm_page_size());\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -658,1 +658,1 @@\n-  const int page_size = os::vm_page_size();\n+  const size_t page_size = os::vm_page_size();\n@@ -1066,1 +1066,1 @@\n-  const int page_size = os::vm_page_size();\n+  const int page_size = (int)os::vm_page_size();\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -973,1 +973,1 @@\n-  const int page_size = os::vm_page_size();\n+  const int page_size = (int)os::vm_page_size();\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -110,1 +110,1 @@\n-  const unsigned int page_size = os::vm_page_size();\n+  const size_t page_size = os::vm_page_size();\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/z\/zGlobals_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1165,2 +1165,2 @@\n-  const int page_size = os::vm_page_size();\n-  const int n_shadow_pages = ((int)StackOverflow::stack_shadow_zone_size()) \/ page_size;\n+  const size_t page_size = os::vm_page_size();\n+  const int n_shadow_pages = StackOverflow::stack_shadow_zone_size() \/ page_size;\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -270,1 +270,1 @@\n-    return base() == reg;\n+    return _mode != literal && base() == reg;\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -153,1 +153,1 @@\n-    __ mvw(t1, objArray_lh);\n+    __ mv(t1, objArray_lh);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_arraycopy_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -453,1 +453,1 @@\n-      __ mvw(dest->as_register(), c->as_jint());\n+      __ mv(dest->as_register(), c->as_jint());\n@@ -521,1 +521,1 @@\n-        __ mvw(t1, c->as_jint_bits());\n+        __ mv(t1, c->as_jint_bits());\n@@ -1004,1 +1004,1 @@\n-    __ mvw(t1, InstanceKlass::fully_initialized);\n+    __ mv(t1, InstanceKlass::fully_initialized);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,1 +99,1 @@\n-  mv(t0, aligned_mask - os::vm_page_size());\n+  mv(t0, aligned_mask - (int)os::vm_page_size());\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,0 +47,2 @@\n+#define __ masm.\n+\n@@ -54,1 +56,0 @@\n-  bool p_succeeded = true;\n@@ -56,10 +57,1 @@\n-    masm.set_code_section(cb->stubs());\n-    if (!is_aligned(masm.offset() + NativeCallTrampolineStub::data_offset, wordSize)) {\n-      if (cb->stubs()->maybe_expand_to_ensure_remaining(NativeInstruction::instruction_size) && cb->blob() == NULL) {\n-        ciEnv::current()->record_failure(\"CodeCache is full\");\n-        p_succeeded = false;\n-        return p_succeeded;\n-      }\n-      masm.align(wordSize, NativeCallTrampolineStub::data_offset);\n-    }\n-\n+    assert(cb->stubs()->remaining() >= MacroAssembler::max_trampoline_stub_size(), \"pre-allocated trampolines\");\n@@ -68,4 +60,2 @@\n-    for (; !it.is_empty(); offset = *it.next()) {\n-      masm.relocate(trampoline_stub_Relocation::spec(cb->insts()->start() + offset));\n-    }\n-    masm.set_code_section(cb->insts());\n+    address stub = __ emit_trampoline_stub(offset, dest);\n+    assert(stub, \"pre-allocated trampolines\");\n@@ -73,4 +63,5 @@\n-    address stub = masm.emit_trampoline_stub(offset, dest);\n-    if (stub == nullptr) {\n-      ciEnv::current()->record_failure(\"CodeCache is full\");\n-      p_succeeded = false;\n+    address reloc_pc = cb->stubs()->end() - NativeCallTrampolineStub::instruction_size;\n+    while (!it.is_empty()) {\n+      offset = *it.next();\n+      address caller_pc = cb->insts()->start() + offset;\n+      cb->stubs()->relocate(reloc_pc, trampoline_stub_Relocation::spec(caller_pc));\n@@ -78,2 +69,1 @@\n-\n-    return p_succeeded;\n+    return true;\n@@ -82,1 +72,6 @@\n-  requests->iterate(emit);\n+  assert(requests->number_of_entries() >= 1, \"at least one\");\n+  const int total_requested_size = MacroAssembler::max_trampoline_stub_size() * requests->number_of_entries();\n+  if (cb->stubs()->maybe_expand_to_ensure_remaining(total_requested_size) && cb->blob() == NULL) {\n+    ciEnv::current()->record_failure(\"CodeCache is full\");\n+    return false;\n+  }\n@@ -84,1 +79,2 @@\n-  return p_succeeded;\n+  requests->iterate(emit);\n+  return true;\n@@ -87,0 +83,2 @@\n+#undef __\n+\n","filename":"src\/hotspot\/cpu\/riscv\/codeBuffer_riscv.cpp","additions":21,"deletions":23,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,2 +72,1 @@\n-  \/\/ (lui, addi, slli, addi, slli, addi) + (lui, addi, slli, addi, slli) + jalr\n-  return 12 * NativeInstruction::instruction_size;\n+  return MacroAssembler::static_call_stub_size();\n@@ -80,1 +79,1 @@\n-  return NativeInstruction::instruction_size + NativeCallTrampolineStub::instruction_size;\n+  return MacroAssembler::max_trampoline_stub_size();\n","filename":"src\/hotspot\/cpu\/riscv\/compiledIC_riscv.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -149,1 +149,1 @@\n-  mvw(t0, (int) ilgl);\n+  mv(t0, (int)ilgl);\n@@ -834,1 +834,1 @@\n-    mv(t0, (int64_t)(7 - os::vm_page_size()));\n+    mv(t0, (int64_t)(7 - (int)os::vm_page_size()));\n@@ -1500,2 +1500,2 @@\n-    mvw(reg2, in_bytes(MultiBranchData::per_case_size()));\n-    mvw(t0, in_bytes(MultiBranchData::case_array_offset()));\n+    mv(reg2, in_bytes(MultiBranchData::per_case_size()));\n+    mv(t0, in_bytes(MultiBranchData::case_array_offset()));\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -212,0 +212,1 @@\n+    InlineSkippedInstructionsCounter skipCounter(this);\n@@ -1935,1 +1936,1 @@\n-  mv(t0, os::vm_page_size());\n+  mv(t0, (int)os::vm_page_size());\n@@ -1949,1 +1950,1 @@\n-  for (int i = 0; i < (int)(StackOverflow::stack_shadow_zone_size() \/ os::vm_page_size()) - 1; i++) {\n+  for (int i = 0; i < (int)(StackOverflow::stack_shadow_zone_size() \/ (int)os::vm_page_size()) - 1; i++) {\n@@ -1952,1 +1953,1 @@\n-    sub(tmp, tmp, os::vm_page_size());\n+    sub(tmp, tmp, (int)os::vm_page_size());\n@@ -2172,1 +2173,1 @@\n-void  MacroAssembler::decode_heap_oop_not_null(Register r) {\n+void MacroAssembler::decode_heap_oop_not_null(Register r) {\n@@ -3144,2 +3145,2 @@\n-  address stub = start_a_stub(NativeInstruction::instruction_size\n-                            + NativeCallTrampolineStub::instruction_size);\n+  \/\/ Max stub size: alignment nop, TrampolineStub.\n+  address stub = start_a_stub(max_trampoline_stub_size());\n@@ -3185,0 +3186,10 @@\n+int MacroAssembler::max_trampoline_stub_size() {\n+  \/\/ Max stub size: alignment nop, TrampolineStub.\n+  return NativeInstruction::instruction_size + NativeCallTrampolineStub::instruction_size;\n+}\n+\n+int MacroAssembler::static_call_stub_size() {\n+  \/\/ (lui, addi, slli, addi, slli, addi) + (lui, addi, slli, addi, slli) + jalr\n+  return 12 * NativeInstruction::instruction_size;\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -415,0 +415,1 @@\n+  static int max_trampoline_stub_size();\n@@ -416,0 +417,1 @@\n+  static int static_call_stub_size();\n@@ -692,1 +694,1 @@\n-  void li(Register Rd, int64_t imm);  \/\/ optimized load immediate\n+  void li  (Register Rd, int64_t imm);  \/\/ optimized load immediate\n@@ -706,2 +708,0 @@\n-  inline void mvw(Register Rd, int32_t imm32)         { mv(Rd, imm32); }\n-\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -947,2 +947,2 @@\n-  int_def FMUL_SINGLE_COST     (  500,  5 * DEFAULT_COST);          \/\/ fadd, fmul, fmadd\n-  int_def FMUL_DOUBLE_COST     (  700,  7 * DEFAULT_COST);          \/\/ fadd, fmul, fmadd\n+  int_def FMUL_SINGLE_COST     (  500,  5 * DEFAULT_COST);          \/\/ fmul, fmadd\n+  int_def FMUL_DOUBLE_COST     (  700,  7 * DEFAULT_COST);          \/\/ fmul, fmadd\n@@ -3901,3 +3901,3 @@\n-\/\/ (actually a mvw $dst $src) and the downstream instructions consume\n-\/\/ the result of the l2i as an iRegI input. That's a shame since the\n-\/\/ mvw is actually redundant but its not too costly.\n+\/\/ (actually an addiw $dst, $src, 0) and the downstream instructions\n+\/\/ consume the result of the L2I as an iRegI input. That's a shame since\n+\/\/ the addiw is actually redundant but its not too costly.\n@@ -6993,1 +6993,1 @@\n-  ins_pipe(ialu_reg);\n+  ins_pipe(ialu_reg_imm);\n@@ -7005,1 +7005,1 @@\n-  ins_pipe(ialu_reg);\n+  ins_pipe(ialu_reg_imm);\n@@ -7015,1 +7015,1 @@\n-  ins_cost(FMUL_SINGLE_COST);\n+  ins_cost(DEFAULT_COST * 5);\n@@ -7030,1 +7030,1 @@\n-  ins_cost(FMUL_DOUBLE_COST);\n+  ins_cost(DEFAULT_COST * 5);\n@@ -7045,1 +7045,1 @@\n-  ins_cost(FMUL_SINGLE_COST);\n+  ins_cost(DEFAULT_COST * 5);\n@@ -7060,1 +7060,1 @@\n-  ins_cost(FMUL_DOUBLE_COST);\n+  ins_cost(DEFAULT_COST * 5);\n@@ -7263,1 +7263,1 @@\n-  ins_pipe(fp_dop_reg_reg_s);\n+  ins_pipe(pipe_class_default);\n@@ -7279,1 +7279,1 @@\n-  ins_pipe(fp_dop_reg_reg_s);\n+  ins_pipe(pipe_class_default);\n@@ -7295,1 +7295,1 @@\n-  ins_pipe(fp_dop_reg_reg_d);\n+  ins_pipe(pipe_class_default);\n@@ -7311,1 +7311,1 @@\n-  ins_pipe(fp_dop_reg_reg_d);\n+  ins_pipe(pipe_class_default);\n@@ -7315,1 +7315,1 @@\n-instruct isIniniteF_reg_reg(iRegINoSp dst, fRegF src)\n+instruct isInfiniteF_reg_reg(iRegINoSp dst, fRegF src)\n@@ -7318,0 +7318,1 @@\n+\n@@ -7321,1 +7322,1 @@\n-    __ andi(as_Register($dst$$reg), as_Register($dst$$reg), 0b10000001);\n+    __ andi(as_Register($dst$$reg), as_Register($dst$$reg), 0b0010000001);\n@@ -7324,1 +7325,2 @@\n-  ins_pipe(fp_dop_reg_reg_s);\n+\n+  ins_pipe(pipe_class_default);\n@@ -7331,0 +7333,1 @@\n+\n@@ -7334,1 +7337,1 @@\n-    __ andi(as_Register($dst$$reg), as_Register($dst$$reg), 0b10000001);\n+    __ andi(as_Register($dst$$reg), as_Register($dst$$reg), 0b0010000001);\n@@ -7337,1 +7340,2 @@\n-  ins_pipe(fp_dop_reg_reg_d);\n+\n+  ins_pipe(pipe_class_default);\n@@ -7344,0 +7348,1 @@\n+\n@@ -7350,1 +7355,2 @@\n-  ins_pipe(fp_dop_reg_reg_s);\n+\n+  ins_pipe(pipe_class_default);\n@@ -7357,0 +7363,1 @@\n+\n@@ -7363,1 +7370,2 @@\n-  ins_pipe(fp_dop_reg_reg_d);\n+\n+  ins_pipe(pipe_class_default);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":30,"deletions":22,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -433,1 +433,1 @@\n-        if ( sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {\n+        if (sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {\n@@ -889,1 +889,1 @@\n-  __ mvw(t0, ContinuationEntry::cookie_value());\n+  __ mv(t0, ContinuationEntry::cookie_value());\n@@ -1695,1 +1695,1 @@\n-      __ andi(swap_reg, swap_reg, 3 - os::vm_page_size());\n+      __ andi(swap_reg, swap_reg, 3 - (int)os::vm_page_size());\n@@ -2102,1 +2102,1 @@\n-  __ mvw(xcpool, Deoptimization::Unpack_deopt); \/\/ callee-saved\n+  __ mv(xcpool, Deoptimization::Unpack_deopt); \/\/ callee-saved\n@@ -2119,1 +2119,1 @@\n-  __ mvw(xcpool, Deoptimization::Unpack_reexecute); \/\/ callee-saved\n+  __ mv(xcpool, Deoptimization::Unpack_reexecute); \/\/ callee-saved\n@@ -2142,1 +2142,1 @@\n-    __ mvw(t0, -1);\n+    __ mv(t0, -1);\n@@ -2145,1 +2145,1 @@\n-    __ mvw(xcpool, (int32_t)Deoptimization::Unpack_reexecute);\n+    __ mv(xcpool, (int32_t)Deoptimization::Unpack_reexecute);\n@@ -2486,1 +2486,1 @@\n-  __ mvw(c_rarg2, (unsigned)Deoptimization::Unpack_uncommon_trap);\n+  __ mv(c_rarg2, (unsigned)Deoptimization::Unpack_uncommon_trap);\n@@ -2512,1 +2512,1 @@\n-    __ mvw(t1, Deoptimization::Unpack_uncommon_trap);\n+    __ mv(t1, Deoptimization::Unpack_uncommon_trap);\n@@ -2613,1 +2613,1 @@\n-  __ mvw(c_rarg1, (unsigned)Deoptimization::Unpack_uncommon_trap);\n+  __ mv(c_rarg1, (unsigned)Deoptimization::Unpack_uncommon_trap);\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1852,1 +1852,1 @@\n-    __ mvw(t0, objArray_lh);\n+    __ mv(t0, objArray_lh);\n@@ -1869,1 +1869,1 @@\n-      __ mvw(t1, Klass::_lh_array_tag_type_value << Klass::_lh_array_tag_shift);\n+      __ mv(t1, Klass::_lh_array_tag_type_value << Klass::_lh_array_tag_shift);\n@@ -1942,1 +1942,1 @@\n-      __ mvw(t0, LogBytesPerLong);\n+      __ mv(t0, LogBytesPerLong);\n@@ -1980,1 +1980,1 @@\n-      __ mvw(t1, objArray_lh);\n+      __ mv(t1, objArray_lh);\n@@ -3858,1 +3858,1 @@\n-    __ mvw(c_rarg1, (return_barrier ? 1 : 0));\n+    __ mv(c_rarg1, (return_barrier ? 1 : 0));\n@@ -3898,1 +3898,1 @@\n-    __ mvw(c_rarg1, (uint32_t)kind);\n+    __ mv(c_rarg1, (uint32_t)kind);\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -605,1 +605,1 @@\n-  const int page_size = os::vm_page_size();\n+  const int page_size = (int)os::vm_page_size();\n@@ -892,1 +892,1 @@\n-  const int page_size = os::vm_page_size();\n+  const int page_size = (int)os::vm_page_size();\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-    __ mvw(t1, vtable_index * vtableEntry::size());\n+    __ mv(t1, vtable_index * vtableEntry::size());\n","filename":"src\/hotspot\/cpu\/riscv\/vtableStubs_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2624,1 +2624,0 @@\n-  {\n@@ -2639,2 +2638,2 @@\n-  int offs = __ offset();\n-  oop_maps->add_gc_map(offs, map);\n+  int oop_map_offs = __ offset();\n+  oop_maps->add_gc_map(oop_map_offs, map);\n@@ -2682,1 +2681,0 @@\n-  }\n@@ -2695,1 +2693,1 @@\n-  __ get_PC(Z_RET);\n+  __ get_PC(Z_RET, oop_map_offs - __ offset());\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -790,1 +790,1 @@\n-  const int page_size = os::vm_page_size();\n+  const int page_size = (int)os::vm_page_size();\n@@ -2023,1 +2023,1 @@\n-  const int page_size      = os::vm_page_size();\n+  const size_t page_size      = os::vm_page_size();\n","filename":"src\/hotspot\/cpu\/s390\/templateInterpreterGenerator_s390.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2016, 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n@@ -85,2 +85,2 @@\n-                                   \"system-z, g8-z14, ldisp_fast, extimm, pcrel_load\/store, cmpb, cond_load\/store, interlocked_update, txm, vectorinstr, instrext2, venh1)\",\n-                                   \"system-z, g9-z15, ldisp_fast, extimm, pcrel_load\/store, cmpb, cond_load\/store, interlocked_update, txm, vectorinstr, instrext2, venh1, instrext3, VEnh2 )\"\n+                                   \"system-z, g8-z14, ldisp_fast, extimm, pcrel_load\/store, cmpb, cond_load\/store, interlocked_update, txm, vectorinstr, instrext2, venh1\",\n+                                   \"system-z, g9-z15, ldisp_fast, extimm, pcrel_load\/store, cmpb, cond_load\/store, interlocked_update, txm, vectorinstr, instrext2, venh1, instrext3, venh2\"\n@@ -377,1 +377,1 @@\n-    jio_snprintf(buf, sizeof(buf), \"%s, out-of-support_as_of_\", z_features[model_ix], z_EOS[model_ix]);\n+    jio_snprintf(buf, sizeof(buf), \"%s, out-of-support_as_of_%s\", z_features[model_ix], z_EOS[model_ix]);\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,1 +90,1 @@\n-  andptr(hdr, aligned_mask - os::vm_page_size());\n+  andptr(hdr, aligned_mask - (int)os::vm_page_size());\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -616,1 +616,1 @@\n-    andptr(tmpReg, (int32_t) (NOT_LP64(0xFFFFF003) LP64_ONLY(7 - os::vm_page_size())) );\n+    andptr(tmpReg, (int32_t) (NOT_LP64(0xFFFFF003) LP64_ONLY(7 - (int)os::vm_page_size())) );\n@@ -2787,2 +2787,2 @@\n-      andl(result, (os::vm_page_size()-1));\n-      cmpl(result, (os::vm_page_size()-16));\n+      andl(result, ((int)os::vm_page_size()-1));\n+      cmpl(result, ((int)os::vm_page_size()-16));\n@@ -2817,2 +2817,2 @@\n-    andl(result, (os::vm_page_size()-1));\n-    cmpl(result, (os::vm_page_size()-16));\n+    andl(result, ((int)os::vm_page_size()-1));\n+    cmpl(result, ((int)os::vm_page_size()-16));\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1272,1 +1272,1 @@\n-    andptr(swap_reg, zero_bits - os::vm_page_size());\n+    andptr(swap_reg, zero_bits - (int)os::vm_page_size());\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1276,3 +1276,3 @@\n-  movl(Address(tmp, (-os::vm_page_size())), size );\n-  subptr(tmp, os::vm_page_size());\n-  subl(size, os::vm_page_size());\n+  movl(Address(tmp, (-(int)os::vm_page_size())), size );\n+  subptr(tmp, (int)os::vm_page_size());\n+  subl(size, (int)os::vm_page_size());\n@@ -1287,1 +1287,1 @@\n-  for (int i = 1; i < ((int)StackOverflow::stack_shadow_zone_size() \/ os::vm_page_size()); i++) {\n+  for (int i = 1; i < ((int)StackOverflow::stack_shadow_zone_size() \/ (int)os::vm_page_size()); i++) {\n@@ -1290,1 +1290,1 @@\n-    movptr(Address(tmp, (-i*os::vm_page_size())), size );\n+    movptr(Address(tmp, (-i*(int)os::vm_page_size())), size );\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1705,1 +1705,1 @@\n-      __ andptr(swap_reg, 3 - os::vm_page_size());\n+      __ andptr(swap_reg, 3 - (int)os::vm_page_size());\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2175,1 +2175,1 @@\n-      __ andptr(swap_reg, 3 - os::vm_page_size());\n+      __ andptr(swap_reg, 3 - (int)os::vm_page_size());\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Intel Corporation. All rights reserved.\n+ * Copyright (c) 2022, 2023, Intel Corporation. All rights reserved.\n@@ -40,4 +40,4 @@\n-\/\/    ( a×2^130 + b ) mod 2^130-5     \/\/i.e. number split along the 130-bit boundary\n-\/\/                                 = ( a×2^130 - 5×a + 5×a + b ) mod 2^130-5\n-\/\/                                 = ( a×(2^130 - 5) + 5×a + b ) mod 2^130-5 \/\/ i.e. adding multiples of modulus is a noop\n-\/\/                                 = ( 5×a + b ) mod 2^130-5\n+\/\/    ( ax2^130 + b ) mod 2^130-5     \/\/i.e. number split along the 130-bit boundary\n+\/\/                                 = ( ax2^130 - 5xa + 5xa + b ) mod 2^130-5\n+\/\/                                 = ( ax(2^130 - 5) + 5xa + b ) mod 2^130-5 \/\/ i.e. adding multiples of modulus is a noop\n+\/\/                                 = ( 5xa + b ) mod 2^130-5\n@@ -50,3 +50,3 @@\n-\/\/    × used for poly1305_multiply8_avx512\n-\/\/    lower-case variables are scalar numbers in 3×44-bit limbs (in gprs)\n-\/\/    upper-case variables are 8-element vector numbers in 3×44-bit limbs (in zmm registers)\n+\/\/    x used for poly1305_multiply8_avx512\n+\/\/    lower-case variables are scalar numbers in 3x44-bit limbs (in gprs)\n+\/\/    upper-case variables are 8-element vector numbers in 3x44-bit limbs (in zmm registers)\n@@ -87,1 +87,1 @@\n-\/\/ i.e. For each block, compute [a2 a1 a0] = [a2 a1 a0] × [r2 r1 r0]\n+\/\/ i.e. For each block, compute [a2 a1 a0] = [a2 a1 a0] x [r2 r1 r0]\n@@ -92,1 +92,1 @@\n-\/\/ ×    r2       r1       r0\n+\/\/ x    r2       r1       r0\n@@ -94,3 +94,3 @@\n-\/\/     a2×r0    a1×r0    a0×r0\n-\/\/ +   a1×r1    a0×r1  5×a2×r1'     (r1' = r1<<2)\n-\/\/ +   a0×r2  5×a2×r2' 5×a1×r2'     (r2' = r2<<2)\n+\/\/     a2xr0    a1xr0    a0xr0\n+\/\/ +   a1xr1    a0xr1  5xa2xr1'     (r1' = r1<<2)\n+\/\/ +   a0xr2  5xa2xr2' 5xa1xr2'     (r2' = r2<<2)\n@@ -104,5 +104,5 @@\n-\/\/    ( p2×2^88 ) mod 2^130-5\n-\/\/                             = ( p2'×2^88 + p2''×2^130) mod 2^130-5 \/\/ Split on 130-bit boudary\n-\/\/                             = ( p2'×2^88 + p2''×2^130 - 5×p2'' + 5×p2'') mod 2^130-5\n-\/\/                             = ( p2'×2^88 + p2''×(2^130 - 5) + 5×p2'') mod 2^130-5 \/\/ i.e. adding multiples of modulus is a noop\n-\/\/                             = ( p2'×2^88 + 5×p2'') mod 2^130-5\n+\/\/    ( p2x2^88 ) mod 2^130-5\n+\/\/                             = ( p2'x2^88 + p2''x2^130) mod 2^130-5 \/\/ Split on 130-bit boudary\n+\/\/                             = ( p2'x2^88 + p2''x2^130 - 5xp2'' + 5xp2'') mod 2^130-5\n+\/\/                             = ( p2'x2^88 + p2''x(2^130 - 5) + 5xp2'') mod 2^130-5 \/\/ i.e. adding multiples of modulus is a noop\n+\/\/                             = ( p2'x2^88 + 5xp2'') mod 2^130-5\n@@ -112,10 +112,10 @@\n-\/\/ For example, partial product (a2×r2):\n-\/\/    (a2×2^88)×(r2×2^88) mod 2^130-5\n-\/\/                                    = (a2×r2 × 2^176) mod 2^130-5\n-\/\/                                    = (a2×r2 × 2^46×2^130) mod 2^130-5\n-\/\/                                    = (a2×r2×2^46 × 2^130- 5×a2×r2×2^46 + 5×a2×r2×2^46) mod 2^130-5\n-\/\/                                    = (a2×r2×2^46 × (2^130- 5) + 5×a2×r2×2^46) mod 2^130-5 \/\/ i.e. adding multiples of modulus is a noop\n-\/\/                                    = (5×a2×r2×2^46) mod 2^130-5\n-\/\/                                    = (a2×5×r2×2^2 × 2^44) mod 2^130-5 \/\/ Align to limb boudary\n-\/\/                                    = (a2×[5×r2×4] × 2^44) mod 2^130-5\n-\/\/                                    = (a2×R2P × 2^44) mod 2^130-5 \/\/ i.e. R2P = 4*5*R2\n+\/\/ For example, partial product (a2xr2):\n+\/\/    (a2x2^88)x(r2x2^88) mod 2^130-5\n+\/\/                                    = (a2xr2 x 2^176) mod 2^130-5\n+\/\/                                    = (a2xr2 x 2^46x2^130) mod 2^130-5\n+\/\/                                    = (a2xr2x2^46 x 2^130- 5xa2xr2x2^46 + 5xa2xr2x2^46) mod 2^130-5\n+\/\/                                    = (a2xr2x2^46 x (2^130- 5) + 5xa2xr2x2^46) mod 2^130-5 \/\/ i.e. adding multiples of modulus is a noop\n+\/\/                                    = (5xa2xr2x2^46) mod 2^130-5\n+\/\/                                    = (a2x5xr2x2^2 x 2^44) mod 2^130-5 \/\/ Align to limb boudary\n+\/\/                                    = (a2x[5xr2x4] x 2^44) mod 2^130-5\n+\/\/                                    = (a2xR2P x 2^44) mod 2^130-5 \/\/ i.e. R2P = 4*5*R2\n@@ -139,3 +139,3 @@\n-  \/\/ p0 = a2×r1'\n-  \/\/ p1 = a2×r2'\n-  \/\/ p2 = a2×r0\n+  \/\/ p0 = a2xr1'\n+  \/\/ p1 = a2xr2'\n+  \/\/ p2 = a2xr0\n@@ -149,3 +149,3 @@\n-  \/\/ p0 += a0×r0\n-  \/\/ p1 += a0×r1\n-  \/\/ p2 += a0×r2\n+  \/\/ p0 += a0xr0\n+  \/\/ p1 += a0xr1\n+  \/\/ p2 += a0xr2\n@@ -159,3 +159,3 @@\n-  \/\/ p0 += a1×r2'\n-  \/\/ p1 += a1×r0\n-  \/\/ p2 += a1×r1\n+  \/\/ p0 += a1xr2'\n+  \/\/ p1 += a1xr0\n+  \/\/ p2 += a1xr1\n@@ -171,2 +171,2 @@\n-  \/\/         P2L   P1L   P0L                     |                 P2L×2^88 + P1L×2^44 + P0L×2^0\n-  \/\/ + P2H   P1H   P0H                           |   + P2H×2^140 + P1H×2^96 + P0H×2^52\n+  \/\/         P2L   P1L   P0L                     |                 P2Lx2^88 + P1Lx2^44 + P0Lx2^0\n+  \/\/ + P2H   P1H   P0H                           |   + P2Hx2^140 + P1Hx2^96 + P0Hx2^52\n@@ -174,1 +174,1 @@\n-  \/\/ = P2H    A2    A1    A0                     |   = P2H×2^130 + A2×2^88 +   A1×2^44 +  A0×2^0\n+  \/\/ = P2H    A2    A1    A0                     |   = P2Hx2^130 + A2x2^88 +   A1x2^44 +  A0x2^0\n@@ -217,2 +217,2 @@\n-\/\/       a2×r0     a1×r0     a0×r0\n-\/\/   +             a0×r1\n+\/\/       a2xr0     a1xr0     a0xr0\n+\/\/   +             a0xr1\n@@ -350,1 +350,1 @@\n- * Copy 5×26-bit (unreduced) limbs stored at Register limbs into  a2:a1:a0 (3×64-bit limbs)\n+ * Copy 5x26-bit (unreduced) limbs stored at Register limbs into  a2:a1:a0 (3x64-bit limbs)\n@@ -396,1 +396,1 @@\n- * Break 3×64-bit a2:a1:a0 limbs into 5×26-bit limbs and store out into 5 quadwords at address `limbs`\n+ * Break 3x64-bit a2:a1:a0 limbs into 5x26-bit limbs and store out into 5 quadwords at address `limbs`\n@@ -477,3 +477,3 @@\n-\/\/  × used for poly1305_multiply8_avx512\n-\/\/  lower-case variables are scalar numbers in 3×44-bit limbs (in gprs)\n-\/\/  upper-case variables are 8&16-element vector numbers in 3×44-bit limbs (in zmm registers)\n+\/\/  x used for poly1305_multiply8_avx512\n+\/\/  lower-case variables are scalar numbers in 3x44-bit limbs (in gprs)\n+\/\/  upper-case variables are 8&16-element vector numbers in 3x44-bit limbs (in zmm registers)\n@@ -499,1 +499,1 @@\n-\/\/    B  = B×R                \/\/ [r^8  0  r^7  0  r^6  0  r^5  0 ]\n+\/\/    B  = BxR                \/\/ [r^8  0  r^7  0  r^6  0  r^5  0 ]\n@@ -503,1 +503,1 @@\n-\/\/    B  = B × R              \/\/ [r^16 r^12 r^15 r^11 r^14 r^10 r^13 r^9]\n+\/\/    B  = B x R              \/\/ [r^16 r^12 r^15 r^11 r^14 r^10 r^13 r^9]\n@@ -510,2 +510,2 @@\n-\/\/     AL = AL × R\n-\/\/     AH = AH × R\n+\/\/     AL = AL x R\n+\/\/     AH = AH x R\n@@ -515,2 +515,2 @@\n-\/\/  AL = AL × CL\n-\/\/  AH = AH × CH\n+\/\/  AL = AL x CL\n+\/\/  AH = AH x CH\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_poly.cpp","additions":53,"deletions":53,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -483,1 +483,1 @@\n-  const int page_size = os::vm_page_size();\n+  const int page_size = (int)os::vm_page_size();\n@@ -735,1 +735,1 @@\n-  const int page_size = os::vm_page_size();\n+  const int page_size = (int)os::vm_page_size();\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -155,1 +155,4 @@\n-  __ store_heap_oop(dst, val, rdx, rbx, LP64_ONLY(r8) NOT_LP64(rsi), decorators);\n+  __ store_heap_oop(dst, val,\n+                    NOT_LP64(rdx) LP64_ONLY(rscratch2),\n+                    NOT_LP64(rbx) LP64_ONLY(r9),\n+                    NOT_LP64(rsi) LP64_ONLY(r8), decorators);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1775,1 +1775,1 @@\n-    \"addr \" PTR_FORMAT \" not aligned to vm_page_size (\" PTR_FORMAT \")\",\n+    \"addr \" PTR_FORMAT \" not aligned to vm_page_size (\" SIZE_FORMAT \")\",\n@@ -1778,1 +1778,1 @@\n-    \"size \" PTR_FORMAT \" not aligned to vm_page_size (\" PTR_FORMAT \")\",\n+    \"size \" PTR_FORMAT \" not aligned to vm_page_size (\" SIZE_FORMAT \")\",\n@@ -1810,1 +1810,1 @@\n-    \"addr \" PTR_FORMAT \" not aligned to vm_page_size (\" PTR_FORMAT \")\",\n+    \"addr \" PTR_FORMAT \" not aligned to vm_page_size (\" SIZE_FORMAT \")\",\n@@ -1813,1 +1813,1 @@\n-    \"size \" PTR_FORMAT \" not aligned to vm_page_size (\" PTR_FORMAT \")\",\n+    \"size \" PTR_FORMAT \" not aligned to vm_page_size (\" SIZE_FORMAT \")\",\n@@ -2218,1 +2218,1 @@\n-static void set_page_size(int page_size) {\n+static void set_page_size(size_t page_size) {\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n-    if (path == NULL) {\n+    if (path == nullptr) {\n@@ -148,1 +148,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -173,1 +173,1 @@\n-      BsdAttachListener::set_path(NULL);\n+      BsdAttachListener::set_path(nullptr);\n@@ -278,1 +278,1 @@\n-      return NULL;      \/\/ reset by peer or other error\n+      return nullptr;      \/\/ reset by peer or other error\n@@ -296,1 +296,1 @@\n-            return NULL;\n+            return nullptr;\n@@ -306,1 +306,1 @@\n-    return NULL;        \/\/ incomplete request\n+    return nullptr;        \/\/ incomplete request\n@@ -317,2 +317,2 @@\n-  if (name == NULL || strlen(name) > AttachOperation::name_length_max) {\n-    return NULL;\n+  if (name == nullptr || strlen(name) > AttachOperation::name_length_max) {\n+    return nullptr;\n@@ -325,2 +325,2 @@\n-    if (arg == NULL) {\n-      op->set_arg(i, NULL);\n+    if (arg == nullptr) {\n+      op->set_arg(i, nullptr);\n@@ -330,1 +330,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -355,1 +355,1 @@\n-      return NULL;      \/\/ log a warning?\n+      return nullptr;      \/\/ log a warning?\n@@ -376,1 +376,1 @@\n-    if (op == NULL) {\n+    if (op == nullptr) {\n@@ -546,1 +546,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/os\/bsd\/attachListener_bsd.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-  if ((result = abi::__cxa_demangle(symbol, NULL, NULL, &status)) != NULL) {\n+  if ((result = abi::__cxa_demangle(symbol, nullptr, nullptr, &status)) != nullptr) {\n@@ -63,1 +63,1 @@\n-  if (symt == NULL) {\n+  if (symt == nullptr) {\n@@ -127,1 +127,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -133,1 +133,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -143,1 +143,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -149,1 +149,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -167,1 +167,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/os\/bsd\/decoder_machO.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-  assert(this != NULL, \"check\");\n@@ -37,1 +36,1 @@\n-  _thread_id        = NULL;\n+  _thread_id        = nullptr;\n@@ -40,3 +39,3 @@\n-  _pthread_id       = NULL;\n-  _siginfo          = NULL;\n-  _ucontext         = NULL;\n+  _pthread_id       = nullptr;\n+  _siginfo          = nullptr;\n+  _ucontext         = nullptr;\n@@ -44,1 +43,1 @@\n-  _alt_sig_stack    = NULL;\n+  _alt_sig_stack    = nullptr;\n@@ -49,1 +48,1 @@\n-  assert(_startThread_lock !=NULL, \"check\");\n+  assert(_startThread_lock !=nullptr, \"check\");\n","filename":"src\/hotspot\/os\/bsd\/osThread_bsd.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-  if (sysctl(mib, 2, &boottime, &len, NULL, 0) >= 0) {\n+  if (sysctl(mib, 2, &boottime, &len, nullptr, 0) >= 0) {\n@@ -169,1 +169,1 @@\n-    time_t currsec = time(NULL);\n+    time_t currsec = time(nullptr);\n@@ -215,1 +215,1 @@\n-  if (sysctl(mib, 2, &cpu_val, &len, NULL, 0) != -1 && cpu_val >= 1) {\n+  if (sysctl(mib, 2, &cpu_val, &len, nullptr, 0) != -1 && cpu_val >= 1) {\n@@ -244,1 +244,1 @@\n-  if (sysctl(mib, 2, &mem_val, &len, NULL, 0) != -1) {\n+  if (sysctl(mib, 2, &mem_val, &len, nullptr, 0) != -1) {\n@@ -265,1 +265,1 @@\n-  if ((home_dir == NULL) || (*home_dir == '\\0')) {\n+  if ((home_dir == nullptr) || (*home_dir == '\\0')) {\n@@ -267,1 +267,1 @@\n-    if (passwd_info != NULL) {\n+    if (passwd_info != nullptr) {\n@@ -340,1 +340,1 @@\n-    if (pslash != NULL) {\n+    if (pslash != nullptr) {\n@@ -345,1 +345,1 @@\n-    if (pslash != NULL) {\n+    if (pslash != nullptr) {\n@@ -347,1 +347,1 @@\n-      if (pslash != NULL) {\n+      if (pslash != nullptr) {\n@@ -350,1 +350,1 @@\n-        if (pslash != NULL) {\n+        if (pslash != nullptr) {\n@@ -357,1 +357,1 @@\n-      vm_exit_during_initialization(\"Failed setting boot class path.\", NULL);\n+      vm_exit_during_initialization(\"Failed setting boot class path.\", nullptr);\n@@ -377,1 +377,1 @@\n-    if (v == NULL) { v = \"\"; v_colon = \"\"; }\n+    if (v == nullptr) { v = \"\"; v_colon = \"\"; }\n@@ -420,1 +420,1 @@\n-    if (pslash != NULL) {\n+    if (pslash != nullptr) {\n@@ -429,1 +429,1 @@\n-    if (pslash != NULL) {\n+    if (pslash != nullptr) {\n@@ -431,1 +431,1 @@\n-      if (pslash != NULL) {\n+      if (pslash != nullptr) {\n@@ -437,1 +437,1 @@\n-        vm_exit_during_initialization(\"Failed setting boot class path.\", NULL);\n+        vm_exit_during_initialization(\"Failed setting boot class path.\", nullptr);\n@@ -459,1 +459,1 @@\n-    if (l == NULL) { l = \"\"; l_colon = \"\"; }\n+    if (l == nullptr) { l = \"\"; l_colon = \"\"; }\n@@ -463,1 +463,1 @@\n-    if (v == NULL) { v = \"\"; v_colon = \"\"; }\n+    if (v == nullptr) { v = \"\"; v_colon = \"\"; }\n@@ -522,1 +522,1 @@\n-objc_registerThreadWithCollector_t objc_registerThreadWithCollectorFunction = NULL;\n+objc_registerThreadWithCollector_t objc_registerThreadWithCollectorFunction = nullptr;\n@@ -549,1 +549,1 @@\n-  if (objc_registerThreadWithCollectorFunction != NULL) {\n+  if (objc_registerThreadWithCollectorFunction != nullptr) {\n@@ -576,1 +576,1 @@\n-  thread = NULL;\n+  thread = nullptr;\n@@ -586,1 +586,1 @@\n-  assert(thread->osthread() == NULL, \"caller responsible\");\n+  assert(thread->osthread() == nullptr, \"caller responsible\");\n@@ -590,1 +590,1 @@\n-  if (osthread == NULL) {\n+  if (osthread == nullptr) {\n@@ -642,1 +642,1 @@\n-      thread->set_osthread(NULL);\n+      thread->set_osthread(nullptr);\n@@ -684,1 +684,1 @@\n-  if (osthread == NULL) {\n+  if (osthread == nullptr) {\n@@ -727,1 +727,1 @@\n-  assert(osthread != NULL, \"osthread not set\");\n+  assert(osthread != nullptr, \"osthread not set\");\n@@ -736,1 +736,1 @@\n-  pthread_sigmask(SIG_SETMASK, &sigmask, NULL);\n+  pthread_sigmask(SIG_SETMASK, &sigmask, nullptr);\n@@ -853,2 +853,2 @@\n-  static char *temp_path = NULL;\n-  if (temp_path == NULL) {\n+  static char *temp_path = nullptr;\n+  if (temp_path == nullptr) {\n@@ -872,1 +872,1 @@\n-  if (libjvm_base_addr == NULL) {\n+  if (libjvm_base_addr == nullptr) {\n@@ -876,1 +876,1 @@\n-    assert(libjvm_base_addr !=NULL, \"Cannot obtain base address for libjvm\");\n+    assert(libjvm_base_addr !=nullptr, \"Cannot obtain base address for libjvm\");\n@@ -890,1 +890,1 @@\n-  assert(buf != NULL, \"sanity check\");\n+  assert(buf != nullptr, \"sanity check\");\n@@ -896,1 +896,1 @@\n-    if (dlinfo.dli_saddr != NULL && dlinfo.dli_sname != NULL) {\n+    if (dlinfo.dli_saddr != nullptr && dlinfo.dli_sname != nullptr) {\n@@ -900,1 +900,1 @@\n-      if (offset != NULL) *offset = addr - (address)dlinfo.dli_saddr;\n+      if (offset != nullptr) *offset = addr - (address)dlinfo.dli_saddr;\n@@ -912,1 +912,1 @@\n-    if (dlinfo.dli_fname != NULL && dlinfo.dli_fbase != NULL) {\n+    if (dlinfo.dli_fname != nullptr && dlinfo.dli_fbase != nullptr) {\n@@ -924,1 +924,1 @@\n-    if (dlinfo.dli_fbase != NULL &&\n+    if (dlinfo.dli_fbase != nullptr &&\n@@ -937,1 +937,1 @@\n-  if (offset != NULL) *offset = -1;\n+  if (offset != nullptr) *offset = -1;\n@@ -944,1 +944,1 @@\n-  assert(buf != NULL, \"sanity check\");\n+  assert(buf != nullptr, \"sanity check\");\n@@ -949,1 +949,1 @@\n-    if (dlinfo.dli_fname != NULL) {\n+    if (dlinfo.dli_fname != nullptr) {\n@@ -952,1 +952,1 @@\n-    if (dlinfo.dli_fbase != NULL && offset != NULL) {\n+    if (dlinfo.dli_fbase != nullptr && offset != nullptr) {\n@@ -975,2 +975,2 @@\n-  if (result != NULL) {\n-    Events::log_dll_message(NULL, \"Loaded shared library %s\", filename);\n+  if (result != nullptr) {\n+    Events::log_dll_message(nullptr, \"Loaded shared library %s\", filename);\n@@ -983,1 +983,1 @@\n-  if (error_report == NULL) {\n+  if (error_report == nullptr) {\n@@ -986,1 +986,1 @@\n-  if (ebuf != NULL && ebuflen > 0) {\n+  if (ebuf != nullptr && ebuflen > 0) {\n@@ -991,1 +991,1 @@\n-  Events::log_dll_message(NULL, \"Loading shared library %s failed, %s\", filename, error_report);\n+  Events::log_dll_message(nullptr, \"Loading shared library %s failed, %s\", filename, error_report);\n@@ -994,1 +994,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1004,2 +1004,2 @@\n-  if (result != NULL) {\n-    Events::log_dll_message(NULL, \"Loaded shared library %s\", filename);\n+  if (result != nullptr) {\n+    Events::log_dll_message(nullptr, \"Loaded shared library %s\", filename);\n@@ -1014,1 +1014,1 @@\n-  if (error_report == NULL) {\n+  if (error_report == nullptr) {\n@@ -1017,1 +1017,1 @@\n-  if (ebuf != NULL && ebuflen > 0) {\n+  if (ebuf != nullptr && ebuflen > 0) {\n@@ -1022,1 +1022,1 @@\n-  Events::log_dll_message(NULL, \"Loading shared library %s failed, %s\", filename, error_report);\n+  Events::log_dll_message(nullptr, \"Loading shared library %s failed, %s\", filename, error_report);\n@@ -1030,1 +1030,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1038,1 +1038,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1048,1 +1048,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1131,1 +1131,1 @@\n-  arch_t lib_arch={elf_head.e_machine,0,elf_head.e_ident[EI_CLASS], elf_head.e_ident[EI_DATA], NULL};\n+  arch_t lib_arch={elf_head.e_machine,0,elf_head.e_ident[EI_CLASS], elf_head.e_ident[EI_DATA], nullptr};\n@@ -1149,1 +1149,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1154,1 +1154,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1160,1 +1160,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1165,1 +1165,1 @@\n-    if (lib_arch.name!=NULL) {\n+    if (lib_arch.name!=nullptr) {\n@@ -1177,1 +1177,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1203,1 +1203,1 @@\n-      dli.dli_fname == NULL) {\n+      dli.dli_fname == nullptr) {\n@@ -1207,1 +1207,1 @@\n-  if (handle == NULL) {\n+  if (handle == nullptr) {\n@@ -1211,1 +1211,1 @@\n-  if (map == NULL) {\n+  if (map == nullptr) {\n@@ -1216,1 +1216,1 @@\n-  while (map->l_prev != NULL)\n+  while (map->l_prev != nullptr)\n@@ -1219,1 +1219,1 @@\n-  while (map != NULL) {\n+  while (map != nullptr) {\n@@ -1248,1 +1248,1 @@\n-  if (sysctl(mib_kern, 2, os, &size, NULL, 0) < 0) {\n+  if (sysctl(mib_kern, 2, os, &size, nullptr, 0) < 0) {\n@@ -1261,1 +1261,1 @@\n-  if (sysctl(mib_release, 2, release, &size, NULL, 0) < 0) {\n+  if (sysctl(mib_release, 2, release, &size, nullptr, 0) < 0) {\n@@ -1269,1 +1269,1 @@\n-  int ret = sysctlbyname(\"kern.osproductversion\", osproductversion, &sz, NULL, 0);\n+  int ret = sysctlbyname(\"kern.osproductversion\", osproductversion, &sz, nullptr, 0);\n@@ -1274,1 +1274,1 @@\n-    if (sysctl(mib_build, 2, build, &size, NULL, 0) < 0) {\n+    if (sysctl(mib_build, 2, build, &size, nullptr, 0) < 0) {\n@@ -1310,1 +1310,1 @@\n-  if (sysctl(mib, 2, &mhz, &size, NULL, 0) < 0) {\n+  if (sysctl(mib, 2, &mhz, &size, nullptr, 0) < 0) {\n@@ -1319,1 +1319,1 @@\n-  if (sysctl(mib_model, 2, model, &size, NULL, 0) < 0) {\n+  if (sysctl(mib_model, 2, model, &size, nullptr, 0) < 0) {\n@@ -1326,1 +1326,1 @@\n-  if (sysctl(mib_machine, 2, machine, &size, NULL, 0) < 0) {\n+  if (sysctl(mib_machine, 2, machine, &size, nullptr, 0) < 0) {\n@@ -1348,1 +1348,1 @@\n-  st->print(\" %dk page\", os::vm_page_size()>>10);\n+  st->print(\" \" SIZE_FORMAT \"k page\", os::vm_page_size()>>10);\n@@ -1355,1 +1355,1 @@\n-  if((sysctlbyname(\"vm.swapusage\", &swap_usage, &size, NULL, 0) == 0) || (errno == ENOMEM)) {\n+  if((sysctlbyname(\"vm.swapusage\", &swap_usage, &size, nullptr, 0) == 0) || (errno == ENOMEM)) {\n@@ -1387,1 +1387,1 @@\n-                                         dli_fname, sizeof(dli_fname), NULL);\n+                                         dli_fname, sizeof(dli_fname), nullptr);\n@@ -1389,1 +1389,1 @@\n-  char *rp = NULL;\n+  char *rp = nullptr;\n@@ -1393,1 +1393,1 @@\n-  if (rp == NULL) {\n+  if (rp == nullptr) {\n@@ -1415,1 +1415,1 @@\n-      if (java_home_var != NULL && java_home_var[0] != 0) {\n+      if (java_home_var != nullptr && java_home_var[0] != 0) {\n@@ -1424,1 +1424,1 @@\n-        if (rp == NULL) {\n+        if (rp == nullptr) {\n@@ -1458,1 +1458,1 @@\n-          if (rp == NULL) {\n+          if (rp == nullptr) {\n@@ -1488,1 +1488,1 @@\n-  Events::log(NULL, \"Protecting memory [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] with protection modes %x\", p2i(addr), p2i(addr+size), prot);\n+  Events::log(nullptr, \"Protecting memory [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] with protection modes %x\", p2i(addr), p2i(addr+size), prot);\n@@ -1528,1 +1528,1 @@\n-  assert(mesg != NULL, \"mesg must be specified\");\n+  assert(mesg != nullptr, \"mesg must be specified\");\n@@ -1590,1 +1590,1 @@\n-  Events::log(NULL, \"Protecting memory [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] with PROT_NONE\", p2i(addr), p2i(addr+size));\n+  Events::log(nullptr, \"Protecting memory [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] with PROT_NONE\", p2i(addr), p2i(addr+size));\n@@ -1622,1 +1622,1 @@\n-\/\/ function returns NULL to indicate failure.\n+\/\/ function returns null to indicate failure.\n@@ -1633,1 +1633,1 @@\n-  return addr == MAP_FAILED ? NULL : addr;\n+  return addr == MAP_FAILED ? nullptr : addr;\n@@ -1641,1 +1641,1 @@\n-  return anon_mmap(NULL \/* addr *\/, bytes, exec);\n+  return anon_mmap(nullptr \/* addr *\/, bytes, exec);\n@@ -1660,1 +1660,1 @@\n-  Events::log(NULL, \"Protecting memory [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] with protection modes %x\", p2i(bottom), p2i(bottom+size), prot);\n+  Events::log(nullptr, \"Protecting memory [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] with protection modes %x\", p2i(bottom), p2i(bottom+size), prot);\n@@ -1702,1 +1702,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1727,2 +1727,2 @@\n-  if (result != NULL) {\n-    if (replace_existing_mapping_with_file_mapping(result, bytes, file_desc) == NULL) {\n+  if (result != nullptr) {\n+    if (replace_existing_mapping_with_file_mapping(result, bytes, file_desc) == nullptr) {\n@@ -1756,1 +1756,1 @@\n-  if (addr != NULL) {\n+  if (addr != nullptr) {\n@@ -1761,1 +1761,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1913,1 +1913,1 @@\n-  int page_size = getpagesize();\n+  size_t page_size = (size_t)getpagesize();\n@@ -1916,1 +1916,1 @@\n-  if (os::vm_page_size() <= 0) {\n+  if (os::vm_page_size() == 0) {\n@@ -2009,1 +2009,1 @@\n-  if (handleLibObjc != NULL) {\n+  if (handleLibObjc != nullptr) {\n@@ -2072,1 +2072,1 @@\n-  if (name != NULL) {\n+  if (name != nullptr) {\n@@ -2089,1 +2089,1 @@\n-    if (dlinfo.dli_sname != NULL && dlinfo.dli_saddr != NULL) {\n+    if (dlinfo.dli_sname != nullptr && dlinfo.dli_saddr != nullptr) {\n@@ -2092,1 +2092,1 @@\n-    } else if (dlinfo.dli_fbase != NULL) {\n+    } else if (dlinfo.dli_fbase != nullptr) {\n@@ -2097,1 +2097,1 @@\n-    if (dlinfo.dli_fname != NULL) {\n+    if (dlinfo.dli_fname != nullptr) {\n@@ -2100,1 +2100,1 @@\n-    if (dlinfo.dli_fbase != NULL) {\n+    if (dlinfo.dli_fbase != nullptr) {\n@@ -2249,1 +2249,1 @@\n-  if (addr != NULL) {\n+  if (addr != nullptr) {\n@@ -2256,1 +2256,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -2375,1 +2375,1 @@\n-  int ret = sysctlbyname(\"kern.corefile\", coreinfo, &sz, NULL, 0);\n+  int ret = sysctlbyname(\"kern.corefile\", coreinfo, &sz, nullptr, 0);\n@@ -2379,1 +2379,1 @@\n-    const char* tail = (pid_pos != NULL) ? (pid_pos + 2) : \"\";\n+    const char* tail = (pid_pos != nullptr) ? (pid_pos + 2) : \"\";\n@@ -2381,1 +2381,1 @@\n-    if (pid_pos != NULL) {\n+    if (pid_pos != nullptr) {\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":105,"deletions":105,"binary":false,"changes":210,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,1 +100,1 @@\n-  static int sched_getcpu()  { return _sched_getcpu != NULL ? _sched_getcpu() : -1; }\n+  static int sched_getcpu()  { return _sched_getcpu != nullptr ? _sched_getcpu() : -1; }\n@@ -102,1 +102,1 @@\n-    return _numa_node_to_cpus != NULL ? _numa_node_to_cpus(node, buffer, bufferlen) : -1;\n+    return _numa_node_to_cpus != nullptr ? _numa_node_to_cpus(node, buffer, bufferlen) : -1;\n@@ -104,2 +104,2 @@\n-  static int numa_max_node() { return _numa_max_node != NULL ? _numa_max_node() : -1; }\n-  static int numa_available() { return _numa_available != NULL ? _numa_available() : -1; }\n+  static int numa_max_node() { return _numa_max_node != nullptr ? _numa_max_node() : -1; }\n+  static int numa_available() { return _numa_available != nullptr ? _numa_available() : -1; }\n@@ -107,1 +107,1 @@\n-    return _numa_tonode_memory != NULL ? _numa_tonode_memory(start, size, node) : -1;\n+    return _numa_tonode_memory != nullptr ? _numa_tonode_memory(start, size, node) : -1;\n@@ -110,1 +110,1 @@\n-    if (_numa_interleave_memory != NULL && _numa_all_nodes != NULL) {\n+    if (_numa_interleave_memory != nullptr && _numa_all_nodes != nullptr) {\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -234,1 +234,1 @@\n-  _impl = NULL;\n+  _impl = nullptr;\n@@ -243,1 +243,1 @@\n-  if (_impl != NULL) {\n+  if (_impl != nullptr) {\n@@ -286,2 +286,2 @@\n-  assert(system_processes != NULL, \"system_processes pointer is NULL!\");\n-  assert(no_of_sys_processes != NULL, \"system_processes counter pointer is NULL!\");\n+  assert(system_processes != nullptr, \"system_processes pointer is null!\");\n+  assert(no_of_sys_processes != nullptr, \"system_processes counter pointer is null!\");\n@@ -289,1 +289,1 @@\n-  pid_t* pids = NULL;\n+  pid_t* pids = nullptr;\n@@ -294,1 +294,1 @@\n-  while (pids == NULL) {\n+  while (pids == nullptr) {\n@@ -296,1 +296,1 @@\n-    size_t pids_bytes = proc_listpids(PROC_ALL_PIDS, 0, NULL, 0);\n+    size_t pids_bytes = proc_listpids(PROC_ALL_PIDS, 0, nullptr, 0);\n@@ -308,1 +308,1 @@\n-      pids = NULL;\n+      pids = nullptr;\n@@ -319,1 +319,1 @@\n-  SystemProcess* next = NULL;\n+  SystemProcess* next = nullptr;\n@@ -354,1 +354,1 @@\n-  _impl = NULL;\n+  _impl = nullptr;\n@@ -363,1 +363,1 @@\n-  if (_impl != NULL) {\n+  if (_impl != nullptr) {\n@@ -369,1 +369,1 @@\n-  _cpu_info = NULL;\n+  _cpu_info = nullptr;\n@@ -384,2 +384,2 @@\n-  if (_cpu_info != NULL) {\n-    if (_cpu_info->cpu_name() != NULL) {\n+  if (_cpu_info != nullptr) {\n+    if (_cpu_info->cpu_name() != nullptr) {\n@@ -388,1 +388,1 @@\n-      _cpu_info->set_cpu_name(NULL);\n+      _cpu_info->set_cpu_name(nullptr);\n@@ -390,1 +390,1 @@\n-    if (_cpu_info->cpu_description() != NULL) {\n+    if (_cpu_info->cpu_description() != nullptr) {\n@@ -393,1 +393,1 @@\n-      _cpu_info->set_cpu_description(NULL);\n+      _cpu_info->set_cpu_description(nullptr);\n@@ -400,1 +400,1 @@\n-  if (NULL == _cpu_info) {\n+  if (nullptr == _cpu_info) {\n@@ -431,1 +431,1 @@\n-  if (sysctl(mib, sizeof(mib) \/ sizeof(mib[0]), NULL, &len, NULL, 0) != 0) {\n+  if (sysctl(mib, sizeof(mib) \/ sizeof(mib[0]), nullptr, &len, nullptr, 0) != 0) {\n@@ -435,1 +435,1 @@\n-  if (sysctl(mib, sizeof(mib) \/ sizeof(mib[0]), buf, &len, NULL, 0) != 0) {\n+  if (sysctl(mib, sizeof(mib) \/ sizeof(mib[0]), buf, &len, nullptr, 0) != 0) {\n@@ -440,1 +440,1 @@\n-  NetworkInterface* ret = NULL;\n+  NetworkInterface* ret = nullptr;\n@@ -471,1 +471,1 @@\n-  _impl = NULL;\n+  _impl = nullptr;\n@@ -475,1 +475,1 @@\n-  if (_impl != NULL) {\n+  if (_impl != nullptr) {\n","filename":"src\/hotspot\/os\/bsd\/os_perf_bsd.cpp","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,1 @@\n-    if (path == NULL) {\n+    if (path == nullptr) {\n@@ -149,1 +149,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -174,1 +174,1 @@\n-      LinuxAttachListener::set_path(NULL);\n+      LinuxAttachListener::set_path(nullptr);\n@@ -278,1 +278,1 @@\n-      return NULL;      \/\/ reset by peer or other error\n+      return nullptr;      \/\/ reset by peer or other error\n@@ -296,1 +296,1 @@\n-            return NULL;\n+            return nullptr;\n@@ -306,1 +306,1 @@\n-    return NULL;        \/\/ incomplete request\n+    return nullptr;        \/\/ incomplete request\n@@ -317,2 +317,2 @@\n-  if (name == NULL || strlen(name) > AttachOperation::name_length_max) {\n-    return NULL;\n+  if (name == nullptr || strlen(name) > AttachOperation::name_length_max) {\n+    return nullptr;\n@@ -325,2 +325,2 @@\n-    if (arg == NULL) {\n-      op->set_arg(i, NULL);\n+    if (arg == nullptr) {\n+      op->set_arg(i, nullptr);\n@@ -330,1 +330,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -355,1 +355,1 @@\n-      return NULL;      \/\/ log a warning?\n+      return nullptr;      \/\/ log a warning?\n@@ -376,1 +376,1 @@\n-    if (op == NULL) {\n+    if (op == nullptr) {\n@@ -551,1 +551,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/os\/linux\/attachListener_linux.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,5 +42,5 @@\n-  CgroupV1MemoryController* memory = NULL;\n-  CgroupV1Controller* cpuset = NULL;\n-  CgroupV1Controller* cpu = NULL;\n-  CgroupV1Controller* cpuacct = NULL;\n-  CgroupV1Controller* pids = NULL;\n+  CgroupV1MemoryController* memory = nullptr;\n+  CgroupV1Controller* cpuset = nullptr;\n+  CgroupV1Controller* cpu = nullptr;\n+  CgroupV1Controller* cpuacct = nullptr;\n+  CgroupV1Controller* pids = nullptr;\n@@ -57,1 +57,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -131,1 +131,1 @@\n-  if (cg_infos[controller]._mount_path != NULL) {\n+  if (cg_infos[controller]._mount_path != nullptr) {\n@@ -157,3 +157,3 @@\n-  FILE *mntinfo = NULL;\n-  FILE *cgroups = NULL;\n-  FILE *cgroup = NULL;\n+  FILE *mntinfo = nullptr;\n+  FILE *cgroups = nullptr;\n+  FILE *cgroup = nullptr;\n@@ -177,1 +177,1 @@\n-  if (cgroups == NULL) {\n+  if (cgroups == nullptr) {\n@@ -183,1 +183,1 @@\n-  while ((p = fgets(buf, MAXPATHLEN, cgroups)) != NULL) {\n+  while ((p = fgets(buf, MAXPATHLEN, cgroups)) != nullptr) {\n@@ -245,1 +245,1 @@\n-  if (cgroup == NULL) {\n+  if (cgroup == nullptr) {\n@@ -253,1 +253,1 @@\n-  while ((p = fgets(buf, MAXPATHLEN, cgroup)) != NULL) {\n+  while ((p = fgets(buf, MAXPATHLEN, cgroup)) != nullptr) {\n@@ -266,1 +266,1 @@\n-    if (controllers == NULL) {\n+    if (controllers == nullptr) {\n@@ -270,1 +270,1 @@\n-    while (!is_cgroupsV2 && (token = strsep(&controllers, \",\")) != NULL) {\n+    while (!is_cgroupsV2 && (token = strsep(&controllers, \",\")) != nullptr) {\n@@ -296,1 +296,1 @@\n-        assert(cg_infos[i]._cgroup_path == NULL, \"cgroup path must only be set once\");\n+        assert(cg_infos[i]._cgroup_path == nullptr, \"cgroup path must only be set once\");\n@@ -306,1 +306,1 @@\n-  if (mntinfo == NULL) {\n+  if (mntinfo == nullptr) {\n@@ -316,1 +316,1 @@\n-  while ((p = fgets(buf, MAXPATHLEN, mntinfo)) != NULL) {\n+  while ((p = fgets(buf, MAXPATHLEN, mntinfo)) != nullptr) {\n@@ -355,1 +355,1 @@\n-      while ((token = strsep(&cptr, \",\")) != NULL) {\n+      while ((token = strsep(&cptr, \",\")) != nullptr) {\n@@ -440,1 +440,1 @@\n-  assert(cg_infos != NULL, \"Invariant\");\n+  assert(cg_infos != nullptr, \"Invariant\");\n@@ -560,1 +560,1 @@\n-  if (limit_str == NULL) {\n+  if (limit_str == nullptr) {\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,1 +93,1 @@\n-    log_debug(os, container)(\"subsystem_file_line_contents: CgroupController* is nullptr\");\n+    log_debug(os, container)(\"subsystem_file_line_contents: CgroupController* is null\");\n@@ -97,1 +97,1 @@\n-    log_debug(os, container)(\"subsystem_file_line_contents: subsystem path is nullptr\");\n+    log_debug(os, container)(\"subsystem_file_line_contents: subsystem path is null\");\n@@ -169,1 +169,1 @@\n-                                     NULL,                                \\\n+                                     nullptr,                             \\\n@@ -187,1 +187,1 @@\n-                                     NULL,                                \\\n+                                     nullptr,                             \\\n@@ -191,1 +191,1 @@\n-    return (return_type) NULL;                                            \\\n+    return (return_type) nullptr;                                         \\\n@@ -296,1 +296,1 @@\n-      _name = NULL;\n+      _name = nullptr;\n@@ -300,3 +300,3 @@\n-      _cgroup_path = NULL;\n-      _root_mount_path = NULL;\n-      _mount_path = NULL;\n+      _cgroup_path = nullptr;\n+      _root_mount_path = nullptr;\n+      _mount_path = nullptr;\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-  if (_root != NULL && cgroup_path != NULL) {\n+  if (_root != nullptr && cgroup_path != nullptr) {\n@@ -55,1 +55,1 @@\n-        if (p != NULL && p == _root) {\n+        if (p != nullptr && p == _root) {\n@@ -300,1 +300,1 @@\n-  if (_pids == NULL) return OSCONTAINER_ERROR;\n+  if (_pids == nullptr) return OSCONTAINER_ERROR;\n@@ -314,1 +314,1 @@\n-  if (_pids == NULL) return OSCONTAINER_ERROR;\n+  if (_pids == nullptr) return OSCONTAINER_ERROR;\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-      _path = NULL;\n+      _path = nullptr;\n@@ -108,5 +108,5 @@\n-    CachingCgroupController* _memory = NULL;\n-    CgroupV1Controller* _cpuset = NULL;\n-    CachingCgroupController* _cpu = NULL;\n-    CgroupV1Controller* _cpuacct = NULL;\n-    CgroupV1Controller* _pids = NULL;\n+    CachingCgroupController* _memory = nullptr;\n+    CgroupV1Controller* _cpuset = nullptr;\n+    CachingCgroupController* _cpu = nullptr;\n+    CgroupV1Controller* _cpuacct = nullptr;\n+    CgroupV1Controller* _pids = nullptr;\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-    CgroupController* _unified = NULL;\n+    CgroupController* _unified = nullptr;\n@@ -56,2 +56,2 @@\n-    CachingCgroupController* _memory = NULL;\n-    CachingCgroupController* _cpu = NULL;\n+    CachingCgroupController* _memory = nullptr;\n+    CachingCgroupController* _cpu = nullptr;\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-  if ((result = abi::__cxa_demangle(symbol, NULL, NULL, &status)) != NULL) {\n+  if ((result = abi::__cxa_demangle(symbol, nullptr, nullptr, &status)) != nullptr) {\n@@ -61,1 +61,1 @@\n-  if (filepath == NULL) return true;\n+  if (filepath == nullptr) return true;\n@@ -64,1 +64,1 @@\n-  if (file == NULL)  return true;\n+  if (file == nullptr)  return true;\n","filename":"src\/hotspot\/os\/linux\/decoder_linux.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-  if (AllocateHeapAt != NULL) {\n+  if (AllocateHeapAt != nullptr) {\n@@ -51,1 +51,1 @@\n-  _path = NULL;\n+  _path = nullptr;\n@@ -55,2 +55,2 @@\n-  char* line_mountpoint = NULL;\n-  char* line_filesystem = NULL;\n+  char* line_mountpoint = nullptr;\n+  char* line_filesystem = nullptr;\n@@ -67,1 +67,1 @@\n-    line_mountpoint = NULL;\n+    line_mountpoint = nullptr;\n@@ -77,1 +77,1 @@\n-  if (fd == NULL) {\n+  if (fd == nullptr) {\n@@ -83,1 +83,1 @@\n-  char* line = NULL;\n+  char* line = nullptr;\n@@ -88,1 +88,1 @@\n-    if (mountpoint != NULL) {\n+    if (mountpoint != nullptr) {\n@@ -112,1 +112,1 @@\n-    for (const char** preferred = preferred_mountpoints; *preferred != NULL; preferred++) {\n+    for (const char** preferred = preferred_mountpoints; *preferred != nullptr; preferred++) {\n@@ -127,1 +127,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -131,1 +131,1 @@\n-  char* path = NULL;\n+  char* path = nullptr;\n","filename":"src\/hotspot\/os\/linux\/gc\/z\/zMountPoint_linux.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n-  if (ZSyscall::get_mempolicy((int*)&id, NULL, 0, (void*)addr, MPOL_F_NODE | MPOL_F_ADDR) == -1) {\n+  if (ZSyscall::get_mempolicy((int*)&id, nullptr, 0, (void*)addr, MPOL_F_NODE | MPOL_F_ADDR) == -1) {\n","filename":"src\/hotspot\/os\/linux\/gc\/z\/zNUMA_linux.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -107,1 +107,1 @@\n-  NULL\n+  nullptr\n@@ -114,1 +114,1 @@\n-  NULL\n+  nullptr\n@@ -232,1 +232,1 @@\n-  if (mountpoint.get() == NULL) {\n+  if (mountpoint.get() == nullptr) {\n@@ -285,1 +285,1 @@\n-  if (AllocateHeapAt == NULL) {\n+  if (AllocateHeapAt == nullptr) {\n@@ -334,1 +334,1 @@\n-  if (file == NULL) {\n+  if (file == nullptr) {\n","filename":"src\/hotspot\/os\/linux\/gc\/z\/zPhysicalMemoryBacking_linux.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-  if (cgroup_subsystem == NULL) {\n+  if (cgroup_subsystem == nullptr) {\n@@ -66,1 +66,1 @@\n-  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  assert(cgroup_subsystem != nullptr, \"cgroup subsystem not available\");\n@@ -71,1 +71,1 @@\n-  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  assert(cgroup_subsystem != nullptr, \"cgroup subsystem not available\");\n@@ -76,1 +76,1 @@\n-  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  assert(cgroup_subsystem != nullptr, \"cgroup subsystem not available\");\n@@ -81,1 +81,1 @@\n-  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  assert(cgroup_subsystem != nullptr, \"cgroup subsystem not available\");\n@@ -86,1 +86,1 @@\n-  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  assert(cgroup_subsystem != nullptr, \"cgroup subsystem not available\");\n@@ -91,1 +91,1 @@\n-  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  assert(cgroup_subsystem != nullptr, \"cgroup subsystem not available\");\n@@ -96,1 +96,1 @@\n-  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  assert(cgroup_subsystem != nullptr, \"cgroup subsystem not available\");\n@@ -101,1 +101,1 @@\n-  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  assert(cgroup_subsystem != nullptr, \"cgroup subsystem not available\");\n@@ -106,1 +106,1 @@\n-  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  assert(cgroup_subsystem != nullptr, \"cgroup subsystem not available\");\n@@ -111,1 +111,1 @@\n-  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  assert(cgroup_subsystem != nullptr, \"cgroup subsystem not available\");\n@@ -116,1 +116,1 @@\n-  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  assert(cgroup_subsystem != nullptr, \"cgroup subsystem not available\");\n@@ -121,1 +121,1 @@\n-  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  assert(cgroup_subsystem != nullptr, \"cgroup subsystem not available\");\n@@ -126,1 +126,1 @@\n-  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  assert(cgroup_subsystem != nullptr, \"cgroup subsystem not available\");\n@@ -131,1 +131,1 @@\n-  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  assert(cgroup_subsystem != nullptr, \"cgroup subsystem not available\");\n@@ -136,1 +136,1 @@\n-  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  assert(cgroup_subsystem != nullptr, \"cgroup subsystem not available\");\n","filename":"src\/hotspot\/os\/linux\/osContainer_linux.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-  assert(this != NULL, \"check\");\n+  assert(this != nullptr, \"check\");\n@@ -36,2 +36,2 @@\n-  _siginfo = NULL;\n-  _ucontext = NULL;\n+  _siginfo = nullptr;\n+  _ucontext = nullptr;\n@@ -39,1 +39,1 @@\n-  _alt_sig_stack = NULL;\n+  _alt_sig_stack = nullptr;\n@@ -44,1 +44,1 @@\n-  assert(_startThread_lock !=NULL, \"check\");\n+  assert(_startThread_lock !=nullptr, \"check\");\n","filename":"src\/hotspot\/os\/linux\/osThread_linux.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -160,1 +160,1 @@\n-address   os::Linux::_initial_thread_stack_bottom = NULL;\n+address   os::Linux::_initial_thread_stack_bottom = nullptr;\n@@ -163,2 +163,2 @@\n-int (*os::Linux::_pthread_getcpuclockid)(pthread_t, clockid_t *) = NULL;\n-int (*os::Linux::_pthread_setname_np)(pthread_t, const char*) = NULL;\n+int (*os::Linux::_pthread_getcpuclockid)(pthread_t, clockid_t *) = nullptr;\n+int (*os::Linux::_pthread_setname_np)(pthread_t, const char*) = nullptr;\n@@ -167,2 +167,2 @@\n-const char * os::Linux::_libc_version = NULL;\n-const char * os::Linux::_libpthread_version = NULL;\n+const char * os::Linux::_libc_version = nullptr;\n+const char * os::Linux::_libpthread_version = nullptr;\n@@ -187,1 +187,1 @@\n-static mallinfo_func_t g_mallinfo = NULL;\n+static mallinfo_func_t g_mallinfo = nullptr;\n@@ -202,1 +202,1 @@\n-static mallinfo2_func_t g_mallinfo2 = NULL;\n+static mallinfo2_func_t g_mallinfo2 = nullptr;\n@@ -287,1 +287,1 @@\n-  if ((fh = os::fopen(\"\/proc\/stat\", \"r\")) == NULL) {\n+  if ((fh = os::fopen(\"\/proc\/stat\", \"r\")) == nullptr) {\n@@ -390,1 +390,1 @@\n-    if (fp == NULL) {\n+    if (fp == nullptr) {\n@@ -463,1 +463,1 @@\n-    if (pslash != NULL) {\n+    if (pslash != nullptr) {\n@@ -467,1 +467,1 @@\n-    if (pslash != NULL) {\n+    if (pslash != nullptr) {\n@@ -472,1 +472,1 @@\n-    if (pslash != NULL) {\n+    if (pslash != nullptr) {\n@@ -474,1 +474,1 @@\n-      if (pslash != NULL) {\n+      if (pslash != nullptr) {\n@@ -480,1 +480,1 @@\n-      vm_exit_during_initialization(\"Failed setting boot class path.\", NULL);\n+      vm_exit_during_initialization(\"Failed setting boot class path.\", nullptr);\n@@ -500,1 +500,1 @@\n-    if (v == NULL) { v = \"\"; v_colon = \"\"; }\n+    if (v == nullptr) { v = \"\"; v_colon = \"\"; }\n@@ -547,1 +547,1 @@\n-  size_t n = confstr(_CS_GNU_LIBC_VERSION, NULL, 0);\n+  size_t n = confstr(_CS_GNU_LIBC_VERSION, nullptr, 0);\n@@ -553,1 +553,1 @@\n-  n = confstr(_CS_GNU_LIBPTHREAD_VERSION, NULL, 0);\n+  n = confstr(_CS_GNU_LIBPTHREAD_VERSION, nullptr, 0);\n@@ -650,1 +650,1 @@\n-    assert(p != NULL && p <= (volatile char *)bottom, \"alloca problem?\");\n+    assert(p != nullptr && p <= (volatile char *)bottom, \"alloca problem?\");\n@@ -660,1 +660,1 @@\n-  assert(t!=NULL, \"just checking\");\n+  assert(t!=nullptr, \"just checking\");\n@@ -668,1 +668,1 @@\n-    pthread_sigmask(SIG_SETMASK, &old_sigset, NULL);\n+    pthread_sigmask(SIG_SETMASK, &old_sigset, nullptr);\n@@ -741,1 +741,1 @@\n-  thread = NULL;\n+  thread = nullptr;\n@@ -766,1 +766,1 @@\n-GetMinStack _get_minstack_func = NULL;\n+GetMinStack _get_minstack_func = nullptr;\n@@ -772,1 +772,1 @@\n-                       _get_minstack_func == NULL ? \"failed\" : \"succeeded\");\n+                       _get_minstack_func == nullptr ? \"failed\" : \"succeeded\");\n@@ -780,1 +780,1 @@\n-  if (_get_minstack_func != NULL) {\n+  if (_get_minstack_func != nullptr) {\n@@ -806,1 +806,1 @@\n-    if (minstack_size > (size_t)os::vm_page_size() + PTHREAD_STACK_MIN) {\n+    if (minstack_size > os::vm_page_size() + PTHREAD_STACK_MIN) {\n@@ -818,1 +818,1 @@\n-  assert(thread->osthread() == NULL, \"caller responsible\");\n+  assert(thread->osthread() == nullptr, \"caller responsible\");\n@@ -822,1 +822,1 @@\n-  if (osthread == NULL) {\n+  if (osthread == nullptr) {\n@@ -875,1 +875,1 @@\n-    thread->set_osthread(NULL);\n+    thread->set_osthread(nullptr);\n@@ -911,1 +911,1 @@\n-      thread->set_osthread(NULL);\n+      thread->set_osthread(nullptr);\n@@ -952,1 +952,1 @@\n-  if (osthread == NULL) {\n+  if (osthread == nullptr) {\n@@ -987,1 +987,1 @@\n-    assert(addr != NULL, \"initialization problem?\");\n+    assert(addr != nullptr, \"initialization problem?\");\n@@ -1017,1 +1017,1 @@\n-  assert(osthread != NULL, \"osthread not set\");\n+  assert(osthread != nullptr, \"osthread not set\");\n@@ -1027,1 +1027,1 @@\n-  pthread_sigmask(SIG_SETMASK, NULL, &current);\n+  pthread_sigmask(SIG_SETMASK, nullptr, &current);\n@@ -1033,1 +1033,1 @@\n-  pthread_sigmask(SIG_SETMASK, &sigmask, NULL);\n+  pthread_sigmask(SIG_SETMASK, &sigmask, nullptr);\n@@ -1049,2 +1049,2 @@\n-  if (os::Linux::initial_thread_stack_bottom() == NULL) return false;\n-  assert(os::Linux::initial_thread_stack_bottom() != NULL &&\n+  if (os::Linux::initial_thread_stack_bottom() == nullptr) return false;\n+  assert(os::Linux::initial_thread_stack_bottom() != nullptr &&\n@@ -1111,1 +1111,1 @@\n-  if (stack_size >= (size_t)(3 * os::vm_page_size())) {\n+  if (stack_size >= 3 * os::vm_page_size()) {\n@@ -1355,1 +1355,1 @@\n-  if (libjvm_base_addr == NULL) {\n+  if (libjvm_base_addr == nullptr) {\n@@ -1359,1 +1359,1 @@\n-    assert(libjvm_base_addr !=NULL, \"Cannot obtain base address for libjvm\");\n+    assert(libjvm_base_addr !=nullptr, \"Cannot obtain base address for libjvm\");\n@@ -1373,1 +1373,1 @@\n-  assert(buf != NULL, \"sanity check\");\n+  assert(buf != nullptr, \"sanity check\");\n@@ -1379,1 +1379,1 @@\n-    if (dlinfo.dli_saddr != NULL && dlinfo.dli_sname != NULL) {\n+    if (dlinfo.dli_saddr != nullptr && dlinfo.dli_sname != nullptr) {\n@@ -1383,1 +1383,1 @@\n-      if (offset != NULL) *offset = addr - (address)dlinfo.dli_saddr;\n+      if (offset != nullptr) *offset = addr - (address)dlinfo.dli_saddr;\n@@ -1387,1 +1387,1 @@\n-    if (dlinfo.dli_fname != NULL && dlinfo.dli_fbase != NULL) {\n+    if (dlinfo.dli_fname != nullptr && dlinfo.dli_fbase != nullptr) {\n@@ -1396,1 +1396,1 @@\n-  if (offset != NULL) *offset = -1;\n+  if (offset != nullptr) *offset = -1;\n@@ -1436,1 +1436,1 @@\n-    _filename(fn), _ebuf(ebuf), _ebuflen(ebuflen), _lib(NULL) {}\n+    _filename(fn), _ebuf(ebuf), _ebuflen(ebuflen), _lib(nullptr) {}\n@@ -1446,1 +1446,1 @@\n-  void * result = NULL;\n+  void * result = nullptr;\n@@ -1504,1 +1504,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -1515,1 +1515,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1523,1 +1523,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1533,1 +1533,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1539,1 +1539,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1646,1 +1646,1 @@\n-  arch_t lib_arch={elf_head.e_machine,0,elf_head.e_ident[EI_CLASS], elf_head.e_ident[EI_DATA], NULL};\n+  arch_t lib_arch={elf_head.e_machine,0,elf_head.e_ident[EI_CLASS], elf_head.e_ident[EI_DATA], nullptr};\n@@ -1664,1 +1664,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1668,1 +1668,1 @@\n-    if (lib_arch.name != NULL) {\n+    if (lib_arch.name != nullptr) {\n@@ -1677,1 +1677,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1682,1 +1682,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1688,1 +1688,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1695,1 +1695,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1698,1 +1698,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1704,1 +1704,1 @@\n-  if (result == NULL) {\n+  if (result == nullptr) {\n@@ -1706,1 +1706,1 @@\n-    if (error_report == NULL) {\n+    if (error_report == nullptr) {\n@@ -1709,1 +1709,1 @@\n-    if (ebuf != NULL && ebuflen > 0) {\n+    if (ebuf != nullptr && ebuflen > 0) {\n@@ -1713,1 +1713,1 @@\n-    Events::log_dll_message(NULL, \"Loading shared library %s failed, %s\", filename, error_report);\n+    Events::log_dll_message(nullptr, \"Loading shared library %s failed, %s\", filename, error_report);\n@@ -1716,1 +1716,1 @@\n-    Events::log_dll_message(NULL, \"Loaded shared library %s\", filename);\n+    Events::log_dll_message(nullptr, \"Loaded shared library %s\", filename);\n@@ -1724,1 +1724,1 @@\n-  void * result = NULL;\n+  void * result = nullptr;\n@@ -1754,2 +1754,2 @@\n-  const char* l_path = NULL;\n-  assert(lib != NULL, \"dll_path parameter must not be NULL\");\n+  const char* l_path = nullptr;\n+  assert(lib != nullptr, \"dll_path parameter must not be null\");\n@@ -1764,1 +1764,1 @@\n-static bool _print_ascii_file(const char* filename, outputStream* st, const char* hdr = NULL) {\n+static bool _print_ascii_file(const char* filename, outputStream* st, const char* hdr = nullptr) {\n@@ -1770,1 +1770,1 @@\n-  if (hdr != NULL) {\n+  if (hdr != nullptr) {\n@@ -1812,1 +1812,1 @@\n-  if ((info->dlpi_name == NULL) || (*info->dlpi_name == '\\0')) {\n+  if ((info->dlpi_name == nullptr) || (*info->dlpi_name == '\\0')) {\n@@ -1817,2 +1817,2 @@\n-  address base = NULL;\n-  address top = NULL;\n+  address base = nullptr;\n+  address top = nullptr;\n@@ -1825,1 +1825,1 @@\n-      if ((base == NULL) || (base > phdr_base)) {\n+      if ((base == nullptr) || (base > phdr_base)) {\n@@ -1830,1 +1830,1 @@\n-      if ((top == NULL) || (top < phdr_top)) {\n+      if ((top == nullptr) || (top < phdr_top)) {\n@@ -1932,1 +1932,1 @@\n-  NULL };\n+  nullptr };\n@@ -1937,1 +1937,1 @@\n-    if (file == NULL) {\n+    if (file == nullptr) {\n@@ -1958,1 +1958,1 @@\n-    if (strstr(buf, \"DISTRIB_DESCRIPTION=\") != NULL || strstr(buf, \"PRETTY_NAME=\") != NULL) {\n+    if (strstr(buf, \"DISTRIB_DESCRIPTION=\") != nullptr || strstr(buf, \"PRETTY_NAME=\") != nullptr) {\n@@ -1960,1 +1960,1 @@\n-      if (ptr != NULL) {\n+      if (ptr != nullptr) {\n@@ -1963,1 +1963,1 @@\n-        if (nl != NULL) *nl = '\\0';\n+        if (nl != nullptr) *nl = '\\0';\n@@ -1969,1 +1969,1 @@\n-        if (nl != NULL) *nl = '\\0';\n+        if (nl != nullptr) *nl = '\\0';\n@@ -1975,1 +1975,1 @@\n-      if (nl != NULL) *nl = '\\0';\n+      if (nl != nullptr) *nl = '\\0';\n@@ -1982,1 +1982,1 @@\n-  if (nl != NULL) *nl = '\\0';\n+  if (nl != nullptr) *nl = '\\0';\n@@ -1988,1 +1988,1 @@\n-  if (fp != NULL) {\n+  if (fp != nullptr) {\n@@ -1999,1 +1999,1 @@\n-    if (file == NULL) {\n+    if (file == nullptr) {\n@@ -2054,2 +2054,2 @@\n-  if (f != NULL) {\n-    while (::fgets(buf, sizeof(buf), f) != NULL && num_found < num_values) {\n+  if (f != nullptr) {\n+    while (::fgets(buf, sizeof(buf), f) != nullptr && num_found < num_values) {\n@@ -2087,1 +2087,1 @@\n-      NULL};\n+      nullptr};\n@@ -2090,1 +2090,1 @@\n-  for (int i = 0; var[i] != NULL; i ++) {\n+  for (int i = 0; var[i] != nullptr; i ++) {\n@@ -2092,1 +2092,1 @@\n-    if (val != NULL) {\n+    if (val != nullptr) {\n@@ -2170,1 +2170,1 @@\n-  st->print_cr(\"container_type: %s\", p_ct != NULL ? p_ct : \"not supported\");\n+  st->print_cr(\"container_type: %s\", p_ct != nullptr ? p_ct : \"not supported\");\n@@ -2173,1 +2173,1 @@\n-  st->print_cr(\"cpu_cpuset_cpus: %s\", p != NULL ? p : \"not supported\");\n+  st->print_cr(\"cpu_cpuset_cpus: %s\", p != nullptr ? p : \"not supported\");\n@@ -2177,1 +2177,1 @@\n-  st->print_cr(\"cpu_memory_nodes: %s\", p != NULL ? p : \"not supported\");\n+  st->print_cr(\"cpu_memory_nodes: %s\", p != nullptr ? p : \"not supported\");\n@@ -2266,1 +2266,1 @@\n-  st->print(\" %dk page\", os::vm_page_size()>>10);\n+  st->print(\" \" SIZE_FORMAT \"k page\", os::vm_page_size()>>10);\n@@ -2299,1 +2299,1 @@\n-        if (strstr(buf, \"model name\") != NULL) {\n+        if (strstr(buf, \"model name\") != nullptr) {\n@@ -2311,1 +2311,1 @@\n-        if (strstr(buf, \"flags\") != NULL) {\n+        if (strstr(buf, \"flags\") != nullptr) {\n@@ -2398,1 +2398,1 @@\n-  if (fp != NULL) {\n+  if (fp != nullptr) {\n@@ -2403,1 +2403,1 @@\n-        if (start != NULL) {\n+        if (start != nullptr) {\n@@ -2416,1 +2416,1 @@\n-            if (nl != NULL) *nl = '\\0';\n+            if (nl != nullptr) *nl = '\\0';\n@@ -2473,1 +2473,1 @@\n-                                         dli_fname, sizeof(dli_fname), NULL);\n+                                         dli_fname, sizeof(dli_fname), nullptr);\n@@ -2475,1 +2475,1 @@\n-  char *rp = NULL;\n+  char *rp = nullptr;\n@@ -2479,1 +2479,1 @@\n-  if (rp == NULL) {\n+  if (rp == nullptr) {\n@@ -2500,1 +2500,1 @@\n-      if (java_home_var != NULL && java_home_var[0] != 0) {\n+      if (java_home_var != nullptr && java_home_var[0] != 0) {\n@@ -2506,1 +2506,1 @@\n-        if (p == NULL) {\n+        if (p == nullptr) {\n@@ -2512,1 +2512,1 @@\n-        if (rp == NULL) {\n+        if (rp == nullptr) {\n@@ -2533,1 +2533,1 @@\n-          if (rp == NULL) {\n+          if (rp == nullptr) {\n@@ -2653,1 +2653,1 @@\n-  assert(mesg != NULL, \"mesg must be specified\");\n+  assert(mesg != nullptr, \"mesg must be specified\");\n@@ -2698,1 +2698,1 @@\n-  assert(mesg != NULL, \"mesg must be specified\");\n+  assert(mesg != nullptr, \"mesg must be specified\");\n@@ -2708,1 +2708,1 @@\n-  if (UseTransparentHugePages && alignment_hint > (size_t)vm_page_size()) {\n+  if (UseTransparentHugePages && alignment_hint > vm_page_size()) {\n@@ -2721,1 +2721,1 @@\n-  if (alignment_hint <= (size_t)os::vm_page_size() || can_commit_large_page_memory()) {\n+  if (alignment_hint <= os::vm_page_size() || can_commit_large_page_memory()) {\n@@ -2769,1 +2769,1 @@\n-  if (os::Linux::numa_move_pages(0, 1, pages, NULL, &id, 0) == -1) {\n+  if (os::Linux::numa_move_pages(0, 1, pages, nullptr, &id, 0) == -1) {\n@@ -2780,1 +2780,1 @@\n-  return os::Linux::numa_move_pages(0, count, pages, NULL, lgrp_ids, 0) == 0;\n+  return os::Linux::numa_move_pages(0, count, pages, nullptr, lgrp_ids, 0) == 0;\n@@ -2827,1 +2827,1 @@\n-  retval = syscall(SYS_getcpu, &cpu, NULL, NULL);\n+  retval = syscall(SYS_getcpu, &cpu, nullptr, nullptr);\n@@ -2837,1 +2837,1 @@\n-  retval = vgetcpu(&cpu, NULL, NULL);\n+  retval = vgetcpu(&cpu, nullptr, nullptr);\n@@ -2867,1 +2867,1 @@\n-  if (f == NULL) {\n+  if (f == nullptr) {\n@@ -2874,1 +2874,1 @@\n-\/\/ Return NULL if the symbol is not defined in this particular version.\n+\/\/ Return null if the symbol is not defined in this particular version.\n@@ -2888,1 +2888,1 @@\n-  if (syscall(SYS_get_mempolicy, &dummy, NULL, 0, (void*)&dummy, 3) == -1) {\n+  if (syscall(SYS_get_mempolicy, &dummy, nullptr, 0, (void*)&dummy, 3) == -1) {\n@@ -2900,1 +2900,1 @@\n-    if (handle != NULL) {\n+    if (handle != nullptr) {\n@@ -3055,1 +3055,1 @@\n-  if (_numa_node_to_cpus_v2 != NULL) {\n+  if (_numa_node_to_cpus_v2 != nullptr) {\n@@ -3067,1 +3067,1 @@\n-  } else if (_numa_node_to_cpus != NULL) {\n+  } else if (_numa_node_to_cpus != nullptr) {\n@@ -3074,1 +3074,1 @@\n-  if (cpu_to_node() != NULL && cpu_id >= 0 && cpu_id < cpu_to_node()->length()) {\n+  if (cpu_to_node() != nullptr && cpu_id >= 0 && cpu_id < cpu_to_node()->length()) {\n@@ -3171,1 +3171,1 @@\n-  committed_start = NULL;\n+  committed_start = nullptr;\n@@ -3199,1 +3199,1 @@\n-        if (committed_start != NULL) {\n+        if (committed_start != nullptr) {\n@@ -3205,1 +3205,1 @@\n-        if (committed_start == NULL) {\n+        if (committed_start == nullptr) {\n@@ -3215,1 +3215,1 @@\n-  if (committed_start != NULL) {\n+  if (committed_start != nullptr) {\n@@ -3298,1 +3298,1 @@\n-\/\/ function returns NULL to indicate failure.\n+\/\/ function returns null to indicate failure.\n@@ -3308,1 +3308,1 @@\n-  return addr == MAP_FAILED ? NULL : addr;\n+  return addr == MAP_FAILED ? nullptr : addr;\n@@ -3312,1 +3312,1 @@\n-\/\/   (req_addr != NULL) or with a given alignment.\n+\/\/   (req_addr != nullptr) or with a given alignment.\n@@ -3314,1 +3314,1 @@\n-\/\/  - req_addr can be NULL. If not NULL, it must be a multiple of alignment.\n+\/\/  - req_addr can be null. If not null, it must be a multiple of alignment.\n@@ -3317,2 +3317,2 @@\n-\/\/ Returns address of memory or NULL. If req_addr was not NULL, will only return\n-\/\/  req_addr or NULL.\n+\/\/ Returns address of memory or null. If req_addr was not null, will only return\n+\/\/  req_addr or null.\n@@ -3321,1 +3321,1 @@\n-  if (req_addr == NULL && alignment > 0) {\n+  if (req_addr == nullptr && alignment > 0) {\n@@ -3326,2 +3326,2 @@\n-  if (start != NULL) {\n-    if (req_addr != NULL) {\n+  if (start != nullptr) {\n+    if (req_addr != nullptr) {\n@@ -3330,1 +3330,1 @@\n-        start = NULL;\n+        start = nullptr;\n@@ -3353,1 +3353,1 @@\n-  return anon_mmap(NULL, bytes);\n+  return anon_mmap(nullptr, bytes);\n@@ -3381,1 +3381,1 @@\n-  Events::log(NULL, \"Protecting memory [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] with protection modes %x\", p2i(bottom), p2i(bottom+size), prot);\n+  Events::log(nullptr, \"Protecting memory [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] with protection modes %x\", p2i(bottom), p2i(bottom+size), prot);\n@@ -3412,1 +3412,1 @@\n-  void *p = mmap(NULL, page_size * 2, PROT_READ|PROT_WRITE,\n+  void *p = mmap(nullptr, page_size * 2, PROT_READ|PROT_WRITE,\n@@ -3440,1 +3440,1 @@\n-  void *p = mmap(NULL, page_size, PROT_READ|PROT_WRITE, flags, -1, 0);\n+  void *p = mmap(nullptr, page_size, PROT_READ|PROT_WRITE, flags, -1, 0);\n@@ -3452,1 +3452,1 @@\n-          page_size_ != (size_t)os::vm_page_size();\n+          page_size_ != os::vm_page_size();\n@@ -3455,1 +3455,1 @@\n-        p = mmap(NULL, page_size_, PROT_READ|PROT_WRITE, flags, -1, 0);\n+        p = mmap(nullptr, page_size_, PROT_READ|PROT_WRITE, flags, -1, 0);\n@@ -3494,1 +3494,1 @@\n-  shmctl(shmid, IPC_RMID, NULL);\n+  shmctl(shmid, IPC_RMID, nullptr);\n@@ -3515,1 +3515,1 @@\n-  if ((f = os::fopen(\"\/proc\/self\/coredump_filter\", \"r+\")) == NULL) {\n+  if ((f = os::fopen(\"\/proc\/self\/coredump_filter\", \"r+\")) == nullptr) {\n@@ -3588,1 +3588,1 @@\n-  while ((entry = readdir(dir)) != NULL) {\n+  while ((entry = readdir(dir)) != nullptr) {\n@@ -3782,1 +3782,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -3788,2 +3788,2 @@\n-  char* pre_reserved_addr = anon_mmap_aligned(NULL \/* req_addr *\/, bytes, alignment);\n-  if (pre_reserved_addr == NULL) {\n+  char* pre_reserved_addr = anon_mmap_aligned(nullptr \/* req_addr *\/, bytes, alignment);\n+  if (pre_reserved_addr == nullptr) {\n@@ -3792,1 +3792,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -3809,1 +3809,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -3818,1 +3818,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -3825,1 +3825,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -3833,1 +3833,1 @@\n-  if (req_addr != NULL) {\n+  if (req_addr != nullptr) {\n@@ -3840,1 +3840,1 @@\n-  \/\/ return large page size aligned memory addresses when req_addr == NULL.\n+  \/\/ return large page size aligned memory addresses when req_addr == nullptr.\n@@ -3847,1 +3847,1 @@\n-    return shmat_at_address(shmid, NULL);\n+    return shmat_at_address(shmid, nullptr);\n@@ -3860,1 +3860,1 @@\n-    return NULL; \/\/ Fallback to small pages.\n+    return nullptr; \/\/ Fallback to small pages.\n@@ -3884,1 +3884,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -3894,1 +3894,1 @@\n-  shmctl(shmid, IPC_RMID, NULL);\n+  shmctl(shmid, IPC_RMID, nullptr);\n@@ -3916,1 +3916,1 @@\n-  assert(req_addr != NULL, \"Must have a requested address for special mappings\");\n+  assert(req_addr != nullptr, \"Must have a requested address for special mappings\");\n@@ -3922,1 +3922,1 @@\n-  if (page_size > (size_t) os::vm_page_size()) {\n+  if (page_size > os::vm_page_size()) {\n@@ -3952,1 +3952,1 @@\n-  assert(page_size > (size_t)os::vm_page_size(), \"Must be a large page size\");\n+  assert(page_size > os::vm_page_size(), \"Must be a large page size\");\n@@ -3965,2 +3965,2 @@\n-  if (aligned_start == NULL) {\n-    return NULL;\n+  if (aligned_start == nullptr) {\n+    return nullptr;\n@@ -3986,1 +3986,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -3995,1 +3995,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -4013,1 +4013,1 @@\n-  if (addr != NULL) {\n+  if (addr != nullptr) {\n@@ -4066,2 +4066,2 @@\n-  if (result != NULL) {\n-    if (replace_existing_mapping_with_file_mapping(result, bytes, file_desc) == NULL) {\n+  if (result != nullptr) {\n+    if (replace_existing_mapping_with_file_mapping(result, bytes, file_desc) == nullptr) {\n@@ -4095,1 +4095,1 @@\n-  if (addr != NULL) {\n+  if (addr != nullptr) {\n@@ -4100,1 +4100,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -4260,1 +4260,1 @@\n-  void* p = ::mmap(NULL, size, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n+  void* p = ::mmap(nullptr, size, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n@@ -4282,5 +4282,2 @@\n-\n-  int page_size = sysconf(_SC_PAGESIZE);\n-  OSInfo::set_vm_page_size(page_size);\n-  OSInfo::set_vm_allocation_granularity(page_size);\n-  if (os::vm_page_size() <= 0) {\n+  int sys_pg_size = sysconf(_SC_PAGESIZE);\n+  if (sys_pg_size < 0) {\n@@ -4290,0 +4287,6 @@\n+  size_t page_size = (size_t) sys_pg_size;\n+  OSInfo::set_vm_page_size(page_size);\n+  OSInfo::set_vm_allocation_granularity(page_size);\n+  if (os::vm_page_size() == 0) {\n+    fatal(\"os_linux.cpp: os::init: OSInfo::set_vm_page_size failed\");\n+  }\n@@ -4413,1 +4416,1 @@\n-  assert(os::Linux::initial_thread_stack_bottom() != NULL, \"sanity\");\n+  assert(os::Linux::initial_thread_stack_bottom() != nullptr, \"sanity\");\n@@ -4456,1 +4459,1 @@\n-  if (codebuf == NULL) {\n+  if (codebuf == nullptr) {\n@@ -4465,1 +4468,1 @@\n-  if ((codebuf == NULL) || (!os::commit_memory(codebuf, page_size, true))) {\n+  if ((codebuf == nullptr) || (!os::commit_memory(codebuf, page_size, true))) {\n@@ -4634,1 +4637,1 @@\n-    if (cpus_p != NULL) {\n+    if (cpus_p != nullptr) {\n@@ -4785,1 +4788,1 @@\n-    if (dlinfo.dli_sname != NULL && dlinfo.dli_saddr != NULL) {\n+    if (dlinfo.dli_sname != nullptr && dlinfo.dli_saddr != nullptr) {\n@@ -4788,1 +4791,1 @@\n-    } else if (dlinfo.dli_fbase != NULL) {\n+    } else if (dlinfo.dli_fbase != nullptr) {\n@@ -4793,1 +4796,1 @@\n-    if (dlinfo.dli_fname != NULL) {\n+    if (dlinfo.dli_fname != nullptr) {\n@@ -4796,1 +4799,1 @@\n-    if (dlinfo.dli_fbase != NULL) {\n+    if (dlinfo.dli_fbase != nullptr) {\n@@ -4945,1 +4948,1 @@\n-  if (addr != NULL) {\n+  if (addr != nullptr) {\n@@ -4952,1 +4955,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -5046,1 +5049,1 @@\n-  if (fp == NULL) return -1;\n+  if (fp == nullptr) return -1;\n@@ -5058,1 +5061,1 @@\n-  if (s == NULL) return -1;\n+  if (s == nullptr) return -1;\n@@ -5130,1 +5133,1 @@\n-  const char* tail = (pid_pos != NULL) ? (pid_pos + 2) : \"\";  \/\/ skip over the \"%p\"\n+  const char* tail = (pid_pos != nullptr) ? (pid_pos + 2) : \"\";  \/\/ skip over the \"%p\"\n@@ -5134,1 +5137,1 @@\n-    if (pid_pos != NULL) {\n+    if (pid_pos != nullptr) {\n@@ -5145,1 +5148,1 @@\n-    if (p == NULL) {\n+    if (p == nullptr) {\n@@ -5153,1 +5156,1 @@\n-    } else if (pid_pos != NULL) {\n+    } else if (pid_pos != nullptr) {\n@@ -5166,1 +5169,1 @@\n-  if (((size_t)written < bufferSize) && (pid_pos == NULL) && (core_pattern[0] != '|')) {\n+  if (((size_t)written < bufferSize) && (pid_pos == nullptr) && (core_pattern[0] != '|')) {\n@@ -5332,1 +5335,1 @@\n-  if (f != NULL) {\n+  if (f != nullptr) {\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":195,"deletions":192,"binary":false,"changes":387,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -255,2 +255,2 @@\n-  static void set_numa_all_nodes_ptr(struct bitmask **ptr) { _numa_all_nodes_ptr = (ptr == NULL ? NULL : *ptr); }\n-  static void set_numa_nodes_ptr(struct bitmask **ptr) { _numa_nodes_ptr = (ptr == NULL ? NULL : *ptr); }\n+  static void set_numa_all_nodes_ptr(struct bitmask **ptr) { _numa_all_nodes_ptr = (ptr == nullptr ? nullptr : *ptr); }\n+  static void set_numa_nodes_ptr(struct bitmask **ptr) { _numa_nodes_ptr = (ptr == nullptr ? nullptr : *ptr); }\n@@ -269,1 +269,1 @@\n-  static int sched_getcpu()  { return _sched_getcpu != NULL ? _sched_getcpu() : -1; }\n+  static int sched_getcpu()  { return _sched_getcpu != nullptr ? _sched_getcpu() : -1; }\n@@ -271,1 +271,1 @@\n-  static int numa_max_node() { return _numa_max_node != NULL ? _numa_max_node() : -1; }\n+  static int numa_max_node() { return _numa_max_node != nullptr ? _numa_max_node() : -1; }\n@@ -273,1 +273,1 @@\n-    return _numa_num_configured_nodes != NULL ? _numa_num_configured_nodes() : -1;\n+    return _numa_num_configured_nodes != nullptr ? _numa_num_configured_nodes() : -1;\n@@ -275,1 +275,1 @@\n-  static int numa_available() { return _numa_available != NULL ? _numa_available() : -1; }\n+  static int numa_available() { return _numa_available != nullptr ? _numa_available() : -1; }\n@@ -277,1 +277,1 @@\n-    return _numa_tonode_memory != NULL ? _numa_tonode_memory(start, size, node) : -1;\n+    return _numa_tonode_memory != nullptr ? _numa_tonode_memory(start, size, node) : -1;\n@@ -299,1 +299,1 @@\n-    if (_numa_interleave_memory_v2 != NULL) {\n+    if (_numa_interleave_memory_v2 != nullptr) {\n@@ -302,1 +302,1 @@\n-      } else if (_numa_membind_bitmask != NULL) {\n+      } else if (_numa_membind_bitmask != nullptr) {\n@@ -305,1 +305,1 @@\n-    } else if (_numa_interleave_memory != NULL) {\n+    } else if (_numa_interleave_memory != nullptr) {\n@@ -310,1 +310,1 @@\n-    if (_numa_set_preferred != NULL) {\n+    if (_numa_set_preferred != nullptr) {\n@@ -315,1 +315,1 @@\n-    if (_numa_set_bind_policy != NULL) {\n+    if (_numa_set_bind_policy != nullptr) {\n@@ -320,1 +320,1 @@\n-    return _numa_distance != NULL ? _numa_distance(node1, node2) : -1;\n+    return _numa_distance != nullptr ? _numa_distance(node1, node2) : -1;\n@@ -323,1 +323,1 @@\n-    return _numa_move_pages != NULL ? _numa_move_pages(pid, count, pages, nodes, status, flags) : -1;\n+    return _numa_move_pages != nullptr ? _numa_move_pages(pid, count, pages, nodes, status, flags) : -1;\n@@ -329,1 +329,1 @@\n-    if (_numa_bitmask_isbitset != NULL && _numa_all_nodes_ptr != NULL) {\n+    if (_numa_bitmask_isbitset != nullptr && _numa_all_nodes_ptr != nullptr) {\n@@ -336,1 +336,1 @@\n-    if (_numa_bitmask_isbitset != NULL && _numa_nodes_ptr != NULL) {\n+    if (_numa_bitmask_isbitset != nullptr && _numa_nodes_ptr != nullptr) {\n@@ -338,1 +338,1 @@\n-    } else if (_numa_bitmask_isbitset != NULL && _numa_all_nodes_ptr != NULL) {\n+    } else if (_numa_bitmask_isbitset != nullptr && _numa_all_nodes_ptr != nullptr) {\n@@ -355,1 +355,1 @@\n-    if (_numa_bitmask_isbitset != NULL) {\n+    if (_numa_bitmask_isbitset != nullptr) {\n@@ -359,1 +359,1 @@\n-        return _numa_membind_bitmask != NULL ? _numa_bitmask_isbitset(_numa_membind_bitmask, node) : false;\n+        return _numa_membind_bitmask != nullptr ? _numa_bitmask_isbitset(_numa_membind_bitmask, node) : false;\n@@ -371,1 +371,1 @@\n-    if (_numa_membind_bitmask != NULL && _numa_max_node != NULL && _numa_bitmask_isbitset != NULL) {\n+    if (_numa_membind_bitmask != nullptr && _numa_max_node != nullptr && _numa_bitmask_isbitset != nullptr) {\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -238,1 +238,1 @@\n-  if ((f = os::fopen(procfile, \"r\")) == NULL) {\n+  if ((f = os::fopen(procfile, \"r\")) == nullptr) {\n@@ -247,1 +247,1 @@\n-    if ((tmp = strrchr(buf, ')')) != NULL) {\n+    if ((tmp = strrchr(buf, ')')) != nullptr) {\n@@ -275,1 +275,1 @@\n-  if ((f = os::fopen(\"\/proc\/stat\", \"r\")) == NULL) {\n+  if ((f = os::fopen(\"\/proc\/stat\", \"r\")) == nullptr) {\n@@ -293,1 +293,1 @@\n-  if ((taskDir = opendir(\"\/proc\/self\/task\")) == NULL) {\n+  if ((taskDir = opendir(\"\/proc\/self\/task\")) == nullptr) {\n@@ -403,1 +403,1 @@\n-  if ((f = open_statfile()) == NULL) {\n+  if ((f = open_statfile()) == nullptr) {\n@@ -409,1 +409,1 @@\n-    if (fgets(line, sizeof(line), f) != NULL) {\n+    if (fgets(line, sizeof(line), f) != nullptr) {\n@@ -518,1 +518,1 @@\n-  _counters.cpus = NULL;\n+  _counters.cpus = nullptr;\n@@ -545,1 +545,1 @@\n-  if (_counters.cpus != NULL) {\n+  if (_counters.cpus != nullptr) {\n@@ -576,3 +576,3 @@\n-  assert(pjvmUserLoad != NULL, \"pjvmUserLoad not inited\");\n-  assert(pjvmKernelLoad != NULL, \"pjvmKernelLoad not inited\");\n-  assert(psystemTotalLoad != NULL, \"psystemTotalLoad not inited\");\n+  assert(pjvmUserLoad != nullptr, \"pjvmUserLoad not inited\");\n+  assert(pjvmKernelLoad != nullptr, \"pjvmKernelLoad not inited\");\n+  assert(psystemTotalLoad != nullptr, \"psystemTotalLoad not inited\");\n@@ -606,1 +606,1 @@\n-  _impl = NULL;\n+  _impl = nullptr;\n@@ -615,1 +615,1 @@\n-  if (_impl != NULL) {\n+  if (_impl != nullptr) {\n@@ -688,1 +688,1 @@\n-  assert(name != NULL, \"name pointer is NULL!\");\n+  assert(name != nullptr, \"name pointer is null!\");\n@@ -726,2 +726,2 @@\n-  if ((fp = os::fopen(buffer, \"r\")) != NULL) {\n-    if (fgets(buffer, PATH_MAX, fp) != NULL) {\n+  if ((fp = os::fopen(buffer, \"r\")) != nullptr) {\n+    if (fgets(buffer, PATH_MAX, fp) != nullptr) {\n@@ -731,1 +731,1 @@\n-      if (start != NULL && start[1] != '\\0') {\n+      if (start != nullptr && start[1] != '\\0') {\n@@ -734,1 +734,1 @@\n-        if (end != NULL) {\n+        if (end != nullptr) {\n@@ -750,1 +750,1 @@\n-  char* cmdline = NULL;\n+  char* cmdline = nullptr;\n@@ -754,1 +754,1 @@\n-  if ((fp = os::fopen(buffer, \"r\")) != NULL) {\n+  if ((fp = os::fopen(buffer, \"r\")) != nullptr) {\n@@ -793,1 +793,1 @@\n-  if (str != NULL) {\n+  if (str != nullptr) {\n@@ -796,1 +796,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -809,1 +809,1 @@\n-  if (get_exe_path() != NULL) {\n+  if (get_exe_path() != nullptr) {\n@@ -813,1 +813,1 @@\n-  char* cmdline = NULL;\n+  char* cmdline = nullptr;\n@@ -815,1 +815,1 @@\n-  if (cmdline != NULL) {\n+  if (cmdline != nullptr) {\n@@ -830,1 +830,1 @@\n-    if (_entry == NULL) {\n+    if (_entry == nullptr) {\n@@ -842,2 +842,2 @@\n-  _dir = NULL;\n-  _entry = NULL;\n+  _dir = nullptr;\n+  _entry = nullptr;\n@@ -849,1 +849,1 @@\n-  _entry = NULL;\n+  _entry = nullptr;\n@@ -857,1 +857,1 @@\n-  if (_dir != NULL) {\n+  if (_dir != nullptr) {\n@@ -863,1 +863,1 @@\n-  _iterator = NULL;\n+  _iterator = nullptr;\n@@ -872,1 +872,1 @@\n-  if (_iterator != NULL) {\n+  if (_iterator != nullptr) {\n@@ -878,3 +878,3 @@\n-  assert(system_processes != NULL, \"system_processes pointer is NULL!\");\n-  assert(no_of_sys_processes != NULL, \"system_processes counter pointers is NULL!\");\n-  assert(_iterator != NULL, \"iterator is NULL!\");\n+  assert(system_processes != nullptr, \"system_processes pointer is null!\");\n+  assert(no_of_sys_processes != nullptr, \"system_processes counter pointers is null!\");\n+  assert(_iterator != nullptr, \"iterator is null!\");\n@@ -884,1 +884,1 @@\n-  *system_processes = NULL;\n+  *system_processes = nullptr;\n@@ -891,1 +891,1 @@\n-    if (*system_processes != NULL) {\n+    if (*system_processes != nullptr) {\n@@ -910,1 +910,1 @@\n-  _impl = NULL;\n+  _impl = nullptr;\n@@ -919,1 +919,1 @@\n-  if (_impl != NULL) {\n+  if (_impl != nullptr) {\n@@ -925,1 +925,1 @@\n-  _cpu_info = NULL;\n+  _cpu_info = nullptr;\n@@ -940,2 +940,2 @@\n-  if (_cpu_info != NULL) {\n-    if (_cpu_info->cpu_name() != NULL) {\n+  if (_cpu_info != nullptr) {\n+    if (_cpu_info->cpu_name() != nullptr) {\n@@ -944,1 +944,1 @@\n-      _cpu_info->set_cpu_name(NULL);\n+      _cpu_info->set_cpu_name(nullptr);\n@@ -946,1 +946,1 @@\n-    if (_cpu_info->cpu_description() != NULL) {\n+    if (_cpu_info->cpu_description() != nullptr) {\n@@ -949,1 +949,1 @@\n-      _cpu_info->set_cpu_description(NULL);\n+      _cpu_info->set_cpu_description(nullptr);\n@@ -956,1 +956,1 @@\n-  if (_cpu_info == NULL) {\n+  if (_cpu_info == nullptr) {\n@@ -1003,1 +1003,1 @@\n-  int64_t value = strtoll(buf, NULL, 10);\n+  int64_t value = strtoll(buf, nullptr, 10);\n@@ -1017,3 +1017,3 @@\n-  NetworkInterface* ret = NULL;\n-  for (cur_address = addresses; cur_address != NULL; cur_address = cur_address->ifa_next) {\n-    if ((cur_address->ifa_addr == NULL) || (cur_address->ifa_addr->sa_family != AF_PACKET)) {\n+  NetworkInterface* ret = nullptr;\n+  for (cur_address = addresses; cur_address != nullptr; cur_address = cur_address->ifa_next) {\n+    if ((cur_address->ifa_addr == nullptr) || (cur_address->ifa_addr->sa_family != AF_PACKET)) {\n@@ -1037,1 +1037,1 @@\n-  _impl = NULL;\n+  _impl = nullptr;\n@@ -1041,1 +1041,1 @@\n-  if (_impl != NULL) {\n+  if (_impl != nullptr) {\n","filename":"src\/hotspot\/os\/linux\/os_perf_linux.cpp","additions":53,"deletions":53,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-    JavaPermission p = { \"java.lang.management.ManagementPermission\", \"control\", NULL };\n+    JavaPermission p = { \"java.lang.management.ManagementPermission\", \"control\", nullptr };\n","filename":"src\/hotspot\/os\/linux\/trimCHeapDCmd.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-  return syscall(SYS_futex, addr, futex_op, op_arg, NULL, NULL, 0);\n+  return syscall(SYS_futex, addr, futex_op, op_arg, nullptr, nullptr, 0);\n","filename":"src\/hotspot\/os\/linux\/waitBarrier_linux.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1906,1 +1906,1 @@\n-  st->print(\" %dk page\", os::vm_page_size()>>10);\n+  st->print(\" \" SIZE_FORMAT \"k page\", os::vm_page_size()>>10);\n@@ -2505,1 +2505,1 @@\n-      int page_size = os::vm_page_size();\n+      size_t page_size = os::vm_page_size();\n@@ -3162,1 +3162,1 @@\n-  const size_t default_page_size = (size_t) os::vm_page_size();\n+  const size_t default_page_size = os::vm_page_size();\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-  const int page_size = os::vm_page_size();\n+  const size_t page_size = os::vm_page_size();\n","filename":"src\/hotspot\/os\/windows\/os_windows.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-  if (*fr->sp() == nullptr) {\n+  if (*fr->sp() == (intptr_t) nullptr) {\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/os_aix_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -558,1 +558,1 @@\n-    int page_size = os::vm_page_size();\n+    size_t page_size = os::vm_page_size();\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/os_bsd_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2016, 2019 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n@@ -175,1 +175,8 @@\n-      return frame(fr->sender_sp(), fr->native_sender_pc());\n+      intptr_t* sender_sp = fr->sender_sp();\n+      address   sender_fp = (address)*sender_sp;\n+      ptrdiff_t entry_len = sender_fp - (address)sender_sp;\n+      if (entry_len < frame::z_abi_160_size) {\n+        return frame(sender_sp, fr->sender_pc());\n+      } else {\n+        return frame(sender_sp, fr->native_sender_pc());\n+      }\n","filename":"src\/hotspot\/os_cpu\/linux_s390\/os_linux_s390.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -352,1 +352,1 @@\n-    int page_size = os::vm_page_size();\n+    size_t page_size = os::vm_page_size();\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,1 +136,1 @@\n-  const int page_size = os::vm_page_size();\n+  const int page_size = (int)os::vm_page_size();\n@@ -249,1 +249,1 @@\n-  return offset < 0 || offset >= os::vm_page_size();\n+  return offset < 0 || offset >= static_cast<intptr_t>(os::vm_page_size());\n","filename":"src\/hotspot\/share\/asm\/assembler.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+#define __ masm.\n+\n@@ -49,1 +51,1 @@\n-    address stub = masm.start_a_stub(CompiledStaticCall::to_interp_stub_size());\n+    address stub = __ start_a_stub(CompiledStaticCall::to_interp_stub_size());\n@@ -58,1 +60,1 @@\n-      masm.relocate(static_stub_Relocation::spec(caller_pc), relocate_format);\n+      __ relocate(static_stub_Relocation::spec(caller_pc), relocate_format);\n@@ -61,2 +63,2 @@\n-    masm.emit_static_call_stub();\n-    masm.end_a_stub();\n+    __ emit_static_call_stub();\n+    __ end_a_stub();\n@@ -67,0 +69,2 @@\n+#undef __\n+\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.inline.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"sanitizers\/leak.hpp\"\n@@ -53,0 +54,2 @@\n+  \/\/ Ignore leaked arena, it is used by ValueType and Interval during initialization.\n+  LSAN_IGNORE_OBJECT(arena);\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+#include \"sanitizers\/leak.hpp\"\n@@ -993,0 +994,2 @@\n+    \/\/ Register CDS memory region with LSan.\n+    LSAN_REGISTER_ROOT_REGION(cds_base, cds_end - cds_base);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1627,1 +1627,2 @@\n-  _irreducible_entry = false;\n+  _irreducible_loop_head = false;\n+  _irreducible_loop_secondary_entry = false;\n@@ -1845,0 +1846,34 @@\n+\/\/ Analogous to PhaseIdealLoop::is_in_irreducible_loop\n+bool ciTypeFlow::Block::is_in_irreducible_loop() const {\n+  if (!outer()->has_irreducible_entry()) {\n+    return false; \/\/ No irreducible loop in method.\n+  }\n+  Loop* lp = loop(); \/\/ Innermost loop containing block.\n+  if (lp == nullptr) {\n+    assert(!is_post_visited(), \"must have enclosing loop once post-visited\");\n+    return false; \/\/ Not yet processed, so we do not know, yet.\n+  }\n+  \/\/ Walk all the way up the loop-tree, search for an irreducible loop.\n+  do {\n+    if (lp->is_irreducible()) {\n+      return true; \/\/ We are in irreducible loop.\n+    }\n+    if (lp->head()->pre_order() == 0) {\n+      return false; \/\/ Found root loop, terminate.\n+    }\n+    lp = lp->parent();\n+  } while (lp != nullptr);\n+  \/\/ We have \"lp->parent() == nullptr\", which happens only for infinite loops,\n+  \/\/ where no parent is attached to the loop. We did not find any irreducible\n+  \/\/ loop from this block out to lp. Thus lp only has one entry, and no exit\n+  \/\/ (it is infinite and reducible). We can always rewrite an infinite loop\n+  \/\/ that is nested inside other loops:\n+  \/\/ while(condition) { infinite_loop; }\n+  \/\/ with an equivalent program where the infinite loop is an outermost loop\n+  \/\/ that is not nested in any loop:\n+  \/\/ while(condition) { break; } infinite_loop;\n+  \/\/ Thus, we can understand lp as an outermost loop, and can terminate and\n+  \/\/ conclude: this block is in no irreducible loop.\n+  return false;\n+}\n+\n@@ -1889,1 +1924,3 @@\n-  if (is_irreducible_entry()) st->print(\" irred\");\n+  if (is_in_irreducible_loop()) st->print(\" in_irred\");\n+  if (is_irreducible_loop_head()) st->print(\" irred_head\");\n+  if (is_irreducible_loop_secondary_entry()) st->print(\" irred_entry\");\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.cpp","additions":39,"deletions":2,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -538,2 +538,5 @@\n-    \/\/ This block is entry to irreducible loop.\n-    bool                             _irreducible_entry;\n+    \/\/ This block is a loop head of an irreducible loop.\n+    bool                             _irreducible_loop_head;\n+\n+    \/\/ This block is a secondary entry to an irreducible loop (entry but not head).\n+    bool                             _irreducible_loop_secondary_entry;\n@@ -690,2 +693,5 @@\n-    void   set_irreducible_entry(bool c) { _irreducible_entry = c; }\n-    bool   is_irreducible_entry() const  { return _irreducible_entry; }\n+    bool   is_in_irreducible_loop() const;\n+    void   set_irreducible_loop_head()   { _irreducible_loop_head = true; }\n+    bool   is_irreducible_loop_head() const { return _irreducible_loop_head; }\n+    void   set_irreducible_loop_secondary_entry() { _irreducible_loop_secondary_entry = true; }\n+    bool   is_irreducible_loop_secondary_entry() const { return _irreducible_loop_secondary_entry; }\n@@ -758,1 +764,2 @@\n-      entry->set_irreducible_entry(true);\n+      head()->set_irreducible_loop_head();\n+      entry->set_irreducible_loop_secondary_entry();\n@@ -882,1 +889,1 @@\n-  Loop* loop_tree_root()              { return _loop_tree_root; }\n+  Loop* loop_tree_root() const        { return _loop_tree_root; }\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.hpp","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1898,1 +1898,0 @@\n-                                      bool need_verify,\n@@ -1909,1 +1908,1 @@\n-  \/\/ check code_attribute_length first\n+  \/\/ check code_attribute_length\n@@ -1912,3 +1911,0 @@\n-  if (!need_verify && !DumpSharedSpaces) {\n-    return nullptr;\n-  }\n@@ -2538,1 +2534,1 @@\n-          stackmap_data = parse_stackmap_table(cfs, code_attribute_length, _need_verify, CHECK_NULL);\n+          stackmap_data = parse_stackmap_table(cfs, code_attribute_length, CHECK_NULL);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4671,1 +4671,1 @@\n-    _page_size = os::vm_page_size();\n+    _page_size = (int)os::vm_page_size();\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1452,5 +1452,3 @@\n-    if (!info.is_excluded()) {\n-      bool created;\n-      _cloned_table->put_if_absent(k, info, &created);\n-      assert(created, \"must be\");\n-    }\n+    bool created;\n+    _cloned_table->put_if_absent(k, info, &created);\n+    assert(created, \"must be\");\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1214,0 +1214,10 @@\n+  do_intrinsic(_IndexPartiallyInUpperRange, jdk_internal_vm_vector_VectorSupport, index_partially_in_upper_range_name, index_partially_in_upper_range_sig, F_S)\\\n+    do_signature(index_partially_in_upper_range_sig, \"(Ljava\/lang\/Class;\"                                                                                      \\\n+                                                     \"Ljava\/lang\/Class;\"                                                                                       \\\n+                                                     \"I\"                                                                                                       \\\n+                                                     \"J\"                                                                                                       \\\n+                                                     \"J\"                                                                                                       \\\n+                                                     \"Ljdk\/internal\/vm\/vector\/VectorSupport$IndexPartiallyInUpperRangeOperation;)\"                             \\\n+                                                     \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMask;\")                                                      \\\n+    do_name(index_partially_in_upper_range_name, \"indexPartiallyInUpperRange\")                                                                                 \\\n+                                                                                                                               \\\n@@ -1322,1 +1332,1 @@\n-  LAST_COMPILER_INLINE = _IndexVector,\n+  LAST_COMPILER_INLINE = _IndexPartiallyInUpperRange,\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+#include \"sanitizers\/leak.hpp\"\n@@ -170,1 +171,1 @@\n-int CodeCache::_number_of_nmethods_with_dependencies = 0;\n+volatile int CodeCache::_number_of_nmethods_with_dependencies = 0;\n@@ -314,1 +315,1 @@\n-  const size_t alignment = MAX2(page_size(false, 8), (size_t) os::vm_allocation_granularity());\n+  const size_t alignment = MAX2(page_size(false, 8), os::vm_allocation_granularity());\n@@ -332,0 +333,3 @@\n+  \/\/ Register CodeHeaps with LSan as we sometimes embed pointers to malloc memory.\n+  LSAN_REGISTER_ROOT_REGION(rs.base(), rs.size());\n+\n@@ -356,1 +360,1 @@\n-  const size_t rs_align = MAX2(rs_ps, (size_t) os::vm_allocation_granularity());\n+  const size_t rs_align = MAX2(rs_ps, os::vm_allocation_granularity());\n@@ -586,1 +590,1 @@\n-      _number_of_nmethods_with_dependencies--;\n+      Atomic::dec(&_number_of_nmethods_with_dependencies);\n@@ -621,1 +625,1 @@\n-      _number_of_nmethods_with_dependencies++;\n+      Atomic::inc(&_number_of_nmethods_with_dependencies);\n@@ -1197,0 +1201,2 @@\n+    \/\/ Register CodeHeaps with LSan as we sometimes embed pointers to malloc memory.\n+    LSAN_REGISTER_ROOT_REGION(rs.base(), rs.size());\n@@ -1216,2 +1222,2 @@\n-int CodeCache::number_of_nmethods_with_dependencies() {\n-  return _number_of_nmethods_with_dependencies;\n+bool CodeCache::has_nmethods_with_dependencies() {\n+  return Atomic::load_acquire(&_number_of_nmethods_with_dependencies) != 0;\n@@ -1428,1 +1434,3 @@\n-  if (number_of_nmethods_with_dependencies() == 0) return;\n+  if (!has_nmethods_with_dependencies()) {\n+    return;\n+  }\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -96,3 +96,3 @@\n-  static address _low_bound;                            \/\/ Lower bound of CodeHeap addresses\n-  static address _high_bound;                           \/\/ Upper bound of CodeHeap addresses\n-  static int _number_of_nmethods_with_dependencies;     \/\/ Total number of nmethods with dependencies\n+  static address _low_bound;                                 \/\/ Lower bound of CodeHeap addresses\n+  static address _high_bound;                                \/\/ Upper bound of CodeHeap addresses\n+  static volatile int _number_of_nmethods_with_dependencies; \/\/ Total number of nmethods with dependencies\n@@ -206,0 +206,7 @@\n+  \/\/ Arm nmethods so that special actions are taken (nmethod_entry_barrier) for\n+  \/\/ on-stack nmethods. It's used in two places:\n+  \/\/ 1. Used before the start of concurrent marking so that oops inside\n+  \/\/    on-stack nmethods are visited.\n+  \/\/ 2. Used at the end of (stw\/concurrent) marking so that nmethod::_gc_epoch\n+  \/\/    is up-to-date, which provides more accurate estimate of\n+  \/\/    nmethod::is_cold.\n@@ -319,2 +326,2 @@\n-  \/\/ tells how many nmethods have dependencies\n-  static int number_of_nmethods_with_dependencies();\n+  \/\/ tells if there are nmethods with dependencies\n+  static bool has_nmethods_with_dependencies();\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"sanitizers\/leak.hpp\"\n@@ -275,0 +276,3 @@\n+    \/\/ LSan appears unable to follow malloc-based memory consistently when embedded as an immediate\n+    \/\/ in generated machine code. So we have to ignore it.\n+    LSAN_IGNORE_OBJECT(holder);\n@@ -445,0 +449,3 @@\n+      \/\/ LSan appears unable to follow malloc-based memory consistently when embedded as an\n+      \/\/ immediate in generated machine code. So we have to ignore it.\n+      LSAN_IGNORE_OBJECT(holder);\n","filename":"src\/hotspot\/share\/code\/compiledIC.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-  size_t align = MAX2((size_t)os::vm_allocation_granularity(), page_size);\n+  size_t align = MAX2(os::vm_allocation_granularity(), page_size);\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonArguments.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1013,1 +1013,1 @@\n-void G1CollectedHeap::prepare_heap_for_mutators() {\n+void G1CollectedHeap::prepare_for_mutator_after_full_collection() {\n@@ -1028,1 +1028,0 @@\n-  \/\/ Start a new incremental collection set for the next pause\n@@ -1030,1 +1029,0 @@\n-\n@@ -1869,26 +1867,0 @@\n-#ifndef PRODUCT\n-void G1CollectedHeap::allocate_dummy_regions() {\n-  \/\/ Let's fill up most of the region\n-  size_t word_size = HeapRegion::GrainWords - 1024;\n-  \/\/ And as a result the region we'll allocate will be humongous.\n-  guarantee(is_humongous(word_size), \"sanity\");\n-\n-  \/\/ _filler_array_max_size is set to humongous object threshold\n-  \/\/ but temporarily change it to use CollectedHeap::fill_with_object().\n-  AutoModifyRestore<size_t> temporarily(_filler_array_max_size, word_size);\n-\n-  for (uintx i = 0; i < G1DummyRegionsPerGC; ++i) {\n-    \/\/ Let's use the existing mechanism for the allocation\n-    HeapWord* dummy_obj = humongous_obj_allocate(word_size);\n-    if (dummy_obj != NULL) {\n-      MemRegion mr(dummy_obj, word_size);\n-      CollectedHeap::fill_with_object(mr);\n-    } else {\n-      \/\/ If we can't allocate once, we probably cannot allocate\n-      \/\/ again. Let's get out of the loop.\n-      break;\n-    }\n-  }\n-}\n-#endif \/\/ !PRODUCT\n-\n@@ -2645,2 +2617,0 @@\n-  double start = os::elapsedTime();\n-\n@@ -2657,2 +2627,0 @@\n-\n-  phase_times()->record_start_new_cset_time_ms((os::elapsedTime() - start) * 1000.0);\n@@ -2768,1 +2736,1 @@\n-void G1CollectedHeap::prepare_tlabs_for_mutator() {\n+void G1CollectedHeap::prepare_for_mutator_after_young_collection() {\n@@ -2774,2 +2742,2 @@\n-  allocate_dummy_regions();\n-\n+  \/\/ Start a new incremental collection set for the mutator phase.\n+  start_new_collection_set();\n@@ -2778,3 +2746,1 @@\n-  resize_all_tlabs();\n-\n-  phase_times()->record_resize_tlab_time_ms((Ticks::now() - start).seconds() * 1000.0);\n+  phase_times()->record_prepare_for_mutator_time_ms((Ticks::now() - start).seconds() * 1000.0);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":5,"deletions":39,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+#include \"runtime\/threadSMR.hpp\"\n@@ -123,0 +124,26 @@\n+\/\/ Helper to claim contiguous sets of JavaThread for processing by multiple threads.\n+class G1JavaThreadsListClaimer : public StackObj {\n+  ThreadsListHandle _list;\n+  uint _claim_step;\n+\n+  volatile uint _cur_claim;\n+\n+  \/\/ Attempts to claim _claim_step JavaThreads, returning an array of claimed\n+  \/\/ JavaThread* with count elements. Returns null (and a zero count) if there\n+  \/\/ are no more threads to claim.\n+  JavaThread* const* claim(uint& count);\n+\n+public:\n+  G1JavaThreadsListClaimer(uint claim_step) : _list(), _claim_step(claim_step), _cur_claim(0) {\n+    assert(claim_step > 0, \"must be\");\n+  }\n+\n+  \/\/ Executes the given closure on the elements of the JavaThread list, chunking the\n+  \/\/ JavaThread set in claim_step chunks for each caller to reduce parallelization\n+  \/\/ overhead.\n+  void apply(ThreadClosure* cl);\n+\n+  \/\/ Total number of JavaThreads that can be claimed.\n+  uint length() const { return _list.length(); }\n+};\n+\n@@ -276,8 +303,0 @@\n-  \/\/ This is a non-product method that is helpful for testing. It is\n-  \/\/ called at the end of a GC and artificially expands the heap by\n-  \/\/ allocating a number of dead regions. This way we can induce very\n-  \/\/ frequent marking cycles and stress the cleanup \/ concurrent\n-  \/\/ cleanup code more (as all the regions that will be allocated by\n-  \/\/ this method will be found dead by the marking cycle).\n-  void allocate_dummy_regions() PRODUCT_RETURN;\n-\n@@ -494,1 +513,1 @@\n-  void prepare_heap_for_mutators();\n+  void prepare_for_mutator_after_full_collection();\n@@ -774,1 +793,1 @@\n-  void prepare_tlabs_for_mutator();\n+  void prepare_for_mutator_after_young_collection();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":29,"deletions":10,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"runtime\/threadSMR.inline.hpp\"\n@@ -52,0 +53,24 @@\n+inline JavaThread* const* G1JavaThreadsListClaimer::claim(uint& count) {\n+  count = 0;\n+  if (Atomic::load(&_cur_claim) >= _list.length()) {\n+    return nullptr;\n+  }\n+  uint claim = Atomic::fetch_and_add(&_cur_claim, _claim_step);\n+  if (claim >= _list.length()) {\n+    return nullptr;\n+  }\n+  count = MIN2(_list.length() - claim, _claim_step);\n+  return _list.list()->threads() + claim;\n+}\n+\n+inline void G1JavaThreadsListClaimer::apply(ThreadClosure* cl) {\n+  JavaThread* const* list;\n+  uint count;\n+\n+  while ((list = claim(count)) != nullptr) {\n+    for (uint i = 0; i < count; i++) {\n+      cl->do_thread(list[i]);\n+    }\n+  }\n+}\n+\n@@ -217,1 +242,1 @@\n-  Klass* k = obj->klass();\n+  Klass* k = obj->klass_raw();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -231,1 +231,1 @@\n-  _heap->prepare_heap_for_mutators();\n+  _heap->prepare_for_mutator_after_full_collection();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-      assert(false, \"Failed\");\n+      fatal(\"there should not have been any failures\");\n@@ -151,1 +151,1 @@\n-        assert(false, \"Failed\");\n+        fatal(\"there should not have been any failures\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -156,0 +156,2 @@\n+  _gc_par_phases[ResizeThreadLABs] = new WorkerDataArray<double>(\"ResizeTLABs\", \"Resize TLABs (ms):\", max_gc_threads);\n+\n@@ -176,1 +178,0 @@\n-  _cur_resize_tlab_time_ms = 0.0;\n@@ -187,1 +188,1 @@\n-  _recorded_start_new_cset_time_ms = 0.0;\n+  _recorded_prepare_for_mutator_time_ms = 0.0;\n@@ -492,1 +493,1 @@\n-                        _recorded_start_new_cset_time_ms +\n+                        _recorded_prepare_for_mutator_time_ms +\n@@ -530,0 +531,3 @@\n+  if (UseTLAB && ResizeTLAB) {\n+    debug_phase(_gc_par_phases[ResizeThreadLABs], 1);\n+  }\n@@ -540,4 +544,1 @@\n-  debug_time(\"Start New Collection Set\", _recorded_start_new_cset_time_ms);\n-  if (UseTLAB && ResizeTLAB) {\n-    debug_time(\"Resize TLABs\", _cur_resize_tlab_time_ms);\n-  }\n+  debug_time(\"Prepare For Mutator\", _recorded_prepare_for_mutator_time_ms);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+    ResizeThreadLABs,\n@@ -182,1 +183,0 @@\n-  double _cur_resize_tlab_time_ms;\n@@ -202,1 +202,1 @@\n-  double _recorded_start_new_cset_time_ms;\n+  double _recorded_prepare_for_mutator_time_ms;\n@@ -279,4 +279,0 @@\n-  void record_resize_tlab_time_ms(double ms) {\n-    _cur_resize_tlab_time_ms = ms;\n-  }\n-\n@@ -359,2 +355,2 @@\n-  void record_start_new_cset_time_ms(double time_ms) {\n-    _recorded_start_new_cset_time_ms = time_ms;\n+  void record_prepare_for_mutator_time_ms(double time_ms) {\n+    _recorded_prepare_for_mutator_time_ms = time_ms;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.hpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,2 @@\n-  _committed(mtGC), _dirty(mtGC), _special(false), _executable(false) {\n+  _committed(mtGC), _dirty(mtGC), _special(false) {\n+  assert(!rs.executable(), \"precondition\");\n@@ -52,1 +53,1 @@\n-            \"Given used reserved space size needs to be OS page size aligned (%d bytes) but is \" SIZE_FORMAT, os::vm_page_size(), used_size);\n+            \"Given used reserved space size needs to be OS page size aligned (\" SIZE_FORMAT \" bytes) but is \" SIZE_FORMAT, os::vm_page_size(), used_size);\n@@ -62,1 +63,0 @@\n-  _executable = rs.executable();\n@@ -82,1 +82,0 @@\n-  _executable             = false;\n@@ -143,1 +142,1 @@\n-  os::commit_memory_or_exit(start_addr, size, _page_size, _executable, \"G1 virtual space\");\n+  os::commit_memory_or_exit(start_addr, size, _page_size, false, \"G1 virtual space\");\n@@ -150,1 +149,1 @@\n-  os::commit_memory_or_exit(aligned_end_address, _tail_size, os::vm_page_size(), _executable, \"G1 virtual space\");\n+  os::commit_memory_or_exit(aligned_end_address, _tail_size, os::vm_page_size(), false, \"G1 virtual space\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1PageBasedVirtualSpace.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -74,3 +74,0 @@\n-  \/\/ Indicates whether the committed space should be executable.\n-  bool _executable;\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1PageBasedVirtualSpace.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-  _region_granularity(region_granularity),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionToSpaceMapper.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-  size_t _region_granularity;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionToSpaceMapper.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1025,3 +1025,1 @@\n-  _g1h->start_new_collection_set();\n-\n-  _g1h->prepare_tlabs_for_mutator();\n+  _g1h->prepare_for_mutator_after_young_collection();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+#include \"runtime\/threads.hpp\"\n+#include \"runtime\/threadSMR.hpp\"\n@@ -704,0 +706,25 @@\n+class G1PostEvacuateCollectionSetCleanupTask2::ResizeTLABsTask : public G1AbstractSubTask {\n+  G1JavaThreadsListClaimer _claimer;\n+\n+  \/\/ There is not much work per thread so the number of threads per worker is high.\n+  static const uint ThreadsPerWorker = 250;\n+\n+public:\n+  ResizeTLABsTask() : G1AbstractSubTask(G1GCPhaseTimes::ResizeThreadLABs), _claimer(ThreadsPerWorker) { }\n+\n+  void do_work(uint worker_id) override {\n+    class ResizeClosure : public ThreadClosure {\n+    public:\n+\n+      void do_thread(Thread* thread) {\n+        static_cast<JavaThread*>(thread)->tlab().resize();\n+      }\n+    } cl;\n+    _claimer.apply(&cl);\n+  }\n+\n+  double worker_cost() const override {\n+    return (double)_claimer.length() \/ ThreadsPerWorker;\n+  }\n+};\n+\n@@ -725,0 +752,3 @@\n+  if (UseTLAB && ResizeTLAB) {\n+    add_parallel_task(new ResizeTLABsTask());\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+\/\/ - Resize TLABs\n@@ -73,0 +74,1 @@\n+  class ResizeTLABsTask;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -247,5 +247,0 @@\n-  develop(uintx, G1DummyRegionsPerGC, 0,                                    \\\n-          \"The number of dummy regions G1 will allocate at the end of \"     \\\n-          \"each evacuation pause in order to artificially fill up the \"     \\\n-          \"heap and stress the marking implementation.\")                    \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -497,4 +497,0 @@\n-public:\n-  VerifyLiveClosure(G1CollectedHeap* g1h, VerifyOption vo) : G1VerificationClosure(g1h, vo) {}\n-  virtual void do_oop(narrowOop* p) { do_oop_work(p); }\n-  virtual void do_oop(oop* p) { do_oop_work(p); }\n@@ -507,2 +503,0 @@\n-    verify_liveness(p);\n-  }\n@@ -510,2 +504,0 @@\n-  template <class T>\n-  void verify_liveness(T* p) {\n@@ -513,7 +505,3 @@\n-    Log(gc, verify) log;\n-    if (!CompressedOops::is_null(heap_oop)) {\n-      oop obj = CompressedOops::decode_not_null(heap_oop);\n-      bool failed = false;\n-      bool is_in_heap = _g1h->is_in(obj);\n-      if (!is_in_heap || _g1h->is_obj_dead_cond(obj, _vo)) {\n-        MutexLocker x(ParGCRareEvent_lock, Mutex::_no_safepoint_check_flag);\n+    if (CompressedOops::is_null(heap_oop)) {\n+      return;\n+    }\n@@ -521,24 +509,7 @@\n-        if (!_failures) {\n-          log.error(\"----------\");\n-        }\n-        ResourceMark rm;\n-        if (!is_in_heap) {\n-          HeapRegion* from = _g1h->heap_region_containing(p);\n-          log.error(\"Field \" PTR_FORMAT \" of live obj \" PTR_FORMAT \" in region \" HR_FORMAT,\n-                    p2i(p), p2i(_containing_obj), HR_FORMAT_PARAMS(from));\n-          LogStream ls(log.error());\n-          print_object(&ls, _containing_obj);\n-          HeapRegion* const to = _g1h->heap_region_containing(obj);\n-          log.error(\"points to obj \" PTR_FORMAT \" in region \" HR_FORMAT \" remset %s\",\n-                    p2i(obj), HR_FORMAT_PARAMS(to), to->rem_set()->get_state_str());\n-        } else {\n-          HeapRegion* from = _g1h->heap_region_containing(p);\n-          HeapRegion* to = _g1h->heap_region_containing(obj);\n-          log.error(\"Field \" PTR_FORMAT \" of live obj \" PTR_FORMAT \" in region \" HR_FORMAT,\n-                    p2i(p), p2i(_containing_obj), HR_FORMAT_PARAMS(from));\n-          LogStream ls(log.error());\n-          print_object(&ls, _containing_obj);\n-          log.error(\"points to dead obj \" PTR_FORMAT \" in region \" HR_FORMAT,\n-                    p2i(obj), HR_FORMAT_PARAMS(to));\n-          print_object(&ls, obj);\n-        }\n+    oop obj = CompressedOops::decode_raw_not_null(heap_oop);\n+    bool is_in_heap = _g1h->is_in(obj);\n+    if (!is_in_heap || _g1h->is_obj_dead_cond(obj, _vo)) {\n+      MutexLocker x(ParGCRareEvent_lock, Mutex::_no_safepoint_check_flag);\n+\n+      Log(gc, verify) log;\n+      if (!_failures) {\n@@ -546,3 +517,0 @@\n-        _failures = true;\n-        failed = true;\n-        _n_failures++;\n@@ -550,0 +518,19 @@\n+      ResourceMark rm;\n+\n+      HeapRegion* from = _g1h->heap_region_containing(p);\n+      log.error(\"Field \" PTR_FORMAT \" of live obj \" PTR_FORMAT \" in region \" HR_FORMAT,\n+                p2i(p), p2i(_containing_obj), HR_FORMAT_PARAMS(from));\n+      LogStream ls(log.error());\n+      print_object(&ls, _containing_obj);\n+\n+      if (!is_in_heap) {\n+        log.error(\"points to address \" PTR_FORMAT \" outside of heap\", p2i(obj));\n+      } else {\n+        HeapRegion* to = _g1h->heap_region_containing(obj);\n+        log.error(\"points to dead obj \" PTR_FORMAT \" in region \" HR_FORMAT \" remset %s\",\n+                  p2i(obj), HR_FORMAT_PARAMS(to), to->rem_set()->get_state_str());\n+        print_object(&ls, obj);\n+      }\n+      log.error(\"----------\");\n+      _failures = true;\n+      _n_failures++;\n@@ -552,0 +539,6 @@\n+\n+public:\n+  VerifyLiveClosure(G1CollectedHeap* g1h, VerifyOption vo) : G1VerificationClosure(g1h, vo) {}\n+\n+  virtual void do_oop(narrowOop* p) { do_oop_work(p); }\n+  virtual void do_oop(oop* p) { do_oop_work(p); }\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":35,"deletions":42,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -58,3 +58,0 @@\n-  \/\/ Split the given address into region of that card and the card within that\n-  \/\/ region.\n-  inline void split_card(OopOrNarrowOopStar from, uint& card_region, uint& card_within_region) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -510,1 +510,1 @@\n-      && page_size() > (size_t)os::vm_page_size()) {\n+      && page_size() > os::vm_page_size()) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-  const size_t rs_align = page_sz == (size_t) os::vm_page_size() ? 0 :\n+  const size_t rs_align = page_sz == os::vm_page_size() ? 0 :\n","filename":"src\/hotspot\/share\/gc\/parallel\/parMarkBitMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-  void inline_write_ref_field_gc(void* field, oop new_val) {\n+  void inline_write_ref_field_gc(void* field) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCardTable.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -113,6 +113,0 @@\n-  \/\/ Pushes onto the marking stack.  If the marking stack is full,\n-  \/\/ pushes onto the overflow stack.\n-  void stack_push(oop obj);\n-  \/\/ Do not implement an equivalent stack_pop.  Deal with the\n-  \/\/ marking stack and overflow stack directly.\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -448,1 +448,1 @@\n-  const size_t rs_align = page_sz == (size_t) os::vm_page_size() ? 0 :\n+  const size_t rs_align = page_sz == os::vm_page_size() ? 0 :\n@@ -965,1 +965,0 @@\n-  CodeCache::arm_all_nmethods();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -320,1 +320,1 @@\n-    PSScavenge::card_table()->inline_write_ref_field_gc(p, new_obj);\n+    PSScavenge::card_table()->inline_write_ref_field_gc(p);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,8 +66,7 @@\n-\/\/\n-\/\/ DefNewGeneration functions.\n-\n-\/\/ Methods of protected closure types.\n-\n-DefNewGeneration::IsAliveClosure::IsAliveClosure(Generation* young_gen) : _young_gen(young_gen) {\n-  assert(_young_gen->kind() == Generation::DefNew, \"Expected the young generation here\");\n-}\n+class IsAliveClosure: public BoolObjectClosure {\n+  Generation* _young_gen;\n+public:\n+  IsAliveClosure(Generation* young_gen) : _young_gen(young_gen) {\n+    assert(_young_gen->kind() == Generation::DefNew,\n+        \"Expected the young generation here\");\n+  }\n@@ -75,3 +74,20 @@\n-bool DefNewGeneration::IsAliveClosure::do_object_b(oop p) {\n-  return cast_from_oop<HeapWord*>(p) >= _young_gen->reserved().end() || p->is_forwarded();\n-}\n+  bool do_object_b(oop p) {\n+    return cast_from_oop<HeapWord*>(p) >= _young_gen->reserved().end() || p->is_forwarded();\n+  }\n+};\n+\n+class KeepAliveClosure: public OopClosure {\n+  ScanWeakRefClosure* _cl;\n+  CardTableRS* _rs;\n+  HeapWord* _boundary;\n+\n+  template <class T>\n+  inline void do_oop_work(T* p) {\n+#ifdef ASSERT\n+    {\n+      \/\/ We never expect to see a null reference being processed\n+      \/\/ as a weak reference.\n+      oop obj = RawAccess<IS_NOT_NULL>::oop_load(p);\n+      assert (oopDesc::is_oop(obj), \"expected an oop while scanning weak refs\");\n+    }\n+#endif \/\/ ASSERT\n@@ -79,6 +95,1 @@\n-DefNewGeneration::FastKeepAliveClosure::\n-FastKeepAliveClosure(DefNewGeneration* g, ScanWeakRefClosure* cl) :\n-  _cl(cl) {\n-  _rs = GenCollectedHeap::heap()->rem_set();\n-  _boundary = g->reserved().end();\n-}\n+    Devirtualizer::do_oop(_cl, p);\n@@ -86,2 +97,8 @@\n-void DefNewGeneration::FastKeepAliveClosure::do_oop(oop* p)       { DefNewGeneration::FastKeepAliveClosure::do_oop_work(p); }\n-void DefNewGeneration::FastKeepAliveClosure::do_oop(narrowOop* p) { DefNewGeneration::FastKeepAliveClosure::do_oop_work(p); }\n+    \/\/ Optimized for Defnew generation if it's the youngest generation:\n+    \/\/ we set a younger_gen card if we have an older->youngest\n+    \/\/ generation pointer.\n+    oop obj = RawAccess<IS_NOT_NULL>::oop_load(p);\n+    if ((cast_from_oop<HeapWord*>(obj) < _boundary) && GenCollectedHeap::heap()->is_in_reserved(p)) {\n+      _rs->inline_write_ref_field_gc(p);\n+    }\n+  }\n@@ -89,7 +106,6 @@\n-DefNewGeneration::FastEvacuateFollowersClosure::\n-FastEvacuateFollowersClosure(SerialHeap* heap,\n-                             DefNewScanClosure* cur,\n-                             DefNewYoungerGenClosure* older) :\n-  _heap(heap), _scan_cur_or_nonheap(cur), _scan_older(older)\n-{\n-}\n+public:\n+  KeepAliveClosure(DefNewGeneration* g, ScanWeakRefClosure* cl) :\n+    _cl(cl) {\n+    _rs = GenCollectedHeap::heap()->rem_set();\n+    _boundary = g->reserved().end();\n+  }\n@@ -97,6 +113,22 @@\n-void DefNewGeneration::FastEvacuateFollowersClosure::do_void() {\n-  do {\n-    _heap->oop_since_save_marks_iterate(_scan_cur_or_nonheap, _scan_older);\n-  } while (!_heap->no_allocs_since_save_marks());\n-  guarantee(_heap->young_gen()->promo_failure_scan_is_complete(), \"Failed to finish scan\");\n-}\n+  void do_oop(oop* p)       { do_oop_work(p); }\n+  void do_oop(narrowOop* p) { do_oop_work(p); }\n+};\n+\n+class FastEvacuateFollowersClosure: public VoidClosure {\n+  SerialHeap* _heap;\n+  DefNewScanClosure* _scan_cur_or_nonheap;\n+  DefNewYoungerGenClosure* _scan_older;\n+public:\n+  FastEvacuateFollowersClosure(SerialHeap* heap,\n+                               DefNewScanClosure* cur,\n+                               DefNewYoungerGenClosure* older) :\n+    _heap(heap), _scan_cur_or_nonheap(cur), _scan_older(older)\n+  {}\n+\n+  void do_void() {\n+    do {\n+      _heap->oop_since_save_marks_iterate(_scan_cur_or_nonheap, _scan_older);\n+    } while (!_heap->no_allocs_since_save_marks());\n+    guarantee(_heap->young_gen()->promo_failure_scan_is_complete(), \"Failed to finish scan\");\n+  }\n+};\n@@ -581,1 +613,1 @@\n-  FastKeepAliveClosure keep_alive(this, &scan_weak_ref);\n+  KeepAliveClosure keep_alive(this, &scan_weak_ref);\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":65,"deletions":33,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -162,30 +162,0 @@\n- public:  \/\/ was \"protected\" but caused compile error on win32\n-  class IsAliveClosure: public BoolObjectClosure {\n-    Generation* _young_gen;\n-  public:\n-    IsAliveClosure(Generation* young_gen);\n-    bool do_object_b(oop p);\n-  };\n-\n-  class FastKeepAliveClosure: public OopClosure {\n-    ScanWeakRefClosure* _cl;\n-    CardTableRS* _rs;\n-    HeapWord* _boundary;\n-    template <class T> void do_oop_work(T* p);\n-  public:\n-    FastKeepAliveClosure(DefNewGeneration* g, ScanWeakRefClosure* cl);\n-    virtual void do_oop(oop* p);\n-    virtual void do_oop(narrowOop* p);\n-  };\n-\n-  class FastEvacuateFollowersClosure: public VoidClosure {\n-    SerialHeap* _heap;\n-    DefNewScanClosure* _scan_cur_or_nonheap;\n-    DefNewYoungerGenClosure* _scan_older;\n-  public:\n-    FastEvacuateFollowersClosure(SerialHeap* heap,\n-                                 DefNewScanClosure* cur,\n-                                 DefNewYoungerGenClosure* older);\n-    void do_void();\n-  };\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.hpp","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -39,22 +39,0 @@\n-template <class T>\n-inline void DefNewGeneration::FastKeepAliveClosure::do_oop_work(T* p) {\n-#ifdef ASSERT\n-  {\n-    \/\/ We never expect to see a null reference being processed\n-    \/\/ as a weak reference.\n-    oop obj = RawAccess<IS_NOT_NULL>::oop_load(p);\n-    assert (oopDesc::is_oop(obj), \"expected an oop while scanning weak refs\");\n-  }\n-#endif \/\/ ASSERT\n-\n-  Devirtualizer::do_oop(_cl, p);\n-\n-  \/\/ Optimized for Defnew generation if it's the youngest generation:\n-  \/\/ we set a younger_gen card if we have an older->youngest\n-  \/\/ generation pointer.\n-  oop obj = RawAccess<IS_NOT_NULL>::oop_load(p);\n-  if ((cast_from_oop<HeapWord*>(obj) < _boundary) && GenCollectedHeap::heap()->is_in_reserved(p)) {\n-    _rs->inline_write_ref_field_gc(p);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.inline.hpp","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"gc\/shared\/genOopClosures.hpp\"\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,2 +102,2 @@\n-  const size_t rs_align = _page_size == (size_t) os::vm_page_size() ? 0 :\n-    MAX2(_page_size, (size_t) os::vm_allocation_granularity());\n+  const size_t rs_align = _page_size == os::vm_page_size() ? 0 :\n+    MAX2(_page_size, os::vm_allocation_granularity());\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"gc\/shared\/genOopClosures.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableRS.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -605,1 +605,0 @@\n-    CodeCache::arm_all_nmethods();\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -202,1 +202,0 @@\n-    assert(obj != NULL, \"must have a base\");\n@@ -502,4 +501,1 @@\n-  bool anonymous = (decorators & ON_UNKNOWN_OOP_REF) != 0;\n-  bool on_heap = (decorators & IN_HEAP) != 0;\n-\n-  if (!access.is_oop() || (!on_heap && !anonymous)) {\n+  if (!access.is_oop()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2016, 2023, Red Hat, Inc. All rights reserved.\n@@ -62,1 +62,1 @@\n-  size_t page_size = (size_t)os::vm_page_size();\n+  size_t page_size = os::vm_page_size();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -181,3 +181,3 @@\n-  size_t heap_page_size   = UseLargePages ? (size_t)os::large_page_size() : (size_t)os::vm_page_size();\n-  size_t bitmap_page_size = UseLargePages ? (size_t)os::large_page_size() : (size_t)os::vm_page_size();\n-  size_t region_page_size = UseLargePages ? (size_t)os::large_page_size() : (size_t)os::vm_page_size();\n+  size_t heap_page_size   = UseLargePages ? os::large_page_size() : os::vm_page_size();\n+  size_t bitmap_page_size = UseLargePages ? os::large_page_size() : os::vm_page_size();\n+  size_t region_page_size = UseLargePages ? os::large_page_size() : os::vm_page_size();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -555,1 +556,1 @@\n-  int page_size = os::vm_page_size();\n+  size_t page_size = os::vm_page_size();\n@@ -560,1 +561,1 @@\n-      page_size = (int)large_page_size;\n+      page_size = large_page_size;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrier.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,3 @@\n+  if (jt->is_attaching_via_jni()) {\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrThreadIterator.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,1 @@\n-    static int vm_page_size;\n+    static size_t vm_page_size;\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-int CompilerToVM::Data::vm_page_size;\n+size_t CompilerToVM::Data::vm_page_size;\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVMInit.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-  static_field(CompilerToVM::Data,             vm_page_size,                           int)                                          \\\n+  static_field(CompilerToVM::Data,             vm_page_size,                           size_t)                                       \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-  int alignment = os::vm_allocation_granularity();\n+  size_t alignment = os::vm_allocation_granularity();\n","filename":"src\/hotspot\/share\/memory\/allocation.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -186,1 +186,1 @@\n-  const size_t alignment = (size_t)os::vm_page_size();\n+  const size_t alignment = os::vm_page_size();\n@@ -225,1 +225,1 @@\n-  const size_t reserved_segments_alignment = MAX2((size_t)os::vm_page_size(), granularity);\n+  const size_t reserved_segments_alignment = MAX2(os::vm_page_size(), granularity);\n","filename":"src\/hotspot\/share\/memory\/heap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-#include \"sanitizers\/address.h\"\n+#include \"sanitizers\/address.hpp\"\n","filename":"src\/hotspot\/share\/memory\/metaspace\/chunkManager.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-    _commit_granule_bytes = MAX2((size_t)os::vm_page_size(), 64 * K);\n+    _commit_granule_bytes = MAX2(os::vm_page_size(), 64 * K);\n@@ -60,1 +60,1 @@\n-    _commit_granule_bytes = MAX2((size_t)os::vm_page_size(), 16 * K);\n+    _commit_granule_bytes = MAX2(os::vm_page_size(), 16 * K);\n@@ -66,1 +66,1 @@\n-    _commit_granule_bytes = MAX2((size_t)os::vm_page_size(), 64 * K);\n+    _commit_granule_bytes = MAX2(os::vm_page_size(), 64 * K);\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceSettings.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -45,1 +45,2 @@\n-#include \"sanitizers\/address.h\"\n+#include \"sanitizers\/address.hpp\"\n+#include \"sanitizers\/leak.hpp\"\n@@ -242,0 +243,4 @@\n+\n+  \/\/ Register memory region related to Metaspace. The Metaspace contains lots of pointers to malloc\n+  \/\/ memory.\n+  LSAN_REGISTER_ROOT_REGION(rs.base(), rs.size());\n@@ -273,0 +278,3 @@\n+  \/\/ Unregister memory region related to Metaspace.\n+  LSAN_UNREGISTER_ROOT_REGION(_rs.base(), _rs.size());\n+\n@@ -278,0 +286,1 @@\n+\n","filename":"src\/hotspot\/share\/memory\/metaspace\/virtualSpaceNode.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+#include \"sanitizers\/leak.hpp\"\n@@ -754,1 +755,5 @@\n-  CompiledICProtectionBehaviour::set_current(new DefaultICProtectionBehaviour());\n+  DefaultICProtectionBehaviour* protection_behavior = new DefaultICProtectionBehaviour();\n+  \/\/ Ignore leak of DefaultICProtectionBehaviour. It is overriden by some GC implementations and the\n+  \/\/ pointer is leaked once.\n+  LSAN_IGNORE_OBJECT(protection_behavior);\n+  CompiledICProtectionBehaviour::set_current(protection_behavior);\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-  if (preferred_page_size != (size_t)os::vm_page_size()) {\n+  if (preferred_page_size != os::vm_page_size()) {\n@@ -134,1 +134,1 @@\n-         page_size != (size_t) os::vm_page_size();\n+         page_size != os::vm_page_size();\n@@ -259,1 +259,1 @@\n-    } while (page_size > (size_t) os::vm_page_size());\n+    } while (page_size > os::vm_page_size());\n@@ -264,1 +264,1 @@\n-    assert(page_size == (size_t) os::vm_page_size(), \"inv\");\n+    assert(page_size == os::vm_page_size(), \"inv\");\n@@ -287,1 +287,1 @@\n-  assert(page_size >= (size_t) os::vm_page_size(), \"Invalid page size\");\n+  assert(page_size >= os::vm_page_size(), \"Invalid page size\");\n@@ -297,1 +297,1 @@\n-  alignment = MAX2(alignment, (size_t)os::vm_page_size());\n+  alignment = MAX2(alignment, os::vm_page_size());\n@@ -362,1 +362,1 @@\n-  assert(_alignment >= (size_t)os::vm_page_size(), \"must be at least page size big\");\n+  assert(_alignment >= os::vm_page_size(), \"must be at least page size big\");\n@@ -495,1 +495,1 @@\n-  guarantee(alignment == MAX2(alignment, (size_t)os::vm_page_size()), \"alignment too small\");\n+  guarantee(alignment == MAX2(alignment, os::vm_page_size()), \"alignment too small\");\n","filename":"src\/hotspot\/share\/memory\/virtualspace.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -312,1 +312,1 @@\n-                       NULL, 0, dst,\n+                       nullptr, 0, dst,\n@@ -320,1 +320,1 @@\n-    AccessT::arraycopy(NULL, 0, src,\n+    AccessT::arraycopy(nullptr, 0, src,\n@@ -335,2 +335,2 @@\n-    return AccessT::oop_arraycopy(NULL, 0, src,\n-                                  NULL, 0, dst,\n+    return AccessT::oop_arraycopy(nullptr, 0, src,\n+                                  nullptr, 0, dst,\n","filename":"src\/hotspot\/share\/oops\/access.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -214,1 +214,1 @@\n-      assert(bs != NULL, \"GC barriers invoked before BarrierSet is set\");\n+      assert(bs != nullptr, \"GC barriers invoked before BarrierSet is set\");\n@@ -227,1 +227,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -237,1 +237,1 @@\n-      assert(bs != NULL, \"GC barriers invoked before BarrierSet is set\");\n+      assert(bs != nullptr, \"GC barriers invoked before BarrierSet is set\");\n@@ -250,1 +250,1 @@\n-        return NULL;\n+        return nullptr;\n","filename":"src\/hotspot\/share\/oops\/access.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-  if (p != NULL) {\n+  if (p != nullptr) {\n@@ -52,1 +52,1 @@\n-  if (class_annotations() != NULL) {\n+  if (class_annotations() != nullptr) {\n@@ -57,1 +57,1 @@\n-  if (class_type_annotations() != NULL) {\n+  if (class_type_annotations() != nullptr) {\n@@ -67,1 +67,1 @@\n-  if (annotations != NULL) {\n+  if (annotations != nullptr) {\n@@ -75,1 +75,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -84,1 +84,1 @@\n-  it->push(&_fields_type_annotations); \/\/ FIXME: need a test case where _fields_type_annotations != NULL\n+  it->push(&_fields_type_annotations); \/\/ FIXME: need a test case where _fields_type_annotations != nullptr\n","filename":"src\/hotspot\/share\/oops\/annotations.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,4 +73,4 @@\n-  Annotations() : _class_annotations(NULL),\n-                  _fields_annotations(NULL),\n-                  _class_type_annotations(NULL),\n-                  _fields_type_annotations(NULL) {}\n+  Annotations() : _class_annotations(nullptr),\n+                  _fields_annotations(nullptr),\n+                  _class_type_annotations(nullptr),\n+                  _fields_type_annotations(nullptr) {}\n","filename":"src\/hotspot\/share\/oops\/annotations.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n-  if (super() == NULL)  return NULL;  \/\/ bootstrap case\n+  if (super() == nullptr)  return nullptr;  \/\/ bootstrap case\n@@ -64,1 +64,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -89,2 +89,2 @@\n-  _higher_dimension(NULL),\n-  _lower_dimension(NULL) {\n+  _higher_dimension(nullptr),\n+  _lower_dimension(nullptr) {\n@@ -95,1 +95,1 @@\n-  set_super(Universe::is_bootstrapping() ? NULL : vmClasses::Object_klass());\n+  set_super(Universe::is_bootstrapping() ? nullptr : vmClasses::Object_klass());\n@@ -105,1 +105,1 @@\n-  k->initialize_supers(super_klass, NULL, CHECK);\n+  k->initialize_supers(super_klass, nullptr, CHECK);\n@@ -111,1 +111,1 @@\n-  assert((module_entry != NULL) || ((module_entry == NULL) && !ModuleEntryTable::javabase_defined()),\n+  assert((module_entry != nullptr) || ((module_entry == nullptr) && !ModuleEntryTable::javabase_defined()),\n@@ -113,1 +113,1 @@\n-  oop module = (module_entry != NULL) ? module_entry->module() : (oop)NULL;\n+  oop module = (module_entry != nullptr) ? module_entry->module() : (oop)nullptr;\n@@ -121,1 +121,1 @@\n-  assert(transitive_interfaces == NULL, \"sanity\");\n+  assert(transitive_interfaces == nullptr, \"sanity\");\n@@ -124,1 +124,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -134,1 +134,1 @@\n-  \/\/ initialization to NULL not necessary, area already cleared\n+  \/\/ initialization to null not necessary, area already cleared\n@@ -162,1 +162,1 @@\n-  if (_higher_dimension != NULL) {\n+  if (_higher_dimension != nullptr) {\n@@ -170,1 +170,1 @@\n-  if (_higher_dimension != NULL) {\n+  if (_higher_dimension != nullptr) {\n@@ -181,1 +181,1 @@\n-  if (_higher_dimension != NULL) {\n+  if (_higher_dimension != nullptr) {\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,2 +99,2 @@\n-    if (obj != NULL) {\n-      assert(raw == NULL, \"either raw or in-heap\");\n+    if (obj != nullptr) {\n+      assert(raw == nullptr, \"either raw or in-heap\");\n@@ -104,1 +104,1 @@\n-      assert(raw != NULL, \"either raw or in-heap\");\n+      assert(raw != nullptr, \"either raw or in-heap\");\n","filename":"src\/hotspot\/share\/oops\/arrayOop.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-NarrowPtrStruct CompressedOops::_narrow_oop = { NULL, 0, true };\n+NarrowPtrStruct CompressedOops::_narrow_oop = { nullptr, 0, true };\n@@ -82,2 +82,2 @@\n-  assert((intptr_t)base() <= ((intptr_t)_heap_address_range.start() - os::vm_page_size()) ||\n-         base() == NULL, \"invalid value\");\n+  assert((intptr_t)base() <= ((intptr_t)_heap_address_range.start() - (intptr_t)os::vm_page_size()) ||\n+         base() == nullptr, \"invalid value\");\n@@ -151,1 +151,1 @@\n-  return _narrow_oop._base != NULL && is_disjoint_heap_base_address(_narrow_oop._base);\n+  return _narrow_oop._base != nullptr && is_disjoint_heap_base_address(_narrow_oop._base);\n@@ -158,1 +158,1 @@\n-  return _narrow_oop._base != NULL && !is_disjoint_heap_base_address(_narrow_oop._base);\n+  return _narrow_oop._base != nullptr && !is_disjoint_heap_base_address(_narrow_oop._base);\n@@ -182,1 +182,1 @@\n-NarrowPtrStruct CompressedKlassPointers::_narrow_klass = { NULL, 0, true };\n+NarrowPtrStruct CompressedKlassPointers::_narrow_klass = { nullptr, 0, true };\n","filename":"src\/hotspot\/share\/oops\/compressedOops.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-  \/\/ NULL if using wide oops or zero based narrow oops.\n+  \/\/ null if using wide oops or zero based narrow oops.\n@@ -119,1 +119,1 @@\n-  static bool is_null(oop v)       { return v == NULL; }\n+  static bool is_null(oop v)       { return v == nullptr; }\n@@ -130,0 +130,1 @@\n+  static inline oop decode_raw_not_null(oop v);\n@@ -181,1 +182,1 @@\n-  static bool is_null(Klass* v)      { return v == NULL; }\n+  static bool is_null(Klass* v)      { return v == nullptr; }\n","filename":"src\/hotspot\/share\/oops\/compressedOops.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n-  return is_null(v) ? (oop)NULL : decode_not_null(v);\n+  return is_null(v) ? nullptr : decode_not_null(v);\n@@ -81,0 +81,5 @@\n+inline oop CompressedOops::decode_raw_not_null(oop v) {\n+  assert(v != nullptr, \"object is null\");\n+  return v;\n+}\n+\n@@ -140,1 +145,1 @@\n-  return is_null(v) ? (Klass*)NULL : decode_not_null(v);\n+  return is_null(v) ? nullptr : decode_not_null(v);\n","filename":"src\/hotspot\/share\/oops\/compressedOops.inline.hpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,2 +56,2 @@\n-  set_constants(NULL);\n-  set_stackmap_data(NULL);\n+  set_constants(nullptr);\n+  set_stackmap_data(nullptr);\n@@ -65,1 +65,1 @@\n-  set_constants(NULL);\n+  set_constants(nullptr);\n@@ -82,1 +82,1 @@\n-  if (stackmap_data() != NULL) {\n+  if (stackmap_data() != nullptr) {\n@@ -85,1 +85,1 @@\n-  set_stackmap_data(NULL);\n+  set_stackmap_data(nullptr);\n@@ -435,1 +435,1 @@\n-  if (m != NULL) {\n+  if (m != nullptr) {\n@@ -451,1 +451,1 @@\n-  if (m != NULL) {\n+  if (m != nullptr) {\n@@ -454,1 +454,1 @@\n-    st->print(\"NULL\");\n+    st->print(\"null\");\n@@ -463,1 +463,1 @@\n-  guarantee(method() != NULL && method()->is_method(), \"should be method\");\n+  guarantee(method() != nullptr && method()->is_method(), \"should be method\");\n","filename":"src\/hotspot\/share\/oops\/constMethod.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -279,1 +279,1 @@\n-  bool has_stackmap_table() const { return _stackmap_data != NULL; }\n+  bool has_stackmap_table() const { return _stackmap_data != nullptr; }\n@@ -401,1 +401,1 @@\n-    return has_method_annotations() ? *(method_annotations_addr()) : NULL;\n+    return has_method_annotations() ? *(method_annotations_addr()) : nullptr;\n@@ -409,1 +409,1 @@\n-    return has_parameter_annotations() ? *(parameter_annotations_addr()) : NULL;\n+    return has_parameter_annotations() ? *(parameter_annotations_addr()) : nullptr;\n@@ -417,1 +417,1 @@\n-    return has_type_annotations() ? *(type_annotations_addr()) : NULL;\n+    return has_type_annotations() ? *(type_annotations_addr()) : nullptr;\n@@ -425,1 +425,1 @@\n-    return has_default_annotations() ? *(default_annotations_addr()) : NULL;\n+    return has_default_annotations() ? *(default_annotations_addr()) : nullptr;\n","filename":"src\/hotspot\/share\/oops\/constMethod.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-  assert(tags != NULL, \"invariant\");\n+  assert(tags != nullptr, \"invariant\");\n@@ -108,1 +108,1 @@\n-    assert(_tags != NULL, \"invariant\");\n+    assert(_tags != nullptr, \"invariant\");\n@@ -113,1 +113,1 @@\n-    assert(NULL == _pool_holder, \"invariant\");\n+    assert(nullptr == _pool_holder, \"invariant\");\n@@ -117,1 +117,1 @@\n-  if (cache() != NULL) {\n+  if (cache() != nullptr) {\n@@ -119,1 +119,1 @@\n-    set_cache(NULL);\n+    set_cache(nullptr);\n@@ -123,1 +123,1 @@\n-  set_resolved_klasses(NULL);\n+  set_resolved_klasses(nullptr);\n@@ -126,1 +126,1 @@\n-  set_operands(NULL);\n+  set_operands(nullptr);\n@@ -132,1 +132,1 @@\n-  set_tags(NULL);\n+  set_tags(nullptr);\n@@ -167,2 +167,2 @@\n-  if (_cache == NULL) {\n-    return NULL;\n+  if (_cache == nullptr) {\n+    return nullptr;\n@@ -227,1 +227,1 @@\n-  assert(resolved_klasses() == NULL, \"sanity\");\n+  assert(resolved_klasses() == nullptr, \"sanity\");\n@@ -258,1 +258,1 @@\n-  assert(k != NULL, \"must be valid klass\");\n+  assert(k != nullptr, \"must be valid klass\");\n@@ -265,1 +265,1 @@\n-  \/\/ and the Klass* non-NULL, so we need hardware store ordering here.\n+  \/\/ and the Klass* non-null, so we need hardware store ordering here.\n@@ -271,1 +271,1 @@\n-\/\/ Returns nullptr if this class is not supported, or _resolved_reference doesn't exist.\n+\/\/ Returns null if this class is not supported, or _resolved_reference doesn't exist.\n@@ -273,1 +273,1 @@\n-  if (_cache == NULL) {\n+  if (_cache == nullptr) {\n@@ -288,1 +288,1 @@\n-    int ref_map_len = ref_map == NULL ? 0 : ref_map->length();\n+    int ref_map_len = ref_map == nullptr ? 0 : ref_map->length();\n@@ -293,1 +293,1 @@\n-      if (obj != NULL && i < ref_map_len) {\n+      if (obj != nullptr && i < ref_map_len) {\n@@ -310,1 +310,1 @@\n-  if (rr != NULL) {\n+  if (rr != nullptr) {\n@@ -331,1 +331,1 @@\n-  assert(_cache != NULL, \"constant pool _cache should not be NULL\");\n+  assert(_cache != nullptr, \"constant pool _cache should not be null\");\n@@ -334,1 +334,1 @@\n-  if (resolved_references() != NULL) return;\n+  if (resolved_references() != nullptr) return;\n@@ -340,1 +340,1 @@\n-        _cache->archived_references() != NULL) {\n+        _cache->archived_references() != nullptr) {\n@@ -377,1 +377,1 @@\n-    resolved_references() != NULL ? resolved_references()->length() : 0);\n+    resolved_references() != nullptr ? resolved_references()->length() : 0);\n@@ -402,2 +402,2 @@\n-  if (cache() != NULL) {\n-    \/\/ cache() is NULL if this class is not yet linked.\n+  if (cache() != nullptr) {\n+    \/\/ cache() is null if this class is not yet linked.\n@@ -422,1 +422,1 @@\n-  \/\/ k could be NULL if the referenced class has been excluded via\n+  \/\/ k could be null if the referenced class has been excluded via\n@@ -425,1 +425,1 @@\n-  if (k != NULL) {\n+  if (k != nullptr) {\n@@ -439,1 +439,1 @@\n-  resolved_klasses()->at_put(resolved_klass_index, NULL);\n+  resolved_klasses()->at_put(resolved_klass_index, nullptr);\n@@ -460,1 +460,1 @@\n-  const char * source_file = NULL;\n+  const char * source_file = nullptr;\n@@ -467,1 +467,1 @@\n-      if (s != NULL) {\n+      if (s != nullptr) {\n@@ -474,1 +474,1 @@\n-    if (source_file != NULL) {\n+    if (source_file != nullptr) {\n@@ -502,1 +502,1 @@\n-    if (klass != NULL) {\n+    if (klass != nullptr) {\n@@ -548,1 +548,1 @@\n-    assert(klass != NULL, \"must be resolved if exception was cleared\");\n+    assert(klass != nullptr, \"must be resolved if exception was cleared\");\n@@ -560,1 +560,1 @@\n-  \/\/ and the Klass* stored in _resolved_klasses is non-NULL, so we need\n+  \/\/ and the Klass* stored in _resolved_klasses is non-null, so we need\n@@ -571,1 +571,1 @@\n-    this_cp->resolved_klasses()->at_put(resolved_klass_index, NULL);\n+    this_cp->resolved_klasses()->at_put(resolved_klass_index, nullptr);\n@@ -581,1 +581,1 @@\n-\/\/ instanceof operations. Returns NULL if the class has not been loaded or\n+\/\/ instanceof operations. Returns null if the class has not been loaded or\n@@ -591,1 +591,1 @@\n-    assert(k != NULL, \"should be resolved\");\n+    assert(k != nullptr, \"should be resolved\");\n@@ -594,1 +594,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -605,1 +605,1 @@\n-    if (k != NULL && current->is_Java_thread()) {\n+    if (k != nullptr && current->is_Java_thread()) {\n@@ -609,1 +609,1 @@\n-      \/\/ return NULL if verification fails\n+      \/\/ return null if verification fails\n@@ -613,1 +613,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -624,1 +624,1 @@\n-  if (cpool->cache() == NULL)  return NULL;  \/\/ nothing to load yet\n+  if (cpool->cache() == nullptr)  return nullptr;  \/\/ nothing to load yet\n@@ -629,1 +629,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -637,1 +637,1 @@\n-  if (cpool->cache() == NULL)  return false;  \/\/ nothing to load yet\n+  if (cpool->cache() == nullptr)  return false;  \/\/ nothing to load yet\n@@ -644,1 +644,1 @@\n-  if (cpool->cache() == NULL)  return NULL;  \/\/ nothing to load yet\n+  if (cpool->cache() == nullptr)  return nullptr;  \/\/ nothing to load yet\n@@ -652,1 +652,1 @@\n-  if (cpool->cache() == NULL)  return false;  \/\/ nothing to load yet\n+  if (cpool->cache() == nullptr)  return false;  \/\/ nothing to load yet\n@@ -671,1 +671,1 @@\n-  if (!uncached && cache() != NULL) {\n+  if (!uncached && cache() != nullptr) {\n@@ -696,1 +696,1 @@\n-  if (!uncached && cache() != NULL) {\n+  if (!uncached && cache() != nullptr) {\n@@ -712,1 +712,1 @@\n-  if (!uncached && cache() != NULL) {\n+  if (!uncached && cache() != nullptr) {\n@@ -791,1 +791,1 @@\n-  if (message != NULL) {\n+  if (message != nullptr) {\n@@ -827,3 +827,3 @@\n-  Symbol* cause_sym = NULL;\n-  Symbol* cause_msg = NULL;\n-  if (cause != NULL && cause != pending_exception) {\n+  Symbol* cause_sym = nullptr;\n+  Symbol* cause_msg = nullptr;\n+  if (cause != nullptr && cause != pending_exception) {\n@@ -841,3 +841,3 @@\n-  Symbol* message = NULL;\n-  Symbol* cause = NULL;\n-  Symbol* cause_msg = NULL;\n+  Symbol* message = nullptr;\n+  Symbol* cause = nullptr;\n+  Symbol* cause_msg = nullptr;\n@@ -845,2 +845,2 @@\n-  assert(error != NULL, \"checking\");\n-  const char* cause_str = cause_msg != NULL ? cause_msg->as_C_string() : NULL;\n+  assert(error != nullptr, \"checking\");\n+  const char* cause_str = cause_msg != nullptr ? cause_msg->as_C_string() : nullptr;\n@@ -849,1 +849,1 @@\n-  if (message != NULL) {\n+  if (message != nullptr) {\n@@ -851,1 +851,1 @@\n-    if (cause != NULL) {\n+    if (cause != nullptr) {\n@@ -858,1 +858,1 @@\n-    if (cause != NULL) {\n+    if (cause != nullptr) {\n@@ -929,1 +929,1 @@\n-  oop result_oop = NULL;\n+  oop result_oop = nullptr;\n@@ -945,1 +945,1 @@\n-    if (result_oop != NULL) {\n+    if (result_oop != nullptr) {\n@@ -949,1 +949,1 @@\n-        result_oop = NULL;\n+        result_oop = nullptr;\n@@ -951,1 +951,1 @@\n-      if (status_return != NULL)  (*status_return) = true;\n+      if (status_return != nullptr)  (*status_return) = true;\n@@ -962,1 +962,1 @@\n-  if (status_return != NULL) {\n+  if (status_return != nullptr) {\n@@ -969,1 +969,1 @@\n-      if (this_cp->resolved_klasses()->at(resolved_klass_index) == NULL) {\n+      if (this_cp->resolved_klasses()->at(resolved_klass_index) == nullptr) {\n@@ -971,1 +971,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -985,1 +985,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1031,2 +1031,2 @@\n-        const char* fail = NULL;\n-        if (result_oop == NULL) {\n+        const char* fail = nullptr;\n+        if (result_oop == nullptr) {\n@@ -1040,1 +1040,1 @@\n-        if (fail != NULL) {\n+        if (fail != nullptr) {\n@@ -1166,1 +1166,1 @@\n-    oop new_result = (result_oop == NULL ? Universe::the_null_sentinel() : result_oop);\n+    oop new_result = (result_oop == nullptr ? Universe::the_null_sentinel() : result_oop);\n@@ -1174,1 +1174,1 @@\n-        old_result = NULL;\n+        old_result = nullptr;\n@@ -1185,1 +1185,1 @@\n-  oop str = StringTable::intern(sym, CHECK_(NULL));\n+  oop str = StringTable::intern(sym, CHECK_(nullptr));\n@@ -1231,1 +1231,1 @@\n-  if (str != NULL) return str;\n+  if (str != nullptr) return str;\n@@ -1233,1 +1233,1 @@\n-  str = StringTable::intern(sym, CHECK_(NULL));\n+  str = StringTable::intern(sym, CHECK_(nullptr));\n@@ -1483,1 +1483,1 @@\n-  if ( operands() != NULL) { \/\/ the safety check\n+  if ( operands() != nullptr) { \/\/ the safety check\n@@ -2284,1 +2284,1 @@\n-  if (pool_holder() != NULL) {\n+  if (pool_holder() != nullptr) {\n@@ -2314,1 +2314,1 @@\n-        guarantee(k != NULL, \"need klass\");\n+        guarantee(k != nullptr, \"need klass\");\n@@ -2411,1 +2411,1 @@\n-  if (operands() != NULL)  st->print(\"\/operands[%d]\", operands()->length());\n+  if (operands() != nullptr)  st->print(\"\/operands[%d]\", operands()->length());\n@@ -2413,1 +2413,1 @@\n-  if (pool_holder() != NULL) {\n+  if (pool_holder() != nullptr) {\n@@ -2419,1 +2419,1 @@\n-  if (cache() != NULL) {\n+  if (cache() != nullptr) {\n@@ -2440,2 +2440,2 @@\n-  if (pool_holder() != NULL) {\n-    \/\/ Note: pool_holder() can be NULL in temporary constant pools\n+  if (pool_holder() != nullptr) {\n+    \/\/ Note: pool_holder() can be null in temporary constant pools\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":84,"deletions":84,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -189,1 +189,1 @@\n-      (Symbol*)NULL : symbol_at(_generic_signature_index);\n+      nullptr : symbol_at(_generic_signature_index);\n@@ -197,1 +197,1 @@\n-      (Symbol*)NULL : symbol_at(_source_file_name_index);\n+      nullptr : symbol_at(_source_file_name_index);\n@@ -568,1 +568,1 @@\n-    if (operands == NULL || operands->length() == 0)  return 0;\n+    if (operands == nullptr || operands->length() == 0)  return 0;\n@@ -719,1 +719,1 @@\n-    return resolve_constant_at_impl(h_this, index, _no_index_sentinel, NULL, THREAD);\n+    return resolve_constant_at_impl(h_this, index, _no_index_sentinel, nullptr, THREAD);\n@@ -724,1 +724,1 @@\n-    return resolve_constant_at_impl(h_this, _no_index_sentinel, cache_index, NULL, THREAD);\n+    return resolve_constant_at_impl(h_this, _no_index_sentinel, cache_index, nullptr, THREAD);\n@@ -729,1 +729,1 @@\n-    return resolve_constant_at_impl(h_this, pool_index, _possible_index_sentinel, NULL, THREAD);\n+    return resolve_constant_at_impl(h_this, pool_index, _possible_index_sentinel, nullptr, THREAD);\n@@ -814,1 +814,1 @@\n-  Array<u2>* reference_map() const        {  return (_cache == NULL) ? NULL :  _cache->reference_map(); }\n+  Array<u2>* reference_map() const        {  return (_cache == nullptr) ? nullptr :  _cache->reference_map(); }\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-  _f1 = NULL;\n+  _f1 = nullptr;\n@@ -104,1 +104,1 @@\n-  assert(f1 != NULL, \"\");\n+  assert(f1 != nullptr, \"\");\n@@ -161,1 +161,1 @@\n-  assert(method->interpreter_entry() != NULL, \"should have been set at this point\");\n+  assert(method->interpreter_entry() != nullptr, \"should have been set at this point\");\n@@ -166,1 +166,1 @@\n-  InstanceKlass* holder = NULL;  \/\/ have to declare this outside the switch\n+  InstanceKlass* holder = nullptr;  \/\/ have to declare this outside the switch\n@@ -399,1 +399,1 @@\n-  LogStream* log_stream = NULL;\n+  LogStream* log_stream = nullptr;\n@@ -446,1 +446,1 @@\n-  if (log_stream != NULL) {\n+  if (log_stream != nullptr) {\n@@ -486,1 +486,1 @@\n-    if (f1 != NULL) {\n+    if (f1 != nullptr) {\n@@ -524,1 +524,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -530,1 +530,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -566,1 +566,1 @@\n-  assert (_f1 != NULL, \"should not call with uninteresting entry\");\n+  assert (_f1 != nullptr, \"should not call with uninteresting entry\");\n@@ -584,1 +584,1 @@\n-  if (m != NULL) {\n+  if (m != nullptr) {\n@@ -595,1 +595,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -597,1 +597,1 @@\n-  Method* m = NULL;\n+  Method* m = nullptr;\n@@ -602,2 +602,2 @@\n-    \/\/ NULL _f1 means this is a virtual entry so also not interesting\n-    return NULL;\n+    \/\/ null _f1 means this is a virtual entry so also not interesting\n+    return nullptr;\n@@ -612,3 +612,3 @@\n-  assert(m != NULL && m->is_method(), \"sanity check\");\n-  if (m == NULL || !m->is_method()) {\n-    return NULL;\n+  assert(m != nullptr && m->is_method(), \"sanity check\");\n+  if (m == nullptr || !m->is_method()) {\n+    return nullptr;\n@@ -732,1 +732,1 @@\n-  assert(_initial_entries != NULL, \"archived cpcache must have been initialized\");\n+  assert(_initial_entries != nullptr, \"archived cpcache must have been initialized\");\n@@ -739,1 +739,1 @@\n-  _initial_entries = NULL;\n+  _initial_entries = nullptr;\n@@ -748,1 +748,1 @@\n-  set_reference_map(NULL);\n+  set_reference_map(nullptr);\n@@ -750,1 +750,1 @@\n-  if (_initial_entries != NULL) {\n+  if (_initial_entries != nullptr) {\n@@ -753,1 +753,1 @@\n-    _initial_entries = NULL;\n+    _initial_entries = nullptr;\n@@ -761,1 +761,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -787,1 +787,1 @@\n-    if (old_method == NULL || !old_method->is_old()) {\n+    if (old_method == nullptr || !old_method->is_old()) {\n@@ -805,1 +805,1 @@\n-    if (m != NULL && !entry_at(i)->check_no_old_or_obsolete_entries()) {\n+    if (m != nullptr && !entry_at(i)->check_no_old_or_obsolete_entries()) {\n@@ -817,1 +817,1 @@\n-    if (entry_at(i)->get_interesting_method_entry() != NULL) {\n+    if (entry_at(i)->get_interesting_method_entry() != nullptr) {\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":27,"deletions":27,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -148,1 +148,1 @@\n-    assert(existing_f1 == NULL || existing_f1 == f1, \"illegal field change\");\n+    assert(existing_f1 == nullptr || existing_f1 == f1, \"illegal field change\");\n@@ -229,1 +229,1 @@\n-    const methodHandle& method,                  \/\/ the method\/prototype if any (NULL, otherwise)\n+    const methodHandle& method,                  \/\/ the method\/prototype if any (null, otherwise)\n@@ -445,1 +445,1 @@\n-  oop  archived_references() NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n+  oop  archived_references() NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-  Metadata* f1 = f1_ord(); assert(f1 == NULL || f1->is_method(), \"\");\n+  Metadata* f1 = f1_ord(); assert(f1 == nullptr || f1->is_method(), \"\");\n@@ -65,1 +65,1 @@\n-  Metadata* f1 = f1_ord(); assert(f1 == NULL || f1->is_klass(), \"\");\n+  Metadata* f1 = f1_ord(); assert(f1 == nullptr || f1->is_klass(), \"\");\n@@ -69,1 +69,1 @@\n-inline bool ConstantPoolCacheEntry::is_f1_null() const { Metadata* f1 = f1_ord(); return f1 == NULL; }\n+inline bool ConstantPoolCacheEntry::is_f1_null() const { Metadata* f1 = f1_ord(); return f1 == nullptr; }\n@@ -92,1 +92,1 @@\n-                                                  _constant_pool(NULL),\n+                                                  _constant_pool(nullptr),\n","filename":"src\/hotspot\/share\/oops\/cpCache.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -129,1 +129,1 @@\n-      return NULL;\n+      return nullptr;\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -283,1 +283,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -421,1 +421,1 @@\n-    bb_mark_fct(this, excps.handler_pc(i), NULL);\n+    bb_mark_fct(this, excps.handler_pc(i), nullptr);\n@@ -432,1 +432,1 @@\n-        bb_mark_fct(this, bci, NULL);\n+        bb_mark_fct(this, bci, nullptr);\n@@ -434,1 +434,1 @@\n-    fellThrough = jump_targets_do(&bcs, &GenerateOopMap::bb_mark_fct, NULL);\n+    fellThrough = jump_targets_do(&bcs, &GenerateOopMap::bb_mark_fct, nullptr);\n@@ -440,1 +440,1 @@\n-        bb_mark_fct(this, bci + Bytecodes::length_for(bytecode), NULL);\n+        bb_mark_fct(this, bci + Bytecodes::length_for(bytecode), nullptr);\n@@ -444,1 +444,1 @@\n-        bb_mark_fct(this, bci + Bytecodes::length_for(bytecode), NULL);\n+        bb_mark_fct(this, bci + Bytecodes::length_for(bytecode), nullptr);\n@@ -652,1 +652,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -675,3 +675,3 @@\n-#define ALLOC_RESOURCE_ARRAY(var, type, count) \\\n-  var = NEW_RESOURCE_ARRAY_RETURN_NULL(type, count);              \\\n-  if (var == NULL) {                                              \\\n+#define ALLOC_RESOURCE_ARRAY(var, type, count)                           \\\n+  var = NEW_RESOURCE_ARRAY_RETURN_NULL(type, count);                     \\\n+  if (var == nullptr) {                                                  \\\n@@ -679,1 +679,1 @@\n-    return;                                                       \\\n+    return;                                                              \\\n@@ -804,1 +804,1 @@\n-  guarantee(bb != NULL, \"null basicblock\");\n+  guarantee(bb != nullptr, \"null basicblock\");\n@@ -1160,1 +1160,1 @@\n-    bool fall_through = jump_targets_do(&itr, GenerateOopMap::merge_state, NULL);\n+    bool fall_through = jump_targets_do(&itr, GenerateOopMap::merge_state, nullptr);\n@@ -1166,1 +1166,1 @@\n-      ret_jump_targets_do(&itr, GenerateOopMap::merge_state, itr.get_index(), NULL);\n+      ret_jump_targets_do(&itr, GenerateOopMap::merge_state, itr.get_index(), nullptr);\n@@ -1229,1 +1229,1 @@\n-        guarantee(excBB != NULL, \"no basic block for exception\");\n+        guarantee(excBB != nullptr, \"no basic block for exception\");\n@@ -1843,1 +1843,1 @@\n-    guarantee(bb != NULL, \"no basic block for bci\");\n+    guarantee(bb != nullptr, \"no basic block for bci\");\n@@ -2070,1 +2070,1 @@\n-  _init_vars = NULL;\n+  _init_vars = nullptr;\n@@ -2091,1 +2091,1 @@\n-  TraceTime t_all(NULL, &_total_oopmap_time, TimeOopMap);\n+  TraceTime t_all(nullptr, &_total_oopmap_time, TimeOopMap);\n@@ -2103,1 +2103,1 @@\n-  _new_var_map    = NULL;\n+  _new_var_map    = nullptr;\n@@ -2221,1 +2221,1 @@\n-  guarantee(bb != NULL, \"no basic block for bci\");\n+  guarantee(bb != nullptr, \"no basic block for bci\");\n@@ -2281,1 +2281,1 @@\n-  assert(_new_var_map!=NULL, \"nothing to rewrite\");\n+  assert(_new_var_map!=nullptr, \"nothing to rewrite\");\n@@ -2305,1 +2305,1 @@\n-  _new_var_map = NULL;\n+  _new_var_map = nullptr;\n@@ -2505,1 +2505,1 @@\n-  assert(_ret_adr_tos != NULL, \"must be initialized\");\n+  assert(_ret_adr_tos != nullptr, \"must be initialized\");\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.cpp","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-  RetTable()                                                  { _first = NULL; }\n+  RetTable()                                                  { _first = nullptr; }\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-    if (cld != NULL) {\n+    if (cld != nullptr) {\n@@ -67,1 +67,1 @@\n-      if (cld != NULL) {\n+      if (cld != nullptr) {\n","filename":"src\/hotspot\/share\/oops\/instanceClassLoaderKlass.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-    char* data = NULL;                                           \\\n+    char* data = nullptr;                                        \\\n@@ -117,1 +117,1 @@\n-    if (clss_name != NULL) {                                     \\\n+    if (clss_name != nullptr) {                                  \\\n@@ -127,1 +127,1 @@\n-    char* data = NULL;                                           \\\n+    char* data = nullptr;                                        \\\n@@ -130,1 +130,1 @@\n-    if (clss_name != NULL) {                                     \\\n+    if (clss_name != nullptr) {                                  \\\n@@ -149,1 +149,1 @@\n-  assert(class_name != NULL, \"invariant\");\n+  assert(class_name != nullptr, \"invariant\");\n@@ -157,1 +157,1 @@\n-    if (super_klass != NULL) {\n+    if (super_klass != nullptr) {\n@@ -177,1 +177,1 @@\n-  if (_nest_members == NULL || _nest_members == Universe::the_empty_short_array()) {\n+  if (_nest_members == nullptr || _nest_members == Universe::the_empty_short_array()) {\n@@ -209,2 +209,2 @@\n-  assert(k != NULL, \"sanity check\");\n-  assert(_permitted_subclasses != NULL && _permitted_subclasses != Universe::the_empty_short_array(),\n+  assert(k != nullptr, \"sanity check\");\n+  assert(_permitted_subclasses != nullptr && _permitted_subclasses != Universe::the_empty_short_array(),\n@@ -248,1 +248,1 @@\n-\/\/ (such as a native JIT thread) then we simply return NULL, which in turn\n+\/\/ (such as a native JIT thread) then we simply return null, which in turn\n@@ -255,2 +255,2 @@\n-\/\/ VirtualMachineErrors are propagated with a NULL return.\n-\/\/ Under any conditions where the _nest_host can be set to non-NULL the resulting\n+\/\/ VirtualMachineErrors are propagated with a null return.\n+\/\/ Under any conditions where the _nest_host can be set to non-null the resulting\n@@ -261,1 +261,1 @@\n-  if (nest_host_k != NULL) {\n+  if (nest_host_k != nullptr) {\n@@ -274,1 +274,1 @@\n-      return NULL; \/\/ sentinel to say \"try again from a different context\"\n+      return nullptr; \/\/ sentinel to say \"try again from a different context\"\n@@ -284,1 +284,1 @@\n-        return NULL; \/\/ propagate VMEs\n+        return nullptr; \/\/ propagate VMEs\n@@ -301,1 +301,1 @@\n-      const char* error = NULL;\n+      const char* error = nullptr;\n@@ -363,3 +363,3 @@\n-  assert(host != NULL, \"NULL nest host specified\");\n-  assert(_nest_host == NULL, \"current class has resolved nest-host\");\n-  assert(nest_host_error() == NULL, \"unexpected nest host resolution error exists: %s\",\n+  assert(host != nullptr, \"null nest host specified\");\n+  assert(_nest_host == nullptr, \"current class has resolved nest-host\");\n+  assert(nest_host_error() == nullptr, \"unexpected nest host resolution error exists: %s\",\n@@ -367,1 +367,1 @@\n-  assert((host->_nest_host == NULL && host->_nest_host_index == 0) ||\n+  assert((host->_nest_host == nullptr && host->_nest_host_index == 0) ||\n@@ -378,1 +378,1 @@\n-    } else if (_nest_members != NULL && _nest_members != Universe::the_empty_short_array()) {\n+    } else if (_nest_members != nullptr && _nest_members != Universe::the_empty_short_array()) {\n@@ -390,1 +390,1 @@\n-  assert(this_key != NULL, \"sanity\");\n+  assert(this_key != nullptr, \"sanity\");\n@@ -406,1 +406,1 @@\n-  if (cur_host == NULL) {\n+  if (cur_host == nullptr) {\n@@ -411,1 +411,1 @@\n-  if (k_nest_host == NULL) {\n+  if (k_nest_host == nullptr) {\n@@ -427,1 +427,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -441,1 +441,1 @@\n-  assert(class_name != NULL, \"invariant\");\n+  assert(class_name != nullptr, \"invariant\");\n@@ -443,1 +443,1 @@\n-  assert(loader_data != NULL, \"invariant\");\n+  assert(loader_data != nullptr, \"invariant\");\n@@ -468,1 +468,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -477,1 +477,1 @@\n-  if (m != NULL) {\n+  if (m != nullptr) {\n@@ -491,1 +491,1 @@\n-  assert(default_vtable_indices() == NULL, \"only create once\");\n+  assert(default_vtable_indices() == nullptr, \"only create once\");\n@@ -502,4 +502,4 @@\n-  _nest_members(NULL),\n-  _nest_host(NULL),\n-  _permitted_subclasses(NULL),\n-  _record_components(NULL),\n+  _nest_members(nullptr),\n+  _nest_host(nullptr),\n+  _permitted_subclasses(nullptr),\n+  _record_components(nullptr),\n@@ -513,1 +513,1 @@\n-  _init_thread(NULL)\n+  _init_thread(nullptr)\n@@ -521,1 +521,1 @@\n-  assert(NULL == _methods, \"underlying memory not zeroed?\");\n+  assert(nullptr == _methods, \"underlying memory not zeroed?\");\n@@ -528,1 +528,1 @@\n-  if (methods != NULL && methods != Universe::the_empty_method_array() &&\n+  if (methods != nullptr && methods != Universe::the_empty_method_array() &&\n@@ -532,1 +532,1 @@\n-      if (method == NULL) continue;  \/\/ maybe null if error processing\n+      if (method == nullptr) continue;  \/\/ maybe null if error processing\n@@ -551,1 +551,1 @@\n-    Array<InstanceKlass*>* sti = (super_klass == NULL) ? NULL :\n+    Array<InstanceKlass*>* sti = (super_klass == nullptr) ? nullptr :\n@@ -553,1 +553,1 @@\n-    if (ti != sti && ti != NULL && !ti->is_shared()) {\n+    if (ti != sti && ti != nullptr && !ti->is_shared()) {\n@@ -560,1 +560,1 @@\n-      local_interfaces != NULL && !local_interfaces->is_shared()) {\n+      local_interfaces != nullptr && !local_interfaces->is_shared()) {\n@@ -567,1 +567,1 @@\n-  if (record_components != NULL && !record_components->is_shared()) {\n+  if (record_components != nullptr && !record_components->is_shared()) {\n@@ -580,2 +580,2 @@\n-  if (java_mirror() != NULL) {\n-    java_lang_Class::set_klass(java_mirror(), NULL);\n+  if (java_mirror() != nullptr) {\n+    java_lang_Class::set_klass(java_mirror(), nullptr);\n@@ -594,1 +594,1 @@\n-  assert(array_klasses() == NULL, \"array classes shouldn't be created for this class yet\");\n+  assert(array_klasses() == nullptr, \"array classes shouldn't be created for this class yet\");\n@@ -604,1 +604,1 @@\n-  set_methods(NULL);\n+  set_methods(nullptr);\n@@ -607,1 +607,1 @@\n-  set_record_components(NULL);\n+  set_record_components(nullptr);\n@@ -609,1 +609,1 @@\n-  if (method_ordering() != NULL &&\n+  if (method_ordering() != nullptr &&\n@@ -614,1 +614,1 @@\n-  set_method_ordering(NULL);\n+  set_method_ordering(nullptr);\n@@ -617,1 +617,1 @@\n-  if (default_methods() != NULL &&\n+  if (default_methods() != nullptr &&\n@@ -623,1 +623,1 @@\n-  set_default_methods(NULL);\n+  set_default_methods(nullptr);\n@@ -626,1 +626,1 @@\n-  if (default_vtable_indices() != NULL &&\n+  if (default_vtable_indices() != nullptr &&\n@@ -630,1 +630,1 @@\n-  set_default_vtable_indices(NULL);\n+  set_default_vtable_indices(nullptr);\n@@ -636,1 +636,1 @@\n-  if (secondary_supers() != NULL &&\n+  if (secondary_supers() != nullptr &&\n@@ -643,1 +643,1 @@\n-  set_secondary_supers(NULL);\n+  set_secondary_supers(nullptr);\n@@ -646,2 +646,2 @@\n-  set_transitive_interfaces(NULL);\n-  set_local_interfaces(NULL);\n+  set_transitive_interfaces(nullptr);\n+  set_local_interfaces(nullptr);\n@@ -649,1 +649,1 @@\n-  if (fields() != NULL && !fields()->is_shared()) {\n+  if (fields() != nullptr && !fields()->is_shared()) {\n@@ -652,1 +652,1 @@\n-  set_fields(NULL, 0);\n+  set_fields(nullptr, 0);\n@@ -656,1 +656,1 @@\n-  if (constants() != NULL) {\n+  if (constants() != nullptr) {\n@@ -664,1 +664,1 @@\n-    set_constants(NULL);\n+    set_constants(nullptr);\n@@ -667,1 +667,1 @@\n-  if (inner_classes() != NULL &&\n+  if (inner_classes() != nullptr &&\n@@ -672,1 +672,1 @@\n-  set_inner_classes(NULL);\n+  set_inner_classes(nullptr);\n@@ -674,1 +674,1 @@\n-  if (nest_members() != NULL &&\n+  if (nest_members() != nullptr &&\n@@ -679,1 +679,1 @@\n-  set_nest_members(NULL);\n+  set_nest_members(nullptr);\n@@ -681,1 +681,1 @@\n-  if (permitted_subclasses() != NULL &&\n+  if (permitted_subclasses() != nullptr &&\n@@ -686,1 +686,1 @@\n-  set_permitted_subclasses(NULL);\n+  set_permitted_subclasses(nullptr);\n@@ -689,1 +689,1 @@\n-  if (annotations() != NULL && !annotations()->is_shared()) {\n+  if (annotations() != nullptr && !annotations()->is_shared()) {\n@@ -692,1 +692,1 @@\n-  set_annotations(NULL);\n+  set_annotations(nullptr);\n@@ -704,1 +704,1 @@\n-  return _record_components != NULL &&\n+  return _record_components != nullptr &&\n@@ -710,1 +710,1 @@\n-  return _permitted_subclasses != NULL &&\n+  return _permitted_subclasses != nullptr &&\n@@ -819,1 +819,1 @@\n-  if (super_klass != NULL) {\n+  if (super_klass != nullptr) {\n@@ -1046,1 +1046,1 @@\n-      jt->set_class_to_be_initialized(NULL);\n+      jt->set_class_to_be_initialized(nullptr);\n@@ -1093,1 +1093,1 @@\n-    if (super_klass != NULL && super_klass->should_be_initialized()) {\n+    if (super_klass != nullptr && super_klass->should_be_initialized()) {\n@@ -1124,1 +1124,1 @@\n-    if (class_initializer() != NULL) {\n+    if (class_initializer() != nullptr) {\n@@ -1186,1 +1186,1 @@\n-    set_init_thread(NULL); \/\/ reset _init_thread before changing _init_state\n+    set_init_thread(nullptr); \/\/ reset _init_thread before changing _init_state\n@@ -1191,1 +1191,1 @@\n-    set_init_thread(NULL); \/\/ reset _init_thread before changing _init_state\n+    set_init_thread(nullptr); \/\/ reset _init_thread before changing _init_state\n@@ -1199,2 +1199,2 @@\n-  if (ik == NULL) {\n-    return NULL;\n+  if (ik == nullptr) {\n+    return nullptr;\n@@ -1204,2 +1204,2 @@\n-    if (ikls != NULL && !ikls->is_loader_alive()) {\n-      return NULL;  \/\/ don't return unloaded class\n+    if (ikls != nullptr && !ikls->is_loader_alive()) {\n+      return nullptr;  \/\/ don't return unloaded class\n@@ -1217,2 +1217,2 @@\n-  assert(addr != NULL, \"null addr\");\n-  if (addr != NULL) {\n+  assert(addr != nullptr, \"null addr\");\n+  if (addr != nullptr) {\n@@ -1225,1 +1225,1 @@\n-  if (ik == NULL) {\n+  if (ik == nullptr) {\n@@ -1238,1 +1238,1 @@\n-\/\/   NULL                  - no implementor\n+\/\/   null                  - no implementor\n@@ -1256,1 +1256,1 @@\n-  if (super_ik != NULL && super_ik->implements_interface(this))\n+  if (super_ik != nullptr && super_ik->implements_interface(this))\n@@ -1263,1 +1263,1 @@\n-  if (iklass == NULL) {\n+  if (iklass == nullptr) {\n@@ -1279,1 +1279,1 @@\n-    set_implementor(NULL);\n+    set_implementor(nullptr);\n@@ -1309,1 +1309,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1317,1 +1317,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1409,1 +1409,1 @@\n-  if (array_klasses_acquire() == NULL) {\n+  if (array_klasses_acquire() == nullptr) {\n@@ -1417,1 +1417,1 @@\n-      if (array_klasses() == NULL) {\n+      if (array_klasses() == nullptr) {\n@@ -1432,2 +1432,2 @@\n-  if (oak == NULL) {\n-    return NULL;\n+  if (oak == nullptr) {\n+    return nullptr;\n@@ -1452,1 +1452,1 @@\n-  if (clinit != NULL && clinit->has_valid_initializer_flags()) {\n+  if (clinit != nullptr && clinit->has_valid_initializer_flags()) {\n@@ -1455,1 +1455,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1461,1 +1461,1 @@\n-       (ReplaySuppressInitializers >= 2 && class_loader() != NULL))) {\n+       (ReplaySuppressInitializers >= 2 && class_loader() != nullptr))) {\n@@ -1485,1 +1485,1 @@\n-    ls.print_cr(\"%s (\" PTR_FORMAT \")\", h_method() == NULL ? \"(no method)\" : \"\", p2i(this));\n+    ls.print_cr(\"%s (\" PTR_FORMAT \")\", h_method() == nullptr ? \"(no method)\" : \"\", p2i(this));\n@@ -1487,1 +1487,1 @@\n-  if (h_method() != NULL) {\n+  if (h_method() != nullptr) {\n@@ -1500,1 +1500,1 @@\n-  if (oop_map_cache == NULL) {\n+  if (oop_map_cache == nullptr) {\n@@ -1503,1 +1503,1 @@\n-    if ((oop_map_cache = _oop_map_cache) == NULL) {\n+    if ((oop_map_cache = _oop_map_cache) == nullptr) {\n@@ -1543,1 +1543,1 @@\n-    if (intf2 != NULL) return intf2;\n+    if (intf2 != nullptr) return intf2;\n@@ -1546,1 +1546,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1558,1 +1558,1 @@\n-    if (intf != NULL) return intf;\n+    if (intf != nullptr) return intf;\n@@ -1562,1 +1562,1 @@\n-    if (supr != NULL) return InstanceKlass::cast(supr)->find_field(name, sig, fd);\n+    if (supr != nullptr) return InstanceKlass::cast(supr)->find_field(name, sig, fd);\n@@ -1565,1 +1565,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1578,1 +1578,1 @@\n-    if (intf != NULL) return intf;\n+    if (intf != nullptr) return intf;\n@@ -1582,1 +1582,1 @@\n-    if (supr != NULL) return InstanceKlass::cast(supr)->find_field(name, sig, is_static, fd);\n+    if (supr != nullptr) return InstanceKlass::cast(supr)->find_field(name, sig, is_static, fd);\n@@ -1585,1 +1585,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1602,1 +1602,1 @@\n-  while (klass != NULL) {\n+  while (klass != nullptr) {\n@@ -1650,1 +1650,1 @@\n-  if (super != NULL) {\n+  if (super != nullptr) {\n@@ -1670,1 +1670,1 @@\n-  if (super != NULL) {\n+  if (super != nullptr) {\n@@ -1796,1 +1796,1 @@\n-  assert(((meth == NULL) || !meth->is_static()),\n+  assert(((meth == nullptr) || !meth->is_static()),\n@@ -1864,1 +1864,1 @@\n-  return hit >= 0 ? methods->at(hit): NULL;\n+  return hit >= 0 ? methods->at(hit): nullptr;\n@@ -1950,1 +1950,1 @@\n-  assert(end_ptr != NULL, \"just checking\");\n+  assert(end_ptr != nullptr, \"just checking\");\n@@ -1971,1 +1971,1 @@\n-  while (klass != NULL) {\n+  while (klass != nullptr) {\n@@ -1977,1 +1977,1 @@\n-    if (method != NULL) {\n+    if (method != nullptr) {\n@@ -1983,1 +1983,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1991,1 +1991,1 @@\n-  while (klass != NULL) {\n+  while (klass != nullptr) {\n@@ -2005,2 +2005,2 @@\n-  Method* m = NULL;\n-  if (default_methods() != NULL) {\n+  Method* m = nullptr;\n+  if (default_methods() != nullptr) {\n@@ -2010,1 +2010,1 @@\n-  if (m == NULL) {\n+  if (m == nullptr) {\n@@ -2024,1 +2024,1 @@\n-  InstanceKlass *ik = NULL;\n+  InstanceKlass *ik = nullptr;\n@@ -2028,1 +2028,1 @@\n-    if (m != NULL && m->is_public() && !m->is_static() &&\n+    if (m != nullptr && m->is_public() && !m->is_static() &&\n@@ -2033,1 +2033,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2085,2 +2085,2 @@\n-  JNIid* probe = jni_ids() == NULL ? NULL : jni_ids()->find(offset);\n-  if (probe == NULL) {\n+  JNIid* probe = jni_ids() == nullptr ? nullptr : jni_ids()->find(offset);\n+  if (probe == nullptr) {\n@@ -2096,1 +2096,1 @@\n-  if (inner_class_list == NULL) {\n+  if (inner_class_list == nullptr) {\n@@ -2111,1 +2111,1 @@\n-  assert (inner_class_list != NULL, \"_inner_classes list is not set up\");\n+  assert (inner_class_list != nullptr, \"_inner_classes list is not set up\");\n@@ -2131,1 +2131,1 @@\n-  jmethodID id = NULL;\n+  jmethodID id = nullptr;\n@@ -2135,1 +2135,1 @@\n-  \/\/ transitions from NULL to non-NULL which is safe because we use\n+  \/\/ transitions from null to non-null which is safe because we use\n@@ -2146,1 +2146,1 @@\n-  \/\/ grow and we'll have transitions from non-NULL to bigger non-NULL.\n+  \/\/ grow and we'll have transitions from non-null to bigger non-null.\n@@ -2151,1 +2151,1 @@\n-  if (jmeths != NULL) {\n+  if (jmeths != nullptr) {\n@@ -2164,3 +2164,3 @@\n-  if (jmeths == NULL ||   \/\/ no cache yet\n-      length <= idnum ||  \/\/ cache is too short\n-      id == NULL) {       \/\/ cache doesn't contain entry\n+  if (jmeths == nullptr ||   \/\/ no cache yet\n+      length <= idnum ||     \/\/ cache is too short\n+      id == nullptr) {       \/\/ cache doesn't contain entry\n@@ -2173,2 +2173,2 @@\n-    jmethodID  to_dealloc_id     = NULL;\n-    jmethodID* to_dealloc_jmeths = NULL;\n+    jmethodID  to_dealloc_id     = nullptr;\n+    jmethodID* to_dealloc_jmeths = nullptr;\n@@ -2177,1 +2177,1 @@\n-    jmethodID* new_jmeths = NULL;\n+    jmethodID* new_jmeths = nullptr;\n@@ -2190,1 +2190,1 @@\n-      jmethodID new_id = NULL;\n+      jmethodID new_id = nullptr;\n@@ -2194,1 +2194,1 @@\n-        assert(current_method != NULL, \"old and but not obsolete, so should exist\");\n+        assert(current_method != nullptr, \"old and but not obsolete, so should exist\");\n@@ -2208,1 +2208,1 @@\n-    if (to_dealloc_jmeths != NULL) {\n+    if (to_dealloc_jmeths != nullptr) {\n@@ -2212,1 +2212,1 @@\n-    if (to_dealloc_id != NULL) {\n+    if (to_dealloc_id != nullptr) {\n@@ -2230,1 +2230,1 @@\n-    if (id == NULL) {\n+    if (id == nullptr) {\n@@ -2248,3 +2248,3 @@\n-  assert(new_id != NULL, \"sanity check\");\n-  assert(to_dealloc_id_p != NULL, \"sanity check\");\n-  assert(to_dealloc_jmeths_p != NULL, \"sanity check\");\n+  assert(new_id != nullptr, \"sanity check\");\n+  assert(to_dealloc_id_p != nullptr, \"sanity check\");\n+  assert(to_dealloc_jmeths_p != nullptr, \"sanity check\");\n@@ -2255,1 +2255,1 @@\n-  jmethodID  id     = NULL;\n+  jmethodID  id     = nullptr;\n@@ -2258,1 +2258,1 @@\n-  if (jmeths == NULL ||                         \/\/ no cache yet\n+  if (jmeths == nullptr ||                      \/\/ no cache yet\n@@ -2260,1 +2260,1 @@\n-    if (jmeths != NULL) {\n+    if (jmeths != nullptr) {\n@@ -2273,1 +2273,1 @@\n-  if (id == NULL) {\n+  if (id == nullptr) {\n@@ -2296,3 +2296,3 @@\n-  assert(cache != NULL, \"sanity check\");\n-  assert(length_p != NULL, \"sanity check\");\n-  assert(id_p != NULL, \"sanity check\");\n+  assert(cache != nullptr, \"sanity check\");\n+  assert(length_p != nullptr, \"sanity check\");\n+  assert(id_p != nullptr, \"sanity check\");\n@@ -2303,1 +2303,1 @@\n-    *id_p = NULL;\n+    *id_p = nullptr;\n@@ -2310,1 +2310,1 @@\n-\/\/ Lookup a jmethodID, NULL if not found.  Do no blocking, no allocations, no handles\n+\/\/ Lookup a jmethodID, null if not found.  Do no blocking, no allocations, no handles\n@@ -2315,2 +2315,2 @@\n-  jmethodID id = NULL;\n-  if (jmeths != NULL &&                         \/\/ If there is a cache\n+  jmethodID id = nullptr;\n+  if (jmeths != nullptr &&                      \/\/ If there is a cache\n@@ -2318,1 +2318,1 @@\n-    id = jmeths[idnum+1];                       \/\/ Look up the id (may be NULL)\n+    id = jmeths[idnum+1];                       \/\/ Look up the id (may be null)\n@@ -2362,2 +2362,2 @@\n-      if (impl != NULL && !impl->is_loader_alive()) {\n-        \/\/ NULL this field, might be an unloaded instance klass or NULL\n+      if (impl != nullptr && !impl->is_loader_alive()) {\n+        \/\/ null this field, might be an unloaded instance klass or null\n@@ -2365,1 +2365,1 @@\n-        if (Atomic::cmpxchg(iklass, impl, (InstanceKlass*)NULL) == impl) {\n+        if (Atomic::cmpxchg(iklass, impl, (InstanceKlass*)nullptr) == impl) {\n@@ -2383,2 +2383,2 @@\n-    if (mdo != NULL) {\n-      MutexLocker ml(SafepointSynchronize::is_at_safepoint() ? NULL : mdo->extra_data_lock());\n+    if (mdo != nullptr) {\n+      MutexLocker ml(SafepointSynchronize::is_at_safepoint() ? nullptr : mdo->extra_data_lock());\n@@ -2430,1 +2430,1 @@\n-      if (ioe->interface_klass() != NULL) {\n+      if (ioe->interface_klass() != nullptr) {\n@@ -2483,1 +2483,1 @@\n-  if (array_klasses() != NULL) {\n+  if (array_klasses() != nullptr) {\n@@ -2487,4 +2487,4 @@\n-  \/\/ These are not allocated from metaspace. They are safe to set to NULL.\n-  _source_debug_extension = NULL;\n-  _dep_context = NULL;\n-  _osr_nmethods_head = NULL;\n+  \/\/ These are not allocated from metaspace. They are safe to set to null.\n+  _source_debug_extension = nullptr;\n+  _dep_context = nullptr;\n+  _osr_nmethods_head = nullptr;\n@@ -2492,4 +2492,4 @@\n-  _breakpoints = NULL;\n-  _previous_versions = NULL;\n-  _cached_class_file = NULL;\n-  _jvmti_cached_class_field_map = NULL;\n+  _breakpoints = nullptr;\n+  _previous_versions = nullptr;\n+  _cached_class_file = nullptr;\n+  _jvmti_cached_class_field_map = nullptr;\n@@ -2498,4 +2498,4 @@\n-  _init_thread = NULL;\n-  _methods_jmethod_ids = NULL;\n-  _jni_ids = NULL;\n-  _oop_map_cache = NULL;\n+  _init_thread = nullptr;\n+  _methods_jmethod_ids = nullptr;\n+  _jni_ids = nullptr;\n+  _oop_map_cache = nullptr;\n@@ -2503,1 +2503,1 @@\n-  _nest_host = NULL;\n+  _nest_host = nullptr;\n@@ -2506,1 +2506,1 @@\n-  _init_monitor = NULL;\n+  _init_monitor = nullptr;\n@@ -2513,1 +2513,1 @@\n-  if (array_klasses() != NULL) {\n+  if (array_klasses() != nullptr) {\n@@ -2520,1 +2520,1 @@\n-  _package_entry = NULL;\n+  _package_entry = nullptr;\n@@ -2523,1 +2523,1 @@\n-    _package_entry = NULL;\n+    _package_entry = nullptr;\n@@ -2526,1 +2526,1 @@\n-      _package_entry = NULL;\n+      _package_entry = nullptr;\n@@ -2530,1 +2530,1 @@\n-      _package_entry = NULL;\n+      _package_entry = nullptr;\n@@ -2573,1 +2573,1 @@\n-  if (array_klasses() != NULL) {\n+  if (array_klasses() != nullptr) {\n@@ -2605,1 +2605,1 @@\n-  if (java_super() != NULL && !java_super()->can_be_verified_at_dumptime()) {\n+  if (java_super() != nullptr && !java_super()->can_be_verified_at_dumptime()) {\n@@ -2647,1 +2647,1 @@\n-  assert(ik != NULL, \"invariant\");\n+  assert(ik != nullptr, \"invariant\");\n@@ -2673,1 +2673,1 @@\n-  if (_oop_map_cache != NULL) {\n+  if (_oop_map_cache != nullptr) {\n@@ -2675,1 +2675,1 @@\n-    _oop_map_cache = NULL;\n+    _oop_map_cache = nullptr;\n@@ -2680,1 +2680,1 @@\n-  set_jni_ids(NULL);\n+  set_jni_ids(nullptr);\n@@ -2683,2 +2683,2 @@\n-  if (jmeths != (jmethodID*)NULL) {\n-    release_set_methods_jmethod_ids(NULL);\n+  if (jmeths != (jmethodID*)nullptr) {\n+    release_set_methods_jmethod_ids(nullptr);\n@@ -2688,1 +2688,1 @@\n-  assert(_dep_context == NULL,\n+  assert(_dep_context == nullptr,\n@@ -2699,1 +2699,1 @@\n-  if (_cached_class_file != NULL) {\n+  if (_cached_class_file != nullptr) {\n@@ -2701,1 +2701,1 @@\n-    _cached_class_file = NULL;\n+    _cached_class_file = nullptr;\n@@ -2713,2 +2713,2 @@\n-  if (array == NULL) {\n-    _source_debug_extension = NULL;\n+  if (array == nullptr) {\n+    _source_debug_extension = nullptr;\n@@ -2756,1 +2756,1 @@\n-  \/\/ Add the semicolon and the NULL\n+  \/\/ Add the semicolon and the null\n@@ -2799,1 +2799,1 @@\n-  if (is_shared() && _package_entry != NULL) {\n+  if (is_shared() && _package_entry != nullptr) {\n@@ -2805,1 +2805,1 @@\n-      _package_entry = NULL;\n+      _package_entry = nullptr;\n@@ -2812,1 +2812,1 @@\n-      (pkg_entry != NULL) ? NULL : ClassLoader::package_from_class_name(name());\n+      (pkg_entry != nullptr) ? nullptr : ClassLoader::package_from_class_name(name());\n@@ -2815,1 +2815,1 @@\n-  if (pkg_entry != NULL) {\n+  if (pkg_entry != nullptr) {\n@@ -2821,1 +2821,1 @@\n-  if (pkg_name != NULL && loader_data != NULL) {\n+  if (pkg_name != nullptr && loader_data != nullptr) {\n@@ -2824,1 +2824,1 @@\n-    _package_entry = pkg_entry != NULL ? pkg_entry : loader_data->packages()->lookup_only(pkg_name);\n+    _package_entry = pkg_entry != nullptr ? pkg_entry : loader_data->packages()->lookup_only(pkg_name);\n@@ -2829,1 +2829,1 @@\n-    if (_package_entry == NULL) {\n+    if (_package_entry == nullptr) {\n@@ -2836,1 +2836,1 @@\n-        assert(ModuleEntryTable::javabase_moduleEntry() != NULL, JAVA_BASE_NAME \" module is NULL\");\n+        assert(ModuleEntryTable::javabase_moduleEntry() != nullptr, JAVA_BASE_NAME \" module is null\");\n@@ -2839,1 +2839,1 @@\n-        assert(loader_data->unnamed_module() != NULL, \"unnamed module is NULL\");\n+        assert(loader_data->unnamed_module() != nullptr, \"unnamed module is null\");\n@@ -2845,1 +2845,1 @@\n-      assert(_package_entry != NULL, \"Package entry for class %s not found, loader %s\",\n+      assert(_package_entry != nullptr, \"Package entry for class %s not found, loader %s\",\n@@ -2862,1 +2862,1 @@\n-                      (loader_data != NULL) ? loader_data->loader_name_and_id() : \"NULL\",\n+                      (loader_data != nullptr) ? loader_data->loader_name_and_id() : \"null\",\n@@ -2877,1 +2877,1 @@\n-  if (_package_entry != NULL) {\n+  if (_package_entry != nullptr) {\n@@ -2901,2 +2901,2 @@\n-    classloader2 = NULL;\n-    classpkg2 = NULL;\n+    classloader2 = nullptr;\n+    classpkg2 = nullptr;\n@@ -2935,2 +2935,2 @@\n-    \/\/ Check that package_from_class_name() returns NULL, not \"\", if there is no package.\n-    assert(other_pkg == NULL || other_pkg->utf8_length() > 0, \"package name is empty string\");\n+    \/\/ Check that package_from_class_name() returns null, not \"\", if there is no package.\n+    assert(other_pkg == nullptr || other_pkg->utf8_length() > 0, \"package name is empty string\");\n@@ -2939,1 +2939,1 @@\n-      this->package() != NULL ? this->package()->name() : NULL;\n+      this->package() != nullptr ? this->package()->name() : nullptr;\n@@ -2941,1 +2941,1 @@\n-    if (this_package_name == NULL || other_pkg == NULL) {\n+    if (this_package_name == nullptr || other_pkg == nullptr) {\n@@ -2970,1 +2970,1 @@\n-      class_name != NULL && class_name->utf8_length() >= 5) {\n+      class_name != nullptr && class_name->utf8_length() >= 5) {\n@@ -2982,1 +2982,1 @@\n-      assert(pkg_name != NULL, \"Error in parsing package name starting with 'java\/'\");\n+      assert(pkg_name != nullptr, \"Error in parsing package name starting with 'java\/'\");\n@@ -3018,1 +3018,1 @@\n-  InstanceKlass* outer_klass = NULL;\n+  InstanceKlass* outer_klass = nullptr;\n@@ -3036,1 +3036,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -3041,1 +3041,1 @@\n-    if (NULL == outer_klass) {\n+    if (nullptr == outer_klass) {\n@@ -3053,1 +3053,1 @@\n-  if (NULL == outer_klass) return NULL;\n+  if (nullptr == outer_klass) return nullptr;\n@@ -3107,1 +3107,1 @@\n-  if (m != NULL) {\n+  if (m != nullptr) {\n@@ -3142,1 +3142,1 @@\n-  return NULL; \/\/ offset entry not found\n+  return nullptr; \/\/ offset entry not found\n@@ -3155,1 +3155,1 @@\n-  if (!intf_method->is_abstract() && default_methods() != NULL) {\n+  if (!intf_method->is_abstract() && default_methods() != nullptr) {\n@@ -3180,1 +3180,1 @@\n-  if (default_methods() != NULL) {\n+  if (default_methods() != nullptr) {\n@@ -3183,1 +3183,1 @@\n-      if (old_method == NULL || !old_method->is_old()) {\n+      if (old_method == nullptr || !old_method->is_old()) {\n@@ -3212,1 +3212,1 @@\n-  assert(prev == NULL || !prev->is_in_use() COMPILER2_PRESENT(|| StressRecompilation),\n+  assert(prev == nullptr || !prev->is_in_use() COMPILER2_PRESENT(|| StressRecompilation),\n@@ -3225,1 +3225,1 @@\n-    if (inv != NULL && inv->is_in_use()) {\n+    if (inv != nullptr && inv->is_in_use()) {\n@@ -3234,1 +3234,1 @@\n-  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? NULL : CompiledMethod_lock\n+  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock\n@@ -3237,1 +3237,1 @@\n-  nmethod* last = NULL;\n+  nmethod* last = nullptr;\n@@ -3243,1 +3243,1 @@\n-  while(cur != NULL && cur != n) {\n+  while(cur != nullptr && cur != n) {\n@@ -3251,1 +3251,1 @@\n-  nmethod* next = NULL;\n+  nmethod* next = nullptr;\n@@ -3255,1 +3255,1 @@\n-    if (last == NULL) {\n+    if (last == nullptr) {\n@@ -3262,1 +3262,1 @@\n-  n->set_osr_link(NULL);\n+  n->set_osr_link(nullptr);\n@@ -3264,1 +3264,1 @@\n-  while (cur != NULL) {\n+  while (cur != nullptr) {\n@@ -3276,1 +3276,1 @@\n-  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? NULL : CompiledMethod_lock,\n+  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock,\n@@ -3280,1 +3280,1 @@\n-  while (osr != NULL) {\n+  while (osr != nullptr) {\n@@ -3292,1 +3292,1 @@\n-  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? NULL : CompiledMethod_lock,\n+  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock,\n@@ -3295,2 +3295,2 @@\n-  nmethod* best = NULL;\n-  while (osr != NULL) {\n+  nmethod* best = nullptr;\n+  while (osr != nullptr) {\n@@ -3312,1 +3312,1 @@\n-        if (best == NULL || (osr->comp_level() > best->comp_level())) {\n+        if (best == nullptr || (osr->comp_level() > best->comp_level())) {\n@@ -3324,2 +3324,2 @@\n-  assert(match_level == false || best == NULL, \"shouldn't pick up anything if match_level is set\");\n-  if (best != NULL && best->comp_level() >= comp_level) {\n+  assert(match_level == false || best == nullptr, \"shouldn't pick up anything if match_level is set\");\n+  if (best != nullptr && best->comp_level() >= comp_level) {\n@@ -3328,1 +3328,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -3373,1 +3373,1 @@\n-  for (n = 0; sub != NULL; n++, sub = sub->next_sibling()) {\n+  for (n = 0; sub != nullptr; n++, sub = sub->next_sibling()) {\n@@ -3402,1 +3402,1 @@\n-  if (Verbose && default_methods() != NULL) {\n+  if (Verbose && default_methods() != nullptr) {\n@@ -3408,1 +3408,1 @@\n-  if (default_vtable_indices() != NULL) {\n+  if (default_vtable_indices() != nullptr) {\n@@ -3414,1 +3414,1 @@\n-  if (class_loader_data() != NULL) {\n+  if (class_loader_data() != nullptr) {\n@@ -3419,1 +3419,1 @@\n-  if (source_file_name() != NULL) {\n+  if (source_file_name() != nullptr) {\n@@ -3424,1 +3424,1 @@\n-  if (source_debug_extension() != NULL) {\n+  if (source_debug_extension() != nullptr) {\n@@ -3437,1 +3437,1 @@\n-         pv_node != NULL;\n+         pv_node != nullptr;\n@@ -3447,1 +3447,1 @@\n-  if (generic_signature() != NULL) {\n+  if (generic_signature() != nullptr) {\n@@ -3454,1 +3454,1 @@\n-  if (record_components() != NULL) {\n+  if (record_components() != nullptr) {\n@@ -3458,1 +3458,1 @@\n-  if (java_mirror() != NULL) {\n+  if (java_mirror() != nullptr) {\n@@ -3463,1 +3463,1 @@\n-    st->print_cr(BULLET\"java mirror:       NULL\");\n+    st->print_cr(BULLET\"java mirror:       null\");\n@@ -3495,1 +3495,1 @@\n-   if (_obj == NULL) {\n+   if (_obj == nullptr) {\n@@ -3511,1 +3511,1 @@\n-    if (value != NULL &&\n+    if (value != nullptr &&\n@@ -3529,1 +3529,1 @@\n-    if (real_klass != NULL && real_klass->is_instance_klass()) {\n+    if (real_klass != nullptr && real_klass->is_instance_klass()) {\n@@ -3555,1 +3555,1 @@\n-      && java_lang_String::value(obj) != NULL) {\n+      && java_lang_String::value(obj) != nullptr) {\n@@ -3566,1 +3566,1 @@\n-    if (k != NULL) {\n+    if (k != nullptr) {\n@@ -3580,1 +3580,1 @@\n-    if (vmentry != NULL) {\n+    if (vmentry != nullptr) {\n@@ -3586,1 +3586,1 @@\n-    if (vmtarget != NULL) {\n+    if (vmtarget != nullptr) {\n@@ -3592,1 +3592,1 @@\n-      if (clazz != NULL) {\n+      if (clazz != nullptr) {\n@@ -3595,1 +3595,1 @@\n-        st->print(\"NULL\");\n+        st->print(\"null\");\n@@ -3598,1 +3598,1 @@\n-      if (name != NULL) {\n+      if (name != nullptr) {\n@@ -3601,1 +3601,1 @@\n-        st->print(\"NULL\");\n+        st->print(\"null\");\n@@ -3630,4 +3630,4 @@\n-  if (cfs != NULL) {\n-    if (cfs->source() != NULL) {\n-      const char* module_name = (module_entry->name() == NULL) ? UNNAMED_MODULE : module_entry->name()->as_C_string();\n-      if (module_name != NULL) {\n+  if (cfs != nullptr) {\n+    if (cfs->source() != nullptr) {\n+      const char* module_name = (module_entry->name() == nullptr) ? UNNAMED_MODULE : module_entry->name()->as_C_string();\n+      if (module_name != nullptr) {\n@@ -3648,3 +3648,3 @@\n-        NULL;\n-      \/\/ caller can be NULL, for example, during a JVMTI VM_Init hook\n-      if (caller != NULL) {\n+        nullptr;\n+      \/\/ caller can be null, for example, during a JVMTI VM_Init hook\n+      if (caller != nullptr) {\n@@ -3678,1 +3678,1 @@\n-    if (local_interfaces() != NULL && local_interfaces()->length() > 0) {\n+    if (local_interfaces() != nullptr && local_interfaces()->length() > 0) {\n@@ -3743,1 +3743,1 @@\n-  if (subklass() != NULL) {\n+  if (subklass() != nullptr) {\n@@ -3750,1 +3750,1 @@\n-  if (sib != NULL) {\n+  if (sib != nullptr) {\n@@ -3769,1 +3769,1 @@\n-  if (transitive_interfaces() != NULL) {\n+  if (transitive_interfaces() != nullptr) {\n@@ -3778,1 +3778,1 @@\n-  if (methods() != NULL) {\n+  if (methods() != nullptr) {\n@@ -3791,1 +3791,1 @@\n-  if (method_ordering() != NULL) {\n+  if (method_ordering() != nullptr) {\n@@ -3812,1 +3812,1 @@\n-  if (default_methods() != NULL) {\n+  if (default_methods() != nullptr) {\n@@ -3825,1 +3825,1 @@\n-  if (jni_ids() != NULL) {\n+  if (jni_ids() != nullptr) {\n@@ -3830,1 +3830,1 @@\n-  if (constants() != NULL) {\n+  if (constants() != nullptr) {\n@@ -3856,1 +3856,1 @@\n-  while (current != NULL) {\n+  while (current != nullptr) {\n@@ -3860,1 +3860,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -3864,1 +3864,1 @@\n-  while (current != NULL) {\n+  while (current != nullptr) {\n@@ -3878,1 +3878,1 @@\n-  while (current != NULL) {\n+  while (current != nullptr) {\n@@ -3900,1 +3900,1 @@\n-  assert(_init_thread == NULL, \"should be cleared before state change\");\n+  assert(_init_thread == nullptr, \"should be cleared before state change\");\n@@ -3933,1 +3933,1 @@\n-  if (previous_versions() == NULL) {\n+  if (previous_versions() == nullptr) {\n@@ -3943,1 +3943,1 @@\n-  assert(loader_data != NULL, \"should never be null\");\n+  assert(loader_data != nullptr, \"should never be null\");\n@@ -3954,1 +3954,1 @@\n-  for (; pv_node != NULL; ) {\n+  for (; pv_node != nullptr; ) {\n@@ -3957,1 +3957,1 @@\n-    assert(pvcp != NULL, \"cp ref was unexpectedly cleared\");\n+    assert(pvcp != nullptr, \"cp ref was unexpectedly cleared\");\n@@ -3969,1 +3969,1 @@\n-      pv_node->link_previous_versions(NULL);   \/\/ point next to NULL\n+      pv_node->link_previous_versions(nullptr);   \/\/ point next to null\n@@ -3980,1 +3980,1 @@\n-      assert(pvcp->pool_holder() != NULL, \"Constant pool with no holder\");\n+      assert(pvcp->pool_holder() != nullptr, \"Constant pool with no holder\");\n@@ -4001,1 +4001,1 @@\n-      _previous_versions != NULL) {\n+      _previous_versions != nullptr) {\n@@ -4015,1 +4015,1 @@\n-             prev_version != NULL;\n+             prev_version != nullptr;\n@@ -4088,1 +4088,1 @@\n-  assert(scratch_class->previous_versions() == NULL, \"shouldn't have a previous version\");\n+  assert(scratch_class->previous_versions() == nullptr, \"shouldn't have a previous version\");\n@@ -4096,1 +4096,1 @@\n-  Method* m = NULL;\n+  Method* m = nullptr;\n@@ -4100,1 +4100,1 @@\n-  if (m == NULL || m->method_idnum() != idnum) {\n+  if (m == nullptr || m->method_idnum() != idnum) {\n@@ -4108,1 +4108,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -4116,1 +4116,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -4119,1 +4119,1 @@\n-  if (m != NULL && m->orig_method_idnum() == idnum) {\n+  if (m != nullptr && m->orig_method_idnum() == idnum) {\n@@ -4130,1 +4130,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -4136,2 +4136,2 @@\n-  if (holder == NULL) {\n-    return NULL; \/\/ The version of klass is gone, no method is found\n+  if (holder == nullptr) {\n+    return nullptr; \/\/ The version of klass is gone, no method is found\n@@ -4160,2 +4160,2 @@\n-  assert(_current != NULL, \"required\");\n-  if (_visit_subclasses && _current->subklass() != NULL) {\n+  assert(_current != nullptr, \"required\");\n+  if (_visit_subclasses && _current->subklass() != nullptr) {\n@@ -4166,1 +4166,1 @@\n-  while (_current->next_sibling() == NULL && _current != _root) {\n+  while (_current->next_sibling() == nullptr && _current != _root) {\n@@ -4171,1 +4171,1 @@\n-    _current = NULL;\n+    _current = nullptr;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":310,"deletions":310,"binary":false,"changes":620,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-\/\/ If \"obj\" argument to constructor is NULL, prints static fields, otherwise prints non-static fields.\n+\/\/ If \"obj\" argument to constructor is null, prints static fields, otherwise prints non-static fields.\n@@ -86,1 +86,1 @@\n-   FieldPrinter(outputStream* st, oop obj = NULL) : _obj(obj), _st(st) {}\n+   FieldPrinter(outputStream* st, oop obj = nullptr) : _obj(obj), _st(st) {}\n@@ -204,1 +204,1 @@\n-  \/\/ the source debug extension for this klass, NULL if not specified.\n+  \/\/ the source debug extension for this klass, null if not specified.\n@@ -206,1 +206,1 @@\n-  \/\/ it is stored in the instanceklass as a NULL-terminated UTF-8 string\n+  \/\/ it is stored in the instanceklass as a null-terminated UTF-8 string\n@@ -241,1 +241,1 @@\n-  jmethodID*      volatile _methods_jmethod_ids;  \/\/ jmethodIDs corresponding to method_idnum, or NULL if none\n+  jmethodID*      volatile _methods_jmethod_ids;  \/\/ jmethodIDs corresponding to method_idnum, or null if none\n@@ -297,1 +297,1 @@\n-  \/\/     NULL: no implementor.\n+  \/\/     null: no implementor.\n@@ -385,1 +385,1 @@\n-    guarantee(_local_interfaces == NULL || a == NULL, \"Just checking\");\n+    guarantee(_local_interfaces == nullptr || a == nullptr, \"Just checking\");\n@@ -390,1 +390,1 @@\n-    guarantee(_transitive_interfaces == NULL || a == NULL, \"Just checking\");\n+    guarantee(_transitive_interfaces == nullptr || a == nullptr, \"Just checking\");\n@@ -409,1 +409,1 @@\n-    guarantee(_fields == NULL || f == NULL, \"Just checking\");\n+    guarantee(_fields == nullptr || f == nullptr, \"Just checking\");\n@@ -447,1 +447,1 @@\n-    assert(_nest_host != NULL, \"must be\");\n+    assert(_nest_host != nullptr, \"must be\");\n@@ -452,1 +452,1 @@\n-  \/\/ Returns NULL if there was no error.\n+  \/\/ Returns null if there was no error.\n@@ -455,1 +455,1 @@\n-  \/\/ Returns NULL if resolution is not possible from the calling context.\n+  \/\/ Returns null if resolution is not possible from the calling context.\n@@ -481,1 +481,1 @@\n-  bool in_unnamed_package() const   { return (_package_entry == NULL); }\n+  bool in_unnamed_package() const   { return (_package_entry == nullptr); }\n@@ -586,1 +586,1 @@\n-  \/\/ find a local method (returns NULL if not found)\n+  \/\/ find a local method (returns null if not found)\n@@ -600,1 +600,1 @@\n-  \/\/ find a local method (returns NULL if not found)\n+  \/\/ find a local method (returns null if not found)\n@@ -607,1 +607,1 @@\n-  \/\/ find a local method from given methods array (returns NULL if not found)\n+  \/\/ find a local method from given methods array (returns null if not found)\n@@ -623,1 +623,1 @@\n-  \/\/ lookup operation (returns NULL if not found)\n+  \/\/ lookup operation (returns null if not found)\n@@ -630,1 +630,1 @@\n-  \/\/ (returns NULL if not found)\n+  \/\/ (returns null if not found)\n@@ -634,1 +634,1 @@\n-  \/\/ (returns NULL if not found)\n+  \/\/ (returns null if not found)\n@@ -709,1 +709,1 @@\n-  InstanceKlass* previous_versions() const { return NULL; }\n+  InstanceKlass* previous_versions() const { return nullptr; }\n@@ -713,1 +713,1 @@\n-    for (InstanceKlass* ik = this; ik != NULL; ik = ik->previous_versions()) {\n+    for (InstanceKlass* ik = this; ik != nullptr; ik = ik->previous_versions()) {\n@@ -718,1 +718,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -739,1 +739,1 @@\n-    _previous_versions = NULL;\n+    _previous_versions = nullptr;\n@@ -775,1 +775,1 @@\n-    assert(data == NULL, \"unexpected call with JVMTI disabled\");\n+    assert(data == nullptr, \"unexpected call with JVMTI disabled\");\n@@ -777,1 +777,1 @@\n-  JvmtiCachedClassFileData * get_cached_class_file() { return (JvmtiCachedClassFileData *)NULL; }\n+  JvmtiCachedClassFileData * get_cached_class_file() { return (JvmtiCachedClassFileData *)nullptr; }\n@@ -822,1 +822,1 @@\n-    return (_annotations != NULL) ? _annotations->class_annotations() : NULL;\n+    return (_annotations != nullptr) ? _annotations->class_annotations() : nullptr;\n@@ -825,1 +825,1 @@\n-    return (_annotations != NULL) ? _annotations->fields_annotations() : NULL;\n+    return (_annotations != nullptr) ? _annotations->fields_annotations() : nullptr;\n@@ -828,1 +828,1 @@\n-    return (_annotations != NULL) ? _annotations->class_type_annotations() : NULL;\n+    return (_annotations != nullptr) ? _annotations->class_type_annotations() : nullptr;\n@@ -831,1 +831,1 @@\n-    return (_annotations != NULL) ? _annotations->fields_type_annotations() : NULL;\n+    return (_annotations != nullptr) ? _annotations->fields_type_annotations() : nullptr;\n@@ -928,1 +928,1 @@\n-    assert(k != NULL, \"k should not be null\");\n+    assert(k != nullptr, \"k should not be null\");\n@@ -934,1 +934,1 @@\n-    return (super() == NULL) ? NULL : cast(super());\n+    return (super() == nullptr) ? nullptr : cast(super());\n@@ -1088,1 +1088,1 @@\n-  \/\/ going from NULL to non-NULL.\n+  \/\/ going from null to non-null.\n@@ -1116,1 +1116,1 @@\n-  \/\/ find a local method (returns NULL if not found)\n+  \/\/ find a local method (returns null if not found)\n@@ -1249,1 +1249,1 @@\n-    if (k->inner_classes() != NULL) {\n+    if (k->inner_classes() != nullptr) {\n@@ -1335,1 +1335,1 @@\n-    return (_current == NULL);\n+    return (_current == nullptr);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":35,"deletions":35,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -190,1 +190,1 @@\n-  if (k == NULL) {\n+  if (k == nullptr) {\n@@ -192,1 +192,1 @@\n-    THROW_(vmSymbols::java_lang_InstantiationException(), NULL);\n+    THROW_(vmSymbols::java_lang_InstantiationException(), nullptr);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-  if (k != NULL && k->is_instance_klass()) {\n+  if (k != nullptr && k->is_instance_klass()) {\n@@ -64,1 +64,1 @@\n-  if (k != NULL && k->is_instance_klass()) {\n+  if (k != nullptr && k->is_instance_klass()) {\n","filename":"src\/hotspot\/share\/oops\/instanceMirrorKlass.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,3 +55,3 @@\n-    \/\/ We'll get NULL for primitive mirrors.\n-    if (klass != NULL) {\n-      if (klass->class_loader_data() == NULL) {\n+    \/\/ We'll get null for primitive mirrors.\n+    if (klass != nullptr) {\n+      if (klass->class_loader_data() == nullptr) {\n@@ -74,1 +74,1 @@\n-      \/\/ We would like to assert here (as below) that if klass has been NULL, then\n+      \/\/ We would like to assert here (as below) that if klass has been null, then\n@@ -128,2 +128,2 @@\n-      \/\/ We'll get NULL for primitive mirrors.\n-      if (klass != NULL) {\n+      \/\/ We'll get null for primitive mirrors.\n+      if (klass != nullptr) {\n","filename":"src\/hotspot\/share\/oops\/instanceMirrorKlass.inline.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,1 +115,1 @@\n-  if (referent != NULL) {\n+  if (referent != nullptr) {\n@@ -120,1 +120,1 @@\n-  if (next != NULL) {\n+  if (next != nullptr) {\n","filename":"src\/hotspot\/share\/oops\/instanceRefKlass.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,1 @@\n-  if (rd != NULL) {\n+  if (rd != nullptr) {\n@@ -71,1 +71,1 @@\n-    if (referent != NULL) {\n+    if (referent != nullptr) {\n@@ -103,1 +103,1 @@\n-  assert(closure->ref_discoverer() == NULL, \"ReferenceDiscoverer should not be set\");\n+  assert(closure->ref_discoverer() == nullptr, \"ReferenceDiscoverer should not be set\");\n@@ -110,1 +110,1 @@\n-  assert(closure->ref_discoverer() == NULL, \"ReferenceDiscoverer should not be set\");\n+  assert(closure->ref_discoverer() == nullptr, \"ReferenceDiscoverer should not be set\");\n","filename":"src\/hotspot\/share\/oops\/instanceRefKlass.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -238,1 +238,1 @@\n-    st->print_cr(\"CHUNK NULL\");\n+    st->print_cr(\"CHUNK null\");\n","filename":"src\/hotspot\/share\/oops\/instanceStackChunkKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-  if (_name != NULL) _name->increment_refcount();\n+  if (_name != nullptr) _name->increment_refcount();\n@@ -99,1 +99,1 @@\n-  while (t != NULL) {\n+  while (t != nullptr) {\n@@ -107,1 +107,1 @@\n-  if (_name != NULL) _name->decrement_refcount();\n+  if (_name != nullptr) _name->decrement_refcount();\n@@ -134,1 +134,1 @@\n-    if (s == NULL || s->next_sibling() != NULL) \/\/ Oops; wrong count; give up\n+    if (s == nullptr || s->next_sibling() != nullptr) \/\/ Oops; wrong count; give up\n@@ -162,1 +162,1 @@\n-  assert(s != NULL, \"Throw NPE!\");\n+  assert(s != nullptr, \"Throw NPE!\");\n@@ -179,1 +179,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -191,1 +191,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -231,1 +231,1 @@\n-  if (super() == NULL)\n+  if (super() == nullptr)\n@@ -240,2 +240,2 @@\n-  if (k == NULL) {\n-    set_super(NULL);\n+  if (k == nullptr) {\n+    set_super(nullptr);\n@@ -245,1 +245,1 @@\n-    assert(super() == NULL || super() == vmClasses::Object_klass(),\n+    assert(super() == nullptr || super() == vmClasses::Object_klass(),\n@@ -276,1 +276,1 @@\n-        assert(primary_super_of_depth(j1) == NULL, \"super list padding\");\n+        assert(primary_super_of_depth(j1) == nullptr, \"super list padding\");\n@@ -278,1 +278,1 @@\n-      while (t != NULL) {\n+      while (t != nullptr) {\n@@ -288,1 +288,1 @@\n-  if (secondary_supers() == NULL) {\n+  if (secondary_supers() == nullptr) {\n@@ -295,1 +295,1 @@\n-    for (p = super(); !(p == NULL || p->can_be_primary_super()); p = p->super()) {\n+    for (p = super(); !(p == nullptr || p->can_be_primary_super()); p = p->super()) {\n@@ -303,1 +303,1 @@\n-    if (secondaries == NULL) {\n+    if (secondaries == nullptr) {\n@@ -310,1 +310,1 @@\n-    for (p = super(); !(p == NULL || p->can_be_primary_super()); p = p->super()) {\n+    for (p = super(); !(p == nullptr || p->can_be_primary_super()); p = p->super()) {\n@@ -342,1 +342,1 @@\n-      \/\/ We must not copy any NULL placeholders left over from bootstrap.\n+      \/\/ We must not copy any null placeholders left over from bootstrap.\n@@ -344,1 +344,1 @@\n-      assert(s2->at(j) != NULL, \"correct bootstrapping order\");\n+      assert(s2->at(j) != nullptr, \"correct bootstrapping order\");\n@@ -355,1 +355,1 @@\n-  assert(transitive_interfaces == NULL, \"sanity\");\n+  assert(transitive_interfaces == nullptr, \"sanity\");\n@@ -357,1 +357,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -363,2 +363,2 @@\n-  assert(super() == NULL || super()->is_instance_klass(), \"must be instance klass\");\n-  return _super == NULL ? NULL : InstanceKlass::cast(_super);\n+  assert(super() == nullptr || super()->is_instance_klass(), \"must be instance klass\");\n+  return _super == nullptr ? nullptr : InstanceKlass::cast(_super);\n@@ -374,1 +374,1 @@\n-       chain != NULL;\n+       chain != nullptr;\n@@ -388,1 +388,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -395,1 +395,1 @@\n-       chain != NULL;\n+       chain != nullptr;\n@@ -408,1 +408,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -431,1 +431,1 @@\n-  if (super == NULL) return;        \/\/ special case: class Object\n+  if (super == nullptr) return;     \/\/ special case: class Object\n@@ -433,1 +433,1 @@\n-          && (super->superklass() == NULL || !is_interface())),\n+          && (super->superklass() == nullptr || !is_interface())),\n@@ -441,1 +441,1 @@\n-    if (prev_first_subklass != NULL) {\n+    if (prev_first_subklass != nullptr) {\n@@ -460,1 +460,1 @@\n-    if (subklass == NULL || subklass->is_loader_alive()) {\n+    if (subklass == nullptr || subklass->is_loader_alive()) {\n@@ -485,1 +485,1 @@\n-    if (sub != NULL) {\n+    if (sub != nullptr) {\n@@ -492,1 +492,1 @@\n-    if (sibling != NULL) {\n+    if (sibling != nullptr) {\n@@ -503,1 +503,1 @@\n-      while ((ik = ik->previous_versions()) != NULL) {\n+      while ((ik = ik->previous_versions()) != nullptr) {\n@@ -525,1 +525,1 @@\n-    \/\/ to follow these pointers anyway, as they will be set to NULL in\n+    \/\/ to follow these pointers anyway, as they will be set to null in\n@@ -548,3 +548,3 @@\n-  set_subklass(NULL);\n-  set_next_sibling(NULL);\n-  set_next_link(NULL);\n+  set_subklass(nullptr);\n+  set_next_sibling(nullptr);\n+  set_next_link(nullptr);\n@@ -553,1 +553,1 @@\n-  set_class_loader_data(NULL);\n+  set_class_loader_data(nullptr);\n@@ -579,1 +579,1 @@\n-  if (class_loader_data() == NULL) {\n+  if (class_loader_data() == nullptr) {\n@@ -588,1 +588,1 @@\n-  ModuleEntry* module_entry = NULL;\n+  ModuleEntry* module_entry = nullptr;\n@@ -601,1 +601,1 @@\n-  Handle module_handle(THREAD, ((module_entry != NULL) ? module_entry->module() : (oop)NULL));\n+  Handle module_handle(THREAD, ((module_entry != nullptr) ? module_entry->module() : (oop)nullptr));\n@@ -623,1 +623,1 @@\n-  if (java_mirror() == NULL) {\n+  if (java_mirror() == nullptr) {\n@@ -692,1 +692,1 @@\n-  if (name() == NULL)  return \"<unknown>\";\n+  if (name() == nullptr)  return \"<unknown>\";\n@@ -697,1 +697,1 @@\n-  if (name() == NULL)  return \"<unknown>\";\n+  if (name() == nullptr)  return \"<unknown>\";\n@@ -772,1 +772,1 @@\n-  if (super() != NULL) {\n+  if (super() != nullptr) {\n@@ -775,1 +775,1 @@\n-  if (secondary_super_cache() != NULL) {\n+  if (secondary_super_cache() != nullptr) {\n@@ -781,1 +781,1 @@\n-    if (ko != NULL) {\n+    if (ko != nullptr) {\n@@ -786,1 +786,1 @@\n-  if (java_mirror_no_keepalive() != NULL) {\n+  if (java_mirror_no_keepalive() != nullptr) {\n@@ -849,1 +849,1 @@\n-  if (joint_description == NULL) {\n+  if (joint_description == nullptr) {\n@@ -908,1 +908,1 @@\n-  assert(cld != NULL, \"class_loader_data should not be null\");\n+  assert(cld != nullptr, \"class_loader_data should not be null\");\n@@ -922,1 +922,1 @@\n-    if (parent_cld == NULL) {\n+    if (parent_cld == nullptr) {\n@@ -924,1 +924,1 @@\n-      if (cl_name_and_id != NULL) {\n+      if (cl_name_and_id != nullptr) {\n@@ -941,1 +941,1 @@\n-  if (class_description == NULL) {\n+  if (class_description == nullptr) {\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":54,"deletions":54,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -148,1 +148,1 @@\n-  \/\/ First subclass (NULL if none); _subklass->next_sibling() is next one\n+  \/\/ First subclass (null if none); _subklass->next_sibling() is next one\n@@ -150,1 +150,1 @@\n-  \/\/ Sibling link (or NULL); links all subklasses of a klass\n+  \/\/ Sibling link (or null); links all subklasses of a klass\n@@ -223,1 +223,1 @@\n-  virtual InstanceKlass* java_super() const  { return NULL; }\n+  virtual InstanceKlass* java_super() const  { return nullptr; }\n@@ -235,1 +235,1 @@\n-  \/\/ If there is no such element, return either NULL or this.\n+  \/\/ If there is no such element, return either null or this.\n@@ -239,1 +239,1 @@\n-    assert(super == NULL || super->super_depth() == i, \"correct display\");\n+    assert(super == nullptr || super->super_depth() == i, \"correct display\");\n@@ -268,1 +268,1 @@\n-  oop archived_java_mirror() NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n+  oop archived_java_mirror() NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n@@ -275,1 +275,1 @@\n-  \/\/ Set java mirror OopHandle to NULL for CDS\n+  \/\/ Set java mirror OopHandle to null for CDS\n@@ -531,1 +531,1 @@\n-  \/\/ These will return NULL instead of allocating on the heap:\n+  \/\/ These will return null instead of allocating on the heap:\n@@ -570,1 +570,1 @@\n-    } else if (_java_mirror.ptr_raw() == NULL) {\n+    } else if (_java_mirror.ptr_raw() == nullptr) {\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,1 @@\n-  vtable_length = super == NULL ? 0 : super->vtable_length();\n+  vtable_length = super == nullptr ? 0 : super->vtable_length();\n@@ -93,1 +93,1 @@\n-  get_mirandas(&new_mirandas, all_mirandas, super, methods, NULL, local_interfaces,\n+  get_mirandas(&new_mirandas, all_mirandas, super, methods, nullptr, local_interfaces,\n@@ -109,1 +109,1 @@\n-  if (super == NULL && vtable_length != Universe::base_vtable_size()) {\n+  if (super == nullptr && vtable_length != Universe::base_vtable_size()) {\n@@ -134,1 +134,1 @@\n-  if (super == NULL) {\n+  if (super == nullptr) {\n@@ -215,1 +215,1 @@\n-    if (default_methods != NULL) {\n+    if (default_methods != nullptr) {\n@@ -219,1 +219,1 @@\n-        assert(def_vtable_indices != NULL, \"should be created\");\n+        assert(def_vtable_indices != nullptr, \"should be created\");\n@@ -317,1 +317,1 @@\n-  while (superk != NULL && superk->super() != NULL) {\n+  while (superk != nullptr && superk->super() != nullptr) {\n@@ -346,1 +346,1 @@\n-      superk = (InstanceKlass*)NULL;\n+      superk = (InstanceKlass*)nullptr;\n@@ -350,1 +350,1 @@\n-    superk = superk->super() == NULL ? NULL : InstanceKlass::cast(superk->super());\n+    superk = superk->super() == nullptr ? nullptr : InstanceKlass::cast(superk->super());\n@@ -391,1 +391,1 @@\n-  Array<int>* def_vtable_indices = NULL;\n+  Array<int>* def_vtable_indices = nullptr;\n@@ -403,1 +403,1 @@\n-    assert(def_vtable_indices != NULL, \"def vtable alloc?\");\n+    assert(def_vtable_indices != nullptr, \"def vtable alloc?\");\n@@ -441,1 +441,1 @@\n-  if (super == NULL) {\n+  if (super == nullptr) {\n@@ -454,2 +454,2 @@\n-  assert(target_klass != NULL, \"impossible\");\n-  if (target_klass == NULL) {\n+  assert(target_klass != nullptr, \"impossible\");\n+  if (target_klass == nullptr) {\n@@ -494,1 +494,1 @@\n-                                                     target_classname)) != NULL))) {\n+                                                     target_classname)) != nullptr))) {\n@@ -507,1 +507,1 @@\n-        if (supers != NULL) {\n+        if (supers != nullptr) {\n@@ -515,1 +515,1 @@\n-          if (def_vtable_indices != NULL) {\n+          if (def_vtable_indices != nullptr) {\n@@ -553,1 +553,1 @@\n-      const char* sig = (m != NULL) ? m->name_and_sig_as_C_string() : \"<NULL>\";\n+      const char* sig = (m != nullptr) ? m->name_and_sig_as_C_string() : \"<null>\";\n@@ -555,1 +555,1 @@\n-      if (m != NULL) {\n+      if (m != nullptr) {\n@@ -571,1 +571,1 @@\n-    if (target_method() != NULL && super_klass != NULL) {\n+    if (target_method() != nullptr && super_klass != nullptr) {\n@@ -592,1 +592,1 @@\n-          if (failed_type_symbol != NULL) {\n+          if (failed_type_symbol != nullptr) {\n@@ -618,1 +618,1 @@\n-  GrowableArray<InstanceKlass*>* supers = new GrowableArray<InstanceKlass*>(_length, _length, NULL);\n+  GrowableArray<InstanceKlass*>* supers = new GrowableArray<InstanceKlass*>(_length, _length, nullptr);\n@@ -663,1 +663,1 @@\n-  if (target_method->method_holder() != NULL &&\n+  if (target_method->method_holder() != nullptr &&\n@@ -672,1 +672,1 @@\n-  if (super == NULL) {\n+  if (super == nullptr) {\n@@ -687,3 +687,3 @@\n-  Method* super_method = NULL;\n-  InstanceKlass *holder = NULL;\n-  Method* recheck_method =  NULL;\n+  Method* super_method = nullptr;\n+  InstanceKlass *holder = nullptr;\n+  Method* recheck_method =  nullptr;\n@@ -691,1 +691,1 @@\n-  while (k != NULL) {\n+  while (k != nullptr) {\n@@ -694,1 +694,1 @@\n-    if (super_method == NULL) {\n+    if (super_method == nullptr) {\n@@ -746,1 +746,1 @@\n-    if (sk->lookup_method_in_all_interfaces(name, signature, Klass::DefaultsLookupMode::find) != NULL) {\n+    if (sk->lookup_method_in_all_interfaces(name, signature, Klass::DefaultsLookupMode::find) != nullptr) {\n@@ -852,1 +852,1 @@\n-                                       Klass::PrivateLookupMode::skip) != NULL)\n+                                       Klass::PrivateLookupMode::skip) != nullptr)\n@@ -858,2 +858,2 @@\n-  if ((default_methods != NULL) &&\n-    (InstanceKlass::find_method(default_methods, name, signature) != NULL))\n+  if ((default_methods != nullptr) &&\n+    (InstanceKlass::find_method(default_methods, name, signature) != nullptr))\n@@ -869,1 +869,1 @@\n-  for (const Klass* cursuper = super; cursuper != NULL; cursuper = cursuper->super())\n+  for (const Klass* cursuper = super; cursuper != nullptr; cursuper = cursuper->super())\n@@ -876,1 +876,1 @@\n-     if (found_mth != NULL && (!is_interface ||\n+     if (found_mth != nullptr && (!is_interface ||\n@@ -918,1 +918,1 @@\n-        if (sk->lookup_method_in_all_interfaces(im->name(), im->signature(), Klass::DefaultsLookupMode::find) == NULL) {\n+        if (sk->lookup_method_in_all_interfaces(im->name(), im->signature(), Klass::DefaultsLookupMode::find) == nullptr) {\n@@ -921,1 +921,1 @@\n-        if (all_mirandas != NULL) {\n+        if (all_mirandas != nullptr) {\n@@ -965,1 +965,1 @@\n-  get_mirandas(&mirandas, NULL, ik()->super(), ik()->methods(),\n+  get_mirandas(&mirandas, nullptr, ik()->super(), ik()->methods(),\n@@ -973,1 +973,1 @@\n-      if (meth != NULL) {\n+      if (meth != nullptr) {\n@@ -1000,1 +1000,1 @@\n-  if (default_methods != NULL) {\n+  if (default_methods != nullptr) {\n@@ -1022,1 +1022,1 @@\n-    if (old_method == NULL || !old_method->is_old()) {\n+    if (old_method == nullptr || !old_method->is_old()) {\n@@ -1055,1 +1055,1 @@\n-    if (m != NULL &&\n+    if (m != nullptr &&\n@@ -1070,1 +1070,1 @@\n-    if (m != NULL) {\n+    if (m != nullptr) {\n@@ -1092,1 +1092,1 @@\n-  if (m == NULL) return;\n+  if (m == nullptr) return;\n@@ -1115,1 +1115,1 @@\n-    if (offset_entry  != NULL && offset_entry->interface_klass() != NULL) { \/\/ Check that itable is initialized\n+    if (offset_entry  != nullptr && offset_entry->interface_klass() != nullptr) { \/\/ Check that itable is initialized\n@@ -1164,1 +1164,1 @@\n-      assert(interf != NULL && ioe->offset() != 0, \"bad offset entry in itable\");\n+      assert(interf != nullptr && ioe->offset() != 0, \"bad offset entry in itable\");\n@@ -1171,1 +1171,1 @@\n-  guarantee(ioe->interface_klass() == NULL && ioe->offset() == 0, \"terminator entry missing\");\n+  guarantee(ioe->interface_klass() == nullptr && ioe->offset() == 0, \"terminator entry missing\");\n@@ -1182,1 +1182,1 @@\n-    if (target != NULL && interface_method != NULL) {\n+    if (target != nullptr && interface_method != nullptr) {\n@@ -1197,1 +1197,1 @@\n-        if (failed_type_symbol != NULL) {\n+        if (failed_type_symbol != nullptr) {\n@@ -1226,1 +1226,1 @@\n-    new GrowableArray<Method*>(_size_method_table, _size_method_table, NULL);\n+    new GrowableArray<Method*>(_size_method_table, _size_method_table, nullptr);\n@@ -1262,1 +1262,1 @@\n-        assert(m != NULL, \"methods can never be null\");\n+        assert(m != nullptr, \"methods can never be null\");\n@@ -1324,1 +1324,1 @@\n-    Method* target = NULL;\n+    Method* target = nullptr;\n@@ -1335,2 +1335,2 @@\n-    if (target == NULL || !target->is_public() || target->is_abstract() || target->is_overpass()) {\n-      assert(target == NULL || !target->is_overpass() || target->is_public(),\n+    if (target == nullptr || !target->is_public() || target->is_abstract() || target->is_overpass()) {\n+      assert(target == nullptr || !target->is_overpass() || target->is_public(),\n@@ -1339,1 +1339,1 @@\n-      if (!(target == NULL) && !target->is_public()) {\n+      if (!(target == nullptr) && !target->is_public()) {\n@@ -1351,1 +1351,1 @@\n-      if (supers != NULL) {\n+      if (supers != nullptr) {\n@@ -1358,1 +1358,1 @@\n-        if (target != NULL) {\n+        if (target != nullptr) {\n@@ -1382,1 +1382,1 @@\n-    if (old_method == NULL || !old_method->is_old()) {\n+    if (old_method == nullptr || !old_method->is_old()) {\n@@ -1405,1 +1405,1 @@\n-    if (m != NULL &&\n+    if (m != nullptr &&\n@@ -1422,1 +1422,1 @@\n-    if (m != NULL) {\n+    if (m != nullptr) {\n@@ -1573,1 +1573,1 @@\n-  if (super != NULL) {\n+  if (super != nullptr) {\n@@ -1605,1 +1605,1 @@\n-    assert(method() != NULL, \"must have set method\");\n+    assert(method() != nullptr, \"must have set method\");\n@@ -1607,1 +1607,1 @@\n-  if (method() != NULL) {\n+  if (method() != nullptr) {\n","filename":"src\/hotspot\/share\/oops\/klassVtable.cpp","additions":64,"deletions":64,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,1 @@\n-  void initialize_vtable(GrowableArray<InstanceKlass*>* supers = NULL);\n+  void initialize_vtable(GrowableArray<InstanceKlass*>* supers = nullptr);\n@@ -193,2 +193,2 @@\n-  void set(Method* method)  { assert(method != NULL, \"use clear\"); _method = method; }\n-  void clear()                { _method = NULL; }\n+  void set(Method* method)  { assert(method != nullptr, \"use clear\"); _method = method; }\n+  void clear()                { _method = nullptr; }\n@@ -204,1 +204,1 @@\n-  assert(table()[i].method() != NULL, \"should not be null\");\n+  assert(table()[i].method() != nullptr, \"should not be null\");\n@@ -249,1 +249,1 @@\n-  void clear()             { _method = NULL; }\n+  void clear()             { _method = nullptr; }\n@@ -301,1 +301,1 @@\n-  void initialize_itable(GrowableArray<Method*>* supers = NULL);\n+  void initialize_itable(GrowableArray<Method*>* supers = nullptr);\n","filename":"src\/hotspot\/share\/oops\/klassVtable.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,2 +72,2 @@\n-      if (mon == NULL) {\n-        st->print(\"NULL (this should never be seen!)\");\n+      if (mon == nullptr) {\n+        st->print(\"null (this should never be seen!)\");\n","filename":"src\/hotspot\/share\/oops\/markWord.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,2 +57,2 @@\n-    if (NULL == m)\n-      st->print(\"NULL\");\n+    if (nullptr == m)\n+      st->print(\"null\");\n","filename":"src\/hotspot\/share\/oops\/metadata.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -110,1 +110,1 @@\n-  set_method_data(NULL);\n+  set_method_data(nullptr);\n@@ -115,2 +115,2 @@\n-  set_interpreter_entry(NULL); \/\/ sets i2i entry and from_int\n-  set_adapter_entry(NULL);\n+  set_interpreter_entry(nullptr); \/\/ sets i2i entry and from_int\n+  set_adapter_entry(nullptr);\n@@ -121,1 +121,1 @@\n-    set_signature_handler(NULL);\n+    set_signature_handler(nullptr);\n@@ -133,1 +133,1 @@\n-  set_constMethod(NULL);\n+  set_constMethod(nullptr);\n@@ -135,1 +135,1 @@\n-  set_method_data(NULL);\n+  set_method_data(nullptr);\n@@ -139,1 +139,1 @@\n-  if (code() != NULL) _code = NULL;\n+  if (code() != nullptr) _code = nullptr;\n@@ -152,1 +152,1 @@\n-  assert(adapter() != NULL, \"must have\");\n+  assert(adapter() != nullptr, \"must have\");\n@@ -157,1 +157,1 @@\n-  assert(adapter() != NULL, \"must have\");\n+  assert(adapter() != nullptr, \"must have\");\n@@ -162,1 +162,1 @@\n-  assert(adapter() != NULL, \"must have\");\n+  assert(adapter() != nullptr, \"must have\");\n@@ -168,1 +168,1 @@\n-  assert(adapter() != NULL, \"must have\");\n+  assert(adapter() != nullptr, \"must have\");\n@@ -236,1 +236,1 @@\n-                          ex_klass == NULL ? \"NULL\" : ex_klass->external_name(), mh->name()->as_C_string());\n+                          ex_klass == nullptr ? \"null\" : ex_klass->external_name(), mh->name()->as_C_string());\n@@ -263,1 +263,1 @@\n-                               ex_klass == NULL ? \"NULL\" : ex_klass->external_name(), mh->name()->as_C_string(), handler_bci);\n+                               ex_klass == nullptr ? \"null\" : ex_klass->external_name(), mh->name()->as_C_string(), handler_bci);\n@@ -266,1 +266,1 @@\n-      } else if (ex_klass == NULL) {\n+      } else if (ex_klass == nullptr) {\n@@ -270,1 +270,1 @@\n-          log_info(exceptions)(\"NULL exception class is implicitly caught by handler in method \\\"%s\\\" at BCI: %d\",\n+          log_info(exceptions)(\"null exception class is implicitly caught by handler in method \\\"%s\\\" at BCI: %d\",\n@@ -292,1 +292,1 @@\n-        assert(k != NULL, \"klass not loaded\");\n+        assert(k != nullptr, \"klass not loaded\");\n@@ -297,1 +297,1 @@\n-                                 ex_klass == NULL ? \"NULL\" : ex_klass->external_name(), mh->name()->as_C_string(), handler_bci);\n+                                 ex_klass == nullptr ? \"null\" : ex_klass->external_name(), mh->name()->as_C_string(), handler_bci);\n@@ -372,1 +372,1 @@\n-  if (is_native() && bcp == NULL) {\n+  if (is_native() && bcp == nullptr) {\n@@ -467,1 +467,1 @@\n-    if (trial_name == NULL) {\n+    if (trial_name == nullptr) {\n@@ -471,1 +471,1 @@\n-    if (method == NULL) {\n+    if (method == nullptr) {\n@@ -483,1 +483,1 @@\n-  return NULL; \/\/ not found\n+  return nullptr; \/\/ not found\n@@ -488,1 +488,1 @@\n-  if (method == NULL) {\n+  if (method == nullptr) {\n@@ -499,1 +499,1 @@\n-    if (method == NULL) {\n+    if (method == nullptr) {\n@@ -509,1 +509,1 @@\n-  if (entry != NULL) {\n+  if (entry != nullptr) {\n@@ -527,1 +527,1 @@\n-  if (is_accessor() || is_empty_method() || (code() != NULL)) {\n+  if (is_accessor() || is_empty_method() || (code() != nullptr)) {\n@@ -532,1 +532,1 @@\n-  else if ((method_counters() != NULL &&\n+  else if ((method_counters() != nullptr &&\n@@ -534,1 +534,1 @@\n-           (method_data() != NULL &&\n+           (method_data() != nullptr &&\n@@ -571,1 +571,1 @@\n-  if (method_data() != NULL) {\n+  if (method_data() != nullptr) {\n@@ -617,1 +617,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -636,1 +636,1 @@\n-  if (counters == NULL) {\n+  if (counters == nullptr) {\n@@ -639,1 +639,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -796,1 +796,1 @@\n-  if (method_holder() != NULL &&\n+  if (method_holder() != nullptr &&\n@@ -974,1 +974,1 @@\n-    return SystemDictionary::find_instance_klass(thread, klass_name, loader, prot) != NULL;\n+    return SystemDictionary::find_instance_klass(thread, klass_name, loader, prot) != nullptr;\n@@ -992,1 +992,1 @@\n-  assert(function != NULL, \"use clear_native_function to unregister natives\");\n+  assert(function != nullptr, \"use clear_native_function to unregister natives\");\n@@ -1001,1 +1001,1 @@\n-      function != NULL) {\n+      function != nullptr) {\n@@ -1016,1 +1016,1 @@\n-  if (nm != NULL) {\n+  if (nm != nullptr) {\n@@ -1026,1 +1026,1 @@\n-  return (func != NULL && func != SharedRuntime::native_method_throw_unsatisfied_link_error_entry());\n+  return (func != nullptr && func != SharedRuntime::native_method_throw_unsatisfied_link_error_entry());\n@@ -1046,1 +1046,1 @@\n-  assert(reason != NULL, \"must provide a reason\");\n+  assert(reason != nullptr, \"must provide a reason\");\n@@ -1060,1 +1060,1 @@\n-    if (reason != NULL) {\n+    if (reason != nullptr) {\n@@ -1065,1 +1065,1 @@\n-  if ((TraceDeoptimization || LogCompilation) && (xtty != NULL)) {\n+  if ((TraceDeoptimization || LogCompilation) && (xtty != nullptr)) {\n@@ -1069,1 +1069,1 @@\n-    if (reason != NULL) {\n+    if (reason != nullptr) {\n@@ -1150,1 +1150,1 @@\n-  \/\/ this may be NULL if c2i adapters have not been made yet\n+  \/\/ this may be null if c2i adapters have not been made yet\n@@ -1152,2 +1152,2 @@\n-  if (adapter() == NULL) {\n-    _from_compiled_entry    = NULL;\n+  if (adapter() == nullptr) {\n+    _from_compiled_entry    = nullptr;\n@@ -1160,1 +1160,1 @@\n-  _code = NULL;\n+  _code = nullptr;\n@@ -1164,1 +1164,1 @@\n-  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? NULL : CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n+  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n@@ -1175,1 +1175,1 @@\n-  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? NULL : CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n+  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n@@ -1183,5 +1183,5 @@\n-  _code = NULL;\n-  _adapter = NULL;\n-  _i2i_entry = NULL;\n-  _from_compiled_entry = NULL;\n-  _from_interpreted_entry = NULL;\n+  _code = nullptr;\n+  _adapter = nullptr;\n+  _i2i_entry = nullptr;\n+  _from_compiled_entry = nullptr;\n+  _from_interpreted_entry = nullptr;\n@@ -1190,2 +1190,2 @@\n-    *native_function_addr() = NULL;\n-    set_signature_handler(NULL);\n+    *native_function_addr() = nullptr;\n+    set_signature_handler(nullptr);\n@@ -1195,1 +1195,1 @@\n-  set_method_data(NULL);\n+  set_method_data(nullptr);\n@@ -1205,1 +1205,1 @@\n-  if (adapter() != NULL) {\n+  if (adapter() != nullptr) {\n@@ -1208,1 +1208,1 @@\n-  assert( _code == NULL, \"nothing compiled yet\" );\n+  assert( _code == nullptr, \"nothing compiled yet\" );\n@@ -1213,1 +1213,1 @@\n-  assert(adapter() == NULL, \"init'd to NULL\");\n+  assert(adapter() == nullptr, \"init'd to null\");\n@@ -1215,1 +1215,1 @@\n-  assert(entry != NULL, \"interpreter entry must be non-null\");\n+  assert(entry != nullptr, \"interpreter entry must be non-null\");\n@@ -1240,3 +1240,3 @@\n-    _from_interpreted_entry = NULL;\n-    _from_compiled_entry = NULL;\n-    _i2i_entry = NULL;\n+    _from_interpreted_entry = nullptr;\n+    _from_compiled_entry = nullptr;\n+    _i2i_entry = nullptr;\n@@ -1251,1 +1251,1 @@\n-  if (adapter == NULL ) {\n+  if (adapter == nullptr ) {\n@@ -1276,1 +1276,1 @@\n-  assert(_from_compiled_entry != NULL, \"must be set\");\n+  assert(_from_compiled_entry != nullptr, \"must be set\");\n@@ -1286,1 +1286,1 @@\n-  return code == NULL || (code->method() == NULL) || (code->method() == (Method*)this && !code->is_osr_method());\n+  return code == nullptr || (code->method() == nullptr) || (code->method() == (Method*)this && !code->is_osr_method());\n@@ -1295,1 +1295,1 @@\n-  guarantee(mh->adapter() != NULL, \"Adapter blob must already exist!\");\n+  guarantee(mh->adapter() != nullptr, \"Adapter blob must already exist!\");\n@@ -1314,1 +1314,1 @@\n-    assert(mh->_from_interpreted_entry == NULL, \"initialized incorrectly\"); \/\/ see link_method\n+    assert(mh->_from_interpreted_entry == nullptr, \"initialized incorrectly\"); \/\/ see link_method\n@@ -1342,1 +1342,1 @@\n-    if (ik->lookup_method(name(), signature()) == NULL) {\n+    if (ik->lookup_method(name(), signature()) == nullptr) {\n@@ -1499,1 +1499,1 @@\n-  if (klass != NULL && klass->class_loader() != NULL) {\n+  if (klass != nullptr && klass->class_loader() != nullptr) {\n@@ -1504,1 +1504,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1617,1 +1617,1 @@\n-  \/\/ if loader is not the default loader (i.e., != NULL), we can't know the intrinsics\n+  \/\/ if loader is not the default loader (i.e., non-null), we can't know the intrinsics\n@@ -1622,1 +1622,1 @@\n-  if ((ik->class_loader() != NULL) && !SystemDictionary::is_platform_class_loader(ik->class_loader())) {\n+  if ((ik->class_loader() != nullptr) && !SystemDictionary::is_platform_class_loader(ik->class_loader())) {\n@@ -1716,1 +1716,1 @@\n-      if( klass == NULL) { sig_is_loaded = false; }\n+      if( klass == nullptr) { sig_is_loaded = false; }\n@@ -1747,1 +1747,1 @@\n-    if (func == NULL) {\n+    if (func == nullptr) {\n@@ -1848,1 +1848,1 @@\n-  for (; bp != NULL; bp = bp->next()) {\n+  for (; bp != nullptr; bp = bp->next()) {\n@@ -1863,1 +1863,1 @@\n-  for (; bp != NULL; bp = bp->next()) {\n+  for (; bp != nullptr; bp = bp->next()) {\n@@ -1882,1 +1882,1 @@\n-  BreakpointInfo* prev_bp = NULL;\n+  BreakpointInfo* prev_bp = nullptr;\n@@ -1884,1 +1884,1 @@\n-  for (BreakpointInfo* bp = ik->breakpoints(); bp != NULL; bp = next_bp) {\n+  for (BreakpointInfo* bp = ik->breakpoints(); bp != nullptr; bp = next_bp) {\n@@ -1891,1 +1891,1 @@\n-      if (prev_bp != NULL)\n+      if (prev_bp != nullptr)\n@@ -1930,2 +1930,2 @@\n-  if (((mcs != NULL) ? mcs->invocation_counter()->carry() : false) ||\n-      ((mdo != NULL) ? mdo->invocation_counter()->carry() : false)) {\n+  if (((mcs != nullptr) ? mcs->invocation_counter()->carry() : false) ||\n+      ((mdo != nullptr) ? mdo->invocation_counter()->carry() : false)) {\n@@ -1934,2 +1934,2 @@\n-    return ((mcs != NULL) ? mcs->invocation_counter()->count() : 0) +\n-           ((mdo != NULL) ? mdo->invocation_counter()->count() : 0);\n+    return ((mcs != nullptr) ? mcs->invocation_counter()->count() : 0) +\n+           ((mdo != nullptr) ? mdo->invocation_counter()->count() : 0);\n@@ -1942,2 +1942,2 @@\n-  if (((mcs != NULL) ? mcs->backedge_counter()->carry() : false) ||\n-      ((mdo != NULL) ? mdo->backedge_counter()->carry() : false)) {\n+  if (((mcs != nullptr) ? mcs->backedge_counter()->carry() : false) ||\n+      ((mdo != nullptr) ? mdo->backedge_counter()->carry() : false)) {\n@@ -1946,2 +1946,2 @@\n-    return ((mcs != NULL) ? mcs->backedge_counter()->count() : 0) +\n-           ((mdo != NULL) ? mdo->backedge_counter()->count() : 0);\n+    return ((mcs != nullptr) ? mcs->backedge_counter()->count() : 0) +\n+           ((mdo != nullptr) ? mdo->backedge_counter()->count() : 0);\n@@ -1953,1 +1953,1 @@\n-  if (mcs != NULL) {\n+  if (mcs != nullptr) {\n@@ -1962,1 +1962,1 @@\n-  if (mcs != NULL) {\n+  if (mcs != nullptr) {\n@@ -1971,1 +1971,1 @@\n-  if (mcs != NULL) {\n+  if (mcs != nullptr) {\n@@ -1978,1 +1978,1 @@\n-  if (mcs != NULL) {\n+  if (mcs != nullptr) {\n@@ -1992,1 +1992,1 @@\n-  _next = NULL;\n+  _next = nullptr;\n@@ -2052,1 +2052,1 @@\n-    if (_next == NULL) {\n+    if (_next == nullptr) {\n@@ -2074,1 +2074,1 @@\n-    for (JNIMethodBlockNode* b = _last_free; b != NULL; b = b->_next) {\n+    for (JNIMethodBlockNode* b = _last_free; b != nullptr; b = b->_next) {\n@@ -2096,1 +2096,1 @@\n-      if (b->_next == NULL) {\n+      if (b->_next == nullptr) {\n@@ -2101,1 +2101,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -2105,2 +2105,2 @@\n-    if (m == NULL) return false;\n-    for (JNIMethodBlockNode* b = &_head; b != NULL; b = b->_next) {\n+    if (m == nullptr) return false;\n+    for (JNIMethodBlockNode* b = &_head; b != nullptr; b = b->_next) {\n@@ -2136,1 +2136,1 @@\n-    for (JNIMethodBlockNode* b = &_head; b != NULL; b = b->_next) {\n+    for (JNIMethodBlockNode* b = &_head; b != nullptr; b = b->_next) {\n@@ -2138,1 +2138,1 @@\n-        b->_methods[i] = NULL;\n+        b->_methods[i] = nullptr;\n@@ -2146,1 +2146,1 @@\n-    for (JNIMethodBlockNode* b = &_head; b != NULL; b = b->_next) {\n+    for (JNIMethodBlockNode* b = &_head; b != nullptr; b = b->_next) {\n@@ -2159,1 +2159,1 @@\n-JNIMethodBlockNode::JNIMethodBlockNode(int num_methods) : _top(0), _next(NULL) {\n+JNIMethodBlockNode::JNIMethodBlockNode(int num_methods) : _top(0), _next(nullptr) {\n@@ -2172,1 +2172,1 @@\n-  if (cld->jmethod_ids() == NULL) {\n+  if (cld->jmethod_ids() == nullptr) {\n@@ -2185,1 +2185,1 @@\n-  if (cld->jmethod_ids() == NULL) {\n+  if (cld->jmethod_ids() == nullptr) {\n@@ -2201,1 +2201,1 @@\n-  assert(cld->jmethod_ids() != NULL, \"should have method handles\");\n+  assert(cld->jmethod_ids() != nullptr, \"should have method handles\");\n@@ -2210,1 +2210,1 @@\n-           new_method->method_holder()->class_loader() == NULL, \/\/ allow Unsafe substitution\n+           new_method->method_holder()->class_loader() == nullptr, \/\/ allow Unsafe substitution\n@@ -2218,1 +2218,1 @@\n-  assert(m != NULL, \"should be called with non-null method\");\n+  assert(m != nullptr, \"should be called with non-null method\");\n@@ -2221,1 +2221,1 @@\n-  if (cld->jmethod_ids() == NULL) return false;\n+  if (cld->jmethod_ids() == nullptr) return false;\n@@ -2226,1 +2226,1 @@\n-  if (mid == NULL) return NULL;\n+  if (mid == nullptr) return nullptr;\n@@ -2228,2 +2228,2 @@\n-  if (o == NULL || o == JNIMethodBlock::_free_method) {\n-    return NULL;\n+  if (o == nullptr || o == JNIMethodBlock::_free_method) {\n+    return nullptr;\n@@ -2234,1 +2234,1 @@\n-  \/\/ unloaded, we need to return NULL here too because after a safepoint, its memory\n+  \/\/ unloaded, we need to return null here too because after a safepoint, its memory\n@@ -2236,1 +2236,1 @@\n-  return o->method_holder()->is_loader_alive() ? o : NULL;\n+  return o->method_holder()->is_loader_alive() ? o : nullptr;\n@@ -2271,1 +2271,1 @@\n-  if (m == NULL) {\n+  if (m == nullptr) {\n@@ -2321,1 +2321,1 @@\n-  if (a == NULL)\n+  if (a == nullptr)\n@@ -2331,1 +2331,1 @@\n-  if (method_data() != NULL) {\n+  if (method_data() != nullptr) {\n@@ -2369,1 +2369,1 @@\n-  if (code() != NULL) {\n+  if (code() != nullptr) {\n@@ -2402,1 +2402,1 @@\n-  if (WizardMode && code() != NULL) st->print(\" ((nmethod*)%p)\", code());\n+  if (WizardMode && code() != nullptr) st->print(\" ((nmethod*)%p)\", code());\n@@ -2411,1 +2411,1 @@\n-  guarantee(md == NULL ||\n+  guarantee(md == nullptr ||\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":120,"deletions":120,"binary":false,"changes":240,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -114,1 +114,1 @@\n-  \/\/ field can come and go.  It can transition from NULL to not-null at any\n+  \/\/ field can come and go.  It can transition from null to not-null at any\n@@ -116,1 +116,1 @@\n-  \/\/ NULL only at safepoints (because of a de-opt).\n+  \/\/ null only at safepoints (because of a de-opt).\n@@ -167,1 +167,1 @@\n-  Symbol* generic_signature() const              { int idx = generic_signature_index(); return ((idx != 0) ? constants()->symbol_at(idx) : (Symbol*)NULL); }\n+  Symbol* generic_signature() const              { int idx = generic_signature_index(); return ((idx != 0) ? constants()->symbol_at(idx) : nullptr); }\n@@ -235,1 +235,1 @@\n-    if (mcs == NULL) {\n+    if (mcs == nullptr) {\n@@ -243,1 +243,1 @@\n-    if (mcs != NULL) {\n+    if (mcs != nullptr) {\n@@ -249,1 +249,1 @@\n-    if (mcs != NULL) {\n+    if (mcs != nullptr) {\n@@ -256,1 +256,1 @@\n-    if (mcs != NULL) {\n+    if (mcs != nullptr) {\n@@ -299,1 +299,1 @@\n-    if (mcs != NULL) {\n+    if (mcs != nullptr) {\n@@ -307,1 +307,1 @@\n-    if (mcs == NULL) {\n+    if (mcs == nullptr) {\n@@ -342,1 +342,1 @@\n-  \/\/ exception of klass ex_klass thrown at throw_bci. A value of NULL\n+  \/\/ exception of klass ex_klass thrown at throw_bci. A value of null\n@@ -373,1 +373,1 @@\n-    _method_counters = NULL;\n+    _method_counters = nullptr;\n@@ -380,1 +380,1 @@\n-    return mcs == NULL ? 0 : mcs->prev_event_count();\n+    return mcs == nullptr ? 0 : mcs->prev_event_count();\n@@ -384,1 +384,1 @@\n-    if (mcs != NULL) {\n+    if (mcs != nullptr) {\n@@ -390,1 +390,1 @@\n-    return mcs == NULL ? 0 : mcs->prev_time();\n+    return mcs == nullptr ? 0 : mcs->prev_time();\n@@ -394,1 +394,1 @@\n-    if (mcs != NULL) {\n+    if (mcs != nullptr) {\n@@ -400,1 +400,1 @@\n-    return mcs == NULL ? 0 : mcs->rate();\n+    return mcs == nullptr ? 0 : mcs->rate();\n@@ -404,1 +404,1 @@\n-    if (mcs != NULL) {\n+    if (mcs != nullptr) {\n@@ -509,1 +509,1 @@\n-  \/\/ Must specify a real function (not NULL).\n+  \/\/ Must specify a real function (not null).\n@@ -776,1 +776,1 @@\n-  \/\/ refers to NULL (as is the case for any weak reference).\n+  \/\/ refers to null (as is the case for any weak reference).\n@@ -787,1 +787,1 @@\n-  \/\/ result guaranteed not to be NULL.\n+  \/\/ result guaranteed not to be null.\n@@ -789,1 +789,1 @@\n-    assert(mid != NULL, \"JNI method id should not be null\");\n+    assert(mid != nullptr, \"JNI method id should not be null\");\n@@ -794,1 +794,1 @@\n-  \/\/ should provide a valid jmethodID, but might not. NULL is returned\n+  \/\/ should provide a valid jmethodID, but might not. Null is returned\n@@ -808,1 +808,1 @@\n-  \/\/ Lookup the jmethodID for this method.  Return NULL if not found.\n+  \/\/ Lookup the jmethodID for this method.  Return null if not found.\n@@ -905,1 +905,1 @@\n-   return method_holder()->lookup_osr_nmethod(this, InvocationEntryBci, level, match_level) != NULL;\n+   return method_holder()->lookup_osr_nmethod(this, InvocationEntryBci, level, match_level) != nullptr;\n@@ -940,1 +940,1 @@\n-    if (_method_counters == NULL) {\n+    if (_method_counters == nullptr) {\n@@ -979,1 +979,1 @@\n-  static void sort_methods(Array<Method*>* methods, bool set_idnums = true, method_comparator_func func = NULL);\n+  static void sort_methods(Array<Method*>* methods, bool set_idnums = true, method_comparator_func func = nullptr);\n@@ -990,1 +990,1 @@\n-    assert(new_method != NULL, \"method_with_idnum() should not be NULL\");\n+    assert(new_method != nullptr, \"method_with_idnum() should not be null\");\n@@ -1125,1 +1125,1 @@\n-      _table = NULL;\n+      _table = nullptr;\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,1 @@\n-inline bool Method::has_compiled_code() const { return code() != NULL; }\n+inline bool Method::has_compiled_code() const { return code() != nullptr; }\n","filename":"src\/hotspot\/share\/oops\/method.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-  _data = NULL;\n+  _data = nullptr;\n@@ -121,1 +121,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -138,1 +138,1 @@\n-  if (extra != NULL) {\n+  if (extra != nullptr) {\n@@ -320,2 +320,2 @@\n-    if (k != NULL && (always_clean || !k->is_loader_alive())) {\n-      set_type(i, with_status((Klass*)NULL, p));\n+    if (k != nullptr && (always_clean || !k->is_loader_alive())) {\n+      set_type(i, with_status((Klass*)nullptr, p));\n@@ -329,2 +329,2 @@\n-  if (k != NULL && (always_clean || !k->is_loader_alive())) {\n-    set_type(with_status((Klass*)NULL, p));\n+  if (k != nullptr && (always_clean || !k->is_loader_alive())) {\n+    set_type(with_status((Klass*)nullptr, p));\n@@ -409,1 +409,1 @@\n-    if (p != NULL && (always_clean || !p->is_loader_alive())) {\n+    if (p != nullptr && (always_clean || !p->is_loader_alive())) {\n@@ -419,1 +419,1 @@\n-    if (receiver(row) != NULL)  entries++;\n+    if (receiver(row) != nullptr)  entries++;\n@@ -428,1 +428,1 @@\n-    if (receiver(row) != NULL) {\n+    if (receiver(row) != nullptr) {\n@@ -433,1 +433,1 @@\n-    if (receiver(row) != NULL) {\n+    if (receiver(row) != nullptr) {\n@@ -808,1 +808,1 @@\n-FailedSpeculation::FailedSpeculation(address speculation, int speculation_len) : _data_len(speculation_len), _next(NULL) {\n+FailedSpeculation::FailedSpeculation(address speculation, int speculation_len) : _data_len(speculation_len), _next(nullptr) {\n@@ -817,1 +817,1 @@\n-    if (nm != NULL) {\n+    if (nm != nullptr) {\n@@ -821,1 +821,1 @@\n-      if (method != NULL) {\n+      if (method != nullptr) {\n@@ -825,1 +825,1 @@\n-        if (jvmci_name != NULL) {\n+        if (jvmci_name != nullptr) {\n@@ -838,1 +838,1 @@\n-  assert(failed_speculations_address != NULL, \"must be\");\n+  assert(failed_speculations_address != nullptr, \"must be\");\n@@ -841,1 +841,1 @@\n-  if (fs == NULL) {\n+  if (fs == nullptr) {\n@@ -851,3 +851,3 @@\n-    if (*cursor == NULL) {\n-      FailedSpeculation* old_fs = Atomic::cmpxchg(cursor, (FailedSpeculation*) NULL, fs);\n-      if (old_fs == NULL) {\n+    if (*cursor == nullptr) {\n+      FailedSpeculation* old_fs = Atomic::cmpxchg(cursor, (FailedSpeculation*) nullptr, fs);\n+      if (old_fs == nullptr) {\n@@ -865,1 +865,1 @@\n-  assert(failed_speculations_address != NULL, \"must be\");\n+  assert(failed_speculations_address != nullptr, \"must be\");\n@@ -867,1 +867,1 @@\n-  while (fs != NULL) {\n+  while (fs != nullptr) {\n@@ -1102,1 +1102,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1147,1 +1147,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1189,1 +1189,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1206,1 +1206,1 @@\n-    parameters_type_data()->post_initialize(NULL, this);\n+    parameters_type_data()->post_initialize(nullptr, this);\n@@ -1313,1 +1313,1 @@\n-  _failed_speculations = NULL;\n+  _failed_speculations = nullptr;\n@@ -1348,1 +1348,1 @@\n-  DataLayout* prev = NULL;\n+  DataLayout* prev = nullptr;\n@@ -1352,1 +1352,1 @@\n-      else if (prev != NULL)   set_hint_di(dp_to_di((address)prev));\n+      else if (prev != nullptr)   set_hint_di(dp_to_di((address)prev));\n@@ -1360,1 +1360,1 @@\n-\/\/ Translate a bci to its corresponding data, or NULL.\n+\/\/ Translate a bci to its corresponding data, or null.\n@@ -1371,1 +1371,1 @@\n-  return bci_to_extra_data(bci, NULL, false);\n+  return bci_to_extra_data(bci, nullptr, false);\n@@ -1399,1 +1399,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1402,1 +1402,1 @@\n-      return NULL; \/\/ ArgInfoData is at the end of extra data section.\n+      return nullptr; \/\/ ArgInfoData is at the end of extra data section.\n@@ -1404,1 +1404,1 @@\n-      if (m == NULL && dp->bci() == bci) {\n+      if (m == nullptr && dp->bci() == bci) {\n@@ -1409,1 +1409,1 @@\n-      if (m != NULL) {\n+      if (m != nullptr) {\n@@ -1415,1 +1415,1 @@\n-          if (data->method() == NULL) {\n+          if (data->method() == nullptr) {\n@@ -1417,1 +1417,1 @@\n-            return NULL;\n+            return nullptr;\n@@ -1428,1 +1428,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1432,1 +1432,1 @@\n-\/\/ Translate a bci to its corresponding extra data, or NULL.\n+\/\/ Translate a bci to its corresponding extra data, or null.\n@@ -1440,2 +1440,2 @@\n-  if (m != NULL && m->is_old()) {\n-    return NULL;\n+  if (m != nullptr && m->is_old()) {\n+    return nullptr;\n@@ -1451,1 +1451,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -1460,1 +1460,1 @@\n-    if (result != NULL || dp >= end) {\n+    if (result != nullptr || dp >= end) {\n@@ -1464,1 +1464,1 @@\n-    assert(dp->tag() == DataLayout::no_tag || (dp->tag() == DataLayout::speculative_trap_data_tag && m != NULL), \"should be free\");\n+    assert(dp->tag() == DataLayout::no_tag || (dp->tag() == DataLayout::speculative_trap_data_tag && m != nullptr), \"should be free\");\n@@ -1466,1 +1466,1 @@\n-    u1 tag = m == NULL ? DataLayout::bit_data_tag : DataLayout::speculative_trap_data_tag;\n+    u1 tag = m == nullptr ? DataLayout::bit_data_tag : DataLayout::speculative_trap_data_tag;\n@@ -1468,2 +1468,2 @@\n-    if (m != NULL && next_extra(dp)->tag() != DataLayout::no_tag) {\n-      return NULL;\n+    if (m != nullptr && next_extra(dp)->tag() != DataLayout::no_tag) {\n+      return nullptr;\n@@ -1485,1 +1485,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1495,1 +1495,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1740,1 +1740,1 @@\n-      assert(m != NULL, \"should have a method\");\n+      assert(m != nullptr, \"should have a method\");\n@@ -1784,1 +1784,1 @@\n-      assert(m != NULL && cl->is_live(m), \"Method should exist\");\n+      assert(m != nullptr && cl->is_live(m), \"Method should exist\");\n@@ -1807,1 +1807,1 @@\n-  if (parameters != NULL) {\n+  if (parameters != nullptr) {\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":52,"deletions":52,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -404,1 +404,1 @@\n-    return is_BitData()         ? (BitData*)        this : NULL;\n+    return is_BitData()         ? (BitData*)        this : nullptr;\n@@ -408,1 +408,1 @@\n-    return is_CounterData()     ? (CounterData*)    this : NULL;\n+    return is_CounterData()     ? (CounterData*)    this : nullptr;\n@@ -412,1 +412,1 @@\n-    return is_JumpData()        ? (JumpData*)       this : NULL;\n+    return is_JumpData()        ? (JumpData*)       this : nullptr;\n@@ -416,1 +416,1 @@\n-    return is_ReceiverTypeData() ? (ReceiverTypeData*)this : NULL;\n+    return is_ReceiverTypeData() ? (ReceiverTypeData*)this : nullptr;\n@@ -420,1 +420,1 @@\n-    return is_VirtualCallData() ? (VirtualCallData*)this : NULL;\n+    return is_VirtualCallData() ? (VirtualCallData*)this : nullptr;\n@@ -424,1 +424,1 @@\n-    return is_RetData()         ? (RetData*)        this : NULL;\n+    return is_RetData()         ? (RetData*)        this : nullptr;\n@@ -428,1 +428,1 @@\n-    return is_BranchData()      ? (BranchData*)     this : NULL;\n+    return is_BranchData()      ? (BranchData*)     this : nullptr;\n@@ -432,1 +432,1 @@\n-    return is_ArrayData()       ? (ArrayData*)      this : NULL;\n+    return is_ArrayData()       ? (ArrayData*)      this : nullptr;\n@@ -436,1 +436,1 @@\n-    return is_MultiBranchData() ? (MultiBranchData*)this : NULL;\n+    return is_MultiBranchData() ? (MultiBranchData*)this : nullptr;\n@@ -440,1 +440,1 @@\n-    return is_ArgInfoData() ? (ArgInfoData*)this : NULL;\n+    return is_ArgInfoData() ? (ArgInfoData*)this : nullptr;\n@@ -444,1 +444,1 @@\n-    return is_CallTypeData() ? (CallTypeData*)this : NULL;\n+    return is_CallTypeData() ? (CallTypeData*)this : nullptr;\n@@ -448,1 +448,1 @@\n-    return is_VirtualCallTypeData() ? (VirtualCallTypeData*)this : NULL;\n+    return is_VirtualCallTypeData() ? (VirtualCallTypeData*)this : nullptr;\n@@ -452,1 +452,1 @@\n-    return is_ParametersTypeData() ? (ParametersTypeData*)this : NULL;\n+    return is_ParametersTypeData() ? (ParametersTypeData*)this : nullptr;\n@@ -456,1 +456,1 @@\n-    return is_SpeculativeTrapData() ? (SpeculativeTrapData*)this : NULL;\n+    return is_SpeculativeTrapData() ? (SpeculativeTrapData*)this : nullptr;\n@@ -473,1 +473,1 @@\n-  virtual void print_data_on(outputStream* st, const char* extra = NULL) const {\n+  virtual void print_data_on(outputStream* st, const char* extra = nullptr) const {\n@@ -536,1 +536,1 @@\n-  void print_data_on(outputStream* st, const char* extra = NULL) const;\n+  void print_data_on(outputStream* st, const char* extra = nullptr) const;\n@@ -586,1 +586,1 @@\n-  void print_data_on(outputStream* st, const char* extra = NULL) const;\n+  void print_data_on(outputStream* st, const char* extra = nullptr) const;\n@@ -659,1 +659,1 @@\n-  void print_data_on(outputStream* st, const char* extra = NULL) const;\n+  void print_data_on(outputStream* st, const char* extra = nullptr) const;\n@@ -717,1 +717,1 @@\n-      assert(res != NULL, \"invalid\");\n+      assert(res != nullptr, \"invalid\");\n@@ -720,1 +720,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -741,1 +741,1 @@\n-    : _pd(NULL), _base_off(base_off) {}\n+    : _pd(nullptr), _base_off(base_off) {}\n@@ -1077,1 +1077,1 @@\n-  virtual void print_data_on(outputStream* st, const char* extra = NULL) const;\n+  virtual void print_data_on(outputStream* st, const char* extra = nullptr) const;\n@@ -1142,1 +1142,1 @@\n-    assert(recv == NULL || recv->is_klass(), \"wrong type\");\n+    assert(recv == nullptr || recv->is_klass(), \"wrong type\");\n@@ -1180,1 +1180,1 @@\n-    set_receiver(row, NULL);\n+    set_receiver(row, nullptr);\n@@ -1217,1 +1217,1 @@\n-  void print_data_on(outputStream* st, const char* extra = NULL) const;\n+  void print_data_on(outputStream* st, const char* extra = nullptr) const;\n@@ -1249,1 +1249,1 @@\n-  void print_data_on(outputStream* st, const char* extra = NULL) const;\n+  void print_data_on(outputStream* st, const char* extra = nullptr) const;\n@@ -1381,1 +1381,1 @@\n-  virtual void print_data_on(outputStream* st, const char* extra = NULL) const;\n+  virtual void print_data_on(outputStream* st, const char* extra = nullptr) const;\n@@ -1473,1 +1473,1 @@\n-  void print_data_on(outputStream* st, const char* extra = NULL) const;\n+  void print_data_on(outputStream* st, const char* extra = nullptr) const;\n@@ -1537,1 +1537,1 @@\n-  void print_data_on(outputStream* st, const char* extra = NULL) const;\n+  void print_data_on(outputStream* st, const char* extra = nullptr) const;\n@@ -1696,1 +1696,1 @@\n-  void print_data_on(outputStream* st, const char* extra = NULL) const;\n+  void print_data_on(outputStream* st, const char* extra = nullptr) const;\n@@ -1721,1 +1721,1 @@\n-  void print_data_on(outputStream* st, const char* extra = NULL) const;\n+  void print_data_on(outputStream* st, const char* extra = nullptr) const;\n@@ -1780,1 +1780,1 @@\n-  virtual void print_data_on(outputStream* st, const char* extra = NULL) const;\n+  virtual void print_data_on(outputStream* st, const char* extra = nullptr) const;\n@@ -1850,1 +1850,1 @@\n-  virtual void print_data_on(outputStream* st, const char* extra = NULL) const;\n+  virtual void print_data_on(outputStream* st, const char* extra = nullptr) const;\n@@ -1886,1 +1886,1 @@\n-\/\/ is NULL to begin with, the interpreter assumes that the current method\n+\/\/ is null to begin with, the interpreter assumes that the current method\n@@ -2135,1 +2135,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -2286,1 +2286,1 @@\n-                                                   assert(aid != NULL, \"arg_info must be not null\");\n+                                                   assert(aid != nullptr, \"arg_info must be not null\");\n@@ -2295,1 +2295,1 @@\n-                                                   assert(aid != NULL, \"arg_info must be not null\");\n+                                                   assert(aid != nullptr, \"arg_info must be not null\");\n@@ -2311,1 +2311,1 @@\n-    return param == NULL ? 0 : param->size_in_bytes();\n+    return param == nullptr ? 0 : param->size_in_bytes();\n@@ -2324,2 +2324,2 @@\n-  bool is_valid(ProfileData* current) const { return current != NULL; }\n-  bool is_valid(DataLayout*  current) const { return current != NULL; }\n+  bool is_valid(ProfileData* current) const { return current != nullptr; }\n+  bool is_valid(DataLayout*  current) const { return current != nullptr; }\n@@ -2338,1 +2338,1 @@\n-  \/\/ Get the data at an arbitrary bci, or NULL if there is none.\n+  \/\/ Get the data at an arbitrary bci, or null if there is none.\n@@ -2343,3 +2343,3 @@\n-    ProfileData* data = NULL;\n-    \/\/ If m not NULL, try to allocate a SpeculativeTrapData entry\n-    if (m == NULL) {\n+    ProfileData* data = nullptr;\n+    \/\/ If m not null, try to allocate a SpeculativeTrapData entry\n+    if (m == nullptr) {\n@@ -2348,1 +2348,1 @@\n-    if (data != NULL) {\n+    if (data != nullptr) {\n@@ -2352,1 +2352,1 @@\n-    if (data != NULL) {\n+    if (data != nullptr) {\n@@ -2358,1 +2358,1 @@\n-    if (data != NULL) {\n+    if (data != nullptr) {\n@@ -2361,1 +2361,1 @@\n-    return bci_to_extra_data(bci, NULL, true);\n+    return bci_to_extra_data(bci, nullptr, true);\n@@ -2412,1 +2412,1 @@\n-    return _parameters_type_data_di != no_parameters ? data_layout_at(_parameters_type_data_di)->data_in()->as_ParametersTypeData() : NULL;\n+    return _parameters_type_data_di != no_parameters ? data_layout_at(_parameters_type_data_di)->data_in()->as_ParametersTypeData() : nullptr;\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":50,"deletions":50,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-  Klass* super_klass = NULL;\n+  Klass* super_klass = nullptr;\n@@ -64,1 +64,1 @@\n-    if (element_super != NULL) {\n+    if (element_super != nullptr) {\n@@ -67,1 +67,1 @@\n-      bool supers_exist = super_klass != NULL;\n+      bool supers_exist = super_klass != nullptr;\n@@ -73,1 +73,1 @@\n-        if (elem_super->array_klass_or_null() == NULL) {\n+        if (elem_super->array_klass_or_null() == nullptr) {\n@@ -80,1 +80,1 @@\n-        Klass* ek = NULL;\n+        Klass* ek = nullptr;\n@@ -100,1 +100,1 @@\n-  Symbol* name = NULL;\n+  Symbol* name = nullptr;\n@@ -124,1 +124,1 @@\n-  assert(module != NULL, \"No module entry for array\");\n+  assert(module != nullptr, \"No module entry for array\");\n@@ -130,1 +130,1 @@\n-  \/\/ including classes in the bootstrap (NULL) class loader.\n+  \/\/ including classes in the bootstrap (null) class loader.\n@@ -149,1 +149,1 @@\n-  assert(bk != NULL && (bk->is_instance_klass() || bk->is_typeArray_klass()), \"invalid bottom klass\");\n+  assert(bk != nullptr && (bk->is_instance_klass() || bk->is_typeArray_klass()), \"invalid bottom klass\");\n@@ -294,1 +294,1 @@\n-    assert(arrayOopDesc::obj_offset_to_raw<narrowOop>(s, src_offset, NULL) ==\n+    assert(arrayOopDesc::obj_offset_to_raw<narrowOop>(s, src_offset, nullptr) ==\n@@ -296,1 +296,1 @@\n-    assert(arrayOopDesc::obj_offset_to_raw<narrowOop>(d, dst_offset, NULL) ==\n+    assert(arrayOopDesc::obj_offset_to_raw<narrowOop>(d, dst_offset, nullptr) ==\n@@ -302,1 +302,1 @@\n-    assert(arrayOopDesc::obj_offset_to_raw<oop>(s, src_offset, NULL) ==\n+    assert(arrayOopDesc::obj_offset_to_raw<oop>(s, src_offset, nullptr) ==\n@@ -304,1 +304,1 @@\n-    assert(arrayOopDesc::obj_offset_to_raw<oop>(d, dst_offset, NULL) ==\n+    assert(arrayOopDesc::obj_offset_to_raw<oop>(d, dst_offset, nullptr) ==\n@@ -318,1 +318,1 @@\n-  if (higher_dimension_acquire() == NULL) {\n+  if (higher_dimension_acquire() == nullptr) {\n@@ -326,1 +326,1 @@\n-      if (higher_dimension() == NULL) {\n+      if (higher_dimension() == nullptr) {\n@@ -352,2 +352,2 @@\n-  if (higher_dimension_acquire() == NULL) {\n-    return NULL;\n+  if (higher_dimension_acquire() == nullptr) {\n+    return nullptr;\n@@ -378,1 +378,1 @@\n-  assert(transitive_interfaces == NULL, \"sanity\");\n+  assert(transitive_interfaces == nullptr, \"sanity\");\n@@ -381,1 +381,1 @@\n-  int num_elem_supers = elem_supers == NULL ? 0 : elem_supers->length();\n+  int num_elem_supers = elem_supers == nullptr ? 0 : elem_supers->length();\n@@ -386,1 +386,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -394,1 +394,1 @@\n-      assert(array_super != NULL, \"must already have been created\");\n+      assert(array_super != nullptr, \"must already have been created\");\n@@ -413,1 +413,1 @@\n-  if (element_klass() == NULL) {\n+  if (element_klass() == nullptr) {\n@@ -425,1 +425,1 @@\n-  assert(bottom_klass() != NULL, \"ObjArrayKlass returned unexpected NULL bottom_klass\");\n+  assert(bottom_klass() != nullptr, \"ObjArrayKlass returned unexpected null bottom_klass\");\n@@ -431,1 +431,1 @@\n-  assert(bottom_klass() != NULL, \"ObjArrayKlass returned unexpected NULL bottom_klass\");\n+  assert(bottom_klass() != nullptr, \"ObjArrayKlass returned unexpected null bottom_klass\");\n@@ -462,1 +462,1 @@\n-    if (oa->obj_at(index) != NULL) {\n+    if (oa->obj_at(index) != nullptr) {\n@@ -466,1 +466,1 @@\n-      st->print_cr(\"NULL\");\n+      st->print_cr(\"null\");\n@@ -483,1 +483,1 @@\n-  if (obj != NULL) {\n+  if (obj != nullptr) {\n@@ -486,1 +486,1 @@\n-    st->print_cr(\"NULL\");\n+    st->print_cr(\"null\");\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,1 +89,1 @@\n-  if (oop_desc != NULL) {\n+  if (oop_desc != nullptr) {\n@@ -126,1 +126,1 @@\n-  return obj == NULL ? true : is_oop(obj, ignore_mark_word);\n+  return obj == nullptr ? true : is_oop(obj, ignore_mark_word);\n@@ -163,1 +163,1 @@\n-    if (narrow_klass == 0) return NULL;\n+    if (narrow_klass == 0) return nullptr;\n@@ -174,1 +174,1 @@\n-    if (CompressedOops::is_null(narrow_oop)) return NULL;\n+    if (CompressedOops::is_null(narrow_oop)) return nullptr;\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,0 +88,2 @@\n+  \/\/ Get the raw value without any checks.\n+  inline Klass* klass_raw() const;\n@@ -263,1 +265,1 @@\n-  \/\/ this call returns \"NULL\" for that thread; any other thread has the\n+  \/\/ this call returns null for that thread; any other thread has the\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -110,0 +110,8 @@\n+Klass* oopDesc::klass_raw() const {\n+  if (UseCompressedClassPointers) {\n+    return CompressedKlassPointers::decode_raw(_metadata._compressed_klass);\n+  } else {\n+    return _metadata._klass;\n+  }\n+}\n+\n@@ -111,1 +119,1 @@\n-  assert(Universe::is_bootstrapping() || (k != NULL && k->is_klass()), \"incorrect Klass\");\n+  assert(Universe::is_bootstrapping() || (k != nullptr && k->is_klass()), \"incorrect Klass\");\n@@ -120,1 +128,1 @@\n-  assert(Universe::is_bootstrapping() || (k != NULL && k->is_klass()), \"incorrect Klass\");\n+  assert(Universe::is_bootstrapping() || (k != nullptr && k->is_klass()), \"incorrect Klass\");\n@@ -273,1 +281,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -344,1 +352,1 @@\n-  return obj == NULL || obj->klass()->is_subtype_of(klass);\n+  return obj == nullptr || obj->klass()->is_subtype_of(klass);\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-  OopHandle() : _obj(NULL) {}\n+  OopHandle() : _obj(nullptr) {}\n@@ -67,1 +67,1 @@\n-  bool is_empty() const { return _obj == NULL; }\n+  bool is_empty() const { return _obj == nullptr; }\n","filename":"src\/hotspot\/share\/oops\/oopHandle.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-  return (_obj == NULL) ? (oop)NULL : NativeAccess<>::oop_load(_obj);\n+  return (_obj == nullptr) ? (oop)nullptr : NativeAccess<>::oop_load(_obj);\n@@ -38,1 +38,1 @@\n-  return (_obj == NULL) ? (oop)NULL : NativeAccess<AS_NO_KEEPALIVE>::oop_load(_obj);\n+  return (_obj == nullptr) ? (oop)nullptr : NativeAccess<AS_NO_KEEPALIVE>::oop_load(_obj);\n@@ -43,1 +43,1 @@\n-  if (_obj == NULL) {\n+  if (_obj == nullptr) {\n@@ -51,1 +51,1 @@\n-  if (_obj != NULL) {\n+  if (_obj != nullptr) {\n@@ -53,1 +53,1 @@\n-    NativeAccess<>::oop_store(_obj, (oop)NULL);\n+    NativeAccess<>::oop_store(_obj, nullptr);\n@@ -60,1 +60,1 @@\n-  assert(ptr != NULL, \"should not use replace\");\n+  assert(ptr != nullptr, \"should not use replace\");\n","filename":"src\/hotspot\/share\/oops\/oopHandle.inline.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-  if (t != NULL && t->is_Java_thread()) {\n+  if (t != nullptr && t->is_Java_thread()) {\n@@ -48,1 +48,1 @@\n-  if (t != NULL && t->is_Java_thread()) {\n+  if (t != nullptr && t->is_Java_thread()) {\n","filename":"src\/hotspot\/share\/oops\/oopsHierarchy.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,1 +71,1 @@\n-\/\/ Converting NULL to oop to Handle implicit is no longer accepted by the\n+\/\/ Converting null to oop to Handle implicit is no longer accepted by the\n","filename":"src\/hotspot\/share\/oops\/oopsHierarchy.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-  if (annotations() != NULL) {\n+  if (annotations() != nullptr) {\n@@ -49,1 +49,1 @@\n-  if (type_annotations() != NULL) {\n+  if (type_annotations() != nullptr) {\n@@ -73,1 +73,1 @@\n-  if (_annotations != NULL) {\n+  if (_annotations != nullptr) {\n@@ -77,1 +77,1 @@\n-  if (_type_annotations != NULL) {\n+  if (_type_annotations != nullptr) {\n","filename":"src\/hotspot\/share\/oops\/recordComponent.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -196,2 +196,2 @@\n-  bool verify(size_t* out_size = NULL, int* out_oops = NULL,\n-              int* out_frames = NULL, int* out_interpreted_frames = NULL) NOT_DEBUG({ return true; });\n+  bool verify(size_t* out_size = nullptr, int* out_oops = nullptr,\n+              int* out_frames = nullptr, int* out_interpreted_frames = nullptr) NOT_DEBUG({ return true; });\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-    if (scan == NULL)\n+    if (scan == nullptr)\n@@ -148,1 +148,1 @@\n-  if (strchr(pattern, '*') == NULL) {\n+  if (strchr(pattern, '*') == nullptr) {\n@@ -188,1 +188,1 @@\n-  if (s == NULL) {\n+  if (s == nullptr) {\n","filename":"src\/hotspot\/share\/oops\/symbol.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -176,1 +176,1 @@\n-    if (s != NULL) {\n+    if (s != nullptr) {\n@@ -181,1 +181,1 @@\n-    if (s != NULL) {\n+    if (s != nullptr) {\n@@ -231,1 +231,1 @@\n-    assert(len >= 0 && substring != NULL, \"substring must be valid\");\n+    assert(len >= 0 && substring != nullptr, \"substring must be valid\");\n@@ -284,1 +284,1 @@\n-  void print_symbol_on(outputStream* st = NULL) const;\n+  void print_symbol_on(outputStream* st = nullptr) const;\n","filename":"src\/hotspot\/share\/oops\/symbol.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-  SymbolHandleBase() : _temp(NULL) { }\n+  SymbolHandleBase() : _temp(nullptr) { }\n","filename":"src\/hotspot\/share\/oops\/symbolHandle.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,2 +47,2 @@\n-  Symbol* sym = NULL;\n-  if (name_str != NULL) {\n+  Symbol* sym = nullptr;\n+  if (name_str != nullptr) {\n@@ -60,1 +60,1 @@\n-  \/\/ including classes in the bootstrap (NULL) class loader.\n+  \/\/ including classes in the bootstrap (null) class loader.\n@@ -181,1 +181,1 @@\n-  if (higher_dimension_acquire() == NULL) {\n+  if (higher_dimension_acquire() == nullptr) {\n@@ -189,1 +189,1 @@\n-      if (higher_dimension() == NULL) {\n+      if (higher_dimension() == nullptr) {\n@@ -214,2 +214,2 @@\n-  if (higher_dimension_acquire() == NULL) {\n-    return NULL;\n+  if (higher_dimension_acquire() == nullptr) {\n+    return nullptr;\n@@ -253,1 +253,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -375,1 +375,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,1 +71,1 @@\n-  oop protection_domain() const { return NULL; }\n+  oop protection_domain() const { return nullptr; }\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-  assert(obj != NULL, \"no need to create weak null oop\");\n+  assert(obj != nullptr, \"no need to create weak null oop\");\n@@ -40,1 +40,1 @@\n-  if (_obj == NULL) {\n+  if (_obj == nullptr) {\n@@ -51,1 +51,1 @@\n-  if (_obj != NULL) {\n+  if (_obj != nullptr) {\n@@ -54,1 +54,1 @@\n-    NativeAccess<ON_PHANTOM_OOP_REF>::oop_store(_obj, (oop)NULL);\n+    NativeAccess<ON_PHANTOM_OOP_REF>::oop_store(_obj, nullptr);\n","filename":"src\/hotspot\/share\/oops\/weakHandle.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-\/\/ if the value is NULL.  If it is NULL, it has been cleaned out by GC.\n+\/\/ if the value is null.  If it is null, it has been cleaned out by GC.\n@@ -49,1 +49,1 @@\n-  WeakHandle() : _obj(NULL) {} \/\/ needed for init\n+  WeakHandle() : _obj(nullptr) {} \/\/ needed for init\n@@ -56,1 +56,1 @@\n-  bool is_null() const { return _obj == NULL; }\n+  bool is_null() const { return _obj == nullptr; }\n@@ -63,1 +63,1 @@\n-  bool is_empty() const { return _obj == NULL; }\n+  bool is_empty() const { return _obj == nullptr; }\n","filename":"src\/hotspot\/share\/oops\/weakHandle.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -621,3 +621,6 @@\n-  develop(bool, VerifyIterativeGVN, false,                                  \\\n-          \"Verify Def-Use modifications during sparse Iterative Global \"    \\\n-          \"Value Numbering\")                                                \\\n+  develop(uint, VerifyIterativeGVN, 0,                                      \\\n+          \"Verify Iterative Global Value Numbering\"                         \\\n+          \"=XY, with Y: verify Def-Use modifications during IGVN\"           \\\n+          \"          X: verify that type(n) == n->Value() after IGVN\"       \\\n+          \"X and Y in 0=off; 1=on\")                                         \\\n+          constraint(VerifyIterativeGVNConstraintFunc, AtParse)             \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -785,0 +785,1 @@\n+  case vmIntrinsics::_IndexPartiallyInUpperRange:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,15 @@\n-  const Type* ft = phase->type(in(1))->filter_speculative(_type);\n+\n+  const Type* in_type = phase->type(in(1));\n+  const Type* ft = in_type->filter_speculative(_type);\n+\n+  \/\/ Check if both _type and in_type had a speculative type, but for the just\n+  \/\/ computed ft the speculative type was dropped.\n+  if (ft->speculative() == nullptr &&\n+      _type->speculative() != nullptr &&\n+      in_type->speculative() != nullptr) {\n+    \/\/ Speculative type may have disagreed between cast and input, and was\n+    \/\/ dropped in filtering. Recompute so that ft can take speculative type\n+    \/\/ of in_type. If we did not do it now, a subsequent ::Value call would\n+    \/\/ do it, and violate idempotence of ::Value.\n+    ft = in_type->filter_speculative(ft);\n+  }\n@@ -61,4 +75,7 @@\n-      const Type* t1 = phase->type(in(1));\n-      if( t1 == Type::TOP )  assert(ft == Type::TOP, \"special case #1\");\n-      const Type* rt = t1->join_speculative(_type);\n-      if (rt->empty())       assert(ft == Type::TOP, \"special case #2\");\n+      if (in_type == Type::TOP) {\n+        assert(ft == Type::TOP, \"special case #1\");\n+      }\n+      const Type* rt = in_type->join_speculative(_type);\n+      if (rt->empty()) {\n+        assert(ft == Type::TOP, \"special case #2\");\n+      }\n@@ -68,4 +85,5 @@\n-    if (phase->type(in(1)) == TypePtr::NULL_PTR &&\n-        _type->isa_ptr() && _type->is_ptr()->_ptr == TypePtr::NotNull)\n-    assert(ft == Type::TOP, \"special case #3\");\n-    break;\n+    if (in_type == TypePtr::NULL_PTR &&\n+        _type->isa_ptr() && _type->is_ptr()->_ptr == TypePtr::NotNull) {\n+      assert(ft == Type::TOP, \"special case #3\");\n+      break;\n+    }\n@@ -213,3 +231,17 @@\n-  \/\/ Try to improve the type of the CastII if we recognize a CmpI\/If\n-  \/\/ pattern.\n-  if (_dependency != RegularDependency) {\n+  \/\/ Try to improve the type of the CastII if we recognize a CmpI\/If pattern.\n+  \/\/\n+  \/\/ in1  in2\n+  \/\/  |    |\n+  \/\/  +--- | --+\n+  \/\/  |    |   |\n+  \/\/ CmpINode  |\n+  \/\/    |      |\n+  \/\/ BoolNode  |\n+  \/\/    |      |\n+  \/\/  IfNode   |\n+  \/\/    |      |\n+  \/\/  IfProj   |\n+  \/\/    |      |\n+  \/\/   CastIINode\n+  \/\/\n+  if (carry_dependency()) {\n@@ -347,1 +379,1 @@\n-  if (can_reshape && !phase->C->post_loop_opts_phase()) {\n+  if (!phase->C->post_loop_opts_phase()) {\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":46,"deletions":14,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -438,0 +438,13 @@\n+void RegionNode::set_loop_status(RegionNode::LoopStatus status) {\n+  assert(status != RegionNode::LoopStatus::NeverIrreducibleEntry, \"do not set this\");\n+  assert(loop_status() == RegionNode::LoopStatus::NeverIrreducibleEntry, \"why set our status again?\");\n+  _loop_status = status;\n+}\n+\n+#ifdef ASSERT\n+void RegionNode::verify_can_be_irreducible_entry() const {\n+  assert(loop_status() == RegionNode::LoopStatus::MaybeIrreducibleEntry, \"must be marked irreducible\");\n+  assert(!is_Loop(), \"LoopNode cannot be irreducible loop entry\");\n+}\n+#endif \/\/ASSERT\n+\n@@ -525,0 +538,1 @@\n+  bool found_top = false; \/\/ irreducible loops need to check reachability if we find TOP\n@@ -548,0 +562,1 @@\n+        found_top = true;\n@@ -583,1 +598,14 @@\n-  if (can_reshape && cnt == 1) {\n+  if (can_reshape && found_top && loop_status() == RegionNode::LoopStatus::MaybeIrreducibleEntry) {\n+    \/\/ Is it a dead irreducible loop?\n+    \/\/ If an irreducible loop loses one of the multiple entries\n+    \/\/ that went into the loop head, or any secondary entries,\n+    \/\/ we need to verify if the irreducible loop is still reachable,\n+    \/\/ as the special logic in is_unreachable_region only works\n+    \/\/ for reducible loops.\n+    if (is_unreachable_from_root(phase)) {\n+      \/\/ The irreducible loop is dead - must remove it\n+      PhaseIterGVN* igvn = phase->is_IterGVN();\n+      remove_unreachable_subgraph(igvn);\n+      return nullptr;\n+    }\n+  } else if (can_reshape && cnt == 1) {\n@@ -593,3 +621,0 @@\n-      \/\/ This region and therefore all nodes on the input control path(s) are unreachable\n-      \/\/ from root. To avoid incomplete removal of unreachable subgraphs, walk up the CFG\n-      \/\/ and aggressively replace all nodes by top.\n@@ -597,39 +622,2 @@\n-      Node* top = phase->C->top();\n-      ResourceMark rm;\n-      Node_List nstack;\n-      VectorSet visited;\n-      nstack.push(this);\n-      visited.set(_idx);\n-      while (nstack.size() != 0) {\n-        Node* n = nstack.pop();\n-        for (uint i = 0; i < n->req(); ++i) {\n-          Node* m = n->in(i);\n-          assert(m != (Node*)phase->C->root(), \"Should be unreachable from root\");\n-          if (m != NULL && m->is_CFG() && !visited.test_set(m->_idx)) {\n-            nstack.push(m);\n-          }\n-        }\n-        if (n->is_Region()) {\n-          \/\/ Eagerly replace phis with top to avoid regionless phis.\n-          n->set_req(0, NULL);\n-          bool progress = true;\n-          uint max = n->outcnt();\n-          DUIterator j;\n-          while (progress) {\n-            progress = false;\n-            for (j = n->outs(); n->has_out(j); j++) {\n-              Node* u = n->out(j);\n-              if (u->is_Phi()) {\n-                igvn->replace_node(u, top);\n-                if (max != n->outcnt()) {\n-                  progress = true;\n-                  j = n->refresh_out_pos(j);\n-                  max = n->outcnt();\n-                }\n-              }\n-            }\n-          }\n-        }\n-        igvn->replace_node(n, top);\n-      }\n-      return NULL;\n+      remove_unreachable_subgraph(igvn);\n+      return nullptr;\n@@ -807,0 +795,53 @@\n+\/\/--------------------------remove_unreachable_subgraph----------------------\n+\/\/ This region and therefore all nodes on the input control path(s) are unreachable\n+\/\/ from root. To avoid incomplete removal of unreachable subgraphs, walk up the CFG\n+\/\/ and aggressively replace all nodes by top.\n+\/\/ If a control node \"def\" with a single control output \"use\" has its single output\n+\/\/ \"use\" replaced with top, then \"use\" removes itself. This has the consequence that\n+\/\/ when we visit \"use\", it already has all inputs removed. They are lost and we cannot\n+\/\/ traverse them. This is why we fist find all unreachable nodes, and then remove\n+\/\/ them in a second step.\n+void RegionNode::remove_unreachable_subgraph(PhaseIterGVN* igvn) {\n+  Node* top = igvn->C->top();\n+  ResourceMark rm;\n+  Unique_Node_List unreachable; \/\/ visit each only once\n+  unreachable.push(this);\n+  \/\/ Recursively find all control inputs.\n+  for (uint i = 0; i < unreachable.size(); i++) {\n+    Node* n = unreachable.at(i);\n+    for (uint i = 0; i < n->req(); ++i) {\n+      Node* m = n->in(i);\n+      assert(m == nullptr || !m->is_Root(), \"Should be unreachable from root\");\n+      if (m != nullptr && m->is_CFG()) {\n+        unreachable.push(m);\n+      }\n+    }\n+  }\n+  \/\/ Remove all unreachable nodes.\n+  for (uint i = 0; i < unreachable.size(); i++) {\n+    Node* n = unreachable.at(i);\n+    if (n->is_Region()) {\n+      \/\/ Eagerly replace phis with top to avoid regionless phis.\n+      n->set_req(0, nullptr);\n+      bool progress = true;\n+      uint max = n->outcnt();\n+      DUIterator j;\n+      while (progress) {\n+        progress = false;\n+        for (j = n->outs(); n->has_out(j); j++) {\n+          Node* u = n->out(j);\n+          if (u->is_Phi()) {\n+            igvn->replace_node(u, top);\n+            if (max != n->outcnt()) {\n+              progress = true;\n+              j = n->refresh_out_pos(j);\n+              max = n->outcnt();\n+            }\n+          }\n+        }\n+      }\n+    }\n+    igvn->replace_node(n, top);\n+  }\n+}\n+\n@@ -955,0 +996,16 @@\n+#ifndef PRODUCT\n+void RegionNode::dump_spec(outputStream* st) const {\n+  Node::dump_spec(st);\n+  switch (loop_status()) {\n+  case RegionNode::LoopStatus::MaybeIrreducibleEntry:\n+    st->print(\"#irreducible \");\n+    break;\n+  case RegionNode::LoopStatus::Reducible:\n+    st->print(\"#reducible \");\n+    break;\n+  case RegionNode::LoopStatus::NeverIrreducibleEntry:\n+    break; \/\/ nothing\n+  }\n+}\n+#endif\n+\n@@ -1274,2 +1331,1 @@\n-  ft = phase->saturate(ft, phase->type_or_null(this), _type);\n-\n+  ft = phase->saturate_and_maybe_push_to_igvn_worklist(this, ft);\n@@ -1357,0 +1413,3 @@\n+  if (must_wait_for_region_in_irreducible_loop(phase)) {\n+    return this;\n+  }\n@@ -1704,0 +1763,12 @@\n+  \/\/ This optimization tries to find two or more inputs of phi with the same constant value\n+  \/\/ It then splits them into a separate Phi, and according Region. If this is a loop-entry,\n+  \/\/ and the loop entry has multiple fall-in edges, and some of those fall-in edges have that\n+  \/\/ constant, and others not, we may split the fall-in edges into separate Phi's, and create\n+  \/\/ an irreducible loop. For reducible loops, this never seems to happen, as the multiple\n+  \/\/ fall-in edges are already merged before the loop head during parsing. But with irreducible\n+  \/\/ loops present the order or merging during parsing can sometimes prevent this.\n+  if (phase->C->has_irreducible_loop()) {\n+    \/\/ Avoid this optimization if any irreducible loops are present. Else we may create\n+    \/\/ an irreducible loop that we do not detect.\n+    return nullptr;\n+  }\n@@ -1898,0 +1969,25 @@\n+\/\/ If the Phi's Region is in an irreducible loop, and the Region\n+\/\/ has had an input removed, but not yet transformed, it could be\n+\/\/ that the Region (and this Phi) are not reachable from Root.\n+\/\/ If we allow the Phi to collapse before the Region, this may lead\n+\/\/ to dead-loop data. Wait for the Region to check for reachability,\n+\/\/ and potentially remove the dead code.\n+bool PhiNode::must_wait_for_region_in_irreducible_loop(PhaseGVN* phase) const {\n+  RegionNode* region = in(0)->as_Region();\n+  if (region->loop_status() == RegionNode::LoopStatus::MaybeIrreducibleEntry) {\n+    Node* top = phase->C->top();\n+    for (uint j = 1; j < req(); j++) {\n+      Node* rc = region->in(j); \/\/ for each control input\n+      if (rc == nullptr || phase->type(rc) == Type::TOP) {\n+        \/\/ Region is missing a control input\n+        Node* n = in(j);\n+        if (n != nullptr && n != top) {\n+          \/\/ Phi still has its input, so region just lost its input\n+          return true;\n+        }\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -1917,0 +2013,4 @@\n+  if (must_wait_for_region_in_irreducible_loop(phase)) {\n+    return nullptr;\n+  }\n+\n@@ -2034,1 +2134,1 @@\n-    if (ident != uin && !ident->is_top()) {\n+    if (ident != uin && !ident->is_top() && !must_wait_for_region_in_irreducible_loop(phase)) {\n@@ -2042,1 +2142,2 @@\n-    assert(ident == uin || ident->is_top(), \"Identity must clean this up\");\n+    \/\/ Identity may not return the expected uin, if it has to wait for the region, in irreducible case\n+    assert(ident == uin || ident->is_top() || must_wait_for_region_in_irreducible_loop(phase), \"Identity must clean this up\");\n@@ -2496,1 +2597,5 @@\n-  assert(cached_vbox != NULL, \"sanity\");\n+  if (cached_vbox == nullptr) {\n+    \/\/ We have a Phi dead-loop (no data-input). Phi nodes are considered safe,\n+    \/\/ so just avoid this optimization.\n+    return nullptr;\n+  }\n@@ -2737,0 +2842,4 @@\n+  if (phase->type(in(0)->in(0)) == Type::TOP) {\n+    assert(in(0)->is_CatchProj(), \"control is CatchProj\");\n+    return phase->C->top(); \/\/ dead code\n+  }\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":158,"deletions":49,"binary":false,"changes":207,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,0 +68,12 @@\n+public:\n+  enum LoopStatus {\n+    \/\/ No guarantee: the region may be an irreducible loop entry, thus we have to\n+    \/\/ be careful when removing entry control to it.\n+    MaybeIrreducibleEntry,\n+    \/\/ Limited guarantee: this region may be (nested) inside an irreducible loop,\n+    \/\/ but it will never be an irreducible loop entry.\n+    NeverIrreducibleEntry,\n+    \/\/ Strong guarantee: this region is not (nested) inside an irreducible loop.\n+    Reducible,\n+  };\n+\n@@ -70,0 +82,1 @@\n+  LoopStatus _loop_status;\n@@ -79,1 +92,5 @@\n-  RegionNode(uint required) : Node(required), _is_unreachable_region(false) {\n+  RegionNode(uint required)\n+    : Node(required),\n+      _is_unreachable_region(false),\n+      _loop_status(LoopStatus::NeverIrreducibleEntry)\n+  {\n@@ -98,0 +115,4 @@\n+  LoopStatus loop_status() const { return _loop_status; };\n+  void set_loop_status(LoopStatus status);\n+  DEBUG_ONLY(void verify_can_be_irreducible_entry() const;)\n+\n@@ -108,0 +129,1 @@\n+  void remove_unreachable_subgraph(PhaseIterGVN* igvn);\n@@ -111,0 +133,1 @@\n+  NOT_PRODUCT(virtual void dump_spec(outputStream* st) const;)\n@@ -154,0 +177,2 @@\n+  bool must_wait_for_region_in_irreducible_loop(PhaseGVN* phase) const;\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":27,"deletions":2,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -759,0 +759,3 @@\n+\n+    gvn.set_type(root(), root()->bottom_type());\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+    init_class_id(Class_Con);\n@@ -56,1 +57,3 @@\n-  ConINode( const TypeInt *t ) : ConNode(t) {}\n+  ConINode(const TypeInt* t) : ConNode(t) {\n+    init_class_id(Class_ConI);\n+  }\n","filename":"src\/hotspot\/share\/opto\/connode.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -951,2 +951,1 @@\n-      _gvn.set_type(ex_klass_node, TypeInstKlassPtr::OBJECT);\n-\n+      ex_klass_node = _gvn.transform(ex_klass_node);\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -728,0 +728,2 @@\n+  case vmIntrinsics::_IndexPartiallyInUpperRange:\n+    return inline_index_partially_in_upper_range();\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -360,0 +360,1 @@\n+  bool inline_index_partially_in_upper_range();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+  RegionNode::dump_spec(st);\n@@ -3140,1 +3141,1 @@\n-  Node *landing_pad = new RegionNode( fall_in_cnt+1 );\n+  RegionNode* landing_pad = new RegionNode(fall_in_cnt + 1);\n@@ -3142,0 +3143,2 @@\n+  \/\/ If _head was irreducible loop entry, landing_pad may now be too\n+  landing_pad->set_loop_status(_head->as_Region()->loop_status());\n@@ -4629,4 +4632,0 @@\n-\n-  \/\/ disable assert until issue with split_flow_path is resolved (6742111)\n-  \/\/ assert(!_has_irreducible_loops || C->parsed_irreducible_loop() || C->is_osr_compilation(),\n-  \/\/        \"shouldn't introduce irreducible loops\");\n@@ -5058,0 +5057,1 @@\n+  DEBUG_ONLY(verify_regions_in_irreducible_loops();)\n@@ -5152,4 +5152,9 @@\n-    \/\/ Weeny check for irreducible.  This child was already visited (this\n-    \/\/ IS the post-work phase).  Is this child's loop header post-visited\n-    \/\/ as well?  If so, then I found another entry into the loop.\n-    if (!_verify_only) {\n+    if (is_postvisited(l->_head)) {\n+      \/\/ We are currently visiting l, but its head has already been post-visited.\n+      \/\/ l is irreducible: we just found a second entry m.\n+      _has_irreducible_loops = true;\n+      RegionNode* secondary_entry = m->as_Region();\n+      DEBUG_ONLY(secondary_entry->verify_can_be_irreducible_entry();)\n+\n+      \/\/ Walk up the loop-tree, mark all loops that are already post-visited as irreducible\n+      \/\/ Since m is a secondary entry to them all.\n@@ -5157,1 +5162,0 @@\n-        \/\/ found irreducible\n@@ -5159,0 +5163,2 @@\n+        RegionNode* head = l->_head->as_Region();\n+        DEBUG_ONLY(head->verify_can_be_irreducible_entry();)\n@@ -5160,1 +5166,0 @@\n-        _has_irreducible_loops = true;\n@@ -5163,0 +5168,6 @@\n+#ifndef PRODUCT\n+          if (TraceLoopOpts) {\n+            tty->print_cr(\"bailout: unhandled CFG: infinite irreducible loop\");\n+            m->dump();\n+          }\n+#endif\n@@ -5167,0 +5178,2 @@\n+    }\n+    if (!_verify_only) {\n@@ -5234,0 +5247,68 @@\n+#ifdef ASSERT\n+\/\/--------------------------verify_regions_in_irreducible_loops----------------\n+\/\/ Iterate down from Root through CFG, verify for every region:\n+\/\/ if it is in an irreducible loop it must be marked as such\n+void PhaseIdealLoop::verify_regions_in_irreducible_loops() {\n+  ResourceMark rm;\n+  if (!_has_irreducible_loops) {\n+    \/\/ last build_loop_tree has not found any irreducible loops\n+    \/\/ hence no region has to be marked is_in_irreduible_loop\n+    return;\n+  }\n+\n+  RootNode* root = C->root();\n+  Unique_Node_List worklist; \/\/ visit all nodes once\n+  worklist.push(root);\n+  bool failure = false;\n+  for (uint i = 0; i < worklist.size(); i++) {\n+    Node* n = worklist.at(i);\n+    if (n->is_Region()) {\n+      RegionNode* region = n->as_Region();\n+      if (is_in_irreducible_loop(region) &&\n+          region->loop_status() == RegionNode::LoopStatus::Reducible) {\n+        failure = true;\n+        tty->print(\"irreducible! \");\n+        region->dump();\n+      }\n+    }\n+    for (DUIterator_Fast jmax, j = n->fast_outs(jmax); j < jmax; j++) {\n+      Node* use = n->fast_out(j);\n+      if (use->is_CFG()) {\n+        worklist.push(use); \/\/ push if was not pushed before\n+      }\n+    }\n+  }\n+  assert(!failure, \"region in irreducible loop was marked as reducible\");\n+}\n+\n+\/\/---------------------------is_in_irreducible_loop-------------------------\n+\/\/ Analogous to ciTypeFlow::Block::is_in_irreducible_loop\n+bool PhaseIdealLoop::is_in_irreducible_loop(RegionNode* region) {\n+  if (!_has_irreducible_loops) {\n+    return false; \/\/ no irreducible loop in graph\n+  }\n+  IdealLoopTree* l = get_loop(region); \/\/ l: innermost loop that contains region\n+  do {\n+    if (l->_irreducible) {\n+      return true; \/\/ found it\n+    }\n+    if (l == _ltree_root) {\n+      return false; \/\/ reached root, terimnate\n+    }\n+    l = l->_parent;\n+  } while (l != nullptr);\n+  assert(region->is_in_infinite_subgraph(), \"must be in infinite subgraph\");\n+  \/\/ We have \"l->_parent == nullptr\", which happens only for infinite loops,\n+  \/\/ where no parent is attached to the loop. We did not find any irreducible\n+  \/\/ loop from this block out to lp. Thus lp only has one entry, and no exit\n+  \/\/ (it is infinite and reducible). We can always rewrite an infinite loop\n+  \/\/ that is nested inside other loops:\n+  \/\/ while(condition) { infinite_loop; }\n+  \/\/ with an equivalent program where the infinite loop is an outermost loop\n+  \/\/ that is not nested in any loop:\n+  \/\/ while(condition) { break; } infinite_loop;\n+  \/\/ Thus, we can understand lp as an outermost loop, and can terminate and\n+  \/\/ conclude: this block is in no irreducible loop.\n+  return false;\n+}\n+#endif\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":92,"deletions":11,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -1075,0 +1075,6 @@\n+#ifdef ASSERT\n+  \/\/ verify that regions in irreducible loops are marked is_in_irreducible_loop\n+  void verify_regions_in_irreducible_loops();\n+  bool is_in_irreducible_loop(RegionNode* region);\n+#endif\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2153,0 +2153,4 @@\n+      assert(use->in(idx) == old, \"old is still input of use\");\n+      \/\/ We notify all uses of old, including use, and the indirect uses,\n+      \/\/ that may now be optimized because we have replaced old with phi.\n+      _igvn.add_users_to_worklist(old);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -190,0 +190,2 @@\n+      } else if (proj_in->is_top()) {\n+        break; \/\/ dead code\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -740,0 +740,4 @@\n+bool Node::is_not_dead(const Node* n) {\n+  return n == nullptr || !PhaseIterGVN::is_verify_def_use() || !(n->is_dead());\n+}\n+\n@@ -1147,1 +1151,1 @@\n-\/\/ these Ideal calls need to hold.  Running with '+VerifyIterativeGVN' checks\n+\/\/ these Ideal calls need to hold.  Running with '-XX:VerifyIterativeGVN=1' checks\n@@ -1149,1 +1153,1 @@\n-\/\/ hacking an Ideal call, be sure to test with +VerifyIterativeGVN!\n+\/\/ hacking an Ideal call, be sure to test with '-XX:VerifyIterativeGVN=1'\n@@ -1382,0 +1386,1 @@\n+  VectorSet dead_set; \/\/ notify uses only once\n@@ -1389,0 +1394,4 @@\n+    if (!dead_set.test_set(dead->_idx)) {\n+      \/\/ If dead has any live uses, those are now still attached. Notify them before we lose them.\n+      igvn->add_users_to_worklist(dead);\n+    }\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,0 +72,1 @@\n+class ConINode;\n@@ -414,1 +415,1 @@\n-#define is_not_dead(n) ((n) == NULL || !VerifyIterativeGVN || !((n)->is_dead()))\n+  static bool is_not_dead(const Node* n);\n@@ -714,0 +715,3 @@\n+      DEFINE_CLASS_ID(Con, Type, 8)\n+          DEFINE_CLASS_ID(ConI, Con, 0)\n+\n@@ -865,0 +869,1 @@\n+  DEFINE_CLASS_QUERY(ConI)\n@@ -1040,1 +1045,1 @@\n-  \/\/ +VerifyIterativeGVN!\n+  \/\/ -XX:VerifyIterativeGVN=1\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,1 +373,1 @@\n-          (C->has_java_calls() || frame_size_in_bytes > os::vm_page_size()>>3\n+          (C->has_java_calls() || frame_size_in_bytes > (int)(os::vm_page_size())>>3\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -225,0 +225,23 @@\n+    bool is_in_irreducible_loop() const {\n+      return flow()->is_in_irreducible_loop();\n+    }\n+    bool is_irreducible_loop_entry() const {\n+      return flow()->is_irreducible_loop_head() || flow()->is_irreducible_loop_secondary_entry();\n+    }\n+    void copy_irreducible_status_to(RegionNode* region, const JVMState* jvms) {\n+      assert(!is_irreducible_loop_entry() || is_in_irreducible_loop(), \"entry is part of irreducible loop\");\n+      if (is_in_irreducible_loop()) {\n+        \/\/ The block is in an irreducible loop of this method, so it is possible that this\n+        \/\/ region becomes an irreducible loop entry. (no guarantee)\n+        region->set_loop_status(RegionNode::LoopStatus::MaybeIrreducibleEntry);\n+      } else if (jvms->caller() != nullptr) {\n+        \/\/ The block is not in an irreducible loop of this method, hence it cannot ever\n+        \/\/ be the entry of an irreducible loop. But it may be inside an irreducible loop\n+        \/\/ of a caller of this inlined method. (limited guarantee)\n+        assert(region->loop_status() == RegionNode::LoopStatus::NeverIrreducibleEntry, \"status not changed\");\n+      } else {\n+        \/\/ The block is not in an irreducible loop of this method, and there is no outer\n+        \/\/ method. This region will never be in an irreducible loop (strong guarantee)\n+        region->set_loop_status(RegionNode::LoopStatus::Reducible);\n+      }\n+    }\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -547,1 +547,0 @@\n-  gvn().set_type(root(), root()->bottom_type());\n@@ -682,0 +681,1 @@\n+          block->copy_irreducible_status_to(r, jvms());\n@@ -1503,1 +1503,6 @@\n-    if (b->is_loop_head()) tty->print(\"  lphd\");\n+    if (b->is_loop_head()) {\n+      tty->print(\"  lphd\");\n+    }\n+    if (b->is_irreducible_loop_entry()) {\n+      tty->print(\"  irreducible\");\n+    }\n@@ -1692,0 +1697,1 @@\n+      target->copy_irreducible_status_to(r, jvms());\n@@ -1729,1 +1735,1 @@\n-      if (!block()->flow()->is_irreducible_entry()) {\n+      if (!block()->flow()->is_irreducible_loop_secondary_entry()) {\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -942,1 +942,1 @@\n-    if (!no_dead_loop) n->dump(3);\n+    if (!no_dead_loop) n->dump_bfs(100,0,\"#\");\n@@ -1021,1 +1021,1 @@\n-  if (VerifyIterativeGVN) {\n+  if (is_verify_def_use()) {\n@@ -1132,1 +1132,1 @@\n-  if (VerifyIterativeGVN && PrintOpto) {\n+  if (is_verify_def_use() && PrintOpto) {\n@@ -1150,0 +1150,2 @@\n+\n+  verify_optimize();\n@@ -1213,0 +1215,91 @@\n+#ifdef ASSERT\n+void PhaseIterGVN::verify_optimize() {\n+  if (is_verify_Value()) {\n+    ResourceMark rm;\n+    Unique_Node_List worklist;\n+    bool failure = false;\n+    \/\/ BFS all nodes, starting at root\n+    worklist.push(C->root());\n+    for (uint j = 0; j < worklist.size(); ++j) {\n+      Node* n = worklist.at(j);\n+      failure |= verify_node_value(n);\n+      \/\/ traverse all inputs and outputs\n+      for (uint i = 0; i < n->req(); i++) {\n+        if (n->in(i) != nullptr) {\n+          worklist.push(n->in(i));\n+        }\n+      }\n+      for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+        worklist.push(n->fast_out(i));\n+      }\n+    }\n+    \/\/ If we get this assert, check why the reported nodes were not processed again in IGVN.\n+    \/\/ We should either make sure that these nodes are properly added back to the IGVN worklist\n+    \/\/ in PhaseIterGVN::add_users_to_worklist to update them again or add an exception\n+    \/\/ in the verification code above if that is not possible for some reason (like Load nodes).\n+    assert(!failure, \"Missed optimization opportunity in PhaseIterGVN\");\n+  }\n+}\n+\n+\/\/ Check that type(n) == n->Value(), return true if we have a failure.\n+\/\/ We have a list of exceptions, see detailed comments in code.\n+\/\/ (1) Integer \"widen\" changes, but the range is the same.\n+\/\/ (2) LoadNode performs deep traversals. Load is not notified for changes far away.\n+\/\/ (3) CmpPNode performs deep traversals if it compares oopptr. CmpP is not notified for changes far away.\n+bool PhaseIterGVN::verify_node_value(Node* n) {\n+  \/\/ If we assert inside type(n), because the type is still a nullptr, then maybe\n+  \/\/ the node never went through gvn.transform, which would be a bug.\n+  const Type* told = type(n);\n+  const Type* tnew = n->Value(this);\n+  if (told == tnew) {\n+    return false;\n+  }\n+  \/\/ Exception (1)\n+  \/\/ Integer \"widen\" changes, but range is the same.\n+  if (told->isa_integer(tnew->basic_type()) != nullptr) { \/\/ both either int or long\n+    const TypeInteger* t0 = told->is_integer(tnew->basic_type());\n+    const TypeInteger* t1 = tnew->is_integer(tnew->basic_type());\n+    if (t0->lo_as_long() == t1->lo_as_long() &&\n+        t0->hi_as_long() == t1->hi_as_long()) {\n+      return false; \/\/ ignore integer widen\n+    }\n+  }\n+  \/\/ Exception (2)\n+  \/\/ LoadNode performs deep traversals. Load is not notified for changes far away.\n+  if (n->is_Load() && !told->singleton()) {\n+    \/\/ MemNode::can_see_stored_value looks up through many memory nodes,\n+    \/\/ which means we would need to notify modifications from far up in\n+    \/\/ the inputs all the way down to the LoadNode. We don't do that.\n+    return false;\n+  }\n+  \/\/ Exception (3)\n+  \/\/ CmpPNode performs deep traversals if it compares oopptr. CmpP is not notified for changes far away.\n+  if (n->Opcode() == Op_CmpP && type(n->in(1))->isa_oopptr() && type(n->in(2))->isa_oopptr()) {\n+    \/\/ SubNode::Value\n+    \/\/ CmpPNode::sub\n+    \/\/ MemNode::detect_ptr_independence\n+    \/\/ MemNode::all_controls_dominate\n+    \/\/ We find all controls of a pointer load, and see if they dominate the control of\n+    \/\/ an allocation. If they all dominate, we know the allocation is after (independent)\n+    \/\/ of the pointer load, and we can say the pointers are different. For this we call\n+    \/\/ n->dominates(sub, nlist) to check if controls n of the pointer load dominate the\n+    \/\/ control sub of the allocation. The problems is that sometimes dominates answers\n+    \/\/ false conservatively, and later it can determine that it is indeed true. Loops with\n+    \/\/ Region heads can lead to giving up, whereas LoopNodes can be skipped easier, and\n+    \/\/ so the traversal becomes more powerful. This is difficult to remidy, we would have\n+    \/\/ to notify the CmpP of CFG updates. Luckily, we recompute CmpP::Value during CCP\n+    \/\/ after loop-opts, so that should take care of many of these cases.\n+    return false;\n+  }\n+  tty->cr();\n+  tty->print_cr(\"Missed Value optimization:\");\n+  n->dump_bfs(1, 0, \"\");\n+  tty->print_cr(\"Current type:\");\n+  told->dump_on(tty);\n+  tty->cr();\n+  tty->print_cr(\"Optimized type:\");\n+  tnew->dump_on(tty);\n+  tty->cr();\n+  return true;\n+}\n+#endif\n@@ -1247,1 +1340,2 @@\n-  if (VerifyIterativeGVN) {\n+#ifdef ASSERT\n+  if (is_verify_def_use()) {\n@@ -1250,0 +1344,1 @@\n+#endif\n@@ -1497,1 +1592,1 @@\n-  if( VerifyIterativeGVN ) {\n+  if (is_verify_def_use()) {\n@@ -1578,2 +1673,2 @@\n-      if (use_op == Op_CmpI) {\n-        Node* phi = countedloop_phi_from_cmp((CmpINode*)use, n);\n+      if (use_op == Op_CmpI || use_op == Op_CmpL) {\n+        Node* phi = countedloop_phi_from_cmp(use->as_Cmp(), n);\n@@ -1581,5 +1676,3 @@\n-          \/\/ If an opaque node feeds into the limit condition of a\n-          \/\/ CountedLoop, we need to process the Phi node for the\n-          \/\/ induction variable when the opaque node is removed:\n-          \/\/ the range of values taken by the Phi is now known and\n-          \/\/ so its type is also known.\n+          \/\/ Input to the cmp of a loop exit check has changed, thus\n+          \/\/ the loop limit may have changed, which can then change the\n+          \/\/ range values of the trip-count Phi.\n@@ -1588,12 +1681,61 @@\n-        Node* in1 = use->in(1);\n-        for (uint i = 0; i < in1->outcnt(); i++) {\n-          if (in1->raw_out(i)->Opcode() == Op_CastII) {\n-            Node* castii = in1->raw_out(i);\n-            if (castii->in(0) != NULL && castii->in(0)->in(0) != NULL && castii->in(0)->in(0)->is_If()) {\n-              Node* ifnode = castii->in(0)->in(0);\n-              if (ifnode->in(1) != NULL && ifnode->in(1)->is_Bool() && ifnode->in(1)->in(1) == use) {\n-                \/\/ Reprocess a CastII node that may depend on an\n-                \/\/ opaque node value when the opaque node is\n-                \/\/ removed. In case it carries a dependency we can do\n-                \/\/ a better job of computing its type.\n-                _worklist.push(castii);\n+      }\n+      if (use_op == Op_CmpI) {\n+        Node* cmp = use;\n+        Node* in1 = cmp->in(1);\n+        Node* in2 = cmp->in(2);\n+        \/\/ Notify CmpI \/ If pattern from CastIINode::Value (left pattern).\n+        \/\/ Must also notify if in1 is modified and possibly turns into X (right pattern).\n+        \/\/\n+        \/\/ in1  in2                   in1  in2\n+        \/\/  |    |                     |    |\n+        \/\/  +--- | --+                 |    |\n+        \/\/  |    |   |                 |    |\n+        \/\/ CmpINode  |                CmpINode\n+        \/\/    |      |                   |\n+        \/\/ BoolNode  |                BoolNode\n+        \/\/    |      |        OR         |\n+        \/\/  IfNode   |                 IfNode\n+        \/\/    |      |                   |\n+        \/\/  IfProj   |                 IfProj   X\n+        \/\/    |      |                   |      |\n+        \/\/   CastIINode                 CastIINode\n+        \/\/\n+        if (in1 != in2) { \/\/ if they are equal, the CmpI can fold them away\n+          if (in1 == n) {\n+            \/\/ in1 modified -> could turn into X -> do traversal based on right pattern.\n+            for (DUIterator_Fast i2max, i2 = cmp->fast_outs(i2max); i2 < i2max; i2++) {\n+              Node* bol = cmp->fast_out(i2); \/\/ For each Bool\n+              if (bol->is_Bool()) {\n+                for (DUIterator_Fast i3max, i3 = bol->fast_outs(i3max); i3 < i3max; i3++) {\n+                  Node* iff = bol->fast_out(i3); \/\/ For each If\n+                  if (iff->is_If()) {\n+                    for (DUIterator_Fast i4max, i4 = iff->fast_outs(i4max); i4 < i4max; i4++) {\n+                      Node* if_proj = iff->fast_out(i4); \/\/ For each IfProj\n+                      assert(if_proj->is_IfProj(), \"If only has IfTrue and IfFalse as outputs\");\n+                      for (DUIterator_Fast i5max, i5 = if_proj->fast_outs(i5max); i5 < i5max; i5++) {\n+                        Node* castii = if_proj->fast_out(i5); \/\/ For each CastII\n+                        if (castii->is_CastII() &&\n+                            castii->as_CastII()->carry_dependency()) {\n+                          _worklist.push(castii);\n+                        }\n+                      }\n+                    }\n+                  }\n+                }\n+              }\n+            }\n+          } else {\n+            \/\/ Only in2 modified -> can assume X == in2 (left pattern).\n+            assert(n == in2, \"only in2 modified\");\n+            \/\/ Find all CastII with input in1.\n+            for (DUIterator_Fast jmax, j = in1->fast_outs(jmax); j < jmax; j++) {\n+              Node* castii = in1->fast_out(j);\n+              if (castii->is_CastII() && castii->as_CastII()->carry_dependency()) {\n+                \/\/ Find If.\n+                if (castii->in(0) != nullptr && castii->in(0)->in(0) != nullptr && castii->in(0)->in(0)->is_If()) {\n+                  Node* ifnode = castii->in(0)->in(0);\n+                  \/\/ Check that if connects to the cmp\n+                  if (ifnode->in(1) != nullptr && ifnode->in(1)->is_Bool() && ifnode->in(1)->in(1) == cmp) {\n+                    _worklist.push(castii);\n+                  }\n+                }\n@@ -1607,1 +1749,1 @@\n-    \/\/ If changed Cast input, check Phi users for simple cycles\n+    \/\/ If changed Cast input, notify down for Phi and Sub - both do \"uncast\"\n@@ -1611,1 +1753,2 @@\n-        if (u->is_Phi())\n+        if (u->is_Phi() || u->is_Sub()) {\n+          \/\/ Phi (.., CastII, ..) or Sub(Cast(x), x)\n@@ -1613,0 +1756,18 @@\n+        } else if (u->is_ConstraintCast()) {\n+          \/\/ Follow cast-chains down to Sub: Sub( CastII(CastII(x)), x)\n+          \/\/ This case is quite rare. Let's BFS-traverse casts, to find Subs:\n+          ResourceMark rm;\n+          Unique_Node_List casts;\n+          casts.push(u); \/\/ start traversal\n+          for (uint j = 0; j < casts.size(); ++j) {\n+            Node* cast = casts.at(j); \/\/ for every cast\n+            for (DUIterator_Fast kmax, k = cast->fast_outs(kmax); k < kmax; k++) {\n+              Node* cast_use = cast->fast_out(k);\n+              if (cast_use->is_ConstraintCast()) {\n+                casts.push(cast_use); \/\/ traverse this cast also\n+              } else if (cast_use->is_Sub()) {\n+                _worklist.push(cast_use); \/\/ found Sub\n+              }\n+            }\n+          }\n+        }\n@@ -1623,0 +1784,9 @@\n+    \/\/ If changed LShift inputs, check And users for shift and mask (And) operation\n+    if (use_op == Op_LShiftI || use_op == Op_LShiftL) {\n+      for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n+        Node* u = use->fast_out(i2);\n+        if (u->Opcode() == Op_AndI || u->Opcode() == Op_AndL) {\n+          _worklist.push(u);\n+        }\n+      }\n+    }\n@@ -1816,1 +1986,1 @@\n-\/\/ We have a list of exceptions, see comments in code.\n+\/\/ We have a list of exceptions, see comments in verify_node_value.\n@@ -1821,30 +1991,1 @@\n-    const Type* told = type(n);\n-    const Type* tnew = n->Value(this);\n-    if (told != tnew) {\n-      \/\/ Check special cases that are ok\n-      if (told->isa_integer(tnew->basic_type()) != nullptr) { \/\/ both either int or long\n-        const TypeInteger* t0 = told->is_integer(tnew->basic_type());\n-        const TypeInteger* t1 = tnew->is_integer(tnew->basic_type());\n-        if (t0->lo_as_long() == t1->lo_as_long() &&\n-            t0->hi_as_long() == t1->hi_as_long()) {\n-          continue; \/\/ ignore integer widen\n-        }\n-      }\n-      if (n->is_Load() && !told->singleton()) {\n-        \/\/ MemNode::can_see_stored_value looks up through many memory nodes,\n-        \/\/ which means we would need to notify modifications from far up in\n-        \/\/ the inputs all the way down to the LoadNode. We don't do that.\n-        continue;\n-      }\n-      verify_type(n, tnew, told);\n-      tty->cr();\n-      tty->print_cr(\"Missed optimization (PhaseCCP):\");\n-      n->dump_bfs(1, 0, \"\");\n-      tty->print_cr(\"Current type:\");\n-      told->dump_on(tty);\n-      tty->cr();\n-      tty->print_cr(\"Optimized type:\");\n-      tnew->dump_on(tty);\n-      tty->cr();\n-      failure = true;\n-    }\n+    failure |= verify_node_value(n);\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":198,"deletions":57,"binary":false,"changes":255,"status":"modified"},{"patch":"@@ -338,0 +338,3 @@\n+  virtual const Type* saturate_and_maybe_push_to_igvn_worklist(const TypeNode* n, const Type* new_type) {\n+    return saturate(new_type, type_or_null(n), n->type());\n+  }\n@@ -479,0 +482,4 @@\n+#ifdef ASSERT\n+  void verify_optimize();\n+  bool verify_node_value(Node* n);\n+#endif\n@@ -567,0 +574,8 @@\n+  static bool is_verify_def_use() {\n+    \/\/ '-XX:VerifyIterativeGVN=1'\n+    return (VerifyIterativeGVN % 10) == 1;\n+  }\n+  static bool is_verify_Value() {\n+    \/\/ '-XX:VerifyIterativeGVN=10'\n+    return ((VerifyIterativeGVN % 100) \/ 10) == 1;\n+  }\n@@ -568,1 +583,1 @@\n-  \/\/ Sub-quadratic implementation of VerifyIterativeGVN.\n+  \/\/ Sub-quadratic implementation of '-XX:VerifyIterativeGVN=1' (Use-Def verification).\n@@ -622,0 +637,8 @@\n+  virtual const Type* saturate_and_maybe_push_to_igvn_worklist(const TypeNode* n, const Type* new_type) {\n+    const Type* t = saturate(new_type, type_or_null(n), n->type());\n+    if (t != new_type) {\n+      \/\/ Type was widened in CCP, but IGVN may be able to make it narrower.\n+      _worklist.push((Node*)n);\n+    }\n+    return t;\n+  }\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1194,1 +1194,1 @@\n-  this->set_req(1,ldk2);\n+  this->set_req_X(1, ldk2, phase);\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -3041,0 +3041,1 @@\n+          _igvn.register_new_node_with_optimizer(cnt);\n@@ -3173,1 +3174,2 @@\n-    Node* ex = ExtractNode::make(def, def_pos, velt_basic_type(def));\n+    ConINode* def_pos_con = _igvn.intcon(def_pos)->as_ConI();\n+    Node* ex = ExtractNode::make(def, def_pos_con, velt_basic_type(def));\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2732,1 +2732,2 @@\n-  Node* operation = gvn().transform(ExtractNode::make(opd, idx->get_con(), elem_bt));\n+  ConINode* idx_con = gvn().intcon(idx->get_con())->as_ConI();\n+  Node* operation = gvn().transform(ExtractNode::make(opd, idx_con, elem_bt));\n@@ -3008,0 +3009,128 @@\n+\n+\/\/ public static\n+\/\/ <E,\n+\/\/  M extends VectorMask<E>>\n+\/\/ M indexPartiallyInUpperRange(Class<? extends M> mClass, Class<E> eClass, int length,\n+\/\/                              long offset, long limit,\n+\/\/                              IndexPartiallyInUpperRangeOperation<E, M> defaultImpl)\n+bool LibraryCallKit::inline_index_partially_in_upper_range() {\n+  const TypeInstPtr* mask_klass   = gvn().type(argument(0))->isa_instptr();\n+  const TypeInstPtr* elem_klass   = gvn().type(argument(1))->isa_instptr();\n+  const TypeInt*     vlen         = gvn().type(argument(2))->isa_int();\n+\n+  if (mask_klass == NULL || elem_klass == NULL || vlen == NULL ||\n+      mask_klass->const_oop() == NULL || elem_klass->const_oop() == NULL || !vlen->is_con()) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** missing constant: mclass=%s etype=%s vlen=%s\",\n+                    NodeClassNames[argument(0)->Opcode()],\n+                    NodeClassNames[argument(1)->Opcode()],\n+                    NodeClassNames[argument(2)->Opcode()]);\n+    }\n+    return false; \/\/ not enough info for intrinsification\n+  }\n+\n+  if (!is_klass_initialized(mask_klass)) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** klass argument not initialized\");\n+    }\n+    return false;\n+  }\n+\n+  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n+  if (!elem_type->is_primitive_type()) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n+    }\n+    return false; \/\/ should be primitive type\n+  }\n+\n+  int num_elem = vlen->get_con();\n+  BasicType elem_bt = elem_type->basic_type();\n+\n+  \/\/ Check whether the necessary ops are supported by current hardware.\n+  bool supports_mask_gen = arch_supports_vector(Op_VectorMaskGen, num_elem, elem_bt, VecMaskUseStore);\n+  if (!supports_mask_gen) {\n+    if (!arch_supports_vector(Op_VectorLoadConst, num_elem, elem_bt, VecMaskNotUsed) ||\n+        !arch_supports_vector(VectorNode::replicate_opcode(elem_bt), num_elem, elem_bt, VecMaskNotUsed) ||\n+        !arch_supports_vector(Op_VectorMaskCmp, num_elem, elem_bt, VecMaskUseStore)) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** not supported: vlen=%d etype=%s\", num_elem, type2name(elem_bt));\n+      }\n+      return false; \/\/ not supported\n+    }\n+\n+    \/\/ Check whether the scalar cast operation is supported by current hardware.\n+    if (elem_bt != T_LONG) {\n+      int cast_op = is_integral_type(elem_bt) ? Op_ConvL2I\n+                                              : (elem_bt == T_FLOAT ? Op_ConvL2F : Op_ConvL2D);\n+      if (!Matcher::match_rule_supported(cast_op)) {\n+        if (C->print_intrinsics()) {\n+          tty->print_cr(\"  ** Rejected op (%s) because architecture does not support it\",\n+                        NodeClassNames[cast_op]);\n+        }\n+        return false; \/\/ not supported\n+      }\n+    }\n+  }\n+\n+  Node* offset = argument(3);\n+  Node* limit = argument(5);\n+  if (offset == NULL || limit == NULL) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** offset or limit argument is NULL\");\n+    }\n+    return false; \/\/ not supported\n+  }\n+\n+  ciKlass* box_klass = mask_klass->const_oop()->as_instance()->java_lang_Class_klass();\n+  assert(is_vector_mask(box_klass), \"argument(0) should be a mask class\");\n+  const TypeInstPtr* box_type = TypeInstPtr::make_exact(TypePtr::NotNull, box_klass);\n+\n+  \/\/ We assume \"offset > 0 && limit >= offset && limit - offset < num_elem\".\n+  \/\/ So directly get indexLimit with \"indexLimit = limit - offset\".\n+  Node* indexLimit = gvn().transform(new SubLNode(limit, offset));\n+  Node* mask = NULL;\n+  if (supports_mask_gen) {\n+    mask = gvn().transform(VectorMaskGenNode::make(indexLimit, elem_bt, num_elem));\n+  } else {\n+    \/\/ Generate the vector mask based on \"mask = iota < indexLimit\".\n+    \/\/ Broadcast \"indexLimit\" to a vector.\n+    switch (elem_bt) {\n+      case T_BOOLEAN: \/\/ fall-through\n+      case T_BYTE:    \/\/ fall-through\n+      case T_SHORT:   \/\/ fall-through\n+      case T_CHAR:    \/\/ fall-through\n+      case T_INT: {\n+        indexLimit = gvn().transform(new ConvL2INode(indexLimit));\n+        break;\n+      }\n+      case T_DOUBLE: {\n+        indexLimit = gvn().transform(new ConvL2DNode(indexLimit));\n+        break;\n+      }\n+      case T_FLOAT: {\n+        indexLimit = gvn().transform(new ConvL2FNode(indexLimit));\n+        break;\n+      }\n+      case T_LONG: {\n+        \/\/ no conversion needed\n+        break;\n+      }\n+      default: fatal(\"%s\", type2name(elem_bt));\n+    }\n+    indexLimit = gvn().transform(VectorNode::scalar2vector(indexLimit, num_elem, Type::get_const_basic_type(elem_bt)));\n+\n+    \/\/ Load the \"iota\" vector.\n+    const TypeVect* vt = TypeVect::make(elem_bt, num_elem);\n+    Node* iota = gvn().transform(new VectorLoadConstNode(gvn().makecon(TypeInt::ZERO), vt));\n+\n+    \/\/ Compute the vector mask with \"mask = iota < indexLimit\".\n+    ConINode* pred_node = (ConINode*)gvn().makecon(TypeInt::make(BoolTest::lt));\n+    const TypeVect* vmask_type = TypeVect::makemask(elem_bt, num_elem);\n+    mask = gvn().transform(new VectorMaskCmpNode(BoolTest::lt, iota, indexLimit, pred_node, vmask_type));\n+  }\n+  Node* vbox = box_vector(mask, box_type, elem_bt, num_elem);\n+  set_result(vbox);\n+  C->set_max_vector_size(MAX2(C->max_vector_size(), (uint)(num_elem * type2aelembytes(elem_bt))));\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":130,"deletions":1,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1088,3 +1088,2 @@\n-Node* ExtractNode::make(Node* v, uint position, BasicType bt) {\n-  assert((int)position < Matcher::max_vector_size(bt), \"pos in range\");\n-  ConINode* pos = ConINode::make((int)position);\n+Node* ExtractNode::make(Node* v, ConINode* pos, BasicType bt) {\n+  assert(pos->get_int() < Matcher::max_vector_size(bt), \"pos in range\");\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1279,1 +1279,1 @@\n-  static Node* make(Node* v, uint position, BasicType bt);\n+  static Node* make(Node* v, ConINode* pos, BasicType bt);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+#include \"sanitizers\/leak.hpp\"\n@@ -986,0 +987,2 @@\n+    \/\/ LSan appears unable to keep track of qname, ignore it.\n+    LSAN_IGNORE_OBJECT(qname);\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-  return os::vm_page_size();\n+  return (jint)os::vm_page_size();\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1482,1 +1482,1 @@\n-  size_t displacement_due_to_null_page = align_up((size_t)os::vm_page_size(),\n+  size_t displacement_due_to_null_page = align_up(os::vm_page_size(),\n@@ -1551,1 +1551,1 @@\n-                                          (size_t)os::vm_allocation_granularity(),\n+                                          os::vm_allocation_granularity(),\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -275,2 +275,2 @@\n-static bool stack_overflow_check(JavaThread* thread, int size, address sp) {\n-  const int page_size = os::vm_page_size();\n+static bool stack_overflow_check(JavaThread* thread, size_t size, address sp) {\n+  const size_t page_size = os::vm_page_size();\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -294,1 +294,2 @@\n-JVMFlag::Error TypeProfileLevelConstraintFunc(uintx value, bool verbose) {\n+JVMFlag::Error TypeProfileLevelConstraintFunc(uint value, bool verbose) {\n+  uint original_value = value;\n@@ -298,1 +299,1 @@\n-                          \"Invalid value (\" UINTX_FORMAT \") \"\n+                          \"Invalid value (\" UINT32_FORMAT \") \"\n@@ -304,0 +305,8 @@\n+  if (value != 0) {\n+    JVMFlag::printError(verbose,\n+                        \"Invalid value (\" UINT32_FORMAT \") \"\n+                        \"for TypeProfileLevel: maximal 3 digits\\n\", original_value);\n+    return JVMFlag::VIOLATES_CONSTRAINT;\n+  }\n+  return JVMFlag::SUCCESS;\n+}\n@@ -305,0 +314,17 @@\n+JVMFlag::Error VerifyIterativeGVNConstraintFunc(uint value, bool verbose) {\n+  uint original_value = value;\n+  for (int i = 0; i < 2; i++) {\n+    if (value % 10 > 1) {\n+      JVMFlag::printError(verbose,\n+                          \"Invalid value (\" UINT32_FORMAT \") \"\n+                          \"in VerifyIterativeGVN at position %d\\n\", value, i);\n+      return JVMFlag::VIOLATES_CONSTRAINT;\n+    }\n+    value = value \/ 10;\n+  }\n+  if (value != 0) {\n+    JVMFlag::printError(verbose,\n+                        \"Invalid value (\" UINT32_FORMAT \") \"\n+                        \"for VerifyIterativeGVN: maximal 2 digits\\n\", original_value);\n+    return JVMFlag::VIOLATES_CONSTRAINT;\n+  }\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsCompiler.cpp","additions":29,"deletions":3,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,2 @@\n-  f(uintx, TypeProfileLevelConstraintFunc)              \\\n+  f(uint,  TypeProfileLevelConstraintFunc)              \\\n+  f(uint,  VerifyIterativeGVNConstraintFunc)            \\\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsCompiler.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-                        \"less than page size (%d)\\n\",\n+                        \"less than page size (\" SIZE_FORMAT \")\\n\",\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1112,1 +1112,1 @@\n-  product_pd(uintx, TypeProfileLevel,                                       \\\n+  product_pd(uint, TypeProfileLevel,                                        \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/gcHeapSummary.hpp\"\n@@ -46,0 +47,1 @@\n+#include \"sanitizers\/leak.hpp\"\n@@ -126,0 +128,8 @@\n+#ifdef LEAK_SANITIZER\n+  {\n+    \/\/ Register the Java heap with LSan.\n+    VirtualSpaceSummary summary = Universe::heap()->create_heap_space_summary();\n+    LSAN_REGISTER_ROOT_REGION(summary.start(), summary.reserved_size());\n+  }\n+#endif \/\/ LEAK_SANITIZER\n+\n@@ -186,0 +196,7 @@\n+#ifdef LEAK_SANITIZER\n+    {\n+      \/\/ Unregister the Java heap with LSan.\n+      VirtualSpaceSummary summary = Universe::heap()->create_heap_space_summary();\n+      LSAN_UNREGISTER_ROOT_REGION(summary.start(), summary.reserved_size());\n+    }\n+#endif \/\/ LEAK_SANITIZER\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+#include \"sanitizers\/leak.hpp\"\n@@ -419,0 +420,24 @@\n+  \/\/ At this point only one thread is executing this logic. Any other threads\n+  \/\/ attempting to invoke before_exit() will wait above and return early once\n+  \/\/ this thread finishes before_exit().\n+\n+  \/\/ Do not add any additional shutdown logic between the above mutex logic and\n+  \/\/ leak sanitizer logic below. Any additional shutdown code which performs some\n+  \/\/ cleanup should be added after the leak sanitizer logic below.\n+\n+#ifdef LEAK_SANITIZER\n+  \/\/ If we are built with LSan, we need to perform leak checking. If we are\n+  \/\/ terminating normally, not halting and no VM error, we perform a normal\n+  \/\/ leak check which terminates if leaks are found. If we are not terminating\n+  \/\/ normally, halting or VM error, we perform a recoverable leak check which\n+  \/\/ prints leaks but will not terminate.\n+  if (!halt && !VMError::is_error_reported()) {\n+    LSAN_DO_LEAK_CHECK();\n+  } else {\n+    \/\/ Ignore the return value.\n+    static_cast<void>(LSAN_DO_RECOVERABLE_LEAK_CHECK());\n+  }\n+#endif\n+\n+  \/\/ Actual shutdown logic begins here.\n+\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -552,1 +552,1 @@\n-      guarantee((size_t)v >= (size_t)os::vm_page_size(),\n+      guarantee((size_t)v >= os::vm_page_size(),\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"sanitizers\/leak.hpp\"\n@@ -288,0 +289,1 @@\n+    LSAN_IGNORE_OBJECT(_watcher_thread);\n","filename":"src\/hotspot\/share\/runtime\/nonJavaThread.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -373,1 +373,1 @@\n-  static int vm_page_size() { return OSInfo::vm_page_size(); }\n+  static size_t vm_page_size() { return OSInfo::vm_page_size(); }\n@@ -414,1 +414,1 @@\n-  static int vm_allocation_granularity() { return OSInfo::vm_allocation_granularity(); }\n+  static size_t vm_allocation_granularity() { return OSInfo::vm_allocation_granularity(); }\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,2 @@\n-int OSInfo::_vm_page_size = -1;\n-int OSInfo::_vm_allocation_granularity = -1;\n+size_t OSInfo::_vm_page_size = 0;\n+size_t OSInfo::_vm_allocation_granularity = 0;\n","filename":"src\/hotspot\/share\/runtime\/osInfo.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,2 @@\n-  static int    _vm_page_size;\n-  static int    _vm_allocation_granularity;\n+  static size_t    _vm_page_size;\n+  static size_t    _vm_allocation_granularity;\n@@ -39,1 +39,1 @@\n-  static int vm_page_size() { return _vm_page_size; }\n+  static size_t vm_page_size() { return _vm_page_size; }\n@@ -42,1 +42,1 @@\n-  static int vm_allocation_granularity() { return _vm_allocation_granularity; }\n+  static size_t vm_allocation_granularity() { return _vm_allocation_granularity; }\n@@ -44,3 +44,2 @@\n-  static void set_vm_page_size(int n) {\n-    assert(_vm_page_size < 0, \"init only once\");\n-    assert(n > 0, \"sanity\");\n+  static void set_vm_page_size(size_t n) {\n+    assert(_vm_page_size == 0, \"init only once\");\n@@ -50,3 +49,2 @@\n-  static void set_vm_allocation_granularity(int n) {\n-    assert(_vm_allocation_granularity < 0, \"init only once\");\n-    assert(n > 0, \"sanity\");\n+  static void set_vm_allocation_granularity(size_t n) {\n+    assert(_vm_allocation_granularity == 0, \"init only once\");\n","filename":"src\/hotspot\/share\/runtime\/osInfo.hpp","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-  size_t capacity = align_up(PerfDataMemorySize,\n+  size_t capacity = align_up((size_t)PerfDataMemorySize,\n@@ -100,2 +100,2 @@\n-                          \" os::vm_allocation_granularity = %d,\"\n-                          \" adjusted size = \" SIZE_FORMAT,\n+                          \" os::vm_allocation_granularity = \" SIZE_FORMAT\n+                          \", adjusted size = \" SIZE_FORMAT,\n","filename":"src\/hotspot\/share\/runtime\/perfMemory.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"","filename":"src\/hotspot\/share\/sanitizers\/address.hpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/hotspot\/share\/sanitizers\/address.h","status":"renamed"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2023, Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_SANITIZERS_LEAK_HPP\n+#define SHARE_SANITIZERS_LEAK_HPP\n+\n+#ifdef LEAK_SANITIZER\n+#include <sanitizer\/lsan_interface.h>\n+#endif\n+\n+\/\/ LSAN_REGISTER_ROOT_REGION()\/LSAN_UNREGISTER_ROOT_REGION()\n+\/\/\n+\/\/ Register\/unregister regions of memory with LSan. LSan scans these regions looking for\n+\/\/ pointers to malloc memory. This is only necessary when pointers to malloc memory are\n+\/\/ located in memory that is not returned by malloc, such as mapped memory. LSan will\n+\/\/ skip inaccessible parts of the region, such as those that are not readable.\n+#ifdef LEAK_SANITIZER\n+#define LSAN_REGISTER_ROOT_REGION(addr, size) __lsan_register_root_region((addr), (size))\n+#define LSAN_UNREGISTER_ROOT_REGION(addr, size) __lsan_unregister_root_region((addr), (size))\n+#else\n+#define LSAN_REGISTER_ROOT_REGION(addr, size) \\\n+  do {                                        \\\n+    if (false) {                              \\\n+      ((void) (addr));                        \\\n+      ((void) (size));                        \\\n+    }                                         \\\n+  } while (false)\n+#define LSAN_UNREGISTER_ROOT_REGION(addr, size) \\\n+  do {                                          \\\n+    if (false) {                                \\\n+      ((void) (addr));                          \\\n+      ((void) (size));                          \\\n+    }                                           \\\n+  } while (false)\n+#endif\n+\n+\/\/ LSAN_IGNORE_OBJECT()\n+\/\/\n+\/\/ Causes LSan to ignore any leaks related to the object. Should only be used\n+\/\/ in cases where leaks are intentional or where LSan will be unable to discover\n+\/\/ pointers to object, for example due to pointers being stored unaligned.\n+#ifdef LEAK_SANITIZER\n+#define LSAN_IGNORE_OBJECT(object) __lsan_ignore_object(object)\n+#else\n+#define LSAN_IGNORE_OBJECT(object) \\\n+  do {                             \\\n+    if (false) {                   \\\n+      ((void) (object));           \\\n+    }                              \\\n+  } while (false)\n+#endif\n+\n+\/\/ LSAN_DO_LEAK_CHECK()\n+\/\/\n+\/\/ Perform a leak check, terminating the process if leaks are found. LSan will\n+\/\/ skip performing leak checks at process exit and further calls will be ignored.\n+#ifdef LEAK_SANITIZER\n+#define LSAN_DO_LEAK_CHECK() __lsan_do_leak_check()\n+#else\n+#define LSAN_DO_LEAK_CHECK() ((void) 0)\n+#endif\n+\n+\/\/ LSAN_DO_RECOVERABLE_LEAK_CHECK()\n+\/\/\n+\/\/ Perform a leak check without terminating if leaks are found.\n+#ifdef LEAK_SANITIZER\n+#define LSAN_DO_RECOVERABLE_LEAK_CHECK() __lsan_do_recoverable_leak_check()\n+#else\n+#define LSAN_DO_RECOVERABLE_LEAK_CHECK() ((int) 0)\n+#endif\n+\n+#endif \/\/ SHARE_SANITIZERS_ADDRESS_HPP\n","filename":"src\/hotspot\/share\/sanitizers\/leak.hpp","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -118,1 +118,1 @@\n-  return _malloc_total + _vm_total.reserved;\n+  return _malloc_total + _vm_total.committed;\n","filename":"src\/hotspot\/share\/services\/nmtUsage.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -800,1 +800,1 @@\n-      \/\/ that a statement begins at the “left edge” of the line.\n+      \/\/ that a statement begins at the \"left edge\" of the line.\n","filename":"src\/hotspot\/share\/utilities\/elfFile.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -191,1 +191,1 @@\n-  static constexpr intptr_t segfault_address = (1 * K) AIX_ONLY(+ (4 * K));\n+  static constexpr intptr_t segfault_address = AIX_ONLY(-1) NOT_AIX(1 * K);\n","filename":"src\/hotspot\/share\/utilities\/vmError.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1159,16 +1159,10 @@\n-        perms.merge(fp.getName(), fp,\n-            new java.util.function.BiFunction<>() {\n-                @Override\n-                public Permission apply(Permission existingVal,\n-                                        Permission newVal) {\n-                    int oldMask = ((FilePermission)existingVal).getMask();\n-                    int newMask = ((FilePermission)newVal).getMask();\n-                    if (oldMask != newMask) {\n-                        int effective = oldMask | newMask;\n-                        if (effective == newMask) {\n-                            return newVal;\n-                        }\n-                        if (effective != oldMask) {\n-                            return ((FilePermission)newVal)\n-                                    .withNewActions(effective);\n-                        }\n+        perms.merge(fp.getName(), fp, (existingVal, newVal) -> {\n+                int oldMask = ((FilePermission)existingVal).getMask();\n+                int newMask = ((FilePermission)newVal).getMask();\n+                if (oldMask != newMask) {\n+                    int effective = oldMask | newMask;\n+                    if (effective == newMask) {\n+                        return newVal;\n+                    }\n+                    if (effective != oldMask) {\n+                        return ((FilePermission)newVal).withNewActions(effective);\n@@ -1176,1 +1170,0 @@\n-                    return existingVal;\n@@ -1178,0 +1171,1 @@\n+                return existingVal;\n","filename":"src\/java.base\/share\/classes\/java\/io\/FilePermission.java","additions":12,"deletions":18,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -190,2 +190,5 @@\n- * It defines a thread-local variable to hold the thread-specific filter, and constructs a filter factory\n- * that composes that filter with the static JVM-wide filter and the stream-specific filter.\n+ * It defines a thread-local variable to hold the thread-specific filter, and construct a filter factory\n+ * that composes that filter with the static JVM-wide filter and the stream-specific filter,\n+ * rejecting any classes not handled by those two filters.\n+ * If a stream specific filter is set and does not accept or reject a class,\n+ * the combined JVM-wide filter and thread filter is applied.\n@@ -210,2 +213,3 @@\n- *                 \/\/ Wrap the filter to reject UNDECIDED results\n- *                 filter = ObjectInputFilter.rejectUndecidedClass(filter);\n+ *                 \/\/ Merge to invoke the thread local filter and then the JVM-wide filter (if any)\n+ *                 filter = ObjectInputFilter.merge(filter, next);\n+ *                 return ObjectInputFilter.rejectUndecidedClass(filter);\n@@ -213,8 +217,1 @@\n- *             if (next != null) {\n- *                 \/\/ Merge the next filter with the thread filter, if any\n- *                 \/\/ Initially this is the static JVM-wide filter passed from the OIS constructor\n- *                 \/\/ Wrap the filter to reject UNDECIDED results\n- *                 filter = ObjectInputFilter.merge(next, filter);\n- *                 filter = ObjectInputFilter.rejectUndecidedClass(filter);\n- *             }\n- *             return filter;\n+ *             return (next == null) ? null : ObjectInputFilter.rejectUndecidedClass(next);\n@@ -225,1 +222,1 @@\n- *             \/\/ If there is a stream-specific filter wrap it and a filter to recheck for undecided\n+ *             \/\/ If there is a stream-specific filter merge to invoke it and then the current filter.\n@@ -227,3 +224,1 @@\n- *                 next = ObjectInputFilter.merge(next, curr);\n- *                 next = ObjectInputFilter.rejectUndecidedClass(next);\n- *                 return next;\n+ *                 return ObjectInputFilter.merge(next, curr);\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputFilter.java","additions":11,"deletions":16,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -988,0 +988,209 @@\n+\n+    \/* expm1(x)\n+     * Returns exp(x)-1, the exponential of x minus 1.\n+     *\n+     * Method\n+     *   1. Argument reduction:\n+     *      Given x, find r and integer k such that\n+     *\n+     *               x = k*ln2 + r,  |r| <= 0.5*ln2 ~ 0.34658\n+     *\n+     *      Here a correction term c will be computed to compensate\n+     *      the error in r when rounded to a floating-point number.\n+     *\n+     *   2. Approximating expm1(r) by a special rational function on\n+     *      the interval [0,0.34658]:\n+     *      Since\n+     *          r*(exp(r)+1)\/(exp(r)-1) = 2+ r^2\/6 - r^4\/360 + ...\n+     *      we define R1(r*r) by\n+     *          r*(exp(r)+1)\/(exp(r)-1) = 2+ r^2\/6 * R1(r*r)\n+     *      That is,\n+     *          R1(r**2) = 6\/r *((exp(r)+1)\/(exp(r)-1) - 2\/r)\n+     *                   = 6\/r * ( 1 + 2.0*(1\/(exp(r)-1) - 1\/r))\n+     *                   = 1 - r^2\/60 + r^4\/2520 - r^6\/100800 + ...\n+     *      We use a special Reme algorithm on [0,0.347] to generate\n+     *      a polynomial of degree 5 in r*r to approximate R1. The\n+     *      maximum error of this polynomial approximation is bounded\n+     *      by 2**-61. In other words,\n+     *          R1(z) ~ 1.0 + Q1*z + Q2*z**2 + Q3*z**3 + Q4*z**4 + Q5*z**5\n+     *      where   Q1  =  -1.6666666666666567384E-2,\n+     *              Q2  =   3.9682539681370365873E-4,\n+     *              Q3  =  -9.9206344733435987357E-6,\n+     *              Q4  =   2.5051361420808517002E-7,\n+     *              Q5  =  -6.2843505682382617102E-9;\n+     *      (where z=r*r, and the values of Q1 to Q5 are listed below)\n+     *      with error bounded by\n+     *          |                  5           |     -61\n+     *          | 1.0+Q1*z+...+Q5*z   -  R1(z) | <= 2\n+     *          |                              |\n+     *\n+     *      expm1(r) = exp(r)-1 is then computed by the following\n+     *      specific way which minimize the accumulation rounding error:\n+     *                             2     3\n+     *                            r     r    [ 3 - (R1 + R1*r\/2)  ]\n+     *            expm1(r) = r + --- + --- * [--------------------]\n+     *                            2     2    [ 6 - r*(3 - R1*r\/2) ]\n+     *\n+     *      To compensate the error in the argument reduction, we use\n+     *              expm1(r+c) = expm1(r) + c + expm1(r)*c\n+     *                         ~ expm1(r) + c + r*c\n+     *      Thus c+r*c will be added in as the correction terms for\n+     *      expm1(r+c). Now rearrange the term to avoid optimization\n+     *      screw up:\n+     *                      (      2                                    2 )\n+     *                      ({  ( r    [ R1 -  (3 - R1*r\/2) ]  )  }    r  )\n+     *       expm1(r+c)~r - ({r*(--- * [--------------------]-c)-c} - --- )\n+     *                      ({  ( 2    [ 6 - r*(3 - R1*r\/2) ]  )  }    2  )\n+     *                      (                                             )\n+     *\n+     *                 = r - E\n+     *   3. Scale back to obtain expm1(x):\n+     *      From step 1, we have\n+     *         expm1(x) = either 2^k*[expm1(r)+1] - 1\n+     *                  = or     2^k*[expm1(r) + (1-2^-k)]\n+     *   4. Implementation notes:\n+     *      (A). To save one multiplication, we scale the coefficient Qi\n+     *           to Qi*2^i, and replace z by (x^2)\/2.\n+     *      (B). To achieve maximum accuracy, we compute expm1(x) by\n+     *        (i)   if x < -56*ln2, return -1.0, (raise inexact if x!=inf)\n+     *        (ii)  if k=0, return r-E\n+     *        (iii) if k=-1, return 0.5*(r-E)-0.5\n+     *        (iv)  if k=1 if r < -0.25, return 2*((r+0.5)- E)\n+     *                     else          return  1.0+2.0*(r-E);\n+     *        (v)   if (k<-2||k>56) return 2^k(1-(E-r)) - 1 (or exp(x)-1)\n+     *        (vi)  if k <= 20, return 2^k((1-2^-k)-(E-r)), else\n+     *        (vii) return 2^k(1-((E+2^-k)-r))\n+     *\n+     * Special cases:\n+     *      expm1(INF) is INF, expm1(NaN) is NaN;\n+     *      expm1(-INF) is -1, and\n+     *      for finite argument, only expm1(0)=0 is exact.\n+     *\n+     * Accuracy:\n+     *      according to an error analysis, the error is always less than\n+     *      1 ulp (unit in the last place).\n+     *\n+     * Misc. info.\n+     *      For IEEE double\n+     *          if x >  7.09782712893383973096e+02 then expm1(x) overflow\n+     *\n+     * Constants:\n+     * The hexadecimal values are the intended ones for the following\n+     * constants. The decimal values may be used, provided that the\n+     * compiler will convert from decimal to binary accurately enough\n+     * to produce the hexadecimal values shown.\n+     *\/\n+    static class Expm1 {\n+        private static final double one         =  1.0;\n+        private static final double huge        =  1.0e+300;\n+        private static final double tiny        =  1.0e-300;\n+        private static final double o_threshold =  0x1.62e42fefa39efp9;   \/\/  7.09782712893383973096e+02\n+        private static final double ln2_hi      =  0x1.62e42feep-1;       \/\/  6.93147180369123816490e-01\n+        private static final double ln2_lo      =  0x1.a39ef35793c76p-33; \/\/  1.90821492927058770002e-10\n+        private static final double invln2      =  0x1.71547652b82fep0;   \/\/  1.44269504088896338700e+00\n+        \/\/ scaled coefficients related to expm1\n+        private static final double Q1          = -0x1.11111111110f4p-5;  \/\/ -3.33333333333331316428e-02\n+        private static final double Q2          =  0x1.a01a019fe5585p-10; \/\/  1.58730158725481460165e-03\n+        private static final double Q3          = -0x1.4ce199eaadbb7p-14; \/\/ -7.93650757867487942473e-05\n+        private static final double Q4          =  0x1.0cfca86e65239p-18; \/\/  4.00821782732936239552e-06\n+        private static final double Q5          = -0x1.afdb76e09c32dp-23; \/\/ -2.01099218183624371326e-07\n+\n+        static double compute(double x) {\n+            double y, hi, lo, c=0, t, e, hxs, hfx, r1;\n+            int k, xsb;\n+            \/*unsigned*\/ int hx;\n+\n+            hx  = __HI(x);  \/\/ high word of x\n+            xsb = hx & 0x8000_0000;          \/\/ sign bit of x\n+            y = Math.abs(x);\n+            hx &= 0x7fff_ffff;               \/\/ high word of |x|\n+\n+            \/\/ filter out huge and non-finite argument\n+            if (hx >= 0x4043_687A) {                  \/\/ if |x| >= 56*ln2\n+                if (hx >= 0x4086_2E42) {              \/\/ if |x| >= 709.78...\n+                    if (hx >= 0x7ff_00000) {\n+                        if (((hx & 0xf_ffff) | __LO(x)) != 0) {\n+                            return x + x;     \/\/ NaN\n+                        } else {\n+                            return (xsb == 0)? x : -1.0; \/\/ exp(+-inf)={inf,-1}\n+                        }\n+                    }\n+                    if (x > o_threshold) {\n+                        return huge*huge; \/\/ overflow\n+                    }\n+                }\n+                if (xsb != 0) { \/\/ x < -56*ln2, return -1.0 with inexact\n+                    if (x + tiny < 0.0) {         \/\/ raise inexact\n+                        return tiny - one;        \/\/ return -1\n+                    }\n+                }\n+            }\n+\n+            \/\/ argument reduction\n+            if (hx > 0x3fd6_2e42) {         \/\/ if  |x| > 0.5 ln2\n+                if (hx < 0x3FF0_A2B2) {     \/\/ and |x| < 1.5 ln2\n+                    if (xsb == 0) {\n+                        hi = x - ln2_hi;\n+                        lo = ln2_lo;\n+                        k =  1;\n+                    } else {\n+                        hi = x + ln2_hi;\n+                        lo = -ln2_lo;\n+                        k = -1;\n+                    }\n+                } else {\n+                    k  = (int)(invln2*x + ((xsb == 0) ? 0.5 : -0.5));\n+                    t  = k;\n+                    hi = x - t*ln2_hi;      \/\/ t*ln2_hi is exact here\n+                    lo = t*ln2_lo;\n+                }\n+                x  = hi - lo;\n+                c  = (hi - x) - lo;\n+            } else if (hx < 0x3c90_0000) {  \/\/ when |x| < 2**-54, return x\n+                t = huge + x; \/\/ return x with inexact flags when x != 0\n+                return x - (t - (huge + x));\n+            } else {\n+                k = 0;\n+            }\n+\n+            \/\/ x is now in primary range\n+            hfx = 0.5*x;\n+            hxs = x*hfx;\n+            r1 = one + hxs*(Q1 + hxs*(Q2 + hxs*(Q3 + hxs*(Q4 + hxs*Q5))));\n+            t  = 3.0 - r1*hfx;\n+            e  = hxs *((r1 - t)\/(6.0 - x*t));\n+            if (k == 0) {\n+                return x - (x*e - hxs);          \/\/ c is 0\n+            } else {\n+                e  = (x*(e - c) - c);\n+                e -= hxs;\n+                if (k == -1) {\n+                    return 0.5*(x - e) - 0.5;\n+                }\n+                if (k == 1) {\n+                    if (x < -0.25) {\n+                        return -2.0*(e - (x + 0.5));\n+                    } else {\n+                        return one + 2.0*(x - e);\n+                    }\n+                }\n+                if (k <= -2 || k > 56) {   \/\/ suffice to return exp(x) - 1\n+                    y = one - (e - x);\n+                    y = __HI(y, __HI(y) + (k << 20));     \/\/ add k to y's exponent\n+                    return y - one;\n+                }\n+                t = one;\n+                if (k < 20) {\n+                    t = __HI(t, 0x3ff0_0000 - (0x2_00000 >> k));  \/\/ t = 1-2^-k\n+                    y = t - ( e - x);\n+                    y = __HI(y, __HI(y) + (k << 20));     \/\/ add k to y's exponent\n+                } else {\n+                    t = __HI(t, ((0x3ff - k) << 20));     \/\/ 2^-k\n+                    y = x - (e + t);\n+                    y += one;\n+                    y = __HI(y, __HI(y) + (k << 20));     \/\/ add k to y's exponent\n+                }\n+            }\n+            return y;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/FdLibm.java","additions":209,"deletions":0,"binary":false,"changes":209,"status":"modified"},{"patch":"@@ -2096,1 +2096,3 @@\n-    public static native double expm1(double x);\n+    public static double expm1(double x) {\n+        return FdLibm.Expm1.compute(x);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StrictMath.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1386,18 +1386,11 @@\n-        \/\/ permission if applicable. NOTE: cannot use lambda for\n-        \/\/ remappingFunction parameter until JDK-8076596 is fixed.\n-        perms.merge(sp.getName(), sp,\n-            new java.util.function.BiFunction<>() {\n-                @Override\n-                public SocketPermission apply(SocketPermission existingVal,\n-                                              SocketPermission newVal) {\n-                    int oldMask = existingVal.getMask();\n-                    int newMask = newVal.getMask();\n-                    if (oldMask != newMask) {\n-                        int effective = oldMask | newMask;\n-                        if (effective == newMask) {\n-                            return newVal;\n-                        }\n-                        if (effective != oldMask) {\n-                            return new SocketPermission(sp.getName(),\n-                                                        effective);\n-                        }\n+        \/\/ permission if applicable.\n+        perms.merge(sp.getName(), sp, (existingVal, newVal) -> {\n+                int oldMask = existingVal.getMask();\n+                int newMask = newVal.getMask();\n+                if (oldMask != newMask) {\n+                    int effective = oldMask | newMask;\n+                    if (effective == newMask) {\n+                        return newVal;\n+                    }\n+                    if (effective != oldMask) {\n+                        return new SocketPermission(sp.getName(), effective);\n@@ -1405,1 +1398,0 @@\n-                    return existingVal;\n@@ -1407,0 +1399,1 @@\n+                return existingVal;\n","filename":"src\/java.base\/share\/classes\/java\/net\/SocketPermission.java","additions":13,"deletions":20,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-    private String input;\n+    private final String input;\n@@ -53,1 +53,1 @@\n-    private int index;\n+    private final int index;\n","filename":"src\/java.base\/share\/classes\/java\/net\/URISyntaxException.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -208,1 +208,9 @@\n-            return super.clone();\n+            MessageDigestSpi o = (MessageDigestSpi)super.clone();\n+            if (o.tempArray != null) {\n+                \/\/ New byte arrays are allocated when the ByteBuffer argument\n+                \/\/ to engineUpdate is not backed by a byte array.\n+                \/\/ Here, the newly allocated byte array must also be cloned\n+                \/\/ to prevent threads from sharing the same memory.\n+                o.tempArray = tempArray.clone();\n+            }\n+            return o;\n","filename":"src\/java.base\/share\/classes\/java\/security\/MessageDigestSpi.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,16 +82,9 @@\n-        \/\/ Add permission to map. NOTE: cannot use lambda for\n-        \/\/ remappingFunction parameter until JDK-8076596 is fixed.\n-        perms.compute(unresolvedPermission.getName(),\n-            new java.util.function.BiFunction<>() {\n-                @Override\n-                public List<UnresolvedPermission> apply(String key,\n-                                        List<UnresolvedPermission> oldValue) {\n-                    if (oldValue == null) {\n-                        List<UnresolvedPermission> v =\n-                            new CopyOnWriteArrayList<>();\n-                        v.add(unresolvedPermission);\n-                        return v;\n-                    } else {\n-                        oldValue.add(unresolvedPermission);\n-                        return oldValue;\n-                    }\n+        \/\/ Add permission to map.\n+        perms.compute(unresolvedPermission.getName(), (key, oldValue) -> {\n+                if (oldValue == null) {\n+                    List<UnresolvedPermission> v = new CopyOnWriteArrayList<>();\n+                    v.add(unresolvedPermission);\n+                    return v;\n+                } else {\n+                    oldValue.add(unresolvedPermission);\n+                    return oldValue;\n","filename":"src\/java.base\/share\/classes\/java\/security\/UnresolvedPermissionCollection.java","additions":10,"deletions":17,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -472,18 +472,11 @@\n-        \/\/ permission if applicable. NOTE: cannot use lambda for\n-        \/\/ remappingFunction parameter until JDK-8076596 is fixed.\n-        perms.merge(propName, pp,\n-            new java.util.function.BiFunction<>() {\n-                @Override\n-                public PropertyPermission apply(PropertyPermission existingVal,\n-                                                PropertyPermission newVal) {\n-\n-                    int oldMask = existingVal.getMask();\n-                    int newMask = newVal.getMask();\n-                    if (oldMask != newMask) {\n-                        int effective = oldMask | newMask;\n-                        if (effective == newMask) {\n-                            return newVal;\n-                        }\n-                        if (effective != oldMask) {\n-                            return new PropertyPermission(propName, effective);\n-                        }\n+        \/\/ permission if applicable.\n+        perms.merge(propName, pp, (existingVal, newVal) -> {\n+                int oldMask = existingVal.getMask();\n+                int newMask = newVal.getMask();\n+                if (oldMask != newMask) {\n+                    int effective = oldMask | newMask;\n+                    if (effective == newMask) {\n+                        return newVal;\n+                    }\n+                    if (effective != oldMask) {\n+                        return new PropertyPermission(propName, effective);\n@@ -491,1 +484,0 @@\n-                    return existingVal;\n@@ -493,0 +485,1 @@\n+                return existingVal;\n","filename":"src\/java.base\/share\/classes\/java\/util\/PropertyPermission.java","additions":13,"deletions":20,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2865,1 +2865,1 @@\n-            boolean waiting = false;\n+            Thread current = Thread.currentThread(), w;\n@@ -2869,2 +2869,2 @@\n-                        if (waiting)\n-                            waiter = null;\n+                        if (waiter == current)\n+                            U.compareAndSetReference(this, WAITERTHREAD, current, null);\n@@ -2874,7 +2874,5 @@\n-                else if ((s & WAITER) == 0) {\n-                    if (U.compareAndSetInt(this, LOCKSTATE, s, s | WAITER)) {\n-                        waiting = true;\n-                        waiter = Thread.currentThread();\n-                    }\n-                }\n-                else if (waiting)\n+                else if ((s & WAITER) == 0)\n+                    U.compareAndSetInt(this, LOCKSTATE, s, s | WAITER);\n+                else if ((w = waiter) == null)\n+                    U.compareAndSetReference(this, WAITERTHREAD, null, current);\n+                else if (w == current)\n@@ -3299,0 +3297,2 @@\n+        private static final long WAITERTHREAD\n+            = U.objectFieldOffset(TreeBin.class, \"waiter\");\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ConcurrentHashMap.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -238,1 +238,5 @@\n-        return getVerificationResult(p) == null;\n+        Exception e = getVerificationResult(p);\n+        if (debug != null && e != null) {\n+            debug.println(\"Provider verification result: \" + e);\n+        }\n+        return e == null;\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/JceSecurity.java.template","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -213,0 +213,17 @@\n+    \/* ============================================================================ *\/\n+    public interface IndexPartiallyInUpperRangeOperation<E,\n+                                                         M extends VectorMask<E>> {\n+        M apply(long offset, long limit);\n+    }\n+\n+    @IntrinsicCandidate\n+    public static\n+    <E,\n+     M extends VectorMask<E>>\n+    M indexPartiallyInUpperRange(Class<? extends M> mClass, Class<E> eClass,\n+                                 int length, long offset, long limit,\n+                                 IndexPartiallyInUpperRangeOperation<E, M> defaultImpl) {\n+        assert isNonCapturingLambda(defaultImpl) : defaultImpl;\n+        return defaultImpl.apply(offset, limit);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -600,10 +600,10 @@\n-                        stdAlgName = stdAlgName.toUpperCase(Locale.ENGLISH);\n-                    }\n-                    \/\/ add the name->oid and oid->name mappings if none exists\n-                    if (KnownOIDs.findMatch(stdAlgName) == null) {\n-                        \/\/ not override earlier entries if it exists\n-                        t.putIfAbsent(stdAlgName, ostr);\n-                    }\n-                    if (KnownOIDs.findMatch(ostr) == null) {\n-                        \/\/ not override earlier entries if it exists\n-                        t.putIfAbsent(ostr, stdAlgName);\n+                        String upperStdAlgName = stdAlgName.toUpperCase(Locale.ENGLISH);\n+                        \/\/ add the name->oid and oid->name mappings if none exists\n+                        if (KnownOIDs.findMatch(upperStdAlgName) == null) {\n+                            \/\/ do not override earlier entries if it exists\n+                            t.putIfAbsent(upperStdAlgName, ostr);\n+                        }\n+                        if (KnownOIDs.findMatch(ostr) == null) {\n+                            \/\/ do not override earlier entries if it exists\n+                            t.putIfAbsent(ostr, stdAlgName);\n+                        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/AlgorithmId.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -946,4 +946,10 @@\n-# XML Signatures that violate any of these constraints will fail. The\n-# mode is enforced by default. The mode can be disabled by setting the\n-# property \"org.jcp.xml.dsig.secureValidation\" to Boolean.FALSE with the\n-# javax.xml.crypto.XMLCryptoContext.setProperty() method.\n+# XML Signatures that violate any of these constraints will fail.\n+# The mode can be enabled or disabled by setting the property\n+# \"org.jcp.xml.dsig.secureValidation\" to Boolean.TRUE or Boolean.FALSE with\n+# the javax.xml.crypto.XMLCryptoContext.setProperty() method, or by setting\n+# the system property \"org.jcp.xml.dsig.secureValidation\" to \"true\" or\n+# \"false\". Any other value for the system property is also treated as \"false\".\n+# If the system property is set, it supersedes the XMLCryptoContext property\n+# value.\n+#\n+# The secure validation mode is enabled by default.\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,29 @@\n+Owner: CN=Certigna, O=Dhimyotis, C=FR\n+Issuer: CN=Certigna, O=Dhimyotis, C=FR\n+Serial number: fedce3010fc948ff\n+Valid from: Fri Jun 29 15:13:05 GMT 2007 until: Tue Jun 29 15:13:05 GMT 2027\n+Signature algorithm name: SHA1withRSA\n+Subject Public Key Algorithm: 2048-bit RSA key\n+Version: 3\n+-----BEGIN CERTIFICATE-----\n+MIIDqDCCApCgAwIBAgIJAP7c4wEPyUj\/MA0GCSqGSIb3DQEBBQUAMDQxCzAJBgNV\n+BAYTAkZSMRIwEAYDVQQKDAlEaGlteW90aXMxETAPBgNVBAMMCENlcnRpZ25hMB4X\n+DTA3MDYyOTE1MTMwNVoXDTI3MDYyOTE1MTMwNVowNDELMAkGA1UEBhMCRlIxEjAQ\n+BgNVBAoMCURoaW15b3RpczERMA8GA1UEAwwIQ2VydGlnbmEwggEiMA0GCSqGSIb3\n+DQEBAQUAA4IBDwAwggEKAoIBAQDIaPHJ1tazNHUmgh7stL7qXOEm7RFHYeGifBZ4\n+QCHkYJ5ayGPhxLGWkv8YbWkj4Sti993iNi+RB7lIzw7sebYs5zRLcAglozyHGxny\n+gQcPOJAZ0xH+hrTy0V4eHpbNgGzOOzGTtvKg0KmVEn2lmsxryIRWijOp5yIVUxbw\n+zBfsV1\/pogqYCd7jX5xv3EjjhQsVWqa6n6xI4wmy9\/Qy3l40vhx4XUJbzg4ij02Q\n+130yGLMLLGq\/jj8UEYkgDncUtT2UCIf3JR7VsmAA7G8qKCVuKj4YYxclPz5EIBb2\n+JsglrgVKtOdjLPOMFlN+XPsRGgjBRmKfIrjxwo1p3Po6WAbfAgMBAAGjgbwwgbkw\n+DwYDVR0TAQH\/BAUwAwEB\/zAdBgNVHQ4EFgQUGu3+QTmQtCRZvgHyUtVF9lo53BEw\n+ZAYDVR0jBF0wW4AUGu3+QTmQtCRZvgHyUtVF9lo53BGhOKQ2MDQxCzAJBgNVBAYT\n+AkZSMRIwEAYDVQQKDAlEaGlteW90aXMxETAPBgNVBAMMCENlcnRpZ25hggkA\/tzj\n+AQ\/JSP8wDgYDVR0PAQH\/BAQDAgEGMBEGCWCGSAGG+EIBAQQEAwIABzANBgkqhkiG\n+9w0BAQUFAAOCAQEAhQMeknH2Qq\/ho2Ge6\/PAD\/Kl1NqV5ta+aDY9fm4fTIrv0Q8h\n+bV6lUmPOEvjvKtpv6zf+EwLHyzs+ImvaYS5\/1HI93TDhHkxAGYwP15zRgzB7mFnc\n+fca5DClMoTOi62c6ZYTTluLtdkVwj7Ur3vkj1kluPBS1xp81HlDQwY9qcEQCYsuu\n+HWhBp6pX6FOqB9IG9tUUBguRA3UsbHK1YZWaDYu5Def131TN3ubY1gkIl2PlwS6w\n+t0QmwCbAr1UwnjvVNioZBPRcHv\/PLLf\/0P2HQBHVESO7SMAhqaQoLf0V+LBOK\/Qw\n+WyH8EZE0vkHve52Xdf+XlcCWWC\/qu0bXu+TZLg==\n+-----END CERTIFICATE-----\n","filename":"src\/java.base\/share\/data\/cacerts\/certignaca","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,0 +95,14 @@\n+        \/\/ if a prefix is present, remove it and note the expected path type\n+        final WindowsPathType expectedType;\n+        if (input.startsWith(\"\\\\\\\\?\\\\\")) {\n+            if (input.startsWith(\"UNC\\\\\", 4)) {\n+                expectedType = WindowsPathType.UNC;\n+                input = \"\\\\\\\\\" + input.substring(8);\n+            } else {\n+                expectedType = WindowsPathType.ABSOLUTE;\n+                input = input.substring(4);\n+            }\n+        } else {\n+            expectedType = null;\n+        }\n+\n@@ -150,0 +164,8 @@\n+        if (expectedType != null && type != expectedType) {\n+            if (expectedType == WindowsPathType.ABSOLUTE) { \/\/ long path prefix\n+                throw new InvalidPathException(input, \"Long path prefix can only be used with an absolute path\");\n+            } else if (expectedType == WindowsPathType.UNC) { \/\/ long UNC path prefix\n+                throw new InvalidPathException(input, \"Long UNC path prefix can only be used with a UNC path\");\n+            }\n+        }\n+\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsPathParser.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2268,1 +2268,2 @@\n-     * @see #setSize\n+     * @see #setSize(int, int)\n+     * @see #getSize\n@@ -8565,1 +8566,1 @@\n-     * @see #removePropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)\n+     * @see #removePropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)\n@@ -8629,1 +8630,1 @@\n-     * @see #addPropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)\n+     * @see #addPropertyChangeListener(java.beans.PropertyChangeListener)\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Component.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1700,1 +1700,1 @@\n-             * @see #setBackground\n+             * @see #getBackground\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/List.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -421,1 +421,0 @@\n-     * @see         java.awt.MediaTracker#waitForAll(long)\n@@ -530,1 +529,1 @@\n-     * @see         java.awt.MediaTracker#checkID(int, boolean)\n+     * @see         java.awt.MediaTracker#checkID(int)\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/MediaTracker.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-     * @see #setBackground\n+     * @see #getBackground\n","filename":"src\/java.desktop\/share\/classes\/javax\/accessibility\/AccessibleComponent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -291,1 +291,1 @@\n-     * @see #VERTICAL\n+     * @see #HORIZONTAL\n@@ -303,1 +303,1 @@\n-     * @see #HORIZONTAL\n+     * @see #VERTICAL\n","filename":"src\/java.desktop\/share\/classes\/javax\/accessibility\/AccessibleState.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -158,1 +158,1 @@\n-     * @see #isEditable\n+     * @see #isEditable()\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JComboBox.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -720,1 +720,1 @@\n-     * @see #setFixedCellWidth\n+     * @see #getFixedCellWidth\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JList.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -545,1 +545,1 @@\n-     * @see #setLabel\n+     * @see #getLabel\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JPopupMenu.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import java.util.ArrayList;\n@@ -28,1 +29,0 @@\n-import java.util.LinkedList;\n@@ -73,1 +73,1 @@\n-            LinkedList<Component> aAncestory = new LinkedList<Component>();\n+            ArrayList<Component> aAncestory = new ArrayList<>();\n@@ -86,1 +86,1 @@\n-            LinkedList<Component> bAncestory = new LinkedList<Component>();\n+            ArrayList<Component> bAncestory = new ArrayList<>();\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/LayoutComparator.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2246,11 +2246,7 @@\n-            \/* Activate a JInternalFrame if necessary. *\/\n-            if (eventID == MouseEvent.MOUSE_PRESSED) {\n-                Object object = ev.getSource();\n-                if (!(object instanceof Component)) {\n-                    return;\n-                }\n-                Component component = (Component)object;\n-                if (component != null) {\n-                    Component parent = component;\n-                    while (parent != null && !(parent instanceof Window)) {\n-                        if (parent instanceof JInternalFrame) {\n+\n+            \/\/ Activate a JInternalFrame if necessary.\n+            if (eventID == MouseEvent.MOUSE_PRESSED\n+                    && ev.getSource() instanceof Component parent) {\n+                while (parent != null && !(parent instanceof Window)) {\n+                    if (parent instanceof JInternalFrame internalFrame) {\n+                        try {\n@@ -2258,2 +2254,2 @@\n-                            try { ((JInternalFrame)parent).setSelected(true); }\n-                            catch (PropertyVetoException e1) { }\n+                            internalFrame.setSelected(true);\n+                        } catch (PropertyVetoException ignored) {\n@@ -2261,1 +2257,0 @@\n-                        parent = parent.getParent();\n@@ -2263,0 +2258,2 @@\n+\n+                    parent = parent.getParent();\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicLookAndFeel.java","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -238,6 +238,5 @@\n-    \/**\n-     * The class represents the border of a {@code JInternalFrame}.\n-     *\/\n-    @SuppressWarnings(\"serial\") \/\/ Superclass is not serializable across versions\n-    public static class InternalFrameBorder extends AbstractBorder implements UIResource {\n-        private static final int CORNER = 14;\n+    @SuppressWarnings(\"serial\")\n+    private abstract static sealed class AbstractMetalWindowBorder\n+            extends AbstractBorder\n+            implements UIResource\n+            permits FrameBorder, DialogBorder, InternalFrameBorderImpl {\n@@ -245,4 +244,3 @@\n-        \/**\n-         * Constructs a {@code InternalFrameBorder}.\n-         *\/\n-        public InternalFrameBorder() {}\n+        protected Color background;\n+        protected Color highlight;\n+        protected Color shadow;\n@@ -250,2 +248,5 @@\n-        public void paintBorder(Component c, Graphics g, int x, int y,\n-                                int w, int h) {\n+        private static final int CORNER = 14;\n+\n+        @Override\n+        public final void paintBorder(Component c, Graphics g,\n+                                      int x, int y, int w, int h) {\n@@ -257,6 +258,3 @@\n-        private void paintUnscaledBorder(Component c, Graphics g,\n-                                         int width, int height,\n-                                         double scaleFactor) {\n-            Color background;\n-            Color highlight;\n-            Color shadow;\n+        protected abstract boolean isActive(Component c);\n+\n+        protected abstract boolean isResizable(Component c);\n@@ -264,1 +262,2 @@\n-            if (c instanceof JInternalFrame && ((JInternalFrame)c).isSelected()) {\n+        protected void updateColors(Component c) {\n+            if (isActive(c)) {\n@@ -273,0 +272,1 @@\n+        }\n@@ -274,2 +274,4 @@\n-            \/\/ scaled border\n-            int thickness = (int) Math.ceil(4 * scaleFactor);\n+        private void paintUnscaledBorder(Component c, Graphics g,\n+                                         int width, int height,\n+                                         double scaleFactor) {\n+            updateColors(c);\n@@ -277,0 +279,2 @@\n+            \/\/ scaled thickness\n+            int thickness = (int) Math.ceil(4 * scaleFactor);\n@@ -283,3 +287,3 @@\n-            if (c instanceof JInternalFrame && ((JInternalFrame)c).isResizable()) {\n-                \/\/ midpoint at which highlight & shadow lines\n-                \/\/ are positioned on the border\n+            if (isResizable(c)) {\n+                \/\/midpoint at which highlight & shadow lines\n+                \/\/are positioned on the border\n@@ -287,4 +291,11 @@\n-                int stkWidth = clipRound(scaleFactor);\n-                int offset = (((scaleFactor - stkWidth) >= 0) && ((stkWidth % 2) != 0)) ? 1 : 0;\n-                int loc1 = thickness % 2 == 0 ? midPoint + stkWidth \/ 2 - stkWidth : midPoint;\n-                int loc2 = thickness % 2 == 0 ? midPoint + stkWidth \/ 2 : midPoint + stkWidth;\n+                int strokeWidth = clipRound(scaleFactor);\n+                int offset = (((scaleFactor - strokeWidth) >= 0)\n+                              && ((strokeWidth % 2) != 0)) ? 1 : 0;\n+\n+                int loc1 = (thickness % 2 == 0)\n+                           ? midPoint + strokeWidth \/ 2 - strokeWidth\n+                           : midPoint;\n+                int loc2 = (thickness % 2 == 0)\n+                           ? midPoint + strokeWidth \/ 2\n+                           : midPoint + strokeWidth;\n+\n@@ -295,1 +306,1 @@\n-                    ((Graphics2D) g).setStroke(new BasicStroke((float) stkWidth));\n+                    ((Graphics2D) g).setStroke(new BasicStroke((float) strokeWidth));\n@@ -318,1 +329,2 @@\n-        public Insets getBorderInsets(Component c, Insets newInsets) {\n+        @Override\n+        public final Insets getBorderInsets(Component c, Insets newInsets) {\n@@ -324,0 +336,16 @@\n+    @SuppressWarnings(\"serial\")\n+    private static final class InternalFrameBorderImpl extends AbstractMetalWindowBorder {\n+\n+        @Override\n+        protected boolean isActive(Component c) {\n+            return (c instanceof JInternalFrame\n+                    && ((JInternalFrame)c).isSelected());\n+        }\n+\n+        @Override\n+        protected boolean isResizable(Component c) {\n+            return ((c instanceof JInternalFrame\n+                    && ((JInternalFrame) c).isResizable()));\n+        }\n+    }\n+\n@@ -325,2 +353,1 @@\n-     * Border for a Frame.\n-     * @since 1.4\n+     * The class represents the border of a {@code JInternalFrame}.\n@@ -329,9 +356,1 @@\n-    static class FrameBorder extends AbstractBorder implements UIResource {\n-        private static final int corner = 14;\n-\n-        public void paintBorder(Component c, Graphics g, int x, int y,\n-            int w, int h) {\n-\n-            Color background;\n-            Color highlight;\n-            Color shadow;\n+    public static class InternalFrameBorder extends AbstractBorder implements UIResource {\n@@ -339,10 +358,1 @@\n-            Window window = SwingUtilities.getWindowAncestor(c);\n-            if (window != null && window.isActive()) {\n-                background = MetalLookAndFeel.getPrimaryControlDarkShadow();\n-                highlight = MetalLookAndFeel.getPrimaryControlShadow();\n-                shadow = MetalLookAndFeel.getPrimaryControlInfo();\n-            } else {\n-                background = MetalLookAndFeel.getControlDarkShadow();\n-                highlight = MetalLookAndFeel.getControlShadow();\n-                shadow = MetalLookAndFeel.getControlInfo();\n-            }\n+        private final InternalFrameBorderImpl border;\n@@ -350,6 +360,6 @@\n-            g.setColor(background);\n-            \/\/ Draw outermost lines\n-            g.drawLine( x+1, y+0, x+w-2, y+0);\n-            g.drawLine( x+0, y+1, x+0, y +h-2);\n-            g.drawLine( x+w-1, y+1, x+w-1, y+h-2);\n-            g.drawLine( x+1, y+h-1, x+w-2, y+h-1);\n+        \/**\n+         * Constructs a {@code InternalFrameBorder}.\n+         *\/\n+        public InternalFrameBorder() {\n+            border = new InternalFrameBorderImpl();\n+        }\n@@ -357,4 +367,5 @@\n-            \/\/ Draw the bulk of the border\n-            for (int i = 1; i < 5; i++) {\n-                g.drawRect(x+i,y+i,w-(i*2)-1, h-(i*2)-1);\n-            }\n+        @Override\n+        public void paintBorder(Component c, Graphics g, int x, int y,\n+                                int w, int h) {\n+            border.paintBorder(c, g, x, y, w, h);\n+        }\n@@ -362,7 +373,5 @@\n-            if ((window instanceof Frame) && ((Frame) window).isResizable()) {\n-                g.setColor(highlight);\n-                \/\/ Draw the Long highlight lines\n-                g.drawLine( corner+1, 3, w-corner, 3);\n-                g.drawLine( 3, corner+1, 3, h-corner);\n-                g.drawLine( w-2, corner+1, w-2, h-corner);\n-                g.drawLine( corner+1, h-2, w-corner, h-2);\n+        @Override\n+        public Insets getBorderInsets(Component c, Insets newInsets) {\n+            return border.getBorderInsets(c, newInsets);\n+        }\n+    }\n@@ -370,7 +379,6 @@\n-                g.setColor(shadow);\n-                \/\/ Draw the Long shadow lines\n-                g.drawLine( corner, 2, w-corner-1, 2);\n-                g.drawLine( 2, corner, 2, h-corner-1);\n-                g.drawLine( w-3, corner, w-3, h-corner-1);\n-                g.drawLine( corner, h-3, w-corner-1, h-3);\n-            }\n+    \/**\n+     * Border for a Frame.\n+     * @since 1.4\n+     *\/\n+    @SuppressWarnings(\"serial\") \/\/ Superclass is not serializable across versions\n+    static final class FrameBorder extends AbstractMetalWindowBorder implements UIResource {\n@@ -378,0 +386,4 @@\n+        @Override\n+        protected boolean isActive(Component c) {\n+            Window window = SwingUtilities.getWindowAncestor(c);\n+            return (window != null && window.isActive());\n@@ -380,4 +392,5 @@\n-        public Insets getBorderInsets(Component c, Insets newInsets)\n-        {\n-            newInsets.set(5, 5, 5, 5);\n-            return newInsets;\n+        @Override\n+        protected boolean isResizable(Component c) {\n+            Window window = SwingUtilities.getWindowAncestor(c);\n+            return ((window instanceof Frame)\n+                    && ((Frame) window).isResizable());\n@@ -392,3 +405,4 @@\n-    static class DialogBorder extends AbstractBorder implements UIResource\n-    {\n-        private static final int corner = 14;\n+    static sealed class DialogBorder\n+            extends AbstractMetalWindowBorder\n+            implements UIResource\n+            permits ErrorDialogBorder, QuestionDialogBorder, WarningDialogBorder {\n@@ -396,2 +410,1 @@\n-        protected Color getActiveBackground()\n-        {\n+        protected Color getActiveBackground() {\n@@ -401,2 +414,1 @@\n-        protected Color getActiveHighlight()\n-        {\n+        protected final Color getActiveHighlight() {\n@@ -406,2 +418,1 @@\n-        protected Color getActiveShadow()\n-        {\n+        protected final Color getActiveShadow() {\n@@ -411,2 +422,1 @@\n-        protected Color getInactiveBackground()\n-        {\n+        protected final Color getInactiveBackground() {\n@@ -416,2 +426,1 @@\n-        protected Color getInactiveHighlight()\n-        {\n+        protected final Color getInactiveHighlight() {\n@@ -421,2 +430,1 @@\n-        protected Color getInactiveShadow()\n-        {\n+        protected final Color getInactiveShadow() {\n@@ -426,8 +434,3 @@\n-        public void paintBorder(Component c, Graphics g, int x, int y, int w, int h)\n-        {\n-            Color background;\n-            Color highlight;\n-            Color shadow;\n-\n-            Window window = SwingUtilities.getWindowAncestor(c);\n-            if (window != null && window.isActive()) {\n+        @Override\n+        protected final void updateColors(Component c) {\n+            if (isActive(c)) {\n@@ -442,0 +445,1 @@\n+        }\n@@ -443,29 +447,4 @@\n-            g.setColor(background);\n-            \/\/ Draw outermost lines\n-            g.drawLine( x + 1, y + 0, x + w-2, y + 0);\n-            g.drawLine( x + 0, y + 1, x + 0, y + h - 2);\n-            g.drawLine( x + w - 1, y + 1, x + w - 1, y + h - 2);\n-            g.drawLine( x + 1, y + h - 1, x + w - 2, y + h - 1);\n-\n-            \/\/ Draw the bulk of the border\n-            for (int i = 1; i < 5; i++) {\n-                g.drawRect(x+i,y+i,w-(i*2)-1, h-(i*2)-1);\n-            }\n-\n-\n-            if ((window instanceof Dialog) && ((Dialog) window).isResizable()) {\n-                g.setColor(highlight);\n-                \/\/ Draw the Long highlight lines\n-                g.drawLine( corner+1, 3, w-corner, 3);\n-                g.drawLine( 3, corner+1, 3, h-corner);\n-                g.drawLine( w-2, corner+1, w-2, h-corner);\n-                g.drawLine( corner+1, h-2, w-corner, h-2);\n-\n-                g.setColor(shadow);\n-                \/\/ Draw the Long shadow lines\n-                g.drawLine( corner, 2, w-corner-1, 2);\n-                g.drawLine( 2, corner, 2, h-corner-1);\n-                g.drawLine( w-3, corner, w-3, h-corner-1);\n-                g.drawLine( corner, h-3, w-corner-1, h-3);\n-            }\n-\n+        @Override\n+        protected final boolean isActive(Component c) {\n+            Window window = SwingUtilities.getWindowAncestor(c);\n+            return (window != null && window.isActive());\n@@ -474,4 +453,5 @@\n-        public Insets getBorderInsets(Component c, Insets newInsets)\n-        {\n-            newInsets.set(5, 5, 5, 5);\n-            return newInsets;\n+        @Override\n+        protected final boolean isResizable(Component c) {\n+            Window window = SwingUtilities.getWindowAncestor(c);\n+            return ((window instanceof Dialog)\n+                    && ((Dialog) window).isResizable());\n@@ -486,1 +466,1 @@\n-    static class ErrorDialogBorder extends DialogBorder implements UIResource\n+    static final class ErrorDialogBorder extends DialogBorder implements UIResource\n@@ -500,1 +480,1 @@\n-    static class QuestionDialogBorder extends DialogBorder implements UIResource\n+    static final class QuestionDialogBorder extends DialogBorder implements UIResource\n@@ -513,1 +493,1 @@\n-    static class WarningDialogBorder extends DialogBorder implements UIResource\n+    static final class WarningDialogBorder extends DialogBorder implements UIResource\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/metal\/MetalBorders.java","additions":118,"deletions":138,"binary":false,"changes":256,"status":"modified"},{"patch":"@@ -618,0 +618,14 @@\n+     * <p>\n+     * Whilst this API may be safe for loading local resources that are\n+     * delivered with a {@code LookAndFeel} or application, and so have an\n+     * equal level of trust with application code, using it to load from\n+     * remote resources, particularly any which may have a lower level of\n+     * trust, is strongly discouraged.\n+     * The alternative mechanisms to load styles from an {@code InputStream}\n+     * {@linkplain #load(InputStream, Class)}\n+     * using resources co-located with the application or by providing a\n+     * {@code SynthStyleFactory} to\n+     * {@linkplain #setStyleFactory setStyleFactory(SynthStyleFactory)}\n+     * are preferred.\n+     * Consequently this method is deprecated and will be removed in a future\n+     * release.\n@@ -625,0 +639,2 @@\n+     * @deprecated Use {@link #load(InputStream, Class)} or\n+     * {@link #setStyleFactory setStyleFactory(SynthStyleFactory)} instead\n@@ -626,0 +642,1 @@\n+    @Deprecated(since = \"21\", forRemoval = true)\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/SynthLookAndFeel.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -73,0 +73,2 @@\n+    <\/p>\n+    <p>\n@@ -97,0 +99,5 @@\n+    <p>Note: Synth's file format allows for the definition of code to be executed.\n+       Loading any code from a remote location should be used only\n+       with extreme caution from a trusted source over a secure connection.\n+       It is strongly discouraged for an application or a LookAndFeel to do so.\n+    <\/p>\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/doc-files\/synthFileFormat.html","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -520,1 +520,1 @@\n-     *  @see #setColumnCount\n+     *  @see #setRowCount\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/table\/DefaultTableModel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1053,1 +1053,1 @@\n-            if (component.isEditable()) {\n+            if (component != null && component.isEditable()) {\n@@ -1068,1 +1068,1 @@\n-            if (component.isEditable() && isBlinkRateSaved) {\n+            if ((component == null || component.isEditable()) && isBlinkRateSaved) {\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/DefaultCaret.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import java.util.Arrays;\n@@ -1049,1 +1048,0 @@\n-            Arrays.fill(spaceMap, 0);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/ParagraphView.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -352,1 +352,0 @@\n-     * @see View#getViewCount\n@@ -701,1 +700,2 @@\n-     * @see View#insertUpdate\n+     * @see View#removeUpdate\n+     * @see View#changedUpdate\n@@ -742,1 +742,2 @@\n-     * @see View#removeUpdate\n+     * @see View#insertUpdate\n+     * @see View#changedUpdate\n@@ -783,1 +784,2 @@\n-     * @see View#changedUpdate\n+     * @see View#insertUpdate\n+     * @see View#removeUpdate\n@@ -805,1 +807,0 @@\n-     * @see View#getDocument\n@@ -816,1 +817,1 @@\n-     * @see View#getStartOffset\n+     * @see View#getEndOffset\n@@ -827,1 +828,1 @@\n-     * @see View#getEndOffset\n+     * @see View#getStartOffset\n@@ -839,1 +840,0 @@\n-     * @see View#getElement\n@@ -1342,1 +1342,1 @@\n-     * @see View#modelToView\n+     * @see View#viewToModel\n@@ -1360,1 +1360,1 @@\n-     * @see View#viewToModel\n+     * @see View#modelToView\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/View.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1016,3 +1016,0 @@\n-            for (int i = 0; i < columnRequirements.length; i++) {\n-                adjustmentWeights[i] = 0;\n-            }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/TableView.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+\n@@ -38,1 +39,2 @@\n-import static sun.java2d.pipe.hw.AccelSurface.*;\n+\n+import static sun.java2d.pipe.hw.AccelSurface.UNDEFINED;\n@@ -310,0 +312,3 @@\n+        \/\/ We're asked to restore contents by the accelerated surface, which\n+        \/\/ means that it had been lost\n+        acceleratedSurfaceLost();\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/VolatileSurfaceManager.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -43,2 +43,0 @@\n-import static sun.java2d.pipe.hw.AccelSurface.*;\n-import static sun.java2d.d3d.D3DContext.D3DContextCaps.*;\n@@ -47,0 +45,6 @@\n+import static sun.java2d.d3d.D3DContext.D3DContextCaps.CAPS_RT_PLAIN_ALPHA;\n+import static sun.java2d.d3d.D3DContext.D3DContextCaps.CAPS_RT_TEXTURE_ALPHA;\n+import static sun.java2d.pipe.hw.AccelSurface.RT_TEXTURE;\n+import static sun.java2d.pipe.hw.AccelSurface.TEXTURE;\n+import static sun.java2d.pipe.hw.AccelSurface.UNDEFINED;\n+\n@@ -163,10 +167,0 @@\n-    \/**\n-     * We're asked to restore contents by the accelerated surface, which means\n-     * that it had been lost.\n-     *\/\n-    @Override\n-    public SurfaceData restoreContents() {\n-        acceleratedSurfaceLost();\n-        return super.restoreContents();\n-    }\n-\n","filename":"src\/java.desktop\/windows\/classes\/sun\/java2d\/d3d\/D3DVolatileSurfaceManager.java","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -214,1 +214,1 @@\n-#endif _D3DRESOURCEMANAGER_H_\n+#endif \/\/ _D3DRESOURCEMANAGER_H_\n","filename":"src\/java.desktop\/windows\/native\/libawt\/java2d\/d3d\/D3DResourceManager.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -262,2 +262,2 @@\n-                \/\/ ^\n-                \/\/  \\ case -> inverse\n+                \/* ^\n+                    \\ case -> inverse *\/\n@@ -276,2 +276,2 @@\n-                \/\/ \\      ^\n-                \/\/  v or \/  - leave as is\n+                \/* \\      ^\n+                    v or \/  - leave as is *\/\n@@ -285,2 +285,2 @@\n-                \/\/ \\\n-                \/\/  v\n+                \/* \\\n+                    v *\/\n","filename":"src\/java.desktop\/windows\/native\/libawt\/java2d\/d3d\/D3DVertexCacher.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -259,1 +259,1 @@\n-#endif _WIN32SURFACEDATA_H_\n+#endif \/\/ _WIN32SURFACEDATA_H_\n","filename":"src\/java.desktop\/windows\/native\/libawt\/java2d\/windows\/GDIWindowSurfaceData.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-#endif WINDOWSFLAGS_H\n+#endif \/\/ WINDOWSFLAGS_H\n","filename":"src\/java.desktop\/windows\/native\/libawt\/java2d\/windows\/WindowsFlags.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-#endif _DEVICES_H_\n+#endif \/\/ _DEVICES_H_\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/Devices.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -274,1 +274,1 @@\n-#endif _AWT_CUSTOMPALETTEDEF_H\n+#endif \/\/ _AWT_CUSTOMPALETTEDEF_H\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_CustomPaletteDef.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-#endif AWT_PALETTE_H\n+#endif \/\/ AWT_PALETTE_H\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Palette.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -269,1 +269,1 @@\n-#endif DEBUG\n+#endif \/\/ DEBUG\n@@ -631,1 +631,1 @@\n-        \/\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n+        \/\/*************************************************************************\n@@ -2157,2 +2157,2 @@\n-    pActionChain(NULL), pLastProcessedAction(NULL),\n-    execFunc(NULL), execParam(NULL)\n+    execFunc(NULL), execParam(NULL),\n+    pActionChain(NULL), pLastProcessedAction(NULL)\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Toolkit.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-#endif AWT_WIN32GRAPHICSDEVICE_H\n+#endif \/\/ AWT_WIN32GRAPHICSDEVICE_H\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Win32GraphicsDevice.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -570,17 +570,11 @@\n-        \/\/ permission if applicable. NOTE: cannot use lambda for\n-        \/\/ remappingFunction parameter until JDK-8076596 is fixed.\n-        perms.merge(princName, sp,\n-            new java.util.function.BiFunction<>() {\n-                @Override\n-                public Permission apply(Permission existingVal,\n-                                        Permission newVal) {\n-                    int oldMask = ((ServicePermission) existingVal).getMask();\n-                    int newMask = ((ServicePermission) newVal).getMask();\n-                    if (oldMask != newMask) {\n-                        int effective = oldMask | newMask;\n-                        if (effective == newMask) {\n-                            return newVal;\n-                        }\n-                        if (effective != oldMask) {\n-                            return new ServicePermission(princName, effective);\n-                        }\n+        \/\/ permission if applicable.\n+        perms.merge(princName, sp, (existingVal, newVal) -> {\n+                int oldMask = ((ServicePermission) existingVal).getMask();\n+                int newMask = ((ServicePermission) newVal).getMask();\n+                if (oldMask != newMask) {\n+                    int effective = oldMask | newMask;\n+                    if (effective == newMask) {\n+                        return newVal;\n+                    }\n+                    if (effective != oldMask) {\n+                        return new ServicePermission(princName, effective);\n@@ -588,1 +582,0 @@\n-                    return existingVal;\n@@ -590,0 +583,1 @@\n+                return existingVal;\n","filename":"src\/java.security.jgss\/share\/classes\/javax\/security\/auth\/kerberos\/ServicePermission.java","additions":13,"deletions":19,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -246,1 +246,0 @@\n-        mechContext = null;\n@@ -248,0 +247,4 @@\n+        if (mechContext != null) {\n+            mechContext.dispose();\n+            mechContext = null;\n+        }\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/spnego\/SpNegoContext.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,6 +26,8 @@\n-\/\/ This library is client-side only, and only supports the default credentials.\n-\/\/ It speaks krb5 and SPNEGO. NTLM is excluded from SPNEGO negotiation.\n-\/\/\n-\/\/ This library can be built directly with the following command:\n-\/\/   cl -I %OPENJDK%\\src\\java.security.jgss\\share\\native\\libj2gss\\ sspi.cpp \\\n-\/\/      -link -dll -out:sspi_bridge.dll\n+\/*\n+ * This library is client-side only, and only supports the default credentials.\n+ * It speaks krb5 and SPNEGO. NTLM is excluded from SPNEGO negotiation.\n+ *\n+ * This library can be built directly with the following command:\n+ *   cl -I %OPENJDK%\\src\\java.security.jgss\\share\\native\\libj2gss\\ sspi.cpp \\\n+ *      -link -dll -out:sspi_bridge.dll\n+ *\/\n","filename":"src\/java.security.jgss\/windows\/native\/libsspi_bridge\/sspi.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,0 +61,6 @@\n+ * The mode can be disabled by setting the property to {@code Boolean.FALSE}.\n+ * The mode can also be enabled or disabled by setting the\n+ * {@systemProperty org.jcp.xml.dsig.secureValidation} system property to\n+ * \"true\" or \"false\". Any other value for the system property is also treated\n+ * as \"false\". If the system property is set, it supersedes the\n+ * {@code DOMValidateContext} property value.\n","filename":"src\/java.xml.crypto\/share\/classes\/javax\/xml\/crypto\/dsig\/dom\/DOMValidateContext.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n@@ -42,0 +44,15 @@\n+    private static final com.sun.org.slf4j.internal.Logger LOG =\n+        com.sun.org.slf4j.internal.LoggerFactory.getLogger(Utils.class);\n+    private static final String SECVAL_PROP_NAME =\n+        \"org.jcp.xml.dsig.secureValidation\";\n+    private static final boolean SECVAL_SYSPROP_SET;\n+    private static final boolean SECVAL_SYSPROP;\n+    static {\n+        String sysProp = privilegedGetProperty(SECVAL_PROP_NAME);\n+        SECVAL_SYSPROP_SET = sysProp != null;\n+        SECVAL_SYSPROP = Boolean.parseBoolean(sysProp);\n+        if (SECVAL_SYSPROP_SET && !SECVAL_SYSPROP) {\n+            LOG.warn(\"Secure validation mode disabled\");\n+        }\n+    }\n+\n@@ -111,0 +128,10 @@\n+    @SuppressWarnings(\"removal\")\n+    private static String privilegedGetProperty(String theProp) {\n+        if (System.getSecurityManager() == null) {\n+            return System.getProperty(theProp);\n+        } else {\n+            return AccessController.doPrivileged(\n+                 (PrivilegedAction<String>) () -> System.getProperty(theProp));\n+        }\n+    }\n+\n@@ -112,0 +139,4 @@\n+        \/\/ If set, system property supersedes XMLCryptoContext property\n+        if (SECVAL_SYSPROP_SET) {\n+            return SECVAL_SYSPROP;\n+        }\n@@ -115,1 +146,1 @@\n-        return getBoolean(xc, \"org.jcp.xml.dsig.secureValidation\");\n+        return getBoolean(xc, SECVAL_PROP_NAME);\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/Utils.java","additions":33,"deletions":2,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -631,3 +631,2 @@\n-       \/**\n-       * Accessible Value routines\n-       *\/\n+     * Accessible Value routines\n+     *\/\n","filename":"src\/jdk.accessibility\/windows\/native\/include\/bridge\/AccessBridgeCalls.h","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -671,1 +671,1 @@\n-#endif _notdef\n+#endif \/\/ _notdef\n","filename":"src\/jdk.accessibility\/windows\/native\/jaccessinspector\/jaccessinspector.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,0 +106,8 @@\n+        \/**\n+         * Used for instances of {@link EscapeTree}\n+         * representing some escaped documentation text.\n+         *\n+         * @since 21\n+         *\/\n+        ESCAPE,\n+\n@@ -253,1 +261,1 @@\n-         * representing some documentation text.\n+         * representing some plain documentation text.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/doctree\/DocTree.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -146,0 +146,16 @@\n+    \/**\n+     * Visits an {@code EscapeTree} node.\n+     *\n+     * @implSpec Visits the provided {@code EscapeTree} node\n+     * by calling {@code visitOther(node, p)}.\n+     *\n+     * @param node the node being visited\n+     * @param p a parameter value\n+     * @return a result value\n+     *\n+     * @since 21\n+     *\/\n+    default R visitEscape(EscapeTree node, P p)  {\n+        return visitOther(node, p);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/doctree\/DocTreeVisitor.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.source.doctree;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.util.Elements;\n+\n+\/**\n+ * A tree node for a character represented by an escape sequence.\n+ *\n+ * @apiNote This class does not itself constrain the set of valid escape sequences,\n+ * although the set may be effectively constrained to those defined in the\n+ * <a href=\"{@docRoot}\/..\/specs\/javadoc\/doc-comment-spec.html#escape-sequences\">\n+ * Documentation Comment Specification for the Standard Doclet<\/a>,\n+ * including the following context-sensitive escape sequences:\n+ *\n+ * <ul>\n+ * <li>{@code @@}, representing {@code @}, where it would otherwise be treated as introducing a block or inline tag,\n+ * <li>{@code @\/}, representing {@code \/}, as part of {@code *@\/} to represent <code>&ast;&sol;<\/code>, and\n+ * <li>{@code @*}, representing {@code *}, where it would otherwise be {@linkplain Elements#getDocComment(Element) discarded},\n+ *     after whitespace at the beginning of a line.\n+ * <\/ul>\n+ *\n+ * @since 21\n+ *\/\n+public interface EscapeTree extends TextTree {\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * <p>Note: this method returns the escaped character, not the original escape sequence.\n+     *\/\n+    @Override\n+    String getBody();\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/doctree\/EscapeTree.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import javax.lang.model.element.Element;\n@@ -31,0 +32,1 @@\n+import javax.lang.model.util.Elements;\n@@ -46,0 +48,1 @@\n+import com.sun.source.doctree.EscapeTree;\n@@ -178,0 +181,23 @@\n+    \/**\n+     * Creates a new {@code EscapeTree} object, to represent an escaped character.\n+     *\n+     * @apiNote This method does not itself constrain the set of valid escape sequences,\n+     * although the set may be effectively constrained to those defined in the\n+     * <a href=\"{@docRoot}\/..\/specs\/javadoc\/doc-comment-spec.html#escape-sequences\">\n+     * Documentation Comment Specification for the Standard Doclet<\/a>,\n+     * including the following context-sensitive escape sequences:\n+     *\n+     * <ul>\n+     * <li>{@code @@}, representing {@code @}, where it would otherwise be treated as introducing a block or inline tag,\n+     * <li>{@code @\/}, representing {@code \/}, as part of {@code *@\/} to represent <code>&ast;&sol;<\/code>, and\n+     * <li>{@code @*}, representing {@code *}, where it would otherwise be {@linkplain Elements#getDocComment(Element) discarded},\n+     *     after whitespace at the beginning of a line.\n+     * <\/ul>\n+     *\n+     * @param ch the character\n+     * @return an {@code EscapeTree} object\n+     *\n+     * @since 21\n+     *\/\n+    EscapeTree newEscapeTree(char ch);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/DocTreeFactory.java","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -280,0 +280,16 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation returns {@code null}.\n+     *\n+     * @param node  {@inheritDoc}\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n+     *\n+     * @since 21\n+     *\/\n+    @Override\n+    public R visitEscape(EscapeTree node, P p) {\n+        return null;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/DocTreeScanner.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -235,0 +235,16 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n+     * @return  the result of {@code defaultAction}\n+     *\n+     * @since 21\n+     *\/\n+    @Override\n+    public R visitEscape(EscapeTree node, P p) {\n+        return defaultAction(node, p);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/SimpleDocTreeVisitor.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.stream.Collectors;\n@@ -393,0 +394,9 @@\n+    \/**\n+     * Describe modifier flags as they migh appear in source code, i.e.,\n+     * separated by spaces and in the order suggested by JLS 8.1.1.\n+     *\/\n+    public static String toSource(long flags) {\n+        return asModifierSet(flags).stream()\n+          .map(Modifier::toString)\n+          .collect(Collectors.joining(\" \"));\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -306,1 +306,1 @@\n-                log.error(pos, Errors.CantAssignValToFinalVar(v));\n+                log.error(pos, Errors.CantAssignValToVar(Flags.toSource(v.flags() & (STATIC | FINAL)), v));\n@@ -5222,1 +5222,1 @@\n-            Env<AttrContext> errEnv = env.dup(env.tree);\n+            Env<AttrContext> errEnv = env.dup(env.tree, env.info.dup());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -467,0 +467,3 @@\n+        \/* When performing speculative attribution on an argument expression, we should make sure that argument type\n+         * cache does not get polluted with local types, as that leads to spurious type errors (see JDK-8295019)\n+         *\/\n@@ -468,1 +471,1 @@\n-                null, AttributionMode.SPECULATIVE, null);\n+                null, AttributionMode.SPECULATIVE, !hasTypeDeclaration(tree) ? null : argumentAttr.withLocalCacheContext());\n@@ -471,0 +474,16 @@\n+    \/\/ where\n+        private boolean hasTypeDeclaration(JCTree tree) {\n+            TypeDeclVisitor typeDeclVisitor = new TypeDeclVisitor();\n+            typeDeclVisitor.scan(tree);\n+            return typeDeclVisitor.result;\n+        }\n+\n+        private static class TypeDeclVisitor extends TreeScanner {\n+            boolean result = false;\n+\n+            @Override\n+            public void visitClassDef(JCClassDecl that) {\n+                result = true;\n+            }\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/DeferredAttr.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -337,1 +337,1 @@\n-                             component.accessor));\n+                             component.accessor)).setType(types.erasure(component.accessor.getReturnType()));\n@@ -542,1 +542,1 @@\n-                                VarSymbol binding = ((JCBindingPattern) pattern).var.sym;\n+                                BindingSymbol binding = (BindingSymbol) ((JCBindingPattern) pattern).var.sym;\n@@ -545,1 +545,1 @@\n-                                                              make.Ident(binding),\n+                                                              make.Ident(bindingContext.getBindingFor(binding)),\n@@ -743,1 +743,1 @@\n-                                               make.DefaultCaseLabel());\n+                                    make.PatternCaseLabel(binding, newGuard));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -155,0 +155,4 @@\n+    char peekChar() {\n+        return buf[bp < buflen ? bp + 1 : buflen];\n+    }\n+\n@@ -227,0 +231,4 @@\n+                    \/\/ check for context-sensitive escape sequences:\n+                    \/\/   newline whitespace @@\n+                    \/\/   newline whitespace @*\n+                    \/\/   *@\/\n@@ -228,2 +236,21 @@\n-                        addPendingText(trees, lastNonWhite);\n-                        break loop;\n+                        char peek = peekChar();\n+                        if (peek == '@' || peek == '*') {\n+                            addPendingText(trees, bp - 1);\n+                            nextChar();\n+                            trees.add(m.at(bp - 1).newEscapeTree(ch));\n+                            newline = false;\n+                            nextChar();\n+                            textStart = bp;\n+                            break;\n+                        } else {\n+                            addPendingText(trees, lastNonWhite);\n+                            break loop;\n+                        }\n+                    } else if (textStart != -1 && buf[bp - 1] == '*' && peekChar() == '\/') {\n+                        addPendingText(trees, bp - 1);\n+                        nextChar();\n+                        trees.add(m.at(bp - 1).newEscapeTree('\/'));\n+                        newline = false;\n+                        nextChar();\n+                        textStart = bp;\n+                        break;\n@@ -283,0 +310,1 @@\n+            int prefPos = bp;\n@@ -285,1 +313,1 @@\n-            return erroneous(\"dc.no.tag.name\", p);\n+            return erroneous(\"dc.no.tag.name\", p, prefPos);\n@@ -296,4 +324,18 @@\n-            addPendingText(list, bp - 2);\n-            list.add(inlineTag());\n-            textStart = bp;\n-            lastNonWhite = -1;\n+            \/\/ check for context-sensitive escape-sequence\n+            \/\/   {@@\n+            if (peekChar() == '@') {\n+                if (textStart == -1) {\n+                    textStart = bp - 1;\n+                }\n+                addPendingText(list, bp - 1);\n+                nextChar();\n+                list.add(m.at(bp - 1).newEscapeTree('@'));\n+                nextChar();\n+                textStart = -1;\n+                lastNonWhite = bp;\n+            } else {\n+                addPendingText(list, bp - 2);\n+                list.add(inlineTag());\n+                textStart = bp;\n+                lastNonWhite = -1;\n+            }\n@@ -318,1 +360,1 @@\n-                return erroneous(\"dc.no.tag.name\", p);\n+                return erroneous(\"dc.no.tag.name\", p, bp);\n@@ -626,0 +668,27 @@\n+                case '@':\n+                    \/\/ check for context-sensitive escape sequences:\n+                    \/\/   newline whitespace @@\n+                    \/\/   newline whitespace @*\n+                    \/\/   *@\/\n+                    if (newline) {\n+                        char peek = peekChar();\n+                        if (peek == '@' || peek == '*') {\n+                            addPendingText(trees, bp - 1);\n+                            nextChar();\n+                            trees.add(m.at(bp - 1).newEscapeTree(ch));\n+                            newline = false;\n+                            nextChar();\n+                            textStart = bp;\n+                            break;\n+                        }\n+                    } else if (textStart != -1 && buf[bp - 1] == '*' && peekChar() == '\/') {\n+                        addPendingText(trees, bp - 1);\n+                        nextChar();\n+                        trees.add(m.at(bp - 1).newEscapeTree('\/'));\n+                        newline = false;\n+                        nextChar();\n+                        textStart = bp;\n+                        break;\n+                    }\n+                    \/\/ fallthrough\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/DocCommentParser.java","additions":77,"deletions":8,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -336,3 +336,3 @@\n-# 0: symbol\n-compiler.err.cant.assign.val.to.final.var=\\\n-    cannot assign a value to final variable {0}\n+# 0: set of flag or string, 1: symbol\n+compiler.err.cant.assign.val.to.var=\\\n+    cannot assign a value to {0} variable {1}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -171,0 +171,5 @@\n+            case ESCAPE -> {\n+                DCEscape esc = (DCEscape) this;\n+                return esc.pos + 2;\n+            }\n+\n@@ -644,0 +649,1 @@\n+    }\n@@ -645,0 +651,21 @@\n+    public static class DCEscape extends DCTree implements EscapeTree {\n+        public final char ch;\n+\n+        DCEscape(char ch) {\n+            this.ch = ch;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public Kind getKind() {\n+            return Kind.ESCAPE;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public <R, D> R accept(DocTreeVisitor<R, D> v, D d) {\n+            return v.visitEscape(this, d);\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public String getBody() {\n+            return String.valueOf(ch);\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/DCTree.java","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -248,0 +248,11 @@\n+    @Override @DefinedBy(Api.COMPILER_TREE)\n+    public Void visitEscape(EscapeTree node, Void p) {\n+        try {\n+            out.write(\"@\");\n+            print(node.getBody());\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+        return null;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/DocPretty.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,0 +63,1 @@\n+import com.sun.tools.javac.tree.DCTree.DCEscape;\n@@ -279,0 +280,7 @@\n+    @Override @DefinedBy(Api.COMPILER_TREE)\n+    public DCEscape newEscapeTree(char ch) {\n+        DCEscape tree = new DCEscape(ch);\n+        tree.pos = pos;\n+        return tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/DocTreeMaker.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,1 @@\n+import com.sun.source.doctree.EscapeTree;\n@@ -221,0 +222,6 @@\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public Object visitEscape(EscapeTree node, Object p) {\n+            result.append(node.getBody());\n+            return null;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/jdk\/internal\/shellsupport\/doc\/JavadocFormatter.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -413,1 +413,1 @@\n-                    if (t.close || idleConnections.size() >= MAX_IDLE_CONNECTIONS) {\n+                    if (t.close) {\n@@ -964,3 +964,18 @@\n-        c.idleStartTime = System.currentTimeMillis();\n-        c.setState(State.IDLE);\n-        idleConnections.add(c);\n+        boolean close = false;\n+\n+        synchronized(idleConnections) {\n+            if (idleConnections.size() >= MAX_IDLE_CONNECTIONS) {\n+                \/\/ closing the connection here could block\n+                \/\/ instead set boolean and close outside the synchronized block\n+                close = true;\n+            } else {\n+                c.idleStartTime = System.currentTimeMillis();\n+                c.setState(State.IDLE);\n+                idleConnections.add(c);\n+            }\n+        }\n+\n+        if (close) {\n+            c.close();\n+            allConnections.remove(c);\n+        }\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/ServerImpl.java","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -198,1 +198,1 @@\n-    @Override\n+    \/*package-private*\/\n@@ -200,1 +200,1 @@\n-    public VectorMask<E> indexInRange(int offset, int limit) {\n+    VectorMask<E> indexPartiallyInRange(int offset, int limit) {\n@@ -204,1 +204,1 @@\n-        return this.andNot(badMask);\n+        return badMask.not();\n@@ -207,1 +207,1 @@\n-    @Override\n+    \/*package-private*\/\n@@ -209,1 +209,1 @@\n-    public VectorMask<E> indexInRange(long offset, long limit) {\n+    VectorMask<E> indexPartiallyInRange(long offset, long limit) {\n@@ -213,1 +213,14 @@\n-        return this.andNot(badMask);\n+        return badMask.not();\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public VectorMask<E> indexInRange(int offset, int limit) {\n+        if (offset < 0) {\n+            return this.and(indexPartiallyInRange(offset, limit));\n+        } else if (offset >= limit) {\n+            return vectorSpecies().maskAll(false);\n+        } else if (limit - offset >= length()) {\n+            return this;\n+        }\n+        return this.and(indexPartiallyInUpperRange(offset, limit));\n@@ -216,0 +229,14 @@\n+    @ForceInline\n+    public VectorMask<E> indexInRange(long offset, long limit) {\n+        if (offset < 0) {\n+            return this.and(indexPartiallyInRange(offset, limit));\n+        } else if (offset >= limit) {\n+            return vectorSpecies().maskAll(false);\n+        } else if (limit - offset >= length()) {\n+            return this;\n+        }\n+        return this.and(indexPartiallyInUpperRange(offset, limit));\n+    }\n+\n+    abstract VectorMask<E> indexPartiallyInUpperRange(long offset, long limit);\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractMask.java","additions":34,"deletions":7,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -688,0 +688,9 @@\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        Byte128Mask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (Byte128Mask) VectorSupport.indexPartiallyInUpperRange(\n+                Byte128Mask.class, byte.class, VLENGTH, offset, limit,\n+                (o, l) -> (Byte128Mask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -720,0 +720,9 @@\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        Byte256Mask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (Byte256Mask) VectorSupport.indexPartiallyInUpperRange(\n+                Byte256Mask.class, byte.class, VLENGTH, offset, limit,\n+                (o, l) -> (Byte256Mask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -784,0 +784,9 @@\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        Byte512Mask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (Byte512Mask) VectorSupport.indexPartiallyInUpperRange(\n+                Byte512Mask.class, byte.class, VLENGTH, offset, limit,\n+                (o, l) -> (Byte512Mask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -672,0 +672,9 @@\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        Byte64Mask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (Byte64Mask) VectorSupport.indexPartiallyInUpperRange(\n+                Byte64Mask.class, byte.class, VLENGTH, offset, limit,\n+                (o, l) -> (Byte64Mask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -658,0 +658,9 @@\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        ByteMaxMask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (ByteMaxMask) VectorSupport.indexPartiallyInUpperRange(\n+                ByteMaxMask.class, byte.class, VLENGTH, offset, limit,\n+                (o, l) -> (ByteMaxMask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -649,0 +649,9 @@\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        Double128Mask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (Double128Mask) VectorSupport.indexPartiallyInUpperRange(\n+                Double128Mask.class, double.class, VLENGTH, offset, limit,\n+                (o, l) -> (Double128Mask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -653,0 +653,9 @@\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        Double256Mask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (Double256Mask) VectorSupport.indexPartiallyInUpperRange(\n+                Double256Mask.class, double.class, VLENGTH, offset, limit,\n+                (o, l) -> (Double256Mask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -661,0 +661,9 @@\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        Double512Mask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (Double512Mask) VectorSupport.indexPartiallyInUpperRange(\n+                Double512Mask.class, double.class, VLENGTH, offset, limit,\n+                (o, l) -> (Double512Mask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -647,0 +647,9 @@\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        Double64Mask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (Double64Mask) VectorSupport.indexPartiallyInUpperRange(\n+                Double64Mask.class, double.class, VLENGTH, offset, limit,\n+                (o, l) -> (Double64Mask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -646,0 +646,9 @@\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        DoubleMaxMask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (DoubleMaxMask) VectorSupport.indexPartiallyInUpperRange(\n+                DoubleMaxMask.class, double.class, VLENGTH, offset, limit,\n+                (o, l) -> (DoubleMaxMask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -653,0 +653,9 @@\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        Float128Mask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (Float128Mask) VectorSupport.indexPartiallyInUpperRange(\n+                Float128Mask.class, float.class, VLENGTH, offset, limit,\n+                (o, l) -> (Float128Mask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -661,0 +661,9 @@\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        Float256Mask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (Float256Mask) VectorSupport.indexPartiallyInUpperRange(\n+                Float256Mask.class, float.class, VLENGTH, offset, limit,\n+                (o, l) -> (Float256Mask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -677,0 +677,9 @@\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        Float512Mask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (Float512Mask) VectorSupport.indexPartiallyInUpperRange(\n+                Float512Mask.class, float.class, VLENGTH, offset, limit,\n+                (o, l) -> (Float512Mask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -649,0 +649,9 @@\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        Float64Mask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (Float64Mask) VectorSupport.indexPartiallyInUpperRange(\n+                Float64Mask.class, float.class, VLENGTH, offset, limit,\n+                (o, l) -> (Float64Mask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -646,0 +646,9 @@\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        FloatMaxMask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (FloatMaxMask) VectorSupport.indexPartiallyInUpperRange(\n+                FloatMaxMask.class, float.class, VLENGTH, offset, limit,\n+                (o, l) -> (FloatMaxMask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -664,0 +664,9 @@\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        Int128Mask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (Int128Mask) VectorSupport.indexPartiallyInUpperRange(\n+                Int128Mask.class, int.class, VLENGTH, offset, limit,\n+                (o, l) -> (Int128Mask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -672,0 +672,9 @@\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        Int256Mask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (Int256Mask) VectorSupport.indexPartiallyInUpperRange(\n+                Int256Mask.class, int.class, VLENGTH, offset, limit,\n+                (o, l) -> (Int256Mask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -688,0 +688,9 @@\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        Int512Mask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (Int512Mask) VectorSupport.indexPartiallyInUpperRange(\n+                Int512Mask.class, int.class, VLENGTH, offset, limit,\n+                (o, l) -> (Int512Mask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -660,0 +660,9 @@\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        Int64Mask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (Int64Mask) VectorSupport.indexPartiallyInUpperRange(\n+                Int64Mask.class, int.class, VLENGTH, offset, limit,\n+                (o, l) -> (Int64Mask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -658,0 +658,9 @@\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        IntMaxMask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (IntMaxMask) VectorSupport.indexPartiallyInUpperRange(\n+                IntMaxMask.class, int.class, VLENGTH, offset, limit,\n+                (o, l) -> (IntMaxMask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -650,0 +650,9 @@\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        Long128Mask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (Long128Mask) VectorSupport.indexPartiallyInUpperRange(\n+                Long128Mask.class, long.class, VLENGTH, offset, limit,\n+                (o, l) -> (Long128Mask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -654,0 +654,9 @@\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        Long256Mask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (Long256Mask) VectorSupport.indexPartiallyInUpperRange(\n+                Long256Mask.class, long.class, VLENGTH, offset, limit,\n+                (o, l) -> (Long256Mask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -662,0 +662,9 @@\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        Long512Mask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (Long512Mask) VectorSupport.indexPartiallyInUpperRange(\n+                Long512Mask.class, long.class, VLENGTH, offset, limit,\n+                (o, l) -> (Long512Mask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -648,0 +648,9 @@\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        Long64Mask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (Long64Mask) VectorSupport.indexPartiallyInUpperRange(\n+                Long64Mask.class, long.class, VLENGTH, offset, limit,\n+                (o, l) -> (Long64Mask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -648,0 +648,9 @@\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        LongMaxMask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (LongMaxMask) VectorSupport.indexPartiallyInUpperRange(\n+                LongMaxMask.class, long.class, VLENGTH, offset, limit,\n+                (o, l) -> (LongMaxMask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -672,0 +672,9 @@\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        Short128Mask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (Short128Mask) VectorSupport.indexPartiallyInUpperRange(\n+                Short128Mask.class, short.class, VLENGTH, offset, limit,\n+                (o, l) -> (Short128Mask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -688,0 +688,9 @@\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        Short256Mask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (Short256Mask) VectorSupport.indexPartiallyInUpperRange(\n+                Short256Mask.class, short.class, VLENGTH, offset, limit,\n+                (o, l) -> (Short256Mask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -720,0 +720,9 @@\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        Short512Mask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (Short512Mask) VectorSupport.indexPartiallyInUpperRange(\n+                Short512Mask.class, short.class, VLENGTH, offset, limit,\n+                (o, l) -> (Short512Mask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -664,0 +664,9 @@\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        Short64Mask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (Short64Mask) VectorSupport.indexPartiallyInUpperRange(\n+                Short64Mask.class, short.class, VLENGTH, offset, limit,\n+                (o, l) -> (Short64Mask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -658,0 +658,9 @@\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        ShortMaxMask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (ShortMaxMask) VectorSupport.indexPartiallyInUpperRange(\n+                ShortMaxMask.class, short.class, VLENGTH, offset, limit,\n+                (o, l) -> (ShortMaxMask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -931,0 +931,9 @@\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        $masktype$ indexPartiallyInUpperRange(long offset, long limit) {\n+            return ($masktype$) VectorSupport.indexPartiallyInUpperRange(\n+                $masktype$.class, $type$.class, VLENGTH, offset, limit,\n+                (o, l) -> ($masktype$) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+import com.sun.source.doctree.EscapeTree;\n@@ -1341,0 +1342,6 @@\n+                @Override\n+                public Boolean visitEscape(EscapeTree node, Content content) {\n+                    result.add(node.getBody());\n+                    return false;\n+                }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import com.sun.source.doctree.EscapeTree;\n@@ -389,0 +390,5 @@\n+            @Override\n+            public List<? extends DocTree> visitEscape(EscapeTree node, Void p) {\n+                return asList(node.getBody());\n+            }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/CommentHelper.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,0 +68,1 @@\n+import com.sun.source.doctree.EscapeTree;\n@@ -351,0 +352,1 @@\n+        hasNonWhitespaceText = true;\n@@ -361,0 +363,8 @@\n+    @Override @DefinedBy(Api.COMPILER_TREE)\n+    public Void visitEscape(EscapeTree tree, Void ignore) {\n+        hasNonWhitespaceText = true;\n+        checkAllowsText(tree);\n+        markEnclosingTag(Flag.HAS_TEXT);\n+        return null;\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclint\/Checker.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-import com.sun.jdi.request.EventRequest;\n@@ -473,2 +472,0 @@\n-        tsr.setSuspendPolicy(EventRequest.SUSPEND_NONE);\n-        tdr.setSuspendPolicy(EventRequest.SUSPEND_NONE);\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/example\/debug\/tty\/VMConnection.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.util.StringJoiner;\n@@ -45,0 +46,2 @@\n+    private final List<String> conflictedOptions = new ArrayList<>();\n+\n@@ -67,0 +70,1 @@\n+        checkConflict();\n@@ -71,0 +75,25 @@\n+    protected void checkConflict() {\n+        if (conflictedOptions.isEmpty()) {\n+            return;\n+        }\n+\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"Option\");\n+\n+        \/\/ If multiple options conflict, the following blocks are executed\n+        if (conflictedOptions.size() > 1) {\n+            sb.append(\"s \");\n+            StringJoiner sj = new StringJoiner(\", \");\n+            while (conflictedOptions.size() > 1) {\n+                sj.add(conflictedOptions.remove(0));\n+            }\n+            sb.append(sj);\n+            sb.append(\" and\");\n+        }\n+\n+        sb.append(\" \");\n+        sb.append(conflictedOptions.remove(0));\n+        sb.append(\" can only be specified once.\");\n+        throw new IllegalArgumentException(sb.toString());\n+    }\n+\n@@ -97,1 +126,5 @@\n-                        throw new IllegalArgumentException(\"Duplicates in diagnostic command arguments\");\n+                        if (!conflictedOptions.contains(key)) {\n+                            conflictedOptions.add(key);\n+                        }\n+                    } else {\n+                        options.put(key, v);\n@@ -99,1 +132,0 @@\n-                    options.put(key, v);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/ArgumentParser.java","additions":35,"deletions":3,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,1 +99,1 @@\n-      ASSERT_EQ((size_t) os::vm_page_size(), os::large_page_size()) << \"Test needs further refinement\";\n+      ASSERT_EQ(os::vm_page_size(), os::large_page_size()) << \"Test needs further refinement\";\n@@ -405,1 +405,1 @@\n-      ASSERT_EQ((size_t)os::vm_page_size(), os::large_page_size()) << \"Test needs further refinement\";\n+      ASSERT_EQ(os::vm_page_size(), os::large_page_size()) << \"Test needs further refinement\";\n","filename":"test\/hotspot\/gtest\/memory\/test_virtualspace.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#include \"sanitizers\/address.h\"\n+#include \"sanitizers\/address.hpp\"\n","filename":"test\/hotspot\/gtest\/metaspace\/test_virtualspacenode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -204,1 +204,1 @@\n-    EXPECT_TRUE(is_aligned(32 * M, (size_t)os::vm_page_size()));\n+    EXPECT_TRUE(is_aligned(32 * M, os::vm_page_size()));\n","filename":"test\/hotspot\/gtest\/runtime\/test_arguments.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -701,1 +701,1 @@\n-  ASSERT_LE(os::min_page_size(), (size_t)os::vm_page_size());\n+  ASSERT_LE(os::min_page_size(), os::vm_page_size());\n@@ -707,1 +707,1 @@\n-  ASSERT_EQ(os::page_sizes().smallest(), (size_t)os::vm_page_size());\n+  ASSERT_EQ(os::page_sizes().smallest(), os::vm_page_size());\n@@ -710,1 +710,1 @@\n-    ASSERT_GT(os::large_page_size(), (size_t)os::vm_page_size());\n+    ASSERT_GT(os::large_page_size(), os::vm_page_size());\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_linux.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-  const intptr_t page_sizes[] = {os::vm_page_size(), 4096, 8192, 65536, 2 * 1024 * 1024};\n+  const intptr_t page_sizes[] = {static_cast<intptr_t>(os::vm_page_size()), 4096, 8192, 65536, 2 * 1024 * 1024};\n","filename":"test\/hotspot\/gtest\/utilities\/test_globalDefinitions.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -85,2 +85,0 @@\n-vmTestbase\/nsk\/jdi\/ClassType\/invokeMethod\/invokemethod011\/TestDescription.java 8282379 generic-all\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList-svc-vthread.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -127,1 +127,1 @@\n-            if (WHITE_BOX.getUintxVMFlag(\"TypeProfileLevel\") == 20) {\n+            if (WHITE_BOX.getUintVMFlag(\"TypeProfileLevel\") == 20) {\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestArrayCopyNoInitDeopt.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @summary Run with -Xcomp to test -XX:+VerifyIterativeGVN in debug builds.\n+ * @summary Run with -Xcomp to test -XX:VerifyIterativeGVN=11 in debug builds.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm\/timeout=300 -Xbatch -Xcomp -XX:+VerifyIterativeGVN compiler.c2.TestVerifyIterativeGVN\n+ * @run main\/othervm\/timeout=300 -Xbatch -Xcomp -XX:VerifyIterativeGVN=11 compiler.c2.TestVerifyIterativeGVN\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestVerifyIterativeGVN.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,1496 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+super public class TestDeadIrreducibleLoops\n+{\n+    public Method \"<init>\":\"()V\"\n+    stack 2 locals 1\n+    {\n+        aload_0;\n+        invokespecial  Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+    }\n+\n+    static Method test_001:\"(IIII)I\"\n+    stack 20 locals 20\n+    {\n+        \/\/ Irreducible loop with 3 Regions, 2 are entries, 1 is not entry\n+        iconst_0;\n+        istore 10;\n+\n+        iload_0;\n+        ifeq LEND; \/\/ runtime check, skip all code\n+\n+        iload_1;\n+        ifeq ENTRY1; \/\/ irreducible entry\n+        goto ENTRY2;\n+\n+    ENTRY1:\n+        \/\/ 43 Region - irreducible-entry\n+        iload 3;\n+        ifeq L1;\n+        iinc 10, 1;\n+    ENTRY2:\n+        \/\/ 44 Region - irreducible-entry\n+        iinc 10, 2;\n+    L1:\n+        \/\/ 60 Region - irreducible (but not entry)\n+        \/\/ can be loop-head, if build_loop_tree\n+        \/\/ first reaches ENTRY2\n+        iinc 10, 4;\n+        iload_2;\n+        ifeq ENTRY1; \/\/ loop-end\n+\n+    LEND:\n+        iload 10;\n+        ireturn;\n+    }\n+\n+    static Method test_002:\"(I)V\"\n+    stack 10 locals 10\n+    {\n+        \/\/ split_fall_in splits up an irreducible-entry Region\n+        iconst_0;\n+        istore     1;\n+        iload      0;\n+        ifle L2;\n+    L1:\n+        \/\/ bci:8\n+        \/\/ 30  Region (tagged irreducible at parsing)\n+        iload      0;\n+        ifne L3;\n+    L2:\n+        \/\/ bci:13\n+        \/\/ 29  Region (tagged irreducible at parsing)\n+        \/\/ 100 Region\n+        \/\/ 129 Region (produced in split_fall_in, must be tagged irreducible)\n+        \/\/ 134 Loop\n+        goto L1;\n+    L3:\n+        iload      1;\n+        ifgt L1;\n+        return;\n+    }\n+\n+    static Method test_003:\"(I)I\"\n+    stack 5 locals 25\n+    {\n+        \/\/ Cut off both entries to irreducible loop at the same time:\n+        \/\/ LOOP_y (empty_loop) collapses -> cut off both entries to irreducible LOOP_3\n+        \/\/ LOOP_3 should be removed during IGVN\n+        iconst_m1;\n+        istore           12;\n+        \n+        \/\/ empty loop, where var[20] counts to 0\n+        \/\/ and var[21] counts to 10001\n+        ldc              10001;\n+        istore           20;\n+        iconst_0;\n+        istore           21;\n+    LOOP_Y:\n+        iinc             20, -1;\n+        iinc             21, 1;\n+        iload            20;\n+        ifgt             LOOP_Y;\n+\n+        \/\/ once the empty_loop above collapses, we see this is true\n+        iload            21;\n+        ldc              10001;\n+        if_icmpeq        LEND;\n+\n+        iload_0;\n+        ldc              1;\n+        iand;\n+        ifeq             LOOP_3c; \/\/ second entry\n+\n+        \/\/ first entry\n+    LOOP_3a:\n+        iinc             12, 11;\n+        iload            12;\n+        ifge             LOOP_3c; \/\/ skip\n+    LOOP_3b:\n+        iinc             12, 7;\n+    LOOP_3c:\n+        iinc             12, 3;\n+        iload            12;\n+        ldc              1001;\n+        if_icmpne        LOOP_3a; \/\/ loop\n+    LEND:\n+        iload            12;\n+        ireturn;\n+    }\n+\n+    static Method test_004:\"(Ljava\/lang\/Object;)Ljava\/lang\/Object;\"\n+    stack 10 locals 10\n+    {\n+        \/\/ When we detect irreducible loops, we add more Phi nodes\n+        \/\/ This test generates dead code, where we create a dead-loop\n+        \/\/ of Phi nodes. Phi nodes are considered dead-loop safe,\n+        \/\/ so they should be handled gracefully.\n+        \/\/ This is a regression test for the faulty \"sanity\" assert\n+        \/\/ in PhiNode::merge_through_phi. Instead of asserting,\n+        \/\/ we now just abort the optimization.\n+        iconst_1;\n+        istore      5;\n+    LOOP:\n+        iconst_0;\n+        ifge        HEAD;\n+        goto        LOOP;\n+    HEAD:\n+        iload       5;\n+        ifge        LCMP;\n+        iload       5;\n+        iflt        L29;\n+    L30:\n+        iload       5;\n+        iflt        BOTTOM;\n+    L29:\n+        iload       5;\n+        ifeq        L30;\n+    BOTTOM:\n+        goto        HEAD;\n+    LCMP:\n+        aload_0;\n+        areturn;\n+    }\n+\n+    static Method test_005:\"(II)V\"\n+    stack 20 locals 20\n+    {\n+        \/\/ Triggers compile bailout: bad CFG: both infinite and irreducible\n+\n+        iload_0;\n+        ifeq LEND; \/\/ runtime check, avoid infinte loop below\n+\n+        iconst_0;\n+        istore 10;\n+\n+        iload_1;\n+        ifeq ENTRY2;\n+\n+    ENTRY1:\n+        iinc 10, 1;\n+    ENTRY2:\n+        iinc 10, 2;\n+        goto ENTRY1; \/\/ backedge\n+        \n+    LEND:\n+        return;\n+    }\n+\n+    static Method test_006:\"(I)I\"\n+    stack 5 locals 25\n+    {\n+        \/\/ check that disconnected irreducible loop collapses instantly\n+        \/\/ and does not create data dead-loop with iinc \/ AddI\n+        iconst_m1;\n+        istore           12;\n+\n+        \/\/ empty loop, where var[20] counts to 0\n+        \/\/ and var[21] counts to 10001\n+        ldc              10001;\n+        istore           20;\n+        iconst_0;\n+        istore           21;\n+    LOOP_Y:\n+        iinc             20, -1;\n+        iinc             21, 1;\n+        iload            20;\n+        ifgt             LOOP_Y;\n+\n+        \/\/ once the empty_loop above collapses, we see this is true\n+        iload            21;\n+        ldc              10001;\n+        if_icmpeq        LEND;\n+\n+        \/\/ second entry\n+        iload_0;\n+        ldc              1;\n+        iand;\n+        ifgt             LOOP_3d;\n+        \n+        \/\/ first entry\n+    LOOP_3a:\n+        iload            12;\n+        ifge             LOOP_3d;\n+    LOOP_3b:\n+        iload_0; \/\/ eventually, we get TOP and things die from the inside out\n+        ldc              2;\n+        if_icmplt        LOOP_3b;\n+        iinc             12, 1; \/\/ the problematic AddI\n+        goto             LOOP_3a;\n+    LOOP_3d:\n+        iload            12;\n+        ldc              1001;\n+        if_icmpne        LOOP_3a;\n+    LEND:\n+        iload_0;\n+        ireturn;\n+    }\n+\n+    static Method test_007:\"(III)V\"\n+    stack 20 locals 40\n+    {\n+        \/\/ Irreducible entry Regions lose all loop-internal control\n+        \/\/ Once empty_loop collapses, we never loop-back to\n+        \/\/ ENTRY1 nor ENTRY2. SKIP1 and SKIP2 become the new\n+        \/\/ irreducible loop entries.\n+        iload_0;\n+        ifeq LEND; \/\/ runtime check, avoid code below\n+\n+        \/\/ empty loop, where var[20] counts to 0\n+        \/\/ and var[21] counts to 10001\n+        ldc              10001;\n+        istore           20;\n+        iconst_0;\n+        istore           21;\n+    EMPTY_LOOP:\n+        iinc             20, -1;\n+        iinc             21, 1;\n+        iload            20;\n+        ifgt             EMPTY_LOOP;\n+\n+        iconst_0;\n+        istore 30; \/\/ x = 0\n+\n+        iload_1;\n+        ifeq ENTRY1;\n+        goto ENTRY2; \/\/ the order here is arbitrary\n+\n+    ENTRY1:\n+        iinc 30, 1; \/\/ x += 1\n+\n+    SKIP1:\n+        ldc 10001;\n+        iload 21;\n+        if_icmpeq SKIP2; \/\/ always true after empty_loop collapses\n+\n+    ENTRY2:\n+        iinc 30, 32; \/\/ x += 2\n+\n+    SKIP2:\n+        iload_2;\n+        ifeq LEND; \/\/ loop-exit\n+\n+        ldc 10001;\n+        iload 21;\n+        if_icmpeq SKIP1; \/\/ always true after empty_loop collapses\n+\n+        goto ENTRY1; \/\/ backedge\n+\n+    LEND:\n+        return;\n+    }\n+\n+    static Method test_008:\"(III)V\"\n+    stack 20 locals 20\n+    {\n+        \/\/ Same as test_008, but ENTRY1 and ENTRY2 already\n+        \/\/ lose internal loop control during parsing,\n+        \/\/ and SKIP1 and SKIP2 are new entry Regions.\n+\n+        iload_0;\n+        ifeq LEND; \/\/ runtime check, skip code below\n+\n+        iconst_0;\n+        istore 10; \/\/ x = 0\n+\n+        iload_1;\n+        ifeq ENTRY2;\n+        goto ENTRY1; \/\/ the order here is arbitrary\n+\n+    ENTRY1:\n+        iinc 10, 1; \/\/ x += 1\n+\n+    SKIP1:\n+        iconst_0;\n+        ifeq SKIP2; \/\/ always true\n+\n+    ENTRY2:\n+        iinc 10, 32; \/\/ x += 2\n+\n+    SKIP2:\n+        iload_2;\n+        ifeq LEND; \/\/ loop-exit\n+\n+        iconst_0;\n+        ifeq SKIP1; \/\/ always true\n+\n+        goto ENTRY1; \/\/ backedge\n+\n+    LEND:\n+        return;\n+    }\n+\n+    static Method test_009:\"(IIIIIII)V\"\n+    stack 20 locals 40\n+    {\n+        \/\/ same as test_007, except extra ifs in ENTRY1 and ENTRY2\n+        \/\/ once ENTRY1 and ENTRY2 lose \"backedges\",\n+        \/\/ the ELSE1 and ELSE2 sections are no longer in the irreducible loop\n+        \/\/ and SKIP1 and SKIP2 become the new loop entries\n+        iload 0;\n+        ifeq LEND; \/\/ runtime check, avoid code below\n+\n+        \/\/ empty loop, where var[20] counts to 0\n+        \/\/ and var[21] counts to 10001\n+        ldc              10001;\n+        istore           20;\n+        iconst_0;\n+        istore           21;\n+    EMPTY_LOOP:\n+        iinc             20, -1;\n+        iinc             21, 1;\n+        iload            20;\n+        ifgt             EMPTY_LOOP;\n+\n+        iconst_0;\n+        istore 30; \/\/ x = 0\n+\n+        iload 1;\n+        ifeq ENTRY1;\n+        goto ENTRY2; \/\/ the order here is arbitrary\n+\n+    ENTRY1:\n+        iinc 30, 1; \/\/ x += 1\n+        iload 2;\n+        ifeq ELSE1;\n+\n+        iinc 30, 2; \/\/ x += 2\n+        iload 3;\n+        ifeq ELSE1;\n+\n+        iinc 30, 4; \/\/ x += 4\n+\n+    ELSE1:\n+        iinc 30, 8; \/\/ x += 8\n+\n+    SKIP1:\n+        ldc 10001;\n+        iload 21;\n+        if_icmpeq SKIP2; \/\/ always true after empty_loop collapses\n+\n+    ENTRY2:\n+        iinc 30, 16; \/\/ x += 16\n+        iload 4;\n+        ifeq ELSE2;\n+\n+        iinc 30, 32; \/\/ x += 32\n+        iload 5;\n+        ifeq ELSE2;\n+\n+        iinc 30, 64; \/\/ x += 64\n+\n+    ELSE2:\n+        iinc 30, 128; \/\/ x += 128\n+\n+    SKIP2:\n+        iload 6;\n+        ifeq LEND; \/\/ loop-exit\n+\n+        ldc 10001;\n+        iload 21;\n+        if_icmpeq SKIP1; \/\/ always true after empty_loop collapses\n+\n+        goto ENTRY1; \/\/ backedge\n+\n+    LEND:\n+        return;\n+    }\n+\n+    static Method test_010:\"(IIIII)V\"\n+    stack 10 locals 5\n+    {\n+    \/\/ outer: irreducible, inner: reducible loop\n+    \/\/ ENTRY1 is loop-head for both\n+    \/\/ test that is_in_irreducible_loop walks up to outermost loop with that loop-head\n+        iload_0;\n+        ifeq LEND; \/\/ runtime check, avoid code below\n+\n+        iload 4;\n+        ifeq SYMMETRY;\n+\n+        iload_1;\n+        ifeq ENTRY1;\n+        goto ENTRY2;\n+\n+    ENTRY1:\n+        \/\/ loop-head\n+        iload_2;\n+        ifeq ENTRY1; \/\/ backedge of reducible loop (inner)\n+    ENTRY2:\n+        \/\/ second-entry block\n+        iload_3;\n+        ifeq LEND;\n+        goto ENTRY1; \/\/ backedge of irreducible loop (outer)\n+\n+    SYMMETRY: \/\/ same as ENTRY1 \/ ENTRY2\n+        iload_1;\n+        ifeq ENTRY4; \/\/ but these are swapped\n+        goto ENTRY3;\n+\n+    ENTRY3:\n+        \/\/ loop-head\n+        iload_2;\n+        ifeq ENTRY3; \/\/ backedge of reducible loop (inner)\n+    ENTRY4:\n+        \/\/ second-entry block\n+        iload_3;\n+        ifeq LEND;\n+        goto ENTRY3; \/\/ backedge of irreducible loop (outer)\n+\n+    LEND:\n+        return;\n+    }\n+\n+    static Method test_011:\"(IIIII)V\"\n+    stack 20 locals 20\n+    {\n+    \/\/ If we define irreducible-entry as the Block \/ Region\n+    \/\/ that is either the head of the (outermost) irreducible loop,\n+    \/\/ or the location where we found a secondary entry to the loop,\n+    \/\/ we find that this definition depends on the order of the\n+    \/\/ DF traversal.\n+    \/\/ (backtrack, edge 0 -> 29, normal forward edge)\n+    \/\/ \n+    \/\/ bci-order 1:\n+    \/\/ 0, 29, 4, 11, 24 (backedge to 11), 16, 21 (backedge to 11),\n+    \/\/ 8 (second entry to 16, make 11 irreducible loop head)\n+    \/\/ \n+    \/\/ bci-order 2:\n+    \/\/ 0, 4, 8, 16, 21, 11 (backedge to 16), 24 (backedge to 11), 29\n+    \/\/ (backtrack, find edge from 16 -> 24, second entry to 24,\n+    \/\/  16 is irreducible loop head)\n+    \/\/ (backtrack, find edge from 4 -> 11, second entry to 11,\n+    \/\/  16 is again irreducible loop head)\n+    \/\/ (backtrack, edge 0 -> 29, normal forward edge)\n+    \/\/ \n+    \/\/ Note: in order 2, bci:24 is a entry, but not for order 1.\n+    \/\/ This makes asserts that check the consistency of entries\n+    \/\/ difficult, if not impossible.\n+\n+    \/\/ bci: 0\n+        iload_0;\n+        ifeq LEND; \/\/ runtime check, avoid code below\n+\n+    \/\/ bci: 4\n+        iload_1;\n+        ifeq ENTRY1;\n+    \/\/ bci: 8\n+        goto ENTRY2;\n+\n+    ENTRY1:\n+    \/\/ bci: 11\n+        iload            2;\n+        ifeq             BOTTOM;\n+    ENTRY2:\n+    \/\/ bci: 16\n+        iload            3;\n+        ifeq             BOTTOM;\n+    \/\/ bci: 21\n+        goto             ENTRY1;\n+\n+    BOTTOM:\n+    \/\/ bci: 24\n+        iload            4;\n+        ifeq             ENTRY1;\n+ \n+    LEND:\n+    \/\/ bci: 29\n+        return;\n+    }\n+\n+    static Method test_012a:\"(IIIIIIII)V\"\n+    stack 20 locals 20\n+    {\n+    \/\/ reducible loop inside irreducible loop\n+    \/\/ block numbers give order that leads to only\n+    \/\/ ENTRY1 and ENTRY2 being irreducible loop entries\n+\n+        \/\/ block 0\n+        iload_0;\n+        ifeq LEND; \/\/ runtime check, avoid code below\n+\n+        \/\/ block 2\n+        iload_1;\n+        ifeq ENTRY1;\n+        \/\/ block 12\n+        goto ENTRY2;\n+\n+    ENTRY1:\n+        \/\/ block 3\n+        iload            2;\n+        ifeq             BOTTOM1;\n+        \/\/ block 8\n+        goto             ENTRY2;\n+    ENTRY2:\n+        \/\/ block 9\n+        iload            3;\n+        ifeq             BOTTOM1;\n+        \/\/ block 10\n+        iload            7;\n+        ifeq             LEND;\n+        \/\/ block 11\n+        goto             ENTRY1;\n+\n+    BOTTOM1:\n+        \/\/ region must be marked as irreducible\n+        \/\/ it is loop-head of irreducible loop, but also\n+        \/\/ itself in the irreducible loop that surrounds it\n+        \/\/ there is also a traversal that makes this a\n+        \/\/ irreducible loop entry:\n+        \/\/ 0, 2, 12, 9, 10, 11, 3, 8 (-> backedge to 9)\n+        \/\/ 4 (-> backedge to 3), 5, 7 (->backedge to 4),\n+        \/\/ 1, 6 (-> backedge to 5, -> backedge to 3) ... backtrack all the way to 9\n+        \/\/ -> irreducible entry edge to 4\n+        \/\/ Since this kind of block \/ region can be an irreducible loop\n+        \/\/ entry, we should mark the block \/ region as in the irreducible loop\n+        \/\/ this block is split\n+        \/\/ block 4 (in: 3 7 9, out: 5 3)\n+        \/\/ block 6 (in: 5, out: 5 3)\n+        iload            4;\n+        ifeq ENTRY1;\n+    BOTTOM2:\n+        \/\/ block 5\n+        iload            5;\n+        ifeq             BOTTOM1;\n+        \/\/ block 7\n+        iload            6;\n+        ifeq             BOTTOM1;\n+ \n+    LEND:\n+        \/\/ block 1\n+        return;\n+    }\n+\n+    static Method test_012b:\"(IIIII)V\"\n+    stack 20 locals 20\n+    {\n+    \/\/ reducible loop inside irreducible loop\n+    \/\/ this nested loop is an infinite loop (no exit)\n+\n+        iload_0;\n+        ifeq LEND; \/\/ runtime check, avoid code below\n+\n+        iload_1;\n+        ifeq ENTRY1;\n+        goto ENTRY2;\n+\n+    ENTRY1:\n+        iload            2;\n+        ifeq             BOTTOM;\n+        goto             ENTRY2;\n+    ENTRY2:\n+        iload            3;\n+        ifeq             BOTTOM;\n+        goto             ENTRY1;\n+\n+    BOTTOM:\n+        \/\/ this must still be marked as in irreducible loop from above,\n+        \/\/ even though it is the head of a reducible loop\n+        iload            4;\n+        ifeq ENTRY1;\n+        goto BOTTOM; \/\/ reducible loop\n+ \n+    LEND:\n+        return;\n+    }\n+\n+    static Method test_013:\"(IIIIIIIII)V\"\n+    stack 20 locals 40\n+    {\n+    \/\/ Irreducible loop ENTRY1 \/ ENTRY2, eventually collapses\n+    \/\/ Reducible loops LOOP1 \/ LOOP2 inside irreducible loop\n+    \/\/ Irreducible loop BOTTOM, with backedge to ENTRY1 (eventually collapses)\n+        iload_0;\n+        ifeq LEND; \/\/ runtime check, avoid code below\n+\n+        \/\/ empty loop\n+        ldc              10001;\n+        istore           20;\n+        iconst_0;\n+        istore           21;\n+    EMPTY_LOOP:\n+        iinc             20, -1;\n+        iinc             21, 1;\n+        iload            21;\n+        ldc              10001;\n+        if_icmplt        EMPTY_LOOP;\n+        \/\/ var[20] == 0\n+\n+        iconst_1;\n+        istore           30; \/\/ for LOOP1, LOOP2\n+\n+        iload_1;\n+        ifeq ENTRY1;\n+        goto ENTRY2;\n+\n+    ENTRY1:\n+        iload            20;\n+        ifeq             LOOP1;\n+        goto             ENTRY2; \/\/ removed by empty_loop\n+    ENTRY2:\n+        iload            20;\n+        ifeq             LOOP2;\n+        goto             ENTRY1; \/\/ removed by empty_loop\n+\n+    LOOP1:\n+        iload            30;\n+        ldc              2;\n+        imul;\n+        istore           30;\n+        iload            30;\n+        ldc              10000;\n+        if_icmple        LOOP1;\n+        goto             BOTTOM1;\n+    LOOP2:\n+        iload            30;\n+        ldc              2;\n+        imul;\n+        istore           30;\n+        iload            30;\n+        ldc              10000;\n+        if_icmple        LOOP2;\n+        goto             BOTTOM2;\n+\n+    BOTTOM1:\n+        iload            3;\n+        ifeq             BOTTOM2;\n+        iload            4;\n+        ifeq             BOTTOM3;\n+        iload            20;\n+        ifne             ENTRY1; \/\/ removed by empty_loop\n+        goto LEND;\n+    BOTTOM2:\n+        iload            5;\n+        ifeq             BOTTOM3;\n+        iload            6;\n+        ifeq             BOTTOM1;\n+        goto LEND;\n+    BOTTOM3:\n+        iload            7;\n+        ifeq             BOTTOM1;\n+        iload            8;\n+        ifeq             BOTTOM2;\n+        goto LEND;\n+ \n+    LEND:\n+        return;\n+    }\n+\n+    static Method test_014a:\"(III)V\"\n+    stack 20 locals 40\n+    {\n+    \/\/ Irreducible loop that becomes normal loop\n+    \/\/ and is then removed as empty loop (#2)\n+    \/\/ which finally takes out ENTRY3 \/ ENTRY4\n+    \/\/ \n+        iload_0;\n+        ifeq LEND; \/\/ runtime check, avoid code below\n+\n+        \/\/ empty_loop #1\n+        ldc              10001;\n+        istore           20;\n+        iconst_0;\n+        istore           21;\n+    EMPTY_LOOP:\n+        iinc             20, -1;\n+        iinc             21, 1;\n+        iload            21;\n+        ldc              10001;\n+        if_icmplt        EMPTY_LOOP;\n+        \/\/ var[20] == 0 \/\/ empty_loop (#1)\n+\n+        \/\/ variables for ENTRY1 \/ ENTRY2\n+        \/\/ when path to ENTRY2 collapses,\n+        \/\/ the loop becomes reducible and\n+        \/\/ can be removed as empty_loop (#2)\n+        iconst_0;\n+        istore           30;\n+        ldc              20002;\n+        istore           31;\n+\n+        iload            20;\n+        ifeq ENTRY1;\n+        goto ENTRY2; \/\/ removed by empty_loop (#1)\n+\n+    ENTRY1:\n+        iinc             30, 1;\n+    ENTRY2:\n+        iinc             31, -1;\n+        iload            30;\n+        ldc              20002;\n+        if_icmplt        ENTRY1;\n+        \/\/ var[31] == 0 \/\/ empty_loop (#2)\n+\n+        iload            31;\n+        ifeq             LEND; \/\/ always taken due to empty_loop (#2)\n+\n+        iload_1;\n+        ifeq ENTRY3;\n+        goto ENTRY4;\n+\n+        \/\/ irreducible loop at the end\n+        \/\/ expected to be removed after empty_loop (#2) collapses\n+    ENTRY3:\n+        iload_2;\n+        ifeq LEND;\n+    ENTRY4:\n+        goto ENTRY3;\n+\n+    LEND:\n+        return;\n+    }\n+\n+    static Method test_014b:\"(III)V\"\n+    stack 200 locals 200\n+    {\n+    \/\/ Sequence of these loops:\n+    \/\/ Irreducible with 2 entries.\n+    \/\/ One entry collapses, turning the irreducible loop\n+    \/\/ into an empty_loop. This collapses one entry of\n+    \/\/ the next loop. This cascades until all loops are\n+    \/\/ removed.\n+        iload_0;\n+        ifeq LEND; \/\/ runtime check, avoid code below\n+\n+        \/\/ setting up all variables for the loops below\n+        iconst_0;\n+        istore           100;\n+        ldc              10001;\n+        istore           101;\n+        iconst_0;\n+        istore           102;\n+        ldc              10001;\n+        istore           103;\n+        iconst_0;\n+        istore           104;\n+        ldc              10001;\n+        istore           105;\n+        iconst_0;\n+        istore           106;\n+        ldc              10001;\n+        istore           107;\n+        iconst_0;\n+        istore           108;\n+        ldc              10001;\n+        istore           109;\n+        iconst_0;\n+        istore           110;\n+        ldc              10001;\n+        istore           111;\n+        iconst_0;\n+        istore           112;\n+        ldc              10001;\n+        istore           113;\n+        iconst_0;\n+        istore           114;\n+        ldc              10001;\n+        istore           115;\n+\n+        iconst_0; \/\/ collapse during parsing\n+        ifeq ENTRY00;\n+        goto ENTRY01;\n+    ENTRY00:\n+        iinc             100, 1;\n+    ENTRY01:\n+        iinc             101, -1;\n+        iload            100;\n+        ldc              10001;\n+        if_icmplt        ENTRY00;\n+        \/\/ var[101] == 0 \/\/ empty_loop (#1)\n+\n+        iload            101; \/\/ from last empty_loop\n+        ifeq ENTRY02;\n+        goto ENTRY03;\n+    ENTRY02:\n+        iinc             102, 1;\n+    ENTRY03:\n+        iinc             103, -1;\n+        iload            102;\n+        ldc              10001;\n+        if_icmplt        ENTRY02;\n+        \/\/ var[103] == 0 \/\/ empty_loop (#2)\n+\n+        iload            103; \/\/ from last empty_loop\n+        ifeq ENTRY04;\n+        goto ENTRY05;\n+    ENTRY04:\n+        iinc             104, 1;\n+    ENTRY05:\n+        iinc             105, -1;\n+        iload            104;\n+        ldc              10001;\n+        if_icmplt        ENTRY04;\n+        \/\/ var[105] == 0 \/\/ empty_loop (#3)\n+\n+        iload            105; \/\/ from last empty_loop\n+        ifeq ENTRY06;\n+        goto ENTRY07;\n+    ENTRY06:\n+        iinc             106, 1;\n+    ENTRY07:\n+        iinc             107, -1;\n+        iload            106;\n+        ldc              10001;\n+        if_icmplt        ENTRY06;\n+        \/\/ var[107] == 0 \/\/ empty_loop (#4)\n+\n+        iload            107; \/\/ from last empty_loop\n+        ifeq ENTRY08;\n+        goto ENTRY09;\n+    ENTRY08:\n+        iinc             108, 1;\n+    ENTRY09:\n+        iinc             109, -1;\n+        iload            108;\n+        ldc              10001;\n+        if_icmplt        ENTRY08;\n+        \/\/ var[109] == 0 \/\/ empty_loop (#5)\n+\n+        iload            109; \/\/ from last empty_loop\n+        ifeq ENTRY10;\n+        goto ENTRY11;\n+    ENTRY10:\n+        iinc             110, 1;\n+    ENTRY11:\n+        iinc             111, -1;\n+        iload            110;\n+        ldc              10001;\n+        if_icmplt        ENTRY10;\n+        \/\/ var[111] == 0 \/\/ empty_loop (#6)\n+\n+        iload            111; \/\/ from last empty_loop\n+        ifeq ENTRY12;\n+        goto ENTRY13;\n+    ENTRY12:\n+        iinc             112, 1;\n+    ENTRY13:\n+        iinc             113, -1;\n+        iload            112;\n+        ldc              10001;\n+        if_icmplt        ENTRY12;\n+        \/\/ var[113] == 0 \/\/ empty_loop (#7)\n+\n+        iload            113; \/\/ from last empty_loop\n+        ifeq ENTRY14;\n+        goto ENTRY15;\n+    ENTRY14:\n+        iinc             114, 1;\n+    ENTRY15:\n+        iinc             115, -1;\n+        iload            114;\n+        ldc              10001;\n+        if_icmplt        ENTRY14;\n+        \/\/ var[115] == 0 \/\/ empty_loop (#8)\n+\n+        \/\/ final loop, removed after last empty_loop collapses\n+        iload            115;\n+        ifeq             LEND;\n+        iload_1;\n+        ifeq ENTRY3;\n+        goto ENTRY4;\n+    ENTRY3:\n+        iload_2;\n+        ifeq LEND;\n+    ENTRY4:\n+        goto ENTRY3;\n+\n+    LEND:\n+        return;\n+    }\n+\n+    static Method test_015a:\"(I)I\"\n+    stack 20 locals 40\n+    {\n+    \/\/ Irreducible loop that loses second entry already during parsing\n+    \/\/ and later becomes counted loop\n+        iconst_0;\n+        istore           30;\n+        iconst_1;\n+        istore           31;\n+\n+        ldc              0;\n+        ifeq ENTRY1;\n+        goto ENTRY2; \/\/ removed during parsing\n+\n+    ENTRY1:\n+        iinc             30, 1; \/\/ trip count\n+    ENTRY2:\n+        iload            31;\n+        ldc              3; \/\/ compute pow(3,x)\n+        imul;\n+        istore           31;\n+        iload            30;\n+        iload            0;\n+        if_icmplt        ENTRY1;\n+\n+    LEND:\n+        iload            31;\n+        ireturn;\n+    }\n+\n+    static Method test_015b:\"(I)I\"\n+    stack 20 locals 40\n+    {\n+    \/\/ Similar as test_015a, but the irreducible loop only loses the\n+    \/\/ second entry during loop-opts (empty_loop), and the now\n+    \/\/ reducible loop does not become a CountedLoop any more.\n+        iconst_0;\n+        istore           30;\n+        iconst_1;\n+        istore           31;\n+\n+        \/\/ empty_loop\n+        ldc              10001;\n+        istore           20;\n+        iconst_0;\n+        istore           21;\n+    EMPTY_LOOP:\n+        iinc             20, -1;\n+        iinc             21, 1;\n+        iload            21;\n+        ldc              10001;\n+        if_icmplt        EMPTY_LOOP;\n+        \/\/ var[20] == 0 \/\/ empty_loop (#1)\n+\n+        iload            20;\n+        ifeq ENTRY1;\n+        goto ENTRY2; \/\/ removed by empty_loop\n+\n+    ENTRY1:\n+        iinc             30, 1; \/\/ trip count\n+    ENTRY2:\n+        iload            31;\n+        ldc              3; \/\/ compute pow(3,x)\n+        imul;\n+        istore           31;\n+        iload            30;\n+        iload            0;\n+        if_icmplt        ENTRY1;\n+\n+    LEND:\n+        iload            31;\n+        ireturn;\n+    }\n+\n+    static Method test_016:\"(III)V\"\n+    stack 200 locals 300\n+    {\n+    \/\/ Similar to test_014b.\n+    \/\/ Same sequence of irreducible loops collapsing to\n+    \/\/ empty_loops, collapsing and cascading to the next\n+    \/\/ loop.\n+    \/\/ In addition: each of the the loops in that sequence\n+    \/\/ controls an entry to a final big irreducible loop,\n+    \/\/ which slowly collapses, losing entry after entry.\n+        iload_0;\n+        ifeq LEND; \/\/ runtime check, avoid code below\n+\n+        \/\/ setting up all variables for the loops below\n+        iconst_0;\n+        istore           100;\n+        ldc              10001;\n+        istore           101;\n+        iconst_0;\n+        istore           102;\n+        ldc              10001;\n+        istore           103;\n+        iconst_0;\n+        istore           104;\n+        ldc              10001;\n+        istore           105;\n+        iconst_0;\n+        istore           106;\n+        ldc              10001;\n+        istore           107;\n+        iconst_0;\n+        istore           108;\n+        ldc              10001;\n+        istore           109;\n+        iconst_0;\n+        istore           110;\n+        ldc              10001;\n+        istore           111;\n+        iconst_0;\n+        istore           112;\n+        ldc              10001;\n+        istore           113;\n+        iconst_0;\n+        istore           114;\n+        ldc              10001;\n+        istore           115;\n+\n+        iconst_0; \/\/ collapse during parsing\n+        ifeq ENTRY00;\n+        goto ENTRY01;\n+    ENTRY00:\n+        iinc             100, 1;\n+    ENTRY01:\n+        iinc             101, -1;\n+        iload            100;\n+        ldc              10001;\n+        if_icmplt        ENTRY00;\n+        \/\/ var[101] == 0 \/\/ empty_loop (#1)\n+\n+        iload            101; \/\/ from last empty_loop\n+        ifeq ENTRY02;\n+        goto ENTRY03;\n+    ENTRY02:\n+        iinc             102, 1;\n+    ENTRY03:\n+        iinc             103, -1;\n+        iload            102;\n+        ldc              10001;\n+        if_icmplt        ENTRY02;\n+        \/\/ var[103] == 0 \/\/ empty_loop (#2)\n+\n+        iload            103; \/\/ from last empty_loop\n+        ifeq ENTRY04;\n+        goto ENTRY05;\n+    ENTRY04:\n+        iinc             104, 1;\n+    ENTRY05:\n+        iinc             105, -1;\n+        iload            104;\n+        ldc              10001;\n+        if_icmplt        ENTRY04;\n+        \/\/ var[105] == 0 \/\/ empty_loop (#3)\n+\n+        iload            105; \/\/ from last empty_loop\n+        ifeq ENTRY06;\n+        goto ENTRY07;\n+    ENTRY06:\n+        iinc             106, 1;\n+    ENTRY07:\n+        iinc             107, -1;\n+        iload            106;\n+        ldc              10001;\n+        if_icmplt        ENTRY06;\n+        \/\/ var[107] == 0 \/\/ empty_loop (#4)\n+\n+        iload            107; \/\/ from last empty_loop\n+        ifeq ENTRY08;\n+        goto ENTRY09;\n+    ENTRY08:\n+        iinc             108, 1;\n+    ENTRY09:\n+        iinc             109, -1;\n+        iload            108;\n+        ldc              10001;\n+        if_icmplt        ENTRY08;\n+        \/\/ var[109] == 0 \/\/ empty_loop (#5)\n+\n+        iload            109; \/\/ from last empty_loop\n+        ifeq ENTRY10;\n+        goto ENTRY11;\n+    ENTRY10:\n+        iinc             110, 1;\n+    ENTRY11:\n+        iinc             111, -1;\n+        iload            110;\n+        ldc              10001;\n+        if_icmplt        ENTRY10;\n+        \/\/ var[111] == 0 \/\/ empty_loop (#6)\n+\n+        iload            111; \/\/ from last empty_loop\n+        ifeq ENTRY12;\n+        goto ENTRY13;\n+    ENTRY12:\n+        iinc             112, 1;\n+    ENTRY13:\n+        iinc             113, -1;\n+        iload            112;\n+        ldc              10001;\n+        if_icmplt        ENTRY12;\n+        \/\/ var[113] == 0 \/\/ empty_loop (#7)\n+\n+        iload            113; \/\/ from last empty_loop\n+        ifeq ENTRY14;\n+        goto ENTRY15;\n+    ENTRY14:\n+        iinc             114, 1;\n+    ENTRY15:\n+        iinc             115, -1;\n+        iload            114;\n+        ldc              10001;\n+        if_icmplt        ENTRY14;\n+        \/\/ var[115] == 0 \/\/ empty_loop (#8)\n+\n+        \/\/ final loop, every empty_loop from above\n+        \/\/ controls one of the entries\n+        iconst_0;\n+        istore           200;\n+        iload            101;\n+        ifne             BOTTOM1;\n+        iload            103;\n+        ifne             BOTTOM2;\n+        iload            105;\n+        ifne             BOTTOM3;\n+        iload            107;\n+        ifne             BOTTOM4;\n+        iload            109;\n+        ifne             BOTTOM5;\n+        iload            111;\n+        ifne             BOTTOM6;\n+        iload            113;\n+        ifne             BOTTOM7;\n+        iload            115;\n+        ifeq             LEND;\n+        \/\/ finally cut off completely\n+        \/\/ trigger irreducible loop removal\n+        iload            1;\n+        ifeq             BOTTOM8;\n+        goto             BOTTOM0;\n+\n+    BOTTOM0:\n+        iinc             200, 1;\n+    BOTTOM1:\n+        iinc             200, 2;\n+    BOTTOM2:\n+        iinc             200, 4;\n+    BOTTOM3:\n+        iinc             200, 8;\n+    BOTTOM4:\n+        iinc             200, 16;\n+    BOTTOM5:\n+        iinc             200, 32;\n+    BOTTOM6:\n+        iinc             200, 64;\n+    BOTTOM7:\n+        iinc             200, 128;\n+    BOTTOM8:\n+        iload            200;\n+        ldc              30003;\n+        if_icmpgt        LEND;\n+        goto BOTTOM1;\n+\n+    LEND:\n+        return;\n+    }\n+\n+    static Method test_017:\"(III)V\"\n+    stack 20 locals 20\n+    {\n+        \/\/ Triggers partial_peel and strip-mining for a loop\n+        \/\/ where the head was marked is_in_irreducible_loop\n+\n+        iload 2;\n+        ifeq  LEND; \/\/ skip code\n+\n+        iload      1;\n+        ifgt L2;\n+    L1:\n+        nop;\n+    L2:\n+        iinc       1, 1;\n+        iload      1;\n+        ifgt L1;\n+        iload      0;\n+        ifne LEND;\n+        goto L2;\n+\n+    LEND:\n+        return;\n+    }\n+\n+    static Method test_018:\"(I)V\"\n+    stack 20 locals 20\n+    {\n+    \/\/ ciTypeFlow: infinite loop has no parent loop\n+        iload_0;\n+        ifeq LEND; \/\/ skip code\n+    LOOP:\n+        goto LOOP; \/\/ infinite loop\n+    LEND:\n+        return;\n+    }\n+\n+    static Method test_019:\"(IIII)V\"\n+    stack 20 locals 20\n+    {\n+    \/\/ may triggers split_flow_path, because of that aconst_null\n+\n+        iload_0;\n+        ifeq LEND; \/\/ skip code\n+\n+        aconst_null; \/\/ this has a strange side-effect\n+        goto LOOP3;\n+\n+    LOOP1:\n+        nop;\n+    LOOP2:\n+        iload      1;\n+        ifne LOOP1;\n+    LOOP3:\n+        iload      2;\n+        ifge LOOP2;\n+    LOOP4:\n+        iload      3;\n+        ifle LOOP1;\n+        iconst_m1;\n+        iflt LOOP2;\n+        goto LOOP4;\n+\n+    LEND:\n+        return;\n+    }\n+\n+    static Method test_020:\"(IIIII)V\"\n+    stack 20 locals 40\n+    {\n+    \/\/ Get infinite loop at some point that has no NeverBranch node\n+        iload_0;\n+        ifeq LEND; \/\/ skip\n+\n+        iconst_0;\n+        istore     20;\n+    LOOP1:\n+        iload      1;\n+        ifeq LOOP3;\n+    LOOP2:\n+        iconst_0;\n+        ifne LEND;\n+    LOOP3:\n+        iload      20;\n+        istore     30; \/\/ old\n+        iload      2;\n+        iflt LOOP4;\n+        iconst_1;\n+        istore     20; \/\/ overwrite new\n+        iload      30;\n+        iload      3;\n+        if_icmpgt LOOP1;\n+        goto LOOP3;\n+    LOOP4:\n+        iload      4;\n+        iflt LOOP2;\n+        goto LOOP4;\n+\n+    LEND:\n+        return;\n+    }\n+\n+    static Method test_021:\"(IIIIII)V\"\n+    stack 20 locals 20\n+    {\n+    \/\/ Produces a graph where one node is originally located inside\n+    \/\/ a reducible loop, but later that loop collapses, and exposes\n+    \/\/ the node to the outerloop, which is irreducible.\n+        iload_0;\n+        ifeq LEND; \/\/ skip\n+\n+    L1:\n+        iload      1;\n+        ifgt MERGE;\n+    L2:\n+        iload      2;\n+        ifge MERGE;\n+        goto L1;\n+\n+    MERGE:\n+        nop;\n+    LOOP:\n+        iload      3;\n+        ifle L2;\n+        iconst_0; \/\/ always true\n+        ifeq LOOP;\n+        iconst_0; \/\/ always true\n+        ifeq LOOP;\n+    INFTY:\n+        goto INFTY; \/\/ infinite loop\n+\n+    LEND:\n+        return;\n+    }\n+\n+    static Method test_022a:\"(IIII)V\"\n+    stack 20 locals 10\n+    {\n+        \/\/ see test_022b for explanation\n+        iload_0;\n+        ifeq LEND;\n+\n+        aconst_null;\n+        astore     9;\n+        iconst_1;\n+        ifeq ENTRY1; \/\/ eventually collapses\n+        goto ENTRY2;\n+    ENTRY1:\n+        iconst_0;\n+        ifeq LOOP;\n+    ENTRY2:\n+        iload      1;\n+        ifge LOOP;\n+        goto ENTRY1;\n+\n+    LOOP:\n+        \/\/ head is split -> new irreducible loop\n+        aload      9;\n+        pop;\n+        iconst_0;\n+        iflt LOOP;\n+        aconst_null;\n+        astore     9;\n+        iload      2;\n+        ifeq LEND;\n+        goto LOOP;\n+\n+    LEND:\n+        return;\n+    }\n+\n+    static Method test_022b:\"(II)V\"\n+    stack 20 locals 20\n+    {\n+    \/\/ Triggered split_flow_path for a reducible loop that had multiple fall-in\n+    \/\/ edges. The fall-in edges were split over two Phis\/Regions, creating a new\n+    \/\/ undetected irreducible loop. This only seems to happen when there are other\n+    \/\/ irreducible loops present, as it changes the merge-order during parsing.\n+    \/\/ If there are only reducible loops present, we merge the fall-in in a region\n+    \/\/ prior to the loop-head, as far as I understand.\n+        iload_0;\n+        ifeq LEND; \/\/ skip\n+\n+        aconst_null;\n+        astore     9;\n+        iload      1;\n+        ifeq OTHER;\n+    LOOP:\n+        iconst_0; \n+        iflt LEND; \/\/ false - old exit?\n+        aload      9;\n+        pop;\n+        iconst_0;\n+        ifne LOOP; \/\/ false\n+        goto LOOP;\n+ \n+    OTHER:\n+        iconst_m1;\n+        ifeq ENTRY1; \/\/ false\n+        goto ENTRY2; \n+    ENTRY1:\n+        iconst_0;\n+        ifeq LOOP; \/\/ true\n+    ENTRY2:\n+        goto ENTRY1;\n+\n+    LEND:\n+        return;\n+    }\n+\n+    static Method test_023:\"(I)V\"\n+    stack 20 locals 20\n+    {\n+        iload_0;\n+        ifeq LEND;\n+\n+        iconst_0;  \n+        istore     7;\n+        iconst_0;\n+        ifne L4;\n+    L2:\n+        nop;\n+    L4:\n+        iload      7;\n+        ifeq L12;\n+    L12:\n+        iconst_0;\n+        ifeq L2;\n+        goto L12;\n+\n+    LEND:\n+        return;\n+    }   \n+\n+    static Method test_024_inline:\"(I)I\"\n+    stack 20 locals 10\n+    {\n+        iload_0;\n+        ldc 3;\n+        irem;\n+        ifeq SKIP; \/\/ if (v % 3 == 0)\n+\n+        \/\/ (v % 5)\n+        iload_0;\n+        ldc 5;\n+        irem;\n+        istore_0;\n+        goto LEND;\n+\n+    SKIP:\n+        \/\/ (v % 7)\n+        iload_0;\n+        ldc 7;\n+        irem;\n+        istore_0;\n+        goto LEND;\n+\n+    LEND:\n+        iload_0;\n+        ireturn;\n+    }\n+\n+    static Method test_024:\"()I\"\n+    stack 20 locals 10\n+    {\n+    \/\/ Outer loop, irreducible inside, and inline call\n+    \/\/ Test that regions in inline are also handled as\n+    \/\/ they are nested in the irreducible loop\n+        iconst_0;\n+        istore 1; \/\/ i = 0\n+        iconst_0;\n+        istore 3; \/\/ x = 0\n+\n+    LOOP:\n+        iconst_0;\n+        istore 2; \/\/ j = 0\n+        iload 1;\n+        ldc 2;\n+        irem;\n+        ifeq ENTRY1; \/\/ if (i % 2 == 0)\n+        goto ENTRY2;\n+\n+    ENTRY1:\n+        iinc 2, 1; \/\/ j++\n+    ENTRY2:\n+        iload 2;\n+        invokestatic Method test_024_inline:\"(I)I\";\n+        iload 3;\n+        iadd;\n+        istore 3;\n+        iload 2;\n+        ldc 1000;\n+        if_icmplt ENTRY1; \/\/ while (j < 1000)\n+\n+        iinc 1, 1; \/\/ i++\n+        iload 1;\n+        ldc 10000;\n+        if_icmplt LOOP; \/\/ while (i < 10000)\n+\n+    LEND:\n+        iload 3;\n+        ireturn;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestDeadIrreducibleLoops.jasm","additions":1496,"deletions":0,"binary":false,"changes":1496,"status":"added"},{"patch":"@@ -0,0 +1,235 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8280126\n+ * @compile TestDeadIrreducibleLoops.jasm\n+ * @summary Irreducible loops have many entries, only when the last entry loses\n+ *          control from the outside does the loop die, and have to disappear.\n+ * @run main\/othervm\n+ *      -XX:CompileCommand=compileonly,TestDeadIrreducibleLoopsMain::test*\n+ *      -XX:CompileCommand=compileonly,TestDeadIrreducibleLoops::test*\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+StressIGVN\n+ *      TestDeadIrreducibleLoopsMain\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8280126\n+ * @compile TestDeadIrreducibleLoops.jasm\n+ * @summary Irreducible loops have many entries, only when the last entry loses\n+ *          control from the outside does the loop die, and have to disappear.\n+ * @run main\/othervm\n+ *      -XX:CompileCommand=compileonly,TestDeadIrreducibleLoopsMain::test*\n+ *      -XX:CompileCommand=compileonly,TestDeadIrreducibleLoops::test*\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+StressIGVN\n+ *      -XX:PerMethodTrapLimit=0\n+ *      TestDeadIrreducibleLoopsMain\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8280126\n+ * @compile TestDeadIrreducibleLoops.jasm\n+ * @summary Irreducible loops have many entries, only when the last entry loses\n+ *          control from the outside does the loop die, and have to disappear.\n+ * @run main\/othervm\n+ *      -XX:CompileCommand=compileonly,TestDeadIrreducibleLoopsMain::test*\n+ *      -XX:CompileCommand=compileonly,TestDeadIrreducibleLoops::test*\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+StressIGVN\n+ *      -Xcomp -XX:-TieredCompilation\n+ *      TestDeadIrreducibleLoopsMain\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8280126\n+ * @compile TestDeadIrreducibleLoops.jasm\n+ * @summary Irreducible loops have many entries, only when the last entry loses\n+ *          control from the outside does the loop die, and have to disappear.\n+ * @run main\/othervm\n+ *      -XX:CompileCommand=compileonly,TestDeadIrreducibleLoopsMain::test*\n+ *      -XX:CompileCommand=compileonly,TestDeadIrreducibleLoops::test*\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+StressIGVN\n+ *      -Xcomp -XX:-TieredCompilation\n+ *      -XX:PerMethodTrapLimit=0\n+ *      TestDeadIrreducibleLoopsMain\n+ *\/\n+\n+\/\/ Note: if this test fails intermittently, then use -XX:RepeatCompilation=1000\n+\/\/ The tests are run in no particular order. If an earlier test fails, a later one\n+\/\/ may fail too and be easier to debug.\n+\n+public class TestDeadIrreducibleLoopsMain {\n+   static public void main(String[] args) {\n+        TestDeadIrreducibleLoops t = new TestDeadIrreducibleLoops();\n+        test_000(false, false);\n+        t.test_001(0, 0, 0, 0);\n+        t.test_002(-1);\n+        t.test_003(255);\n+        t.test_004(\"I am an object\\n\");\n+        t.test_005(0, 0);\n+        t.test_006(0);\n+        t.test_007(0, 0, 0);\n+        t.test_008(0, 0, 0);\n+        t.test_009(0, 0, 0, 0, 0, 0, 0);\n+        t.test_010(0, 0, 0, 0, 0);\n+        t.test_011(0, 0, 0, 0, 0);\n+        t.test_012a(0, 0, 0, 0, 0, 0, 0, 0);\n+        t.test_012b(0, 0, 0, 0, 0);\n+        t.test_013(0, 0, 0, 0, 0, 0, 0, 0, 0);\n+        t.test_014a(0, 0, 0);\n+        t.test_014b(0, 0, 0);\n+        int x = t.test_015a(123);\n+        int y = t.test_015b(123);\n+        assert x == y: \"pow(3,x)\";\n+        t.test_016(0, 0, 0);\n+        t.test_017(0, 0, 0);\n+        t.test_018(0);\n+        t.test_019(0, 0, 0, 0);\n+        t.test_020(0, 0, 0, 0, 0);\n+        t.test_021(0, 0, 0, 0, 0, 0);\n+        t.test_022a(0, 0, 0, 0);\n+        t.test_022b(0, 0);\n+        t.test_023(0);\n+        t.test_024();\n+        test_025a(false);\n+        test_025b(false, false);\n+    }\n+\n+    public static float test_000(boolean flag1, boolean flag2) {\n+        float ret = 1.0f;\n+        int x = 0;\n+        LOOP1:\n+        for (int i = 1; i < 1000000; i *= 2) { \/\/ about 20 iterations\n+            if (i % 5 != 0) { \/\/ SKIP1\n+                LOOP2:\n+                for (int j = 1; j < 1000000; j *= 2) { \/\/ about 20 iterations\n+                    if (j % 5 != 0) { \/\/ SKIP2\n+                        if (x == 0) { \/\/ eventually always false -> continue statements float out of loop\n+                            ret *= 1.0001;\n+                            if (j > 100) {\n+                                LOOP3:\n+                                for (float m = 1.0f; m < 30000.0f; m *= 1.0001f) {\n+                                    \/\/ OSR starts here - should do more than 100k iterations\n+                                    ret *= 0.99999f;\n+                                }\n+                                x = 1;\n+                            }\n+                            int y = 77;\n+                            for (int e = 0; e < 77; e++) {\n+                                y -= x; \/\/ empty_loop, once we know that x == 1\n+                            }\n+                            if (y == 0) {\n+                                \/\/ always true after OSR -> cut off ENTRY1 and ENTRY2\n+                                return ret;\n+                            }\n+                            ret += 0.01;\n+                            if (ret > 20000) {\n+                                ret = 7.0f;\n+                                continue LOOP1; \/\/ ENTRY1\n+                            }\n+                            \/\/ back to LOOP2 -> ENTRY2\n+                        } \/\/ end if (x == 0)\n+                    } \/\/ end SKIP2\n+                } \/\/ end LOOP2\n+            } \/\/ end SKIP1\n+        } \/\/ end LOOP1\n+        return ret;\n+    }\n+\n+    static float test_025a(boolean flag) {\n+        \/\/ Based on test_000, but much simplified.\n+        \/\/ Irreducible loop with OSR. Inlining in irreducible loop.\n+        float ret = 3.0f;\n+        LOOP1:\n+        for (long i = 1; i < 1000_000_000_000L; i *= 2) {\n+            ret = test_025_inline(ret); \/\/ inline region\n+            LOOP2:\n+            for (long j = 1; j < 1000_000_000_000L; j *= 2) {\n+                for (int e = 0; e < 77; e++) {}\n+                if (flag) {\n+                    continue LOOP1; \/\/ ENTRY1\n+                }\n+                \/\/ back to LOOP2 -> ENTRY2\n+            } \/\/ end LOOP2\n+        } \/\/ end LOOP1\n+        return ret;\n+    }\n+\n+    static float test_025b(boolean flag1, boolean flag2) {\n+        \/\/ Based on test_000.\n+        \/\/ Irreducible loop with OSR. Inlining in irreducible loop.\n+        float ret = 1.0f;\n+        int x = 0;\n+        LOOP1:\n+        for (long i = 1; i < 1000_000_000_000L; i *= 2) {\n+            ret = test_025_inline(ret);\n+            if (i % 5 != 0) { \/\/ SKIP1\n+                LOOP2:\n+                for (long j = 1; j < 1000_000_000_000L; j *= 2) {\n+                    if (j % 5 != 0) { \/\/ SKIP2\n+                        if (x == 0) { \/\/ eventually always false -> continue statements float out of loop\n+                            ret *= 1.0001;\n+                            if (i > 1000_000_000L) {\n+                                LOOP3:\n+                                for (float m = 1.0f; m < 30000.0f; m *= 1.0001f) {\n+                                    \/\/ OSR starts here - should do more than 100k iterations\n+                                    ret *= 0.99999f;\n+                                }\n+                                x = 1;\n+                            }\n+                            int y = 77;\n+                            for (int e = 0; e < 77; e++) {\n+                                y -= x; \/\/ empty_loop, once we know that x == 1\n+                            }\n+                            if (y == 0) {\n+                                \/\/ always true after OSR -> cut off ENTRY1 and ENTRY2\n+                                return ret;\n+                            }\n+                            ret += 0.01;\n+                            if (ret > 20000) {\n+                                ret = 7.0f;\n+                                continue LOOP1; \/\/ ENTRY1\n+                            }\n+                            \/\/ back to LOOP2 -> ENTRY2\n+                        } \/\/ end if (x == 0)\n+                    } \/\/ end SKIP2\n+                } \/\/ end LOOP2\n+            } \/\/ end SKIP1\n+        } \/\/ end LOOP1\n+        return ret;\n+    }\n+\n+    static float test_025_inline(float x) {\n+        if (x >= 1.0f) {\n+          x *= 0.5f;\n+        } else {\n+          x *= 2.0f;\n+        }\n+        \/\/ Region to merge the if\n+        return x;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestDeadIrreducibleLoopsMain.java","additions":235,"deletions":0,"binary":false,"changes":235,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @summary Test which causes a stack overflow segmentation fault with -XX:+VerifyIterativeGVN due to a too deep recursion in Node::verify_recur().\n+ * @summary Test which causes a stack overflow segmentation fault with -XX:VerifyIterativeGVN=1 due to a too deep recursion in Node::verify_recur().\n@@ -30,1 +30,1 @@\n- * @run main\/othervm\/timeout=600 -Xcomp -XX:+VerifyIterativeGVN -XX:CompileCommand=compileonly,compiler.loopopts.TestDeepGraphVerifyIterativeGVN::*\n+ * @run main\/othervm\/timeout=600 -Xcomp -XX:VerifyIterativeGVN=1 -XX:CompileCommand=compileonly,compiler.loopopts.TestDeepGraphVerifyIterativeGVN::*\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestDeepGraphVerifyIterativeGVN.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @summary Test which triggers assertion in PhaseIdealLoop::try_move_store_after_loop with -XX:+VerifyIterativeGVN due to dead hook.\n+ * @summary Test which triggers assertion in PhaseIdealLoop::try_move_store_after_loop with -XX:VerifyIterativeGVN=1 due to dead hook.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm -Xbatch -XX:+VerifyIterativeGVN compiler.loopopts.TestMoveStoreAfterLoopVerifyIterativeGVN\n+ * @run main\/othervm -Xbatch -XX:VerifyIterativeGVN=1 compiler.loopopts.TestMoveStoreAfterLoopVerifyIterativeGVN\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestMoveStoreAfterLoopVerifyIterativeGVN.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,1 +105,1 @@\n-        if (WHITE_BOX.getUintxVMFlag(\"TypeProfileLevel\") == 20) {\n+        if (WHITE_BOX.getUintVMFlag(\"TypeProfileLevel\") == 20) {\n@@ -108,1 +108,1 @@\n-        if (WHITE_BOX.getUintxVMFlag(\"TypeProfileLevel\") == 200) {\n+        if (WHITE_BOX.getUintVMFlag(\"TypeProfileLevel\") == 200) {\n","filename":"test\/hotspot\/jtreg\/compiler\/profiling\/TestTypeProfiling.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\"\n+ * @requires (os.simpleArch == \"x64\" & vm.cpu.features ~= \".*avx2.*\") | os.arch == \"aarch64\"\n@@ -76,1 +76,1 @@\n-  @IR(applyIfCPUFeature={\"avx2\", \"true\"}, counts = {IRNode.REVERSE_V , \" > 0 \"})\n+  @IR(counts = {IRNode.REVERSE_V, \"> 0\"})\n@@ -92,1 +92,1 @@\n-  @IR(applyIfCPUFeature={\"avx2\", \"true\"}, failOn = {IRNode.REVERSE_V , IRNode.REVERSE_L})\n+  @IR(failOn = {IRNode.REVERSE_V, IRNode.REVERSE_L})\n@@ -108,1 +108,1 @@\n-  @IR(applyIfCPUFeature={\"avx2\", \"true\"}, failOn = {IRNode.REVERSE_V , IRNode.REVERSE_L})\n+  @IR(failOn = {IRNode.REVERSE_V, IRNode.REVERSE_L})\n@@ -124,1 +124,1 @@\n-  @IR(applyIfCPUFeature={\"avx2\", \"true\"}, counts = {IRNode.REVERSE_V, \"> 0\"})\n+  @IR(counts = {IRNode.REVERSE_V, \"> 0\"})\n@@ -140,1 +140,1 @@\n-  @IR(applyIfCPUFeature={\"avx2\", \"true\"}, failOn = {IRNode.REVERSE_V, IRNode.REVERSE_I})\n+  @IR(failOn = {IRNode.REVERSE_V, IRNode.REVERSE_I})\n@@ -156,1 +156,1 @@\n-  @IR(applyIfCPUFeature={\"avx2\", \"true\"}, failOn = {IRNode.REVERSE_V, IRNode.REVERSE_I})\n+  @IR(failOn = {IRNode.REVERSE_V, IRNode.REVERSE_I})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestReverseBitsVector.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -186,0 +186,1 @@\n+        new LogMessageWithLevel(\"Resize TLABs\", Level.DEBUG),\n@@ -195,2 +196,1 @@\n-        new LogMessageWithLevel(\"Start New Collection Set\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Resize TLABs\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Prepare For Mutator\", Level.DEBUG),\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestGCLogMessages.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -176,1 +176,1 @@\n-        output = dumpHelloOnly(\"-XX:ArchiveHeapTestClass=NoSuchClass\");\n+        output = dumpHelloOnly(\"-XX:-IgnoreUnrecognizedVMOptions\", \"-XX:ArchiveHeapTestClass=NoSuchClass\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/cacheObject\/ArchiveHeapTestClass.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,0 +97,3 @@\n+    private static final String loggingOpts = \"-Xlog:cds,cds+dynamic=debug,class+load=trace\";\n+    private static final String lambdaLoadedFromArchive =\n+        \".class.load. test.java.lang.invoke.$i[$][$]Lambda[$].*\/0x.*source:.*shared.*objects.*file.*(top)\";\n@@ -107,0 +110,13 @@\n+        String jars = appJar + ps + junitJar;\n+        String className = testPackageName + \".\" + testClassName;\n+\n+        dump(topArchiveName, loggingOpts, \"-cp\", jars, verifyOpt, mainClass, className)\n+            .assertNormalExit(output -> {\n+                    output.shouldContain(\"Written dynamic archive 0x\");\n+                });\n+\n+        run(topArchiveName, loggingOpts, \"-cp\", jars, verifyOpt, mainClass, className)\n+            .assertNormalExit(output -> {\n+                    output.shouldMatch(lambdaLoadedFromArchive)\n+                          .shouldHaveExitValue(0);\n+                });\n@@ -108,3 +124,0 @@\n-        dumpAndRun(topArchiveName, \"-Xlog:cds,cds+dynamic=debug,class+load=trace\",\n-            \"-cp\", appJar + ps + junitJar, verifyOpt,\n-            mainClass, testPackageName + \".\" + testClassName);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/methodHandles\/CDSMHTest_generate.sh","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,3 @@\n+    private static final String loggingOpts = \"-Xlog:cds,cds+dynamic=debug,class+load=trace\";\n+    private static final String lambdaLoadedFromArchive =\n+        \".class.load. test.java.lang.invoke.MethodHandlesAsCollectorTest[$][$]Lambda[$].*\/0x.*source:.*shared.*objects.*file.*(top)\";\n@@ -75,0 +78,13 @@\n+        String jars = appJar + ps + junitJar;\n+        String className = testPackageName + \".\" + testClassName;\n+\n+        dump(topArchiveName, loggingOpts, \"-cp\", jars, verifyOpt, mainClass, className)\n+            .assertNormalExit(output -> {\n+                    output.shouldContain(\"Written dynamic archive 0x\");\n+                });\n+\n+        run(topArchiveName, loggingOpts, \"-cp\", jars, verifyOpt, mainClass, className)\n+            .assertNormalExit(output -> {\n+                    output.shouldMatch(lambdaLoadedFromArchive)\n+                          .shouldHaveExitValue(0);\n+                });\n@@ -76,3 +92,0 @@\n-        dumpAndRun(topArchiveName, \"-Xlog:cds,cds+dynamic=debug,class+load=trace\",\n-            \"-cp\", appJar + ps + junitJar, verifyOpt,\n-            mainClass, testPackageName + \".\" + testClassName);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/methodHandles\/MethodHandlesAsCollectorTest.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,3 @@\n+    private static final String loggingOpts = \"-Xlog:cds,cds+dynamic=debug,class+load=trace\";\n+    private static final String lambdaLoadedFromArchive =\n+        \".class.load. test.java.lang.invoke.MethodHandlesCastFailureTest[$][$]Lambda[$].*\/0x.*source:.*shared.*objects.*file.*(top)\";\n@@ -75,0 +78,13 @@\n+        String jars = appJar + ps + junitJar;\n+        String className = testPackageName + \".\" + testClassName;\n+\n+        dump(topArchiveName, loggingOpts, \"-cp\", jars, verifyOpt, mainClass, className)\n+            .assertNormalExit(output -> {\n+                    output.shouldContain(\"Written dynamic archive 0x\");\n+                });\n+\n+        run(topArchiveName, loggingOpts, \"-cp\", jars, verifyOpt, mainClass, className)\n+            .assertNormalExit(output -> {\n+                    output.shouldMatch(lambdaLoadedFromArchive)\n+                          .shouldHaveExitValue(0);\n+                });\n@@ -76,3 +92,0 @@\n-        dumpAndRun(topArchiveName, \"-Xlog:cds,cds+dynamic=debug,class+load=trace\",\n-            \"-cp\", appJar + ps + junitJar, verifyOpt,\n-            mainClass, testPackageName + \".\" + testClassName);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/methodHandles\/MethodHandlesCastFailureTest.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,3 @@\n+    private static final String loggingOpts = \"-Xlog:cds,cds+dynamic=debug,class+load=trace\";\n+    private static final String lambdaLoadedFromArchive =\n+        \".class.load. test.java.lang.invoke.MethodHandlesGeneralTest[$][$]Lambda[$].*\/0x.*source:.*shared.*objects.*file.*(top)\";\n@@ -75,0 +78,13 @@\n+        String jars = appJar + ps + junitJar;\n+        String className = testPackageName + \".\" + testClassName;\n+\n+        dump(topArchiveName, loggingOpts, \"-cp\", jars, verifyOpt, mainClass, className)\n+            .assertNormalExit(output -> {\n+                    output.shouldContain(\"Written dynamic archive 0x\");\n+                });\n+\n+        run(topArchiveName, loggingOpts, \"-cp\", jars, verifyOpt, mainClass, className)\n+            .assertNormalExit(output -> {\n+                    output.shouldMatch(lambdaLoadedFromArchive)\n+                          .shouldHaveExitValue(0);\n+                });\n@@ -76,3 +92,0 @@\n-        dumpAndRun(topArchiveName, \"-Xlog:cds,cds+dynamic=debug,class+load=trace\",\n-            \"-cp\", appJar + ps + junitJar, verifyOpt,\n-            mainClass, testPackageName + \".\" + testClassName);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/methodHandles\/MethodHandlesGeneralTest.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,3 @@\n+    private static final String loggingOpts = \"-Xlog:cds,cds+dynamic=debug,class+load=trace\";\n+    private static final String lambdaLoadedFromArchive =\n+        \".class.load. test.java.lang.invoke.MethodHandlesInvokersTest[$][$]Lambda[$].*\/0x.*source:.*shared.*objects.*file.*(top)\";\n@@ -75,0 +78,13 @@\n+        String jars = appJar + ps + junitJar;\n+        String className = testPackageName + \".\" + testClassName;\n+\n+        dump(topArchiveName, loggingOpts, \"-cp\", jars, verifyOpt, mainClass, className)\n+            .assertNormalExit(output -> {\n+                    output.shouldContain(\"Written dynamic archive 0x\");\n+                });\n+\n+        run(topArchiveName, loggingOpts, \"-cp\", jars, verifyOpt, mainClass, className)\n+            .assertNormalExit(output -> {\n+                    output.shouldMatch(lambdaLoadedFromArchive)\n+                          .shouldHaveExitValue(0);\n+                });\n@@ -76,3 +92,0 @@\n-        dumpAndRun(topArchiveName, \"-Xlog:cds,cds+dynamic=debug,class+load=trace\",\n-            \"-cp\", appJar + ps + junitJar, verifyOpt,\n-            mainClass, testPackageName + \".\" + testClassName);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/methodHandles\/MethodHandlesInvokersTest.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,3 @@\n+    private static final String loggingOpts = \"-Xlog:cds,cds+dynamic=debug,class+load=trace\";\n+    private static final String lambdaLoadedFromArchive =\n+        \".class.load. test.java.lang.invoke.MethodHandlesPermuteArgumentsTest[$][$]Lambda[$].*\/0x.*source:.*shared.*objects.*file.*(top)\";\n@@ -75,0 +78,13 @@\n+        String jars = appJar + ps + junitJar;\n+        String className = testPackageName + \".\" + testClassName;\n+\n+        dump(topArchiveName, loggingOpts, \"-cp\", jars, verifyOpt, mainClass, className)\n+            .assertNormalExit(output -> {\n+                    output.shouldContain(\"Written dynamic archive 0x\");\n+                });\n+\n+        run(topArchiveName, loggingOpts, \"-cp\", jars, verifyOpt, mainClass, className)\n+            .assertNormalExit(output -> {\n+                    output.shouldMatch(lambdaLoadedFromArchive)\n+                          .shouldHaveExitValue(0);\n+                });\n@@ -76,3 +92,0 @@\n-        dumpAndRun(topArchiveName, \"-Xlog:cds,cds+dynamic=debug,class+load=trace\",\n-            \"-cp\", appJar + ps + junitJar, verifyOpt,\n-            mainClass, testPackageName + \".\" + testClassName);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/methodHandles\/MethodHandlesPermuteArgumentsTest.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,3 @@\n+    private static final String loggingOpts = \"-Xlog:cds,cds+dynamic=debug,class+load=trace\";\n+    private static final String lambdaLoadedFromArchive =\n+        \".class.load. test.java.lang.invoke.MethodHandlesSpreadArgumentsTest[$][$]Lambda[$].*\/0x.*source:.*shared.*objects.*file.*(top)\";\n@@ -75,0 +78,13 @@\n+        String jars = appJar + ps + junitJar;\n+        String className = testPackageName + \".\" + testClassName;\n+\n+        dump(topArchiveName, loggingOpts, \"-cp\", jars, verifyOpt, mainClass, className)\n+            .assertNormalExit(output -> {\n+                    output.shouldContain(\"Written dynamic archive 0x\");\n+                });\n+\n+        run(topArchiveName, loggingOpts, \"-cp\", jars, verifyOpt, mainClass, className)\n+            .assertNormalExit(output -> {\n+                    output.shouldMatch(lambdaLoadedFromArchive)\n+                          .shouldHaveExitValue(0);\n+                });\n@@ -76,3 +92,0 @@\n-        dumpAndRun(topArchiveName, \"-Xlog:cds,cds+dynamic=debug,class+load=trace\",\n-            \"-cp\", appJar + ps + junitJar, verifyOpt,\n-            mainClass, testPackageName + \".\" + testClassName);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/methodHandles\/MethodHandlesSpreadArgumentsTest.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+#ifdef AIX\n+#include <pthread.h>\n+#endif \/\/AIX\n@@ -38,1 +41,9 @@\n-int main(int argc, char *argv[]) {\n+typedef struct {\n+    int argc;\n+    char **argv;\n+} args_list;\n+\n+void* run(void* argp){\n+  args_list *arg = (args_list*) argp;\n+  int argc =  arg->argc;\n+  char **argv = arg->argv;\n@@ -105,0 +116,23 @@\n+  return 0;\n+}\n+\n+int main(int argc, char *argv[]) {\n+   args_list args;\n+   args.argc = argc;\n+   args.argv = argv;\n+#ifdef AIX\n+   size_t adjusted_stack_size = 1024*1024;\n+   pthread_t id;\n+   int result;\n+   pthread_attr_t attr;\n+   pthread_attr_init(&attr);\n+   pthread_attr_setstacksize(&attr, adjusted_stack_size);\n+   result = pthread_create(&id, &attr, run, (void *)&args);\n+   if (result != 0) {\n+     fprintf(stderr, \"Error: pthread_create failed with error code %d \\n\", result);\n+     return -1;\n+   }\n+   pthread_join(id, NULL);\n+#else\n+   run(&args);\n+#endif \/\/AIX\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/daemonDestroy\/exedaemonDestroy.c","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng\/othervm ThreadDumpToFileTest\n+ * @run junit\/othervm ThreadDumpToFileTest\n@@ -40,2 +40,2 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -43,1 +43,1 @@\n-public class ThreadDumpToFileTest {\n+class ThreadDumpToFileTest {\n@@ -49,1 +49,1 @@\n-    public void testThreadDump() throws IOException {\n+    void testThreadDump() throws IOException {\n@@ -58,1 +58,1 @@\n-    public void testPlainThreadDump() throws IOException {\n+    void testPlainThreadDump() throws IOException {\n@@ -67,1 +67,1 @@\n-    public void testJsonThreadDump() throws IOException {\n+    void testJsonThreadDump() throws IOException {\n@@ -88,1 +88,1 @@\n-    public void testDoNotOverwriteFile() throws IOException {\n+    void testDoNotOverwriteFile() throws IOException {\n@@ -95,1 +95,1 @@\n-        assertEquals(Files.readString(file), \"xxx\");\n+        assertEquals(\"xxx\", Files.readString(file));\n@@ -102,1 +102,1 @@\n-    public void testOverwriteFile() throws IOException {\n+    void testOverwriteFile() throws IOException {\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/thread\/ThreadDumpToFileTest.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ *\n+ * @bug 8228604\n+ *\n+ * @requires vm.jvmti\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm\/native -agentlib:MissedStackMapFrames MissedStackMapFrames\n+ *\/\n+\n+import jdk.internal.org.objectweb.asm.ClassReader;\n+import jdk.internal.org.objectweb.asm.ClassVisitor;\n+import jdk.internal.org.objectweb.asm.MethodVisitor;\n+import jdk.internal.org.objectweb.asm.Opcodes;\n+\n+\n+public class MissedStackMapFrames {\n+    static {\n+        System.loadLibrary(\"MissedStackMapFrames\");\n+    }\n+\n+    \/* For each test class:\n+     *  - loads class (JNIEnv::FindClass);\n+     *  - retransforms class (jvmtiEnv::RetransformClasses).\n+     * Saves class bytes passed to ClassFileLoadHook.\n+     *\/\n+    private static native boolean doTest();\n+\n+    \/* methods to analyze doTest results *\/\n+    private static native int testCount();\n+    private static native Class testClass(int idx);\n+    private static native byte[] loadBytes(int idx);\n+    private static native byte[] retransformBytes(int idx);\n+\n+    private static int getStackMapFrameCount(byte[] classfileBuffer) {\n+        ClassReader reader = new ClassReader(classfileBuffer);\n+        final int[] frameCount = {0};\n+        ClassVisitor cv = new ClassVisitor(Opcodes.ASM9) {\n+            @Override\n+            public MethodVisitor visitMethod(int access, String name,\n+                                             String descriptor, String signature,\n+                                             String[] exceptions) {\n+                return new MethodVisitor(Opcodes.ASM9) {\n+                    private int methodFrames = 0;\n+                    @Override\n+                    public void visitFrame(int type, int numLocal, Object[] local,\n+                                           int numStack, Object[] stack) {\n+                        methodFrames++;\n+                    }\n+                    @Override\n+                    public void visitEnd() {\n+                        log(\"  method \" + name + \" - \" + methodFrames + \" frames\");\n+                        frameCount[0] += methodFrames;\n+                    }\n+                };\n+            }\n+        };\n+        reader.accept(cv, 0);\n+        return frameCount[0];\n+    }\n+\n+    private static int checkStackMapFrames(String mode, byte[] classfileBuffer) {\n+        log(mode + \", len = \" + classfileBuffer.length);\n+        int frameCount = getStackMapFrameCount(classfileBuffer);\n+        log(\"  Has stack map frames: \" + frameCount);\n+        if (frameCount == 0) {\n+            throw new RuntimeException(mode + \" - no stack frames\");\n+        }\n+        return frameCount;\n+    }\n+\n+    private static void checkStackMapFrames(String mode, byte[] classfileBuffer, int expectedCount) {\n+        int actualCount = checkStackMapFrames(mode, classfileBuffer);\n+        if (actualCount != expectedCount) {\n+            throw new RuntimeException(mode + \" - unexpected stack frames count: \" + actualCount\n+                                       + \" (expected \" + expectedCount + \")\");\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (!doTest()) {\n+            throw new RuntimeException(\"Test failed\");\n+        }\n+\n+        \/\/ verify results\n+        for (int i = 0; i < testCount(); i++) {\n+            Class cls = testClass(i);\n+            byte[] loadBytes = loadBytes(i);\n+            byte[] retransformBytes = retransformBytes(i);\n+            int loadCount = checkStackMapFrames(cls + \"(load)\", loadBytes);\n+            checkStackMapFrames(cls + \"(retransform)\", retransformBytes, loadCount);\n+        }\n+    }\n+\n+    private static void log(Object msg) {\n+        System.out.println(msg);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/MissedStackMapFrames\/MissedStackMapFrames.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -0,0 +1,223 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+#include <jvmti.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+static void _log(const char* format, ...) {\n+  va_list args;\n+  va_start(args, format);\n+  vprintf(format, args);\n+  va_end(args);\n+  fflush(0);\n+}\n+\n+static jvmtiEnv* jvmti = nullptr;\n+\n+static const char* testClassNames[] = {\n+    \"java\/util\/Date\",               \/\/ JDK class in CDS archive\n+    \"java\/lang\/ProcessBuilder\",     \/\/ JDK class not in CDS\n+    \"MissedStackMapFrames\"          \/\/ non-JDK class\n+};\n+static const int testClassCount = sizeof(testClassNames) \/ sizeof(testClassNames[0]);\n+\n+struct SavedClassBytes {\n+  struct Buffer {\n+    unsigned char* bytes;\n+    jint len;\n+\n+    Buffer() : bytes(nullptr), len(0) {}\n+\n+    void save(const unsigned char *bytes, jint len) {\n+      jvmtiError err = jvmti->Allocate(len, &this->bytes);\n+      if (err != JVMTI_ERROR_NONE) {\n+          _log(\"ClassFileLoadHook: failed to allocate %ld bytes for saved class bytes: %d\\n\", len, err);\n+          return;\n+      }\n+      memcpy(this->bytes, bytes, len);\n+      this->len = len;\n+    }\n+\n+    jbyteArray get(JNIEnv *env) {\n+      if (bytes == nullptr) {\n+        _log(\"SavedClassBytes: NULL\\n\");\n+        return nullptr;\n+      }\n+\n+      jbyteArray result = env->NewByteArray(len);\n+      if (result == nullptr) {\n+        _log(\"SavedClassBytes: NewByteArray(%ld) failed\\n\", len);\n+      } else {\n+        jbyte* arrayPtr = env->GetByteArrayElements(result, nullptr);\n+        if (arrayPtr == nullptr) {\n+          _log(\"SavedClassBytes: Failed to get array elements\\n\");\n+          result = nullptr;\n+        } else {\n+          memcpy(arrayPtr, bytes, len);\n+          env->ReleaseByteArrayElements(result, arrayPtr, 0);\n+        }\n+      }\n+      return result;\n+    }\n+\n+  };\n+\n+  jclass klass;\n+\n+  Buffer load;\n+  Buffer retransform;\n+\n+  SavedClassBytes() : klass(nullptr) {}\n+};\n+\n+static SavedClassBytes savedBytes[testClassCount];\n+\n+static int testClassIndex(const char *name) {\n+  if (name != nullptr) {\n+    for (int i = 0; i < testClassCount; i++) {\n+      if (strcmp(name, testClassNames[i]) == 0) {\n+        return i;\n+      }\n+    }\n+  }\n+  return -1;\n+}\n+\n+\n+extern \"C\" {\n+\n+JNIEXPORT void JNICALL\n+callbackClassFileLoadHook(jvmtiEnv *jvmti_env,\n+        JNIEnv* jni_env,\n+        jclass class_being_redefined,\n+        jobject loader,\n+        const char* name,\n+        jobject protection_domain,\n+        jint class_data_len,\n+        const unsigned char* class_data,\n+        jint* new_class_data_len,\n+        unsigned char** new_class_data) {\n+  int idx = testClassIndex(name);\n+  if (idx >= 0) {\n+    if (class_being_redefined == nullptr) {\n+      \/\/ load\n+      savedBytes[idx].load.save(class_data, class_data_len);\n+    } else {\n+      \/\/ retransform\/redefine\n+      savedBytes[idx].retransform.save(class_data, class_data_len);\n+    }\n+  }\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM* jvm, char* options, void* reserved) {\n+  jint res = jvm->GetEnv((void **)&jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK) {\n+    _log(\"Failed to get JVMTI interface: %ld\\n\", res);\n+    return JNI_ERR;\n+  }\n+\n+  jvmtiCapabilities caps;\n+  memset(&caps, 0, sizeof(caps));\n+\n+  caps.can_retransform_classes = 1;\n+  jvmtiError err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    _log(\"Failed to add capabilities: %d\\n\", err);\n+    return JNI_ERR;\n+  }\n+\n+  jvmtiEventCallbacks eventCallbacks;\n+  memset(&eventCallbacks, 0, sizeof(eventCallbacks));\n+  eventCallbacks.ClassFileLoadHook = callbackClassFileLoadHook;\n+  err = jvmti->SetEventCallbacks(&eventCallbacks, sizeof(eventCallbacks));\n+  if (err != JVMTI_ERROR_NONE) {\n+    _log(\"Error setting event callbacks: %d\\n\", err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr);\n+  if (err != JVMTI_ERROR_NONE) {\n+    _log(\"SetEventNotificationMode(JVMTI_ENABLE) error %d\\n\", err);\n+    return JNI_ERR;\n+  }\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT void JNICALL\n+Agent_OnUnload(JavaVM* jvm) {\n+  return;\n+}\n+\n+\n+JNIEXPORT jboolean JNICALL\n+Java_MissedStackMapFrames_doTest(JNIEnv* env, jclass klass) {\n+\n+  jboolean result = JNI_TRUE;\n+  _log(\">>nTest\\n\");\n+\n+  for (int i = 0; i < testClassCount; i++) {\n+    _log(\"Loading %s...\\n\", testClassNames[i]);\n+\n+    savedBytes[i].klass = env->FindClass(testClassNames[i]);\n+    if (savedBytes[i].klass == nullptr) {\n+      _log(\"Load error\\n\");\n+      result = JNI_FALSE;\n+      continue;\n+    }\n+    savedBytes[i].klass = (jclass)env->NewGlobalRef(savedBytes[i].klass);\n+\n+    _log(\"Retransforming %s...\\n\", testClassNames[i]);\n+    jvmtiError err = jvmti->RetransformClasses(1, &savedBytes[i].klass);\n+    if (err != JVMTI_ERROR_NONE) {\n+      _log(\"RetransformClasses error %d\\n\", err);\n+      result = JNI_FALSE;\n+    }\n+  }\n+  _log(\"<<nTest\\n\");\n+  return result;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_MissedStackMapFrames_testCount(JNIEnv* env, jclass klass) {\n+  return testClassCount;\n+}\n+\n+JNIEXPORT jclass JNICALL\n+Java_MissedStackMapFrames_testClass(JNIEnv* env, jclass klass, jint idx) {\n+  return savedBytes[idx].klass;\n+}\n+\n+JNIEXPORT jbyteArray JNICALL\n+Java_MissedStackMapFrames_loadBytes(JNIEnv* env, jclass klass, jint idx) {\n+  return savedBytes[idx].load.get(env);\n+}\n+\n+JNIEXPORT jbyteArray JNICALL\n+Java_MissedStackMapFrames_retransformBytes(JNIEnv* env, jclass klass, jint idx) {\n+  return savedBytes[idx].retransform.get(env);\n+}\n+\n+} \/\/ extern \"C\"\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/MissedStackMapFrames\/libMissedStackMapFrames.cpp","additions":223,"deletions":0,"binary":false,"changes":223,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,0 +89,7 @@\n+\n+    \/\/ The IR framework will compile this method with C1 at level 2 (with limited profiling information) after the\n+    \/\/ warm-up iterations are done.\n+    @Test(compLevel = CompLevel.C1_LIMITED_PROFILE)\n+    public void basicTestCompileWithC1() {\n+        iFld = 34;\n+    }\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/examples\/BaseTestExample.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,1 @@\n-    \/\/ This version of @Run passes the RunInfo object as an argument. No other arguments and combiniations are allowed.\n+    \/\/ This version of @Run passes the RunInfo object as an argument. No other arguments and combinations are allowed.\n@@ -106,2 +106,7 @@\n-    public void runWithRunInfo() {\n-        \/\/ We could also skip some invocations. This might have an influence on possible @IR rules, need to be careful.\n+    public void runWithRunInfo(RunInfo runInfo) {\n+        \/\/ We could invoke a test multiple times or even skip some invocations completely. This might have an influence\n+        \/\/ on profiling and possible @IR rules as the graph could be different.\n+        if (runInfo.isWarmUp()) {\n+            \/\/ Do something only when warming this method up (i.e. the IR framework has not queued this method for\n+            \/\/ compilation, yet).\n+        }\n@@ -109,1 +114,1 @@\n-            int returnValue = test(34);\n+            int returnValue = test2(34);\n@@ -131,0 +136,17 @@\n+    @Test\n+    public int test3a(int x) {\n+        return x;\n+    }\n+\n+    \/\/ To simulate -Xcomp, we can specify a zero warm-up. The IR framework directly compiles the @Test method test3a()\n+    \/\/ before any invocation of it (called over this @Run method). Afterwards the IR framework invokes the @Run method\n+    \/\/ exactly once.\n+    @Run(test = \"test3a\")\n+    @Warmup(0)\n+    public void runSimulateXcomp() {\n+        int returnValue = test3a(34);\n+        if (returnValue != 34) {\n+            throw new RuntimeException(\"Must match\");\n+        }\n+    }\n+\n@@ -168,0 +190,25 @@\n+\n+    @Test\n+    public int test7(int x) {\n+        return x;\n+    }\n+\n+    \/\/ RunMode.STANDALONE gives the user full control over how the associated @Test method is compiled: The IR framework\n+    \/\/ only invokes this @Run method once, without any additional warm-up iterations, and does NOT initiate a compilation.\n+    \/\/ This is entirely left to the @Run method to do. When also doing IR matching, it needs to be ensured that a C2\n+    \/\/ compilation is triggered. Otherwise, IR matching will fail due to a missing C2 compilation output to match on.\n+    @Run(test = \"test7\", mode = RunMode.STANDALONE)\n+    public void run() {\n+        final int interpreterResult = test7(34); \/\/ First invocation of test7() with interpreter\n+        int compiledResult = 0;\n+        for (int i = 0; i < 10000; i++) {\n+            compiledResult = test7(34); \/\/ At some point, test7() is normally C1 and C2 compiled.\n+            if (interpreterResult != compiledResult) {\n+                \/\/ At some point, compiledResult is the value returned by C1 compiled code and later C2 compiled code\n+                \/\/ of test7(). These values should always match the value returned by the interpreter.\n+                throw new RuntimeException(\"Different result compared to interpreter run\");\n+            }\n+        }\n+        \/\/ At this point, test7() is definitely C2 compiled due to the high number of invocations in the loop above.\n+        \/\/ There is not further invocation of this method (and hence of test7()).\n+    }\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/examples\/CustomRunTestExample.java","additions":52,"deletions":5,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -181,0 +181,16 @@\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_I, \"1\"}) \/\/ Should work but since we do not invoke the method enough times, we fail.\n+    public void testNotCompiled() {\n+        iFld2 = 34;\n+    }\n+\n+    \/\/ RunMode.STANDALONE gives the user full control over how the associated @Test method is compiled: The IR framework\n+    \/\/ only invokes this @Run method once, without any additional warm-up iterations, and does NOT initiate a compilation.\n+    \/\/ This is entirely left to the @Run method to do. Since we invoke the @Test method testNotCompiled() only once, this\n+    \/\/ is not enough to normally trigger a C2 compilation. IR matching fails since there is no C2 compilation output.\n+    \/\/ To fix that, we would need to invoke testNotCompiled() enough times to trigger a C2 compilation.\n+    @Run(test = \"testNotCompiled\", mode = RunMode.STANDALONE)\n+    public void badStandAloneNotCompiled() {\n+        testNotCompiled();\n+    }\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/examples\/IRExample.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -212,0 +212,10 @@\n+                if (invThr.isAlive()) {\n+                    \/\/ The join failed because the invoke never completed.\n+                    log.complain(\"TEST FAILED: invoke never completed\");\n+                    tot_res = Consts.TEST_FAILED;\n+                    \/\/ Do a vm.resume() to see if that helps.\n+                    vm.resume();\n+                    invThr.join(); \/\/ let test time out if this fails\n+                    return quitDebuggee();\n+                }\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ClassType\/invokeMethod\/invokemethod011.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,0 +90,5 @@\n+        \/*\n+         * WARNING: Since this method is called using INVOKE_SINGLE_THREADED, we need to\n+         * be careful not to do anything that might block on another thread. That includes\n+         * calling Thread.sleep(), which can be a problem for virtual threads.\n+         *\/\n@@ -94,1 +99,0 @@\n-            Thread.currentThread().sleep(400);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ClassType\/invokeMethod\/invokemethod011t.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -205,0 +205,9 @@\n+            if (invThr.isAlive()) {\n+                \/\/ The join failed because the invoke never completed.\n+                log.complain(\"TEST FAILED: invoke never completed\");\n+                tot_res = Consts.TEST_FAILED;\n+                \/\/ Do a vm.resume() to see if that helps.\n+                vm.resume();\n+                invThr.join(); \/\/ let test time out if this fails\n+                return quitDebuggee();\n+            }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ClassType\/invokeMethod\/invokemethod012.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,0 +92,5 @@\n+        \/*\n+         * WARNING: Since this method is called using INVOKE_SINGLE_THREADED, we need to\n+         * be careful not to do anything that might block on another thread. That includes\n+         * calling Thread.sleep(), which can be a problem for virtual threads.\n+         *\/\n@@ -96,1 +101,0 @@\n-            Thread.currentThread().sleep(400);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ClassType\/invokeMethod\/invokemethod012t.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -207,0 +207,9 @@\n+            if (invThr.isAlive()) {\n+                \/\/ The join failed because the invoke never completed.\n+                log.complain(\"TEST FAILED: invoke never completed\");\n+                tot_res = Consts.TEST_FAILED;\n+                \/\/ Do a vm.resume() to see if that helps.\n+                vm.resume();\n+                invThr.join(); \/\/ let test time out if this fails\n+                return quitDebuggee();\n+            }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ClassType\/invokeMethod\/invokemethod013.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,0 +91,5 @@\n+        \/*\n+         * WARNING: Since this method is called using INVOKE_SINGLE_THREADED, we need to\n+         * be careful not to do anything that might block on another thread. That includes\n+         * calling Thread.sleep(), which can be a problem for virtual threads.\n+         *\/\n@@ -95,1 +100,0 @@\n-            Thread.currentThread().sleep(400);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ClassType\/invokeMethod\/invokemethod013t.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -209,0 +209,10 @@\n+                if (invThr.isAlive()) {\n+                    \/\/ The join failed because the invoke never completed.\n+                    log.complain(\"TEST FAILED: invoke never completed\");\n+                    tot_res = Consts.TEST_FAILED;\n+                    \/\/ Do a vm.resume() to see if that helps.\n+                    vm.resume();\n+                    invThr.join(); \/\/ let test time out if this fails\n+                    return quitDebuggee();\n+                }\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ObjectReference\/invokeMethod\/invokemethod010.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -184,0 +184,5 @@\n+        \/*\n+         * WARNING: Since this method is called using INVOKE_SINGLE_THREADED, we need to\n+         * be careful not to do anything that might block on another thread. That includes\n+         * calling Thread.sleep(), which can be a problem for virtual threads.\n+         *\/\n@@ -188,1 +193,0 @@\n-            Thread.currentThread().sleep(400);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ObjectReference\/invokeMethod\/invokemethod010t.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -209,0 +209,10 @@\n+                if (invThr.isAlive()) {\n+                    \/\/ The join failed because the invoke never completed.\n+                    log.complain(\"TEST FAILED: invoke never completed\");\n+                    tot_res = Consts.TEST_FAILED;\n+                    \/\/ Do a vm.resume() to see if that helps.\n+                    vm.resume();\n+                    invThr.join(); \/\/ let test time out if this fails\n+                    return quitDebuggee();\n+                }\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ObjectReference\/invokeMethod\/invokemethod011.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -184,0 +184,5 @@\n+        \/*\n+         * WARNING: Since this method is called using INVOKE_SINGLE_THREADED, we need to\n+         * be careful not to do anything that might block on another thread. That includes\n+         * calling Thread.sleep(), which can be a problem for virtual threads.\n+         *\/\n@@ -188,1 +193,0 @@\n-            Thread.currentThread().sleep(400);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ObjectReference\/invokeMethod\/invokemethod011t.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -209,0 +209,9 @@\n+            if (invThr.isAlive()) {\n+                \/\/ The join failed because the invoke never completed.\n+                log.complain(\"TEST FAILED: invoke never completed\");\n+                tot_res = Consts.TEST_FAILED;\n+                \/\/ Do a vm.resume() to see if that helps.\n+                vm.resume();\n+                invThr.join(); \/\/ let test time out if this fails\n+                return quitDebuggee();\n+            }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ObjectReference\/invokeMethod\/invokemethod012.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -184,0 +184,5 @@\n+        \/*\n+         * WARNING: Since this method is called using INVOKE_SINGLE_THREADED, we need to\n+         * be careful not to do anything that might block on another thread. That includes\n+         * calling Thread.sleep(), which can be a problem for virtual threads.\n+         *\/\n@@ -188,1 +193,0 @@\n-            Thread.currentThread().sleep(400);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ObjectReference\/invokeMethod\/invokemethod012t.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -210,0 +210,9 @@\n+            if (invThr.isAlive()) {\n+                \/\/ The join failed because the invoke never completed.\n+                log.complain(\"TEST FAILED: invoke never completed\");\n+                tot_res = Consts.TEST_FAILED;\n+                \/\/ Do a vm.resume() to see if that helps.\n+                vm.resume();\n+                invThr.join(); \/\/ let test time out if this fails\n+                return quitDebuggee();\n+            }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ObjectReference\/invokeMethod\/invokemethod013.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -183,0 +183,5 @@\n+        \/*\n+         * WARNING: Since this method is called using INVOKE_SINGLE_THREADED, we need to\n+         * be careful not to do anything that might block on another thread. That includes\n+         * calling Thread.sleep(), which can be a problem for virtual threads.\n+         *\/\n@@ -187,1 +192,0 @@\n-            Thread.currentThread().sleep(400);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ObjectReference\/invokeMethod\/invokemethod013t.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- *     Single thread loads a tree of classes with signle loader.\n+ *     Single thread loads a tree of classes with single loader.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree002\/btree002.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- *     Multiple threads load a tree of classes with signle loader.\n+ *     Multiple threads load a tree of classes with single loader.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree005\/btree005.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- *     Single thread loads a tree of classes with signle loader.\n+ *     Single thread loads a tree of classes with single loader.\n@@ -54,0 +54,1 @@\n+ *      -t 1\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree008\/btree008.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- *     Multiple threads load a tree of classes with signle loader.\n+ *     Multiple threads load a tree of classes with single loader.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree011\/btree011.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -526,2 +526,0 @@\n-javax\/management\/remote\/mandatory\/notif\/NotifReconnectDeadlockTest.java 8042215 generic-all\n-\n@@ -589,3 +587,0 @@\n-javax\/net\/ssl\/SSLEngine\/EngineCloseOnAlert.java                 8298868 generic-all\n-javax\/net\/ssl\/SSLEngine\/CheckStatus.java                        8298872 generic-all\n-\n@@ -618,1 +613,0 @@\n-java\/security\/Policy\/Root\/Root.java                             8299994 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -638,1 +638,2 @@\n-    sun\/security\/tools\/jarsigner\/compatibility\/Compatibility.java\n+    sun\/security\/tools\/jarsigner\/compatibility\/Compatibility.java \\\n+    java\/security\/Policy\/Root\/Root.java\n","filename":"test\/jdk\/TEST.groups","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @requires (os.family == \"windows\") & (vm.compMode != \"Xcomp\") & (vm.compMode != \"Xint\")\n+ * @requires (os.family == \"windows\") & (vm.compMode != \"Xcomp\") & (vm.compMode != \"Xint\") & (vm.gc != \"Z\")\n@@ -66,1 +66,1 @@\n-            System.out.println(lastError);\n+            System.out.println(\"lastError = \" + lastError);\n@@ -68,0 +68,2 @@\n+                System.err.println(\"iteration \" + i + \" got lastError = \" + lastError\n+                                   + \" (expected \" + VALUE + \")\");\n@@ -95,1 +97,3 @@\n-        new OutputAnalyzer(jdb.getJdbOutput()).shouldMatch(\"The application exited\");\n+        \/\/ Good lastError should be reported in debuggee output:\n+        new OutputAnalyzer(getDebuggeeOutput()).shouldMatch(\"lastError = \" + Integer.toString(TestNativeLastError.VALUE));\n+        \/\/ Exception would be captured in jdb output:\n","filename":"test\/jdk\/com\/sun\/jdi\/JdbLastErrorTest.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,4 +30,4 @@\n- * @run testng\/othervm DumpThreads\n- * @run testng\/othervm -Djdk.trackAllThreads DumpThreads\n- * @run testng\/othervm -Djdk.trackAllThreads=true DumpThreads\n- * @run testng\/othervm -Djdk.trackAllThreadds=false DumpThreads\n+ * @run junit\/othervm DumpThreads\n+ * @run junit\/othervm -Djdk.trackAllThreads DumpThreads\n+ * @run junit\/othervm -Djdk.trackAllThreads=true DumpThreads\n+ * @run junit\/othervm -Djdk.trackAllThreadds=false DumpThreads\n@@ -50,2 +50,2 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -53,1 +53,1 @@\n-public class DumpThreads {\n+class DumpThreads {\n@@ -64,1 +64,1 @@\n-    public void testPlainText() throws Exception {\n+    void testPlainText() throws Exception {\n@@ -101,1 +101,1 @@\n-    public void testJson() throws Exception {\n+    void testJson() throws Exception {\n@@ -121,1 +121,1 @@\n-                assertEquals(threadDump.runtimeVersion(), Runtime.version().toString());\n+                assertEquals(Runtime.version().toString(), threadDump.runtimeVersion());\n@@ -153,1 +153,1 @@\n-    public void testFileAlreadyExsists() throws Exception {\n+    void testFileAlreadyExsists() throws Exception {\n@@ -166,1 +166,1 @@\n-    public void testRelativePath() throws Exception {\n+    void testRelativePath() throws Exception {\n@@ -178,1 +178,1 @@\n-    public void testNull() throws Exception {\n+    void testNull() throws Exception {\n","filename":"test\/jdk\/com\/sun\/management\/HotSpotDiagnosticMXBean\/DumpThreads.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8300268\n+ * @library \/test\/lib\n+ * @modules jdk.httpserver\/sun.net.httpserver\n+ * @build jdk.httpserver\/sun.net.httpserver.HttpServerAccess MaxIdleConnectionsTest\n+ * @run junit\/othervm -Dsun.net.httpserver.maxIdleConnections=4 MaxIdleConnectionsTest\n+ *\/\n+\n+import com.sun.net.httpserver.HttpServer;\n+import jdk.test.lib.net.URIBuilder;\n+import sun.net.httpserver.HttpServerAccess;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.*;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n+public class MaxIdleConnectionsTest {\n+\n+    HttpServer server;\n+    int maxIdleConnections, totalConnections;\n+    CountDownLatch reqFinishedProcessing;\n+\n+    @BeforeAll\n+    void before() throws Exception {\n+        maxIdleConnections = Integer.getInteger(\"sun.net.httpserver.maxIdleConnections\");\n+        totalConnections = maxIdleConnections + 1;\n+        reqFinishedProcessing = new CountDownLatch(totalConnections);\n+        server = startServer(reqFinishedProcessing);\n+    }\n+\n+    @AfterAll\n+    void after() throws Exception {\n+        server.stop(0);\n+    }\n+\n+    \/\/ Issue one too many requests and assert that the idle connection pool doesn't\n+    \/\/ exceed maxIdleConnections\n+    @Test\n+    public void test() throws Exception {\n+        final int port = server.getAddress().getPort();\n+\n+        final List<Future<Void>> responses = new ArrayList<>();\n+        try (final ExecutorService requestIssuer = Executors.newFixedThreadPool(totalConnections)) {\n+            for (int i = 1; i <= totalConnections; i++) {\n+                URL requestURL = URIBuilder.newBuilder()\n+                        .scheme(\"http\")\n+                        .loopback()\n+                        .port(port)\n+                        .path(\"\/MaxIdleConnectionTest\/\" + i)\n+                        .toURL();\n+                final Future<Void> result = requestIssuer.submit(() -> {\n+                    System.out.println(\"Issuing request \" + requestURL);\n+                    final URLConnection conn = requestURL.openConnection();\n+                    try (final InputStream is = conn.getInputStream()) {\n+                        is.readAllBytes();\n+                    }\n+                    return null;\n+                });\n+                responses.add(result);\n+            }\n+            \/\/ wait for all the requests to reach each of the handlers\n+            System.out.println(\"Waiting for all \" + totalConnections + \" requests to reach\" +\n+                    \" the server side request handler\");\n+            reqFinishedProcessing.await();\n+        }\n+\n+        \/\/ verify every request got served before checking idle count\n+        for (int i = 0; i < totalConnections; i++) {\n+            responses.get(i).get();\n+            System.out.println(\"Received successful response for request \" + i);\n+        }\n+\n+        \/\/ assert that the limit set by maxIdleConnections was not exceeded\n+        int idleConnectionCount = HttpServerAccess.getIdleConnectionCount(server);\n+        System.out.println(\"count \" + idleConnectionCount);\n+        assertTrue(maxIdleConnections >= idleConnectionCount,\n+                String.format(\"Too many idle connections: %d, limit: %d\", idleConnectionCount, maxIdleConnections));\n+    }\n+\n+    \/\/ Create HttpServer that will handle requests with multiple threads\n+    private static HttpServer startServer(final CountDownLatch reqFinishedProcessing) throws IOException {\n+        final var bindAddr = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n+        final HttpServer server = HttpServer.create(bindAddr, 0);\n+\n+        final AtomicInteger threadId = new AtomicInteger();\n+        server.setExecutor(Executors.newCachedThreadPool(r -> {\n+            final Thread t = new Thread(r);\n+            t.setName(\"http-request-handler-\" + threadId.incrementAndGet());\n+            t.setDaemon(true);\n+            return t;\n+        }));\n+\n+        server.createContext(\"\/MaxIdleConnectionTest\/\", (exchange) -> {\n+            System.out.println(\"Request \" + exchange.getRequestURI() + \" received\");\n+            System.out.println(\"Sending response for request \" + exchange.getRequestURI() + \" from \" + exchange.getRemoteAddress());\n+            reqFinishedProcessing.countDown();\n+            exchange.sendResponseHeaders(200, 0);\n+            exchange.getResponseBody().close();\n+        });\n+\n+        server.start();\n+        System.out.println(\"Server started at address \" + server.getAddress());\n+        return server;\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/bugs\/8300268\/MaxIdleConnectionsTest.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.net.httpserver;\n+\n+import com.sun.net.httpserver.HttpServer;\n+import java.lang.reflect.Field;\n+import java.util.Set;\n+\n+public class HttpServerAccess {\n+\n+   \/\/ Given a HttpServer object get the number of idleConnections it currently has\n+    public static int getIdleConnectionCount(HttpServer server) throws Exception{\n+        \/\/ Use reflection to get server object which is HTTPServerImpl\n+        Field serverField = server.getClass().getDeclaredField(\"server\");\n+        serverField.setAccessible(true);\n+\n+        \/\/ Get the actual serverImpl class, then get the IdleConnection Field\n+        Object serverImpl = serverField.get(server);\n+        Field idleConnectionField = serverImpl.getClass().getDeclaredField(\"idleConnections\");\n+        idleConnectionField.setAccessible(true);\n+\n+        \/\/ Finally get the IdleConnection object which is of type Set<HttpConnection>\n+        Object idleConnectionSet = idleConnectionField.get(serverImpl);\n+        Set<HttpConnection> idleConnectionPool = (Set<HttpConnection>) idleConnectionSet;\n+        return idleConnectionPool.size();\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/bugs\/8300268\/jdk.httpserver\/sun\/net\/httpserver\/HttpServerAccess.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -1,5 +0,0 @@\n-grant {\n-    permission java.lang.RuntimePermission \"accessClassInPackage.sun.awt\";\n-    permission java.awt.AWTPermission \"createRobot\";\n-    permission java.util.PropertyPermission \"AWT.EventQueueClass\", \"read\";\n-};\n","filename":"test\/jdk\/java\/awt\/AppContext\/ApplicationThreadsStop\/java.policy","additions":0,"deletions":5,"binary":false,"changes":5,"status":"deleted"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Button;\n+import java.awt.Color;\n+import java.awt.Dialog;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.image.BufferedImage;\n+import java.lang.reflect.InvocationTargetException;\n+import javax.swing.SwingUtilities;\n+\n+\/*\n+ * @test\n+ * @bug 6435804\n+ * @summary REGRESSION: NetBeans 5.0 icon no longer shows up when you alt-tab on XP\n+ * @key headful\n+ * @requires (os.family != \"mac\")\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual ALTTABIconBeingErased\n+ *\/\n+\n+public class ALTTABIconBeingErased {\n+\n+    private static final String INSTRUCTIONS =\n+            \"This test verifies that the Frame's icon is not corrupted after showing\\n\"\n+                    + \"and disposing owned dialog\\n\"\n+                    + \"You would see a button in a Frame.\\n\"\n+                    + \"1) The frame should have icon with 2 black and 2 white squares.\\n\"\n+                    + \"2) Verify that icon appearing on ALT-TAB is also a\\n\"\n+                    + \"light icon.\\n\"\n+                    + \"3) Now open a child by pressing on \\\"Open Child\\\" button.\\n\"\n+                    + \"Child Dialog should appear. It should have the same icon as frame.\\n\"\n+                    + \"4) Now close the dialog by pressing Space or clicking on a button in it.\\n\"\n+                    + \"Dialog should be disposed now.\\n\"\n+                    + \"5) Verify that icon on ALT-TAB is the same as before\";\n+\n+    private static Frame frame;\n+    private static final int SIZE = 300;\n+\n+    private static void updateIconImage() {\n+        BufferedImage image = new BufferedImage(SIZE, SIZE, BufferedImage.TYPE_INT_ARGB);\n+\n+        Graphics gr = image.createGraphics();\n+        gr.setColor(Color.WHITE);\n+        gr.fillRect(0, 0, SIZE, SIZE);\n+\n+        gr.setColor(Color.BLACK);\n+        gr.fillRect(0, 0, SIZE \/ 2, SIZE \/ 2);\n+        gr.fillRect(SIZE \/ 2, SIZE \/ 2, SIZE, SIZE);\n+\n+        frame.setIconImage(image);\n+    }\n+\n+    private static void createAndShowGUI(){\n+        frame = new Frame();\n+        Button setImageButton5 = new Button(\"Open Child\");\n+        updateIconImage();\n+\n+        setImageButton5.addActionListener(event -> {\n+            try {\n+                final Dialog d1 = new Dialog(frame, true);\n+                d1.setSize(100, 100);\n+                Button ok = new Button(\"OK\");\n+                ok.addActionListener(e -> {\n+                        d1.setVisible(false);\n+                        d1.dispose();\n+                });\n+                d1.add(ok);\n+                d1.setLocation(frame.getX(), frame.getY() + 70);\n+                d1.setVisible(true);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Test failed because of\" +\n+                        \" exception\" + e + \". Press Fail.\");\n+            }\n+        });\n+\n+        frame.add(setImageButton5, BorderLayout.CENTER);\n+        frame.setSize(200,65);\n+\n+        PassFailJFrame.addTestWindow(frame);\n+        PassFailJFrame.positionTestWindow(frame,\n+                PassFailJFrame.Position.HORIZONTAL);\n+        frame.setVisible(true);\n+    }\n+\n+    public static void main(String[] args) throws InterruptedException,\n+                                                  InvocationTargetException {\n+        PassFailJFrame passFailJFrame = new PassFailJFrame(\"Large Icon \" +\n+                \"Test Instructions\", INSTRUCTIONS, 5, 12, 50);\n+        SwingUtilities.invokeAndWait(ALTTABIconBeingErased::createAndShowGUI);\n+        passFailJFrame.awaitAndCheck();\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Frame\/ALTTABIconBeingErased\/ALTTABIconBeingErased.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -0,0 +1,209 @@\n+\/*\n+ * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Dialog;\n+import java.awt.Frame;\n+import java.awt.Graphics2D;\n+import java.awt.Image;\n+import java.awt.Rectangle;\n+import java.awt.Window;\n+import java.awt.image.BufferedImage;\n+import java.lang.reflect.InvocationTargetException;\n+import javax.swing.ImageIcon;\n+import javax.swing.JLabel;\n+import javax.swing.SwingUtilities;\n+\n+import static java.awt.image.BufferedImage.TYPE_INT_ARGB;\n+import static jdk.test.lib.Platform.isWindows;\n+\n+\/*\n+ * @test\n+ * @bug 6415057\n+ * @summary Tests if toplevel's icons are updated in runtime\n+ * @key headful\n+ * @requires (os.family == \"windows\")\n+ * @modules java.desktop\/sun.awt\n+ * @library \/java\/awt\/regtesthelpers \/test\/lib\n+ * @build PassFailJFrame jdk.test.lib.Platform\n+ * @run main\/manual IconChangingTest\n+ *\/\n+\n+public class IconChangingTest {\n+    private static final int ICON_SIZE = 16;\n+    private static final int MARGIN = 2;\n+    private static final int STACK_SIZE = 4;\n+    \/\/ Number of windows per stack\n+    private static final int WIN_PER_STACK = 4;\n+    private static int windowPosX = 0;\n+\n+    private static final int EXTRA_OFFSET = 50;\n+\n+    private static ImageIcon ii1;\n+    private static ImageIcon ii2;\n+    private static ImageIcon ji;\n+\n+    private static final Window[][] windowStack = new Window[STACK_SIZE][WIN_PER_STACK];\n+    private static final JLabel[][] labels = new JLabel[STACK_SIZE][WIN_PER_STACK];\n+    private static final boolean[][] isResizable = new boolean[][]{\n+            {true, true, false, true},   \/\/stack 1\n+            {true, false, true, false},  \/\/stack 2\n+            {true, false, true, true},   \/\/stack 3\n+            {false, true, false, false}  \/\/stack 4\n+    };\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+            The test is supposed to work on Windows.\n+            It may not work on other platforms.\n+\n+            Icons and window decorations should change in windows\n+            (frames & dialogs) every 3 seconds.\n+\n+            Notes:\n+\n+              * Icons might appear in grayscale.\n+              * Default icon might be either Duke or Java Cup.\n+\n+            Press PASS if the icons match the labels\n+            and are shown correctly, FAIL otherwise.\n+            \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame passFailJFrame = new PassFailJFrame(\"Icon Changing \" +\n+                \"Test Instructions\", INSTRUCTIONS, 5, 18, 40);\n+        SwingUtilities.invokeAndWait(() -> {\n+            try {\n+                createAndShowGUI();\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Error while running the test\", e);\n+            }\n+        });\n+        passFailJFrame.awaitAndCheck();\n+    }\n+\n+    private static void createAndShowGUI() throws InterruptedException,\n+                                                  InvocationTargetException {\n+        PassFailJFrame.positionTestWindow(null,\n+                PassFailJFrame.Position.TOP_LEFT_CORNER);\n+        Rectangle bounds = PassFailJFrame.getInstructionFrameBounds();\n+        windowPosX = bounds.x + bounds.width;\n+\n+        ii1 = new ImageIcon(generateIcon(Color.RED));\n+        ii2 = new ImageIcon(generateIcon(Color.BLUE));\n+        ji = new ImageIcon(IconChangingTest.class.getResource(\"java-icon16.png\"));\n+\n+        \/\/ Creates STACK_SIZE different combinations of window stacks,\n+        \/\/ each stack contains WIN_PER_STACK windows (frame\/dialog).\n+        for (int i = 0; i < STACK_SIZE; i++) {\n+            for (int j = 0; j < WIN_PER_STACK; j++) {\n+                createWindow(i, j);\n+            }\n+        }\n+\n+        Thread thread = new Thread(new Runnable() {\n+            private final ImageIcon[][] icons = {\n+                    {null, ii1},\n+                    {ii2, null},\n+                    {ii1, ii2}\n+            };\n+\n+            @Override\n+            public void run() {\n+                int index = 0;\n+                while (true) {\n+                    try {\n+                        setIcons(icons[index][0], icons[index][1]);\n+                        Thread.sleep(4000);\n+                        if (++index >= icons.length) {\n+                            index = 0;\n+                        }\n+                    } catch (InterruptedException e) {\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            private static void setIcons(final ImageIcon icon1, final ImageIcon icon2) {\n+                Image i1 = (icon1 == null) ? null : icon1.getImage();\n+                Image i2 = (icon2 == null) ? null : icon2.getImage();\n+                ImageIcon li1 = (icon1 == null) ? ji : icon1;\n+                ImageIcon li2 = (icon2 == null) ? li1 : icon2;\n+\n+                ImageIcon[][] iconList = new ImageIcon[][]{\n+                    {li1, li1, ((i2 == null && isWindows()) ? null : li2), li2},\n+                    {li1, (isWindows()) ? null : li1, li2, (isWindows()) ? null : li2},\n+                    {li1, (isWindows()) ? null : li1, li2, li2},\n+                    {li1, li1, (i2 == null && isWindows()) ? null : li2, (isWindows()) ? null : li2},\n+                };\n+\n+                for (int i = 0; i < STACK_SIZE; i++) {\n+                    windowStack[i][0].setIconImage(i1);\n+                    windowStack[i][2].setIconImage(i2);\n+                    for (int j = 0; j < WIN_PER_STACK; j++) {\n+                        labels[i][j].setIcon(iconList[i][j]);\n+                    }\n+                }\n+            }\n+        });\n+        thread.start();\n+    }\n+\n+    private static void createWindow(int i, int j) {\n+        boolean isFrame = (i == 0 && j == 0) || (i == 1 && j == 0);\n+        String title = (isFrame ? \"Frame \": \"Dialog \") + (i+1) + \".\" + (j+1);\n+\n+        windowStack[i][j] = isFrame\n+                            ? createFrame(title, i, j)\n+                            : createDialog(title, i, j);\n+\n+        labels[i][j]= new JLabel(title);\n+        windowStack[i][j].add(labels[i][j]);\n+        windowStack[i][j].setBounds(windowPosX + (i * 200), (j * 100) + EXTRA_OFFSET,\n+                             200, 100);\n+        windowStack[i][j].toFront();\n+        windowStack[i][j].setVisible(true);\n+\n+        PassFailJFrame.addTestWindow(windowStack[i][j]);\n+    }\n+\n+    private static Frame createFrame(String title, int i, int j) {\n+        Frame frame = new Frame(title);\n+        frame.setResizable(isResizable[i][j]);\n+        return frame;\n+    }\n+\n+    private static Dialog createDialog(String title, int i, int j) {\n+        Dialog dialog = new Dialog((j == 0 ? null : windowStack[i][j-1]), title);\n+        dialog.setResizable(isResizable[i][j]);\n+        return dialog;\n+    }\n+\n+    private static Image generateIcon(Color color) {\n+        BufferedImage bImg = new BufferedImage(ICON_SIZE, ICON_SIZE, TYPE_INT_ARGB);\n+        Graphics2D g2d = bImg.createGraphics();\n+        g2d.setColor(color);\n+        g2d.fillRect(MARGIN, MARGIN, ICON_SIZE - 2 * MARGIN, ICON_SIZE - 2 * MARGIN);\n+        g2d.dispose();\n+        return bImg;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Icon\/IconChangingTest\/IconChangingTest.java","additions":209,"deletions":0,"binary":false,"changes":209,"status":"added"},{"patch":"","filename":"test\/jdk\/java\/awt\/Icon\/IconChangingTest\/java-icon16.png","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/java-icon16.png","status":"copied"},{"patch":"@@ -0,0 +1,280 @@\n+\/*\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.AlphaComposite;\n+import java.awt.Color;\n+import java.awt.Dialog;\n+import java.awt.Font;\n+import java.awt.Frame;\n+import java.awt.GradientPaint;\n+import java.awt.Graphics2D;\n+import java.awt.GridLayout;\n+import java.awt.Image;\n+import java.awt.Rectangle;\n+import java.awt.RenderingHints;\n+import java.awt.Window;\n+import java.awt.image.BaseMultiResolutionImage;\n+import java.awt.image.BufferedImage;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.swing.ImageIcon;\n+import javax.swing.JLabel;\n+import javax.swing.SwingUtilities;\n+\n+import static java.awt.image.BufferedImage.TYPE_INT_ARGB;\n+import static jdk.test.lib.Platform.isWindows;\n+\n+\/*\n+ * @test\n+ * @bug 6233560 6280303 6292933\n+ * @summary Tests if toplevel's icons are shown correctly\n+ * @key headful\n+ * @requires (os.family == \"windows\")\n+ * @library \/java\/awt\/regtesthelpers \/test\/lib\n+ * @build PassFailJFrame jdk.test.lib.Platform\n+ * @run main\/manual IconShowingTest\n+ *\/\n+\n+public class IconShowingTest {\n+    private static final int EXTRA_OFFSET = 50;\n+\n+    private static final String INSTRUCTIONS =\n+            \"Look at the icons shown on frames and dialogs, icons of minimized frames\\n\"\n+            + (isWindows() ? \"are displayed in ALT+TAB window\\n\" : \"\") + \"\\n\"+\n+            \"\"\"\n+            Alpha-channel (transparency) should be supported\n+            by Windows and may not be supported by other platforms.\n+\n+            Notes:\n+              * Icons might appear in grayscale.\n+              * Default icon might be either Duke or Java Cup.\n+\n+            Press PASS if the icons match label description in windows\n+            and are shown correctly, FAIL otherwise.\n+            \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame passFailJFrame = new PassFailJFrame(\"Icon Showing \" +\n+                \"Test Instructions\", INSTRUCTIONS, 5, 18, 48);\n+        SwingUtilities.invokeAndWait(() -> {\n+            try {\n+                createAndShowGUI();\n+            } catch (Exception e) {\n+               throw new RuntimeException(\"Error while running the test\", e);\n+            }\n+        });\n+        passFailJFrame.awaitAndCheck();\n+    }\n+\n+    public static void createAndShowGUI()\n+            throws InterruptedException, InvocationTargetException {\n+        Image i_16 = createIcon(16, 8, \"16\");\n+        Image i_32 = createIcon(32, 14, \"32\");\n+        Image i_48 = createIcon(48, 24, \"48\");\n+        Image i_64 = createIcon(64, 30, \"64\");\n+\n+        ImageIcon ji_16 = new ImageIcon(IconShowingTest.class.getResource(\n+                \"java-icon16.png\"));\n+\n+        Image[] images = new Image[] {i_16, i_32, i_48, i_64};\n+        List<Image> imageList = Arrays.asList(images);\n+        ImageIcon icon = new ImageIcon(new MRImage(images));\n+\n+        Frame f1 = new Frame(\"Frame 1\");\n+        f1.setIconImages(imageList);\n+        f1.setLayout(new GridLayout(0, 1));\n+\n+        f1.add(new JLabel(\"Icon 16x16\", new ImageIcon(i_16), JLabel.CENTER));\n+        f1.add(new JLabel(\"Icon 32x32\", new ImageIcon(i_32), JLabel.CENTER));\n+        f1.add(new JLabel(\"Icon 48x48\", new ImageIcon(i_48), JLabel.CENTER));\n+        f1.add(new JLabel(\"Icon 64x64\", new ImageIcon(i_64), JLabel.CENTER));\n+\n+        PassFailJFrame.positionTestWindow(null,\n+                PassFailJFrame.Position.TOP_LEFT_CORNER);\n+        Rectangle bounds = PassFailJFrame.getInstructionFrameBounds();\n+\n+        int windowPosX = bounds.x + bounds.width + 5;\n+        f1.setBounds(windowPosX, EXTRA_OFFSET, 200, 300);\n+        f1.setVisible(true);\n+        f1.toFront();\n+        PassFailJFrame.addTestWindow(f1);\n+        int windowPosY = f1.getY() + f1.getHeight();\n+\n+\n+        Dialog d11 = new Dialog(f1, \"Dialog 1.1\");\n+        d11.setResizable(false);\n+        addIconAndLabelToWindow(d11, windowPosX, windowPosY - EXTRA_OFFSET,\n+                (isWindows() ? \"No icon, non-resizable dialog\"\n+                             : \"Inherited icon, non-resizable dialog\"),\n+                (isWindows() ? null : icon));\n+\n+        Dialog d12 = new Dialog(d11, \"Dialog 1.2\");\n+        addIconAndLabelToWindow(d12, windowPosX, windowPosY + EXTRA_OFFSET,\n+                \"Inherited icon, resizable dialog\", icon);\n+\n+        Frame f2 = new Frame(\"Frame 2\");\n+        addIconAndLabelToWindow(f2, windowPosX + 200, 0,\n+                \"Default Icon\", ji_16);\n+\n+        Dialog d21 = new Dialog(f2, \"Dialog 2.1\");\n+        d21.setResizable(false);\n+        addIconAndLabelToWindow(d21, windowPosX + 200, 100,\n+                (isWindows() ? \"No icon, non-resizable dialog\"\n+                             : \"Inherited default Icon, non-resizable dialog\"),\n+                (isWindows() ? null : ji_16));\n+\n+        Dialog d22 = new Dialog(f2, \"Dialog 2.2\");\n+        addIconAndLabelToWindow(d22, windowPosX + 200, 200,\n+                \"Inherited default Icon, resizable dialog\", ji_16);\n+\n+        Dialog d23 = new Dialog(f2, \"Dialog 2.3\");\n+        d23.setIconImages(imageList);\n+        d23.setResizable(false);\n+        addIconAndLabelToWindow(d23, windowPosX + 200, 300,\n+                \"Modified Icon, non-resizable dialog\", icon);\n+\n+        Dialog d24 = new Dialog(f2, \"Dialog 2.4\");\n+        d24.setIconImages(imageList);\n+        addIconAndLabelToWindow(d24, windowPosX + 200, 400,\n+                \"Modified Icon, resizable dialog\", icon);\n+\n+        Dialog d31 = new Dialog((Frame)null, \"Dialog 3.1\");\n+        addIconAndLabelToWindow(d31, windowPosX + 400, 100,\n+                \"Default icon, resizable dialog\", ji_16);\n+\n+        Dialog d32 = new Dialog(d31, \"Dialog 3.2\");\n+        d32.setResizable(false);\n+        addIconAndLabelToWindow(d32, windowPosX + 400, 200,\n+                (isWindows() ? \"No icon, non-resizable dialog\"\n+                             : \"Default Icon, non-resizable dialog\"),\n+                (isWindows() ? null : ji_16));\n+\n+        Dialog d33 = new Dialog(d31, \"Dialog 3.3\");\n+        d33.setIconImages(imageList);\n+        d33.setResizable(false);\n+        addIconAndLabelToWindow(d33, windowPosX + 400, 300,\n+                \"Modified icon, non-resizable dialog\", icon);\n+\n+\n+        Dialog d34 = new Dialog(d33, \"Dialog 3.4\");\n+        d34.setResizable(false);\n+        addIconAndLabelToWindow(d34, windowPosX + 400, 400,\n+                (isWindows() ? \"No icon, non-resizable dialog\"\n+                             : \"Inherited modified icon, non-resizable dialog\"),\n+                (isWindows() ? null : icon));\n+\n+\n+        Dialog d41 = new Dialog((Frame) null, \"Dialog 4.1\");\n+        d41.setResizable(false);\n+        addIconAndLabelToWindow(d41, windowPosX + 600, 100,\n+                \"Default icon, non-resizable dialog\", ji_16);\n+\n+\n+        Dialog d42 = new Dialog(d41, \"Dialog 4.2\");\n+        addIconAndLabelToWindow(d42, windowPosX + 600, 200,\n+                \"Inherited default icon, resizable dialog\", ji_16);\n+\n+        Dialog d43 = new Dialog(d41, \"Dialog 4.3\");\n+        d43.setIconImages(imageList);\n+        addIconAndLabelToWindow(d43, windowPosX + 600, 300,\n+                \"Modified icon, resizable dialog\", icon);\n+\n+        Dialog d44 = new Dialog(d43, \"Dialog 4.4\");\n+        addIconAndLabelToWindow(d44, windowPosX + 600, 400,\n+                \"Inherited modified icon, resizable dialog\", icon);\n+    }\n+\n+    private static void addIconAndLabelToWindow(Window win, int x, int y,\n+                                                String title, ImageIcon icon) {\n+        win.setBounds(x, (y + EXTRA_OFFSET), 200, 100);\n+        win.add(new JLabel(title, icon, JLabel.CENTER));\n+        win.setVisible(true);\n+        win.toFront();\n+        PassFailJFrame.addTestWindow(win);\n+    }\n+\n+    public static Image createIcon(int size, int fontSize, String value) {\n+        BufferedImage bImg = new BufferedImage(size, size, TYPE_INT_ARGB);\n+        Graphics2D g2d = bImg.createGraphics();\n+\n+        int half = size \/ 2;\n+        for (int i = 0; i < half - 1; i += 2) {\n+            g2d.setComposite(AlphaComposite.Src);\n+            g2d.setColor(Color.RED);\n+            g2d.fillRect(0, i, half, 1);\n+            g2d.setComposite(AlphaComposite.Clear);\n+            g2d.fillRect(0, i + 1, half, 1);\n+        }\n+        g2d.setComposite(AlphaComposite.Clear);\n+        g2d.fillRect(half, 0, half, half);\n+        g2d.setComposite(AlphaComposite.Src);\n+        g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,\n+                RenderingHints.VALUE_TEXT_ANTIALIAS_ON);\n+        g2d.setFont(new Font(\"Dialog\", Font.PLAIN, fontSize));\n+        g2d.setColor(Color.BLUE);\n+        g2d.drawString(value, half - 1, half - 2);\n+\n+        int height = (half + 1) \/ 3;\n+        \/\/ Green\n+        GradientPaint greenGradient = new GradientPaint(0, half - 1, Color.GREEN,\n+                size, half - 1, new Color(0, 255, 0, 0));\n+        g2d.setPaint(greenGradient);\n+        g2d.fillRect(0, half - 1, size, height);\n+\n+        \/\/ Blue\n+        GradientPaint blueGradient = new GradientPaint(0, (half - 1) + height, Color.BLUE,\n+                size, (half - 1) + height, new Color(0, 0, 255, 0));\n+        g2d.setPaint(blueGradient);\n+        g2d.fillRect(0, (half - 1) + height, size, height);\n+\n+        \/\/ Red\n+        GradientPaint redGradient = new GradientPaint(0, (half - 1) + height * 2, Color.RED,\n+                size, (half - 1) + height * 2, new Color(255, 0, 0, 0));\n+        g2d.setPaint(redGradient);\n+        g2d.fillRect(0, (half - 1) + height * 2, size, height);\n+        g2d.dispose();\n+\n+        return bImg;\n+    }\n+\n+    private static class MRImage extends BaseMultiResolutionImage {\n+        public MRImage(Image... resolutionVariants) {\n+            super(resolutionVariants);\n+        }\n+\n+        @Override\n+        public Image getResolutionVariant(double expectedSize, double unused) {\n+            final int size = (int) Math.round(expectedSize \/ 16.0) * 16;\n+            List<Image> imageList = getResolutionVariants();\n+            for (int i = 0; i < imageList.size(); i++) {\n+                if (size == imageList.get(i).getWidth(null)) {\n+                    return imageList.get(i);\n+                } else if (imageList.get(i).getWidth(null) > size) {\n+                    return imageList.get(i > 0 ? i - 1 : i);\n+                }\n+            }\n+            return imageList.get(0); \/\/default\/base image\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Icon\/IconShowingTest\/IconShowingTest.java","additions":280,"deletions":0,"binary":false,"changes":280,"status":"added"},{"patch":"","filename":"test\/jdk\/java\/awt\/Icon\/IconShowingTest\/java-icon16.png","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/java-icon16.png","status":"copied"},{"patch":"@@ -0,0 +1,251 @@\n+\/*\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.AlphaComposite;\n+import java.awt.BorderLayout;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Font;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.RenderingHints;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.IndexColorModel;\n+import java.awt.image.WritableRaster;\n+import java.io.File;\n+import java.io.IOException;\n+\n+import javax.imageio.ImageIO;\n+import javax.swing.Icon;\n+import javax.swing.ImageIcon;\n+import javax.swing.JButton;\n+import javax.swing.JFrame;\n+import javax.swing.JLabel;\n+import javax.swing.SwingUtilities;\n+\n+import static java.awt.image.BufferedImage.TYPE_INT_ARGB;\n+\n+\/*\n+ * @test\n+ * @bug 4987171\n+ * @key headful\n+ * @summary GIF transparency in frame icons not work with Metacity\/GNOME\n+ * @requires (os.family != \"mac\")\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual IconTransparencyTest\n+ *\/\n+\n+public class IconTransparencyTest {\n+    private static final String INSTRUCTIONS = \"\"\"\n+            The icon of the frame and the resized icon in the label should be transparent.\n+            Transparency can be verified by checking if the background color (pink)\n+            is visible in and around icon within the JLabel.\n+\n+            Press continue to view next icon (6 total).\n+            Icon might be presented as grayscale image.\n+\n+            For the 3rd icon in JLabel, the 2nd vertical slot is transparent, hence\n+            the background color (pink) should be visible at the 2nd vertical slot.\n+\n+            For the 4th icon in JLabel, the 5th vertical slot is transparent, hence\n+            the background color (pink) should be visible at the 5th vertical slot.\n+\n+            Press Pass or Fail at the end of test.\n+            \"\"\";\n+\n+    static class TestLabel extends JLabel {\n+        public void paint(Graphics g) {\n+            Dimension d = getSize();\n+            g.setColor(Color.PINK);\n+            g.fillRect(0, 0, d.width, d.height);\n+            Icon icon = getIcon();\n+            if (icon != null) {\n+                icon.paintIcon(this, g, 0, 0);\n+            }\n+            int iw = (icon != null) ? icon.getIconWidth() + 3 : 3;\n+            if (d.width - iw > 0) {\n+                g.setColor(Color.BLACK);\n+                g.drawString(getText(), iw, 16);\n+            }\n+        }\n+    }\n+\n+    static class TestFrame implements ActionListener {\n+        static final int TEST_CNT = 6;\n+        int currTest = 0;\n+        static ImageIcon[] testIcon;\n+\n+        TestLabel label;\n+        JButton button;\n+        static JFrame frame;\n+\n+        final String[] testText = {\n+                \"1st Icon: Size 16x16, GIF\",\n+                \"2nd Icon: Size 48x48, GIF\",\n+                \"3rd Icon: Size 64x64, GIF\",\n+                \"4th Icon: Size 64x64, GIF\",\n+                \"5th Icon: Size 64x64, PNG\",\n+                \"No Icon (system default)\"\n+        };\n+\n+        TestFrame() throws IOException {\n+\n+            generateIcon(16, \"img_16.gif\", 13, 15, 1, \"gif\");\n+            generateIcon(48, \"img_48.gif\", 36, 40, 4, \"gif\");\n+            generateIcon(64, \"img_64.png\", 50, 58, 4, \"png\");\n+\n+            \/\/ gif created with GREEN selected as transparent color index in IndexColorModel\n+            generateGIFWithIndexColorModel(64, \"greenTransparent.gif\", 1);\n+            \/\/ gif created with BLACK selected as transparent color index in IndexColorModel\n+            generateGIFWithIndexColorModel(64, \"blackTransparent.gif\", 4);\n+\n+            testIcon = new ImageIcon[] {\n+                    new ImageIcon(\"img_16.gif\"),\n+                    new ImageIcon(\"img_48.gif\"),\n+                    new ImageIcon(\"greenTransparent.gif\"),\n+                    new ImageIcon(\"blackTransparent.gif\"),\n+                    new ImageIcon(\"img_64.png\"),\n+                    null\n+            };\n+        }\n+\n+        public void createAndShowGUI() {\n+            frame = new JFrame();\n+            \/\/create hint label\n+            label = new TestLabel();\n+            label.setVisible(true);\n+            frame.add(label, BorderLayout.WEST);\n+\n+            \/\/create button\n+            button = new JButton(\"Continue\");\n+            button.setVisible(true);\n+            button.addActionListener(this);\n+            frame.add(button, BorderLayout.EAST);\n+\n+            \/\/show first sample\n+            frame.setIconImage(testIcon[0].getImage());\n+            label.setIcon(testIcon[0]);\n+            label.setText(testText[0]);\n+            frame.pack();\n+\n+            PassFailJFrame.addTestWindow(frame);\n+            PassFailJFrame.positionTestWindow(frame,\n+                    PassFailJFrame.Position.HORIZONTAL);\n+            frame.setVisible(true);\n+        }\n+\n+        public void actionPerformed(ActionEvent event) {\n+            currTest++;\n+            if (currTest < TEST_CNT) {\n+                if (testIcon[currTest] != null) {\n+                    frame.setIconImage(testIcon[currTest].getImage());\n+                } else {\n+                    frame.setIconImage(null);\n+                }\n+\n+                label.setIcon(testIcon[currTest]);\n+                label.setText(testText[currTest]);\n+            } else {\n+                button.setEnabled(false);\n+                button.setText(\"No more icons left.\");\n+            }\n+            frame.revalidate();\n+            frame.pack();\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        TestFrame testFrame = new TestFrame();\n+        PassFailJFrame passFailJFrame = new PassFailJFrame(\"Icon Transparency \" +\n+                \"Test Instructions\", INSTRUCTIONS, 5, 16, 46);\n+        SwingUtilities.invokeAndWait(testFrame::createAndShowGUI);\n+        passFailJFrame.awaitAndCheck();\n+    }\n+\n+    public static void generateIcon(int size, String filename, int fontSize,\n+                                    int yText, int lnHeight, String type) throws IOException {\n+        BufferedImage bImg = new BufferedImage(size, size, TYPE_INT_ARGB);\n+        Graphics2D g2d = bImg.createGraphics();\n+        g2d.setComposite(AlphaComposite.Clear);\n+        g2d.fillRect(0, 0, size, size);\n+\n+        g2d.setComposite(AlphaComposite.Src);\n+        g2d.setColor(Color.BLUE);\n+        g2d.fillRect(0, 0, size, lnHeight);\n+        g2d.setColor(Color.GREEN);\n+        g2d.fillRect(0, lnHeight * 2, size, lnHeight);\n+\n+        g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,\n+                RenderingHints.VALUE_TEXT_ANTIALIAS_OFF);\n+        g2d.setFont(new Font(\"Dialog\", Font.PLAIN, fontSize));\n+        g2d.setColor(Color.RED);\n+        g2d.drawString(\"TR\", 0, yText);\n+        g2d.dispose();\n+\n+        ImageIO.write(bImg, type, new File(filename));\n+    }\n+\n+    protected static void generateGIFWithIndexColorModel(int size, String filename,\n+                                        int transparentColorIndex) throws IOException {\n+        IndexColorModel icm = createIndexedBitmaskColorModel(transparentColorIndex);\n+        BufferedImage img = new BufferedImage(size, size,\n+                BufferedImage.TYPE_BYTE_INDEXED, icm);\n+        int mapSize = icm.getMapSize();\n+        int width = 64 \/ mapSize;\n+\n+        WritableRaster wr = img.getRaster();\n+        for (int i = 0; i < mapSize; i++) {\n+            for (int y = 0; y < 64; y++) {\n+                for (int x = 0; x < width; x++) {\n+                    wr.setSample(i * width + x, y, 0, i);\n+                }\n+            }\n+        }\n+        ImageIO.write(img, \"gif\", new File(filename));\n+    }\n+\n+    protected static IndexColorModel createIndexedBitmaskColorModel(int transparentColorIndex) {\n+        int paletteSize = 8;\n+        byte[] red = new byte[paletteSize];\n+        byte[] green = new byte[paletteSize];\n+        byte[] blue = new byte[paletteSize];\n+\n+        red[0] = (byte)0xff; green[0] = (byte)0x00; blue[0] = (byte)0x00; \/\/red\n+        red[1] = (byte)0x00; green[1] = (byte)0xff; blue[1] = (byte)0x00; \/\/green\n+        red[2] = (byte)0x00; green[2] = (byte)0x00; blue[2] = (byte)0xff; \/\/blue\n+        red[3] = (byte)0xff; green[3] = (byte)0xff; blue[3] = (byte)0xff; \/\/white\n+        red[4] = (byte)0x00; green[4] = (byte)0x00; blue[4] = (byte)0x00; \/\/black\n+        red[5] = (byte)0x80; green[5] = (byte)0x80; blue[5] = (byte)0x80; \/\/grey\n+        red[6] = (byte)0xff; green[6] = (byte)0xff; blue[6] = (byte)0x00; \/\/yellow\n+        red[7] = (byte)0x00; green[7] = (byte)0xff; blue[7] = (byte)0xff; \/\/cyan\n+\n+        int numBits = 3;\n+\n+        return new IndexColorModel(numBits, paletteSize,\n+                red, green, blue, transparentColorIndex);\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/awt\/Icon\/IconTransparencyTest\/IconTransparencyTest.java","additions":251,"deletions":0,"binary":false,"changes":251,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Color;\n+import java.awt.Graphics;\n+import java.awt.Image;\n+import java.awt.image.BufferedImage;\n+import java.util.ArrayList;\n+import javax.swing.JButton;\n+import javax.swing.JFrame;\n+import javax.swing.SwingUtilities;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 6425089\n+ * @summary PIT. Frame does not show a big size jpg image as icon\n+ * @requires (os.family != \"mac\")\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual SetLargeIconTest\n+ *\/\n+\n+public class SetLargeIconTest {\n+    private static final String INSTRUCTIONS = \"\"\"\n+            Case 1: Press \"Pass\" button if this frame does not have icon with green color.\n+\n+            Case 2: Press \"Change to red\" if the frame icon is in green color.\n+            For case 2, press \"Pass\" button if green icon changes to a larger red icon,\n+            press \"Fail\" otherwise.\n+            \"\"\";\n+    private static JFrame frame;\n+\n+    private static void createAndShowGUI() {\n+        frame = new JFrame();\n+\n+        setColoredIcon(Color.green, 128, 128);\n+        JButton btnChangeIcon = new JButton(\"Change to red\");\n+        btnChangeIcon.addActionListener(e -> setColoredIcon(Color.red, 400, 400));\n+\n+        frame.add(btnChangeIcon, BorderLayout.CENTER);\n+        frame.setSize(200,65);\n+\n+        PassFailJFrame.addTestWindow(frame);\n+        PassFailJFrame.positionTestWindow(frame,\n+                PassFailJFrame.Position.HORIZONTAL);\n+        frame.setVisible(true);\n+    }\n+\n+    private static void setColoredIcon(Color color, int width, int height) {\n+        BufferedImage image = new BufferedImage(400, 400, BufferedImage.TYPE_INT_ARGB);\n+        Graphics gr = image.createGraphics();\n+        gr.setColor(color);\n+        gr.fillRect(0, 0, width, height);\n+\n+        ArrayList<Image> imageList = new java.util.ArrayList<>();\n+        imageList.add(image);\n+\n+        frame.setIconImages(imageList);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame passFailJFrame = new PassFailJFrame(\"Large Icon \" +\n+                \"Test Instructions\", INSTRUCTIONS, 5, 8, 50);\n+        SwingUtilities.invokeAndWait(SetLargeIconTest::createAndShowGUI);\n+        passFailJFrame.awaitAndCheck();\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Icon\/SetLargeIconTest\/SetLargeIconTest.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -73,0 +73,2 @@\n+            robot.setAutoDelay(250);\n+            robot.waitForIdle();\n@@ -76,0 +78,1 @@\n+            robot.waitForIdle();\n@@ -103,0 +106,10 @@\n+                    System.out.println(\"Robot.createScreenCapture Expected: \" +\n+                            String.format(\"0x%08X\",rgb));\n+                    System.out.println(\"Robot.createScreenCapture Top Left Actual: \" +\n+                            String.format(\"0x%08X\",image.getRGB(0, 0)));\n+                    System.out.println(\"Robot.createScreenCapture Top Right Actual: \" +\n+                            String.format(\"0x%08X\",image.getRGB(image.getWidth() - 1, 0)));\n+                    System.out.println(\"Robot.createScreenCapture Bottom Right Actual: \" +\n+                            String.format(\"0x%08X\",image.getRGB(image.getWidth() - 1, image.getHeight() - 1)));\n+                    System.out.println(\"Robot.createScreenCapture Top Left Actual: \" +\n+                            String.format(\"0x%08X\",image.getRGB(0, image.getHeight() - 1)));\n","filename":"test\/jdk\/java\/awt\/Multiscreen\/MultiScreenLocationTest\/MultiScreenLocationTest.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.GraphicsEnvironment;\n+import java.awt.Image;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ImageObserver;\n+import java.awt.image.ImageProducer;\n+\n+\/*\n+ * @test id=default\n+ * @bug 8272288\n+ * @key headful\n+ * @summary Broken rendering should be reported by the contentsLost()\n+ *\n+ * @run main\/othervm ReportRenderingError\n+ *\/\n+\n+\/*\n+ * @test id=windows\n+ * @bug 8272288\n+ * @key headful\n+ * @summary Broken rendering should be reported by the contentsLost()\n+ * @requires (os.family == \"windows\")\n+ *\n+ * @run main\/othervm -Dsun.java2d.opengl=True ReportRenderingError\n+ * @run main\/othervm -Dsun.java2d.d3d=True    ReportRenderingError\n+ * @run main\/othervm -Dsun.java2d.d3d=false   ReportRenderingError\n+ *\/\n+\n+\/*\n+ * @test id=macos\n+ * @bug 8272288\n+ * @key headful\n+ * @summary Broken rendering should be reported by the contentsLost()\n+ *\n+ * @requires (os.family == \"mac\")\n+ * @run main\/othervm -Dsun.java2d.opengl=True ReportRenderingError\n+ * @run main\/othervm -Dsun.java2d.metal=True  ReportRenderingError\n+ *\/\n+\n+\/*\n+ * @test id=linux\n+ * @bug 8272288\n+ * @key headful\n+ * @summary Broken rendering should be reported by the contentsLost()\n+ *\n+ * @requires (os.family == \"linux\")\n+ * @run main\/othervm -Dsun.java2d.opengl=True   ReportRenderingError\n+ * @run main\/othervm -Dsun.java2d.xrender=True  ReportRenderingError\n+ * @run main\/othervm -Dsun.java2d.xrender=false ReportRenderingError\n+ *\/\n+public final class ReportRenderingError {\n+\n+    public static void main(String[] args) {\n+        var gc = GraphicsEnvironment.getLocalGraphicsEnvironment()\n+                                    .getDefaultScreenDevice()\n+                                    .getDefaultConfiguration();\n+        var vi = gc.createCompatibleVolatileImage(10, 10);\n+\n+        Image image = new EmptyImage();\n+        BufferedImage snapshot;\n+        int attempt = 0;\n+        do {\n+            vi.validate(gc);\n+            Graphics2D g = vi.createGraphics();\n+            g.setColor(Color.RED);\n+            g.drawImage(image, 0, 0, null); \/\/ <- can cause InvalidPipeException\n+            g.fillRect(0, 0, vi.getWidth(), vi.getHeight());\n+            g.dispose();\n+            snapshot = vi.getSnapshot();\n+        } while (vi.contentsLost() && (++attempt <= 10));\n+\n+        if (vi.contentsLost()) {\n+            System.out.println(\"Content is lost, skip the pixel validation\");\n+        } else {\n+            if (snapshot.getRGB(5, 5) != Color.RED.getRGB()) {\n+                throw new RuntimeException(\"Test failed\");\n+            }\n+        }\n+    }\n+\n+    private static final class EmptyImage extends Image {\n+        @Override\n+        public int getWidth(ImageObserver observer) {\n+            return 10;\n+        }\n+\n+        @Override\n+        public int getHeight(ImageObserver observer) {\n+            return 10;\n+        }\n+\n+        @Override\n+        public ImageProducer getSource() {\n+            return null;\n+        }\n+\n+        @Override\n+        public Graphics getGraphics() {\n+            return null;\n+        }\n+\n+        @Override\n+        public Object getProperty(String name, ImageObserver observer) {\n+            return null;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/image\/VolatileImage\/ReportRenderingError.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -177,0 +177,2 @@\n+            System.out.println(\"Robot.getPixelColor Expected: \" + color);\n+            System.out.println(\"Robot.getPixelColor Actual: \" + screen);\n","filename":"test\/jdk\/java\/awt\/regtesthelpers\/Util.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,3 +26,7 @@\n- * @bug 4851638\n- * @summary Tests for StrictMath.expm1\n- * @compile -Xdiags:verbose Expm1Tests.java\n+ * @bug 4851638 8301396\n+ * @key randomness\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n+ * @build Tests\n+ * @build FdlibmTranslit\n+ * @build Expm1Tests\n@@ -30,0 +34,1 @@\n+ * @summary Tests for StrictMath.expm1\n@@ -31,0 +36,1 @@\n+import jdk.test.lib.RandomFactory;\n@@ -46,1 +52,84 @@\n-    static int testExpm1Case(double input, double expected) {\n+    public static void main(String... args) {\n+        int failures = 0;\n+\n+        failures += testAgainstTranslit();\n+        failures += testExpm1();\n+\n+        if (failures > 0) {\n+            System.err.println(\"Testing expm1 incurred \"\n+                               + failures + \" failures.\");\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    \/\/ Initialize shared random number generator\n+    private static java.util.Random random = RandomFactory.getRandom();\n+\n+    \/**\n+     * Test StrictMath.expm1 against transliteration port of expm1.\n+     *\/\n+    private static int testAgainstTranslit() {\n+        int failures = 0;\n+        double x;\n+\n+        \/\/ Test just above subnormal threshold...\n+        x = Double.MIN_NORMAL;\n+        failures += testRange(x, Math.ulp(x), 1000);\n+\n+        \/\/ ... and just below subnormal threshold ...\n+        x = Math.nextDown(Double.MIN_NORMAL);\n+        failures += testRange(x, -Math.ulp(x), 1000);\n+\n+        \/\/ ... and near 1.0 ...\n+        failures += testRangeMidpoint(1.0, Math.ulp(x), 2000);\n+        \/\/ (Note: probes every-other value less than 1.0 due to\n+        \/\/ change in the size of an ulp at 1.0.\n+\n+        \/\/ Probe near decision points in the FDLIBM algorithm.\n+        double LN2 = StrictMath.log(2.0);\n+        double[] decisionPoints = {\n+             7.09782712893383973096e+02, \/\/ overflow threshold\n+             56.0 * LN2,\n+            -56.0 * LN2,\n+             0.5 * LN2,\n+            -0.5 * LN2,\n+             1.5 * LN2,\n+            -1.5 * LN2,\n+             0x1.0p-54,\n+            -0x1.0p-54,\n+        };\n+\n+        for (double testPoint : decisionPoints) {\n+            failures += testRangeMidpoint(testPoint, Math.ulp(testPoint), 1000);\n+        }\n+\n+        x = Tests.createRandomDouble(random);\n+\n+        \/\/ Make the increment twice the ulp value in case the random\n+        \/\/ value is near an exponent threshold. Don't worry about test\n+        \/\/ elements overflowing to infinity if the starting value is\n+        \/\/ near Double.MAX_VALUE.\n+        failures += testRange(x, 2.0 * Math.ulp(x), 1000);\n+\n+        return failures;\n+    }\n+\n+    private static int testRange(double start, double increment, int count) {\n+        int failures = 0;\n+        double x = start;\n+        for (int i = 0; i < count; i++, x += increment) {\n+            failures += testExpm1Case(x, FdlibmTranslit.expm1(x));\n+        }\n+        return failures;\n+    }\n+\n+    private static int testRangeMidpoint(double midpoint, double increment, int count) {\n+        int failures = 0;\n+        double x = midpoint - increment*(count \/ 2) ;\n+        for (int i = 0; i < count; i++, x += increment) {\n+            failures += testExpm1Case(x, FdlibmTranslit.expm1(x));\n+        }\n+        return failures;\n+    }\n+\n+    private static int testExpm1Case(double input, double expected) {\n@@ -51,1 +140,1 @@\n-    static int testExpm1() {\n+    private static int testExpm1() {\n@@ -784,12 +873,0 @@\n-\n-    public static void main(String [] argv) {\n-        int failures = 0;\n-\n-        failures += testExpm1();\n-\n-        if (failures > 0) {\n-            System.err.println(\"Testing expm1 incurred \"\n-                               + failures + \" failures.\");\n-            throw new RuntimeException();\n-        }\n-    }\n","filename":"test\/jdk\/java\/lang\/StrictMath\/Expm1Tests.java","additions":95,"deletions":18,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -89,0 +89,4 @@\n+    public static double expm1(double x) {\n+        return Expm1.compute(x);\n+    }\n+\n@@ -614,0 +618,193 @@\n+\n+    \/* expm1(x)\n+     * Returns exp(x)-1, the exponential of x minus 1.\n+     *\n+     * Method\n+     *   1. Argument reduction:\n+     *      Given x, find r and integer k such that\n+     *\n+     *               x = k*ln2 + r,  |r| <= 0.5*ln2 ~ 0.34658\n+     *\n+     *      Here a correction term c will be computed to compensate\n+     *      the error in r when rounded to a floating-point number.\n+     *\n+     *   2. Approximating expm1(r) by a special rational function on\n+     *      the interval [0,0.34658]:\n+     *      Since\n+     *          r*(exp(r)+1)\/(exp(r)-1) = 2+ r^2\/6 - r^4\/360 + ...\n+     *      we define R1(r*r) by\n+     *          r*(exp(r)+1)\/(exp(r)-1) = 2+ r^2\/6 * R1(r*r)\n+     *      That is,\n+     *          R1(r**2) = 6\/r *((exp(r)+1)\/(exp(r)-1) - 2\/r)\n+     *                   = 6\/r * ( 1 + 2.0*(1\/(exp(r)-1) - 1\/r))\n+     *                   = 1 - r^2\/60 + r^4\/2520 - r^6\/100800 + ...\n+     *      We use a special Reme algorithm on [0,0.347] to generate\n+     *      a polynomial of degree 5 in r*r to approximate R1. The\n+     *      maximum error of this polynomial approximation is bounded\n+     *      by 2**-61. In other words,\n+     *          R1(z) ~ 1.0 + Q1*z + Q2*z**2 + Q3*z**3 + Q4*z**4 + Q5*z**5\n+     *      where   Q1  =  -1.6666666666666567384E-2,\n+     *              Q2  =   3.9682539681370365873E-4,\n+     *              Q3  =  -9.9206344733435987357E-6,\n+     *              Q4  =   2.5051361420808517002E-7,\n+     *              Q5  =  -6.2843505682382617102E-9;\n+     *      (where z=r*r, and the values of Q1 to Q5 are listed below)\n+     *      with error bounded by\n+     *          |                  5           |     -61\n+     *          | 1.0+Q1*z+...+Q5*z   -  R1(z) | <= 2\n+     *          |                              |\n+     *\n+     *      expm1(r) = exp(r)-1 is then computed by the following\n+     *      specific way which minimize the accumulation rounding error:\n+     *                             2     3\n+     *                            r     r    [ 3 - (R1 + R1*r\/2)  ]\n+     *            expm1(r) = r + --- + --- * [--------------------]\n+     *                            2     2    [ 6 - r*(3 - R1*r\/2) ]\n+     *\n+     *      To compensate the error in the argument reduction, we use\n+     *              expm1(r+c) = expm1(r) + c + expm1(r)*c\n+     *                         ~ expm1(r) + c + r*c\n+     *      Thus c+r*c will be added in as the correction terms for\n+     *      expm1(r+c). Now rearrange the term to avoid optimization\n+     *      screw up:\n+     *                      (      2                                    2 )\n+     *                      ({  ( r    [ R1 -  (3 - R1*r\/2) ]  )  }    r  )\n+     *       expm1(r+c)~r - ({r*(--- * [--------------------]-c)-c} - --- )\n+     *                      ({  ( 2    [ 6 - r*(3 - R1*r\/2) ]  )  }    2  )\n+     *                      (                                             )\n+     *\n+     *                 = r - E\n+     *   3. Scale back to obtain expm1(x):\n+     *      From step 1, we have\n+     *         expm1(x) = either 2^k*[expm1(r)+1] - 1\n+     *                  = or     2^k*[expm1(r) + (1-2^-k)]\n+     *   4. Implementation notes:\n+     *      (A). To save one multiplication, we scale the coefficient Qi\n+     *           to Qi*2^i, and replace z by (x^2)\/2.\n+     *      (B). To achieve maximum accuracy, we compute expm1(x) by\n+     *        (i)   if x < -56*ln2, return -1.0, (raise inexact if x!=inf)\n+     *        (ii)  if k=0, return r-E\n+     *        (iii) if k=-1, return 0.5*(r-E)-0.5\n+     *        (iv)  if k=1 if r < -0.25, return 2*((r+0.5)- E)\n+     *                     else          return  1.0+2.0*(r-E);\n+     *        (v)   if (k<-2||k>56) return 2^k(1-(E-r)) - 1 (or exp(x)-1)\n+     *        (vi)  if k <= 20, return 2^k((1-2^-k)-(E-r)), else\n+     *        (vii) return 2^k(1-((E+2^-k)-r))\n+     *\n+     * Special cases:\n+     *      expm1(INF) is INF, expm1(NaN) is NaN;\n+     *      expm1(-INF) is -1, and\n+     *      for finite argument, only expm1(0)=0 is exact.\n+     *\n+     * Accuracy:\n+     *      according to an error analysis, the error is always less than\n+     *      1 ulp (unit in the last place).\n+     *\n+     * Misc. info.\n+     *      For IEEE double\n+     *          if x >  7.09782712893383973096e+02 then expm1(x) overflow\n+     *\n+     * Constants:\n+     * The hexadecimal values are the intended ones for the following\n+     * constants. The decimal values may be used, provided that the\n+     * compiler will convert from decimal to binary accurately enough\n+     * to produce the hexadecimal values shown.\n+     *\/\n+    static class Expm1 {\n+        private static final double one             = 1.0;\n+        private static final double huge            = 1.0e+300;\n+        private static final double tiny            = 1.0e-300;\n+        private static final double o_threshold     = 7.09782712893383973096e+02; \/* 0x40862E42, 0xFEFA39EF *\/\n+        private static final double ln2_hi          = 6.93147180369123816490e-01; \/* 0x3fe62e42, 0xfee00000 *\/\n+        private static final double ln2_lo          = 1.90821492927058770002e-10; \/* 0x3dea39ef, 0x35793c76 *\/\n+        private static final double invln2          = 1.44269504088896338700e+00; \/* 0x3ff71547, 0x652b82fe *\/\n+        \/* scaled coefficients related to expm1 *\/\n+        private static final double Q1  =  -3.33333333333331316428e-02; \/* BFA11111 111110F4 *\/\n+        private static final double Q2  =   1.58730158725481460165e-03; \/* 3F5A01A0 19FE5585 *\/\n+        private static final double Q3  =  -7.93650757867487942473e-05; \/* BF14CE19 9EAADBB7 *\/\n+        private static final double Q4  =   4.00821782732936239552e-06; \/* 3ED0CFCA 86E65239 *\/\n+        private static final double Q5  =  -2.01099218183624371326e-07; \/* BE8AFDB7 6E09C32D *\/\n+\n+        static double compute(double x) {\n+            double y,hi,lo,c=0,t,e,hxs,hfx,r1;\n+            int k,xsb;\n+            \/*unsigned*\/ int hx;\n+\n+            hx  = __HI(x);  \/* high word of x *\/\n+            xsb = hx&0x80000000;            \/* sign bit of x *\/\n+            if(xsb==0) y=x; else y= -x;     \/* y = |x| *\/\n+            hx &= 0x7fffffff;               \/* high word of |x| *\/\n+\n+            \/* filter out huge and non-finite argument *\/\n+            if(hx >= 0x4043687A) {                  \/* if |x|>=56*ln2 *\/\n+                if(hx >= 0x40862E42) {              \/* if |x|>=709.78... *\/\n+                    if(hx>=0x7ff00000) {\n+                        if(((hx&0xfffff)|__LO(x))!=0)\n+                            return x+x;     \/* NaN *\/\n+                        else return (xsb==0)? x:-1.0;\/* exp(+-inf)={inf,-1} *\/\n+                    }\n+                    if(x > o_threshold) return huge*huge; \/* overflow *\/\n+                }\n+                if(xsb!=0) { \/* x < -56*ln2, return -1.0 with inexact *\/\n+                    if(x+tiny<0.0)          \/* raise inexact *\/\n+                        return tiny-one;        \/* return -1 *\/\n+                }\n+            }\n+\n+            \/* argument reduction *\/\n+            if(hx > 0x3fd62e42) {           \/* if  |x| > 0.5 ln2 *\/\n+                if(hx < 0x3FF0A2B2) {       \/* and |x| < 1.5 ln2 *\/\n+                    if(xsb==0)\n+                        {hi = x - ln2_hi; lo =  ln2_lo;  k =  1;}\n+                    else\n+                        {hi = x + ln2_hi; lo = -ln2_lo;  k = -1;}\n+                } else {\n+                    k  = (int)(invln2*x+((xsb==0)?0.5:-0.5));\n+                    t  = k;\n+                    hi = x - t*ln2_hi;      \/* t*ln2_hi is exact here *\/\n+                    lo = t*ln2_lo;\n+                }\n+                x  = hi - lo;\n+                c  = (hi-x)-lo;\n+            }\n+            else if(hx < 0x3c900000) {      \/* when |x|<2**-54, return x *\/\n+                t = huge+x; \/* return x with inexact flags when x!=0 *\/\n+                return x - (t-(huge+x));\n+            }\n+            else k = 0;\n+\n+            \/* x is now in primary range *\/\n+            hfx = 0.5*x;\n+            hxs = x*hfx;\n+            r1 = one+hxs*(Q1+hxs*(Q2+hxs*(Q3+hxs*(Q4+hxs*Q5))));\n+            t  = 3.0-r1*hfx;\n+            e  = hxs*((r1-t)\/(6.0 - x*t));\n+            if(k==0) return x - (x*e-hxs);          \/* c is 0 *\/\n+            else {\n+                e  = (x*(e-c)-c);\n+                e -= hxs;\n+                if(k== -1) return 0.5*(x-e)-0.5;\n+                if(k==1) {\n+                    if(x < -0.25) return -2.0*(e-(x+0.5));\n+                    else          return  one+2.0*(x-e);\n+                }\n+                if (k <= -2 || k>56) {   \/* suffice to return exp(x)-1 *\/\n+                    y = one-(e-x);\n+                    y = __HI(y,  __HI(y) + (k<<20));     \/* add k to y's exponent *\/\n+                    return y-one;\n+                }\n+                t = one;\n+                if(k<20) {\n+                    t = __HI(t, 0x3ff00000 - (0x200000>>k));  \/* t=1-2^-k *\/\n+                    y = t-(e-x);\n+                    y = __HI(y, __HI(y) + (k<<20));     \/* add k to y's exponent *\/\n+                } else {\n+                    t = __HI(t, ((0x3ff-k)<<20));     \/* 2^-k *\/\n+                    y = x-(e+t);\n+                    y += one;\n+                    y = __HI(y, __HI(y) + (k<<20));     \/* add k to y's exponent *\/\n+                }\n+            }\n+            return y;\n+        }\n+    }\n","filename":"test\/jdk\/java\/lang\/StrictMath\/FdlibmTranslit.java","additions":197,"deletions":0,"binary":false,"changes":197,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng BuilderTest\n+ * @run junit BuilderTest\n@@ -36,3 +36,3 @@\n-import org.testng.SkipException;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assumptions.*;\n@@ -40,1 +40,1 @@\n-public class BuilderTest {\n+class BuilderTest {\n@@ -46,1 +46,1 @@\n-    public void testPlatformThread() throws Exception {\n+    void testPlatformThread() throws Exception {\n@@ -97,1 +97,1 @@\n-    public void testVirtualThread() throws Exception {\n+    void testVirtualThread() throws Exception {\n@@ -144,1 +144,1 @@\n-    public void testName1() {\n+    void testName1() {\n@@ -157,1 +157,1 @@\n-    public void testName2() {\n+    void testName2() {\n@@ -170,1 +170,1 @@\n-    public void testName3() {\n+    void testName3() {\n@@ -192,1 +192,1 @@\n-    public void testName4() {\n+    void testName4() {\n@@ -217,1 +217,1 @@\n-    public void testThreadGroup1() {\n+    void testThreadGroup1() {\n@@ -243,1 +243,1 @@\n-    public void testThreadGroup2() {\n+    void testThreadGroup2() {\n@@ -245,1 +245,1 @@\n-        assertEquals(vgroup.getName(), \"VirtualThreads\");\n+        assertEquals(\"VirtualThreads\", vgroup.getName());\n@@ -264,1 +264,1 @@\n-    public void testPriority1() {\n+    void testPriority1() {\n@@ -278,1 +278,1 @@\n-    public void testPriority2() {\n+    void testPriority2() {\n@@ -292,1 +292,1 @@\n-    public void testPriority3() {\n+    void testPriority3() {\n@@ -294,2 +294,1 @@\n-        if (currentThread.isVirtual())\n-            throw new SkipException(\"Main test is a virtual thread\");\n+        assumeFalse(currentThread.isVirtual(), \"Main thread is a virtual thread\");\n@@ -311,1 +310,1 @@\n-    public void testPriority4() {\n+    void testPriority4() {\n@@ -318,1 +317,1 @@\n-    public void testPriority5() {\n+    void testPriority5() {\n@@ -328,1 +327,1 @@\n-    public void testDaemon1() {\n+    void testDaemon1() {\n@@ -341,1 +340,1 @@\n-    public void testDaemon2() {\n+    void testDaemon2() {\n@@ -354,1 +353,1 @@\n-    public void testDaemon3() {\n+    void testDaemon3() {\n@@ -367,1 +366,1 @@\n-    public void testDaemon4() {\n+    void testDaemon4() {\n@@ -385,1 +384,1 @@\n-    public void testDaemon5() {\n+    void testDaemon5() {\n@@ -402,1 +401,1 @@\n-    public void testStackSize1() {\n+    void testStackSize1() {\n@@ -410,1 +409,1 @@\n-    public void testStackSize2() {\n+    void testStackSize2() {\n@@ -418,1 +417,1 @@\n-    public void testStackSize3() {\n+    void testStackSize3() {\n@@ -427,1 +426,1 @@\n-    public void testUncaughtExceptionHandler1() throws Exception {\n+    void testUncaughtExceptionHandler1() throws Exception {\n@@ -444,1 +443,1 @@\n-    public void testUncaughtExceptionHandler2() throws Exception {\n+    void testUncaughtExceptionHandler2() throws Exception {\n@@ -461,1 +460,1 @@\n-    public void testUncaughtExceptionHandler3() throws Exception {\n+    void testUncaughtExceptionHandler3() throws Exception {\n@@ -480,1 +479,1 @@\n-    public void testUncaughtExceptionHandler4() throws Exception {\n+    void testUncaughtExceptionHandler4() throws Exception {\n@@ -566,1 +565,1 @@\n-    public void testThreadLocals1() throws Exception {\n+    void testThreadLocals1() throws Exception {\n@@ -572,1 +571,1 @@\n-    public void testThreadLocals2() throws Exception {\n+    void testThreadLocals2() throws Exception {\n@@ -582,1 +581,1 @@\n-    public void testThreadLocals3() throws Exception {\n+    void testThreadLocals3() throws Exception {\n@@ -595,1 +594,1 @@\n-    public void testThreadLocals4() throws Exception {\n+    void testThreadLocals4() throws Exception {\n@@ -649,1 +648,1 @@\n-            assertTrue(INHERITED_LOCAL.get() == null);\n+            assertNull(INHERITED_LOCAL.get());\n@@ -676,1 +675,1 @@\n-    public void testInheritedThreadLocals1() throws Exception {\n+    void testInheritedThreadLocals1() throws Exception {\n@@ -690,1 +689,1 @@\n-    public void testInheritedThreadLocals2() throws Exception {\n+    void testInheritedThreadLocals2() throws Exception {\n@@ -704,1 +703,1 @@\n-    public void testInheritedThreadLocals3() throws Exception {\n+    void testInheritedThreadLocals3() throws Exception {\n@@ -724,1 +723,1 @@\n-    public void testInheritedThreadLocals4() throws Exception {\n+    void testInheritedThreadLocals4() throws Exception {\n@@ -827,1 +826,1 @@\n-    public void testContextClassLoader1() throws Exception {\n+    void testContextClassLoader1() throws Exception {\n@@ -841,1 +840,1 @@\n-    public void testContextClassLoader2() throws Exception {\n+    void testContextClassLoader2() throws Exception {\n@@ -855,1 +854,1 @@\n-    public void testContextClassLoader3() throws Exception {\n+    void testContextClassLoader3() throws Exception {\n@@ -875,1 +874,1 @@\n-    public void testContextClassLoader4() throws Exception {\n+    void testContextClassLoader4() throws Exception {\n@@ -898,1 +897,1 @@\n-    public void testNulls1() {\n+    void testNulls1() {\n@@ -909,1 +908,1 @@\n-    public void testNulls2() {\n+    void testNulls2() {\n","filename":"test\/jdk\/java\/lang\/Thread\/BuilderTest.java","additions":48,"deletions":49,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @run testng JoinWithDuration\n+ * @run junit JoinWithDuration\n@@ -34,2 +34,2 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -37,1 +37,1 @@\n-public class JoinWithDuration {\n+class JoinWithDuration {\n@@ -42,1 +42,1 @@\n-    public void testJoinOnUnstartedThread() {\n+    void testJoinOnUnstartedThread() {\n@@ -56,1 +56,1 @@\n-    public void testJoinOnRunningThread() throws Exception {\n+    void testJoinOnRunningThread() throws Exception {\n@@ -79,1 +79,1 @@\n-    public void testJoinOnTerminatingThread() throws Exception {\n+    void testJoinOnTerminatingThread() throws Exception {\n@@ -93,1 +93,1 @@\n-    public void testJoinOnTerminatedThread() throws Exception {\n+    void testJoinOnTerminatedThread() throws Exception {\n@@ -106,1 +106,1 @@\n-    public void testJoinWithInterruptStatusSet() throws Exception {\n+    void testJoinWithInterruptStatusSet() throws Exception {\n@@ -125,2 +125,2 @@\n-    public void testInterruptJoin() throws Exception {\n-        \/\/ schedule current thread to interrupted after 1s\n+    void testInterruptJoin() throws Exception {\n+        \/\/ schedule current thread to be interrupted after 1s\n@@ -147,1 +147,3 @@\n-            wakerThread.interrupt();\n+            LockSupport.unpark(thread);\n+            thread.join();\n+            wakerThread.join();\n@@ -155,1 +157,1 @@\n-    public void testJoinSelf() throws Exception {\n+    void testJoinSelf() throws Exception {\n@@ -172,1 +174,1 @@\n-    public void testJoinNull() throws Exception {\n+    void testJoinNull() throws Exception {\n","filename":"test\/jdk\/java\/lang\/Thread\/JoinWithDuration.java","additions":17,"deletions":15,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @run testng SleepWithDuration\n+ * @run junit SleepWithDuration\n@@ -33,2 +33,2 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -36,1 +36,1 @@\n-public class SleepWithDuration {\n+class SleepWithDuration {\n@@ -42,1 +42,1 @@\n-    public void testSleep() throws Exception {\n+    void testSleep() throws Exception {\n@@ -59,1 +59,1 @@\n-    public void testSleepWithInterruptStatusSet() throws Exception {\n+    void testSleepWithInterruptStatusSet() throws Exception {\n@@ -81,2 +81,2 @@\n-    public void testInterruptSleep() throws Exception {\n-        \/\/ schedule current thread to interrupted after 1s\n+    void testInterruptSleep() throws Exception {\n+        \/\/ schedule current thread to be interrupted after 1s\n@@ -100,1 +100,1 @@\n-            wakerThread.interrupt();\n+            wakerThread.join();\n","filename":"test\/jdk\/java\/lang\/Thread\/SleepWithDuration.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,2 @@\n+import java.util.stream.Stream;\n+\n@@ -26,2 +28,4 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.Arguments;\n@@ -39,1 +43,1 @@\n- * @run testng UncaughtExceptionsTest\n+ * @run junit UncaughtExceptionsTest\n@@ -41,1 +45,1 @@\n-public class UncaughtExceptionsTest {\n+class UncaughtExceptionsTest {\n@@ -43,21 +47,35 @@\n-    @DataProvider\n-    public Object[][] testCases() {\n-        return new Object[][] {\n-            new Object[] { \"ThreadIsDeadAfterJoin\",\n-                           0,\n-                           UncaughtExitSimulator.EXPECTED_RESULT,\n-                           \"Exception in thread \\\"Thread-\\\\d+\\\".*simulateUncaughtExitEvent\"\n-            },\n-            new Object[] {\n-                            \"MainThreadAbruptTermination\",\n-                            1,\n-                            UncaughtExitSimulator.EXPECTED_RESULT,\n-                            \"Exception in thread \\\"main\\\".*simulateUncaughtExitEvent\"\n-            },\n-            new Object[] { \"MainThreadNormalTermination\", 0, UncaughtExitSimulator.EXPECTED_RESULT, \"\"},\n-            new Object[] { \"DefaultUncaughtExceptionHandlerOnMainThread\", 1, UncaughtExitSimulator.EXPECTED_RESULT, \"\" },\n-            new Object[] { \"DefaultUncaughtExceptionHandlerOnMainThreadOverride\", 1, UncaughtExitSimulator.EXPECTED_RESULT, \"\" },\n-            new Object[] { \"DefaultUncaughtExceptionHandlerOnNonMainThreadOverride\", 0, UncaughtExitSimulator.EXPECTED_RESULT, \"\" },\n-            new Object[] { \"DefaultUncaughtExceptionHandlerOnNonMainThread\", 0, UncaughtExitSimulator.EXPECTED_RESULT, \"\" },\n-            new Object[] { \"ThreadGroupUncaughtExceptionHandlerOnNonMainThread\", 0, UncaughtExitSimulator.EXPECTED_RESULT, \"\" }\n-        };\n+    private static Stream<Arguments> testCases() {\n+        return Stream.of(\n+            Arguments.of(\"ThreadIsDeadAfterJoin\",\n+                         0,\n+                         UncaughtExitSimulator.EXPECTED_RESULT,\n+                         \"Exception in thread \\\"Thread-\\\\d+\\\".*simulateUncaughtExitEvent\"),\n+            Arguments.of(\"MainThreadAbruptTermination\",\n+                         1,\n+                         UncaughtExitSimulator.EXPECTED_RESULT,\n+                         \"Exception in thread \\\"main\\\".*simulateUncaughtExitEvent\"),\n+            Arguments.of(\"MainThreadNormalTermination\",\n+                         0,\n+                         UncaughtExitSimulator.EXPECTED_RESULT,\n+                         \"\"),\n+            Arguments.of(\"DefaultUncaughtExceptionHandlerOnMainThread\",\n+                         1,\n+                         UncaughtExitSimulator.EXPECTED_RESULT,\n+                         \"\"),\n+            Arguments.of(\"DefaultUncaughtExceptionHandlerOnMainThreadOverride\",\n+                         1,\n+                         UncaughtExitSimulator.EXPECTED_RESULT,\n+                         \"\"),\n+            Arguments.of(\"DefaultUncaughtExceptionHandlerOnNonMainThreadOverride\",\n+                         0,\n+                         UncaughtExitSimulator.EXPECTED_RESULT,\n+                         \"\"),\n+            Arguments.of(\"DefaultUncaughtExceptionHandlerOnNonMainThread\",\n+                         0,\n+                         UncaughtExitSimulator.EXPECTED_RESULT,\n+                         \"\"),\n+            Arguments.of(\"ThreadGroupUncaughtExceptionHandlerOnNonMainThread\",\n+                         0,\n+                         UncaughtExitSimulator.EXPECTED_RESULT,\n+                         \"\")\n+        );\n@@ -66,2 +84,3 @@\n-    @Test(dataProvider = \"testCases\")\n-    public void test(String className, int exitValue, String stdOutMatch, String stdErrMatch) throws Throwable {\n+    @ParameterizedTest\n+    @MethodSource(\"testCases\")\n+    void test(String className, int exitValue, String stdOutMatch, String stdErrMatch) throws Throwable {\n@@ -94,1 +113,3 @@\n-    public static void throwRuntimeException() { throw new RuntimeException(\"simulateUncaughtExitEvent\"); }\n+    public static void throwRuntimeException() {\n+        throw new RuntimeException(\"simulateUncaughtExitEvent\");\n+    }\n","filename":"test\/jdk\/java\/lang\/Thread\/UncaughtExceptionsTest.java","additions":50,"deletions":29,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng Collectable\n+ * @run junit Collectable\n@@ -34,2 +34,2 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -37,1 +37,1 @@\n-public class Collectable {\n+class Collectable {\n@@ -43,1 +43,1 @@\n-    public void testUnstartedThread() {\n+    void testUnstartedThread() {\n@@ -54,1 +54,1 @@\n-    public void testTerminatedThread() throws Exception {\n+    void testTerminatedThread() throws Exception {\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/Collectable.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run testng CustomScheduler\n+ * @run junit CustomScheduler\n@@ -42,5 +42,5 @@\n-import org.testng.SkipException;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.AfterClass;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.AfterAll;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assumptions.*;\n@@ -48,1 +48,1 @@\n-public class CustomScheduler {\n+class CustomScheduler {\n@@ -50,2 +50,2 @@\n-    private static ExecutorService SCHEDULER_1;\n-    private static ExecutorService SCHEDULER_2;\n+    private static ExecutorService scheduler1;\n+    private static ExecutorService scheduler2;\n@@ -53,4 +53,4 @@\n-    @BeforeClass\n-    public void setup() {\n-        SCHEDULER_1 = Executors.newFixedThreadPool(1);\n-        SCHEDULER_2 = Executors.newFixedThreadPool(1);\n+    @BeforeAll\n+    static void setup() {\n+        scheduler1 = Executors.newFixedThreadPool(1);\n+        scheduler2 = Executors.newFixedThreadPool(1);\n@@ -59,4 +59,4 @@\n-    @AfterClass\n-    public void shutdown() {\n-        SCHEDULER_1.shutdown();\n-        SCHEDULER_2.shutdown();\n+    @AfterAll\n+    static void shutdown() {\n+        scheduler1.shutdown();\n+        scheduler2.shutdown();\n@@ -69,1 +69,1 @@\n-    public void testCustomScheduler1() throws Exception {\n+    void testCustomScheduler1() throws Exception {\n@@ -71,1 +71,1 @@\n-        ThreadBuilders.virtualThreadBuilder(SCHEDULER_1).start(() -> {\n+        ThreadBuilders.virtualThreadBuilder(scheduler1).start(() -> {\n@@ -74,1 +74,1 @@\n-        assertTrue(ref.get() == SCHEDULER_1);\n+        assertTrue(ref.get() == scheduler1);\n@@ -81,1 +81,1 @@\n-    public void testCustomScheduler2() throws Exception {\n+    void testCustomScheduler2() throws Exception {\n@@ -85,1 +85,1 @@\n-                ThreadBuilders.virtualThreadBuilder(SCHEDULER_1).start(() -> {\n+                ThreadBuilders.virtualThreadBuilder(scheduler1).start(() -> {\n@@ -92,1 +92,1 @@\n-        assertTrue(ref.get() == SCHEDULER_1);\n+        assertTrue(ref.get() == scheduler1);\n@@ -100,1 +100,1 @@\n-    public void testCustomScheduler3() throws Exception {\n+    void testCustomScheduler3() throws Exception {\n@@ -102,1 +102,1 @@\n-        ThreadBuilders.virtualThreadBuilder(SCHEDULER_1).start(() -> {\n+        ThreadBuilders.virtualThreadBuilder(scheduler1).start(() -> {\n@@ -111,1 +111,1 @@\n-        assertTrue(ref.get() == SCHEDULER_1);\n+        assertTrue(ref.get() == scheduler1);\n@@ -119,1 +119,1 @@\n-    public void testCustomScheduler4() throws Exception {\n+    void testCustomScheduler4() throws Exception {\n@@ -121,1 +121,1 @@\n-        ThreadBuilders.virtualThreadBuilder(SCHEDULER_1).start(() -> {\n+        ThreadBuilders.virtualThreadBuilder(scheduler1).start(() -> {\n@@ -123,1 +123,1 @@\n-                ThreadBuilders.virtualThreadBuilder(SCHEDULER_2).start(() -> {\n+                ThreadBuilders.virtualThreadBuilder(scheduler2).start(() -> {\n@@ -130,1 +130,1 @@\n-        assertTrue(ref.get() == SCHEDULER_2);\n+        assertTrue(ref.get() == scheduler2);\n@@ -137,1 +137,1 @@\n-    public void testBadCarrier() {\n+    void testBadCarrier() {\n@@ -163,1 +163,1 @@\n-    public void testParkWithInterruptSet() {\n+    void testParkWithInterruptSet() {\n@@ -165,2 +165,1 @@\n-        if (carrier.isVirtual())\n-            throw new SkipException(\"Main test is a virtual thread\");\n+        assumeFalse(carrier.isVirtual(), \"Main thread is a virtual thread\");\n@@ -185,1 +184,1 @@\n-    public void testTerminateWithInterruptSet() {\n+    void testTerminateWithInterruptSet() {\n@@ -187,2 +186,1 @@\n-        if (carrier.isVirtual())\n-            throw new SkipException(\"Main test is a virtual thread\");\n+        assumeFalse(carrier.isVirtual(), \"Main thread is a virtual thread\");\n@@ -205,3 +203,2 @@\n-    public void testRunWithInterruptSet() throws Exception {\n-        if (Thread.currentThread().isVirtual())\n-            throw new SkipException(\"Main test is a virtual thread\");\n+    void testRunWithInterruptSet() throws Exception {\n+        assumeFalse(Thread.currentThread().isVirtual(), \"Main thread is a virtual thread\");\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/CustomScheduler.java","additions":38,"deletions":41,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @modules java.base\/java.lang:+open\n+ * @requires vm.continuations\n@@ -30,1 +30,2 @@\n- * @run testng GetStackTrace\n+ * @modules java.base\/java.lang:+open\n+ * @run main GetStackTrace\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/GetStackTrace.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run testng HoldsLock\n+ * @run junit HoldsLock\n@@ -39,1 +39,1 @@\n- * @run testng\/othervm -XX:+UseHeavyMonitors HoldsLock\n+ * @run junit\/othervm -XX:+UseHeavyMonitors HoldsLock\n@@ -55,2 +55,3 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.Disabled;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -58,1 +59,1 @@\n-public class HoldsLock {\n+class HoldsLock {\n@@ -62,2 +63,3 @@\n-    @Test(enabled=false) \/\/ JDK-8281642\n-    public void testHoldsLock() throws Exception {\n+    @Disabled(\"JDK-8281642\")\n+    @Test\n+    void testHoldsLock() throws Exception {\n@@ -88,1 +90,1 @@\n-    public void testThreadInfo() throws Exception {\n+    void testThreadInfo() throws Exception {\n@@ -126,4 +128,4 @@\n-                assertEquals(info.getThreadState(), Thread.State.WAITING);\n-                assertEquals(info.getLockInfo().getClassName(), vthread.getClass().getName());\n-                assertEquals(info.getLockInfo().getIdentityHashCode(), System.identityHashCode(vthread));\n-                assertEquals(info.getLockOwnerId(), vthreadId);\n+                assertTrue(info.getThreadState() == Thread.State.WAITING);\n+                assertEquals(vthread.getClass().getName(), info.getLockInfo().getClassName());\n+                assertTrue(info.getLockInfo().getIdentityHashCode() == System.identityHashCode(vthread));\n+                assertTrue(info.getLockOwnerId() == vthreadId);\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/HoldsLock.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run testng\/othervm JfrEvents\n+ * @run junit\/othervm JfrEvents\n@@ -51,2 +51,2 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -54,1 +54,1 @@\n-public class JfrEvents {\n+class JfrEvents {\n@@ -61,1 +61,1 @@\n-    public void testVirtualThreadStartAndEnd() throws Exception {\n+    void testVirtualThreadStartAndEnd() throws Exception {\n@@ -92,1 +92,1 @@\n-    public void testVirtualThreadPinned() throws Exception {\n+    void testVirtualThreadPinned() throws Exception {\n@@ -129,1 +129,1 @@\n-    public void testVirtualThreadSubmitFailed() throws Exception {\n+    void testVirtualThreadSubmitFailed() throws Exception {\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/JfrEvents.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng Locking\n+ * @run junit Locking\n@@ -37,2 +37,2 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -40,1 +40,1 @@\n-public class Locking {\n+class Locking {\n@@ -46,1 +46,1 @@\n-    public void testReentrantLock1() throws Exception {\n+    void testReentrantLock1() throws Exception {\n@@ -61,1 +61,1 @@\n-    public void testReentrantLock2() throws Exception {\n+    void testReentrantLock2() throws Exception {\n@@ -77,1 +77,1 @@\n-    public void testReentrantLock3() throws Exception {\n+    void testReentrantLock3() throws Exception {\n@@ -101,1 +101,1 @@\n-    public void testReentrantLock4() throws Exception {\n+    void testReentrantLock4() throws Exception {\n@@ -139,1 +139,1 @@\n-    public void testReentrantLock5() throws Exception {\n+    void testReentrantLock5() throws Exception {\n@@ -173,1 +173,1 @@\n-    public void testReentrantLock6() throws Exception {\n+    void testReentrantLock6() throws Exception {\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/Locking.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run testng ParkWithFixedThreadPool\n+ * @run main ParkWithFixedThreadPool\n@@ -32,0 +32,1 @@\n+\n@@ -35,2 +36,0 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n@@ -39,2 +38,1 @@\n-    @Test\n-    public static void multipleThreadPoolParkTest() throws Exception {\n+    public static void main(String[] args) throws Exception {\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ParkWithFixedThreadPool.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng Parking\n+ * @run junit Parking\n@@ -37,3 +37,2 @@\n-import org.testng.SkipException;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -41,1 +40,1 @@\n-public class Parking {\n+class Parking {\n@@ -48,1 +47,1 @@\n-    public void testPark1() throws Exception {\n+    void testPark1() throws Exception {\n@@ -59,1 +58,1 @@\n-    public void testPark2() throws Exception {\n+    void testPark2() throws Exception {\n@@ -71,1 +70,1 @@\n-    public void testPark3() throws Exception {\n+    void testPark3() throws Exception {\n@@ -86,2 +85,2 @@\n-    public void testPark4() throws Exception {\n-        throw new SkipException(\"Not implemented\");\n+    void testPark4() throws Exception {\n+        \/\/ not implemented\n@@ -94,1 +93,1 @@\n-    public void testPark5() throws Exception {\n+    void testPark5() throws Exception {\n@@ -106,1 +105,1 @@\n-    public void testPark6() throws Exception {\n+    void testPark6() throws Exception {\n@@ -123,1 +122,1 @@\n-    public void testPark7() throws Exception {\n+    void testPark7() throws Exception {\n@@ -145,1 +144,1 @@\n-    public void testPark8() throws Exception {\n+    void testPark8() throws Exception {\n@@ -158,1 +157,1 @@\n-    public void testPark9() throws Exception {\n+    void testPark9() throws Exception {\n@@ -172,1 +171,1 @@\n-    public void testPark10() throws Exception {\n+    void testPark10() throws Exception {\n@@ -187,1 +186,1 @@\n-    public void testPark11() throws Exception {\n+    void testPark11() throws Exception {\n@@ -203,1 +202,1 @@\n-    public void testParkNanos1() throws Exception {\n+    void testParkNanos1() throws Exception {\n@@ -211,1 +210,1 @@\n-    public void testParkNanos2() throws Exception {\n+    void testParkNanos2() throws Exception {\n@@ -219,1 +218,1 @@\n-    public void testParkNanos3() throws Exception {\n+    void testParkNanos3() throws Exception {\n@@ -237,1 +236,1 @@\n-    public void testParkNanos4() throws Exception {\n+    void testParkNanos4() throws Exception {\n@@ -251,1 +250,1 @@\n-    public void testParkNanos5() throws Exception {\n+    void testParkNanos5() throws Exception {\n@@ -266,1 +265,1 @@\n-    public void testParkNanos6() throws Exception {\n+    void testParkNanos6() throws Exception {\n@@ -278,1 +277,1 @@\n-    public void testParkNanos7() throws Exception {\n+    void testParkNanos7() throws Exception {\n@@ -294,1 +293,1 @@\n-    public void testParkNanos8() throws Exception {\n+    void testParkNanos8() throws Exception {\n@@ -307,1 +306,1 @@\n-    public void testParkNanos9() throws Exception {\n+    void testParkNanos9() throws Exception {\n@@ -321,1 +320,1 @@\n-    public void testParkNanos10() throws Exception {\n+    void testParkNanos10() throws Exception {\n@@ -336,1 +335,1 @@\n-    public void testParkNanos11() throws Exception {\n+    void testParkNanos11() throws Exception {\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/Parking.java","additions":28,"deletions":29,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @run testng\/othervm PreviewFeaturesNotEnabled\n+ * @run junit\/othervm PreviewFeaturesNotEnabled\n@@ -34,2 +34,2 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -37,1 +37,1 @@\n-public class PreviewFeaturesNotEnabled {\n+class PreviewFeaturesNotEnabled {\n@@ -43,1 +43,1 @@\n-    public void testOfVirtual() throws Exception {\n+    void testOfVirtual() throws Exception {\n@@ -45,1 +45,1 @@\n-        var exc = expectThrows(InvocationTargetException.class, () -> ofVirtual.invoke(null));\n+        var exc = assertThrows(InvocationTargetException.class, () -> ofVirtual.invoke(null));\n@@ -53,1 +53,1 @@\n-    public void testStartVirutalThread() throws Exception {\n+    void testStartVirutalThread() throws Exception {\n@@ -56,1 +56,1 @@\n-        var exc = expectThrows(InvocationTargetException.class,\n+        var exc = assertThrows(InvocationTargetException.class,\n@@ -65,1 +65,1 @@\n-    public void testNewVirtualThreadPerTaskExecutor() throws Exception {\n+    void testNewVirtualThreadPerTaskExecutor() throws Exception {\n@@ -67,1 +67,1 @@\n-        var exc = expectThrows(InvocationTargetException.class,\n+        var exc = assertThrows(InvocationTargetException.class,\n@@ -76,2 +76,2 @@\n-    public void testContinuationInitializer() throws Exception {\n-        var exc = expectThrows(ExceptionInInitializerError.class,\n+    void testContinuationInitializer() throws Exception {\n+        var exc = assertThrows(ExceptionInInitializerError.class,\n@@ -86,1 +86,1 @@\n-    public void testIsVirtual() throws Exception {\n+    void testIsVirtual() throws Exception {\n@@ -95,1 +95,1 @@\n-    public void testOfPlatform() throws Exception {\n+    void testOfPlatform() throws Exception {\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/PreviewFeaturesNotEnabled.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run testng Reflection\n+ * @run junit Reflection\n@@ -42,3 +42,3 @@\n-import org.testng.SkipException;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assumptions.*;\n@@ -46,1 +46,1 @@\n-public class Reflection {\n+class Reflection {\n@@ -52,1 +52,1 @@\n-    public void testInvokeStatic1() throws Exception {\n+    void testInvokeStatic1() throws Exception {\n@@ -64,1 +64,1 @@\n-    public void testInvokeStatic2() throws Exception {\n+    void testInvokeStatic2() throws Exception {\n@@ -80,1 +80,1 @@\n-    public void testInvokeStatic3() throws Exception {\n+    void testInvokeStatic3() throws Exception {\n@@ -102,1 +102,1 @@\n-    public void testInvokeStatic4() throws Exception {\n+    void testInvokeStatic4() throws Exception {\n@@ -126,1 +126,1 @@\n-    public void testInvokeStatic5() throws Exception {\n+    void testInvokeStatic5() throws Exception {\n@@ -144,3 +144,2 @@\n-    public void testInvokeStatic6() throws Exception {\n-        if (!ThreadBuilders.supportsCustomScheduler())\n-            throw new SkipException(\"No support for custom schedulers\");\n+    void testInvokeStatic6() throws Exception {\n+        assumeTrue(ThreadBuilders.supportsCustomScheduler(), \"No support for custom schedulers\");\n@@ -175,1 +174,1 @@\n-    public void testInvokeInstance1() throws Exception {\n+    void testInvokeInstance1() throws Exception {\n@@ -188,1 +187,1 @@\n-    public void testInvokeInstance2() throws Exception {\n+    void testInvokeInstance2() throws Exception {\n@@ -205,1 +204,1 @@\n-    public void testInvokeInstance3() throws Exception {\n+    void testInvokeInstance3() throws Exception {\n@@ -226,1 +225,1 @@\n-    public void testNewInstance1() throws Exception {\n+    void testNewInstance1() throws Exception {\n@@ -239,1 +238,1 @@\n-    public void testNewInstance2() throws Exception {\n+    void testNewInstance2() throws Exception {\n@@ -256,1 +255,1 @@\n-    public void testNewInstance3() throws Exception {\n+    void testNewInstance3() throws Exception {\n@@ -278,1 +277,1 @@\n-    public void testNewInstance4() throws Exception {\n+    void testNewInstance4() throws Exception {\n@@ -302,1 +301,1 @@\n-    public void testNewInstance5() throws Exception {\n+    void testNewInstance5() throws Exception {\n@@ -320,3 +319,2 @@\n-    public void testNewInstance6() throws Exception {\n-        if (!ThreadBuilders.supportsCustomScheduler())\n-            throw new SkipException(\"No support for custom schedulers\");\n+    void testNewInstance6() throws Exception {\n+        assumeTrue(ThreadBuilders.supportsCustomScheduler(), \"No support for custom schedulers\");\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/Reflection.java","additions":23,"deletions":25,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,2 @@\n- * @run testng StackTraces\n- * @run testng\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+ShowCarrierFrames StackTraces\n+ * @run junit StackTraces\n+ * @run junit\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+ShowCarrierFrames StackTraces\n@@ -43,2 +43,2 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -46,1 +46,1 @@\n-public class StackTraces {\n+class StackTraces {\n@@ -53,1 +53,1 @@\n-    public void testStackTrace() throws Exception {\n+    void testStackTrace() throws Exception {\n@@ -67,1 +67,1 @@\n-    public void testStackWalker() throws Exception {\n+    void testStackWalker() throws Exception {\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/StackTraces.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run testng ThreadAPI\n+ * @run junit ThreadAPI\n@@ -40,1 +40,1 @@\n- * @run testng\/othervm -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations ThreadAPI\n+ * @run junit\/othervm -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations ThreadAPI\n@@ -66,8 +66,9 @@\n-import org.testng.SkipException;\n-import org.testng.annotations.AfterClass;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n-public class ThreadAPI {\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assumptions.*;\n+\n+class ThreadAPI {\n@@ -77,9 +78,5 @@\n-    private ScheduledExecutorService scheduler;\n-\n-    @BeforeClass\n-    public void setUp() throws Exception {\n-        ThreadFactory factory = (task) -> {\n-            Thread thread = new Thread(task);\n-            thread.setDaemon(true);\n-            return thread;\n-        };\n+    private static ScheduledExecutorService scheduler;\n+\n+    @BeforeAll\n+    static void setup() throws Exception {\n+        ThreadFactory factory = Executors.defaultThreadFactory();\n@@ -89,2 +86,2 @@\n-    @AfterClass\n-    public void tearDown() {\n+    @AfterAll\n+    static void finish() {\n@@ -106,1 +103,1 @@\n-    public void testCurrentThread1() throws Exception {\n+    void testCurrentThread1() throws Exception {\n@@ -125,1 +122,1 @@\n-    public void testCurrentThread2() throws Exception {\n+    void testCurrentThread2() throws Exception {\n@@ -150,1 +147,1 @@\n-    public void testCurrentThread3() throws Exception {\n+    void testCurrentThread3() throws Exception {\n@@ -182,1 +179,1 @@\n-    public void testRun1() throws Exception {\n+    void testRun1() throws Exception {\n@@ -193,1 +190,1 @@\n-    public void testStart1() throws Exception {\n+    void testStart1() throws Exception {\n@@ -206,1 +203,1 @@\n-    public void testStart2() throws Exception {\n+    void testStart2() throws Exception {\n@@ -220,1 +217,1 @@\n-    public void testStart3() throws Exception {\n+    void testStart3() throws Exception {\n@@ -230,1 +227,1 @@\n-    public void testStartVirtualThread() throws Exception {\n+    void testStartVirtualThread() throws Exception {\n@@ -256,1 +253,1 @@\n-    public void testStop1() throws Exception {\n+    void testStop1() throws Exception {\n@@ -267,1 +264,1 @@\n-    public void testStop2() throws Exception {\n+    void testStop2() throws Exception {\n@@ -285,1 +282,1 @@\n-    public void testSuspend1() throws Exception {\n+    void testSuspend1() throws Exception {\n@@ -296,1 +293,1 @@\n-    public void testSuspend2() throws Exception {\n+    void testSuspend2() throws Exception {\n@@ -314,1 +311,1 @@\n-    public void testResume1() throws Exception {\n+    void testResume1() throws Exception {\n@@ -325,1 +322,1 @@\n-    public void testResume2() throws Exception {\n+    void testResume2() throws Exception {\n@@ -343,1 +340,1 @@\n-    public void testJoin1() throws Exception {\n+    void testJoin1() throws Exception {\n@@ -363,1 +360,1 @@\n-    public void testJoin2() throws Exception {\n+    void testJoin2() throws Exception {\n@@ -371,1 +368,1 @@\n-    public void testJoin3() throws Exception {\n+    void testJoin3() throws Exception {\n@@ -392,1 +389,1 @@\n-    public void testJoin4() throws Exception {\n+    void testJoin4() throws Exception {\n@@ -400,1 +397,1 @@\n-    public void testJoin5() throws Exception {\n+    void testJoin5() throws Exception {\n@@ -414,1 +411,1 @@\n-    public void testJoin6() throws Exception {\n+    void testJoin6() throws Exception {\n@@ -422,1 +419,1 @@\n-    public void testJoin7() throws Exception {\n+    void testJoin7() throws Exception {\n@@ -436,1 +433,1 @@\n-    public void testJoin8() throws Exception {\n+    void testJoin8() throws Exception {\n@@ -444,1 +441,1 @@\n-    public void testJoin11() throws Exception {\n+    void testJoin11() throws Exception {\n@@ -458,1 +455,1 @@\n-    public void testJoin12() throws Exception {\n+    void testJoin12() throws Exception {\n@@ -466,1 +463,1 @@\n-    public void testJoin13() throws Exception {\n+    void testJoin13() throws Exception {\n@@ -485,1 +482,1 @@\n-    public void testJoin14() throws Exception {\n+    void testJoin14() throws Exception {\n@@ -493,1 +490,1 @@\n-    public void testJoin15() throws Exception {\n+    void testJoin15() throws Exception {\n@@ -509,1 +506,1 @@\n-    public void testJoin16() throws Exception {\n+    void testJoin16() throws Exception {\n@@ -517,1 +514,1 @@\n-    public void testJoin17() throws Exception {\n+    void testJoin17() throws Exception {\n@@ -533,1 +530,1 @@\n-    public void testJoin18() throws Exception {\n+    void testJoin18() throws Exception {\n@@ -541,1 +538,1 @@\n-    public void testJoin19() throws Exception {\n+    void testJoin19() throws Exception {\n@@ -558,1 +555,1 @@\n-    public void testJoin20() throws Exception {\n+    void testJoin20() throws Exception {\n@@ -566,1 +563,1 @@\n-    public void testJoin21() throws Exception {\n+    void testJoin21() throws Exception {\n@@ -582,1 +579,1 @@\n-    public void testJoin22() throws Exception {\n+    void testJoin22() throws Exception {\n@@ -590,1 +587,1 @@\n-    public void testJoin23() throws Exception {\n+    void testJoin23() throws Exception {\n@@ -606,1 +603,1 @@\n-    public void testJoin24() throws Exception {\n+    void testJoin24() throws Exception {\n@@ -614,1 +611,1 @@\n-    public void testJoin25() throws Exception {\n+    void testJoin25() throws Exception {\n@@ -631,1 +628,1 @@\n-    public void testJoin26() throws Exception {\n+    void testJoin26() throws Exception {\n@@ -639,1 +636,1 @@\n-    public void testJoin27() throws Exception {\n+    void testJoin27() throws Exception {\n@@ -664,1 +661,1 @@\n-    public void testJoin28() throws Exception {\n+    void testJoin28() throws Exception {\n@@ -684,1 +681,1 @@\n-    public void testJoin29() throws Exception {\n+    void testJoin29() throws Exception {\n@@ -706,1 +703,1 @@\n-    public void testJoin30() throws Exception {\n+    void testJoin30() throws Exception {\n@@ -734,1 +731,1 @@\n-    public void testJoin31() throws Exception {\n+    void testJoin31() throws Exception {\n@@ -751,1 +748,1 @@\n-    public void testJoin32() throws Exception {\n+    void testJoin32() throws Exception {\n@@ -760,1 +757,1 @@\n-    public void testJoin33() throws Exception {\n+    void testJoin33() throws Exception {\n@@ -781,1 +778,1 @@\n-    public void testJoin34() throws Exception {\n+    void testJoin34() throws Exception {\n@@ -796,1 +793,1 @@\n-    public void testJoin35() throws Exception {\n+    void testJoin35() throws Exception {\n@@ -819,1 +816,1 @@\n-    public void testInterrupt1() throws Exception {\n+    void testInterrupt1() throws Exception {\n@@ -835,1 +832,1 @@\n-    public void testInterrupt2() throws Exception {\n+    void testInterrupt2() throws Exception {\n@@ -845,1 +842,1 @@\n-    public void testInterrupt3() throws Exception {\n+    void testInterrupt3() throws Exception {\n@@ -856,1 +853,1 @@\n-    public void testInterrupt4() throws Exception {\n+    void testInterrupt4() throws Exception {\n@@ -868,1 +865,1 @@\n-    public void testInterrupt5() throws Exception {\n+    void testInterrupt5() throws Exception {\n@@ -883,1 +880,1 @@\n-        assertTrue(exception.get() == null);\n+        assertNull(exception.get());\n@@ -890,1 +887,1 @@\n-    public void testInterrupt6() throws Exception {\n+    void testInterrupt6() throws Exception {\n@@ -908,1 +905,1 @@\n-        assertTrue(exception.get() == null);\n+        assertNull(exception.get());\n@@ -915,1 +912,1 @@\n-    public void testInterrupt7() throws Exception {\n+    void testInterrupt7() throws Exception {\n@@ -928,1 +925,1 @@\n-        assertTrue(exception.get() == null);\n+        assertNull(exception.get());\n@@ -935,1 +932,1 @@\n-    public void testInterrupt8() throws Exception {\n+    void testInterrupt8() throws Exception {\n@@ -948,1 +945,1 @@\n-    public void testInterrupt9() throws Exception {\n+    void testInterrupt9() throws Exception {\n@@ -967,1 +964,1 @@\n-    public void testInterrupt10() throws Exception {\n+    void testInterrupt10() throws Exception {\n@@ -982,1 +979,1 @@\n-    public void testSetName1() throws Exception {\n+    void testSetName1() throws Exception {\n@@ -987,1 +984,1 @@\n-            assertEquals(me.getName(), \"fred\");\n+            assertEquals(\"fred\", me.getName());\n@@ -995,1 +992,1 @@\n-    public void testSetName2() throws Exception {\n+    void testSetName2() throws Exception {\n@@ -998,1 +995,1 @@\n-            assertEquals(me.getName(), \"fred\");\n+            assertEquals(\"fred\", me.getName());\n@@ -1000,1 +997,1 @@\n-            assertEquals(me.getName(), \"joe\");\n+            assertEquals(\"joe\", me.getName());\n@@ -1008,1 +1005,1 @@\n-    public void testSetName3() throws Exception {\n+    void testSetName3() throws Exception {\n@@ -1014,1 +1011,1 @@\n-        assertEquals(thread.getName(), \"fred1\");\n+        assertEquals(\"fred1\", thread.getName());\n@@ -1019,1 +1016,1 @@\n-            assertEquals(thread.getName(), \"fred1\");\n+            assertEquals(\"fred1\", thread.getName());\n@@ -1021,1 +1018,1 @@\n-            assertEquals(thread.getName(), \"fred2\");\n+            assertEquals(\"fred2\", thread.getName());\n@@ -1028,1 +1025,1 @@\n-        assertEquals(thread.getName(), \"fred2\");\n+        assertEquals(\"fred2\", thread.getName());\n@@ -1030,1 +1027,1 @@\n-        assertEquals(thread.getName(), \"fred3\");\n+        assertEquals(\"fred3\", thread.getName());\n@@ -1037,1 +1034,1 @@\n-    public void testSetPriority1() throws Exception {\n+    void testSetPriority1() throws Exception {\n@@ -1059,1 +1056,1 @@\n-    public void testSetPriority2() throws Exception {\n+    void testSetPriority2() throws Exception {\n@@ -1106,1 +1103,1 @@\n-    public void testSetDaemon1() throws Exception {\n+    void testSetDaemon1() throws Exception {\n@@ -1119,1 +1116,1 @@\n-    public void testSetDaemon2() throws Exception {\n+    void testSetDaemon2() throws Exception {\n@@ -1146,3 +1143,2 @@\n-    public void testYield1() throws Exception {\n-        if (!ThreadBuilders.supportsCustomScheduler())\n-            throw new SkipException(\"No support for custom schedulers\");\n+    void testYield1() throws Exception {\n+        assumeTrue(ThreadBuilders.supportsCustomScheduler(), \"No support for custom schedulers\");\n@@ -1168,1 +1164,1 @@\n-        assertEquals(list, List.of(\"A\", \"B\", \"A\", \"B\"));\n+        assertEquals(List.of(\"A\", \"B\", \"A\", \"B\"), list);\n@@ -1175,3 +1171,2 @@\n-    public void testYield2() throws Exception {\n-        if (!ThreadBuilders.supportsCustomScheduler())\n-            throw new SkipException(\"No support for custom schedulers\");\n+    void testYield2() throws Exception {\n+        assumeTrue(ThreadBuilders.supportsCustomScheduler(), \"No support for custom schedulers\");\n@@ -1197,1 +1192,1 @@\n-        assertEquals(list, List.of(\"A\", \"A\", \"B\"));\n+        assertEquals(List.of(\"A\", \"A\", \"B\"), list);\n@@ -1204,1 +1199,1 @@\n-    public void testOnSpinWait() throws Exception {\n+    void testOnSpinWait() throws Exception {\n@@ -1216,1 +1211,1 @@\n-    public void testSleep1() throws Exception {\n+    void testSleep1() throws Exception {\n@@ -1230,1 +1225,1 @@\n-    public void testSleep2() throws Exception {\n+    void testSleep2() throws Exception {\n@@ -1239,3 +1234,2 @@\n-    @DataProvider(name = \"oneSecondSleepers\")\n-    public Object[][] oneSecondSleepers() {\n-        ThrowingRunnable[] sleepers = {\n+    static Stream<ThrowingRunnable> oneSecondSleepers() {\n+        return Stream.of(\n@@ -1244,4 +1238,1 @@\n-        };\n-        return Arrays.stream(sleepers)\n-                .map(s -> new Object[] { s })\n-                .toArray(Object[][]::new);\n+        );\n@@ -1253,2 +1244,3 @@\n-    @Test(dataProvider = \"oneSecondSleepers\")\n-    public void testSleep3(ThrowingRunnable sleeper) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"oneSecondSleepers\")\n+    void testSleep3(ThrowingRunnable sleeper) throws Exception {\n@@ -1265,3 +1257,2 @@\n-    @DataProvider(name = \"sleepers\")\n-    public Object[][] sleepers() {\n-        ThrowingRunnable[] sleepers = {\n+    static Stream<ThrowingRunnable> sleepers() {\n+        return Stream.of(\n@@ -1273,5 +1264,2 @@\n-                () -> Thread.sleep(Duration.ofMillis(1000)),\n-        };\n-        return Arrays.stream(sleepers)\n-                .map(s -> new Object[] { s })\n-                .toArray(Object[][]::new);\n+                () -> Thread.sleep(Duration.ofMillis(1000))\n+        );\n@@ -1283,2 +1271,3 @@\n-    @Test(dataProvider = \"sleepers\")\n-    public void testSleep4(ThrowingRunnable sleeper) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"sleepers\")\n+    void testSleep4(ThrowingRunnable sleeper) throws Exception {\n@@ -1302,1 +1291,1 @@\n-    public void testSleep4() throws Exception {\n+    void testSleep4() throws Exception {\n@@ -1314,3 +1303,2 @@\n-    @DataProvider(name = \"longSleepers\")\n-    public Object[][] longSleepers() {\n-        ThrowingRunnable[] sleepers = {\n+    static Stream<ThrowingRunnable> longSleepers() {\n+        return Stream.of(\n@@ -1319,5 +1307,2 @@\n-                () -> Thread.sleep(Duration.ofSeconds(20)),\n-        };\n-        return Arrays.stream(sleepers)\n-                .map(s -> new Object[] { s })\n-                .toArray(Object[][]::new);\n+                () -> Thread.sleep(Duration.ofSeconds(20))\n+        );\n@@ -1329,2 +1314,3 @@\n-    @Test(dataProvider = \"longSleepers\")\n-    public void testSleep5(ThrowingRunnable sleeper) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"longSleepers\")\n+    void testSleep5(ThrowingRunnable sleeper) throws Exception {\n@@ -1348,1 +1334,1 @@\n-    public void testSleep6() throws Exception {\n+    void testSleep6() throws Exception {\n@@ -1365,1 +1351,1 @@\n-    public void testSleep7() throws Exception {\n+    void testSleep7() throws Exception {\n@@ -1393,1 +1379,1 @@\n-    public void testSleep8() throws Exception {\n+    void testSleep8() throws Exception {\n@@ -1407,1 +1393,1 @@\n-    public void testSleep9() throws Exception {\n+    void testSleep9() throws Exception {\n@@ -1427,1 +1413,1 @@\n-    public void testSleep10() throws Exception {\n+    void testSleep10() throws Exception {\n@@ -1447,1 +1433,1 @@\n-    public void testSleep11() throws Exception {\n+    void testSleep11() throws Exception {\n@@ -1481,1 +1467,1 @@\n-    public void testContextClassLoader1() throws Exception {\n+    void testContextClassLoader1() throws Exception {\n@@ -1494,1 +1480,1 @@\n-    public void testContextClassLoader2() throws Exception {\n+    void testContextClassLoader2() throws Exception {\n@@ -1512,1 +1498,1 @@\n-    public void testContextClassLoader3() throws Exception {\n+    void testContextClassLoader3() throws Exception {\n@@ -1526,1 +1512,1 @@\n-    public void testContextClassLoader4() throws Exception {\n+    void testContextClassLoader4() throws Exception {\n@@ -1546,1 +1532,1 @@\n-    public void testContextClassLoader5() throws Exception {\n+    void testContextClassLoader5() throws Exception {\n@@ -1563,1 +1549,1 @@\n-    public void testContextClassLoader6() throws Exception {\n+    void testContextClassLoader6() throws Exception {\n@@ -1581,1 +1567,1 @@\n-    public void testUncaughtExceptionHandler1() throws Exception {\n+    void testUncaughtExceptionHandler1() throws Exception {\n@@ -1594,1 +1580,1 @@\n-        assertTrue(thread.getUncaughtExceptionHandler() == null);\n+        assertNull(thread.getUncaughtExceptionHandler());\n@@ -1601,1 +1587,1 @@\n-    public void testUncaughtExceptionHandler2() throws Exception {\n+    void testUncaughtExceptionHandler2() throws Exception {\n@@ -1618,1 +1604,1 @@\n-        assertTrue(thread.getUncaughtExceptionHandler() == null);\n+        assertNull(thread.getUncaughtExceptionHandler());\n@@ -1625,1 +1611,1 @@\n-    public void testUncaughtExceptionHandler3() throws Exception {\n+    void testUncaughtExceptionHandler3() throws Exception {\n@@ -1631,1 +1617,1 @@\n-        assertTrue(thread.getUncaughtExceptionHandler() == null);\n+        assertNull(thread.getUncaughtExceptionHandler());\n@@ -1638,1 +1624,1 @@\n-    public void testThreadId1() throws Exception {\n+    void testThreadId1() throws Exception {\n@@ -1674,1 +1660,1 @@\n-    public void testThreadId2() throws Exception {\n+    void testThreadId2() throws Exception {\n@@ -1688,1 +1674,1 @@\n-    public void testGetState1() {\n+    void testGetState1() {\n@@ -1697,1 +1683,1 @@\n-    public void testGetState2() throws Exception {\n+    void testGetState2() throws Exception {\n@@ -1708,3 +1694,2 @@\n-    public void testGetState3() throws Exception {\n-        if (!ThreadBuilders.supportsCustomScheduler())\n-            throw new SkipException(\"No support for custom schedulers\");\n+    void testGetState3() throws Exception {\n+        assumeTrue(ThreadBuilders.supportsCustomScheduler(), \"No support for custom schedulers\");\n@@ -1745,1 +1730,1 @@\n-    public void testGetState4() throws Exception {\n+    void testGetState4() throws Exception {\n@@ -1758,1 +1743,1 @@\n-    public void testGetState5() throws Exception {\n+    void testGetState5() throws Exception {\n@@ -1775,1 +1760,1 @@\n-    public void testGetState6() throws Exception {\n+    void testGetState6() throws Exception {\n@@ -1792,1 +1777,1 @@\n-    public void testGetState7() throws Exception {\n+    void testGetState7() throws Exception {\n@@ -1809,1 +1794,1 @@\n-    public void testGetState8() throws Exception {\n+    void testGetState8() throws Exception {\n@@ -1819,1 +1804,1 @@\n-    public void testIsAlive1() throws Exception {\n+    void testIsAlive1() throws Exception {\n@@ -1841,1 +1826,1 @@\n-    public void testHoldsLock1() throws Exception {\n+    void testHoldsLock1() throws Exception {\n@@ -1852,1 +1837,1 @@\n-    public void testHoldsLock2() throws Exception {\n+    void testHoldsLock2() throws Exception {\n@@ -1865,1 +1850,1 @@\n-    public void testGetStackTrace1() {\n+    void testGetStackTrace1() {\n@@ -1875,3 +1860,2 @@\n-    public void testGetStackTrace2() throws Exception {\n-        if (!ThreadBuilders.supportsCustomScheduler())\n-            throw new SkipException(\"Requires continuations support\");\n+    void testGetStackTrace2() throws Exception {\n+        assumeTrue(ThreadBuilders.supportsCustomScheduler(), \"No support for custom schedulers\");\n@@ -1889,1 +1873,1 @@\n-    public void testGetStackTrace3() throws Exception {\n+    void testGetStackTrace3() throws Exception {\n@@ -1909,3 +1893,2 @@\n-    public void testGetStackTrace4() throws Exception {\n-        if (!ThreadBuilders.supportsCustomScheduler())\n-            throw new SkipException(\"No support for custom schedulers\");\n+    void testGetStackTrace4() throws Exception {\n+        assumeTrue(ThreadBuilders.supportsCustomScheduler(), \"No support for custom schedulers\");\n@@ -1964,1 +1947,1 @@\n-    public void testGetStackTrace5() throws Exception {\n+    void testGetStackTrace5() throws Exception {\n@@ -1985,1 +1968,1 @@\n-    public void testGetStackTrace6() throws Exception {\n+    void testGetStackTrace6() throws Exception {\n@@ -1996,1 +1979,1 @@\n-    public void testGetAllStackTraces1() throws Exception {\n+    void testGetAllStackTraces1() throws Exception {\n@@ -2007,3 +1990,2 @@\n-    public void testGetAllStackTraces2() throws Exception {\n-        if (!ThreadBuilders.supportsCustomScheduler())\n-            throw new SkipException(\"No support for custom schedulers\");\n+    void testGetAllStackTraces2() throws Exception {\n+        assumeTrue(ThreadBuilders.supportsCustomScheduler(), \"No support for custom schedulers\");\n@@ -2049,1 +2031,1 @@\n-            assertTrue(stackTrace != null);\n+            assertNotNull(stackTrace);\n@@ -2054,1 +2036,1 @@\n-            assertTrue(map.get(vthread) == null);\n+            assertNull(map.get(vthread));\n@@ -2068,1 +2050,1 @@\n-    public void testThreadGroup1() throws Exception {\n+    void testThreadGroup1() throws Exception {\n@@ -2078,1 +2060,1 @@\n-        assertTrue(thread.getThreadGroup() == null);\n+        assertNull(thread.getThreadGroup());\n@@ -2085,1 +2067,1 @@\n-    public void testThreadGroup2() throws Exception {\n+    void testThreadGroup2() throws Exception {\n@@ -2099,1 +2081,1 @@\n-    public void testThreadGroup3() throws Exception {\n+    void testThreadGroup3() throws Exception {\n@@ -2127,1 +2109,1 @@\n-    public void testThreadGroup4() throws Exception {\n+    void testThreadGroup4() throws Exception {\n@@ -2151,1 +2133,1 @@\n-    public void testEnumerate1() throws Exception {\n+    void testEnumerate1() throws Exception {\n@@ -2164,1 +2146,1 @@\n-    public void testEnumerate2() throws Exception {\n+    void testEnumerate2() throws Exception {\n@@ -2177,1 +2159,1 @@\n-    public void testEqualsAndHashCode() throws Exception {\n+    void testEqualsAndHashCode() throws Exception {\n@@ -2182,4 +2164,4 @@\n-        assertEquals(vthread1, vthread1);\n-        assertNotEquals(vthread1, vthread2);\n-        assertEquals(vthread2, vthread2);\n-        assertNotEquals(vthread2, vthread1);\n+        assertTrue(vthread1.equals(vthread1));\n+        assertTrue(vthread2.equals(vthread2));\n+        assertFalse(vthread1.equals(vthread2));\n+        assertFalse(vthread2.equals(vthread1));\n@@ -2193,4 +2175,4 @@\n-            assertEquals(vthread1, vthread1);\n-            assertNotEquals(vthread1, vthread2);\n-            assertEquals(vthread2, vthread2);\n-            assertNotEquals(vthread2, vthread1);\n+            assertTrue(vthread1.equals(vthread1));\n+            assertTrue(vthread2.equals(vthread2));\n+            assertFalse(vthread1.equals(vthread2));\n+            assertFalse(vthread2.equals(vthread1));\n@@ -2207,4 +2189,4 @@\n-        assertEquals(vthread1, vthread1);\n-        assertNotEquals(vthread1, vthread2);\n-        assertEquals(vthread2, vthread2);\n-        assertNotEquals(vthread2, vthread1);\n+        assertTrue(vthread1.equals(vthread1));\n+        assertTrue(vthread2.equals(vthread2));\n+        assertFalse(vthread1.equals(vthread2));\n+        assertFalse(vthread2.equals(vthread1));\n@@ -2219,1 +2201,1 @@\n-    public void testToString1() {\n+    void testToString1() {\n@@ -2229,1 +2211,1 @@\n-    public void testToString2() throws Exception {\n+    void testToString2() throws Exception {\n@@ -2241,1 +2223,1 @@\n-    public void testToString3() throws Exception {\n+    void testToString3() throws Exception {\n@@ -2262,1 +2244,1 @@\n-    public void testToString4() throws Exception {\n+    void testToString4() throws Exception {\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ThreadAPI.java","additions":193,"deletions":211,"binary":false,"changes":404,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng ThreadLocals\n+ * @run junit ThreadLocals\n@@ -33,2 +33,2 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -36,1 +36,1 @@\n-public class ThreadLocals {\n+class ThreadLocals {\n@@ -44,1 +44,1 @@\n-    public void testThreadLocal1() throws Exception {\n+    void testThreadLocal1() throws Exception {\n@@ -47,1 +47,1 @@\n-                assertTrue(LOCAL.get() == null);\n+                assertNull(LOCAL.get());\n@@ -59,1 +59,1 @@\n-    public void testThreadLocal2() throws Exception {\n+    void testThreadLocal2() throws Exception {\n@@ -61,1 +61,1 @@\n-            assertTrue(LOCAL.get() == null);\n+            assertNull(LOCAL.get());\n@@ -73,1 +73,1 @@\n-    public void testThreadLocal3() throws Exception {\n+    void testThreadLocal3() throws Exception {\n@@ -91,1 +91,1 @@\n-            assertTrue(LOCAL.get() == null);\n+            assertNull(LOCAL.get());\n@@ -101,1 +101,1 @@\n-            assertTrue(INHERITED_LOCAL.get() == null);\n+            assertNull(INHERITED_LOCAL.get());\n@@ -115,2 +115,2 @@\n-    public void testInheritedThreadLocal1() throws Exception {\n-        assertTrue(INHERITED_LOCAL.get() == null);\n+    void testInheritedThreadLocal1() throws Exception {\n+        assertNull(INHERITED_LOCAL.get());\n@@ -119,1 +119,1 @@\n-                assertTrue(INHERITED_LOCAL.get() == null);\n+                assertNull(INHERITED_LOCAL.get());\n@@ -125,1 +125,1 @@\n-        assertTrue(INHERITED_LOCAL.get() == null);\n+        assertNull(INHERITED_LOCAL.get());\n@@ -132,2 +132,2 @@\n-    public void testInheritedThreadLocal2() throws Exception {\n-        assertTrue(INHERITED_LOCAL.get() == null);\n+    void testInheritedThreadLocal2() throws Exception {\n+        assertNull(INHERITED_LOCAL.get());\n@@ -149,2 +149,2 @@\n-    public void testInheritedThreadLocal3() throws Exception {\n-        assertTrue(INHERITED_LOCAL.get() == null);\n+    void testInheritedThreadLocal3() throws Exception {\n+        assertNull(INHERITED_LOCAL.get());\n@@ -160,1 +160,1 @@\n-        assertTrue(INHERITED_LOCAL.get() == null);\n+        assertNull(INHERITED_LOCAL.get());\n@@ -168,2 +168,2 @@\n-    public void testInheritedThreadLocal4() throws Exception {\n-        assertTrue(INHERITED_LOCAL.get() == null);\n+    void testInheritedThreadLocal4() throws Exception {\n+        assertNull(INHERITED_LOCAL.get());\n@@ -175,1 +175,1 @@\n-                assertTrue(INHERITED_LOCAL.get() == null);\n+                assertNull(INHERITED_LOCAL.get());\n@@ -187,2 +187,2 @@\n-    public void testInheritedThreadLocal5() throws Exception {\n-        assertTrue(INHERITED_LOCAL.get() == null);\n+    void testInheritedThreadLocal5() throws Exception {\n+        assertNull(INHERITED_LOCAL.get());\n@@ -194,1 +194,1 @@\n-                assertTrue(INHERITED_LOCAL.get() == null);\n+                assertNull(INHERITED_LOCAL.get());\n@@ -199,1 +199,1 @@\n-        assertTrue(INHERITED_LOCAL.get() == null);\n+        assertNull(INHERITED_LOCAL.get());\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ThreadLocals.java","additions":28,"deletions":28,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,2 @@\n- * @run testng\/othervm -Djdk.tracePinnedThreads=full TracePinnedThreads\n- * @run testng\/othervm -Djdk.tracePinnedThreads=short TracePinnedThreads\n+ * @run junit\/othervm -Djdk.tracePinnedThreads=full TracePinnedThreads\n+ * @run junit\/othervm -Djdk.tracePinnedThreads=short TracePinnedThreads\n@@ -41,2 +41,2 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -44,1 +44,1 @@\n-public class TracePinnedThreads {\n+class TracePinnedThreads {\n@@ -65,1 +65,1 @@\n-    public void testPinnedCausedBySynchronizedBlock() throws Exception {\n+    void testPinnedCausedBySynchronizedBlock() throws Exception {\n@@ -79,1 +79,1 @@\n-    public void testPinnedCausedByNativeMethod() throws Exception {\n+    void testPinnedCausedByNativeMethod() throws Exception {\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/TracePinnedThreads.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng WaitNotify\n+ * @run junit WaitNotify\n@@ -35,2 +35,2 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -38,1 +38,1 @@\n-public class WaitNotify {\n+class WaitNotify {\n@@ -44,1 +44,1 @@\n-    public void testWaitNotify1() throws Exception {\n+    void testWaitNotify1() throws Exception {\n@@ -67,1 +67,1 @@\n-    public void testWaitNotify2() throws Exception {\n+    void testWaitNotify2() throws Exception {\n@@ -87,1 +87,1 @@\n-    public void testWaitNotify3() throws Exception {\n+    void testWaitNotify3() throws Exception {\n@@ -112,1 +112,1 @@\n-    public void testWaitNotify4() throws Exception {\n+    void testWaitNotify4() throws Exception {\n@@ -133,1 +133,1 @@\n-    public void testWaitNotify5() throws Exception {\n+    void testWaitNotify5() throws Exception {\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/WaitNotify.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @run testng BasicTests\n+ * @run junit BasicTests\n@@ -37,2 +37,2 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -40,1 +40,1 @@\n-public class BasicTests {\n+class BasicTests {\n@@ -43,1 +43,1 @@\n-    public void testGetName1() {\n+    void testGetName1() {\n@@ -49,1 +49,1 @@\n-    public void testGetName2() {\n+    void testGetName2() {\n@@ -51,1 +51,1 @@\n-        assertEquals(group.getName(), \"fred\");\n+        assertEquals(\"fred\", group.getName());\n@@ -55,1 +55,1 @@\n-    public void testGetParent() {\n+    void testGetParent() {\n@@ -66,1 +66,1 @@\n-    public void testParentOf() {\n+    void testParentOf() {\n@@ -88,1 +88,1 @@\n-    public void testActiveCount1() {\n+    void testActiveCount1() {\n@@ -101,1 +101,1 @@\n-    public void testActiveCount2() {\n+    void testActiveCount2() {\n@@ -127,1 +127,1 @@\n-    public void enumerateThreads1() {\n+    void enumerateThreads1() {\n@@ -159,1 +159,1 @@\n-    public void enumerateThreads2() {\n+    void enumerateThreads2() {\n@@ -206,1 +206,1 @@\n-                assertEquals(toSet(threads, 2), Set.of(thread1, thread2));\n+                assertEquals(Set.of(thread1, thread2), toSet(threads, 2));\n@@ -211,1 +211,1 @@\n-                assertEquals(toSet(threads, 2), Set.of(thread1, thread2));\n+                assertEquals(Set.of(thread1, thread2), toSet(threads, 2));\n@@ -264,1 +264,1 @@\n-    public void enumerateThreads3() {\n+    void enumerateThreads3() {\n@@ -307,1 +307,1 @@\n-                assertEquals(toSet(threads, 2), Set.of(thread2, thread3));\n+                assertEquals(Set.of(thread2, thread3), toSet(threads, 2));\n@@ -311,1 +311,1 @@\n-                assertEquals(toSet(threads, 2), Set.of(thread2, thread3));\n+                assertEquals(Set.of(thread2, thread3), toSet(threads, 2));\n@@ -316,1 +316,1 @@\n-                assertEquals(toSet(threads, 2), Set.of(thread2, thread3));\n+                assertEquals(Set.of(thread2, thread3), toSet(threads, 2));\n@@ -320,1 +320,1 @@\n-                assertEquals(toSet(threads, 2), Set.of(thread2, thread3));\n+                assertEquals(Set.of(thread2, thread3), toSet(threads, 2));\n@@ -394,1 +394,1 @@\n-    public void enumerateThreads4() {\n+    void enumerateThreads4() {\n@@ -421,1 +421,1 @@\n-    public void testActiveGroupCount() throws Exception {\n+    void testActiveGroupCount() throws Exception {\n@@ -447,1 +447,1 @@\n-    public void testEnumerateGroups1() throws Exception {\n+    void testEnumerateGroups1() throws Exception {\n@@ -480,1 +480,1 @@\n-        assertEquals(toSet(groups, 2), Set.of(group2, group3));\n+        assertEquals(Set.of(group2, group3), toSet(groups, 2));\n@@ -485,1 +485,1 @@\n-        assertEquals(toSet(groups, 2), Set.of(group2, group3));\n+        assertEquals(Set.of(group2, group3), toSet(groups, 2));\n@@ -549,1 +549,1 @@\n-    public void testEnumerateGroups2() throws Exception {\n+    void testEnumerateGroups2() throws Exception {\n@@ -571,1 +571,1 @@\n-    public void testMaxPriority1() {\n+    void testMaxPriority1() {\n@@ -595,1 +595,1 @@\n-    public void testMaxPriority2() {\n+    void testMaxPriority2() {\n@@ -633,1 +633,1 @@\n-    public void testMaxPriority3() {\n+    void testMaxPriority3() {\n@@ -659,1 +659,1 @@\n-    public void testInterrupt1() {\n+    void testInterrupt1() {\n@@ -672,1 +672,1 @@\n-    public void testInterrupt2() {\n+    void testInterrupt2() {\n@@ -688,1 +688,1 @@\n-    public void testInterrupt3() {\n+    void testInterrupt3() {\n@@ -704,1 +704,1 @@\n-    public void testDestroy() {\n+    void testDestroy() {\n@@ -712,1 +712,1 @@\n-    public void testDaemon() {\n+    void testDaemon() {\n@@ -730,1 +730,1 @@\n-    public void testList() {\n+    void testList() {\n@@ -736,1 +736,1 @@\n-    public void testSuspend() {\n+    void testSuspend() {\n@@ -742,1 +742,1 @@\n-    public void testResume() {\n+    void testResume() {\n@@ -748,1 +748,1 @@\n-    public void testStop() {\n+    void testStop() {\n@@ -754,1 +754,1 @@\n-    public void testNull1() {\n+    void testNull1() {\n@@ -760,1 +760,1 @@\n-    public void testNull2() {\n+    void testNull2() {\n@@ -767,1 +767,1 @@\n-    public void testNull3() {\n+    void testNull3() {\n@@ -774,1 +774,1 @@\n-    public void testNull4() {\n+    void testNull4() {\n@@ -781,1 +781,1 @@\n-    public void testNull5() {\n+    void testNull5() {\n@@ -787,1 +787,1 @@\n-    private <T> Set<T> toSet(T[] array, int len) {\n+    private static <T> Set<T> toSet(T[] array, int len) {\n@@ -791,1 +791,1 @@\n-    static class TestThread extends Thread {\n+    private static class TestThread extends Thread {\n@@ -805,0 +805,1 @@\n+        @Override\n","filename":"test\/jdk\/java\/lang\/ThreadGroup\/BasicTests.java","additions":47,"deletions":46,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -225,1 +225,1 @@\n-            return ForceGC.wait(() -> weakRef.refersTo(null));\n+            return ForceGC.waitFor(() -> weakRef.refersTo(null), 2000L);\n","filename":"test\/jdk\/java\/lang\/invoke\/defineHiddenClass\/UnloadingTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run testng\/othervm VirtualThreads\n+ * @run junit\/othervm VirtualThreads\n@@ -38,1 +38,1 @@\n- * @run testng\/othervm -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations VirtualThreads\n+ * @run junit\/othervm -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations VirtualThreads\n@@ -54,3 +54,3 @@\n-import org.testng.SkipException;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assumptions.*;\n@@ -65,1 +65,1 @@\n-    public void testGetAllThreadIds() throws Exception {\n+    void testGetAllThreadIds() throws Exception {\n@@ -86,1 +86,1 @@\n-    public void testGetThreadInfo1() throws Exception {\n+    void testGetThreadInfo1() throws Exception {\n@@ -102,1 +102,1 @@\n-    public void testGetThreadInfo2() throws Exception {\n+    void testGetThreadInfo2() throws Exception {\n@@ -115,3 +115,2 @@\n-    public void testGetThreadInfo3() throws Exception {\n-        if (!supportsCustomScheduler())\n-            throw new SkipException(\"No support for custom schedulers\");\n+    void testGetThreadInfo3() throws Exception {\n+        assumeTrue(supportsCustomScheduler(), \"No support for custom schedulers\");\n@@ -160,1 +159,1 @@\n-    public void testGetThreadInfo4() throws Exception {\n+    void testGetThreadInfo4() throws Exception {\n@@ -178,1 +177,1 @@\n-    public void testGetThreadCpuTime1() {\n+    void testGetThreadCpuTime1() {\n@@ -194,1 +193,1 @@\n-    public void testGetThreadCpuTime2() throws Exception {\n+    void testGetThreadCpuTime2() throws Exception {\n@@ -206,1 +205,1 @@\n-    public void testGetThreadUserTime1() {\n+    void testGetThreadUserTime1() {\n@@ -222,1 +221,1 @@\n-    public void testGetThreadUserTime2() throws Exception {\n+    void testGetThreadUserTime2() throws Exception {\n@@ -234,2 +233,2 @@\n-    @Test(expectedExceptions = { UnsupportedOperationException.class })\n-    public void testGetCurrentThreadCpuTime() throws Exception {\n+    @Test\n+    void testGetCurrentThreadCpuTime() throws Exception {\n@@ -237,1 +236,2 @@\n-            ManagementFactory.getThreadMXBean().getCurrentThreadCpuTime();\n+            assertThrows(UnsupportedOperationException.class,\n+                    () -> ManagementFactory.getThreadMXBean().getCurrentThreadCpuTime());\n@@ -245,2 +245,2 @@\n-    @Test(expectedExceptions = { UnsupportedOperationException.class })\n-    public void testGetCurrentThreadUserTime() throws Exception {\n+    @Test\n+    void testGetCurrentThreadUserTime() throws Exception {\n@@ -248,1 +248,2 @@\n-            ManagementFactory.getThreadMXBean().getCurrentThreadUserTime();\n+            assertThrows(UnsupportedOperationException.class,\n+                    () -> ManagementFactory.getThreadMXBean().getCurrentThreadUserTime());\n@@ -257,1 +258,1 @@\n-    public void testGetCurrentThreadAllocatedBytes() throws Exception {\n+    void testGetCurrentThreadAllocatedBytes() throws Exception {\n","filename":"test\/jdk\/java\/lang\/management\/ThreadMXBean\/VirtualThreads.java","additions":25,"deletions":24,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -731,1 +731,1 @@\n-        AssertionError fail = TRACKER.check(500);\n+        AssertionError fail = TRACKER.check(5000);\n","filename":"test\/jdk\/java\/net\/httpclient\/AbstractThrowingPushPromises.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run main\/othervm ByteArrayPublishers\n+ * @run main\/othervm -Dsun.net.httpserver.idleInterval=50000 ByteArrayPublishers\n","filename":"test\/jdk\/java\/net\/httpclient\/ByteArrayPublishers.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+ *      -Dsun.net.httpserver.idleInterval=50000\n@@ -71,0 +72,1 @@\n+ *      -Dsun.net.httpserver.idleInterval=50000\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpClientLocalAddrTest.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,4 +34,4 @@\n- * @run main\/othervm\/timeout=40 ManyRequestsLegacy\n- * @run main\/othervm\/timeout=40 -Dtest.insertDelay=true ManyRequestsLegacy\n- * @run main\/othervm\/timeout=40 -Dtest.chunkSize=64 ManyRequestsLegacy\n- * @run main\/othervm\/timeout=40 -Dtest.insertDelay=true\n+ * @run main\/othervm\/timeout=80 -Dsun.net.httpserver.idleInterval=50000 ManyRequestsLegacy\n+ * @run main\/othervm\/timeout=80 -Dtest.insertDelay=true -Dsun.net.httpserver.idleInterval=50000 ManyRequestsLegacy\n+ * @run main\/othervm\/timeout=80 -Dtest.chunkSize=64 -Dsun.net.httpserver.idleInterval=50000 ManyRequestsLegacy\n+ * @run main\/othervm\/timeout=80 -Dtest.insertDelay=true -Dsun.net.httpserver.idleInterval=50000\n","filename":"test\/jdk\/java\/net\/httpclient\/ManyRequestsLegacy.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -292,1 +292,1 @@\n-        AssertionError fail = TRACKER.check(500);\n+        AssertionError fail = TRACKER.check(5000);\n","filename":"test\/jdk\/java\/net\/httpclient\/Response204V2Test.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @requires (vm.compMode != \"Xcomp\")\n","filename":"test\/jdk\/java\/net\/httpclient\/SpecialHeadersTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run testng\/othervm BlockingSocketOps\n+ * @run junit BlockingSocketOps\n@@ -39,1 +39,1 @@\n- * @run testng\/othervm -Djdk.useDirectRegister BlockingSocketOps\n+ * @run junit\/othervm -Djdk.useDirectRegister BlockingSocketOps\n@@ -47,1 +47,1 @@\n- * @run testng\/othervm -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations BlockingSocketOps\n+ * @run junit\/othervm -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations BlockingSocketOps\n@@ -65,2 +65,2 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -68,1 +68,1 @@\n-public class BlockingSocketOps {\n+class BlockingSocketOps {\n@@ -74,1 +74,1 @@\n-    public void testSocketReadWrite1() throws Exception {\n+    void testSocketReadWrite1() throws Exception {\n@@ -97,1 +97,1 @@\n-    public void testSocketRead1() throws Exception {\n+    void testSocketRead1() throws Exception {\n@@ -105,1 +105,1 @@\n-    public void testSocketRead2() throws Exception {\n+    void testSocketRead2() throws Exception {\n@@ -135,1 +135,1 @@\n-    public void testSocketWrite1() throws Exception {\n+    void testSocketWrite1() throws Exception {\n@@ -164,1 +164,1 @@\n-    public void testSocketReadPeerClose1() throws Exception {\n+    void testSocketReadPeerClose1() throws Exception {\n@@ -184,1 +184,1 @@\n-    public void testSocketReadPeerClose2() throws Exception {\n+    void testSocketReadPeerClose2() throws Exception {\n@@ -209,1 +209,1 @@\n-    public void testSocketReadAsyncClose1() throws Exception {\n+    void testSocketReadAsyncClose1() throws Exception {\n@@ -217,1 +217,1 @@\n-    public void testSocketReadAsyncClose2() throws Exception {\n+    void testSocketReadAsyncClose2() throws Exception {\n@@ -245,1 +245,1 @@\n-    public void testSocketReadInterrupt1() throws Exception {\n+    void testSocketReadInterrupt1() throws Exception {\n@@ -253,1 +253,1 @@\n-    public void testSocketReadInterrupt2() throws Exception {\n+    void testSocketReadInterrupt2() throws Exception {\n@@ -286,1 +286,1 @@\n-    public void testSocketWriteAsyncClose() throws Exception {\n+    void testSocketWriteAsyncClose() throws Exception {\n@@ -310,1 +310,1 @@\n-    public void testSocketWriteInterrupt() throws Exception {\n+    void testSocketWriteInterrupt() throws Exception {\n@@ -338,1 +338,1 @@\n-    public void testSocketReadUrgentData() throws Exception {\n+    void testSocketReadUrgentData() throws Exception {\n@@ -370,1 +370,1 @@\n-    public void testServerSocketAccept1() throws Exception {\n+    void testServerSocketAccept1() throws Exception {\n@@ -391,1 +391,1 @@\n-    public void testServerSocketAccept2() throws Exception {\n+    void testServerSocketAccept2() throws Exception {\n@@ -399,1 +399,1 @@\n-    public void testServerSocketAccept3() throws Exception {\n+    void testServerSocketAccept3() throws Exception {\n@@ -429,1 +429,1 @@\n-    public void testServerSocketAcceptAsyncClose1() throws Exception {\n+    void testServerSocketAcceptAsyncClose1() throws Exception {\n@@ -437,1 +437,1 @@\n-    public void testServerSocketAcceptAsyncClose2() throws Exception {\n+    void testServerSocketAcceptAsyncClose2() throws Exception {\n@@ -466,1 +466,1 @@\n-    public void testServerSocketAcceptInterrupt1() throws Exception {\n+    void testServerSocketAcceptInterrupt1() throws Exception {\n@@ -474,1 +474,1 @@\n-    public void testServerSocketAcceptInterrupt2() throws Exception {\n+    void testServerSocketAcceptInterrupt2() throws Exception {\n@@ -507,1 +507,1 @@\n-    public void testDatagramSocketSendReceive1() throws Exception {\n+    void testDatagramSocketSendReceive1() throws Exception {\n@@ -526,1 +526,1 @@\n-                assertEquals(p2.getSocketAddress(), s1.getLocalSocketAddress());\n+                assertEquals(s1.getLocalSocketAddress(), p2.getSocketAddress());\n@@ -536,1 +536,1 @@\n-    public void testDatagramSocketSendReceive2() throws Exception {\n+    void testDatagramSocketSendReceive2() throws Exception {\n@@ -544,1 +544,1 @@\n-    public void testDatagramSocketSendReceive3() throws Exception {\n+    void testDatagramSocketSendReceive3() throws Exception {\n@@ -570,1 +570,1 @@\n-                assertEquals(p2.getSocketAddress(), s1.getLocalSocketAddress());\n+                assertEquals(s1.getLocalSocketAddress(), p2.getSocketAddress());\n@@ -580,1 +580,1 @@\n-    public void testDatagramSocketReceiveTimeout() throws Exception {\n+    void testDatagramSocketReceiveTimeout() throws Exception {\n@@ -600,1 +600,1 @@\n-    public void testDatagramSocketReceiveAsyncClose1() throws Exception {\n+    void testDatagramSocketReceiveAsyncClose1() throws Exception {\n@@ -608,1 +608,1 @@\n-    public void testDatagramSocketReceiveAsyncClose2() throws Exception {\n+    void testDatagramSocketReceiveAsyncClose2() throws Exception {\n@@ -639,1 +639,1 @@\n-    public void testDatagramSocketReceiveInterrupt1() throws Exception {\n+    void testDatagramSocketReceiveInterrupt1() throws Exception {\n@@ -647,1 +647,1 @@\n-    public void testDatagramSocketReceiveInterrupt2() throws Exception {\n+    void testDatagramSocketReceiveInterrupt2() throws Exception {\n","filename":"test\/jdk\/java\/net\/vthread\/BlockingSocketOps.java","additions":37,"deletions":37,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,0 @@\n- *     -Dsun.net.client.defaultReadTimeout=5000\n","filename":"test\/jdk\/java\/net\/vthread\/HttpALot.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run testng\/othervm BlockingChannelOps\n+ * @run junit BlockingChannelOps\n@@ -39,1 +39,1 @@\n- * @run testng\/othervm -Djdk.useDirectRegister BlockingChannelOps\n+ * @run junit\/othervm -Djdk.useDirectRegister BlockingChannelOps\n@@ -47,1 +47,1 @@\n- * @run testng\/othervm -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations BlockingChannelOps\n+ * @run junit\/othervm -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations BlockingChannelOps\n@@ -70,2 +70,2 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -73,1 +73,1 @@\n-public class BlockingChannelOps {\n+class BlockingChannelOps {\n@@ -79,1 +79,1 @@\n-    public void testSocketChannelReadWrite1() throws Exception {\n+    void testSocketChannelReadWrite1() throws Exception {\n@@ -103,1 +103,1 @@\n-    public void testSocketChannelRead() throws Exception {\n+    void testSocketChannelRead() throws Exception {\n@@ -126,1 +126,1 @@\n-    public void testSocketChannelWrite() throws Exception {\n+    void testSocketChannelWrite() throws Exception {\n@@ -154,1 +154,1 @@\n-    public void testSocketChannelReadAsyncClose() throws Exception {\n+    void testSocketChannelReadAsyncClose() throws Exception {\n@@ -171,1 +171,1 @@\n-    public void testSocketChannelReadInterrupt() throws Exception {\n+    void testSocketChannelReadInterrupt() throws Exception {\n@@ -194,1 +194,1 @@\n-    public void testSocketChannelWriteAsyncClose() throws Exception {\n+    void testSocketChannelWriteAsyncClose() throws Exception {\n@@ -225,1 +225,1 @@\n-    public void testSocketChannelWriteInterrupt() throws Exception {\n+    void testSocketChannelWriteInterrupt() throws Exception {\n@@ -259,1 +259,1 @@\n-    public void testSocketAdaptorRead1() throws Exception {\n+    void testSocketAdaptorRead1() throws Exception {\n@@ -267,1 +267,1 @@\n-    public void testSocketAdaptorRead2() throws Exception {\n+    void testSocketAdaptorRead2() throws Exception {\n@@ -296,1 +296,1 @@\n-    public void testServerSocketChannelAccept1() throws Exception {\n+    void testServerSocketChannelAccept1() throws Exception {\n@@ -313,1 +313,1 @@\n-    public void testServerSocketChannelAccept2() throws Exception {\n+    void testServerSocketChannelAccept2() throws Exception {\n@@ -334,1 +334,1 @@\n-    public void testServerSocketChannelAcceptAsyncClose() throws Exception {\n+    void testServerSocketChannelAcceptAsyncClose() throws Exception {\n@@ -353,1 +353,1 @@\n-    public void testServerSocketChannelAcceptInterrupt() throws Exception {\n+    void testServerSocketChannelAcceptInterrupt() throws Exception {\n@@ -378,1 +378,1 @@\n-    public void testSocketChannelAdaptorAccept1() throws Exception {\n+    void testSocketChannelAdaptorAccept1() throws Exception {\n@@ -386,1 +386,1 @@\n-    public void testSocketChannelAdaptorAccept2() throws Exception {\n+    void testSocketChannelAdaptorAccept2() throws Exception {\n@@ -413,1 +413,1 @@\n-    public void testDatagramChannelSendReceive1() throws Exception {\n+    void testDatagramChannelSendReceive1() throws Exception {\n@@ -438,1 +438,1 @@\n-    public void testDatagramChannelSendReceive2() throws Exception {\n+    void testDatagramChannelSendReceive2() throws Exception {\n@@ -462,1 +462,1 @@\n-    public void testDatagramChannelReceiveAsyncClose() throws Exception {\n+    void testDatagramChannelReceiveAsyncClose() throws Exception {\n@@ -480,1 +480,1 @@\n-    public void testDatagramChannelReceiveInterrupt() throws Exception {\n+    void testDatagramChannelReceiveInterrupt() throws Exception {\n@@ -504,1 +504,1 @@\n-    public void testDatagramSocketAdaptorReceive1() throws Exception {\n+    void testDatagramSocketAdaptorReceive1() throws Exception {\n@@ -512,1 +512,1 @@\n-    public void testDatagramSocketAdaptorReceive2() throws Exception {\n+    void testDatagramSocketAdaptorReceive2() throws Exception {\n@@ -543,1 +543,1 @@\n-    public void testDatagramSocketAdaptorReceiveAsyncClose1() throws Exception {\n+    void testDatagramSocketAdaptorReceiveAsyncClose1() throws Exception {\n@@ -552,1 +552,1 @@\n-    public void testDatagramSocketAdaptorReceiveAsyncClose2() throws Exception {\n+    void testDatagramSocketAdaptorReceiveAsyncClose2() throws Exception {\n@@ -579,1 +579,1 @@\n-    public void testDatagramSocketAdaptorReceiveInterrupt1() throws Exception {\n+    void testDatagramSocketAdaptorReceiveInterrupt1() throws Exception {\n@@ -588,1 +588,1 @@\n-    public void testDatagramSocketAdaptorReceiveInterrupt2() throws Exception {\n+    void testDatagramSocketAdaptorReceiveInterrupt2() throws Exception {\n@@ -621,1 +621,1 @@\n-    public void testPipeReadWrite1() throws Exception {\n+    void testPipeReadWrite1() throws Exception {\n@@ -645,1 +645,1 @@\n-    public void testPipeReadWrite2() throws Exception {\n+    void testPipeReadWrite2() throws Exception {\n@@ -668,1 +668,1 @@\n-    public void testPipeReadWrite3() throws Exception {\n+    void testPipeReadWrite3() throws Exception {\n@@ -696,1 +696,1 @@\n-    public void testPipeReadAsyncClose() throws Exception {\n+    void testPipeReadAsyncClose() throws Exception {\n@@ -714,1 +714,1 @@\n-    public void testPipeReadInterrupt() throws Exception {\n+    void testPipeReadInterrupt() throws Exception {\n@@ -738,1 +738,1 @@\n-    public void testPipeWriteAsyncClose() throws Exception {\n+    void testPipeWriteAsyncClose() throws Exception {\n@@ -770,1 +770,1 @@\n-    public void testPipeWriteInterrupt() throws Exception {\n+    void testPipeWriteInterrupt() throws Exception {\n","filename":"test\/jdk\/java\/nio\/channels\/vthread\/BlockingChannelOps.java","additions":39,"deletions":39,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 4313887 6838333 6925932 7006126 8037945 8072495 8140449 8254876\n+ * @bug 4313887 6838333 6925932 7006126 8037945 8072495 8140449 8254876 8298478\n@@ -1440,0 +1440,28 @@\n+\n+        \/\/ long path prefixes\n+        test(\"\\\\\\\\?\\\\C:\\\\mnt\\\\file.dat\")  \/\/ absolute\n+            .string(\"C:\\\\mnt\\\\file.dat\");\n+        test(\"\\\\\\\\?\\\\\\\\\\\\server\\\\share\\\\dir\\\\file.dat\")  \/\/ UNC\n+            .invalid();\n+        test(\"\\\\\\\\?\\\\file.dat\")           \/\/ relative\n+            .invalid();\n+        test(\"\\\\\\\\?\\\\\\\\file.dat\")         \/\/ directory-relative\n+            .invalid();\n+        test(\"\\\\\\\\?\\\\C:file.dat\")         \/\/ drive-relative\n+            .invalid();\n+        test(\"\\\\\\\\?\\\\\")                   \/\/ empty\n+            .invalid();\n+\n+        \/\/ long UNC path prefixes\n+        test(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\dir\\\\file.dat\")      \/\/ UNC\n+            .string(\"\\\\\\\\server\\\\share\\\\dir\\\\file.dat\");\n+        test(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\C:\\\\file.dat\")       \/\/ absolute\n+            .invalid();\n+        test(\"\\\\\\\\?\\\\UNC\\\\file.dat\")                          \/\/ relative\n+            .invalid();\n+        test(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\C:file.dat\")         \/\/ drive-relative\n+            .invalid();\n+        test(\"\\\\\\\\?\\\\UNC\")                                    \/\/ empty\n+            .invalid();\n+        test(\"\\\\\\\\?\\\\UNC\\\\\")                                  \/\/ empty\n+            .invalid();\n","filename":"test\/jdk\/java\/nio\/file\/Path\/PathOps.java","additions":30,"deletions":2,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -40,2 +40,4 @@\n- * @run main\/othervm HandshakeTimeout\n- * @run main\/othervm HandshakeTimeout SSL\n+ * @run main\/othervm\/timeout=10 -Dsun.rmi.transport.tcp.handshakeTimeout=1\n+ *                              HandshakeTimeout\n+ * @run main\/othervm\/timeout=10 -Dsun.rmi.transport.tcp.handshakeTimeout=1\n+ *                              HandshakeTimeout SSL\n@@ -49,1 +51,0 @@\n-import java.rmi.MarshalException;\n@@ -55,2 +56,0 @@\n-    private static final int TIMEOUT = 10000;\n-\n@@ -59,3 +58,0 @@\n-        System.setProperty(\"sun.rmi.transport.tcp.handshakeTimeout\",\n-                           String.valueOf(TIMEOUT \/ 2));\n-\n@@ -79,12 +75,3 @@\n-        Connector connector = new Connector(registry);\n-        Thread t = new Thread(connector);\n-        t.setDaemon(true);\n-        t.start();\n-\n-        \/*\n-         * Wait for call attempt to finished, and analyze result.\n-         *\/\n-        t.join(TIMEOUT);\n-        synchronized (connector) {\n-            if (connector.success) {\n-                throw new RuntimeException(\n+        try {\n+            registry.lookup(\"Dale Cooper\");\n+            throw new RuntimeException(\n@@ -92,50 +79,6 @@\n-            }\n-            if (connector.exception == null) {\n-                throw new RuntimeException(\n-                    \"TEST FAILED: remote call did not time out\");\n-            } else {\n-                System.err.println(\"remote call failed with exception:\");\n-                connector.exception.printStackTrace();\n-                System.err.println();\n-\n-                if (connector.exception instanceof MarshalException) {\n-                    throw new RuntimeException(\n-                        \"TEST FAILED: MarshalException thrown, expecting \" +\n-                        \"java.rmi.ConnectException or ConnectIOException\");\n-                } else if (connector.exception instanceof ConnectException ||\n-                           connector.exception instanceof ConnectIOException)\n-                {\n-                    System.err.println(\n-                        \"TEST PASSED: java.rmi.ConnectException or \" +\n-                        \"ConnectIOException thrown\");\n-                } else {\n-                    throw new RuntimeException(\n-                        \"TEST FAILED: unexpected Exception thrown\",\n-                        connector.exception);\n-                }\n-            }\n-        }\n-    }\n-\n-    private static class Connector implements Runnable {\n-\n-        private final Registry registry;\n-\n-        boolean success = false;\n-        Exception exception = null;\n-\n-        Connector(Registry registry) {\n-            this.registry = registry;\n-        }\n-\n-        public void run() {\n-            try {\n-                registry.lookup(\"Dale Cooper\");\n-                synchronized (this) {\n-                    success = true;\n-                }\n-            } catch (Exception e) {\n-                synchronized (this) {\n-                    exception = e;\n-                }\n-            }\n+        } catch (ConnectException | ConnectIOException e) {\n+            System.err.println(\"Got expected exception:\");\n+            e.printStackTrace();\n+            System.err.println(\n+                    \"TEST PASSED: java.rmi.ConnectException or \" +\n+                            \"ConnectIOException thrown\");\n","filename":"test\/jdk\/java\/rmi\/transport\/handshakeTimeout\/HandshakeTimeout.java","additions":13,"deletions":70,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8246077\n+ * @bug 8246077 8300416\n@@ -28,1 +28,2 @@\n- * consistent in the impl of Cloneable interface\n+ * consistent in the impl of Cloneable interface, and that clones do not\n+ * share memory.\n@@ -31,0 +32,1 @@\n+import java.nio.ByteBuffer;\n@@ -32,0 +34,2 @@\n+import java.util.Arrays;\n+import java.util.Random;\n@@ -56,1 +60,1 @@\n-            CloneNotSupportedException {\n+            CloneNotSupportedException, InterruptedException {\n@@ -74,0 +78,25 @@\n+\n+        System.out.print(\"Testing \" + algo + \" impl from \" + provName);\n+        final var d1 = MessageDigest.getInstance(algo, provName);\n+        final var buffer = ByteBuffer.allocateDirect(1024);\n+        final var r = new Random(1024);\n+\n+        fillBuffer(r, buffer);\n+        d1.update(buffer); \/\/ this statement triggers tempArray allocation\n+        final var d2 = (MessageDigest) d1.clone();\n+        assert Arrays.equals(d1.digest(), d2.digest());\n+\n+        final var t1 = updateThread(d1);\n+        final var t2 = updateThread(d2);\n+        t1.join();\n+        t2.join();\n+\n+        System.out.println(\": Shared data check\");\n+        \/\/ Random is producing the same sequence of bytes for each thread,\n+        \/\/ and thus each MessageDigest should be equal. When the memory is\n+        \/\/ shared, they inevitably overwrite each other's tempArray and\n+        \/\/ you get different results.\n+        if (!Arrays.equals(d1.digest(), d2.digest())) {\n+            throw new AssertionError(\"digests differ\");\n+        }\n+\n@@ -76,0 +105,21 @@\n+\n+    private static void fillBuffer(final Random r, final ByteBuffer buffer) {\n+        final byte[] bytes = new byte[buffer.capacity()];\n+        r.nextBytes(bytes);\n+        buffer.clear();\n+        buffer.put(bytes);\n+        buffer.flip();\n+    }\n+\n+    public static Thread updateThread(final MessageDigest d) {\n+        final var t = new Thread(() -> {\n+            final var r = new Random(1024);\n+            final ByteBuffer buffer = ByteBuffer.allocateDirect(1024);\n+            for (int i = 0; i < 1024; i++) {\n+                fillBuffer(r, buffer);\n+                d.update(buffer);\n+            }\n+        });\n+        t.start();\n+        return t;\n+    }\n","filename":"test\/jdk\/java\/security\/MessageDigest\/TestCloneable.java","additions":54,"deletions":4,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n- * @run testng\/othervm Root\n+ * @requires os.family != \"windows\"\n+ * @run testng\/othervm\/manual Root\n@@ -33,0 +34,4 @@\n+\/*\n+* Run test as root user.\n+* *\/\n+\n@@ -38,0 +43,1 @@\n+import java.io.BufferedReader;\n@@ -39,0 +45,1 @@\n+import java.io.InputStreamReader;\n@@ -50,0 +57,2 @@\n+    private static final Path BACKUP = Paths.get(ROOT, \".backup.policy\");\n+    private static final String ROOT_USER_ID = \"0\";\n@@ -53,0 +62,4 @@\n+        \/\/ Backup user policy file if it already exists\n+        if (TARGET.toFile().exists()) {\n+            Files.copy(TARGET, BACKUP, StandardCopyOption.REPLACE_EXISTING);\n+        }\n@@ -59,0 +72,5 @@\n+        \/\/ Restore original policy file if backup exists\n+        if (BACKUP.toFile().exists()) {\n+            Files.copy(BACKUP, TARGET, StandardCopyOption.REPLACE_EXISTING);\n+            Files.delete(BACKUP);\n+        }\n@@ -62,1 +80,19 @@\n-    private void test() {\n+    private void test() throws InterruptedException, IOException {\n+        System.out.println(\"Run test as root user.\");\n+\n+        Process process = Runtime.getRuntime().exec(\"id -u\");\n+        process.waitFor();\n+        if (process.exitValue() != 0) {\n+            throw new RuntimeException(\"Failed to retrieve user id.\");\n+        }\n+\n+        try (BufferedReader reader = new BufferedReader(\n+                new InputStreamReader(process.getInputStream()))) {\n+            String line = reader.readLine();\n+\n+            if (!ROOT_USER_ID.equals(line)) {\n+                throw new RuntimeException(\n+                        \"This test needs to be run with root privilege.\");\n+            }\n+        }\n+\n","filename":"test\/jdk\/java\/security\/Policy\/Root\/Root.java","additions":38,"deletions":2,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng\/othervm -DthreadFactory=platform ThreadPerTaskExecutorTest\n+ * @run junit\/othervm -DthreadFactory=platform ThreadPerTaskExecutorTest\n@@ -34,1 +34,1 @@\n- * @run testng\/othervm -DthreadFactory=virtual ThreadPerTaskExecutorTest\n+ * @run junit\/othervm -DthreadFactory=virtual ThreadPerTaskExecutorTest\n@@ -48,0 +48,1 @@\n+import java.util.stream.Stream;\n@@ -50,5 +51,6 @@\n-import org.testng.annotations.AfterClass;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -56,1 +58,1 @@\n-public class ThreadPerTaskExecutorTest {\n+class ThreadPerTaskExecutorTest {\n@@ -63,2 +65,2 @@\n-    private ScheduledExecutorService scheduler;\n-    private Object[][] threadFactories;\n+    private static ScheduledExecutorService scheduler;\n+    private static List<ThreadFactory> threadFactories;\n@@ -66,8 +68,3 @@\n-    @BeforeClass\n-    public void setUp() throws Exception {\n-        ThreadFactory factory = (task) -> {\n-            Thread thread = new Thread(task);\n-            thread.setDaemon(true);\n-            return thread;\n-        };\n-        this.scheduler = Executors.newSingleThreadScheduledExecutor(factory);\n+    @BeforeAll\n+    static void setup() throws Exception {\n+        scheduler = Executors.newSingleThreadScheduledExecutor();\n@@ -83,3 +80,1 @@\n-        this.threadFactories = list.stream()\n-                .map(f -> new Object[] { f })\n-                .toArray(Object[][]::new);\n+        threadFactories = list;\n@@ -88,2 +83,2 @@\n-    @AfterClass\n-    public void tearDown() {\n+    @AfterAll\n+    static void shutdown() {\n@@ -93,3 +88,2 @@\n-    @DataProvider(name = \"factories\")\n-    public Object[][] factories() {\n-        return threadFactories;\n+    private static Stream<ThreadFactory> factories() {\n+        return threadFactories.stream();\n@@ -98,6 +92,3 @@\n-    @DataProvider(name = \"executors\")\n-    public Object[][] executors() {\n-        return Arrays.stream(threadFactories)\n-                .map(f -> Executors.newThreadPerTaskExecutor((ThreadFactory) f[0]))\n-                .map(e -> new Object[] { e })\n-                .toArray(Object[][]::new);\n+    private static Stream<ExecutorService> executors() {\n+        return threadFactories.stream()\n+                .map(f -> Executors.newThreadPerTaskExecutor(f));\n@@ -117,2 +108,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testThreadPerTask(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testThreadPerTask(ThreadFactory factory) throws Exception {\n@@ -138,1 +130,1 @@\n-        assertEquals(threadCount.get(), NUM_TASKS);\n+        assertEquals(NUM_TASKS, threadCount.get());\n@@ -149,1 +141,1 @@\n-    public void testThreadFactory() throws Exception {\n+    void testThreadFactory() throws Exception {\n@@ -169,2 +161,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testShutdown(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testShutdown(ExecutorService executor) throws Exception {\n@@ -191,2 +184,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testShutdownNow(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testShutdownNow(ExecutorService executor) throws Exception {\n@@ -204,1 +198,1 @@\n-                Throwable e = expectThrows(ExecutionException.class, result::get);\n+                Throwable e = assertThrows(ExecutionException.class, result::get);\n@@ -218,2 +212,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testClose1(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testClose1(ExecutorService executor) throws Exception {\n@@ -229,2 +224,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testClose2(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testClose2(ExecutorService executor) throws Exception {\n@@ -247,2 +243,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testClose3(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testClose3(ExecutorService executor) throws Exception {\n@@ -260,1 +257,1 @@\n-        expectThrows(ExecutionException.class, future::get);\n+        assertThrows(ExecutionException.class, future::get);\n@@ -266,2 +263,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testClose4(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testClose4(ExecutorService executor) throws Exception {\n@@ -278,1 +276,1 @@\n-        expectThrows(ExecutionException.class, future::get);\n+        assertThrows(ExecutionException.class, future::get);\n@@ -284,2 +282,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testClose5(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testClose5(ExecutorService executor) throws Exception {\n@@ -293,2 +292,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testAwaitTermination1(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testAwaitTermination1(ExecutorService executor) throws Exception {\n@@ -303,2 +303,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testAwaitTermination2(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testAwaitTermination2(ExecutorService executor) throws Exception {\n@@ -320,2 +321,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testSubmitAfterShutdown(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testSubmitAfterShutdown(ExecutorService executor) throws Exception {\n@@ -329,1 +331,1 @@\n-                expectThrows(RejectedExecutionException.class,\n+                assertThrows(RejectedExecutionException.class,\n@@ -340,2 +342,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testSubmitAfterTermination(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testSubmitAfterTermination(ExecutorService executor) throws Exception {\n@@ -344,1 +347,1 @@\n-        expectThrows(RejectedExecutionException.class, () -> executor.submit(() -> {}));\n+        assertThrows(RejectedExecutionException.class, () -> executor.submit(() -> {}));\n@@ -350,2 +353,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testSubmitNulls1(ThreadFactory factory) {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testSubmitNulls1(ThreadFactory factory) {\n@@ -356,2 +360,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testSubmitNulls2(ThreadFactory factory) {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testSubmitNulls2(ThreadFactory factory) {\n@@ -365,2 +370,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testInvokeAny1(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAny1(ExecutorService executor) throws Exception {\n@@ -379,2 +385,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testInvokeAny2(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAny2(ExecutorService executor) throws Exception {\n@@ -411,2 +418,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testInvokeAny3(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAny3(ExecutorService executor) throws Exception {\n@@ -431,2 +439,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testInvokeAny4(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAny4(ExecutorService executor) throws Exception {\n@@ -453,2 +462,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testInvokeAny5(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAny5(ExecutorService executor) throws Exception {\n@@ -468,2 +478,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testInvokeAny6(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAny6(ExecutorService executor) throws Exception {\n@@ -485,2 +496,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testInvokeAnyWithTimeout1(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAnyWithTimeout1(ExecutorService executor) throws Exception {\n@@ -499,2 +511,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testInvokeAnyWithTimeout2(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAnyWithTimeout2(ExecutorService executor) throws Exception {\n@@ -531,2 +544,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testInvokeAnyWithTimeout3(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAnyWithTimeout3(ExecutorService executor) throws Exception {\n@@ -551,2 +565,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testInvokeAnyWithTimeout4(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAnyWithTimeout4(ExecutorService executor) throws Exception {\n@@ -568,2 +583,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testInvokeAnyWithInterruptSet(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAnyWithInterruptSet(ExecutorService executor) throws Exception {\n@@ -588,2 +604,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testInterruptInvokeAny(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInterruptInvokeAny(ExecutorService executor) throws Exception {\n@@ -614,2 +631,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testInvokeAnyAfterShutdown(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAnyAfterShutdown(ExecutorService executor) throws Exception {\n@@ -626,2 +644,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testInvokeAnyEmpty1(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testInvokeAnyEmpty1(ThreadFactory factory) throws Exception {\n@@ -636,2 +655,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testInvokeAnyEmpty2(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testInvokeAnyEmpty2(ThreadFactory factory) throws Exception {\n@@ -647,2 +667,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testInvokeAnyNull1(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testInvokeAnyNull1(ThreadFactory factory) throws Exception {\n@@ -657,2 +678,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testInvokeAnyNull2(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testInvokeAnyNull2(ThreadFactory factory) throws Exception {\n@@ -670,2 +692,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testInvokeAll1(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAll1(ExecutorService executor) throws Exception {\n@@ -695,2 +718,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testInvokeAll2(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAll2(ExecutorService executor) throws Exception {\n@@ -714,1 +738,1 @@\n-            Throwable e1 = expectThrows(ExecutionException.class, () -> list.get(0).get());\n+            Throwable e1 = assertThrows(ExecutionException.class, () -> list.get(0).get());\n@@ -716,1 +740,1 @@\n-            Throwable e2 = expectThrows(ExecutionException.class, () -> list.get(1).get());\n+            Throwable e2 = assertThrows(ExecutionException.class, () -> list.get(1).get());\n@@ -724,2 +748,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testInvokeAll3(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAll3(ExecutorService executor) throws Exception {\n@@ -749,2 +774,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testInvokeAll4(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAll4(ExecutorService executor) throws Exception {\n@@ -787,2 +813,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testInvokeAllInterrupt1(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAllInterrupt1(ExecutorService executor) throws Exception {\n@@ -811,2 +838,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testInvokeAllInterrupt3(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAllInterrupt3(ExecutorService executor) throws Exception {\n@@ -835,2 +863,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testInvokeAllInterrupt4(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAllInterrupt4(ExecutorService executor) throws Exception {\n@@ -861,2 +890,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testInvokeAllInterrupt6(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAllInterrupt6(ExecutorService executor) throws Exception {\n@@ -887,2 +917,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testInvokeAllAfterShutdown1(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAllAfterShutdown1(ExecutorService executor) throws Exception {\n@@ -897,2 +928,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testInvokeAllAfterShutdown2(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAllAfterShutdown2(ExecutorService executor) throws Exception {\n@@ -910,2 +942,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testInvokeAllEmpty1(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAllEmpty1(ExecutorService executor) throws Exception {\n@@ -918,2 +951,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testInvokeAllEmpty2(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAllEmpty2(ExecutorService executor) throws Exception {\n@@ -926,2 +960,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testInvokeAllNull1(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testInvokeAllNull1(ThreadFactory factory) throws Exception {\n@@ -933,2 +968,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testInvokeAllNull2(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testInvokeAllNull2(ThreadFactory factory) throws Exception {\n@@ -943,2 +979,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testInvokeAllNull3(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testInvokeAllNull3(ThreadFactory factory) throws Exception {\n@@ -951,2 +988,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testInvokeAllNull4(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testInvokeAllNull4(ThreadFactory factory) throws Exception {\n@@ -960,2 +998,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testInvokeAllNull5(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testInvokeAllNull5(ThreadFactory factory) throws Exception {\n@@ -975,1 +1014,1 @@\n-    public void testNoThreads1() throws Exception {\n+    void testNoThreads1() throws Exception {\n@@ -981,1 +1020,1 @@\n-    public void testNoThreads2() throws Exception {\n+    void testNoThreads2() throws Exception {\n@@ -987,1 +1026,1 @@\n-    public void testNoThreads3() throws Exception {\n+    void testNoThreads3() throws Exception {\n@@ -994,1 +1033,1 @@\n-    public void testNoThreads4() throws Exception {\n+    void testNoThreads4() throws Exception {\n@@ -1001,1 +1040,1 @@\n-    public void testNull() {\n+    void testNull() {\n","filename":"test\/jdk\/java\/util\/concurrent\/ThreadPerTaskExecutor\/ThreadPerTaskExecutorTest.java","additions":182,"deletions":143,"binary":false,"changes":325,"status":"modified"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @modules java.base\/sun.security.tools.keytool\n+ * @summary JARs with pending block files (where .RSA comes before .SF) should verify correctly\n+ *\/\n+\n+import jdk.security.jarsigner.JarSigner;\n+\n+import java.io.File;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.security.KeyStore;\n+import java.util.Collections;\n+import java.util.jar.*;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n+\n+public class SignedJarPendingBlock {\n+\n+    public static void main(String[] args) throws Exception {\n+        Path jar = createJarFile();\n+        Path signed = signJarFile(jar);\n+        Path pendingBlocks = moveBlockFirst(signed);\n+        Path invalid = invalidate(pendingBlocks);\n+\n+        \/\/ 1: Regular signed JAR with no pending blocks should verify\n+        checkSigned(signed);\n+\n+        \/\/ 2: Signed jar with pending blocks should verify\n+        checkSigned(pendingBlocks);\n+\n+        \/\/ 3: Invalid signed jar with pending blocks should throw SecurityException\n+        try {\n+            checkSigned(invalid);\n+            throw new Exception(\"Expected invalid digest to be detected\");\n+        } catch (SecurityException se) {\n+            \/\/ Ignore\n+        }\n+    }\n+\n+    private static void checkSigned(Path b) throws Exception {\n+        try (JarFile jf = new JarFile(b.toFile(), true)) {\n+\n+            JarEntry je = jf.getJarEntry(\"a.txt\");\n+            try (InputStream in = jf.getInputStream(je)) {\n+                in.transferTo(OutputStream.nullOutputStream());\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Invalidate signed file by modifying the contents of \"a.txt\"\n+     *\/\n+    private static Path invalidate(Path s) throws Exception{\n+        Path invalid = Path.of(\"pending-block-file-invalidated.jar\");\n+\n+        try (ZipFile zip = new ZipFile(s.toFile());\n+            ZipOutputStream out = new ZipOutputStream(Files.newOutputStream(invalid))) {\n+\n+            for (ZipEntry ze : Collections.list(zip.entries())) {\n+                String name = ze.getName();\n+                out.putNextEntry(new ZipEntry(name));\n+\n+                if (name.equals(\"a.txt\")) {\n+                    \/\/ Change the contents of a.txt to trigger SignatureException\n+                    out.write(\"b\".getBytes(StandardCharsets.UTF_8));\n+                } else {\n+                    try (InputStream in = zip.getInputStream(ze)) {\n+                        in.transferTo(out);\n+                    }\n+                }\n+            }\n+        }\n+        return invalid;\n+    }\n+\n+    private static Path moveBlockFirst(Path s) throws Exception {\n+        Path b = Path.of(\"pending-block-file-blockfirst.jar\");\n+        try (ZipFile in = new ZipFile(s.toFile());\n+            ZipOutputStream out = new ZipOutputStream(Files.newOutputStream(b))) {\n+\n+            copy(\"META-INF\/MANIFEST.MF\", in, out);\n+\n+            \/\/ Switch the order of the RSA and SF files\n+            copy(\"META-INF\/SIGNER.RSA\", in, out);\n+            copy(\"META-INF\/SIGNER.SF\", in, out);\n+\n+            copy(\"a.txt\", in, out);\n+        }\n+        return b;\n+    }\n+\n+    \/**\n+     * Copy an entry from a ZipFile to a ZipOutputStream\n+     *\/\n+    private static void copy(String name, ZipFile in, ZipOutputStream out) throws Exception {\n+        out.putNextEntry(new ZipEntry(name));\n+        try (InputStream is = in.getInputStream(in.getEntry(name))) {\n+            is.transferTo(out);\n+        }\n+    }\n+\n+    private static Path signJarFile(Path j) throws Exception {\n+        Path s = Path.of(\"pending-block-file-signed.jar\");\n+\n+        Files.deleteIfExists(Path.of(\"ks\"));\n+\n+        sun.security.tools.keytool.Main.main(\n+                (\"-keystore ks -storepass changeit -keypass changeit -dname\" +\n+                        \" CN=SIGNER\" +\" -alias r -genkeypair -keyalg rsa\").split(\" \"));\n+\n+        char[] pass = \"changeit\".toCharArray();\n+\n+        KeyStore ks = KeyStore.getInstance(new File(\"ks\"), pass);\n+\n+        KeyStore.PrivateKeyEntry pke = (KeyStore.PrivateKeyEntry)\n+                ks.getEntry(\"r\", new KeyStore.PasswordProtection(pass));\n+\n+        JarSigner signer = new JarSigner.Builder(pke)\n+                .digestAlgorithm(\"SHA-256\")\n+                .signatureAlgorithm(\"SHA256withRSA\")\n+                .signerName(\"SIGNER\")\n+                .build();\n+\n+        try (ZipFile in = new ZipFile(j.toFile());\n+            OutputStream out = Files.newOutputStream(s)) {\n+            signer.sign(in, out);\n+        }\n+\n+        return s;\n+    }\n+\n+    \/**\n+     * Create a jar file with single entry \"a.txt\" containing \"a\"\n+     *\/\n+    private static Path createJarFile() throws Exception {\n+        Path jar = Path.of(\"pending-block-file.jar\");\n+        Manifest manifest = new Manifest();\n+        manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, \"1.0\");\n+        try (JarOutputStream out = new JarOutputStream(Files.newOutputStream(jar),manifest)) {\n+            out.putNextEntry(new JarEntry(\"a.txt\"));\n+            out.write(\"a\".getBytes(StandardCharsets.UTF_8));\n+        }\n+        return jar;\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/jar\/JarFile\/SignedJarPendingBlock.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,3 @@\n+ * @library \/test\/lib\n+ * @modules java.base\/sun.security.x509\n+ * @modules java.base\/sun.security.tools.keytool\n@@ -29,2 +32,13 @@\n-import java.io.File;\n-import java.util.jar.JarFile;\n+import jdk.security.jarsigner.JarSigner;\n+import sun.security.tools.keytool.CertAndKeyGen;\n+import sun.security.x509.X500Name;\n+\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.util.Collections;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n@@ -32,0 +46,2 @@\n+import java.util.jar.JarFile;\n+import java.util.jar.JarOutputStream;\n@@ -33,1 +49,4 @@\n-import java.util.Enumeration;\n+import java.util.zip.ZipFile;\n+\n+import static jdk.test.lib.Utils.runAndCheckException;\n+\n@@ -36,6 +55,0 @@\n-    private static void Unreached (Object o)\n-        throws Exception\n-    {\n-        \/\/ Should never get here\n-        throw new Exception (\"Expected exception was not thrown\");\n-    }\n@@ -44,6 +57,0 @@\n-        File f = new File(System.getProperty(\"test.src\", \".\"), \"thawjar.jar\");\n-        JarFile jf = new JarFile(f);\n-        try {\n-            \/\/ Read entries via Enumeration\n-            for (Enumeration e = jf.entries(); e.hasMoreElements();)\n-                jf.getInputStream((ZipEntry) e.nextElement());\n@@ -51,3 +58,4 @@\n-            \/\/ Read entry by name\n-            ZipEntry ze = jf.getEntry(\"getprop.class\");\n-            JarEntry je = jf.getJarEntry(\"getprop.class\");\n+        Path j = createJar();\n+        Path s = signJar(j, keyEntry(\"cn=duke\"));\n+\n+        try (JarFile jf = new JarFile(s.toFile())) {\n@@ -55,3 +63,8 @@\n-            \/\/ Make sure we throw NPE on null objects\n-            try { Unreached (jf.getEntry(null)); }\n-            catch (NullPointerException e) {}\n+            for (JarEntry e: Collections.list(jf.entries())) {\n+                \/\/ Reading entry to trigger verification\n+                jf.getInputStream(e).transferTo(OutputStream.nullOutputStream());\n+                \/\/ Check that all regular files are signed by duke\n+                if (!e.getName().startsWith(\"META-INF\/\")) {\n+                    checkSignedBy(e, \"cn=duke\");\n+                }\n+            }\n@@ -59,2 +72,3 @@\n-            try { Unreached (jf.getJarEntry(null)); }\n-            catch (NullPointerException e) {}\n+            \/\/ Read ZIP and JAR entries by name\n+            Objects.requireNonNull(jf.getEntry(\"getprop.class\"));\n+            Objects.requireNonNull(jf.getJarEntry(\"getprop.class\"));\n@@ -62,2 +76,4 @@\n-            try { Unreached (jf.getInputStream(null)); }\n-            catch (NullPointerException e) {}\n+            \/\/ Make sure we throw NPE on null parameters\n+            runAndCheckException(() -> jf.getEntry(null), NullPointerException.class);\n+            runAndCheckException(() -> jf.getJarEntry(null), NullPointerException.class);\n+            runAndCheckException(() -> jf.getInputStream(null), NullPointerException.class);\n@@ -70,0 +86,56 @@\n+\n+    \/\/ Check that a JAR entry is signed by an expected DN\n+    private static void checkSignedBy(JarEntry e, String expectedDn) throws Exception {\n+        Certificate[] certs = e.getCertificates();\n+        if (certs == null || certs.length == 0) {\n+            throw new Exception(\"JarEntry has no certificates: \" + e.getName());\n+        }\n+\n+        if (certs[0] instanceof X509Certificate x) {\n+            String name = x.getSubjectX500Principal().getName();\n+            if (!name.equalsIgnoreCase(expectedDn)) {\n+                throw new Exception(\"Expected entry signed by %s, was %s\".formatted(name, expectedDn));\n+            }\n+        } else {\n+            throw new Exception(\"Expected JarEntry.getCertificate to return X509Certificate\");\n+        }\n+    }\n+\n+    private static Path createJar() throws Exception {\n+        Path j = Path.of(\"unsigned.jar\");\n+        try (JarOutputStream out = new JarOutputStream(Files.newOutputStream(j))){\n+            out.putNextEntry(new JarEntry(\"getprop.class\"));\n+            out.write(new byte[] {(byte) 0XCA, (byte) 0XFE, (byte) 0XBA, (byte) 0XBE});\n+        }\n+        return j;\n+    }\n+\n+    private static Path signJar(Path j, KeyStore.PrivateKeyEntry entry) throws Exception {\n+        Path s = Path.of(\"signed.jar\");\n+\n+        JarSigner signer = new JarSigner.Builder(entry)\n+                .signerName(\"zigbert\")\n+                .digestAlgorithm(\"SHA-256\")\n+                .signatureAlgorithm(\"SHA256withRSA\")\n+                .build();\n+\n+        try (ZipFile zip = new ZipFile(j.toFile());\n+            OutputStream out = Files.newOutputStream(s)) {\n+            signer.sign(zip, out);\n+        }\n+\n+        return s;\n+    }\n+\n+    private static KeyStore.PrivateKeyEntry keyEntry(String dname) throws Exception {\n+\n+        CertAndKeyGen gen = new CertAndKeyGen(\"RSA\", \"SHA256withRSA\");\n+\n+        gen.generate(1048); \/\/ Small key size makes test run faster\n+\n+        var oneDay = TimeUnit.DAYS.toSeconds(1);\n+        Certificate cert = gen.getSelfCertificate(new X500Name(dname), oneDay);\n+\n+        return new KeyStore.PrivateKeyEntry(gen.getPrivateKey(),\n+                new Certificate[] {cert});\n+    }\n","filename":"test\/jdk\/java\/util\/jar\/JarFile\/VerifySignedJar.java","additions":98,"deletions":26,"binary":false,"changes":124,"status":"modified"},{"filename":"test\/jdk\/java\/util\/jar\/JarFile\/thawjar.jar","binary":true,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,1 +126,3 @@\n-                cc.close();\n+                if (cc != null) {\n+                    cc.close();\n+                }\n@@ -128,2 +130,3 @@\n-                cs.stop();\n-\n+                if (cs != null) {\n+                    cs.stop();\n+                }\n","filename":"test\/jdk\/javax\/management\/MBeanServer\/ExceptionTest.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,1 +90,4 @@\n-        Thread.sleep(100); \/\/ let pass the first client open notif if there is\n+        \/\/ Sleeping here was an attempt to avoid seeing an initial notification.\n+        \/\/ This does not work, but does not matter.\n+        \/\/ Thread.sleep(100);\n+\n@@ -103,0 +106,1 @@\n+                System.out.println(\"Calling sendNotifications\");\n@@ -108,1 +112,1 @@\n-                    lock.wait(10);\n+                    lock.wait(1000); \/\/ sleep as no point in constant notifications\n@@ -146,1 +150,1 @@\n-                \/\/ treat the client notif to know the end\n+                System.out.println(\"handleNotification: \" + n);\n@@ -149,1 +153,1 @@\n-\n+                        \/\/ Expected: [type=jmx.remote.connection.opened][message=Reconnected to server]\n@@ -162,1 +166,1 @@\n-                System.out.println(\">>> Do sleep to make reconnection.\");\n+                System.out.println(\">>> sleeping in NotificationListener to force reconnection.\");\n@@ -173,1 +177,3 @@\n-    private static final long serverTimeout = 1000;\n+    \/\/ serverTimeout increased to avoid occasional problems with initial connect.\n+    \/\/ Not using Utils.adjustTimeout to avoid accidentally making it too long.\n+    private static final long serverTimeout = 2000;\n@@ -176,1 +182,1 @@\n-    private static String clientState = null;\n+    private volatile static String clientState = null;\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/notif\/NotifReconnectDeadlockTest.java","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -203,0 +203,6 @@\n+    private void stopServerSide() throws IOException {\n+        if (cs != null) {\n+            cs.stop();\n+        }\n+    }\n+\n@@ -220,1 +226,1 @@\n-                cs.stop();\n+                stopServerSide();\n@@ -244,1 +250,1 @@\n-                cs.stop();\n+                stopServerSide();\n@@ -266,1 +272,1 @@\n-                cs.stop();\n+                stopServerSide();\n@@ -403,1 +409,1 @@\n-            cs.stop();\n+            stopServerSide();\n","filename":"test\/jdk\/javax\/management\/security\/HashedPasswordFileTest.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1,714 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 4948079\n- * @summary SSLEngineResult needs updating [none yet]\n- *\n- * @run main\/othervm -Djsse.enableCBCProtection=false CheckStatus\n- *\n- * @author Brad Wetmore\n- *\/\n-\n-\/*\n- * This is a simple hack to test a bunch of conditions and check\n- * their return codes.\n- *\/\n-import javax.net.ssl.*;\n-import javax.net.ssl.SSLEngineResult.*;\n-import java.io.*;\n-import java.security.*;\n-import java.nio.*;\n-\n-public class CheckStatus {\n-\n-    private static boolean debug = true;\n-\n-    private SSLContext sslc;\n-    private SSLEngine ssle1;    \/\/ client\n-    private SSLEngine ssle2;    \/\/ server\n-\n-    private static String pathToStores = \"..\/etc\";\n-    private static String keyStoreFile = \"keystore\";\n-    private static String trustStoreFile = \"truststore\";\n-    private static String passwd = \"passphrase\";\n-\n-    private static String keyFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + keyStoreFile;\n-    private static String trustFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + trustStoreFile;\n-\n-    private ByteBuffer appOut1;         \/\/ write side of ssle1\n-    private ByteBuffer appIn1;          \/\/ read side of ssle1\n-    private ByteBuffer appOut2;         \/\/ write side of ssle2\n-    private ByteBuffer appIn2;          \/\/ read side of ssle2\n-\n-    private ByteBuffer oneToTwo;        \/\/ \"reliable\" transport ssle1->ssle2\n-    private ByteBuffer twoToOne;        \/\/ \"reliable\" transport ssle2->ssle1\n-\n-    \/*\n-     * Majority of the test case is here, setup is done below.\n-     *\/\n-\n-    private void createSSLEngines() throws Exception {\n-        ssle1 = sslc.createSSLEngine(\"client\", 1);\n-        ssle1.setUseClientMode(true);\n-\n-        ssle2 = sslc.createSSLEngine(\"server\", 2);\n-        ssle2.setUseClientMode(false);\n-    }\n-\n-    private boolean isHandshaking(SSLEngine e) {\n-        return (e.getHandshakeStatus() != HandshakeStatus.NOT_HANDSHAKING);\n-    }\n-\n-    private void checkResult(ByteBuffer bbIn, ByteBuffer bbOut,\n-            SSLEngineResult result,\n-            Status status, HandshakeStatus hsStatus,\n-            int consumed, int produced)\n-            throws Exception {\n-\n-        if ((status != null) && (result.getStatus() != status)) {\n-            throw new Exception(\"Unexpected Status: need = \" + status +\n-                \" got = \" + result.getStatus());\n-        }\n-\n-        if ((hsStatus != null) && (result.getHandshakeStatus() != hsStatus)) {\n-            throw new Exception(\"Unexpected hsStatus: need = \" + hsStatus +\n-                \" got = \" + result.getHandshakeStatus());\n-        }\n-\n-        if ((consumed != -1) && (consumed != result.bytesConsumed())) {\n-            throw new Exception(\"Unexpected consumed: need = \" + consumed +\n-                \" got = \" + result.bytesConsumed());\n-        }\n-\n-        if ((produced != -1) && (produced != result.bytesProduced())) {\n-            throw new Exception(\"Unexpected produced: need = \" + produced +\n-                \" got = \" + result.bytesProduced());\n-        }\n-\n-        if ((consumed != -1) && (bbIn.position() != result.bytesConsumed())) {\n-            throw new Exception(\"Consumed \" + bbIn.position() +\n-                \" != \" + consumed);\n-        }\n-\n-        if ((produced != -1) && (bbOut.position() != result.bytesProduced())) {\n-            throw new Exception(\"produced \" + bbOut.position() +\n-                \" != \" + produced);\n-        }\n-    }\n-\n-    private void test() throws Exception {\n-        createSSLEngines();\n-        createBuffers();\n-\n-        SSLEngineResult result1;        \/\/ ssle1's results from last operation\n-        SSLEngineResult result2;        \/\/ ssle2's results from last operation\n-\n-        String [] suite1 = new String [] {\n-            \"SSL_RSA_WITH_RC4_128_MD5\" };\n-        String [] suite2 = new String [] {\n-            \"SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA\" };\n-\n-        ssle1.setEnabledCipherSuites(suite1);\n-        ssle2.setEnabledCipherSuites(suite1);\n-\n-        log(\"================\");\n-\n-        log(\"unexpected empty unwrap\");\n-        twoToOne.limit(0);\n-        result1 = ssle1.unwrap(twoToOne, appIn1);\n-        checkResult(twoToOne, appIn1, result1,\n-            Status.OK, HandshakeStatus.NEED_WRAP, 0, 0);\n-        twoToOne.limit(twoToOne.capacity());\n-\n-        log(\"======================================\");\n-        log(\"client hello\");\n-        result1 = ssle1.wrap(appOut1, oneToTwo);\n-        checkResult(appOut1, oneToTwo, result1,\n-             Status.OK, HandshakeStatus.NEED_UNWRAP, 0, -1);\n-\n-        oneToTwo.flip();\n-        result2 = ssle2.unwrap(oneToTwo, appIn2);\n-\n-        checkResult(oneToTwo, appIn2, result2,\n-             Status.OK, HandshakeStatus.NEED_TASK, result1.bytesProduced(), 0);\n-        runDelegatedTasks(ssle2);\n-\n-        oneToTwo.compact();\n-\n-        log(\"Check for unwrap when wrap needed\");\n-        result2 = ssle2.unwrap(oneToTwo, appIn2);\n-        checkResult(oneToTwo, appIn2, result2,\n-            Status.OK, HandshakeStatus.NEED_WRAP, 0, 0);\n-\n-        log(\"======================================\");\n-        log(\"ServerHello\");\n-\n-        result2 = ssle2.wrap(appOut2, twoToOne);\n-        checkResult(appOut2, twoToOne, result2,\n-            Status.OK, HandshakeStatus.NEED_UNWRAP, 0, -1);\n-        twoToOne.flip();\n-\n-        result1 = ssle1.unwrap(twoToOne, appIn1);\n-        checkResult(twoToOne, appIn1, result1,\n-            Status.OK, HandshakeStatus.NEED_TASK, result2.bytesProduced(), 0);\n-        twoToOne.compact();\n-\n-        runDelegatedTasks(ssle1);\n-\n-        log(\"======================================\");\n-        log(\"Key Exchange\");\n-        result1 = ssle1.wrap(appOut1, oneToTwo);\n-        checkResult(appOut1, oneToTwo, result1,\n-             Status.OK, HandshakeStatus.NEED_WRAP, 0, -1);\n-\n-        oneToTwo.flip();\n-        result2 = ssle2.unwrap(oneToTwo, appIn2);\n-\n-        checkResult(oneToTwo, appIn2, result2,\n-             Status.OK, HandshakeStatus.NEED_TASK, result1.bytesProduced(), 0);\n-        runDelegatedTasks(ssle2);\n-\n-        oneToTwo.compact();\n-\n-        log(\"======================================\");\n-        log(\"CCS\");\n-        result1 = ssle1.wrap(appOut1, oneToTwo);\n-        checkResult(appOut1, oneToTwo, result1,\n-             Status.OK, HandshakeStatus.NEED_WRAP, 0, -1);\n-\n-        oneToTwo.flip();\n-        result2 = ssle2.unwrap(oneToTwo, appIn2);\n-\n-        checkResult(oneToTwo, appIn2, result2,\n-             Status.OK, HandshakeStatus.NEED_UNWRAP,\n-             result1.bytesProduced(), 0);\n-\n-        oneToTwo.compact();\n-\n-        log(\"======================================\");\n-        log(\"Finished\");\n-        result1 = ssle1.wrap(appOut1, oneToTwo);\n-        checkResult(appOut1, oneToTwo, result1,\n-             Status.OK, HandshakeStatus.NEED_UNWRAP, 0, -1);\n-\n-        oneToTwo.flip();\n-        result2 = ssle2.unwrap(oneToTwo, appIn2);\n-\n-        checkResult(oneToTwo, appIn2, result2,\n-             Status.OK, HandshakeStatus.NEED_WRAP, result1.bytesProduced(), 0);\n-\n-        oneToTwo.compact();\n-\n-        log(\"======================================\");\n-        log(\"CCS\");\n-\n-        result2 = ssle2.wrap(appOut2, twoToOne);\n-        checkResult(appOut2, twoToOne, result2,\n-            Status.OK, HandshakeStatus.NEED_WRAP, 0, -1);\n-        twoToOne.flip();\n-\n-        result1 = ssle1.unwrap(twoToOne, appIn1);\n-        checkResult(twoToOne, appIn1, result1,\n-            Status.OK, HandshakeStatus.NEED_UNWRAP, result2.bytesProduced(), 0);\n-        twoToOne.compact();\n-\n-        log(\"======================================\");\n-        log(\"FINISHED\");\n-\n-        result2 = ssle2.wrap(appOut2, twoToOne);\n-        checkResult(appOut2, twoToOne, result2,\n-            Status.OK, HandshakeStatus.FINISHED, 0, -1);\n-        twoToOne.flip();\n-\n-        result1 = ssle1.unwrap(twoToOne, appIn1);\n-        checkResult(twoToOne, appIn1, result1,\n-            Status.OK, HandshakeStatus.FINISHED, result2.bytesProduced(), 0);\n-        twoToOne.compact();\n-\n-        log(\"======================================\");\n-        log(\"Check Session\/Ciphers\");\n-\n-        String suite = ssle1.getSession().getCipherSuite();\n-        if (!suite.equals(suite1[0])) {\n-            throw new Exception(\"suites not equal: \" + suite + \"\/\" +\n-                suite1[0]);\n-        }\n-\n-        suite = ssle2.getSession().getCipherSuite();\n-        if (!suite.equals(suite1[0])) {\n-            throw new Exception(\"suites not equal: \" + suite + \"\/\" +\n-                suite1[0]);\n-        }\n-\n-        log(\"======================================\");\n-        log(\"DATA\");\n-\n-        result1 = ssle1.wrap(appOut1, oneToTwo);\n-        checkResult(appOut1, oneToTwo, result1,\n-            Status.OK, HandshakeStatus.NOT_HANDSHAKING,\n-            appOut1.capacity(), -1);\n-        oneToTwo.flip();\n-\n-        result2 = ssle2.wrap(appOut2, twoToOne);\n-        checkResult(appOut2, twoToOne, result2,\n-            Status.OK, HandshakeStatus.NOT_HANDSHAKING,\n-            appOut2.capacity(), -1);\n-        twoToOne.flip();\n-\n-        SSLEngineResult result3 = ssle1.unwrap(twoToOne, appIn1);\n-        checkResult(twoToOne, appIn1, result3,\n-            Status.OK, HandshakeStatus.NOT_HANDSHAKING,\n-            result2.bytesProduced(), result2.bytesConsumed());\n-        twoToOne.compact();\n-\n-        SSLEngineResult result4 = ssle2.unwrap(oneToTwo, appIn2);\n-        checkResult(oneToTwo, appIn2, result4,\n-            Status.OK, HandshakeStatus.NOT_HANDSHAKING,\n-            result1.bytesProduced(), result1.bytesConsumed());\n-        oneToTwo.compact();\n-\n-        appIn1.clear();\n-        appIn2.clear();\n-        appOut1.rewind();\n-        appOut2.rewind();\n-\n-        log(\"======================================\");\n-        log(\"RENEGOTIATE\");\n-\n-        ssle2.getSession().invalidate();\n-        ssle2.setNeedClientAuth(true);\n-\n-        ssle1.setEnabledCipherSuites(suite2);\n-        ssle2.setEnabledCipherSuites(suite2);\n-\n-        ssle2.beginHandshake();\n-\n-        log(\"======================================\");\n-        log(\"HelloRequest\");\n-\n-        result2 = ssle2.wrap(appOut2, twoToOne);\n-        checkResult(appOut2, twoToOne, result2,\n-            Status.OK, HandshakeStatus.NEED_UNWRAP, 0, -1);\n-        twoToOne.flip();\n-\n-        result1 = ssle1.unwrap(twoToOne, appIn1);\n-        checkResult(twoToOne, appIn1, result1,\n-            Status.OK, HandshakeStatus.NEED_TASK, result2.bytesProduced(), 0);\n-        twoToOne.compact();\n-\n-        runDelegatedTasks(ssle1);\n-\n-        log(\"======================================\");\n-        log(\"ClientHello\");\n-\n-        result1 = ssle1.wrap(appOut1, oneToTwo);\n-        checkResult(appOut1, oneToTwo, result1,\n-             Status.OK, HandshakeStatus.NEED_UNWRAP, 0, -1);\n-\n-        oneToTwo.flip();\n-        result2 = ssle2.unwrap(oneToTwo, appIn2);\n-\n-        checkResult(oneToTwo, appIn2, result2,\n-             Status.OK, HandshakeStatus.NEED_TASK, result1.bytesProduced(), 0);\n-        runDelegatedTasks(ssle2);\n-\n-        oneToTwo.compact();\n-\n-        log(\"======================================\");\n-        log(\"CLIENT->SERVER DATA IN MIDDLE OF HANDSHAKE\");\n-\n-        result1 = ssle1.wrap(appOut1, oneToTwo);\n-        checkResult(appOut1, oneToTwo, result1,\n-            Status.OK, HandshakeStatus.NEED_UNWRAP,\n-            appOut1.capacity(), -1);\n-        oneToTwo.flip();\n-\n-        result4 = ssle2.unwrap(oneToTwo, appIn2);\n-        checkResult(oneToTwo, appIn2, result4,\n-            Status.OK, HandshakeStatus.NEED_WRAP,\n-            result1.bytesProduced(), result1.bytesConsumed());\n-        oneToTwo.compact();\n-\n-        appIn2.clear();\n-        appOut1.rewind();\n-\n-        log(\"======================================\");\n-        log(\"ServerHello\");\n-\n-        result2 = ssle2.wrap(appOut2, twoToOne);\n-        checkResult(appOut2, twoToOne, result2,\n-            Status.OK, HandshakeStatus.NEED_UNWRAP, 0, -1);\n-        twoToOne.flip();\n-\n-        result1 = ssle1.unwrap(twoToOne, appIn1);\n-        checkResult(twoToOne, appIn1, result1,\n-            Status.OK, HandshakeStatus.NEED_TASK, result2.bytesProduced(), 0);\n-        twoToOne.compact();\n-\n-        runDelegatedTasks(ssle1);\n-\n-        log(\"======================================\");\n-        log(\"SERVER->CLIENT DATA IN MIDDLE OF HANDSHAKE\");\n-\n-        result2 = ssle2.wrap(appOut2, twoToOne);\n-        checkResult(appOut2, twoToOne, result2,\n-            Status.OK, HandshakeStatus.NEED_UNWRAP,\n-            appOut2.capacity(), -1);\n-        twoToOne.flip();\n-\n-        result3 = ssle1.unwrap(twoToOne, appIn1);\n-        checkResult(twoToOne, appIn1, result3,\n-            Status.OK, HandshakeStatus.NEED_WRAP,\n-            result2.bytesProduced(), result2.bytesConsumed());\n-        twoToOne.compact();\n-\n-        appIn1.clear();\n-        appOut2.rewind();\n-\n-        log(\"======================================\");\n-        log(\"Client Cert and Key Exchange\");\n-        result1 = ssle1.wrap(appOut1, oneToTwo);\n-        checkResult(appOut1, oneToTwo, result1,\n-             Status.OK, HandshakeStatus.NEED_WRAP, 0, -1);\n-\n-        oneToTwo.flip();\n-        result2 = ssle2.unwrap(oneToTwo, appIn2);\n-\n-        checkResult(oneToTwo, appIn2, result2,\n-             Status.OK, HandshakeStatus.NEED_TASK, result1.bytesProduced(), 0);\n-        runDelegatedTasks(ssle2);\n-\n-        oneToTwo.compact();\n-\n-        log(\"======================================\");\n-        log(\"CCS\");\n-        result1 = ssle1.wrap(appOut1, oneToTwo);\n-        checkResult(appOut1, oneToTwo, result1,\n-             Status.OK, HandshakeStatus.NEED_WRAP, 0, -1);\n-\n-        oneToTwo.flip();\n-        result2 = ssle2.unwrap(oneToTwo, appIn2);\n-\n-        checkResult(oneToTwo, appIn2, result2,\n-             Status.OK, HandshakeStatus.NEED_UNWRAP,\n-             result1.bytesProduced(), 0);\n-\n-        oneToTwo.compact();\n-\n-        log(\"======================================\");\n-        log(\"Finished\");\n-        result1 = ssle1.wrap(appOut1, oneToTwo);\n-        checkResult(appOut1, oneToTwo, result1,\n-             Status.OK, HandshakeStatus.NEED_UNWRAP, 0, -1);\n-\n-        oneToTwo.flip();\n-        result2 = ssle2.unwrap(oneToTwo, appIn2);\n-\n-        checkResult(oneToTwo, appIn2, result2,\n-             Status.OK, HandshakeStatus.NEED_WRAP, result1.bytesProduced(), 0);\n-\n-        oneToTwo.compact();\n-\n-        log(\"======================================\");\n-        log(\"CCS\");\n-\n-        result2 = ssle2.wrap(appOut2, twoToOne);\n-        checkResult(appOut2, twoToOne, result2,\n-            Status.OK, HandshakeStatus.NEED_WRAP, 0, -1);\n-        twoToOne.flip();\n-\n-        result1 = ssle1.unwrap(twoToOne, appIn1);\n-        checkResult(twoToOne, appIn1, result1,\n-            Status.OK, HandshakeStatus.NEED_UNWRAP, result2.bytesProduced(), 0);\n-        twoToOne.compact();\n-\n-        log(\"======================================\");\n-        log(\"FINISHED\");\n-\n-        result2 = ssle2.wrap(appOut2, twoToOne);\n-        checkResult(appOut2, twoToOne, result2,\n-            Status.OK, HandshakeStatus.FINISHED, 0, -1);\n-        twoToOne.flip();\n-\n-        result1 = ssle1.unwrap(twoToOne, appIn1);\n-        checkResult(twoToOne, appIn1, result1,\n-            Status.OK, HandshakeStatus.FINISHED, result2.bytesProduced(), 0);\n-        twoToOne.compact();\n-\n-        log(\"======================================\");\n-        log(\"Check Session\/Ciphers\");\n-\n-        suite = ssle1.getSession().getCipherSuite();\n-        if (!suite.equals(suite2[0])) {\n-            throw new Exception(\"suites not equal: \" + suite + \"\/\" +\n-                suite2[0]);\n-        }\n-\n-        suite = ssle2.getSession().getCipherSuite();\n-        if (!suite.equals(suite2[0])) {\n-            throw new Exception(\"suites not equal: \" + suite + \"\/\" +\n-                suite2[0]);\n-        }\n-\n-        log(\"======================================\");\n-        log(\"DATA USING NEW SESSION\");\n-\n-        result1 = ssle1.wrap(appOut1, oneToTwo);\n-        checkResult(appOut1, oneToTwo, result1,\n-            Status.OK, HandshakeStatus.NOT_HANDSHAKING,\n-            appOut1.capacity(), -1);\n-        oneToTwo.flip();\n-\n-        result2 = ssle2.wrap(appOut2, twoToOne);\n-        checkResult(appOut2, twoToOne, result2,\n-            Status.OK, HandshakeStatus.NOT_HANDSHAKING,\n-            appOut2.capacity(), -1);\n-        twoToOne.flip();\n-\n-        result3 = ssle1.unwrap(twoToOne, appIn1);\n-        checkResult(twoToOne, appIn1, result3,\n-            Status.OK, HandshakeStatus.NOT_HANDSHAKING,\n-            result2.bytesProduced(), result2.bytesConsumed());\n-        twoToOne.compact();\n-\n-        result4 = ssle2.unwrap(oneToTwo, appIn2);\n-        checkResult(oneToTwo, appIn2, result4,\n-            Status.OK, HandshakeStatus.NOT_HANDSHAKING,\n-            result1.bytesProduced(), result1.bytesConsumed());\n-        oneToTwo.compact();\n-\n-        appIn1.clear();\n-        appIn2.clear();\n-        appOut1.rewind();\n-        appOut2.rewind();\n-\n-        log(\"======================================\");\n-        log(\"CN\");\n-\n-        if (isHandshaking(ssle1)) {\n-            throw new Exception(\"ssle1 IS handshaking\");\n-        }\n-\n-        if (isHandshaking(ssle2)) {\n-            throw new Exception(\"ssle2 IS handshaking\");\n-        }\n-\n-        ssle2.closeOutbound();\n-\n-        if (!isHandshaking(ssle2)) {\n-            throw new Exception(\"ssle1 IS NOT handshaking\");\n-        }\n-\n-        appOut1.rewind();\n-        appOut2.rewind();\n-\n-        result2 = ssle2.wrap(appOut2, twoToOne);\n-        checkResult(appOut2, twoToOne, result2,\n-            Status.CLOSED, HandshakeStatus.NEED_UNWRAP, 0, -1);\n-        twoToOne.flip();\n-\n-        if (ssle1.isInboundDone()) {\n-            throw new Exception(\"ssle1 inboundDone\");\n-        }\n-\n-        result1 = ssle1.unwrap(twoToOne, appIn1);\n-        checkResult(twoToOne, appIn1, result1,\n-            Status.CLOSED, HandshakeStatus.NEED_WRAP,\n-            result2.bytesProduced(), 0);\n-        twoToOne.compact();\n-\n-        if (!ssle1.isInboundDone()) {\n-            throw new Exception(\"ssle1 inboundDone\");\n-        }\n-\n-        if (!isHandshaking(ssle1)) {\n-            throw new Exception(\"ssle1 IS NOT handshaking\");\n-        }\n-\n-        result2 = ssle2.wrap(appOut2, twoToOne);\n-        checkResult(appOut2, twoToOne, result2,\n-            Status.CLOSED, HandshakeStatus.NEED_UNWRAP, 0, 0);\n-        twoToOne.flip();\n-\n-        log(\"======================================\");\n-        log(\"CN response\");\n-\n-        if (ssle1.isOutboundDone()) {\n-            throw new Exception(\"ssle1 outboundDone\");\n-        }\n-\n-        result1 = ssle1.wrap(appOut1, oneToTwo);\n-        checkResult(appOut1, oneToTwo, result1,\n-             Status.CLOSED, HandshakeStatus.NOT_HANDSHAKING, 0, -1);\n-\n-        if (!ssle1.isOutboundDone()) {\n-            throw new Exception(\"ssle1 outboundDone is NOT done\");\n-        }\n-\n-        if (isHandshaking(ssle1)) {\n-            throw new Exception(\"ssle1 IS handshaking\");\n-        }\n-\n-        oneToTwo.flip();\n-\n-        if (!ssle2.isOutboundDone()) {\n-            throw new Exception(\"ssle1 outboundDone\");\n-        }\n-\n-        if (ssle2.isInboundDone()) {\n-            throw new Exception(\"ssle1 inboundDone\");\n-        }\n-\n-        result2 = ssle2.unwrap(oneToTwo, appIn2);\n-\n-        checkResult(oneToTwo, appIn2, result2,\n-             Status.CLOSED, HandshakeStatus.NOT_HANDSHAKING,\n-             result1.bytesProduced(), 0);\n-\n-        if (!ssle2.isOutboundDone()) {\n-            throw new Exception(\"ssle1 outboundDone is NOT done\");\n-        }\n-\n-        if (!ssle2.isInboundDone()) {\n-            throw new Exception(\"ssle1 inboundDone is NOT done\");\n-        }\n-\n-        if (isHandshaking(ssle2)) {\n-            throw new Exception(\"ssle1 IS handshaking\");\n-        }\n-\n-        oneToTwo.compact();\n-    }\n-\n-    public static void main(String args[]) throws Exception {\n-        \/\/ reset the security property to make sure that the algorithms\n-        \/\/ and keys used in this test are not disabled.\n-        Security.setProperty(\"jdk.tls.disabledAlgorithms\", \"\");\n-\n-        CheckStatus cs;\n-\n-        cs = new CheckStatus();\n-\n-        cs.createSSLEngines();\n-\n-        cs.test();\n-\n-        System.out.println(\"Test Passed.\");\n-    }\n-\n-    \/*\n-     * **********************************************************\n-     * Majority of the test case is above, below is just setup stuff\n-     * **********************************************************\n-     *\/\n-\n-    public CheckStatus() throws Exception {\n-        sslc = getSSLContext(keyFilename, trustFilename);\n-    }\n-\n-    \/*\n-     * Create an initialized SSLContext to use for this test.\n-     *\/\n-    private SSLContext getSSLContext(String keyFile, String trustFile)\n-            throws Exception {\n-\n-        KeyStore ks = KeyStore.getInstance(\"JKS\");\n-        KeyStore ts = KeyStore.getInstance(\"JKS\");\n-\n-        char[] passphrase = \"passphrase\".toCharArray();\n-\n-        ks.load(new FileInputStream(keyFile), passphrase);\n-        ts.load(new FileInputStream(trustFile), passphrase);\n-\n-        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n-        kmf.init(ks, passphrase);\n-\n-        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n-        tmf.init(ts);\n-\n-        SSLContext sslCtx = SSLContext.getInstance(\"TLS\");\n-\n-        sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n-\n-        return sslCtx;\n-    }\n-\n-    private void createBuffers() {\n-        \/\/ Size the buffers as appropriate.\n-\n-        SSLSession session = ssle1.getSession();\n-        int appBufferMax = session.getApplicationBufferSize();\n-        int netBufferMax = session.getPacketBufferSize();\n-\n-        appIn1 = ByteBuffer.allocateDirect(appBufferMax + 50);\n-        appIn2 = ByteBuffer.allocateDirect(appBufferMax + 50);\n-\n-        oneToTwo = ByteBuffer.allocateDirect(netBufferMax);\n-        twoToOne = ByteBuffer.allocateDirect(netBufferMax);\n-\n-        appOut1 = ByteBuffer.wrap(\"Hi Engine2, I'm SSLEngine1\".getBytes());\n-        appOut2 = ByteBuffer.wrap(\"Hello Engine1, I'm SSLEngine2\".getBytes());\n-\n-        log(\"AppOut1 = \" + appOut1);\n-        log(\"AppOut2 = \" + appOut2);\n-        log(\"\");\n-    }\n-\n-    private static void runDelegatedTasks(SSLEngine engine) throws Exception {\n-\n-        Runnable runnable;\n-        while ((runnable = engine.getDelegatedTask()) != null) {\n-            log(\"running delegated task...\");\n-            runnable.run();\n-        }\n-    }\n-\n-    private static void checkTransfer(ByteBuffer a, ByteBuffer b)\n-            throws Exception {\n-        a.flip();\n-        b.flip();\n-\n-        if (!a.equals(b)) {\n-            throw new Exception(\"Data didn't transfer cleanly\");\n-        } else {\n-            log(\"Data transferred cleanly\");\n-        }\n-\n-        a.position(a.limit());\n-        b.position(b.limit());\n-        a.limit(a.capacity());\n-        b.limit(b.capacity());\n-    }\n-\n-    private static void log(String str) {\n-        if (debug) {\n-            System.out.println(str);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLEngine\/CheckStatus.java","additions":0,"deletions":714,"binary":false,"changes":714,"status":"deleted"},{"patch":"@@ -0,0 +1,709 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4948079\n+ * @summary Verify return values from SSLEngine wrap\/unwrap (TLSv1.2) operations\n+ *\n+ * @run main CheckTlsEngineResults\n+ *\n+ * @author Brad Wetmore\n+ *\/\n+\n+\/*\n+ * This is a simple hack to test a bunch of conditions and check\n+ * their return codes.\n+ *\/\n+import javax.net.ssl.*;\n+import javax.net.ssl.SSLEngineResult.*;\n+import java.io.*;\n+import java.security.*;\n+import java.nio.*;\n+\n+public class CheckTlsEngineResults {\n+\n+    private final SSLContext SSL_CONTEXT;\n+    private SSLEngine clientEngine;    \/\/ client\n+    private SSLEngine serverEngine;    \/\/ server\n+\n+    private static final String PATH_TO_STORES = \"..\/etc\";\n+\n+    private static final String KEYSTORE_FILE = \"keystore\";\n+    private static final String TRUSTSTORE_FILE = \"truststore\";\n+\n+    private static final String keyFilename =\n+            System.getProperty(\"test.src\", \".\/\") + \"\/\" + PATH_TO_STORES +\n+                \"\/\" + KEYSTORE_FILE;\n+    private static final String trustFilename =\n+            System.getProperty(\"test.src\", \".\/\") + \"\/\" + PATH_TO_STORES +\n+                \"\/\" + TRUSTSTORE_FILE;\n+\n+    private ByteBuffer clientOut;         \/\/ write side of clientEngine\n+    private ByteBuffer clientIn;          \/\/ read side of clientEngine\n+    private ByteBuffer serverOut;         \/\/ write side of serverEngine\n+    private ByteBuffer serverIn;          \/\/ read side of serverEngine\n+\n+    private ByteBuffer clientToServer;        \/\/ \"reliable\" transport clientEngine->serverEngine\n+    private ByteBuffer serverToClient;        \/\/ \"reliable\" transport serverEngine->clientEngine\n+\n+    \/*\n+     * Majority of the test case is here, setup is done below.\n+     *\/\n+\n+    private void createSSLEngines() throws Exception {\n+        clientEngine = SSL_CONTEXT.createSSLEngine(\"client\", 1);\n+        clientEngine.setUseClientMode(true);\n+\n+        serverEngine = SSL_CONTEXT.createSSLEngine(\"server\", 2);\n+        serverEngine.setUseClientMode(false);\n+    }\n+\n+    private boolean isHandshaking(SSLEngine e) {\n+        return (e.getHandshakeStatus() != HandshakeStatus.NOT_HANDSHAKING);\n+    }\n+\n+    private void checkResult(ByteBuffer bbIn, ByteBuffer bbOut,\n+            SSLEngineResult result,\n+            Status status, HandshakeStatus hsStatus,\n+            int consumed, int produced)\n+            throws Exception {\n+\n+        if ((status != null) && (result.getStatus() != status)) {\n+            throw new Exception(\"Unexpected Status: need = \" + status +\n+                \" got = \" + result.getStatus());\n+        }\n+\n+        if ((hsStatus != null) && (result.getHandshakeStatus() != hsStatus)) {\n+            throw new Exception(\"Unexpected hsStatus: need = \" + hsStatus +\n+                \" got = \" + result.getHandshakeStatus());\n+        }\n+\n+        if ((consumed != -1) && (consumed != result.bytesConsumed())) {\n+            throw new Exception(\"Unexpected consumed: need = \" + consumed +\n+                \" got = \" + result.bytesConsumed());\n+        }\n+\n+        if ((produced != -1) && (produced != result.bytesProduced())) {\n+            throw new Exception(\"Unexpected produced: need = \" + produced +\n+                \" got = \" + result.bytesProduced());\n+        }\n+\n+        if ((consumed != -1) && (bbIn.position() != result.bytesConsumed())) {\n+            throw new Exception(\"Consumed \" + bbIn.position() +\n+                \" != \" + consumed);\n+        }\n+\n+        if ((produced != -1) && (bbOut.position() != result.bytesProduced())) {\n+            throw new Exception(\"produced \" + bbOut.position() +\n+                \" != \" + produced);\n+        }\n+    }\n+\n+    private void test() throws Exception {\n+        createSSLEngines();\n+        createBuffers();\n+\n+        SSLEngineResult result1;        \/\/ clientEngine's results from last operation\n+        SSLEngineResult result2;        \/\/ serverEngine's results from last operation\n+        String [] suite1 = new String [] {\n+            \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA\" };\n+        String [] suite2 = new String [] {\n+            \"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\" };\n+\n+        clientEngine.setEnabledCipherSuites(suite1);\n+        serverEngine.setEnabledCipherSuites(suite1);\n+\n+        log(\"================\");\n+\n+        log(\"unexpected empty unwrap\");\n+        serverToClient.limit(0);\n+        result1 = clientEngine.unwrap(serverToClient, clientIn);\n+        checkResult(serverToClient, clientIn, result1,\n+            Status.OK, HandshakeStatus.NEED_WRAP, 0, 0);\n+        serverToClient.limit(serverToClient.capacity());\n+\n+        log(\"======================================\");\n+        log(\"Client -> Server [ClientHello]\");\n+        result1 = clientEngine.wrap(clientOut, clientToServer);\n+        checkResult(clientOut, clientToServer, result1,\n+             Status.OK, HandshakeStatus.NEED_UNWRAP, 0, -1);\n+\n+        clientToServer.flip();\n+        result2 = serverEngine.unwrap(clientToServer, serverIn);\n+\n+        checkResult(clientToServer, serverIn, result2,\n+             Status.OK, HandshakeStatus.NEED_TASK, result1.bytesProduced(), 0);\n+        runDelegatedTasks(serverEngine);\n+\n+        clientToServer.compact();\n+\n+        log(\"Check for unwrap when wrap needed\");\n+        result2 = serverEngine.unwrap(clientToServer, serverIn);\n+        checkResult(clientToServer, serverIn, result2,\n+            Status.OK, HandshakeStatus.NEED_WRAP, 0, 0);\n+\n+        log(\"======================================\");\n+        log(\"Server -> Client [ServerHello]\");\n+\n+        result2 = serverEngine.wrap(serverOut, serverToClient);\n+        checkResult(serverOut, serverToClient, result2,\n+            Status.OK, HandshakeStatus.NEED_UNWRAP, 0, -1);\n+        serverToClient.flip();\n+\n+        result1 = clientEngine.unwrap(serverToClient, clientIn);\n+        checkResult(serverToClient, clientIn, result1,\n+            Status.OK, HandshakeStatus.NEED_TASK, result2.bytesProduced(), 0);\n+        serverToClient.compact();\n+\n+        runDelegatedTasks(clientEngine);\n+\n+        log(\"======================================\");\n+        log(\"Client -> Server [ClientKeyExchange]\");\n+        result1 = clientEngine.wrap(clientOut, clientToServer);\n+        checkResult(clientOut, clientToServer, result1,\n+             Status.OK, HandshakeStatus.NEED_WRAP, 0, -1);\n+\n+        clientToServer.flip();\n+        result2 = serverEngine.unwrap(clientToServer, serverIn);\n+\n+        checkResult(clientToServer, serverIn, result2,\n+             Status.OK, HandshakeStatus.NEED_TASK, result1.bytesProduced(), 0);\n+        runDelegatedTasks(serverEngine);\n+\n+        clientToServer.compact();\n+\n+        log(\"======================================\");\n+        log(\"Client -> Server [ChangeCipherSpec]\");\n+        result1 = clientEngine.wrap(clientOut, clientToServer);\n+        checkResult(clientOut, clientToServer, result1,\n+             Status.OK, HandshakeStatus.NEED_WRAP, 0, -1);\n+\n+        clientToServer.flip();\n+        result2 = serverEngine.unwrap(clientToServer, serverIn);\n+\n+        checkResult(clientToServer, serverIn, result2,\n+             Status.OK, HandshakeStatus.NEED_UNWRAP,\n+             result1.bytesProduced(), 0);\n+\n+        clientToServer.compact();\n+\n+        log(\"======================================\");\n+        log(\"Client -> Server [Finished]\");\n+        result1 = clientEngine.wrap(clientOut, clientToServer);\n+        checkResult(clientOut, clientToServer, result1,\n+             Status.OK, HandshakeStatus.NEED_UNWRAP, 0, -1);\n+\n+        clientToServer.flip();\n+        result2 = serverEngine.unwrap(clientToServer, serverIn);\n+\n+        checkResult(clientToServer, serverIn, result2,\n+             Status.OK, HandshakeStatus.NEED_WRAP, result1.bytesProduced(), 0);\n+\n+        clientToServer.compact();\n+\n+        log(\"======================================\");\n+        log(\"Server -> Client [NewSessionTicket]\");\n+\n+        result2 = serverEngine.wrap(serverOut, serverToClient);\n+        checkResult(serverOut, serverToClient, result2,\n+            Status.OK, HandshakeStatus.NEED_WRAP, 0, -1);\n+        serverToClient.flip();\n+\n+        result1 = clientEngine.unwrap(serverToClient, clientIn);\n+        checkResult(serverToClient, clientIn, result1,\n+            Status.OK, HandshakeStatus.NEED_UNWRAP, result2.bytesProduced(), 0);\n+        serverToClient.compact();\n+\n+        log(\"======================================\");\n+        log(\"Server -> Client [ChangeCipherSpec]\");\n+\n+        result2 = serverEngine.wrap(serverOut, serverToClient);\n+        checkResult(serverOut, serverToClient, result2,\n+            Status.OK, HandshakeStatus.NEED_WRAP, 0, -1);\n+        serverToClient.flip();\n+\n+        result1 = clientEngine.unwrap(serverToClient, clientIn);\n+        checkResult(serverToClient, clientIn, result1,\n+            Status.OK, HandshakeStatus.NEED_UNWRAP, result2.bytesProduced(), 0);\n+        serverToClient.compact();\n+\n+        log(\"======================================\");\n+        log(\"Server -> Client [Finished]\");\n+\n+        result2 = serverEngine.wrap(serverOut, serverToClient);\n+        checkResult(serverOut, serverToClient, result2,\n+                Status.OK, HandshakeStatus.FINISHED, 0, -1);\n+        serverToClient.flip();\n+\n+        result1 = clientEngine.unwrap(serverToClient, clientIn);\n+        checkResult(serverToClient, clientIn, result1,\n+                Status.OK, HandshakeStatus.FINISHED, result2.bytesProduced(), 0);\n+        serverToClient.compact();\n+\n+\n+        log(\"======================================\");\n+        log(\"Check Session\/Ciphers\");\n+\n+        String suite = clientEngine.getSession().getCipherSuite();\n+        if (!suite.equals(suite1[0])) {\n+            throw new Exception(\"suites not equal: \" + suite + \"\/\" +\n+                suite1[0]);\n+        }\n+\n+        suite = serverEngine.getSession().getCipherSuite();\n+        if (!suite.equals(suite1[0])) {\n+            throw new Exception(\"suites not equal: \" + suite + \"\/\" +\n+                suite1[0]);\n+        }\n+\n+        log(\"======================================\");\n+        log(\"DATA\");\n+\n+        result1 = clientEngine.wrap(clientOut, clientToServer);\n+        checkResult(clientOut, clientToServer, result1,\n+            Status.OK, HandshakeStatus.NOT_HANDSHAKING,\n+            clientOut.capacity(), -1);\n+        clientToServer.flip();\n+\n+        result2 = serverEngine.wrap(serverOut, serverToClient);\n+        checkResult(serverOut, serverToClient, result2,\n+            Status.OK, HandshakeStatus.NOT_HANDSHAKING,\n+            serverOut.capacity(), -1);\n+        serverToClient.flip();\n+\n+        SSLEngineResult result3 = clientEngine.unwrap(serverToClient, clientIn);\n+        checkResult(serverToClient, clientIn, result3,\n+            Status.OK, HandshakeStatus.NOT_HANDSHAKING,\n+            result2.bytesProduced(), result2.bytesConsumed());\n+        serverToClient.compact();\n+\n+        SSLEngineResult result4 = serverEngine.unwrap(clientToServer, serverIn);\n+        checkResult(clientToServer, serverIn, result4,\n+            Status.OK, HandshakeStatus.NOT_HANDSHAKING,\n+            result1.bytesProduced(), result1.bytesConsumed());\n+        clientToServer.compact();\n+\n+        clientIn.clear();\n+        serverIn.clear();\n+        clientOut.rewind();\n+        serverOut.rewind();\n+\n+        log(\"======================================\");\n+        log(\"RENEGOTIATE\");\n+\n+        serverEngine.getSession().invalidate();\n+        serverEngine.setNeedClientAuth(true);\n+\n+        clientEngine.setEnabledCipherSuites(suite2);\n+        serverEngine.setEnabledCipherSuites(suite2);\n+\n+        serverEngine.beginHandshake();\n+\n+        log(\"======================================\");\n+        log(\"Server -> Client [HelloRequest]\");\n+\n+        result2 = serverEngine.wrap(serverOut, serverToClient);\n+        checkResult(serverOut, serverToClient, result2,\n+            Status.OK, HandshakeStatus.NEED_UNWRAP, 0, -1);\n+        serverToClient.flip();\n+\n+        result1 = clientEngine.unwrap(serverToClient, clientIn);\n+        checkResult(serverToClient, clientIn, result1,\n+            Status.OK, HandshakeStatus.NEED_TASK, result2.bytesProduced(), 0);\n+        serverToClient.compact();\n+\n+        runDelegatedTasks(clientEngine);\n+\n+        log(\"======================================\");\n+        log(\"CLient -> Server [ClientHello]\");\n+\n+        result1 = clientEngine.wrap(clientOut, clientToServer);\n+        checkResult(clientOut, clientToServer, result1,\n+             Status.OK, HandshakeStatus.NEED_UNWRAP, 0, -1);\n+\n+        clientToServer.flip();\n+        result2 = serverEngine.unwrap(clientToServer, serverIn);\n+\n+        checkResult(clientToServer, serverIn, result2,\n+             Status.OK, HandshakeStatus.NEED_TASK, result1.bytesProduced(), 0);\n+        runDelegatedTasks(serverEngine);\n+\n+        clientToServer.compact();\n+\n+        log(\"======================================\");\n+        log(\"CLIENT->SERVER DATA IN MIDDLE OF HANDSHAKE\");\n+\n+        result1 = clientEngine.wrap(clientOut, clientToServer);\n+        checkResult(clientOut, clientToServer, result1,\n+            Status.OK, HandshakeStatus.NEED_UNWRAP,\n+            clientOut.capacity(), -1);\n+        clientToServer.flip();\n+\n+        result4 = serverEngine.unwrap(clientToServer, serverIn);\n+        checkResult(clientToServer, serverIn, result4,\n+            Status.OK, HandshakeStatus.NEED_WRAP,\n+            result1.bytesProduced(), result1.bytesConsumed());\n+        clientToServer.compact();\n+\n+        serverIn.clear();\n+        clientOut.rewind();\n+\n+        log(\"======================================\");\n+        log(\"Server -> Client [ServerHello]\");\n+\n+        result2 = serverEngine.wrap(serverOut, serverToClient);\n+        checkResult(serverOut, serverToClient, result2,\n+            Status.OK, HandshakeStatus.NEED_UNWRAP, 0, -1);\n+        serverToClient.flip();\n+\n+        result1 = clientEngine.unwrap(serverToClient, clientIn);\n+        checkResult(serverToClient, clientIn, result1,\n+            Status.OK, HandshakeStatus.NEED_TASK, result2.bytesProduced(), 0);\n+        serverToClient.compact();\n+\n+        runDelegatedTasks(clientEngine);\n+\n+        log(\"======================================\");\n+        log(\"SERVER->CLIENT DATA IN MIDDLE OF HANDSHAKE\");\n+\n+        result2 = serverEngine.wrap(serverOut, serverToClient);\n+        checkResult(serverOut, serverToClient, result2,\n+            Status.OK, HandshakeStatus.NEED_UNWRAP,\n+            serverOut.capacity(), -1);\n+        serverToClient.flip();\n+\n+        result3 = clientEngine.unwrap(serverToClient, clientIn);\n+        checkResult(serverToClient, clientIn, result3,\n+            Status.OK, HandshakeStatus.NEED_WRAP,\n+            result2.bytesProduced(), result2.bytesConsumed());\n+        serverToClient.compact();\n+\n+        clientIn.clear();\n+        serverOut.rewind();\n+\n+        log(\"======================================\");\n+        log(\"Client -> Server [Certificate] and [ClientKeyExchange]\");\n+        result1 = clientEngine.wrap(clientOut, clientToServer);\n+        checkResult(clientOut, clientToServer, result1,\n+             Status.OK, HandshakeStatus.NEED_WRAP, 0, -1);\n+\n+        clientToServer.flip();\n+        result2 = serverEngine.unwrap(clientToServer, serverIn);\n+\n+        checkResult(clientToServer, serverIn, result2,\n+             Status.OK, HandshakeStatus.NEED_TASK, result1.bytesProduced(), 0);\n+        runDelegatedTasks(serverEngine);\n+\n+        clientToServer.compact();\n+\n+        log(\"======================================\");\n+        log(\"Client -> Server [ChangeCipherSpec]\");\n+        result1 = clientEngine.wrap(clientOut, clientToServer);\n+        checkResult(clientOut, clientToServer, result1,\n+             Status.OK, HandshakeStatus.NEED_WRAP, 0, -1);\n+\n+        clientToServer.flip();\n+        result2 = serverEngine.unwrap(clientToServer, serverIn);\n+\n+        checkResult(clientToServer, serverIn, result2,\n+             Status.OK, HandshakeStatus.NEED_UNWRAP,\n+             result1.bytesProduced(), 0);\n+\n+        clientToServer.compact();\n+\n+        log(\"======================================\");\n+        log(\"Client -> Server [Finished]\");\n+        result1 = clientEngine.wrap(clientOut, clientToServer);\n+        checkResult(clientOut, clientToServer, result1,\n+             Status.OK, HandshakeStatus.NEED_UNWRAP, 0, -1);\n+\n+        clientToServer.flip();\n+        result2 = serverEngine.unwrap(clientToServer, serverIn);\n+\n+        checkResult(clientToServer, serverIn, result2,\n+             Status.OK, HandshakeStatus.NEED_WRAP, result1.bytesProduced(), 0);\n+\n+        clientToServer.compact();\n+\n+        log(\"======================================\");\n+        log(\"Server -> Client [NewSessionTicket]\");\n+\n+        result2 = serverEngine.wrap(serverOut, serverToClient);\n+        checkResult(serverOut, serverToClient, result2,\n+            Status.OK, HandshakeStatus.NEED_WRAP, 0, -1);\n+        serverToClient.flip();\n+\n+        result1 = clientEngine.unwrap(serverToClient, clientIn);\n+        checkResult(serverToClient, clientIn, result1,\n+            Status.OK, HandshakeStatus.NEED_UNWRAP, result2.bytesProduced(), 0);\n+        serverToClient.compact();\n+\n+        log(\"======================================\");\n+        log(\"Server -> Client [ChangeCipherSpec]\");\n+\n+        result2 = serverEngine.wrap(serverOut, serverToClient);\n+        checkResult(serverOut, serverToClient, result2,\n+                Status.OK, HandshakeStatus.NEED_WRAP, 0, -1);\n+        serverToClient.flip();\n+\n+        result1 = clientEngine.unwrap(serverToClient, clientIn);\n+        checkResult(serverToClient, clientIn, result1,\n+                Status.OK, HandshakeStatus.NEED_UNWRAP, result2.bytesProduced(), 0);\n+        serverToClient.compact();\n+\n+        log(\"======================================\");\n+        log(\"Server -> Client [Finished]\");\n+\n+        result2 = serverEngine.wrap(serverOut, serverToClient);\n+        checkResult(serverOut, serverToClient, result2,\n+            Status.OK, HandshakeStatus.FINISHED, 0, -1);\n+        serverToClient.flip();\n+\n+        result1 = clientEngine.unwrap(serverToClient, clientIn);\n+        checkResult(serverToClient, clientIn, result1,\n+            Status.OK, HandshakeStatus.FINISHED, result2.bytesProduced(), 0);\n+        serverToClient.compact();\n+\n+        log(\"======================================\");\n+        log(\"Check Session\/Ciphers\");\n+\n+        suite = clientEngine.getSession().getCipherSuite();\n+        if (!suite.equals(suite2[0])) {\n+            throw new Exception(\"suites not equal: \" + suite + \"\/\" +\n+                suite2[0]);\n+        }\n+\n+        suite = serverEngine.getSession().getCipherSuite();\n+        if (!suite.equals(suite2[0])) {\n+            throw new Exception(\"suites not equal: \" + suite + \"\/\" +\n+                suite2[0]);\n+        }\n+\n+        log(\"======================================\");\n+        log(\"DATA USING NEW SESSION\");\n+\n+        result1 = clientEngine.wrap(clientOut, clientToServer);\n+        checkResult(clientOut, clientToServer, result1,\n+            Status.OK, HandshakeStatus.NOT_HANDSHAKING,\n+            clientOut.capacity(), -1);\n+        clientToServer.flip();\n+\n+        result2 = serverEngine.wrap(serverOut, serverToClient);\n+        checkResult(serverOut, serverToClient, result2,\n+            Status.OK, HandshakeStatus.NOT_HANDSHAKING,\n+            serverOut.capacity(), -1);\n+        serverToClient.flip();\n+\n+        result3 = clientEngine.unwrap(serverToClient, clientIn);\n+        checkResult(serverToClient, clientIn, result3,\n+            Status.OK, HandshakeStatus.NOT_HANDSHAKING,\n+            result2.bytesProduced(), result2.bytesConsumed());\n+        serverToClient.compact();\n+\n+        result4 = serverEngine.unwrap(clientToServer, serverIn);\n+        checkResult(clientToServer, serverIn, result4,\n+            Status.OK, HandshakeStatus.NOT_HANDSHAKING,\n+            result1.bytesProduced(), result1.bytesConsumed());\n+        clientToServer.compact();\n+\n+        clientIn.clear();\n+        serverIn.clear();\n+        clientOut.rewind();\n+        serverOut.rewind();\n+\n+        log(\"======================================\");\n+        log(\"Server -> Client [CloseNotify]\");\n+\n+        if (isHandshaking(clientEngine)) {\n+            throw new Exception(\"clientEngine IS handshaking\");\n+        }\n+\n+        if (isHandshaking(serverEngine)) {\n+            throw new Exception(\"serverEngine IS handshaking\");\n+        }\n+\n+        serverEngine.closeOutbound();\n+\n+        if (!isHandshaking(serverEngine)) {\n+            throw new Exception(\"serverEngine IS NOT handshaking\");\n+        }\n+\n+        clientOut.rewind();\n+        serverOut.rewind();\n+\n+        result2 = serverEngine.wrap(serverOut, serverToClient);\n+        checkResult(serverOut, serverToClient, result2,\n+            Status.CLOSED, HandshakeStatus.NOT_HANDSHAKING, 0, -1);\n+        serverToClient.flip();\n+\n+        if (clientEngine.isInboundDone()) {\n+            throw new Exception(\"clientEngine inboundDone\");\n+        }\n+\n+        result1 = clientEngine.unwrap(serverToClient, clientIn);\n+        checkResult(serverToClient, clientIn, result1,\n+            Status.CLOSED, HandshakeStatus.NEED_WRAP,\n+            result2.bytesProduced(), 0);\n+        serverToClient.compact();\n+\n+        if (!clientEngine.isInboundDone()) {\n+            throw new Exception(\"clientEngine inboundDone\");\n+        }\n+\n+        if (!isHandshaking(clientEngine)) {\n+            throw new Exception(\"clientEngine IS NOT handshaking\");\n+        }\n+\n+        result2 = serverEngine.wrap(serverOut, serverToClient);\n+        checkResult(serverOut, serverToClient, result2,\n+            Status.CLOSED, HandshakeStatus.NOT_HANDSHAKING, 0, 0);\n+        serverToClient.flip();\n+\n+        log(\"======================================\");\n+        log(\"CloseNotify response\");\n+\n+        if (clientEngine.isOutboundDone()) {\n+            throw new Exception(\"clientEngine outboundDone\");\n+        }\n+\n+        result1 = clientEngine.wrap(clientOut, clientToServer);\n+        checkResult(clientOut, clientToServer, result1,\n+                        Status.CLOSED, HandshakeStatus.NOT_HANDSHAKING, 0, -1);\n+\n+        if (!clientEngine.isOutboundDone()) {\n+            throw new Exception(\"clientEngine outboundDone is NOT done\");\n+        }\n+\n+        if (isHandshaking(clientEngine)) {\n+            throw new Exception(\"clientEngine IS handshaking\");\n+        }\n+\n+        clientToServer.flip();\n+\n+        if (!serverEngine.isOutboundDone()) {\n+            throw new Exception(\"clientEngine outboundDone\");\n+        }\n+\n+        if (serverEngine.isInboundDone()) {\n+            throw new Exception(\"clientEngine inboundDone\");\n+        }\n+\n+        result2 = serverEngine.unwrap(clientToServer, serverIn);\n+\n+        checkResult(clientToServer, serverIn, result2,\n+             Status.CLOSED, HandshakeStatus.NOT_HANDSHAKING,\n+             result1.bytesProduced(), 0);\n+\n+        if (!serverEngine.isOutboundDone()) {\n+            throw new Exception(\"clientEngine outboundDone is NOT done\");\n+        }\n+\n+        if (!serverEngine.isInboundDone()) {\n+            throw new Exception(\"clientEngine inboundDone is NOT done\");\n+        }\n+\n+        if (isHandshaking(serverEngine)) {\n+            throw new Exception(\"clientEngine IS handshaking\");\n+        }\n+\n+        clientToServer.compact();\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+        CheckTlsEngineResults cs = new CheckTlsEngineResults();\n+        cs.test();\n+        System.out.println(\"Test Passed.\");\n+    }\n+\n+    \/*\n+     * **********************************************************\n+     * Majority of the test case is above, below is just setup stuff\n+     * **********************************************************\n+     *\/\n+\n+    public CheckTlsEngineResults() throws Exception {\n+        SSL_CONTEXT = getSSLContext(keyFilename, trustFilename);\n+    }\n+\n+    \/*\n+     * Create an initialized SSLContext to use for this test.\n+     *\/\n+    private SSLContext getSSLContext(String keyFile, String trustFile)\n+            throws Exception {\n+\n+        KeyStore ks = KeyStore.getInstance(\"JKS\");\n+        KeyStore ts = KeyStore.getInstance(\"JKS\");\n+\n+        char[] passphrase = \"passphrase\".toCharArray();\n+\n+        ks.load(new FileInputStream(keyFile), passphrase);\n+        ts.load(new FileInputStream(trustFile), passphrase);\n+\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n+        kmf.init(ks, passphrase);\n+\n+        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n+        tmf.init(ts);\n+\n+        SSLContext sslCtx = SSLContext.getInstance(\"TLSv1.2\");\n+\n+        sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+\n+        return sslCtx;\n+    }\n+\n+    private void createBuffers() {\n+        \/\/ Size the buffers as appropriate.\n+\n+        SSLSession session = clientEngine.getSession();\n+        int appBufferMax = session.getApplicationBufferSize();\n+        int netBufferMax = session.getPacketBufferSize();\n+\n+        clientIn = ByteBuffer.allocateDirect(appBufferMax + 50);\n+        serverIn = ByteBuffer.allocateDirect(appBufferMax + 50);\n+\n+        clientToServer = ByteBuffer.allocateDirect(netBufferMax);\n+        serverToClient = ByteBuffer.allocateDirect(netBufferMax);\n+\n+        clientOut = ByteBuffer.wrap(\"Hi Server, I'm Client\".getBytes());\n+        serverOut = ByteBuffer.wrap(\"Hello Client, I'm Server\".getBytes());\n+\n+        log(\"Client out = \" + clientOut);\n+        log(\"Server out = \" + serverOut);\n+        log(\"\");\n+    }\n+\n+    private static void runDelegatedTasks(SSLEngine engine) {\n+\n+        Runnable runnable;\n+        while ((runnable = engine.getDelegatedTask()) != null) {\n+            log(\"Running delegated task...\");\n+            runnable.run();\n+        }\n+    }\n+\n+    private static void log(String str) {\n+        System.out.println(str);\n+    }\n+}\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLEngine\/CheckTlsEngineResults.java","additions":709,"deletions":0,"binary":false,"changes":709,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,1 @@\n- *\n- * @run main\/othervm EngineCloseOnAlert\n+ * @run main EngineCloseOnAlert\n@@ -43,3 +42,3 @@\n-    private static final String pathToStores = \"..\/etc\";\n-    private static final String keyStoreFile = \"keystore\";\n-    private static final String trustStoreFile = \"truststore\";\n+    private static final String PATH_TO_STORES = \"..\/etc\";\n+    private static final String KEYSTORE_FILENAME = \"keystore\";\n+    private static final String TRUSTSTORE_FILENAME = \"truststore\";\n@@ -47,6 +46,6 @@\n-    private static final String keyFilename =\n-            System.getProperty(\"test.src\", \".\") + \"\/\" + pathToStores +\n-                \"\/\" + keyStoreFile;\n-    private static final String trustFilename =\n-            System.getProperty(\"test.src\", \".\") + \"\/\" + pathToStores +\n-                \"\/\" + trustStoreFile;\n+    private static final String KEYSTORE_PATH =\n+            System.getProperty(\"test.src\", \".\") + \"\/\" + PATH_TO_STORES +\n+                \"\/\" + KEYSTORE_FILENAME;\n+    private static final String TRUSTSTORE_PATH =\n+            System.getProperty(\"test.src\", \".\") + \"\/\" + PATH_TO_STORES +\n+                \"\/\" + TRUSTSTORE_FILENAME;\n@@ -56,1 +55,0 @@\n-    private static TrustManagerFactory EMPTY_TMF;\n@@ -58,2 +56,0 @@\n-    private static final String[] TLS10ONLY = { \"TLSv1\" };\n-    private static final String[] TLS12ONLY = { \"TLSv1.2\" };\n@@ -94,0 +90,1 @@\n+    private static final String TLSv12 = \"TLSv1.2\";\n@@ -107,1 +104,3 @@\n-            SSLContext context = SSLContext.getDefault();\n+            SSLContext context = SSLContext.getInstance(TLSv12);\n+            context.init(null, null, null);\n+\n@@ -139,1 +138,2 @@\n-            } catch (SSLException e) {\n+                throw new RuntimeException(\"The expected SSLHandshakeException was not thrown.\");\n+            } catch (SSLHandshakeException e) {\n@@ -150,3 +150,0 @@\n-            \/\/ The above should show that isInboundDone returns true, and\n-            \/\/ handshake status is NEED_WRAP. That is the correct behavior,\n-            \/\/ wrap will put a fatal alert message in the buffer.\n@@ -159,1 +156,1 @@\n-            checkEngineState(server, NEED_UNWRAP, true, true);\n+            checkEngineState(server, NOT_HANDSHAKING, true, true);\n@@ -170,1 +167,2 @@\n-            } catch (SSLException e) {\n+                throw new RuntimeException(\"Client did not throw the expected SSLException.\");\n+            } catch (SSLHandshakeException e) {\n@@ -191,2 +189,3 @@\n-            SSLContext cliContext = SSLContext.getDefault();\n-            SSLContext servContext = SSLContext.getInstance(\"TLS\");\n+            SSLContext cliContext = SSLContext.getInstance(TLSv12);\n+            cliContext.init(null, null, null);\n+            SSLContext servContext = SSLContext.getInstance(TLSv12);\n@@ -198,1 +197,0 @@\n-            client.setEnabledProtocols(TLS12ONLY);\n@@ -201,1 +199,0 @@\n-            server.setEnabledProtocols(TLS10ONLY);\n@@ -235,2 +232,3 @@\n-            \/\/ The client should parse this and throw an exception because\n-            \/\/ It is unwiling to do TLS 1.0\n+            \/\/ Change the handshake type field to client_hello which will\n+            \/\/ cause the client to generate an unexpected_message alert\n+            raw.put(5, (byte)0x1);\n@@ -240,1 +238,2 @@\n-            checkEngineState(client, NEED_UNWRAP, false, false);\n+            checkEngineState(client, NEED_WRAP, true, false);\n+            raw.clear();\n@@ -242,0 +241,1 @@\n+            \/\/ Now the client should wrap the exception\n@@ -243,7 +243,10 @@\n-                client.unwrap(raw, plain);\n-            } catch (SSLException e) {\n-                System.out.println(\"Client throws exception: \" + e);\n-                System.out.println(\"Engine closure status: isInboundDone=\"\n-                        + client.isInboundDone() + \", isOutboundDone=\"\n-                        + client.isOutboundDone() + \", handshake status=\"\n-                        + client.getHandshakeStatus());\n+                client.wrap(plain, raw);\n+                throw new RuntimeException(\"The expected exception was not \"\n+                    + \"thrown after the client processed an unexpected message.\");\n+            } catch (SSLProtocolException exc) {\n+                \/\/ this is the expected code path\n+                System.out.println(\"Client throws expected exception: \" + exc);\n+                System.out.println(\"Client engine state: \" +\n+                        \"isInboundDone = \"+ client.isInboundDone() +\n+                        \", isOutboundDone = \" + client.isOutboundDone() +\n+                        \", handshake status = \" + client.getHandshakeStatus());\n@@ -253,2 +256,0 @@\n-\n-            \/\/ Now the client should wrap the exception\n@@ -256,2 +257,1 @@\n-            checkEngineState(client, NEED_UNWRAP, true, true);\n-            raw.flip();\n+            checkEngineState(client, NOT_HANDSHAKING, true, true);\n@@ -260,0 +260,1 @@\n+            raw.flip();\n@@ -263,2 +264,3 @@\n-                checkEngineState(server, NEED_UNWRAP, false, false);\n-            } catch (SSLException e) {\n+                throw new RuntimeException(\"The server did not throw an \"\n+                        + \"SSLProtocolException after parsing an alert message.\");\n+            } catch (SSLProtocolException e) {\n@@ -341,2 +343,2 @@\n-        keystore.load(new FileInputStream(keyFilename), passphrase);\n-        truststore.load(new FileInputStream(trustFilename), passphrase);\n+        keystore.load(new FileInputStream(KEYSTORE_PATH), passphrase);\n+        truststore.load(new FileInputStream(TRUSTSTORE_PATH), passphrase);\n@@ -349,1 +351,1 @@\n-        EMPTY_TMF = TrustManagerFactory.getInstance(\"PKIX\");\n+        TrustManagerFactory EMPTY_TMF = TrustManagerFactory.getInstance(\"PKIX\");\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLEngine\/EngineCloseOnAlert.java","additions":47,"deletions":45,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -1,266 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.awt.AWTException;\n-import java.awt.Color;\n-import java.awt.GridBagLayout;\n-import java.awt.Image;\n-import java.awt.Point;\n-import java.awt.Rectangle;\n-import java.awt.Robot;\n-import java.awt.image.MultiResolutionImage;\n-import java.awt.image.RenderedImage;\n-import java.io.File;\n-import java.lang.reflect.InvocationTargetException;\n-import java.util.List;\n-\n-import javax.imageio.ImageIO;\n-import javax.swing.JFrame;\n-import javax.swing.JInternalFrame;\n-import javax.swing.JLabel;\n-import javax.swing.SwingUtilities;\n-import javax.swing.UIManager;\n-\n-\/*\n- * @test\n- * @bug 8015739\n- * @key headful\n- * @summary Tests whether background color of JInternalFrame is visible\n- * in the border region at different scales by checking the midpoints\n- * and corners of the border.\n- *\n- * @requires (os.family == \"windows\")\n- * @run main\/othervm -Dsun.java2d.uiScale=1 InternalFrameBorderTest\n- * @run main\/othervm -Dsun.java2d.uiScale=1.25 InternalFrameBorderTest\n- * @run main\/othervm -Dsun.java2d.uiScale=1.5 InternalFrameBorderTest\n- * @run main\/othervm -Dsun.java2d.uiScale=1.75 InternalFrameBorderTest\n- * @run main\/othervm -Dsun.java2d.uiScale=2 InternalFrameBorderTest\n- * @run main\/othervm -Dsun.java2d.uiScale=2.5 InternalFrameBorderTest\n- * @run main\/othervm -Dsun.java2d.uiScale=3 InternalFrameBorderTest\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8015739\n- * @key headful\n- * @summary Tests whether background color of JInternalFrame is visible\n- * in the border region at different scales by checking the midpoints\n- * and corners of the border.\n- *\n- * @requires (os.family == \"mac\" | os.family == \"linux\")\n- * @run main\/othervm -Dsun.java2d.uiScale=1 InternalFrameBorderTest\n- * @run main\/othervm -Dsun.java2d.uiScale=2 InternalFrameBorderTest\n- *\/\n-\n-public class InternalFrameBorderTest {\n-    private static final int FRAME_SIZE = 300;\n-    private static final int INTFRAME_SIZE = 150;\n-    private static final int MIDPOINT = INTFRAME_SIZE \/ 2;\n-    private static final int BORDER_THICKNESS = 4;\n-\n-    private static final StringBuffer errorLog = new StringBuffer();\n-\n-    private static JFrame jFrame;\n-    private static Rectangle jFrameBounds;\n-    private static JInternalFrame iFrame;\n-    private static Point iFrameLoc;\n-    private static int iFrameMaxX;\n-    private static int iFrameMaxY;\n-\n-    private static Robot robot;\n-    private static String uiScale;\n-\n-    public static void main(String[] args) throws AWTException,\n-            InterruptedException, InvocationTargetException {\n-        try {\n-            UIManager.setLookAndFeel(\"javax.swing.plaf.metal.MetalLookAndFeel\");\n-        } catch (Exception e) {\n-            System.out.println(\"Metal LAF class not supported\");\n-            return;\n-        }\n-\n-        try {\n-            robot = new Robot();\n-            robot.setAutoDelay(200);\n-            uiScale = System.getProperty(\"sun.java2d.uiScale\");\n-\n-            SwingUtilities.invokeAndWait(InternalFrameBorderTest::createAndShowGUI);\n-            robot.waitForIdle();\n-            robot.delay(500);\n-\n-            SwingUtilities.invokeAndWait(() -> {\n-                iFrameLoc = iFrame.getLocationOnScreen();\n-                iFrameMaxX = iFrameLoc.x + INTFRAME_SIZE;\n-                iFrameMaxY = iFrameLoc.y + INTFRAME_SIZE;\n-                jFrameBounds = jFrame.getBounds();\n-            });\n-\n-            \/\/ Check Borders\n-            checkBorderMidPoints(\"TOP\");\n-            checkBorderMidPoints(\"RIGHT\");\n-            checkBorderMidPoints(\"BOTTOM\");\n-            checkBorderMidPoints(\"LEFT\");\n-\n-            \/\/ Check Corner Diagonals\n-            checkCorners(\"TOP_LEFT\");\n-            checkCorners(\"TOP_RIGHT\");\n-            checkCorners(\"BOTTOM_RIGHT\");\n-            checkCorners(\"BOTTOM_LEFT\");\n-\n-            if (!errorLog.isEmpty()) {\n-                saveScreenCapture(\"JIF_uiScale_\" + uiScale + \".png\");\n-                throw new RuntimeException(\"Following error(s) occurred: \\n\"\n-                        + errorLog);\n-            }\n-        } finally {\n-            if (jFrame != null) {\n-                jFrame.dispose();\n-            }\n-            robot.delay(500);\n-        }\n-    }\n-\n-    private static void checkBorderMidPoints(String borderDirection) {\n-        int x, y;\n-        int start, stop;\n-\n-        switch (borderDirection) {\n-            case \"TOP\" -> {\n-                x = iFrameLoc.x + MIDPOINT;\n-                y = iFrameLoc.y + BORDER_THICKNESS;\n-                start = iFrameLoc.y;\n-                stop = iFrameLoc.y + BORDER_THICKNESS - 1;\n-            }\n-            case \"RIGHT\" -> {\n-                x = iFrameMaxX - BORDER_THICKNESS;\n-                y = iFrameLoc.y + MIDPOINT;\n-                start = iFrameMaxX - BORDER_THICKNESS + 1;\n-                stop = iFrameMaxX;\n-            }\n-            case \"BOTTOM\" -> {\n-                x = iFrameLoc.x + MIDPOINT;\n-                y = iFrameMaxY - BORDER_THICKNESS;\n-                start = iFrameMaxY - BORDER_THICKNESS + 1;\n-                stop = iFrameMaxY;\n-            }\n-            case \"LEFT\" -> {\n-                x = iFrameLoc.x;\n-                y = iFrameLoc.y + MIDPOINT;\n-                start = iFrameLoc.x;\n-                stop = iFrameLoc.x + BORDER_THICKNESS - 1;\n-            }\n-            default -> throw new IllegalStateException(\"Unexpected value: \"\n-                    + borderDirection);\n-        }\n-\n-        boolean isVertical = borderDirection.equals(\"RIGHT\")\n-                || borderDirection.equals(\"LEFT\");\n-        boolean isHorizontal = borderDirection.equals(\"TOP\")\n-                || borderDirection.equals(\"BOTTOM\");\n-\n-        robot.mouseMove(x, y);\n-        for (int i = start; i < stop; i++) {\n-            int locX = isVertical ? i : (iFrameLoc.x + MIDPOINT);\n-            int locY = isHorizontal ? i : (iFrameLoc.y + MIDPOINT);\n-            if (Color.RED.equals(robot.getPixelColor(locX, locY))) {\n-                errorLog.append(\"At uiScale: \" + uiScale\n-                        + \", Red background color detected at \"\n-                        + borderDirection + \" border.\\n\");\n-                break;\n-            }\n-        }\n-        robot.delay(300);\n-    }\n-\n-    private static void checkCorners(String cornerLocation) {\n-        int x, y;\n-\n-        switch (cornerLocation) {\n-            case \"TOP_LEFT\" -> {\n-                x = iFrameLoc.x;\n-                y = iFrameLoc.y;\n-            }\n-            case \"TOP_RIGHT\" -> {\n-                x = iFrameMaxX;\n-                y = iFrameLoc.y;\n-            }\n-            case \"BOTTOM_RIGHT\" -> {\n-                x = iFrameMaxX;\n-                y = iFrameMaxY;\n-            }\n-            case \"BOTTOM_LEFT\" -> {\n-                x = iFrameLoc.x;\n-                y = iFrameMaxY;\n-            }\n-            default -> throw new IllegalStateException(\"Unexpected value: \"\n-                    + cornerLocation);\n-        }\n-\n-        boolean isTop = cornerLocation.equals(\"TOP_LEFT\")\n-                || cornerLocation.equals(\"TOP_RIGHT\");\n-        boolean isLeft = cornerLocation.equals(\"TOP_LEFT\")\n-                || cornerLocation.equals(\"BOTTOM_LEFT\");\n-\n-        robot.mouseMove(x, y);\n-        for (int i = 0; i < BORDER_THICKNESS - 1; i++) {\n-            int locX = isLeft ? (x + i) : (x - i);\n-            int locY = isTop ? (y + i) : (y - i);\n-            if (Color.RED.equals(robot.getPixelColor(locX, locY))) {\n-                errorLog.append(\"At uiScale: \" + uiScale + \", Red background color\"\n-                        + \" detected at \" + cornerLocation + \" corner.\\n\");\n-                break;\n-            }\n-        }\n-        robot.delay(300);\n-    }\n-\n-    private static void createAndShowGUI() {\n-        jFrame = new JFrame();\n-        jFrame.setSize(FRAME_SIZE, FRAME_SIZE);\n-        jFrame.setLayout(null);\n-        jFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n-\n-        JLabel scale = new JLabel(\"UI Scale: \" + uiScale);\n-        iFrame = new JInternalFrame(\"iframe\", true);\n-        iFrame.setLayout(new GridBagLayout());\n-        iFrame.setBackground(Color.RED);\n-        iFrame.add(scale);\n-        iFrame.setLocation(30, 30);\n-        jFrame.getContentPane().add(iFrame);\n-        iFrame.setSize(INTFRAME_SIZE, INTFRAME_SIZE);\n-        iFrame.setVisible(true);\n-        jFrame.setLocation(150, 150);\n-        jFrame.setVisible(true);\n-    }\n-\n-    private static void saveScreenCapture(String filename) {\n-        MultiResolutionImage mrImage = robot.createMultiResolutionScreenCapture(jFrameBounds);\n-        List<Image> variants = mrImage.getResolutionVariants();\n-        RenderedImage image = (RenderedImage) variants.get(variants.size() - 1);\n-        try {\n-            ImageIO.write(image, \"png\", new File(filename));\n-        } catch (Exception e) {\n-            e.printStackTrace();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/javax\/swing\/JInternalFrame\/InternalFrameBorderTest.java","additions":0,"deletions":266,"binary":false,"changes":266,"status":"deleted"},{"patch":"@@ -0,0 +1,351 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.AWTException;\n+import java.awt.Color;\n+import java.awt.Frame;\n+import java.awt.GridBagLayout;\n+import java.awt.Image;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.image.MultiResolutionImage;\n+import java.awt.image.RenderedImage;\n+import java.io.File;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.List;\n+import javax.imageio.ImageIO;\n+import javax.swing.JDialog;\n+import javax.swing.JFrame;\n+import javax.swing.JInternalFrame;\n+import javax.swing.JLabel;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+\n+\/*\n+ * @test\n+ * @bug 8015739 8294484\n+ * @key headful\n+ * @summary Tests whether Metal borders for JFrame, JDialog and JInternalFrame\n+ * scales correctly without any distortions by checking the midpoints and\n+ * corners of the border.\n+ *\n+ * @requires (os.family == \"windows\")\n+ * @run main\/othervm -Dsun.java2d.uiScale=1 ScaledMetalBorderTest\n+ * @run main\/othervm -Dsun.java2d.uiScale=1.25 ScaledMetalBorderTest\n+ * @run main\/othervm -Dsun.java2d.uiScale=1.5 ScaledMetalBorderTest\n+ * @run main\/othervm -Dsun.java2d.uiScale=1.75 ScaledMetalBorderTest\n+ * @run main\/othervm -Dsun.java2d.uiScale=2 ScaledMetalBorderTest\n+ * @run main\/othervm -Dsun.java2d.uiScale=2.5 ScaledMetalBorderTest\n+ * @run main\/othervm -Dsun.java2d.uiScale=3 ScaledMetalBorderTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8015739 8294484\n+ * @key headful\n+ * @summary Tests whether Metal borders for JFrame, JDialog and JInternalFrame\n+ * scales correctly without any distortions by checking the midpoints and\n+ * corners of the border.\n+ *\n+ * @requires (os.family == \"mac\" | os.family == \"linux\")\n+ * @run main\/othervm -Dsun.java2d.uiScale=1 ScaledMetalBorderTest\n+ * @run main\/othervm -Dsun.java2d.uiScale=2 ScaledMetalBorderTest\n+ *\/\n+\n+public class ScaledMetalBorderTest {\n+    private static final int SIZE = 250;\n+    private static final int INTFRAME_SIZE = 180;\n+    private static int MIDPOINT = SIZE \/ 2;\n+    private static final int BORDER_THICKNESS = 4;\n+\n+    private static final StringBuffer errorLog = new StringBuffer();\n+\n+    private static JFrame jFrame;\n+    private static JDialog jDialog;\n+    private static JInternalFrame iFrame;\n+    private static Rectangle windowBounds;\n+    private static Point windowLoc;\n+    private static int windowMaxX;\n+    private static int windowMaxY;\n+\n+    private static Robot robot;\n+    private static String uiScale;\n+    private static JLabel scale;\n+\n+    public static void main(String[] args) throws AWTException,\n+            InterruptedException, InvocationTargetException {\n+        try {\n+            UIManager.setLookAndFeel(\"javax.swing.plaf.metal.MetalLookAndFeel\");\n+            JFrame.setDefaultLookAndFeelDecorated(true);\n+            JDialog.setDefaultLookAndFeelDecorated(true);\n+        } catch (Exception e) {\n+            System.out.println(\"Metal LAF class not supported\");\n+            return;\n+        }\n+\n+        try {\n+            robot = new Robot();\n+            robot.setAutoDelay(100);\n+            uiScale = System.getProperty(\"sun.java2d.uiScale\");\n+            scale = new JLabel(\"UI Scale: \" + uiScale);\n+\n+            \/\/Case 1: JFrame\n+            SwingUtilities.invokeAndWait(ScaledMetalBorderTest::createFrame);\n+            robot.waitForIdle();\n+            robot.delay(100);\n+            runTests(\"JFrame\");\n+\n+            if (!errorLog.isEmpty()) {\n+                saveScreenCapture(\"Frame_uiScale_\" + uiScale + \".png\");\n+                System.err.println(\"JFrame at uiScale: \" + uiScale);\n+                throw new RuntimeException(\"Following error(s) occurred: \\n\"\n+                        + errorLog);\n+            }\n+            errorLog.setLength(0); \/\/ to clear the StringBuffer before next test.\n+\n+            \/\/Case 2: JDialog\n+            SwingUtilities.invokeAndWait(ScaledMetalBorderTest::createDialog);\n+            robot.waitForIdle();\n+            robot.delay(100);\n+            runTests(\"JDialog\");\n+\n+            if (!errorLog.isEmpty()) {\n+                saveScreenCapture(\"Dialog_uiScale_\" + uiScale + \".png\");\n+                System.err.println(\"JDialog at uiScale: \" + uiScale);\n+                throw new RuntimeException(\"Following error(s) occurred: \\n\"\n+                        + errorLog);\n+            }\n+            errorLog.setLength(0); \/\/ to clear the StringBuffer before next test.\n+\n+            \/\/Case 3: JInternalFrame\n+            SwingUtilities.invokeAndWait(ScaledMetalBorderTest::createJInternalFrame);\n+            robot.waitForIdle();\n+            robot.delay(100);\n+            runTests(\"JIF\");\n+\n+            if (!errorLog.isEmpty()) {\n+                saveScreenCapture(\"JIF_uiScale_\" + uiScale + \".png\");\n+                System.err.println(\"JInternalFrame at uiScale: \" + uiScale);\n+                throw new RuntimeException(\"Following error(s) occurred: \\n\"\n+                        + errorLog);\n+            }\n+        } finally {\n+            SwingUtilities.invokeAndWait(() ->{\n+                if (jFrame != null) {\n+                    jFrame.dispose();\n+                }\n+                if (jDialog != null) {\n+                    jDialog.dispose();\n+                }\n+            });\n+            robot.delay(200);\n+        }\n+    }\n+\n+    private static void runTests(String windowType) throws InterruptedException,\n+                                                           InvocationTargetException {\n+        SwingUtilities.invokeAndWait(() -> {\n+            switch (windowType) {\n+                case \"JFrame\" -> {\n+                    windowLoc = jFrame.getLocationOnScreen();\n+                    windowBounds = jFrame.getBounds();\n+                    windowMaxX = windowLoc.x + SIZE;\n+                    windowMaxY = windowLoc.y + SIZE;\n+                }\n+                case \"JDialog\" -> {\n+                    windowLoc = jDialog.getLocationOnScreen();\n+                    windowBounds = jDialog.getBounds();\n+                    windowMaxX = windowLoc.x + SIZE;\n+                    windowMaxY = windowLoc.y + SIZE;\n+                }\n+                case \"JIF\" -> {\n+                    MIDPOINT = INTFRAME_SIZE \/ 2;\n+                    windowLoc = iFrame.getLocationOnScreen();\n+                    windowBounds = jFrame.getBounds();\n+                    windowMaxX = windowLoc.x + INTFRAME_SIZE;\n+                    windowMaxY = windowLoc.y + INTFRAME_SIZE;\n+                }\n+            }\n+        });\n+\n+        \/\/ Check Borders\n+        checkBorderMidPoints(\"TOP\");\n+        checkBorderMidPoints(\"RIGHT\");\n+        checkBorderMidPoints(\"BOTTOM\");\n+        checkBorderMidPoints(\"LEFT\");\n+\n+        \/\/ Check Corner Diagonals\n+        checkCorners(\"TOP_LEFT\");\n+        checkCorners(\"TOP_RIGHT\");\n+        checkCorners(\"BOTTOM_RIGHT\");\n+        checkCorners(\"BOTTOM_LEFT\");\n+    }\n+\n+    private static void checkBorderMidPoints(String borderDirection) {\n+        int x, y;\n+        int start, stop;\n+\n+        switch (borderDirection) {\n+            case \"TOP\" -> {\n+                x = windowLoc.x + MIDPOINT;\n+                y = windowLoc.y + BORDER_THICKNESS;\n+                start = windowLoc.y;\n+                stop = windowLoc.y + BORDER_THICKNESS - 1;\n+            }\n+            case \"RIGHT\" -> {\n+                x = windowMaxX - BORDER_THICKNESS;\n+                y = windowLoc.y + MIDPOINT;\n+                start = windowMaxX - BORDER_THICKNESS + 1;\n+                stop = windowMaxX;\n+            }\n+            case \"BOTTOM\" -> {\n+                x = windowLoc.x + MIDPOINT;\n+                y = windowMaxY - BORDER_THICKNESS;\n+                start = windowMaxY - BORDER_THICKNESS + 1;\n+                stop = windowMaxY;\n+            }\n+            case \"LEFT\" -> {\n+                x = windowLoc.x;\n+                y = windowLoc.y + MIDPOINT;\n+                start = windowLoc.x;\n+                stop = windowLoc.x + BORDER_THICKNESS - 1;\n+            }\n+            default -> throw new IllegalStateException(\"Unexpected value: \"\n+                    + borderDirection);\n+        }\n+\n+        boolean isVertical = borderDirection.equals(\"RIGHT\")\n+                || borderDirection.equals(\"LEFT\");\n+        boolean isHorizontal = borderDirection.equals(\"TOP\")\n+                || borderDirection.equals(\"BOTTOM\");\n+\n+        robot.mouseMove(x, y);\n+        for (int i = start; i < stop; i++) {\n+            int locX = isVertical ? i : (windowLoc.x + MIDPOINT);\n+            int locY = isHorizontal ? i : (windowLoc.y + MIDPOINT);\n+            if (Color.RED.equals(robot.getPixelColor(locX, locY))) {\n+                errorLog.append(\"At uiScale: \" + uiScale\n+                        + \", Red background color detected at \"\n+                        + borderDirection + \" border.\\n\");\n+                break;\n+            }\n+        }\n+        robot.delay(100);\n+    }\n+\n+    private static void checkCorners(String cornerLocation) {\n+        int x, y;\n+\n+        switch (cornerLocation) {\n+            case \"TOP_LEFT\" -> {\n+                x = windowLoc.x;\n+                y = windowLoc.y;\n+            }\n+            case \"TOP_RIGHT\" -> {\n+                x = windowMaxX;\n+                y = windowLoc.y;\n+            }\n+            case \"BOTTOM_RIGHT\" -> {\n+                x = windowMaxX;\n+                y = windowMaxY;\n+            }\n+            case \"BOTTOM_LEFT\" -> {\n+                x = windowLoc.x;\n+                y = windowMaxY;\n+            }\n+            default -> throw new IllegalStateException(\"Unexpected value: \"\n+                    + cornerLocation);\n+        }\n+\n+        boolean isTop = cornerLocation.equals(\"TOP_LEFT\")\n+                || cornerLocation.equals(\"TOP_RIGHT\");\n+        boolean isLeft = cornerLocation.equals(\"TOP_LEFT\")\n+                || cornerLocation.equals(\"BOTTOM_LEFT\");\n+\n+        robot.mouseMove(x, y);\n+        for (int i = 0; i < BORDER_THICKNESS - 1; i++) {\n+            int locX = isLeft ? (x + i) : (x - i);\n+            int locY = isTop ? (y + i) : (y - i);\n+            if (Color.RED.equals(robot.getPixelColor(locX, locY))) {\n+                errorLog.append(\"At uiScale: \" + uiScale + \", Red background color\"\n+                        + \" detected at \" + cornerLocation + \" corner.\\n\");\n+                break;\n+            }\n+        }\n+        robot.delay(100);\n+    }\n+\n+    private static void createFrame() {\n+        jFrame = new JFrame(\"Frame with Metal Border\");\n+        jFrame.setSize(SIZE, SIZE);\n+        jFrame.setBackground(Color.RED);\n+        jFrame.getContentPane().setBackground(Color.RED);\n+        jFrame.setLayout(new GridBagLayout());\n+        jFrame.getContentPane().add(scale);\n+        jFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n+        jFrame.setLocation(150, 150);\n+        jFrame.setVisible(true);\n+    }\n+\n+    private static void createDialog() {\n+        jDialog = new JDialog((Frame) null , \"Dialog with Metal Border\");\n+        jDialog.setSize(SIZE, SIZE);\n+        jDialog.setBackground(Color.RED);\n+        jDialog.getContentPane().setBackground(Color.RED);\n+        jDialog.setLayout(new GridBagLayout());\n+        jDialog.getContentPane().add(scale);\n+        jDialog.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n+        jDialog.setLocation(150, 150);\n+        jDialog.setVisible(true);\n+    }\n+\n+    private static void createJInternalFrame() {\n+        jFrame = new JFrame(\"JIF with Metal Border\");\n+        jFrame.setSize(SIZE, SIZE);\n+        jFrame.setLayout(null);\n+        jFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n+\n+        iFrame = new JInternalFrame(\"iframe\", true);\n+        iFrame.setLayout(new GridBagLayout());\n+        iFrame.setBackground(Color.RED);\n+        iFrame.add(scale);\n+        iFrame.setLocation(30, 30);\n+        jFrame.getContentPane().add(iFrame);\n+        iFrame.setSize(INTFRAME_SIZE, INTFRAME_SIZE);\n+        iFrame.setVisible(true);\n+        jFrame.setLocation(150, 150);\n+        jFrame.setVisible(true);\n+    }\n+\n+    private static void saveScreenCapture(String filename) {\n+        MultiResolutionImage mrImage = robot.createMultiResolutionScreenCapture(windowBounds);\n+        List<Image> variants = mrImage.getResolutionVariants();\n+        RenderedImage image = (RenderedImage) variants.get(variants.size() - 1);\n+        try {\n+            ImageIO.write(image, \"png\", new File(filename));\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/plaf\/metal\/MetalBorders\/ScaledMetalBorderTest.java","additions":351,"deletions":0,"binary":false,"changes":351,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.swing.text.Caret;\n+import javax.swing.text.DefaultCaret;\n+\n+\/*\n+ * @test\n+ * @bug 8301989\n+ * @summary Test checks that there is no exception happens\n+ *          when setting blink rate on a javax.swing.DefaultCaret that is not\n+ *          associated with any text component\n+ * @run main SetCaretRateTest\n+ *\/\n+public class SetCaretRateTest {\n+    public static void main(String[] args) {\n+        Caret caret = new DefaultCaret();\n+        caret.setBlinkRate(0);\n+        caret.setBlinkRate(100);\n+        caret.setBlinkRate(0);\n+        caret = new DefaultCaret();\n+        caret.setBlinkRate(100);\n+        caret.setBlinkRate(0);\n+        caret.setBlinkRate(100);\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/text\/DefaultCaret\/SetCaretRateTest.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8301260\n+ * @summary Check that secureValidation system property works correctly\n+ * @library \/test\/lib\n+ * @run main\/othervm -Dorg.jcp.xml.dsig.secureValidation=true SecureValidationSystemProperty\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8301260\n+ * @summary Check that secureValidation system property works correctly\n+ * @library \/test\/lib\n+ * @run main\/othervm -Dorg.jcp.xml.dsig.secureValidation=false SecureValidationSystemProperty\n+ *\/\n+\n+import java.io.File;\n+import javax.xml.crypto.dsig.XMLSignatureException;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.DocumentBuilder;\n+import org.w3c.dom.Document;\n+\n+import jdk.test.lib.security.SecurityUtils;\n+import jdk.test.lib.security.XMLUtils;\n+import static jdk.test.lib.security.XMLUtils.Validator;\n+\n+public class SecureValidationSystemProperty {\n+\n+    private final static String DIR = System.getProperty(\"test.src\", \".\");\n+    private final static String DATA_DIR =\n+        DIR + System.getProperty(\"file.separator\") + \"data\";\n+\n+    public static void main(String[] args) throws Exception{\n+        \/\/ Re-enable sha1 algs. We just want to make sure DSA keys less than\n+        \/\/ 1024 bits are rejected correctly.\n+        SecurityUtils.removeAlgsFromDSigPolicy(\"sha1\");\n+\n+        String prop = System.getProperty(\"org.jcp.xml.dsig.secureValidation\");\n+        if (prop == null) {\n+            throw new Exception(\"Secure validation system property not set\");\n+        }\n+        boolean isSet = Boolean.parseBoolean(prop);\n+\n+        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n+        dbf.setNamespaceAware(true);\n+        Document doc = dbf.newDocumentBuilder()\n+            .parse(new File(DATA_DIR, \"signature-enveloped-dsa-512.xml\"));\n+        Validator validator = XMLUtils.validator();\n+\n+        \/\/ try again and make sure system property supersedes\n+        \/\/ XMLContext property\n+        validator.secureValidation(!isSet);\n+        validate(validator, doc, isSet);\n+    }\n+\n+    private static void validate(Validator validator, Document doc,\n+            boolean isSet) throws Exception {\n+        try {\n+            validator.validate(doc);\n+            if (isSet) {\n+                throw new Exception(\"signature expected to be rejected \" +\n+                    \"because it was signed with a 512-bit DSA key which is \" +\n+                    \"restricted\");\n+            }\n+        } catch (XMLSignatureException e) {\n+            if (!isSet) {\n+                throw new Exception(\"signature not expected to be rejected \" +\n+                    \"because secure validation mode is not enabled\");\n+            } else {\n+                Throwable cause = e.getCause();\n+                if (cause == null || !cause.getMessage().equals(\n+                        \"DSA keys less than 1024 bits are forbidden when \" +\n+                        \"secure validation is enabled\")) {\n+                    throw new Exception(\"signature rejected for wrong reason\", e);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/xml\/crypto\/dsig\/SecureValidationSystemProperty.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?><Envelope xmlns=\"http:\/\/example.org\/envelope\"><Signature xmlns=\"http:\/\/www.w3.org\/2000\/09\/xmldsig#\"><SignedInfo><CanonicalizationMethod Algorithm=\"http:\/\/www.w3.org\/TR\/2001\/REC-xml-c14n-20010315\"\/><SignatureMethod Algorithm=\"http:\/\/www.w3.org\/2000\/09\/xmldsig#dsa-sha1\"\/><Reference URI=\"\"><Transforms><Transform Algorithm=\"http:\/\/www.w3.org\/2000\/09\/xmldsig#enveloped-signature\"\/><\/Transforms><DigestMethod Algorithm=\"http:\/\/www.w3.org\/2000\/09\/xmldsig#sha1\"\/><DigestValue>l73jZE8SFKG5at7i5Yj+q2aNIzU=<\/DigestValue><\/Reference><\/SignedInfo><SignatureValue>RJiGe6of7CxloaPR9yq6Hw5r+aElz72MAVAfKBgpqnQaNFnDp8dNiQ==<\/SignatureValue><KeyInfo><KeyValue><DSAKeyValue><P>\/KaCzo4Syrom78z3EQ5SbbB4sF7ey80etKII864WF64B81uRpH5t9jQTxeEu0ImbzRMqzVDZkVG9\n+xD7nN1kuFw==<\/P><Q>li7dzDacuo67Jg7mtqEm2TRuOMU=<\/Q><G>Z4Rxsnqc9E7pGknFFH2xqaryRPBaQ01khpMdLRQnG541Awtx\/XPaF5Bpsy4pNWMOHCBiNU0Nogps\n+QW5QvnlMpA==<\/G><Y>nBZMgkVdGHADOfd+XQ4x9cirI5pZg1Ly0cQDLgrXpKn4CP8MJwL9HUnVJ1k7OpXdzOyzJSY75T3u\n+vwu1XEEGHg==<\/Y><\/DSAKeyValue><\/KeyValue><\/KeyInfo><\/Signature><\/Envelope>\n","filename":"test\/jdk\/javax\/xml\/crypto\/dsig\/data\/signature-enveloped-dsa-512.xml","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run testng ManyBindings\n+ * @run junit ManyBindings\n@@ -43,2 +43,2 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -46,2 +46,1 @@\n-@Test\n-public class ManyBindings {\n+class ManyBindings {\n@@ -59,1 +58,2 @@\n-    public void testPlatformThread() {\n+    @Test\n+    void testPlatformThread() {\n@@ -66,1 +66,2 @@\n-    public void testVirtualThread() throws Exception {\n+    @Test\n+    void testVirtualThread() throws Exception {\n@@ -146,1 +147,1 @@\n-                assertEquals(key.get(), value);\n+                assertEquals(value, key.get());\n@@ -160,1 +161,1 @@\n-                assertEquals(key.get(), value);\n+                assertEquals(value, key.get());\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/ScopedValue\/ManyBindings.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng ScopeValueAPI\n+ * @run junit ScopeValueAPI\n@@ -38,0 +38,1 @@\n+import java.util.stream.Stream;\n@@ -39,3 +40,4 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -43,2 +45,1 @@\n-@Test\n-public class ScopeValueAPI {\n+class ScopeValueAPI {\n@@ -46,6 +47,2 @@\n-    @DataProvider\n-    public Object[][] factories() {\n-        return new Object[][] {\n-                { Thread.ofPlatform().factory() },\n-                { Thread.ofVirtual().factory() },\n-        };\n+    private static Stream<ThreadFactory> factories() {\n+        return Stream.of(Thread.ofPlatform().factory(), Thread.ofVirtual().factory());\n@@ -57,2 +54,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testRun(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testRun(ThreadFactory factory) throws Exception {\n@@ -70,2 +68,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testRunThrows(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testRunThrows(ThreadFactory factory) throws Exception {\n@@ -84,2 +83,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testCall(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testCall(ThreadFactory factory) throws Exception {\n@@ -89,1 +89,1 @@\n-            assertEquals(result, \"duke\");\n+            assertEquals(\"duke\", result);\n@@ -96,2 +96,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testCallThrows(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testCallThrows(ThreadFactory factory) throws Exception {\n@@ -110,2 +111,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testGet(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testGet(ThreadFactory factory) throws Exception {\n@@ -120,1 +122,1 @@\n-                assertEquals(name1.get(), \"duke\");\n+                assertEquals(\"duke\", name1.get());\n@@ -129,1 +131,1 @@\n-                assertEquals(name1.get(), \"duke\");\n+                assertEquals(\"duke\", name1.get());\n@@ -141,2 +143,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testIsBound(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testIsBound(ThreadFactory factory) throws Exception {\n@@ -171,2 +174,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testOrElse(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testOrElse(ThreadFactory factory) throws Exception {\n@@ -175,2 +179,2 @@\n-            assertTrue(name.orElse(null) == null);\n-            assertEquals(name.orElse(\"default\"), \"default\");\n+            assertNull(name.orElse(null));\n+            assertEquals(\"default\", name.orElse(\"default\"));\n@@ -180,2 +184,2 @@\n-                assertEquals(name.orElse(null), \"duke\");\n-                assertEquals(name.orElse(\"default\"), \"duke\");\n+                assertEquals(\"duke\", name.orElse(null));\n+                assertEquals(\"duke\", name.orElse(\"default\"));\n@@ -186,2 +190,2 @@\n-                assertEquals(name.orElse(null), \"duke\");\n-                assertEquals(name.orElse(\"default\"), \"duke\");\n+                assertEquals(\"duke\", name.orElse(null));\n+                assertEquals(\"duke\", name.orElse(\"default\"));\n@@ -196,2 +200,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testOrElseThrow(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testOrElseThrow(ThreadFactory factory) throws Exception {\n@@ -205,1 +210,1 @@\n-                assertEquals(name.orElseThrow(FooException::new), \"duke\");\n+                assertEquals(\"duke\", name.orElseThrow(FooException::new));\n@@ -210,1 +215,1 @@\n-                assertEquals(name.orElseThrow(FooException::new), \"duke\");\n+                assertEquals(\"duke\", name.orElseThrow(FooException::new));\n@@ -219,2 +224,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testTwoBindings(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testTwoBindings(ThreadFactory factory) throws Exception {\n@@ -229,2 +235,2 @@\n-                assertEquals(name.get(), \"duke\");\n-                assertEquals((int) age.get(), 100);\n+                assertEquals(\"duke\", name.get());\n+                assertEquals(100, (int) age.get());\n@@ -239,2 +245,2 @@\n-                assertEquals(name.get(), \"duke\");\n-                assertEquals((int) age.get(), 100);\n+                assertEquals(\"duke\", name.get());\n+                assertEquals(100, (int) age.get());\n@@ -252,2 +258,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testRebinding(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testRebinding(ThreadFactory factory) throws Exception {\n@@ -260,1 +267,1 @@\n-                assertEquals(name.get(), \"duke\");\n+                assertEquals(\"duke\", name.get());\n@@ -264,1 +271,1 @@\n-                    assertTrue(\"duchess\".equals(name.get()));\n+                    assertEquals(\"duchess\", name.get());\n@@ -268,1 +275,1 @@\n-                assertEquals(name.get(), \"duke\");\n+                assertEquals(\"duke\", name.get());\n@@ -275,1 +282,1 @@\n-                assertEquals(name.get(), \"duke\");\n+                assertEquals(\"duke\", name.get());\n@@ -279,1 +286,1 @@\n-                    assertTrue(\"duchess\".equals(name.get()));\n+                    assertEquals(\"duchess\", name.get());\n@@ -284,1 +291,1 @@\n-                assertEquals(name.get(), \"duke\");\n+                assertEquals(\"duke\", name.get());\n@@ -294,2 +301,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testRebindingFromNull(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testRebindingFromNull(ThreadFactory factory) throws Exception {\n@@ -302,1 +310,1 @@\n-                assertEquals(name.get(), null);\n+                assertNull(name.get());\n@@ -310,1 +318,1 @@\n-                assertTrue(name.get() == null);\n+                assertNull(name.get());\n@@ -317,1 +325,1 @@\n-                assertEquals(name.get(), null);\n+                assertNull(name.get());\n@@ -326,1 +334,1 @@\n-                assertTrue(name.get() == null);\n+                assertNull(name.get());\n@@ -336,2 +344,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testRebindingToNull(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testRebindingToNull(ThreadFactory factory) throws Exception {\n@@ -344,1 +353,1 @@\n-                assertEquals(name.get(), \"duke\");\n+                assertEquals(\"duke\", name.get());\n@@ -348,1 +357,1 @@\n-                    assertTrue(name.get() == null);\n+                    assertNull(name.get());\n@@ -352,1 +361,1 @@\n-                assertEquals(name.get(), \"duke\");\n+                assertEquals(\"duke\", name.get());\n@@ -359,1 +368,1 @@\n-                assertEquals(name.get(), \"duke\");\n+                assertEquals(\"duke\", name.get());\n@@ -363,1 +372,1 @@\n-                    assertTrue(name.get() == null);\n+                    assertNull(name.get());\n@@ -368,1 +377,1 @@\n-                assertEquals(name.get(), \"duke\");\n+                assertEquals(\"duke\", name.get());\n@@ -378,2 +387,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testCarrierGet(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testCarrierGet(ThreadFactory factory) throws Exception {\n@@ -386,1 +396,1 @@\n-            assertEquals(carrier1.get(name), \"duke\");\n+            assertEquals(\"duke\", carrier1.get(name));\n@@ -391,2 +401,2 @@\n-            assertEquals(carrier2.get(name), \"duke\");\n-            assertEquals((int) carrier2.get(age), 20);\n+            assertEquals(\"duke\", carrier2.get(name));\n+            assertEquals(20, (int) carrier2.get(age));\n@@ -399,1 +409,2 @@\n-    public void testNullPointerException() {\n+    @Test\n+    void testNullPointerException() {\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/ScopedValue\/ScopeValueAPI.java","additions":85,"deletions":74,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng\/othervm PreviewFeaturesNotEnabled\n+ * @run junit\/othervm PreviewFeaturesNotEnabled\n@@ -33,2 +33,2 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -36,1 +36,1 @@\n-public class PreviewFeaturesNotEnabled {\n+class PreviewFeaturesNotEnabled {\n@@ -41,1 +41,1 @@\n-    public void testUnsupportedOperationException() {\n+    void testUnsupportedOperationException() {\n@@ -49,1 +49,1 @@\n-    public void testNoUnsupportedOperationException() {\n+    void testNoUnsupportedOperationException() {\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/StructuredTaskScope\/PreviewFeaturesNotEnabled.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run testng\/othervm -DthreadFactory=platform StructuredTaskScopeTest\n+ * @run junit\/othervm -DthreadFactory=platform StructuredTaskScopeTest\n@@ -37,1 +37,1 @@\n- * @run testng\/othervm -DthreadFactory=virtual StructuredTaskScopeTest\n+ * @run junit\/othervm -DthreadFactory=virtual StructuredTaskScopeTest\n@@ -68,18 +68,15 @@\n-import org.testng.annotations.AfterClass;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n-public class StructuredTaskScopeTest {\n-    private ScheduledExecutorService scheduler;\n-    private Object[][] threadFactories;\n-\n-    @BeforeClass\n-    public void setUp() throws Exception {\n-        ThreadFactory factory = (task) -> {\n-            Thread thread = new Thread(task);\n-            thread.setDaemon(true);\n-            return thread;\n-        };\n-        this.scheduler = Executors.newSingleThreadScheduledExecutor(factory);\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class StructuredTaskScopeTest {\n+    private static ScheduledExecutorService scheduler;\n+    private static List<ThreadFactory> threadFactories;\n+\n+    @BeforeAll\n+    static void setup() throws Exception {\n+        scheduler = Executors.newSingleThreadScheduledExecutor();\n@@ -95,3 +92,1 @@\n-        this.threadFactories = list.stream()\n-                .map(f -> new Object[] { f })\n-                .toArray(Object[][]::new);\n+        threadFactories = list;\n@@ -100,2 +95,2 @@\n-    @AfterClass\n-    public void tearDown() {\n+    @AfterAll\n+    static void shutdown() {\n@@ -105,6 +100,2 @@\n-    \/**\n-     * A provider of ThreadFactory objects for tests.\n-     *\/\n-    @DataProvider\n-    public Object[][] factories() {\n-        return threadFactories;\n+    private static Stream<ThreadFactory> factories() {\n+        return threadFactories.stream();\n@@ -116,2 +107,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testFork1(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testFork1(ThreadFactory factory) throws Exception {\n@@ -131,2 +123,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testFork2(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testFork2(ThreadFactory factory) throws Exception {\n@@ -150,2 +143,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testForkConfined(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testForkConfined(ThreadFactory factory) throws Exception {\n@@ -160,1 +154,1 @@\n-            Throwable ex = expectThrows(ExecutionException.class, future1::get);\n+            Throwable ex = assertThrows(ExecutionException.class, future1::get);\n@@ -169,1 +163,1 @@\n-            assertTrue(future2.resultNow() == null);\n+            assertNull(future2.resultNow());\n@@ -177,1 +171,1 @@\n-                ex = expectThrows(ExecutionException.class, future::get);\n+                ex = assertThrows(ExecutionException.class, future::get);\n@@ -189,2 +183,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testForkAfterShutdown(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testForkAfterShutdown(ThreadFactory factory) throws Exception {\n@@ -207,2 +202,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testForkAfterClose(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testForkAfterClose(ThreadFactory factory) throws Exception {\n@@ -220,1 +216,1 @@\n-    public void testForkReject() throws Exception {\n+    void testForkReject() throws Exception {\n@@ -258,2 +254,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testHandleComplete1(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testHandleComplete1(ThreadFactory factory) throws Exception {\n@@ -278,1 +275,1 @@\n-            assertEquals(futures, Set.of(future1, future2, future3));\n+            assertEquals(Set.of(future1, future2, future3), futures);\n@@ -285,2 +282,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testHandleComplete2(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testHandleComplete2(ThreadFactory factory) throws Exception {\n@@ -288,1 +286,0 @@\n-\n@@ -325,1 +322,1 @@\n-    public void testJoinWithNoThreads() throws Exception {\n+    void testJoinWithNoThreads() throws Exception {\n@@ -334,2 +331,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testJoinWithThreads(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testJoinWithThreads(ThreadFactory factory) throws Exception {\n@@ -342,1 +340,1 @@\n-            assertEquals(future.resultNow(), \"foo\");\n+            assertEquals(\"foo\", future.resultNow());\n@@ -349,2 +347,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testJoinConfined(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testJoinConfined(ThreadFactory factory) throws Exception {\n@@ -357,1 +356,1 @@\n-            Throwable ex = expectThrows(ExecutionException.class, future1::get);\n+            Throwable ex = assertThrows(ExecutionException.class, future1::get);\n@@ -366,1 +365,1 @@\n-                ex = expectThrows(ExecutionException.class, future2::get);\n+                ex = assertThrows(ExecutionException.class, future2::get);\n@@ -377,2 +376,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testInterruptJoin1(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testInterruptJoin1(ThreadFactory factory) throws Exception {\n@@ -380,0 +380,2 @@\n+            var latch = new CountDownLatch(1);\n+\n@@ -381,1 +383,1 @@\n-                Thread.sleep(Duration.ofMillis(100));\n+                latch.await();\n@@ -392,0 +394,3 @@\n+            } finally {\n+                \/\/ let task continue\n+                latch.countDown();\n@@ -396,1 +401,1 @@\n-            assertEquals(future.resultNow(), \"foo\");\n+            assertEquals(\"foo\", future.resultNow());\n@@ -403,2 +408,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testInterruptJoin2(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testInterruptJoin2(ThreadFactory factory) throws Exception {\n@@ -406,0 +412,2 @@\n+            var latch = new CountDownLatch(1);\n+\n@@ -407,1 +415,1 @@\n-                Thread.sleep(Duration.ofSeconds(3));\n+                latch.await();\n@@ -418,0 +426,3 @@\n+            } finally {\n+                \/\/ let task continue\n+                latch.countDown();\n@@ -422,1 +433,1 @@\n-            assertEquals(future.resultNow(), \"foo\");\n+            assertEquals(\"foo\", future.resultNow());\n@@ -429,2 +440,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testJoinWithShutdown1(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testJoinWithShutdown1(ThreadFactory factory) throws Exception {\n@@ -447,2 +459,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testJoinWithShutdown2(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testJoinWithShutdown2(ThreadFactory factory) throws Exception {\n@@ -482,1 +495,1 @@\n-    public void testJoinAfterShutdown() throws Exception {\n+    void testJoinAfterShutdown() throws Exception {\n@@ -493,1 +506,1 @@\n-    public void testJoinAfterClose() throws Exception {\n+    void testJoinAfterClose() throws Exception {\n@@ -505,2 +518,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testJoinUntil1(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testJoinUntil1(ThreadFactory factory) throws Exception {\n@@ -517,1 +531,2 @@\n-            assertTrue(future.isDone() && future.resultNow() == null);\n+            assertTrue(future.isDone());\n+            assertNull(future.resultNow());\n@@ -525,2 +540,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testJoinUntil2(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testJoinUntil2(ThreadFactory factory) throws Exception {\n@@ -548,2 +564,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testJoinUntil3(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testJoinUntil3(ThreadFactory factory) throws Exception {\n@@ -576,2 +593,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testJoinUntil4(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testJoinUntil4(ThreadFactory factory) throws Exception {\n@@ -613,2 +631,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testInterruptJoinUntil1(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testInterruptJoinUntil1(ThreadFactory factory) throws Exception {\n@@ -616,0 +635,2 @@\n+            var latch = new CountDownLatch(1);\n+\n@@ -617,1 +638,1 @@\n-                Thread.sleep(Duration.ofMillis(100));\n+                latch.await();\n@@ -624,1 +645,1 @@\n-                scope.joinUntil(Instant.now().plusSeconds(10));\n+                scope.joinUntil(Instant.now().plusSeconds(30));\n@@ -628,0 +649,3 @@\n+            } finally {\n+                \/\/ let task continue\n+                latch.countDown();\n@@ -632,1 +656,1 @@\n-            assertEquals(future.resultNow(), \"foo\");\n+            assertEquals(\"foo\", future.resultNow());\n@@ -639,2 +663,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testInterruptJoinUntil2(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testInterruptJoinUntil2(ThreadFactory factory) throws Exception {\n@@ -642,0 +667,2 @@\n+            var latch = new CountDownLatch(1);\n+\n@@ -643,1 +670,1 @@\n-                Thread.sleep(Duration.ofSeconds(3));\n+                latch.await();\n@@ -654,0 +681,3 @@\n+            } finally {\n+                \/\/ let task continue\n+                latch.countDown();\n@@ -658,1 +688,1 @@\n-            assertEquals(future.resultNow(), \"foo\");\n+            assertEquals(\"foo\", future.resultNow());\n@@ -665,1 +695,2 @@\n-    public void testShutdownAfterClose() throws Exception {\n+    @Test\n+    void testShutdownAfterClose() throws Exception {\n@@ -676,2 +707,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testShutdownConfined(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testShutdownConfined(ThreadFactory factory) throws Exception {\n@@ -687,1 +719,1 @@\n-                Throwable ex = expectThrows(ExecutionException.class, future::get);\n+                Throwable ex = assertThrows(ExecutionException.class, future::get);\n@@ -696,1 +728,1 @@\n-            Throwable ex = expectThrows(ExecutionException.class, future1::get);\n+            Throwable ex = assertThrows(ExecutionException.class, future1::get);\n@@ -705,1 +737,1 @@\n-            assertTrue(future2.resultNow() == null);\n+            assertNull(future2.resultNow());\n@@ -715,1 +747,2 @@\n-    public void testCloseWithoutJoin1() {\n+    @Test\n+    void testCloseWithoutJoin1() {\n@@ -724,2 +757,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testCloseWithoutJoin2(ThreadFactory factory) {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testCloseWithoutJoin2(ThreadFactory factory) {\n@@ -739,2 +773,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testCloseWithoutJoin3(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testCloseWithoutJoin3(ThreadFactory factory) throws Exception {\n@@ -757,2 +792,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testCloseConfined(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testCloseConfined(ThreadFactory factory) throws Exception {\n@@ -765,1 +801,1 @@\n-            Throwable ex = expectThrows(ExecutionException.class, future1::get);\n+            Throwable ex = assertThrows(ExecutionException.class, future1::get);\n@@ -774,1 +810,1 @@\n-                ex = expectThrows(ExecutionException.class, future2::get);\n+                ex = assertThrows(ExecutionException.class, future2::get);\n@@ -785,2 +821,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testInterruptClose1(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testInterruptClose1(ThreadFactory factory) throws Exception {\n@@ -821,2 +858,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testInterruptClose2(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testInterruptClose2(ThreadFactory factory) throws Exception {\n@@ -857,1 +895,1 @@\n-    public void testStructureViolation1() throws Exception {\n+    void testStructureViolation1() throws Exception {\n@@ -884,2 +922,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testFuture1(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testFuture1(ThreadFactory factory) throws Exception {\n@@ -893,1 +932,1 @@\n-            assertEquals(future.get(), \"foo\");\n+            assertEquals(\"foo\", future.get());\n@@ -895,1 +934,1 @@\n-            assertEquals(future.resultNow(), \"foo\");\n+            assertEquals(\"foo\", future.resultNow());\n@@ -904,2 +943,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testFuture2(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testFuture2(ThreadFactory factory) throws Exception {\n@@ -913,1 +953,1 @@\n-            Throwable ex = expectThrows(ExecutionException.class, future::get);\n+            Throwable ex = assertThrows(ExecutionException.class, future::get);\n@@ -925,2 +965,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testFuture3(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testFuture3(ThreadFactory factory) throws Exception {\n@@ -951,2 +992,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testFutureWithShutdown(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testFutureWithShutdown(ThreadFactory factory) throws Exception {\n@@ -988,2 +1030,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testFutureCancelConfined(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testFutureCancelConfined(ThreadFactory factory) throws Exception {\n@@ -1002,1 +1045,1 @@\n-                Throwable ex = expectThrows(ExecutionException.class, future2::get);\n+                Throwable ex = assertThrows(ExecutionException.class, future2::get);\n@@ -1015,1 +1058,1 @@\n-    public void testToString() throws Exception {\n+    void testToString() throws Exception {\n@@ -1036,1 +1079,1 @@\n-    public void testNulls() throws Exception {\n+    void testNulls() throws Exception {\n@@ -1062,1 +1105,1 @@\n-    public void testShutdownOnSuccess1() throws Exception {\n+    void testShutdownOnSuccess1() throws Exception {\n@@ -1073,1 +1116,1 @@\n-    public void testShutdownOnSuccess2() throws Exception {\n+    void testShutdownOnSuccess2() throws Exception {\n@@ -1082,2 +1125,2 @@\n-            assertEquals(scope.result(), \"foo\");\n-            assertEquals(scope.result(e -> null), \"foo\");\n+            assertEquals(\"foo\", scope.result());\n+            assertEquals(\"foo\", scope.result(e -> null));\n@@ -1091,1 +1134,1 @@\n-    public void testShutdownOnSuccess3() throws Exception {\n+    void testShutdownOnSuccess3() throws Exception {\n@@ -1099,2 +1142,2 @@\n-            assertEquals(scope.result(), \"foo\");\n-            assertEquals(scope.result(e -> null), \"foo\");\n+            assertEquals(\"foo\", scope.result());\n+            assertEquals(\"foo\", scope.result(e -> null));\n@@ -1108,1 +1151,1 @@\n-    public void testShutdownOnSuccess4() throws Exception {\n+    void testShutdownOnSuccess4() throws Exception {\n@@ -1115,1 +1158,1 @@\n-            Throwable ex = expectThrows(ExecutionException.class, () -> scope.result());\n+            Throwable ex = assertThrows(ExecutionException.class, () -> scope.result());\n@@ -1118,1 +1161,1 @@\n-            ex = expectThrows(FooException.class, () -> scope.result(e -> new FooException(e)));\n+            ex = assertThrows(FooException.class, () -> scope.result(e -> new FooException(e)));\n@@ -1127,1 +1170,1 @@\n-    public void testShutdownOnSuccess5() throws Exception {\n+    void testShutdownOnSuccess5() throws Exception {\n@@ -1140,1 +1183,1 @@\n-            Throwable ex = expectThrows(FooException.class,\n+            Throwable ex = assertThrows(FooException.class,\n@@ -1150,1 +1193,1 @@\n-    public void testShutdownOnFailure1() throws Throwable {\n+    void testShutdownOnFailure1() throws Throwable {\n@@ -1162,1 +1205,1 @@\n-    public void testShutdownOnFailure2() throws Throwable {\n+    void testShutdownOnFailure2() throws Throwable {\n@@ -1179,1 +1222,1 @@\n-    public void testShutdownOnFailure3() throws Throwable {\n+    void testShutdownOnFailure3() throws Throwable {\n@@ -1190,1 +1233,1 @@\n-            ex = expectThrows(ExecutionException.class, () -> scope.throwIfFailed());\n+            ex = assertThrows(ExecutionException.class, () -> scope.throwIfFailed());\n@@ -1193,1 +1236,1 @@\n-            ex = expectThrows(FooException.class,\n+            ex = assertThrows(FooException.class,\n@@ -1203,1 +1246,1 @@\n-    public void testShutdownOnFailure4() throws Throwable {\n+    void testShutdownOnFailure4() throws Throwable {\n@@ -1219,1 +1262,1 @@\n-            ex = expectThrows(FooException.class,\n+            ex = assertThrows(FooException.class,\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/StructuredTaskScope\/StructuredTaskScopeTest.java","additions":190,"deletions":147,"binary":false,"changes":337,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run testng\/othervm StructuredThreadDumpTest\n+ * @run junit\/othervm StructuredThreadDumpTest\n@@ -46,2 +46,2 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -49,1 +49,1 @@\n-public class StructuredThreadDumpTest {\n+class StructuredThreadDumpTest {\n@@ -56,1 +56,1 @@\n-    public void testTree() throws Exception {\n+    void testTree() throws Exception {\n@@ -98,1 +98,1 @@\n-    public void testNested() throws Exception {\n+    void testNested() throws Exception {\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/StructuredTaskScope\/StructuredThreadDumpTest.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng WithScopedValue\n+ * @run junit WithScopedValue\n@@ -38,0 +38,1 @@\n+import java.util.stream.Stream;\n@@ -39,3 +40,4 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -43,2 +45,1 @@\n-@Test\n-public class WithScopedValue {\n+class WithScopedValue {\n@@ -46,6 +47,2 @@\n-    @DataProvider\n-    public Object[][] factories() {\n-        return new Object[][] {\n-                { Thread.ofPlatform().factory() },\n-                { Thread.ofVirtual().factory() },\n-        };\n+    private static Stream<ThreadFactory> factories() {\n+        return Stream.of(Thread.ofPlatform().factory(), Thread.ofVirtual().factory());\n@@ -57,2 +54,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testForkInheritsScopedValue1(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testForkInheritsScopedValue1(ThreadFactory factory) throws Exception {\n@@ -75,2 +73,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testForkInheritsScopedValue2(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testForkInheritsScopedValue2(ThreadFactory factory) throws Exception {\n@@ -99,2 +98,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testForkInheritsScopedValue3(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testForkInheritsScopedValue3(ThreadFactory factory) throws Exception {\n@@ -131,1 +131,2 @@\n-    public void testStructureViolation1() throws Exception {\n+    @Test\n+    void testStructureViolation1() throws Exception {\n@@ -167,1 +168,2 @@\n-    public void testStructureViolation2() throws Exception {\n+    @Test\n+    void testStructureViolation2() throws Exception {\n@@ -179,1 +181,2 @@\n-    public void testStructureViolation3() throws Exception {\n+    @Test\n+    void testStructureViolation3() throws Exception {\n@@ -192,1 +195,2 @@\n-    public void testStructureViolation4() throws Exception {\n+    @Test\n+    void testStructureViolation4() throws Exception {\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/StructuredTaskScope\/WithScopedValue.java","additions":27,"deletions":23,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng\/othervm -DthreadFactory=platform ThreadFlockTest\n+ * @run junit\/othervm -DthreadFactory=platform ThreadFlockTest\n@@ -36,1 +36,1 @@\n- * @run testng\/othervm -DthreadFactory=virtual ThreadFlockTest\n+ * @run junit\/othervm -DthreadFactory=virtual ThreadFlockTest\n@@ -46,0 +46,1 @@\n+import java.util.stream.Stream;\n@@ -48,18 +49,14 @@\n-import org.testng.annotations.AfterClass;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n-public class ThreadFlockTest {\n-    private ScheduledExecutorService scheduler;\n-    private Object[][] threadFactories;\n-\n-    @BeforeClass\n-    public void setUp() throws Exception {\n-        ThreadFactory factory = (task) -> {\n-            Thread thread = new Thread(task);\n-            thread.setDaemon(true);\n-            return thread;\n-        };\n-        this.scheduler = Executors.newSingleThreadScheduledExecutor(factory);\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class ThreadFlockTest {\n+    private static ScheduledExecutorService scheduler;\n+    private static List<ThreadFactory> threadFactories;\n+\n+    @BeforeAll\n+    static void setup() throws Exception {\n+        scheduler = Executors.newSingleThreadScheduledExecutor();\n@@ -75,3 +72,1 @@\n-        this.threadFactories = list.stream()\n-                .map(f -> new Object[] { f })\n-                .toArray(Object[][]::new);\n+        threadFactories = list;\n@@ -80,2 +75,2 @@\n-    @AfterClass\n-    public void tearDown() {\n+    @AfterAll\n+    static void shutdown() {\n@@ -85,3 +80,2 @@\n-    @DataProvider(name = \"factories\")\n-    public Object[][] factories() {\n-        return threadFactories;\n+    private static Stream<ThreadFactory> factories() {\n+        return threadFactories.stream();\n@@ -94,1 +88,1 @@\n-    public void testName() {\n+    void testName() {\n@@ -96,1 +90,1 @@\n-            assertEquals(flock.name(), null);\n+            assertNull(flock.name());\n@@ -98,1 +92,1 @@\n-            assertEquals(flock.name(), null);  \/\/ after close\n+            assertNull(flock.name());  \/\/ after close\n@@ -101,1 +95,1 @@\n-            assertEquals(flock.name(), \"fetcher\");\n+            assertEquals(\"fetcher\", flock.name());\n@@ -103,1 +97,1 @@\n-            assertEquals(flock.name(), \"fetcher\");  \/\/ after close\n+            assertEquals(\"fetcher\", flock.name());  \/\/ after close\n@@ -111,1 +105,1 @@\n-    public void testOwner() {\n+    void testOwner() {\n@@ -123,1 +117,1 @@\n-    public void testState() {\n+    void testState() {\n@@ -144,2 +138,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testThreads(ThreadFactory factory) {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testThreads(ThreadFactory factory) {\n@@ -169,1 +164,1 @@\n-            assertEquals(threads, flock.threads().collect(Collectors.toSet()));\n+            assertEquals(flock.threads().collect(Collectors.toSet()), threads);\n@@ -176,1 +171,1 @@\n-        assertTrue(exception.get() == null);\n+        assertNull(exception.get());\n@@ -182,2 +177,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testContainsThread1(ThreadFactory factory) {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testContainsThread1(ThreadFactory factory) {\n@@ -225,2 +221,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testContainsThread2(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testContainsThread2(ThreadFactory factory) throws Exception {\n@@ -279,2 +276,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testStart(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testStart(ThreadFactory factory) throws Exception {\n@@ -293,2 +291,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testStartAfterShutdown(ThreadFactory factory) {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testStartAfterShutdown(ThreadFactory factory) {\n@@ -298,1 +297,1 @@\n-            expectThrows(IllegalStateException.class, () -> flock.start(thread));\n+            assertThrows(IllegalStateException.class, () -> flock.start(thread));\n@@ -305,2 +304,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testStartAfterClose(ThreadFactory factory) {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testStartAfterClose(ThreadFactory factory) {\n@@ -310,1 +310,1 @@\n-        expectThrows(IllegalStateException.class, () -> flock.start(thread));\n+        assertThrows(IllegalStateException.class, () -> flock.start(thread));\n@@ -317,2 +317,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testStartAfterStarted(ThreadFactory factory) {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testStartAfterStarted(ThreadFactory factory) {\n@@ -322,1 +323,1 @@\n-            expectThrows(IllegalThreadStateException.class, () -> flock.start(thread));\n+            assertThrows(IllegalThreadStateException.class, () -> flock.start(thread));\n@@ -329,2 +330,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testStartConfined(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testStartConfined(ThreadFactory factory) throws Exception {\n@@ -373,1 +375,1 @@\n-            assertTrue(cause == null);\n+            assertNull(cause);\n@@ -383,1 +385,1 @@\n-    public void testAwaitAllWithNoThreads() throws Exception {\n+    void testAwaitAllWithNoThreads() throws Exception {\n@@ -393,2 +395,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testAwaitAllWithThreads(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testAwaitAllWithThreads(ThreadFactory factory) throws Exception {\n@@ -413,2 +416,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testAwaitAllWithTimeout1(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testAwaitAllWithTimeout1(ThreadFactory factory) throws Exception {\n@@ -434,2 +438,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testAwaitAllWithTimeout2(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testAwaitAllWithTimeout2(ThreadFactory factory) throws Exception {\n@@ -437,0 +442,2 @@\n+            var latch = new CountDownLatch(1);\n+\n@@ -439,1 +446,1 @@\n-                    Thread.sleep(Duration.ofSeconds(30));\n+                    latch.await();\n@@ -454,1 +461,1 @@\n-                thread.interrupt();\n+                latch.countDown();\n@@ -462,2 +469,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testAwaitAllWithTimeout3(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testAwaitAllWithTimeout3(ThreadFactory factory) throws Exception {\n@@ -465,0 +473,2 @@\n+            var latch = new CountDownLatch(1);\n+\n@@ -467,1 +477,1 @@\n-                    Thread.sleep(Duration.ofSeconds(30));\n+                    latch.await();\n@@ -481,1 +491,1 @@\n-                thread.interrupt();\n+                latch.countDown();\n@@ -492,2 +502,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testAwaitAllWithTimeout4(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testAwaitAllWithTimeout4(ThreadFactory factory) throws Exception {\n@@ -495,0 +506,2 @@\n+            var latch = new CountDownLatch(1);\n+\n@@ -497,1 +510,1 @@\n-                    Thread.sleep(Duration.ofSeconds(30));\n+                    latch.await();\n@@ -513,1 +526,1 @@\n-                thread.interrupt();\n+                latch.countDown();\n@@ -524,2 +537,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testInterruptAwaitAll1(ThreadFactory factory) {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testInterruptAwaitAll1(ThreadFactory factory) {\n@@ -571,1 +585,1 @@\n-        assertTrue(exception.get() == null);\n+        assertNull(exception.get());\n@@ -577,2 +591,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testInterruptAwaitAll2(ThreadFactory factory) {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testInterruptAwaitAll2(ThreadFactory factory) {\n@@ -622,1 +637,1 @@\n-        assertTrue(exception.get() == null);\n+        assertNull(exception.get());\n@@ -629,1 +644,1 @@\n-    public void testAwaitAfterClose() throws Exception {\n+    void testAwaitAfterClose() throws Exception {\n@@ -639,2 +654,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testAwaitAllConfined(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testAwaitAllConfined(ThreadFactory factory) throws Exception {\n@@ -679,2 +695,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testWakeupAwaitAll1(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testWakeupAwaitAll1(ThreadFactory factory) throws Exception {\n@@ -707,2 +724,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testWakeupAwaitAll2(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testWakeupAwaitAll2(ThreadFactory factory) throws Exception {\n@@ -740,2 +758,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testWakeupConfined(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testWakeupConfined(ThreadFactory factory) throws Exception {\n@@ -775,1 +794,1 @@\n-            assertTrue(cause == null);\n+            assertNull(cause);\n@@ -785,1 +804,1 @@\n-    public void testCloseWithNoThreads() {\n+    void testCloseWithNoThreads() {\n@@ -795,2 +814,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testCloseWithThreads(ThreadFactory factory) {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testCloseWithThreads(ThreadFactory factory) {\n@@ -814,1 +834,1 @@\n-        assertTrue(exception.get() == null); \/\/ no exception thrown\n+        assertNull(exception.get()); \/\/ no exception thrown\n@@ -821,1 +841,1 @@\n-    public void testCloseAfterClose() {\n+    void testCloseAfterClose() {\n@@ -832,2 +852,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testCloseConfined(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testCloseConfined(ThreadFactory factory) throws Exception {\n@@ -872,2 +893,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testInterruptClose1(ThreadFactory factory) {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testInterruptClose1(ThreadFactory factory) {\n@@ -889,1 +911,1 @@\n-        assertTrue(exception.get() == null);\n+        assertNull(exception.get());\n@@ -895,2 +917,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testInterruptClose2(ThreadFactory factory) {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testInterruptClose2(ThreadFactory factory) {\n@@ -912,1 +935,1 @@\n-        assertTrue(exception.get() == null);\n+        assertNull(exception.get());\n@@ -918,2 +941,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testShutdownConfined(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testShutdownConfined(ThreadFactory factory) throws Exception {\n@@ -961,1 +985,1 @@\n-            assertTrue(cause == null);\n+            assertNull(cause);\n@@ -971,1 +995,1 @@\n-    public void testStructureViolation() {\n+    void testStructureViolation() {\n@@ -989,2 +1013,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testThreadExitWithOpenFlock(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testThreadExitWithOpenFlock(ThreadFactory factory) throws Exception {\n@@ -1020,1 +1045,1 @@\n-    public void testToString() {\n+    void testToString() {\n@@ -1030,1 +1055,1 @@\n-    public void testNulls() {\n+    void testNulls() {\n@@ -1032,3 +1057,3 @@\n-            expectThrows(NullPointerException.class, () -> flock.start(null));\n-            expectThrows(NullPointerException.class, () -> flock.awaitAll(null));\n-            expectThrows(NullPointerException.class, () -> flock.containsThread(null));\n+            assertThrows(NullPointerException.class, () -> flock.start(null));\n+            assertThrows(NullPointerException.class, () -> flock.awaitAll(null));\n+            assertThrows(NullPointerException.class, () -> flock.containsThread(null));\n","filename":"test\/jdk\/jdk\/internal\/misc\/ThreadFlock\/ThreadFlockTest.java","additions":140,"deletions":115,"binary":false,"changes":255,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run testng WithScopedValue\n+ * @run junit WithScopedValue\n@@ -36,1 +36,0 @@\n-import java.util.concurrent.Executors;\n@@ -39,0 +38,1 @@\n+import java.util.stream.Stream;\n@@ -40,15 +40,9 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n-@Test\n-public class WithScopedValue {\n-\n-    @DataProvider(name = \"factories\")\n-    public Object[][] factories() {\n-        var defaultThreadFactory = Executors.defaultThreadFactory();\n-        var virtualThreadFactory = Thread.ofVirtual().factory();\n-        return new Object[][]{\n-                { defaultThreadFactory, },\n-                { virtualThreadFactory, },\n-        };\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class WithScopedValue {\n+\n+    private static Stream<ThreadFactory> factories() {\n+        return Stream.of(Thread.ofPlatform().factory(), Thread.ofVirtual().factory());\n@@ -60,2 +54,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testInheritsScopedValue(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testInheritsScopedValue(ThreadFactory factory) throws Exception {\n@@ -74,1 +69,1 @@\n-        assertEquals(value, \"duke\");\n+        assertEquals(\"duke\", value);\n@@ -80,1 +75,2 @@\n-    public void testStructureViolation1() {\n+    @Test\n+    void testStructureViolation1() {\n@@ -102,1 +98,2 @@\n-    public void testStructureViolation2() {\n+    @Test\n+    void testStructureViolation2() {\n@@ -133,1 +130,2 @@\n-    public void testStructureViolation3() {\n+    @Test\n+    void testStructureViolation3() {\n@@ -164,1 +162,2 @@\n-    public void testStructureViolation4() {\n+    @Test\n+    void testStructureViolation4() {\n@@ -194,2 +193,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testStructureViolation5(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testStructureViolation5(ThreadFactory factory) throws Exception {\n@@ -200,1 +200,1 @@\n-                expectThrows(StructureViolationException.class, () -> flock.start(thread));\n+                assertThrows(StructureViolationException.class, () -> flock.start(thread));\n@@ -208,2 +208,3 @@\n-    @Test(dataProvider = \"factories\")\n-    public void testStructureViolation6(ThreadFactory factory) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testStructureViolation6(ThreadFactory factory) throws Exception {\n@@ -215,1 +216,1 @@\n-                    expectThrows(StructureViolationException.class, () -> flock.start(thread));\n+                    assertThrows(StructureViolationException.class, () -> flock.start(thread));\n","filename":"test\/jdk\/jdk\/internal\/misc\/ThreadFlock\/WithScopedValue.java","additions":32,"deletions":31,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -110,0 +110,1 @@\n+            \"ResizeTLABs\",\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/collection\/TestG1ParallelPhases.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -150,0 +150,11 @@\n+    private static void verifyTotalDiffBetweenReservedAndCommitted(List<RecordedEvent> events) throws Exception {\n+        RecordedEvent firstTotal = events.stream()\n+                .filter(e -> e.getEventType().getName().equals(UsageTotalEvent))\n+                .findFirst().orElse(null);\n+\n+        \/\/ Verify that the first total event has more reserved than committed memory.\n+        long firstReserved = firstTotal.getLong(\"reserved\");\n+        long firstCommitted = firstTotal.getLong(\"committed\");\n+        assertGreaterThan(firstReserved, firstCommitted, \"initial reserved should be greater than initial committed\");\n+    }\n+\n@@ -170,0 +181,1 @@\n+                verifyTotalDiffBetweenReservedAndCommitted(events);\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestNativeMemoryUsageEvents.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.jcmd;\n+\n+\/**\n+ * @test\n+ * @summary The test verifies that options can only be specified once with jcmd JFR\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @modules jdk.jfr\/jdk.jfr.internal.dcmd\n+ * @run main\/othervm jdk.jfr.jcmd.TestJcmdOptionSpecifiedOnce\n+ *\/\n+public class TestJcmdOptionSpecifiedOnce {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        testJCmdConflict();\n+    }\n+\n+    private static void testJCmdConflict() {\n+        var output= JcmdHelper.jcmd(\"JFR.start name=hello name=greetings\");\n+        output.shouldContain(\"name can only be specified once\");\n+    }\n+}\n+\n","filename":"test\/jdk\/jdk\/jfr\/jcmd\/TestJcmdOptionSpecifiedOnce.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.startupargs;\n+\n+import jdk.test.lib.process.ProcessTools;\n+\n+\/**\n+ * @test The test verifies that options can only be specified once with --XX:StartFlightRecording\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main jdk.jfr.startupargs.TestStartupOptionSpecifiedOnce\n+ *\/\n+public class TestStartupOptionSpecifiedOnce {\n+\n+    public static void main(String[] args) throws Exception {\n+        testStartFlightRecordingConflict();\n+        testConflictThreeOptions();\n+        testAbleMultipleOption();\n+    }\n+\n+    private static void testStartFlightRecordingConflict() throws Exception {\n+        var output = ProcessTools.executeTestJava(\"-XX:StartFlightRecording:disk=true,disk=false,name=cat,name=dog\");\n+        output.shouldContain(\"disk and name can only be specified once.\");\n+    }\n+\n+    private static void testConflictThreeOptions() throws Exception {\n+        var output = ProcessTools.executeTestJava(\"-XX:StartFlightRecording:name=abc,name=def,disk=true,disk=false,delay=1s,delay=2s\");\n+        output.shouldContain(\"name, disk and delay can only be specified once.\");\n+    }\n+\n+    private static void testAbleMultipleOption() throws Exception {\n+        var output = ProcessTools.executeTestJava(\"-XX:StartFlightRecording:settings=default,settings=profile\");\n+        output.shouldNotContain(\"settings can only be specified once\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/startupargs\/TestStartupOptionSpecifiedOnce.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,227 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8245654\n+ * @summary Interoperability tests with Certigna Root CA from Dhimyotis\n+ * @build ValidatePathWithParams\n+ * @run main\/othervm -Djava.security.debug=certpath CertignaCA OCSP\n+ * @run main\/othervm -Djava.security.debug=certpath CertignaCA CRL\n+ *\/\n+\n+\/*\n+ * Obtain TLS test artifacts for Certigna Root CA from:\n+ *\n+ * Valid TLS Certificates:\n+ * https:\/\/valid.servicesca.dhimyotis.com\/\n+ *\n+ * Revoked TLS Certificates:\n+ * https:\/\/revoked.servicesca.dhimyotis.com\/\n+ *\/\n+public class CertignaCA {\n+\n+    \/\/ Owner: CN=Certigna Services CA, OID.2.5.4.97=NTRFR-48146308100036,\n+    \/\/ OU=0002 48146308100036, O=DHIMYOTIS, C=FR\n+    \/\/ Issuer: CN=Certigna, O=Dhimyotis, C=FR\n+    \/\/ Serial number: 6f82fa28acd6f784bb5b120ba87367ad\n+    \/\/ Valid from: Wed Nov 25 03:33:52 PST 2015 until: Sat Nov 22 03:33:52 PST 2025\n+    private static final String INT = \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIGFjCCBP6gAwIBAgIQb4L6KKzW94S7WxILqHNnrTANBgkqhkiG9w0BAQsFADA0\\n\" +\n+            \"MQswCQYDVQQGEwJGUjESMBAGA1UECgwJRGhpbXlvdGlzMREwDwYDVQQDDAhDZXJ0\\n\" +\n+            \"aWduYTAeFw0xNTExMjUxMTMzNTJaFw0yNTExMjIxMTMzNTJaMH0xCzAJBgNVBAYT\\n\" +\n+            \"AkZSMRIwEAYDVQQKDAlESElNWU9USVMxHDAaBgNVBAsMEzAwMDIgNDgxNDYzMDgx\\n\" +\n+            \"MDAwMzYxHTAbBgNVBGEMFE5UUkZSLTQ4MTQ2MzA4MTAwMDM2MR0wGwYDVQQDDBRD\\n\" +\n+            \"ZXJ0aWduYSBTZXJ2aWNlcyBDQTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoC\\n\" +\n+            \"ggIBALPM+7LpWBz9wFcPaTc3xnB+5g0XrnptB0EPPfrR04vO52Ykm4ky1d4ZLd10\\n\" +\n+            \"tbM1fa1RqNSOVWWg93O4pL7zCFKlz6JV74ZZVhHpEAwzBwv2oPnxvVbxtSN67xsS\\n\" +\n+            \"Y66ahUYxjzs8+3FhmsiRxqwnTYvK2u70uglUvRisOKyTL\/M6JnrC4y8tlmoz7OSa\\n\" +\n+            \"5BmBMVplJFQtvmON6N9aHLvYMz+EyJPCbXL6pELxeHjFT5QmIaRamsr2DOTaCjtB\\n\" +\n+            \"ZKI1Wnh3X7lnbjM8MESJiV2t7E9tIQNG0Z\/HI3tO4aaUMum3KysY5sC8v3vi7rry\\n\" +\n+            \"GidgzHQhrtP0ZXWW5UH\/k7umLS\/P\/XXWnCFpc2Lxa1uDGfc2im7xibRoPP+JNZsz\\n\" +\n+            \"N76euFlls6jyEXAiwnVr14tVVTewLK0OWs5SJHpEKp8PGMZRDj59EmMvokWwzL6Q\\n\" +\n+            \"zNZ6vVAp00oOm05sbspNY9+MFqGKKUsKvhFGEa4XmRNxDe6KswLcjPZB+NKHZ0QW\\n\" +\n+            \"Fd4ip5C5XmEK\/8qIPjwVr9dah9+oiHGGO8Wx7gJAMF5DTmkvW7GhqCKj1LmHnabj\\n\" +\n+            \"zc8av6kxWVQZi\/C7HCm9i\/W4wio+JA2EAFLqNL3GPNbK9kau4yPhQt\/c7zxzo0OH\\n\" +\n+            \"nlsV4THCG7oOCd3cfCiyfQcb3FBt6OSpaKRZxjCLBwP00r0fAgMBAAGjggHZMIIB\\n\" +\n+            \"1TASBgNVHRMBAf8ECDAGAQH\/AgEAMA4GA1UdDwEB\/wQEAwIBBjAdBgNVHQ4EFgQU\\n\" +\n+            \"rOyGj0s3HLh\/FxsZ0K7oTuM0XBIwZAYDVR0jBF0wW4AUGu3+QTmQtCRZvgHyUtVF\\n\" +\n+            \"9lo53BGhOKQ2MDQxCzAJBgNVBAYTAkZSMRIwEAYDVQQKDAlEaGlteW90aXMxETAP\\n\" +\n+            \"BgNVBAMMCENlcnRpZ25hggkA\/tzjAQ\/JSP8wSQYDVR0gBEIwQDA+BgoqgXoBgTEB\\n\" +\n+            \"AAECMDAwLgYIKwYBBQUHAgEWImh0dHBzOi8vd3d3LmNlcnRpZ25hLmZyL2F1dG9y\\n\" +\n+            \"aXRlcy8wfAYIKwYBBQUHAQEEcDBuMDQGCCsGAQUFBzAChihodHRwOi8vYXV0b3Jp\\n\" +\n+            \"dGUuY2VydGlnbmEuZnIvY2VydGlnbmEuZGVyMDYGCCsGAQUFBzAChipodHRwOi8v\\n\" +\n+            \"YXV0b3JpdGUuZGhpbXlvdGlzLmNvbS9jZXJ0aWduYS5kZXIwYQYDVR0fBFowWDAp\\n\" +\n+            \"oCegJYYjaHR0cDovL2NybC5jZXJ0aWduYS5mci9jZXJ0aWduYS5jcmwwK6ApoCeG\\n\" +\n+            \"JWh0dHA6Ly9jcmwuZGhpbXlvdGlzLmNvbS9jZXJ0aWduYS5jcmwwDQYJKoZIhvcN\\n\" +\n+            \"AQELBQADggEBAGLft7gIuGPZVfg0cTM+HT2xAZFPDb\/2+siH06x+dH044zMKbBIN\\n\" +\n+            \"bRzhKipwB1A3MW8FQjveE9tyrfyuqZE\/X+o2SlGcdNV44ybYkxo4f6kcLEavV\/IW\\n\" +\n+            \"+oFEnojZlhpksYcxrvQoEyqkAwshe8IS2KtZHKVACrt+XSs0lwvy7ALGmHaF7A4b\\n\" +\n+            \"y6cZWItA7Lhj8XWp+8tBJDj7HocRbWtxzEODdBuyMgJzFrNjc+97J0vH\/K0+3yjm\\n\" +\n+            \"kczpKshMA0tM+MF9XDMN\/MuwrPmUWGO\/fHiqHgUp8yqeWtl1n44ZxkkK1t9GRwhn\\n\" +\n+            \"DWLv73\/xhTmdhWYQ\/reo0GbgBoLiltKmIJQ=\\n\" +\n+            \"-----END CERTIFICATE-----\";\n+\n+    \/\/ Owner: SERIALNUMBER=S230100953, CN=valid.servicesca.dhimyotis.com,\n+    \/\/ OU=0002 48146308100036, O=DHIMYOTIS, L=VILLENEUVE D'ASCQ, C=FR\n+    \/\/ Issuer: CN=Certigna Services CA, OID.2.5.4.97=NTRFR-48146308100036,\n+    \/\/ OU=0002 48146308100036, O=DHIMYOTIS, C=FR\n+    \/\/ Serial number: 2959798fe2e0e7b43810169ae938bc5f\n+    \/\/ Valid from: Sun Mar 13 16:00:00 PDT 2022 until: Mon Mar 13 15:59:59 PDT 2023\n+    private static final String VALID = \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIIkzCCBnugAwIBAgIQKVl5j+Lg57Q4EBaa6Ti8XzANBgkqhkiG9w0BAQsFADB9\\n\" +\n+            \"MQswCQYDVQQGEwJGUjESMBAGA1UECgwJREhJTVlPVElTMRwwGgYDVQQLDBMwMDAy\\n\" +\n+            \"IDQ4MTQ2MzA4MTAwMDM2MR0wGwYDVQRhDBROVFJGUi00ODE0NjMwODEwMDAzNjEd\\n\" +\n+            \"MBsGA1UEAwwUQ2VydGlnbmEgU2VydmljZXMgQ0EwHhcNMjIwMzEzMjMwMDAwWhcN\\n\" +\n+            \"MjMwMzEzMjI1OTU5WjCBmTELMAkGA1UEBhMCRlIxGjAYBgNVBAcMEVZJTExFTkVV\\n\" +\n+            \"VkUgRCdBU0NRMRIwEAYDVQQKDAlESElNWU9USVMxHDAaBgNVBAsMEzAwMDIgNDgx\\n\" +\n+            \"NDYzMDgxMDAwMzYxJzAlBgNVBAMMHnZhbGlkLnNlcnZpY2VzY2EuZGhpbXlvdGlz\\n\" +\n+            \"LmNvbTETMBEGA1UEBRMKUzIzMDEwMDk1MzCCASIwDQYJKoZIhvcNAQEBBQADggEP\\n\" +\n+            \"ADCCAQoCggEBALpeGHbzRGnv1C0PdJS0nT+Cx98Pw8ctaw51m9Vlk2j8AFGZRu8r\\n\" +\n+            \"lX3noQYX0AIfcbk6KqPAreIvJQV0UgM5jxt3mIQF7iU+55MG4mWmSJgKDDq4b3ck\\n\" +\n+            \"WdBy0KpSBqLmB9sHyTNk9NilNu7VwG03HGIltWA2uQFJGC8CkxwAFpMCQ9RVYw2Z\\n\" +\n+            \"NkL\/SsiPgrRLiCJZjesk1oAcLnLp7hbelfUB2Z71VmuDDlom7CsLvdN8eIG+Lj+V\\n\" +\n+            \"wkGmH6AbVGvbFniFDLCNDSJWCQ9AHeO+i0CM\/wd2gBRSgm993p2YMxu5mVZjz\/rp\\n\" +\n+            \"ELaCYjulvNZKvPIFoNe8qsxlXRWeqWaHuPsCAwEAAaOCA\/AwggPsMIHkBggrBgEF\\n\" +\n+            \"BQcBAQSB1zCB1DA4BggrBgEFBQcwAoYsaHR0cDovL2F1dG9yaXRlLmRoaW15b3Rp\\n\" +\n+            \"cy5jb20vc2VydmljZXNjYS5kZXIwNgYIKwYBBQUHMAKGKmh0dHA6Ly9hdXRvcml0\\n\" +\n+            \"ZS5jZXJ0aWduYS5mci9zZXJ2aWNlc2NhLmRlcjAwBggrBgEFBQcwAYYkaHR0cDov\\n\" +\n+            \"L3NlcnZpY2VzY2Eub2NzcC5kaGlteW90aXMuY29tMC4GCCsGAQUFBzABhiJodHRw\\n\" +\n+            \"Oi8vc2VydmljZXNjYS5vY3NwLmNlcnRpZ25hLmZyMB8GA1UdIwQYMBaAFKzsho9L\\n\" +\n+            \"Nxy4fxcbGdCu6E7jNFwSMAkGA1UdEwQCMAAwYQYDVR0gBFowWDAIBgZngQwBAgIw\\n\" +\n+            \"TAYLKoF6AYExAgUBAQEwPTA7BggrBgEFBQcCARYvaHR0cHM6Ly93d3cuY2VydGln\\n\" +\n+            \"bmEuY29tL2F1dG9yaXRlLWNlcnRpZmljYXRpb24wZQYDVR0fBF4wXDAroCmgJ4Yl\\n\" +\n+            \"aHR0cDovL2NybC5jZXJ0aWduYS5mci9zZXJ2aWNlc2NhLmNybDAtoCugKYYnaHR0\\n\" +\n+            \"cDovL2NybC5kaGlteW90aXMuY29tL3NlcnZpY2VzY2EuY3JsMBMGA1UdJQQMMAoG\\n\" +\n+            \"CCsGAQUFBwMBMA4GA1UdDwEB\/wQEAwIFoDBIBgNVHREEQTA\/gh12YWxpZC5zZXJ2\\n\" +\n+            \"aWNlc2NhLmNlcnRpZ25hLmNvbYIedmFsaWQuc2VydmljZXNjYS5kaGlteW90aXMu\\n\" +\n+            \"Y29tMB0GA1UdDgQWBBSGQwwMIdxiI7P+CFU\/Z968XZaSGzCCAX0GCisGAQQB1nkC\\n\" +\n+            \"BAIEggFtBIIBaQFnAHUArfe++nz\/EMiLnT2cHj4YarRnKV3PsQwkyoWGNOvcgooA\\n\" +\n+            \"AAF\/h9eOGgAABAMARjBEAiBaneK2CTn9lH28CUnL2C2\/WklUYkvygMiDrtCIUXfw\\n\" +\n+            \"gQIgJrGxwgGlsYzUdZyZY\/oNWSLByO8\/Jb5LXbNibdk5SnAAdwDoPtDaPvUGNTLn\\n\" +\n+            \"Vyi8iWvJA9PL0RFr7Otp4Xd9bQa9bgAAAX+H14\/NAAAEAwBIMEYCIQCVtuV9p\/Ug\\n\" +\n+            \"IhwVoMUjPp1KzGte\/FmDaKPx432VjOpD+AIhANKWkDEuVnMzPH8sdJCL+eXoB0Q7\\n\" +\n+            \"0mpe5dHEiFJS8lTBAHUAs3N3B+GEUPhjhtYFqdwRCUp5LbFnDAuH3PADDnk2pZoA\\n\" +\n+            \"AAF\/h9eTcQAABAMARjBEAiAjdYhnzPe9lJksk94ngl7PLDRi71tSRN7SslibEyv+\\n\" +\n+            \"XAIgLQ5NKQAaJnF8oA7WnHB8gyJ\/8kqZi52d1WFgARDLR30wDQYJKoZIhvcNAQEL\\n\" +\n+            \"BQADggIBAJhLhW5Gh9yOPKsrMhABd7U5juc5ev97c6s7Az70Yr5\/EtH6TlgC6a1N\\n\" +\n+            \"i0yzFOeXzAR8Svsq6HzqP9kMJkEFIrdWH8JZdEv871EjYetEzLLnO0m+dNEROJAh\\n\" +\n+            \"fcJ2w2LufPNaQ327tGY\/DxDH9jdtgquReO01bPlJ0Yc5J3maz4XapeUm\/kQ8dRzS\\n\" +\n+            \"0UBOxfUlEMpDatZzg7wugy7g9vOndW\/VbtbN5Iioq2bjuykPJZfZUx4cCAmLUS7w\\n\" +\n+            \"bqPThQ54PnybiPXaF8cH1Gq0Rs\/lGB1erzRXRXHgMy61mFY944r13oATnSdTy8Gm\\n\" +\n+            \"QoMsVp9w7WBRo8O4PR606Ke8Ufm9Kg2GJ1sHClf70FNFO\/OSFlr3BLDG0vEMdgVW\\n\" +\n+            \"9QLu6UQXa9PhWMoo030k5fmUySzIUljXnstj3rgcD2HE1UrobTqyRHbbQ8JVWaF0\\n\" +\n+            \"PrPR4WDFI9dY0jixVQucKlX6FCqsyNrJF8GWDlZH+Cd8bk+MA9fKUuX\/vmoOc2d+\\n\" +\n+            \"bvOCliME7YjAJkyclk6yiFIMnqyh+TD0d8WbjE94YC\/293Xqb6WGkRhhsCX9RUrk\\n\" +\n+            \"I6QbS2uicCFGjRsPmjvMkDDxS00MShRl2K\/KpsAx68Cv\/Gcw3bv31obwNXTB2IBg\\n\" +\n+            \"gI0MfBHnjIp1nmNvCNmVIP52YrGQyC2JE7+GZUWTuwUVeDgBhiEZ\\n\" +\n+            \"-----END CERTIFICATE-----\";\n+\n+    \/\/ Owner: SERIALNUMBER=S230120951, CN=revoked.servicesca.dhimyotis.com,\n+    \/\/ OU=0002 48146308100036, O=DHIMYOTIS, L=VILLENEUVE D'ASCQ, C=FR\n+    \/\/ Issuer: CN=Certigna Services CA, OID.2.5.4.97=NTRFR-48146308100036,\n+    \/\/ OU=0002 48146308100036, O=DHIMYOTIS, C=FR\n+    \/\/ Serial number: f88f2566b3dbf73763622db9b2bf9cc\n+    \/\/ Valid from: Sun Mar 13 16:00:00 PDT 2022 until: Mon Mar 13 15:59:59 PDT 2023\n+    private static final String REVOKED = \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIImTCCBoGgAwIBAgIQD4jyVms9v3N2NiLbmyv5zDANBgkqhkiG9w0BAQsFADB9\\n\" +\n+            \"MQswCQYDVQQGEwJGUjESMBAGA1UECgwJREhJTVlPVElTMRwwGgYDVQQLDBMwMDAy\\n\" +\n+            \"IDQ4MTQ2MzA4MTAwMDM2MR0wGwYDVQRhDBROVFJGUi00ODE0NjMwODEwMDAzNjEd\\n\" +\n+            \"MBsGA1UEAwwUQ2VydGlnbmEgU2VydmljZXMgQ0EwHhcNMjIwMzEzMjMwMDAwWhcN\\n\" +\n+            \"MjMwMzEzMjI1OTU5WjCBmzELMAkGA1UEBhMCRlIxGjAYBgNVBAcMEVZJTExFTkVV\\n\" +\n+            \"VkUgRCdBU0NRMRIwEAYDVQQKDAlESElNWU9USVMxHDAaBgNVBAsMEzAwMDIgNDgx\\n\" +\n+            \"NDYzMDgxMDAwMzYxKTAnBgNVBAMMIHJldm9rZWQuc2VydmljZXNjYS5kaGlteW90\\n\" +\n+            \"aXMuY29tMRMwEQYDVQQFEwpTMjMwMTIwOTUxMIIBIjANBgkqhkiG9w0BAQEFAAOC\\n\" +\n+            \"AQ8AMIIBCgKCAQEAouvIzemKChCjYICW+TzRigLkqaTdMLnaPlGaXyCCoEUS6nkK\\n\" +\n+            \"QnrwTgebf1X9\/mwSAuvTo3Ck7CVgE8AMqsPTluSjezCJuED\/F3HYy2YsbIhnVK\/i\\n\" +\n+            \"uSzKsDGVY3RlVNm2MA2viVTNBbOFhk4kefYqpDCmp3EGvIDOCb7Y5PTuKKQ79s97\\n\" +\n+            \"uDm+0WoBnOdwSuZMUg+hvINBgu2JQFwiWP0g\/SxoK6Ci9SVokM3zR4KgECkMVArf\\n\" +\n+            \"cH0dN+5SYvByaGegQJy7TdKqDsf1lIHM19tUXcxOBNRgV3Rf7WMNIlERtLXjRfke\\n\" +\n+            \"IWXf8QtXRVIH\/i\/PoVTDo2qvQOMnZFY\/Eb5dFQIDAQABo4ID9DCCA\/AwgeQGCCsG\\n\" +\n+            \"AQUFBwEBBIHXMIHUMDgGCCsGAQUFBzAChixodHRwOi8vYXV0b3JpdGUuZGhpbXlv\\n\" +\n+            \"dGlzLmNvbS9zZXJ2aWNlc2NhLmRlcjA2BggrBgEFBQcwAoYqaHR0cDovL2F1dG9y\\n\" +\n+            \"aXRlLmNlcnRpZ25hLmZyL3NlcnZpY2VzY2EuZGVyMDAGCCsGAQUFBzABhiRodHRw\\n\" +\n+            \"Oi8vc2VydmljZXNjYS5vY3NwLmRoaW15b3Rpcy5jb20wLgYIKwYBBQUHMAGGImh0\\n\" +\n+            \"dHA6Ly9zZXJ2aWNlc2NhLm9jc3AuY2VydGlnbmEuZnIwHwYDVR0jBBgwFoAUrOyG\\n\" +\n+            \"j0s3HLh\/FxsZ0K7oTuM0XBIwCQYDVR0TBAIwADBhBgNVHSAEWjBYMAgGBmeBDAEC\\n\" +\n+            \"AjBMBgsqgXoBgTECBQEBATA9MDsGCCsGAQUFBwIBFi9odHRwczovL3d3dy5jZXJ0\\n\" +\n+            \"aWduYS5jb20vYXV0b3JpdGUtY2VydGlmaWNhdGlvbjBlBgNVHR8EXjBcMCugKaAn\\n\" +\n+            \"hiVodHRwOi8vY3JsLmNlcnRpZ25hLmZyL3NlcnZpY2VzY2EuY3JsMC2gK6Aphido\\n\" +\n+            \"dHRwOi8vY3JsLmRoaW15b3Rpcy5jb20vc2VydmljZXNjYS5jcmwwEwYDVR0lBAww\\n\" +\n+            \"CgYIKwYBBQUHAwEwDgYDVR0PAQH\/BAQDAgWgMEwGA1UdEQRFMEOCH3Jldm9rZWQu\\n\" +\n+            \"c2VydmljZXNjYS5jZXJ0aWduYS5jb22CIHJldm9rZWQuc2VydmljZXNjYS5kaGlt\\n\" +\n+            \"eW90aXMuY29tMB0GA1UdDgQWBBTGIed1eHBS8Z1H3PdMkItpjyjq2TCCAX0GCisG\\n\" +\n+            \"AQQB1nkCBAIEggFtBIIBaQFnAHcArfe++nz\/EMiLnT2cHj4YarRnKV3PsQwkyoWG\\n\" +\n+            \"NOvcgooAAAF\/h9g4MAAABAMASDBGAiEAp\/1fQB730JrX9YGD3d1Uq7rTAL95tMKe\\n\" +\n+            \"G6kgUP1GEWoCIQCzi6feA3cImTH6tVZALNEmve\/n8SVFAvD2AvX8ioCD9QB1AOg+\\n\" +\n+            \"0No+9QY1MudXKLyJa8kD08vREWvs62nhd31tBr1uAAABf4fYNHcAAAQDAEYwRAIg\\n\" +\n+            \"Dnd8oOV7\/MuaiyR23qbdRVf1kBSsDxnLp1\/vRdD0JTYCIAw7LuZalEVa\/0KpuNHs\\n\" +\n+            \"NIdUJgV4Vioa2xkb9fdPIhtkAHUAs3N3B+GEUPhjhtYFqdwRCUp5LbFnDAuH3PAD\\n\" +\n+            \"Dnk2pZoAAAF\/h9g7nwAABAMARjBEAiA80M1W3V3iKjm6Dwn+hKkmvGiuXZoM6o3f\\n\" +\n+            \"QJsZ2ZOx0QIgUiS3I83WzoCdD4qO9rlmDQhRD69CeVzCgLtkaTPz3JYwDQYJKoZI\\n\" +\n+            \"hvcNAQELBQADggIBADKub0gNyasTvURoYukQCllqDC+SvWA4TURBcmQMNjdVkreJ\\n\" +\n+            \"B3O91HZhTyhrCBJxybeIG89zuRI6rjTpHCQGFqtP7968NA3eUlxGGnAPpw6VbN47\\n\" +\n+            \"Ake+CRI9XnhxcKmTGm987DjtIBH42BedS59P1T56grZP5ysOog9Hz4eYo2ytbZqt\\n\" +\n+            \"P\/DHggivymaaiIaBsqup8C7\/XN3vVAa\/yo1FeLJ48i1d0M9hjGBUFMajd8Y5+pE7\\n\" +\n+            \"p6Nb5mT1LXbetORYXMyG3MiJQPBAr1dLnRGnOZxc1Kxa1QwoAFQAFIXFpqfBwfHi\\n\" +\n+            \"NaSDdFS\/wLbpe7UvtC8FWLq9sgITDEkPqDPCsbu8Vc7OxaMhBJ7HQGaAYMReGADG\\n\" +\n+            \"Elx9ffAc+dFR62zFnqMLouaEznZ7FVNmU3cYbrFVBvnGmoDRe0AKUoYv5DCiawUg\\n\" +\n+            \"qeQS69DgG7DOE5VIDaWX2Cevy81mz7O8EVQsyS15J\/MUxzWfQpRaHUqkge6G9FSH\\n\" +\n+            \"hF\/Nm48oWgpWop5aIF2O6bA\/Bt1VvAWdypUPUr4gtpYIQoOQBzTFgBVWUeOTOImE\\n\" +\n+            \"avvpzSwGQfZkB7t5PcAQ+zYGxWq7fr30\/qY3geePcXJCGWS6PXyj8lNn4CaJ2sMF\\n\" +\n+            \"GKxNJGD49\/5uoxi3b3TzGUn\/3eG2qP2RZoXZ6ZPLAo+moIy3XLwMoZm3Im8r\\n\" +\n+            \"-----END CERTIFICATE-----\";\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        ValidatePathWithParams pathValidator;\n+        String[] validChainToValidate;\n+        String[] revChainToValidate;\n+\n+        if (args.length >= 1 && \"CRL\".equalsIgnoreCase(args[0])) {\n+            pathValidator = new ValidatePathWithParams(null);\n+            pathValidator.enableCRLCheck();\n+\n+            validChainToValidate = new String[]{VALID, INT};\n+            revChainToValidate = new String[]{REVOKED, INT};\n+        } else {\n+            \/\/ OCSP check by default\n+            \/\/ int certificate doesn't specify OCSP responder\n+            pathValidator = new ValidatePathWithParams(new String[]{INT});\n+            pathValidator.enableOCSPCheck();\n+\n+            validChainToValidate = new String[]{VALID};\n+            revChainToValidate = new String[]{REVOKED};\n+        }\n+\n+        \/\/ Validate valid\n+        pathValidator.validate(validChainToValidate,\n+                ValidatePathWithParams.Status.GOOD, null, System.out);\n+\n+        \/\/ Validate Revoked\n+        pathValidator.validate(revChainToValidate,\n+                ValidatePathWithParams.Status.REVOKED,\n+                \"Mon Mar 14 03:00:16 PDT 2022\", System.out);\n+    }\n+}\n+\n","filename":"test\/jdk\/security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/CertignaCA.java","additions":227,"deletions":0,"binary":false,"changes":227,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- *      8243559 8225072 8258630 8259312 8256421 8225081 8225082 8225083\n+ *      8243559 8225072 8258630 8259312 8256421 8225081 8225082 8225083 8245654\n@@ -57,1 +57,1 @@\n-    private static final int COUNT = 89;\n+    private static final int COUNT = 90;\n@@ -62,1 +62,1 @@\n-            = \"0D:9C:40:8F:CE:B1:C7:27:89:54:FD:80:DA:B6:91:F4:C9:94:15:C4:8D:25:62:34:D4:70:32:60:1A:6F:13:27\";\n+            = \"A3:57:D9:69:62:ED:00:ED:72:83:1E:15:46:02:93:F3:12:0F:49:83:E3:E6:D0:9F:96:34:05:9C:43:EB:D6:05\";\n@@ -249,0 +249,2 @@\n+            put(\"certignaca [jdk]\",\n+                    \"E3:B6:A2:DB:2E:D7:CE:48:84:2F:7A:C5:32:41:C7:B7:1D:54:14:4B:FB:40:C1:1F:3F:1D:0B:42:F5:EE:A1:2D\");\n","filename":"test\/jdk\/sun\/security\/lib\/cacerts\/VerifyCACerts.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8301788\n+ * @library \/test\/lib\n+ * @summary AlgorithmId should keep lowercase characters from 3rd party providers\n+ * @modules java.base\/sun.security.x509\n+ *          java.base\/sun.security.util\n+ *\/\n+import jdk.test.lib.Asserts;\n+import sun.security.x509.AlgorithmId;\n+\n+import java.security.Provider;\n+import java.security.Security;\n+import java.util.Locale;\n+\n+public class Uppercase {\n+\n+    private static final String OID = \"2.3.4.5.8301788\";\n+    private static final String ALG = \"Oolala\";\n+\n+    public static void main(String[] args) throws Exception {\n+        Security.addProvider(new ProviderImpl());\n+        Asserts.assertEQ(AlgorithmId.get(ALG).getOID().toString(), OID);\n+        Asserts.assertEQ(AlgorithmId.get(ALG.toUpperCase(Locale.ROOT)).getOID().toString(), OID);\n+        Asserts.assertEQ(AlgorithmId.get(OID).getName(), ALG);\n+    }\n+\n+    public static class ProviderImpl extends Provider {\n+        public ProviderImpl() {\n+            super(\"ProviderImpl\", \"1.0\", \"ProviderImpl\");\n+            \/\/ It does not matter if we really provide an implementation\n+            put(\"MessageDigest.\" + ALG, \"Uppercase$MessageDigestImpl\");\n+            put(\"Alg.Alias.MessageDigest.OID.\" + OID, ALG);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/x509\/AlgorithmId\/Uppercase.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug      8301813\n+ * @summary  Bad caret position in error message\n+ * @library  \/tools\/lib ..\/..\/lib\n+ * @modules  jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build    toolbox.ToolBox javadoc.tester.*\n+ * @run main TestNoTagName\n+ *\/\n+\n+import java.nio.file.Path;\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+public class TestNoTagName extends JavadocTester {\n+\n+    public static void main(String... args) throws Exception {\n+        var test = new TestNoTagName();\n+        test.runTests();\n+    }\n+\n+    private ToolBox tb = new ToolBox();\n+\n+    @Test\n+    public void test_inline_missing(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                    \/**\n+                     * abc {@ } def\n+                     *\/\n+                    public class C { private C() { } }\n+                    \"\"\"\n+                );\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                src.resolve(\"C.java\").toString()\n+                );\n+        checkExit(Exit.ERROR);\n+        checkOutput(Output.OUT, true, \"\"\"\n+                C.java:2: error: no tag name after '@'\n+                 * abc {@ } def\n+                         ^\n+                \"\"\");\n+    }\n+\n+    @Test\n+    public void test_inline_bad(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                    \/**\n+                     * abc {@\/ } def\n+                     *\/\n+                    public class C { private C() { } }\n+                    \"\"\"\n+        );\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                src.resolve(\"C.java\").toString()\n+        );\n+        checkExit(Exit.ERROR);\n+        checkOutput(Output.OUT, true, \"\"\"\n+                C.java:2: error: no tag name after '@'\n+                 * abc {@\/ } def\n+                         ^\n+                \"\"\");\n+    }\n+\n+    @Test\n+    public void test_block_missing(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                    \/**\n+                     * abc.\n+                     * @ def\n+                     *\/\n+                    public class C { private C() { } }\n+                    \"\"\"\n+        );\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                src.resolve(\"C.java\").toString()\n+        );\n+        checkExit(Exit.ERROR);\n+        checkOutput(Output.OUT, true, \"\"\"\n+                C.java:3: error: no tag name after '@'\n+                 * @ def\n+                    ^\n+                \"\"\");\n+    }\n+\n+    @Test\n+    public void test_block_bad(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                    \/**\n+                     * abc.\n+                     * @\/ def\n+                     *\/\n+                    public class C { private C() { } }\n+                    \"\"\"\n+        );\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                src.resolve(\"C.java\").toString()\n+        );\n+        checkExit(Exit.ERROR);\n+        checkOutput(Output.OUT, true, \"\"\"\n+                C.java:3: error: no tag name after '@'\n+                 * @\/ def\n+                    ^\n+                \"\"\");\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testNoTagName\/TestNoTagName.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -131,1 +131,1 @@\n-                new ExpectedDiagnostic(\"compiler.err.cant.assign.val.to.final.var\", 0, 3, 1, -1, -1, Diagnostic.Kind.ERROR));\n+                new ExpectedDiagnostic(\"compiler.err.cant.assign.val.to.var\", 0, 3, 1, -1, -1, Diagnostic.Kind.ERROR));\n@@ -133,1 +133,1 @@\n-                new ExpectedDiagnostic(\"compiler.err.cant.assign.val.to.final.var\", 0, 3, 1, -1, -1, Diagnostic.Kind.ERROR));\n+                new ExpectedDiagnostic(\"compiler.err.cant.assign.val.to.var\", 0, 3, 1, -1, -1, Diagnostic.Kind.ERROR));\n","filename":"test\/langtools\/jdk\/jshell\/ModifiersTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8274148\n+ * @bug 8274148 8301580\n@@ -102,0 +102,15 @@\n+    public void testClassErrorRecovery() { \/\/JDK-8301580\n+        assertHighlights(\"\"\"\n+                         class C {\n+                            void m\n+                            {\n+                                return ;\n+                            }\n+                         }\n+                         \"\"\",\n+                         \"Highlight[start=0, end=5, attributes=[KEYWORD]]\",\n+                         \"Highlight[start=6, end=7, attributes=[DECLARATION]]\",\n+                         \"Highlight[start=13, end=17, attributes=[KEYWORD]]\",\n+                         \"Highlight[start=32, end=38, attributes=[KEYWORD]]\");\n+    }\n+\n","filename":"test\/langtools\/jdk\/jshell\/SnippetHighlightTest.java","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -12,1 +12,1 @@\n- * @@@\n+ * @!#\n","filename":"test\/langtools\/tools\/doclint\/BadPackageCommentTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,4 +5,1 @@\n- * @@@\n-   ^\n-BadPackageCommentTest.java:12: error: no tag name after '@'\n- * @@@\n+ * @!#\n@@ -10,4 +7,1 @@\n-BadPackageCommentTest.java:12: error: no tag name after '@'\n- * @@@\n-     ^\n-3 errors\n+1 error\n","filename":"test\/langtools\/tools\/doclint\/BadPackageCommentTest.out","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -69,0 +69,4 @@\n+    \/**\n+     * <ul> &amp; <li> ... <\/li> <\/ul>\n+     *\/\n+    public void entity_not_allowed() { }\n@@ -70,0 +74,4 @@\n+    \/**\n+     * <ul> *@\/ <li> ... <\/li> <\/ul>\n+     *\/\n+    public void escape_not_allowed() { }\n","filename":"test\/langtools\/tools\/doclint\/HtmlTagsTest.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,1 +46,7 @@\n-13 errors\n+HtmlTagsTest.java:70: error: text not allowed in <ul> element\n+     * <ul> &amp; <li> ... <\/li> <\/ul>\n+            ^\n+HtmlTagsTest.java:75: error: text not allowed in <ul> element\n+     * <ul> *@\/ <li> ... <\/li> <\/ul>\n+           ^\n+15 errors\n","filename":"test\/langtools\/tools\/doclint\/HtmlTagsTest.out","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.doclint\n+ * @build DocLintTester\n+ * @run main DocLintTester -ref ReturnTest.out ReturnTest.java\n+ *\/\n+\n+\/** No comment. *\/\n+public class ReturnTest {\n+    \/**\n+     {@return legal} **\/\n+    public int m_legal() { return 0; }\n+\n+    \/** <p> {@return illegal} **\/\n+    public int m_illegal_html() { return 0; }\n+\n+    \/** text {@return illegal} **\/\n+    public int m_illegal_text() { return 0; }\n+\n+    \/** &amp;{@return illegal} **\/\n+    public int m_illegal_entity() { return 0; }\n+\n+    \/** @@{@return illegal} **\/\n+    public int m_illegal_escape() { return 0; }\n+\n+    \/** {@return legal} text {@return illegal} **\/\n+    public int m_illegal_repeat() { return 0; }\n+\n+    \/** . *\/\n+    private ReturnTest() { }\n+}\n","filename":"test\/langtools\/tools\/doclint\/ReturnTest.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,19 @@\n+ReturnTest.java:14: warning: {@return} not at beginning of description\n+    \/** <p> {@return illegal} **\/\n+            ^\n+ReturnTest.java:17: warning: {@return} not at beginning of description\n+    \/** text {@return illegal} **\/\n+             ^\n+ReturnTest.java:20: warning: {@return} not at beginning of description\n+    \/** &amp;{@return illegal} **\/\n+             ^\n+ReturnTest.java:23: warning: {@return} not at beginning of description\n+    \/** @@{@return illegal} **\/\n+          ^\n+ReturnTest.java:26: warning: @return has already been specified\n+    \/** {@return legal} text {@return illegal} **\/\n+                             ^\n+ReturnTest.java:26: warning: {@return} not at beginning of description\n+    \/** {@return legal} text {@return illegal} **\/\n+                             ^\n+6 warnings\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/doclint\/ReturnTest.out","additions":19,"deletions":0,"binary":false,"changes":19,"status":"added"},{"patch":"@@ -12,1 +12,1 @@\n-    public void m0() {}\n+    public void m_legal() {}\n@@ -15,1 +15,10 @@\n-    public void m1() {}\n+    public void m_illegal_html() {}\n+\n+    \/** text {@summary illegal} **\/\n+    public void m_illegal_text() {}\n+\n+    \/** &amp;{@summary illegal} **\/\n+    public void m_illegal_entity() {}\n+\n+    \/** @@{@summary illegal} **\/\n+    public void m_illegal_escape() {}\n@@ -18,1 +27,1 @@\n-    public void m2() {}\n+    public void m_illegal_repeat() {}\n","filename":"test\/langtools\/tools\/doclint\/SummaryTest.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -5,0 +5,9 @@\n+    \/** text {@summary illegal} **\/\n+             ^\n+SummaryTest.java:20: warning: invalid use of @summary\n+    \/** &amp;{@summary illegal} **\/\n+             ^\n+SummaryTest.java:23: warning: invalid use of @summary\n+    \/** @@{@summary illegal} **\/\n+          ^\n+SummaryTest.java:26: warning: invalid use of @summary\n@@ -7,1 +16,1 @@\n-2 warnings\n+5 warnings\n","filename":"test\/langtools\/tools\/doclint\/SummaryTest.out","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-InnerNamedConstant_2.java:26:13: compiler.err.cant.assign.val.to.final.var: z\n+InnerNamedConstant_2.java:26:13: compiler.err.cant.assign.val.to.var: static final, z\n","filename":"test\/langtools\/tools\/javac\/InnerNamedConstant_2_A.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-InnerNamedConstant_2.java:26:13: compiler.err.cant.assign.val.to.final.var: z\n+InnerNamedConstant_2.java:26:13: compiler.err.cant.assign.val.to.var: static final, z\n","filename":"test\/langtools\/tools\/javac\/InnerNamedConstant_2_B.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,2 +1,2 @@\n-StoreClass.java:12:19: compiler.err.cant.assign.val.to.final.var: class\n-StoreClass.java:13:12: compiler.err.cant.assign.val.to.final.var: class\n+StoreClass.java:12:19: compiler.err.cant.assign.val.to.var: static final, class\n+StoreClass.java:13:12: compiler.err.cant.assign.val.to.var: static final, class\n","filename":"test\/langtools\/tools\/javac\/StoreClass.out","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8301025\n+ * @enablePreview\n+ * @compile T8301025.java\n+ * @summary ClassCastException in switch with generic record\n+ * @modules jdk.compiler\n+ *\/\n+public class T8301025 {\n+    record TestRecord<T extends String>(T t) {}\n+\n+    public static void main(String argv[]) {\n+        TestRecord r = new TestRecord(\"a\");\n+        switch (r) {\n+            case TestRecord(String cS)-> {\n+                System.out.println(\"String\");\n+            }\n+            case TestRecord(Object cO)->{\n+                System.out.println(\"Object\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/T8301025.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -3,1 +3,1 @@\n-BadTwr.java:20:13: compiler.err.cant.assign.val.to.final.var: thatsIt\n+BadTwr.java:20:13: compiler.err.cant.assign.val.to.var: final, thatsIt\n","filename":"test\/langtools\/tools\/javac\/TryWithResources\/BadTwr.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-\/\/ key: compiler.err.cant.assign.val.to.final.var\n+\/\/ key: compiler.err.cant.assign.val.to.var\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantAssignToFinal.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8300914\n+ * @summary Allow `@` as an escape in documentation comments\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.file\n+ *          jdk.compiler\/com.sun.tools.javac.tree\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build DocCommentTester\n+ * @run main DocCommentTester AtEscapeTest.java\n+ *\/\n+\n+class AtEscapeTest {\n+    \/**\n+     * abc\n+     * @@tag\n+     * def\n+     *\/\n+    void escape_block_tag() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:1\n+  firstSentence: 3\n+    Text[TEXT, pos:1, abc|_]\n+    Escape[ESCAPE, pos:6, @]\n+    Text[TEXT, pos:8, tag|_def]\n+  body: empty\n+  block tags: empty\n+]\n+*\/\n+\n+    \/**\n+     * abc {@@tag} def\n+     *\/\n+    void escape_inline_tag() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:1\n+  firstSentence: 3\n+    Text[TEXT, pos:1, abc_{]\n+    Escape[ESCAPE, pos:6, @]\n+    Text[TEXT, pos:8, tag}_def]\n+  body: empty\n+  block tags: empty\n+]\n+*\/\n+\n+    \/**\n+     * abc \/* def *@\/ ghi\n+     *\/\n+    void escape_end_comment() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:1\n+  firstSentence: 3\n+    Text[TEXT, pos:1, abc_\/*_def_*]\n+    Escape[ESCAPE, pos:13, \/]\n+    Text[TEXT, pos:15, _ghi]\n+  body: empty\n+  block tags: empty\n+]\n+*\/\n+    \/**\n+     abc\n+     @* def\n+     ghi\n+     *\/\n+    void escape_asterisk() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:5\n+  firstSentence: 3\n+    Text[TEXT, pos:5, abc|_____]\n+    Escape[ESCAPE, pos:14, *]\n+    Text[TEXT, pos:16, _def|_____ghi]\n+  body: empty\n+  block tags: empty\n+]\n+*\/\n+\n+    \/**\n+     * abc.\n+     * not an escaped tag @@tag;\n+     * xyz.\n+     *\/\n+    void not_escaped_tag() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:1\n+  firstSentence: 1\n+    Text[TEXT, pos:1, abc.]\n+  body: 1\n+    Text[TEXT, pos:7, not_an_escaped_tag_@@tag;|_xyz.]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/**\n+     * abc.\n+     * not an escaped asterisk @*;\n+     * xyz.\n+     *\/\n+    void not_escaped_asterisk() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:1\n+  firstSentence: 1\n+    Text[TEXT, pos:1, abc.]\n+  body: 1\n+    Text[TEXT, pos:7, not_an_escaped_asterisk_@*;|_xyz.]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/**\n+     * abc.\n+     * not an escaped solidus @\/.\n+     * xyz.\n+     *\/\n+    void not_escaped_solidus() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:1\n+  firstSentence: 1\n+    Text[TEXT, pos:1, abc.]\n+  body: 1\n+    Text[TEXT, pos:7, not_an_escaped_solidus_@\/.|_xyz.]\n+  block tags: empty\n+]\n+*\/\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/doctree\/AtEscapeTest.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -131,1 +131,1 @@\n-    Literal[CODE, pos:6, |_____@Override|..._____void_m()_{_}|_]\n+    Literal[CODE, pos:6, |_____@Override|_____void_m()_{_}|_]\n@@ -161,1 +161,1 @@\n-      body: {@code_if_(a_<_b...)_{_}|_@author_jjg\n+      body: {@code_if_(a_<_b)_{_}|_@author_jjg\n","filename":"test\/langtools\/tools\/javac\/doctree\/CodeTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -465,0 +465,5 @@\n+            public Void visitEscape(EscapeTree node, Void p) {\n+                header(node, node.getBody());\n+                return null;\n+            }\n+\n@@ -807,0 +812,4 @@\n+            private static final int BEGIN = 32;\n+            private static final String ELLIPSIS = \"...\";\n+            private static final int END = 32;\n+\n@@ -809,1 +818,1 @@\n-                return (s.length() < 32)\n+                return (s.length() < BEGIN + ELLIPSIS.length() + END)\n@@ -811,1 +820,1 @@\n-                        : s.substring(0, 16) + \"...\" + s.substring(16);\n+                        : s.substring(0, BEGIN) + ELLIPSIS + s.substring(s.length() - END);\n@@ -932,1 +941,1 @@\n-            String s2 = s.trim().replaceFirst(\"\\\\.\\\\s*\\\\n *@\", \".\\n@\");\n+            String s2 = s.trim().replaceFirst(\"\\\\.\\\\s*\\\\n *@(?![@*])\", \".\\n@\");\n@@ -951,1 +960,1 @@\n-            return s.replaceAll(\"\\n[ \\t]+@\", \"\\n@\");\n+            return s.replaceAll(\"\\n[ \\t]+@(?![@*])\", \"\\n@\");\n","filename":"test\/langtools\/tools\/javac\/doctree\/DocCommentTester.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-        Reference[REFERENCE, pos:17, java.lang.String...#substring(int,_int)]\n+        Reference[REFERENCE, pos:17, java.lang.String#substring(int,_int)]\n","filename":"test\/langtools\/tools\/javac\/doctree\/LinkPlainTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-        Reference[REFERENCE, pos:12, java.lang.String...#substring(int,_int)]\n+        Reference[REFERENCE, pos:12, java.lang.String#substring(int,_int)]\n","filename":"test\/langtools\/tools\/javac\/doctree\/LinkTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-      body: {@literal_if_(a_...<_b)_{_}|_@author_jjg\n+      body: {@literal_if_(a_<_b)_{_}|_@author_jjg\n","filename":"test\/langtools\/tools\/javac\/doctree\/LiteralTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -154,1 +154,1 @@\n-        Reference[REFERENCE, pos:12, java.lang.String...#matches(String_regex)]\n+        Reference[REFERENCE, pos:12, java.lang.String#matches(String_regex)]\n","filename":"test\/langtools\/tools\/javac\/doctree\/SeeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-      body: @serialField_fie...ld_String#member_f3_is_a_String\n+      body: @serialField_field_String#member_f3_is_a_String\n@@ -104,1 +104,1 @@\n-      body: @serialField_fie...ld_String##fragment_f4_is_a_String\n+      body: @serialField_field_String##fragment_f4_is_a_String\n","filename":"test\/langtools\/tools\/javac\/doctree\/SerialFieldTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 7021614 8078320 8273244 8284908 8301201\n+ * @bug 7021614 8078320 8273244 8284908 8301201 8301813\n@@ -96,1 +96,1 @@\n-    Erroneous[ERRONEOUS, pos:1, prefPos:5\n+    Erroneous[ERRONEOUS, pos:1, prefPos:2\n@@ -144,1 +144,1 @@\n-    Erroneous[ERRONEOUS, pos:1, prefPos:2\n+    Erroneous[ERRONEOUS, pos:1, prefPos:3\n","filename":"test\/langtools\/tools\/javac\/doctree\/TagTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-      body: @throws_Exceptio...n##fragment_text\n+      body: @throws_Exception##fragment_text\n","filename":"test\/langtools\/tools\/javac\/doctree\/ThrowableTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -174,1 +174,1 @@\n-      body: {@value_\"%d\"_jav...a.awt.Color#RED_j\n+      body: {@value_\"%d\"_java.awt.Color#RED_j\n@@ -210,1 +210,1 @@\n-      body: {@value_java.awt....Color##fragment\n+      body: {@value_java.awt.Color##fragment\n","filename":"test\/langtools\/tools\/javac\/doctree\/ValueTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -19,1 +19,1 @@\n-    Text[TEXT, pos:59, A_simple_well_fo...rmed_html_document]\n+    Text[TEXT, pos:59, A_simple_well_formed_html_document]\n","filename":"test\/langtools\/tools\/javac\/doctree\/dcapi\/overview0.html.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-    Text[TEXT, pos:104, Illegal_second_b...ody_pair,_the_first_body_should_not_be_ignored.|]\n+    Text[TEXT, pos:104, Illegal_second_body_pair,_the_first_body_should_not_be_ignored.|]\n","filename":"test\/langtools\/tools\/javac\/doctree\/dcapi\/overview6.html.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-    DocType[DOC_TYPE, pos:10, HTML_PUBLIC_\"-\/\/...W3C\/\/DTD_HTML_4.01\/\/EN\"|________\"http:\/\/www.w3.org\/TR\/html4\/strict.dtd\"]\n+    DocType[DOC_TYPE, pos:10, HTML_PUBLIC_\"-\/\/W3C\/\/DTD_HTML_4....\/www.w3.org\/TR\/html4\/strict.dtd\"]\n@@ -26,1 +26,1 @@\n-    Text[TEXT, pos:192, A_simple_well_fo...rmed_html_document]\n+    Text[TEXT, pos:192, A_simple_well_formed_html_document]\n","filename":"test\/langtools\/tools\/javac\/doctree\/dcapi\/package.html.out","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -19,1 +19,1 @@\n-    Text[TEXT, pos:60, A_simple_well_fo...rmed_html_document]\n+    Text[TEXT, pos:60, A_simple_well_formed_html_document]\n","filename":"test\/langtools\/tools\/javac\/doctree\/dcapi\/pkg\/package.html.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -869,5 +869,1 @@\n-    \/*\n-     * The following tests do not work just yet with nb-javac nor javac,\n-     * they need further investigation, see CR: 7167356\n-     *\/\n-\n+    @Test\n@@ -913,0 +909,1 @@\n+    @Test\n@@ -954,0 +951,1 @@\n+    @Test\n@@ -967,1 +965,1 @@\n-        assertEquals(\"testStartPositionEnumConstantInit\", -1, start);\n+        assertEquals(\"testStartPositionEnumConstantInit\", 23, start);\n","filename":"test\/langtools\/tools\/javac\/parser\/JavacParserTest.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-BindingsTest2.java:247:17: compiler.err.cant.assign.val.to.final.var: s\n+BindingsTest2.java:247:17: compiler.err.cant.assign.val.to.var: final, s\n","filename":"test\/langtools\/tools\/javac\/patterns\/BindingsTest2.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8291769\n+ * @bug 8291769 8301858\n@@ -46,0 +46,2 @@\n+        assertEquals(runCheckExpressionWithUnconditionalAndParams(new R1(42)), 1);\n+        assertEquals(runCheckExpressionWithUnconditionalAndParams(new R1(new Object())), 2);\n@@ -106,0 +108,11 @@\n+    public static int runCheckExpressionWithUnconditionalAndParams(R1 r) {\n+        switch (r) {\n+            case R1(Integer i):\n+                return meth_I(i);\n+            case R1(Object o):\n+                return meth_O(o);\n+        }\n+    }\n+    public static int meth_I(Integer i) { return 1; }\n+    public static int meth_O(Object o) { return 2;}\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/DeconstructionDesugaring.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2031,1 +2031,1 @@\n-        assertFail(\"compiler.err.cant.assign.val.to.final.var\",\n+        assertFail(\"compiler.err.cant.assign.val.to.var\",\n@@ -2040,1 +2040,1 @@\n-        assertFail(\"compiler.err.cant.assign.val.to.final.var\",\n+        assertFail(\"compiler.err.cant.assign.val.to.var\",\n","filename":"test\/langtools\/tools\/javac\/records\/RecordCompilationTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8301580\n+ * @summary Verify error recovery w.r.t. Attr\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.jdeps\/com.sun.tools.classfile\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main AttrRecovery\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import toolbox.JavacTask;\n+import toolbox.Task.Expect;\n+import toolbox.Task.OutputKind;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+\n+public class AttrRecovery extends TestRunner {\n+\n+    ToolBox tb;\n+\n+    public AttrRecovery() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        AttrRecovery t = new AttrRecovery();\n+        t.runTests();\n+    }\n+\n+    @Test\n+    public void testFlowExits() throws Exception {\n+        String code = \"\"\"\n+                      class C {\n+                          void build\n+                          {\n+                              return ;\n+                          }\n+                      }\n+                      \"\"\";\n+        Path curPath = Path.of(\".\");\n+        List<String> actual = new JavacTask(tb)\n+                .options(\"-XDrawDiagnostics\", \"-XDdev\", \"-XDshould-stop.at=FLOW\")\n+                .sources(code)\n+                .outdir(curPath)\n+                .run(Expect.FAIL)\n+                .getOutputLines(OutputKind.DIRECT);\n+\n+        List<String> expected = List.of(\n+                \"C.java:3:5: compiler.err.expected: '('\",\n+                \"C.java:4:9: compiler.err.ret.outside.meth\",\n+                \"2 errors\"\n+        );\n+\n+        if (!Objects.equals(actual, expected)) {\n+            error(\"Expected: \" + expected + \", but got: \" + actual);\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/recovery\/AttrRecovery.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8295019\n+ * @summary Cannot call a method with a parameter of a local class declared in a lambda\n+ * @compile TypeDeclarationInsideExpressionTest.java\n+ *\/\n+\n+class TypeDeclarationInsideExpressionTest {\n+    class LambdaTest {\n+        void run(Runnable r) {}\n+\n+        void m() {\n+            run(() -> {\n+                class C {\n+                    static void takeC(C c) {}\n+                    static C giveC() {\n+                        return null;\n+                    }\n+                }\n+                C.takeC(C.giveC());\n+\n+                record R() {\n+                    static void takeR(R r) {}\n+                    static R giveR() { return null; }\n+                }\n+                R.takeR(R.giveR());\n+\n+                interface I {\n+                    static void takeI(I i) {}\n+                    static I giveI() { return null; }\n+                }\n+                I.takeI(I.giveI());\n+\n+                enum E {\n+                    A;\n+                    static void takeE(E e) {}\n+                    static E giveE() { return null; }\n+                }\n+                E.takeE(E.giveE());\n+            });\n+        }\n+    }\n+\n+    class SwitchExprTest {\n+        void run(int i) {}\n+        void m(int o) {\n+            run(switch(o) {\n+                case 1 -> {\n+                    class C {\n+                        static int takeC(C c) { return 0; }\n+                        static C giveC() { return null; }\n+                    }\n+                    yield C.takeC(C.giveC());\n+                }\n+                case 2 -> {\n+                    record R() {\n+                        static int takeR(R r) { return 0; }\n+                        static R giveR() { return null; }\n+                    }\n+                    yield R.takeR(R.giveR());\n+                }\n+                case 3 -> {\n+                    interface I {\n+                        static int takeI(I i) { return 0; }\n+                        static I giveI() { return null; }\n+                    }\n+                    yield I.takeI(I.giveI());\n+                }\n+                case 4 -> {\n+                    enum E {\n+                        A;\n+                        static int takeE(E e) { return 0; }\n+                        static E giveE() { return null; }\n+                    }\n+                    yield E.takeE(E.giveE());\n+                }\n+                default -> throw new AssertionError();\n+            });\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/typeDeclarationInsideExpression\/TypeDeclarationInsideExpressionTest.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,2 +41,12 @@\n-     * returns true, or a specific waiting time elapses.  The waiting time\n-     * is 1 second scaled with the jtreg testing timeout factor.\n+     * returns true, or the waiting time elapses.  The waiting time\n+     * is 1 second scaled with the jtreg testing timeout factor. This method\n+     * is equivalent to calling {@link #waitFor(BooleanSupplier, long)\n+     * waitFor(booleanSupplier, Math.round(1000L * JTREG_TIMEOUT_FACTOR)}\n+     * where {@code JTREG_TIMEOUT_FACTOR} is the value of\n+     * \"test.timeout.factor\" system property.\n+     *\n+     * @apiNote If the given {@code booleanSupplier} is expected to never\n+     * return true, for example to check if an object that is expected\n+     * to be strongly reachable is still alive,\n+     * {@link #waitFor(BooleanSupplier, long)} can be used to specify\n+     * the timeout for the wait method to return.\n@@ -46,1 +56,2 @@\n-     *     if did not complete after the specific waiting time.\n+     *     if did not complete after the waiting time.\n+\n@@ -49,0 +60,18 @@\n+        return waitFor(booleanSupplier, Math.round(1000L * TIMEOUT_FACTOR));\n+    }\n+\n+    \/**\n+     * Causes the current thread to wait until the {@code booleanSupplier}\n+     * returns true, or the specified waiting time elapses.\n+     *\n+     * @apiNote If the given {@code booleanSupplier} is expected to never\n+     * return true, for example to check if an object that is expected\n+     * to be strongly reachable is still alive, this method can be used\n+     * to specify the timeout independent of the jtreg timeout factor.\n+     *\n+     * @param booleanSupplier boolean supplier\n+     * @param timeout the maximum time to wait, in milliseconds\n+     * @return true if the {@code booleanSupplier} returns true, or false\n+     *     if did not complete after the specified waiting time.\n+     *\/\n+    public static boolean waitFor(BooleanSupplier booleanSupplier, long timeout) {\n@@ -56,1 +85,1 @@\n-        int retries = (int)(Math.round(1000L * TIMEOUT_FACTOR) \/ 200);\n+        int retries = (int)(timeout \/ 200);\n","filename":"test\/lib\/jdk\/test\/lib\/util\/ForceGC.java","additions":34,"deletions":5,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+\/\/\n+\/\/ Copyright (c) 2023, Arm Limited. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\/\/\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.util.concurrent.TimeUnit;\n+import jdk.incubator.vector.*;\n+import org.openjdk.jmh.annotations.*;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class IndexInRangeBenchmark {\n+    @Param({\"7\", \"256\", \"259\", \"512\"})\n+    private int size;\n+\n+    private boolean[] mask;\n+\n+    private static final VectorSpecies<Byte> bspecies = VectorSpecies.ofLargestShape(byte.class);\n+    private static final VectorSpecies<Short> sspecies = VectorSpecies.ofLargestShape(short.class);\n+    private static final VectorSpecies<Integer> ispecies = VectorSpecies.ofLargestShape(int.class);\n+    private static final VectorSpecies<Long> lspecies = VectorSpecies.ofLargestShape(long.class);\n+    private static final VectorSpecies<Float> fspecies = VectorSpecies.ofLargestShape(float.class);\n+    private static final VectorSpecies<Double> dspecies = VectorSpecies.ofLargestShape(double.class);\n+\n+    @Setup(Level.Trial)\n+    public void Setup() {\n+        mask = new boolean[512];\n+    }\n+\n+    @Benchmark\n+    public void byteIndexInRange() {\n+        for (int i = 0; i < size; i += bspecies.length()) {\n+            var m = bspecies.indexInRange(i, size);\n+            m.intoArray(mask, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void shortIndexInRange() {\n+        for (int i = 0; i < size; i += sspecies.length()) {\n+            var m = sspecies.indexInRange(i, size);\n+            m.intoArray(mask, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void intIndexInRange() {\n+        for (int i = 0; i < size; i += ispecies.length()) {\n+            var m = ispecies.indexInRange(i, size);\n+            m.intoArray(mask, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void longIndexInRange() {\n+        for (int i = 0; i < size; i += lspecies.length()) {\n+            var m = lspecies.indexInRange(i, size);\n+            m.intoArray(mask, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void floatIndexInRange() {\n+        for (int i = 0; i < size; i += fspecies.length()) {\n+            var m = fspecies.indexInRange(i, size);\n+            m.intoArray(mask, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void doubleIndexInRange() {\n+        for (int i = 0; i < size; i += dspecies.length()) {\n+            var m = dspecies.indexInRange(i, size);\n+            m.intoArray(mask, i);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/IndexInRangeBenchmark.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"}]}