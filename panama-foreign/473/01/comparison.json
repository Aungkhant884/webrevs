{"files":[{"patch":"@@ -12,0 +12,21 @@\n+\n+---\n+About Project Panama\n+===================\n+This repository contains changes which aim at improving the interoperability between the Java programming language and native libraries, which is one of the main goals of Project Panama. More information can be found at: https:\/\/openjdk.java.net\/projects\/panama\/\n+\n+The Project Panama JBS dashboard can be found at: https:\/\/bugs.openjdk.java.net\/Dashboard.jspa?selectPageId=18412\n+\n+Early acccess (EA) binary snapshots can be found at: http:\/\/jdk.java.net\/panama\/\n+\n+About the panama-foreign repository\n+===================\n+This repository houses two main branches:\n+- **foreign-memaccess+abi**: Contains the developement of both the foreign memory access API ([JEP 393](https:\/\/openjdk.java.net\/jeps\/393)) and the foreign linker API ([JEP 389](https:\/\/openjdk.java.net\/jeps\/389)). The former can be used to interact with different kinds of memory resources, including so-called off-heap or native memory. The latter can be used to call native code in a .dll\/.so\/.dylib, or to create a native function pointer to a Java method which can be passed to code in a native library. More information on how to use the memory access API and foreign linker API can be found [here](doc\/panama_ffi.md) and [here](doc\/panama_memaccess.md), respectively.\n+- **foreign-jextract**: Contains the development of an API to parse native headers, which can be used to create an abstract representation (declarations) from a C header file. This branch also provides an accompanying extraction tool (jextract), which is built on top of the API, and can be used to generate Java bindings to access functions and\/or structs in a native library described by a given header file. More information on how to use the jextract tool can be found [here](doc\/panama_jextract.md).\n+\n+The foreign-jextract branch depends on the foreign-memaccess+abi branch, which in turn depends on the master branch (which is kept periodically in sync with jdk\/jdk). As such, the foreign-jextract branch is the most complete of the three and therefore the default branch of this repository.\n+\n+Building notes\n+===================\n+Jextract requires [LLVM 9.x](https:\/\/releases.llvm.org\/download.html) as a dependency. So, to build the foreign-jextract branch, the flag `--with-libclang=\/path\/to\/llvm\/root` must be supplied when generating a build configuration. Please see [doc\/building.md](doc\/building.md) for general building instructions.\n","filename":"README.md","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,443 @@\n+<!DOCTYPE html>\n+<html xmlns=\"http:\/\/www.w3.org\/1999\/xhtml\" lang=\"\" xml:lang=\"\">\n+<head>\n+  <meta charset=\"utf-8\" \/>\n+  <meta name=\"generator\" content=\"pandoc\" \/>\n+  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, user-scalable=yes\" \/>\n+  <title>panama_ffi<\/title>\n+  <style type=\"text\/css\">\n+      code{white-space: pre-wrap;}\n+      span.smallcaps{font-variant: small-caps;}\n+      span.underline{text-decoration: underline;}\n+      div.column{display: inline-block; vertical-align: top; width: 50%;}\n+  <\/style>\n+  <style type=\"text\/css\">\n+a.sourceLine { display: inline-block; line-height: 1.25; }\n+a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }\n+a.sourceLine:empty { height: 1.2em; }\n+.sourceCode { overflow: visible; }\n+code.sourceCode { white-space: pre; position: relative; }\n+div.sourceCode { margin: 1em 0; }\n+pre.sourceCode { margin: 0; }\n+@media screen {\n+div.sourceCode { overflow: auto; }\n+}\n+@media print {\n+code.sourceCode { white-space: pre-wrap; }\n+a.sourceLine { text-indent: -1em; padding-left: 1em; }\n+}\n+pre.numberSource a.sourceLine\n+  { position: relative; left: -4em; }\n+pre.numberSource a.sourceLine::before\n+  { content: attr(title);\n+    position: relative; left: -1em; text-align: right; vertical-align: baseline;\n+    border: none; pointer-events: all; display: inline-block;\n+    -webkit-touch-callout: none; -webkit-user-select: none;\n+    -khtml-user-select: none; -moz-user-select: none;\n+    -ms-user-select: none; user-select: none;\n+    padding: 0 4px; width: 4em;\n+    color: #aaaaaa;\n+  }\n+pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }\n+div.sourceCode\n+  {  }\n+@media screen {\n+a.sourceLine::before { text-decoration: underline; }\n+}\n+code span.al { color: #ff0000; font-weight: bold; } \/* Alert *\/\n+code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } \/* Annotation *\/\n+code span.at { color: #7d9029; } \/* Attribute *\/\n+code span.bn { color: #40a070; } \/* BaseN *\/\n+code span.bu { } \/* BuiltIn *\/\n+code span.cf { color: #007020; font-weight: bold; } \/* ControlFlow *\/\n+code span.ch { color: #4070a0; } \/* Char *\/\n+code span.cn { color: #880000; } \/* Constant *\/\n+code span.co { color: #60a0b0; font-style: italic; } \/* Comment *\/\n+code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } \/* CommentVar *\/\n+code span.do { color: #ba2121; font-style: italic; } \/* Documentation *\/\n+code span.dt { color: #902000; } \/* DataType *\/\n+code span.dv { color: #40a070; } \/* DecVal *\/\n+code span.er { color: #ff0000; font-weight: bold; } \/* Error *\/\n+code span.ex { } \/* Extension *\/\n+code span.fl { color: #40a070; } \/* Float *\/\n+code span.fu { color: #06287e; } \/* Function *\/\n+code span.im { } \/* Import *\/\n+code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } \/* Information *\/\n+code span.kw { color: #007020; font-weight: bold; } \/* Keyword *\/\n+code span.op { color: #666666; } \/* Operator *\/\n+code span.ot { color: #007020; } \/* Other *\/\n+code span.pp { color: #bc7a00; } \/* Preprocessor *\/\n+code span.sc { color: #4070a0; } \/* SpecialChar *\/\n+code span.ss { color: #bb6688; } \/* SpecialString *\/\n+code span.st { color: #4070a0; } \/* String *\/\n+code span.va { color: #19177c; } \/* Variable *\/\n+code span.vs { color: #4070a0; } \/* VerbatimString *\/\n+code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } \/* Warning *\/\n+  <\/style>\n+  <link rel=\"stylesheet\" href=\"..\/make\/data\/docs-resources\/resources\/jdk-default.css\" \/>\n+<\/head>\n+<body>\n+<nav id=\"TOC\">\n+<ul>\n+<li><a href=\"#state-of-foreign-function-support\">State of foreign function support<\/a><ul>\n+<li><a href=\"#native-addresses\">Native addresses<\/a><\/li>\n+<li><a href=\"#symbol-lookups\">Symbol lookups<\/a><\/li>\n+<li><a href=\"#c-linker\">C Linker<\/a><\/li>\n+<li><a href=\"#downcalls\">Downcalls<\/a><\/li>\n+<li><a href=\"#upcalls\">Upcalls<\/a><\/li>\n+<li><a href=\"#native-scope\">Native scope<\/a><\/li>\n+<li><a href=\"#varargs\">Varargs<\/a><\/li>\n+<li><a href=\"#appendix-full-source-code\">Appendix: full source code<\/a><\/li>\n+<\/ul><\/li>\n+<\/ul>\n+<\/nav>\n+<h2 id=\"state-of-foreign-function-support\">State of foreign function support<\/h2>\n+<p><strong>October 2020<\/strong><\/p>\n+<ul>\n+<li>Adjust reference to NativeScope handoff<\/li>\n+<li>Tweak references to restricted segments to use new API<\/li>\n+<li>Tweak signature of LibraryLookup::lookup<\/li>\n+<li>Replaced usages of ForeignLinker with CLinker, as per new API<\/li>\n+<\/ul>\n+<p><strong>Maurizio Cimadamore<\/strong><\/p>\n+<p>In this document we explore the main concepts behind Panama's foreign function support; as we shall see, the central abstraction in the foreign function support is the so called <em>foreign linker<\/em>, an abstraction that allows clients to construct <em>native<\/em> method handles — that is, method handles whose invocation targets a native function defined in some native library. As we shall see, Panama foreign function support is completely expressed in terms of Java code and no intermediate native code is required.<\/p>\n+<h3 id=\"native-addresses\">Native addresses<\/h3>\n+<p>Before we dive into the specifics of the foreign function support, it would be useful to briefly recap some of the main concepts we have learned when exploring the <a href=\"http:\/\/cr.openjdk.java.net\/~mcimadamore\/panama\/foreign-memaccess.html\">foreign memory access support<\/a>. The Foreign Memory Access API allows client to create and manipulate <em>memory segments<\/em>. A memory segment is a view over a memory source (either on- or off-heap) which is spatially bounded, temporally bounded and thread-confined. The guarantees ensure that dereferencing a segment that has been created by Java code is always <em>safe<\/em>, and can never result in a VM crash, or, worse, in silent memory corruption.<\/p>\n+<p>Now, in the case of memory segments, the above properties (spatial bounds, temporal bounds and confinement) can be known <em>in full<\/em> when the segment is created. But when we interact with native libraries we will often be receiving <em>raw<\/em> pointers; such pointers have no spatial bounds (does a <code>char*<\/code> in C refer to one <code>char<\/code>, or a <code>char<\/code> array of a given size?), no notion of temporal bounds, nor thread-confinement. Raw addresses in our interop support are modelled using the <code>MemoryAddress<\/code> abstraction.<\/p>\n+<p>A memory address is just what the name implies: it encapsulates a memory address (either on- or off-heap). Since, in order to dereference memory using a memory access var handle, we need a segment, it follows that it is <em>not<\/em> possible to directly dereference a memory address — to do that we need a segment first. So clients can proceed in three different ways here.<\/p>\n+<p>First, if the memory address is known to belong to a segment the client <em>already<\/em> owns, a <em>rebase<\/em> operation can be performed; in other words, the client can ask the address what is its offset relative to a given segment, and then proceed to dereference the original segment accordingly:<\/p>\n+<div class=\"sourceCode\" id=\"cb1\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb1-1\" title=\"1\">MemorySegment segment = MemorySegment.<span class=\"fu\">allocateNative<\/span>(<span class=\"dv\">100<\/span>);<\/a>\n+<a class=\"sourceLine\" id=\"cb1-2\" title=\"2\">...<\/a>\n+<a class=\"sourceLine\" id=\"cb1-3\" title=\"3\">MemoryAddress addr = <span class=\"kw\">... <\/span><span class=\"co\">\/\/obtain address from native code<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb1-4\" title=\"4\"><span class=\"dt\">int<\/span> x = MemoryAccess.<span class=\"fu\">getIntAtOffset<\/span>(segment, addr.<span class=\"fu\">segmentOffset<\/span>(segment));    <\/a><\/code><\/pre><\/div>\n+<p>Secondly, if the client does <em>not<\/em> have a segment which contains a given memory address, it can create one <em>unsafely<\/em>, using the <code>MemoryAddress::asSegmentRestricted<\/code>; this can also be useful to inject extra knowledge about spatial bounds which might be available in the native library the client is interacting with:<\/p>\n+<div class=\"sourceCode\" id=\"cb2\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb2-1\" title=\"1\">MemoryAddress addr = <span class=\"kw\">... <\/span><span class=\"co\">\/\/obtain address from native code<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb2-2\" title=\"2\">MemorySegment segment = addr.<span class=\"fu\">asSegmentRestricted<\/span>(<span class=\"dv\">100<\/span>);<\/a>\n+<a class=\"sourceLine\" id=\"cb2-3\" title=\"3\"><span class=\"dt\">int<\/span> x = MemoryAccess.<span class=\"fu\">getInt<\/span>(segment);<\/a><\/code><\/pre><\/div>\n+<p>Alternatively, the client can fall back to use the so called <em>everything<\/em> segment - that is, a primordial segment which covers the entire native heap. Since this segment is available as a constant, dereference can happen without the need of creating any additional segment instances:<\/p>\n+<div class=\"sourceCode\" id=\"cb3\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb3-1\" title=\"1\">MemoryAddress addr = <span class=\"kw\">... <\/span><span class=\"co\">\/\/obtain address from native code<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb3-2\" title=\"2\"><span class=\"dt\">int<\/span> x = MemoryAccess.<span class=\"fu\">getIntAtOffset<\/span>(MemorySegment.<span class=\"fu\">ofNativeRestricted<\/span>(), addr.<span class=\"fu\">toRawLongValue<\/span>());<\/a><\/code><\/pre><\/div>\n+<p>Of course, since accessing the entire native heap is inherently <em>unsafe<\/em>, accessing the <em>everything<\/em> segment is considered a <em>restricted<\/em> operation which is only allowed after explicit opt in by setting the <code>foreign.restricted=permit<\/code> runtime flag.<\/p>\n+<p><code>MemoryAddress<\/code>, like <code>MemorySegment<\/code> , implements the <code>Addressable<\/code> interface, which is a functional interface whose method projects an entity down to a <code>MemoryAddress<\/code> instance. In the case of <code>MemoryAddress<\/code> such a projection is the identity function; in the case of a memory segment, the projection returns the <code>MemoryAddres<\/code> instance for the segment's base address. This abstraction allows to pass either memory address or memory segments where an address is expected (this is especially useful when generating native bindings).<\/p>\n+<h3 id=\"symbol-lookups\">Symbol lookups<\/h3>\n+<p>The first ingredient of any foreign function support is a mechanism to lookup symbols in native libraries. In traditional Java\/JNI, this is done via the <code>System::loadLibrary<\/code> and <code>System::load<\/code> methods, which internally map into calls to <code>dlopen<\/code>. In Panama, library lookups are modeled more directly, using a class called<code>LibraryLookup<\/code> (similar to a method handle lookup), which provides capabilities to lookup named symbols in a given native library; we can obtain a library lookup in 3 different ways:<\/p>\n+<ul>\n+<li><code>LibraryLookup::ofDefault<\/code> — returns the library lookup which can <em>see<\/em> all the symbols that have been loaded with the VM<\/li>\n+<li><code>LibraryLookup::ofPath<\/code> — creates a library lookup associated with the library found at the given absolute path<\/li>\n+<li><code>LibraryLookup::ofLibrary<\/code> — creates a library lookup associated with the library with given name (this might require setting the <code>java.library.path<\/code> variable accordingly)<\/li>\n+<\/ul>\n+<p>Once a lookup has been obtained, a client can use it to retrieve handles to library symbols (either global variables or functions) using the <code>lookup(String)<\/code> method, which returns an <code>Optional&lt;LibraryLookup.Symbol&gt;<\/code>. A lookup symbol is just a proxy for a memory address (in fact, it implements <code>Addressable<\/code>) and a name.<\/p>\n+<p>For instance, the following code can be used to lookup the <code>clang_getClangVersion<\/code> function provided by the <code>clang<\/code> library:<\/p>\n+<div class=\"sourceCode\" id=\"cb4\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb4-1\" title=\"1\">LibraryLookup libclang = LibraryLookup.<span class=\"fu\">ofLibrary<\/span>(<span class=\"st\">&quot;clang&quot;<\/span>);<\/a>\n+<a class=\"sourceLine\" id=\"cb4-2\" title=\"2\">LibraryLookup.<span class=\"fu\">Symbol<\/span> clangVersion = libclang.<span class=\"fu\">lookup<\/span>(<span class=\"st\">&quot;clang_getClangVersion&quot;<\/span>).<span class=\"fu\">get<\/span>();<\/a><\/code><\/pre><\/div>\n+<p>One crucial distinction between the library loading support of the Foreign Linker API and of JNI is that JNI libraries are loaded into a class loader. Furthermore, to preserve <a href=\"https:\/\/docs.oracle.com\/javase\/7\/docs\/technotes\/guides\/jni\/jni-12.html#libmanage\">classloader integrity<\/a> integrity, the same JNI library cannot be loaded into more than one classloader. The foreign function support described here is more primitive — the Foreign Linker API allows clients to target native libraries directly, without any intervening JNI code. Crucially, Java objects are never passed to and from native code by the Foreign Linker API. Because of this, libraries loaded through the <code>LibraryLookup<\/code> hook are not tied to any class loader and can be (re)loaded as many times as needed.<\/p>\n+<h3 id=\"c-linker\">C Linker<\/h3>\n+<p>At the core of Panama foreign function support we find the <code>CLinker<\/code> abstraction. This abstraction plays a dual role: first, for downcalls, it allows to model native function calls as plain <code>MethodHandle<\/code> calls (see <code>ForeignLinker::downcallHandle<\/code>); second, for upcalls, it allows to convert an existing <code>MethodHandle<\/code> (which might point to some Java method) into a <code>MemorySegment<\/code> which could then be passed to native functions as a function pointer (see <code>ForeignLinker::upcallStub<\/code>):<\/p>\n+<div class=\"sourceCode\" id=\"cb5\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb5-1\" title=\"1\"><span class=\"kw\">interface<\/span> CLinker {<\/a>\n+<a class=\"sourceLine\" id=\"cb5-2\" title=\"2\">    MethodHandle <span class=\"fu\">downcallHandle<\/span>(Addressable func, MethodType type, FunctionDescriptor function);<\/a>\n+<a class=\"sourceLine\" id=\"cb5-3\" title=\"3\">    MemorySegment <span class=\"fu\">upcallStub<\/span>(MethodHandle target, FunctionDescriptor function);<\/a>\n+<a class=\"sourceLine\" id=\"cb5-4\" title=\"4\">    ...<\/a>\n+<a class=\"sourceLine\" id=\"cb5-5\" title=\"5\">    <span class=\"dt\">static<\/span> CLinker <span class=\"fu\">getInstance<\/span>() { <span class=\"kw\">... <\/span>}<\/a>\n+<a class=\"sourceLine\" id=\"cb5-6\" title=\"6\">}<\/a><\/code><\/pre><\/div>\n+<p>In the following sections we will dive deeper into how downcall handles and upcall stubs are created; here we want to focus on the similarities between these two routines. First, both take a <code>FunctionDescriptor<\/code> instance — essentially an aggregate of memory layouts which is used to describe the signature of a foreign function in full. Speaking of C, the <code>CLinker<\/code> class defines many layout constants (one for each main C primitive type) — these layouts can be combined using a <code>FunctionDescriptor<\/code> to describe the signature of a C function. For instance, assuming we have a C function taking a <code>char*<\/code> and returning a <code>long<\/code> we can model such a function with the following descriptor:<\/p>\n+<div class=\"sourceCode\" id=\"cb6\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb6-1\" title=\"1\">FunctionDescriptor func = FunctionDescriptor.<span class=\"fu\">of<\/span>(CLinker.<span class=\"fu\">C_LONG<\/span>, CLinker.<span class=\"fu\">C_POINTER<\/span>);<\/a><\/code><\/pre><\/div>\n+<p>The layouts used above will be mapped to the right layout according to the platform we are executing on. This also means that these layouts will be platform dependent and that e.g. <code>C_LONG<\/code> will be a 32 bit value layout on Windows, while being a 64-bit value on Linux.<\/p>\n+<p>Layouts defined in the <code>CLinker<\/code> class are not only handy, as they already model the C types we want to work on; they also contain hidden pieces of information which the foreign linker support uses in order to compute the calling sequence associated with a given function descriptor. For instance, the two C types <code>int<\/code> and <code>float<\/code> might share a similar memory layout (they both are expressed as 32 bit values), but are typically passed using different machine registers. The layout attributes attached to the C-specific layouts in the <code>CLinker<\/code> class ensures that arguments and return values are interpreted in the correct way.<\/p>\n+<p>Another similarity between <code>downcallHandle<\/code> and <code>upcallStub<\/code> is that they both accept (either directly, or indirectly) a <code>MethodType<\/code> instance. The method type describes the Java signatures that clients will be using when interacting with said downcall handles, or upcall stubs. The C linker implementation adds constraints on which layouts can be used with which Java carrier — for instance by enforcing that the size of the Java carrier is equal to that of the corresponding layout, or by making sure that certain layouts are associated with specific carriers. The following table shows the Java carrier vs. layout mappings enforced by the Linux\/macOS foreign linker implementation:<\/p>\n+<table>\n+<thead>\n+<tr class=\"header\">\n+<th>C layout<\/th>\n+<th>Java carrier<\/th>\n+<\/tr>\n+<\/thead>\n+<tbody>\n+<tr class=\"odd\">\n+<td><code>C_BOOL<\/code><\/td>\n+<td><code>byte<\/code><\/td>\n+<\/tr>\n+<tr class=\"even\">\n+<td><code>C_CHAR<\/code><\/td>\n+<td><code>byte<\/code><\/td>\n+<\/tr>\n+<tr class=\"odd\">\n+<td><code>C_SHORT<\/code><\/td>\n+<td><code>short<\/code><\/td>\n+<\/tr>\n+<tr class=\"even\">\n+<td><code>C_INT<\/code><\/td>\n+<td><code>int<\/code><\/td>\n+<\/tr>\n+<tr class=\"odd\">\n+<td><code>C_LONG<\/code><\/td>\n+<td><code>long<\/code><\/td>\n+<\/tr>\n+<tr class=\"even\">\n+<td><code>C_LONGLONG<\/code><\/td>\n+<td><code>long<\/code><\/td>\n+<\/tr>\n+<tr class=\"odd\">\n+<td><code>C_FLOAT<\/code><\/td>\n+<td><code>float<\/code><\/td>\n+<\/tr>\n+<tr class=\"even\">\n+<td><code>C_DOUBLE<\/code><\/td>\n+<td><code>double<\/code><\/td>\n+<\/tr>\n+<tr class=\"odd\">\n+<td><code>C_POINTER<\/code><\/td>\n+<td><code>MemoryAddress<\/code><\/td>\n+<\/tr>\n+<tr class=\"even\">\n+<td><code>GroupLayout<\/code><\/td>\n+<td><code>MemorySegment<\/code><\/td>\n+<\/tr>\n+<\/tbody>\n+<\/table>\n+<p>Aside from the mapping between primitive layout and primitive Java carriers (which might vary across platforms), it is important to note how all pointer layouts must correspond to a <code>MemoryAddress<\/code> carrier, whereas structs (whose layout is defined by a <code>GroupLayout<\/code>) must be associated with a <code>MemorySegment<\/code> carrier.<\/p>\n+<h3 id=\"downcalls\">Downcalls<\/h3>\n+<p>We will now look at how foreign functions can be called from Java using the foreign linker abstraction. Assume we wanted to call the following function from the standard C library:<\/p>\n+<div class=\"sourceCode\" id=\"cb7\"><pre class=\"sourceCode c\"><code class=\"sourceCode c\"><a class=\"sourceLine\" id=\"cb7-1\" title=\"1\"><span class=\"dt\">size_t<\/span> strlen(<span class=\"dt\">const<\/span> <span class=\"dt\">char<\/span> *s);<\/a><\/code><\/pre><\/div>\n+<p>In order to do that, we have to:<\/p>\n+<ul>\n+<li>lookup the <code>strlen<\/code> symbol<\/li>\n+<li><p>describe the signature of the C function using the layouts in the <code>CLinker<\/code> class<\/p><\/li>\n+<li>select a Java signature we want to <em>overlay<\/em> on the native function — this will be the signature that clients of the native method handles will interact with<\/li>\n+<li><p>create a <em>downcall<\/em> native method handle with the above information, using the standard C foreign linker<\/p><\/li>\n+<\/ul>\n+<p>Here's an example of how we might want to do that (a full listing of all the examples in this and subsequent sections will be provided in the <a href=\"#appendix:%20full-source-code\">appendix<\/a>):<\/p>\n+<div class=\"sourceCode\" id=\"cb8\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb8-1\" title=\"1\">MethodHandle strlen = CLinker.<span class=\"fu\">getInstance<\/span>().<span class=\"fu\">downcallHandle<\/span>(<\/a>\n+<a class=\"sourceLine\" id=\"cb8-2\" title=\"2\">        LibraryLookup.<span class=\"fu\">ofDefault<\/span>().<span class=\"fu\">lookup<\/span>(<span class=\"st\">&quot;strlen&quot;<\/span>).<span class=\"fu\">get<\/span>(),<\/a>\n+<a class=\"sourceLine\" id=\"cb8-3\" title=\"3\">        MethodType.<span class=\"fu\">methodType<\/span>(<span class=\"dt\">long<\/span>.<span class=\"fu\">class<\/span>, MemoryAddress.<span class=\"fu\">class<\/span>),<\/a>\n+<a class=\"sourceLine\" id=\"cb8-4\" title=\"4\">        FunctionDescriptor.<span class=\"fu\">of<\/span>(C_LONG, C_POINTER)<\/a>\n+<a class=\"sourceLine\" id=\"cb8-5\" title=\"5\">);<\/a><\/code><\/pre><\/div>\n+<p>Note that, since the function <code>strlen<\/code> is part of the standard C library, which is loaded with the VM, we can just use the default lookup to look it up. The rest is pretty straightforward — the only tricky detail is how to model <code>size_t<\/code>: typically this type has the size of a pointer, so we can use <code>C_LONG<\/code> on Linux, but we'd have to use <code>C_LONGLONG<\/code> on Windows. On the Java side, we model the <code>size_t<\/code> using a <code>long<\/code> and the pointer is modeled using a <code>MemoryAddress<\/code> parameter.<\/p>\n+<p>One we have obtained the downcall native method handle, we can just use it as any other method handle:<\/p>\n+<div class=\"sourceCode\" id=\"cb9\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb9-1\" title=\"1\"><span class=\"dt\">long<\/span> len = strlen.<span class=\"fu\">invokeExact<\/span>(CLinker.<span class=\"fu\">toCString<\/span>(<span class=\"st\">&quot;Hello&quot;<\/span>).<span class=\"fu\">address<\/span>()) <span class=\"co\">\/\/ 5<\/span><\/a><\/code><\/pre><\/div>\n+<p>Here we are using one of the helper methods in <code>CLinker<\/code> to convert a Java string into an off-heap memory segment which contains a <code>NULL<\/code> terminated C string. We then pass that segment to the method handle and retrieve our result in a Java <code>long<\/code>. Note how all this has been possible <em>without<\/em> any piece of intervening native code — all the interop code can be expressed in (low level) Java.<\/p>\n+<p>Now that we have seen the basics of how foreign function calls are supported in Panama, let's add some additional considerations. First, it is important to note that, albeit the interop code is written in Java, the above code can <em>not<\/em> be considered 100% safe. There are many arbitrary decisions to be made when setting up downcall method handles such as the one above, some of which might be obvious to us (e.g. how many parameters does the function take), but which cannot ultimately be verified by the Panama runtime. After all, a symbol in a dynamic library is, mostly a numeric offset and, unless we are using a shared library with debugging information, no type information is attached to a given library symbol. This means that, in this case, the Panama runtime has to <em>trust<\/em> our description of the <code>strlen<\/code> function. For this reason, access to the foreign linker is a restricted operation, which can only be performed if the runtime flag <code>foreign.restricted=permit<\/code> is passed on the command line of the Java launcher <a href=\"#1\"><sup>1<\/sup><\/a>.<\/p>\n+<p>Finally let's talk about the life-cycle of some of the entities involved here; first, as a downcall native handle wraps a lookup symbol, the library from which the symbol has been loaded will stay loaded until there are reachable downcall handles referring to one of its symbols; in the above example, this consideration is less important, given the use of the default lookup object, which can be assumed to stay alive for the entire duration of the application.<\/p>\n+<p>Certain functions might return pointers, or structs; it is important to realize that if a function returns a pointer (or a <code>MemoryAddress<\/code>), no life-cycle whatsoever is attached to that pointer. It is then up to the client to e.g. free the memory associated with that pointer, or do nothing (in case the library is responsible for the life-cycle of that pointer). If a library returns a struct by value, things are different, as a <em>fresh<\/em>, confined memory segment is allocated off-heap and returned to the callee. It is the responsibility of the callee to cleanup that struct's segment (using <code>MemorySegment::close<\/code>) <a href=\"#2\"><sup>2<\/sup><\/a>.<\/p>\n+<p>Performance-wise, the reader might ask how efficient calling a foreign function using a native method handle is; the answer is <em>very<\/em>. The JVM comes with some special support for native method handles, so that, if a give method handle is invoked many times (e.g, inside an <em>hot<\/em> loop), the JIT compiler might decide to just generate a snippet of assembly code required to call the native function, and execute that directly. In most cases, invoking native function this way is as efficient as doing so through JNI <a href=\"#3a\"><sup>3a<\/sup><\/a><a href=\"#3b\"><sup>3b<\/sup><\/a>.<\/p>\n+<h3 id=\"upcalls\">Upcalls<\/h3>\n+<p>Sometimes, it is useful to pass Java code as a function pointer to some native function; we can achieve that by using foreign linker support for upcalls. To demonstrate this, let's consider the following function from the C standard library:<\/p>\n+<div class=\"sourceCode\" id=\"cb10\"><pre class=\"sourceCode c\"><code class=\"sourceCode c\"><a class=\"sourceLine\" id=\"cb10-1\" title=\"1\"><span class=\"dt\">void<\/span> qsort(<span class=\"dt\">void<\/span> *base, <span class=\"dt\">size_t<\/span> nmemb, <span class=\"dt\">size_t<\/span> size,<\/a>\n+<a class=\"sourceLine\" id=\"cb10-2\" title=\"2\">           <span class=\"dt\">int<\/span> (*compar)(<span class=\"dt\">const<\/span> <span class=\"dt\">void<\/span> *, <span class=\"dt\">const<\/span> <span class=\"dt\">void<\/span> *));<\/a><\/code><\/pre><\/div>\n+<p>This is a function that can be used to sort the contents of an array, using a custom comparator function — <code>compar<\/code> — which is passed as a function pointer. To be able to call the <code>qsort<\/code> function from Java we have first to create a downcall native method handle for it:<\/p>\n+<div class=\"sourceCode\" id=\"cb11\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb11-1\" title=\"1\">MethodHandle qsort = CLinker.<span class=\"fu\">getInstance<\/span>().<span class=\"fu\">downcallHandle<\/span>(<\/a>\n+<a class=\"sourceLine\" id=\"cb11-2\" title=\"2\">        LibraryLookup.<span class=\"fu\">ofDefault<\/span>().<span class=\"fu\">lookup<\/span>(<span class=\"st\">&quot;qsort&quot;<\/span>).<span class=\"fu\">get<\/span>(),<\/a>\n+<a class=\"sourceLine\" id=\"cb11-3\" title=\"3\">        MethodType.<span class=\"fu\">methodType<\/span>(<span class=\"dt\">void<\/span>.<span class=\"fu\">class<\/span>, MemoryAddress.<span class=\"fu\">class<\/span>, <span class=\"dt\">long<\/span>.<span class=\"fu\">class<\/span>, <span class=\"dt\">long<\/span>.<span class=\"fu\">class<\/span>, MemoryAddress.<span class=\"fu\">class<\/span>),<\/a>\n+<a class=\"sourceLine\" id=\"cb11-4\" title=\"4\">        FunctionDescriptor.<span class=\"fu\">ofVoid<\/span>(C_POINTER, C_LONG, C_LONG, C_POINTER)<\/a>\n+<a class=\"sourceLine\" id=\"cb11-5\" title=\"5\">);<\/a><\/code><\/pre><\/div>\n+<p>As before, we use <code>C_LONG<\/code> and <code>long.class<\/code> to map the C <code>size_t<\/code> type, and we use <code>MemoryAddess.class<\/code> both for the first pointer parameter (the array pointer) and the last parameter (the function pointer).<\/p>\n+<p>This time, in order to invoke the <code>qsort<\/code> downcall handle, we need a <em>function pointer<\/em> to be passed as the last parameter; this is where the upcall support in foreign linker comes in handy, as it allows us to create a function pointer out of an existing method handle. First, let's write a function that can compare two int elements (passed as pointers):<\/p>\n+<div class=\"sourceCode\" id=\"cb12\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb12-1\" title=\"1\"><span class=\"kw\">class<\/span> Qsort {<\/a>\n+<a class=\"sourceLine\" id=\"cb12-2\" title=\"2\">    <span class=\"dt\">static<\/span> <span class=\"dt\">int<\/span> <span class=\"fu\">qsortCompare<\/span>(MemoryAddress addr1, MemoryAddress addr2) {<\/a>\n+<a class=\"sourceLine\" id=\"cb12-3\" title=\"3\">        <span class=\"kw\">return<\/span> MemoryAccess.<span class=\"fu\">getIntAtOffset<\/span>(MemorySegment.<span class=\"fu\">ofNativeRestricted<\/span>(), addr1.<span class=\"fu\">toRawLongValue<\/span>()) - <\/a>\n+<a class=\"sourceLine\" id=\"cb12-4\" title=\"4\">               MemoryAccess.<span class=\"fu\">getIntAtOffset<\/span>(MemorySegment.<span class=\"fu\">ofNativeRestricted<\/span>(), addr2.<span class=\"fu\">toRawLongValue<\/span>());<\/a>\n+<a class=\"sourceLine\" id=\"cb12-5\" title=\"5\">    }<\/a>\n+<a class=\"sourceLine\" id=\"cb12-6\" title=\"6\">}<\/a><\/code><\/pre><\/div>\n+<p>Here we can see that the function is performing some <em>unsafe<\/em> dereference of the pointer contents, by using the <em>everything<\/em> segment. Now let's create a method handle pointing to the comparator function above:<\/p>\n+<div class=\"sourceCode\" id=\"cb13\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb13-1\" title=\"1\">MethodHandle comparHandle = MethodHandles.<span class=\"fu\">lookup<\/span>()<\/a>\n+<a class=\"sourceLine\" id=\"cb13-2\" title=\"2\">                                         .<span class=\"fu\">findStatic<\/span>(Qsort.<span class=\"fu\">class<\/span>, <span class=\"st\">&quot;qsortCompare&quot;<\/span>,<\/a>\n+<a class=\"sourceLine\" id=\"cb13-3\" title=\"3\">                                                     MethodType.<span class=\"fu\">methodType<\/span>(<span class=\"dt\">int<\/span>.<span class=\"fu\">class<\/span>, MemoryAddress.<span class=\"fu\">class<\/span>, MemoryAddress.<span class=\"fu\">class<\/span>));<\/a><\/code><\/pre><\/div>\n+<p>Now that we have a method handle for our Java comparator function, we can create a function pointer, using the foreign linker upcall support — as for downcalls, we have to describe the signature of the foreign function pointer using the layouts in the <code>CLinker<\/code> class:<\/p>\n+<div class=\"sourceCode\" id=\"cb14\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb14-1\" title=\"1\">MemorySegment comparFunc = CLinker.<span class=\"fu\">getInstance<\/span>().<span class=\"fu\">upcallStub<\/span>(<\/a>\n+<a class=\"sourceLine\" id=\"cb14-2\" title=\"2\">    comparHandle,<\/a>\n+<a class=\"sourceLine\" id=\"cb14-3\" title=\"3\">    FunctionDescriptor.<span class=\"fu\">of<\/span>(C_INT, C_POINTER, C_POINTER)<\/a>\n+<a class=\"sourceLine\" id=\"cb14-4\" title=\"4\">);<\/a><\/code><\/pre><\/div>\n+<p>So, we finally have a memory segment — <code>comparFunc<\/code> — containing a stub that can be used to invoke our Java comparator function; this means we now have all we need to call the <code>qsort<\/code> downcall handle:<\/p>\n+<div class=\"sourceCode\" id=\"cb15\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb15-1\" title=\"1\">MemorySegment array = MemorySegment.<span class=\"fu\">allocateNative<\/span>(<span class=\"dv\">4<\/span> * <span class=\"dv\">10<\/span>);<\/a>\n+<a class=\"sourceLine\" id=\"cb15-2\" title=\"2\">array.<span class=\"fu\">copyFrom<\/span>(MemorySegment.<span class=\"fu\">ofArray<\/span>(<span class=\"kw\">new<\/span> <span class=\"dt\">int<\/span>[] { <span class=\"dv\">0<\/span>, <span class=\"dv\">9<\/span>, <span class=\"dv\">3<\/span>, <span class=\"dv\">4<\/span>, <span class=\"dv\">6<\/span>, <span class=\"dv\">5<\/span>, <span class=\"dv\">1<\/span>, <span class=\"dv\">8<\/span>, <span class=\"dv\">2<\/span>, <span class=\"dv\">7<\/span> }));<\/a>\n+<a class=\"sourceLine\" id=\"cb15-3\" title=\"3\">qsort.<span class=\"fu\">invokeExact<\/span>(array.<span class=\"fu\">address<\/span>(), <span class=\"dv\">10L<\/span>, <span class=\"dv\">4L<\/span>, comparFunc.<span class=\"fu\">address<\/span>());<\/a>\n+<a class=\"sourceLine\" id=\"cb15-4\" title=\"4\"><span class=\"dt\">int<\/span>[] sorted = array.<span class=\"fu\">toIntArray<\/span>(); <span class=\"co\">\/\/ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]<\/span><\/a><\/code><\/pre><\/div>\n+<p>The above code creates an off-heap array, then copies the contents of a Java array on it (we shall see in the next <a href=\"#native-scope\">section<\/a> ways to do that more succinctly), and then pass the array to the <code>qsort<\/code> handle, along with the comparator function we obtained from the foreign linker. As a side-effect, after the call, the contents of the off-heap array will be sorted (as instructed by our comparator function, written in Java). We can than extract a new Java array from the segment, which contains the sorted elements. This is a more advanced example, but one that shows how powerful the native interop support provided by the foreign linker abstraction is, allowing full bidirectional interop support between Java and native.<\/p>\n+<p>As before, we conclude with a quick note on life-cycle. First, the life-cycle of the upcall stub is tied to that of the segment returned by the foreign linker. When the segment is closed, the upcall is uninstalled from the VM and will no longer be a valid function pointer. Second, the life-cycle of structs (if any) passed by value to the Java upcall function is independent from that of the upcall <a href=\"#4\"><sup>4<\/sup><\/a>, so again the user will have to pay attention not to leak memory and to call <code>MemorySegment::close<\/code> on any segments obtained through an upcall.<\/p>\n+<h3 id=\"native-scope\">Native scope<\/h3>\n+<p>Idiomatic C code implicitly relies on stack allocation to allow for concise variable declarations; consider this example:<\/p>\n+<div class=\"sourceCode\" id=\"cb16\"><pre class=\"sourceCode c\"><code class=\"sourceCode c\"><a class=\"sourceLine\" id=\"cb16-1\" title=\"1\"><span class=\"dt\">void<\/span> foo(<span class=\"dt\">int<\/span> i, <span class=\"dt\">int<\/span> *size);<\/a>\n+<a class=\"sourceLine\" id=\"cb16-2\" title=\"2\"><\/a>\n+<a class=\"sourceLine\" id=\"cb16-3\" title=\"3\"><span class=\"dt\">int<\/span> size = <span class=\"dv\">5<\/span>;<\/a>\n+<a class=\"sourceLine\" id=\"cb16-4\" title=\"4\">foo(<span class=\"dv\">42<\/span>, &amp;size);<\/a><\/code><\/pre><\/div>\n+<p>Here the function <code>foo<\/code> takes an output parameter, a pointer to an <code>int<\/code> variable. Unfortunately (and we have seen part of that pain in the <code>qsort<\/code> example above), implementing this idiom in Panama is not straightforward:<\/p>\n+<div class=\"sourceCode\" id=\"cb17\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb17-1\" title=\"1\">MethodHandle foo = ...<\/a>\n+<a class=\"sourceLine\" id=\"cb17-2\" title=\"2\">MemorySegment size = MemorySegment.<span class=\"fu\">allocateNative<\/span>(C_INT);<\/a>\n+<a class=\"sourceLine\" id=\"cb17-3\" title=\"3\">MemoryAccess.<span class=\"fu\">setInt<\/span>(size, <span class=\"dv\">5<\/span>);<\/a>\n+<a class=\"sourceLine\" id=\"cb17-4\" title=\"4\">foo.<span class=\"fu\">invokeExact<\/span>(<span class=\"dv\">42<\/span>, size);<\/a><\/code><\/pre><\/div>\n+<p>There are a number of issues with the above code snippet:<\/p>\n+<ul>\n+<li>compared to the C code, it is very verbose<\/li>\n+<li>allocation is very slow compared to C; allocating the <code>size<\/code> variable now takes a full <code>malloc<\/code>, while in C the variable was simply stack-allocated<\/li>\n+<li>we end up with a standalone segment with its own temporal bounds, which will have to be <em>closed<\/em> later, to avoid leaks<\/li>\n+<\/ul>\n+<p>To address these problems, Panama provides a <code>NativeScope<\/code> abstraction, which can be used to group allocation so as to achieve superior allocation performance, but also so that groups of logically-related segments can share the same temporal bounds, and can therefore be closed at once (e.g. by using a single <em>try-with-resources<\/em> statement). With the help of native scopes, the above code can be rewritten as follows:<\/p>\n+<div class=\"sourceCode\" id=\"cb18\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb18-1\" title=\"1\"><span class=\"kw\">try<\/span> (NativeScope scope = NativeScope.<span class=\"fu\">unboundedScope<\/span>()) {<\/a>\n+<a class=\"sourceLine\" id=\"cb18-2\" title=\"2\">    MemorySegment size = scope.<span class=\"fu\">allocate<\/span>(C_INT, <span class=\"dv\">5<\/span>);<\/a>\n+<a class=\"sourceLine\" id=\"cb18-3\" title=\"3\">    foo.<span class=\"fu\">invokeExact<\/span>(<span class=\"dv\">42<\/span>, size);<\/a>\n+<a class=\"sourceLine\" id=\"cb18-4\" title=\"4\">}<\/a><\/code><\/pre><\/div>\n+<p>It's easy to see how this code improves over the former in many ways; first, native scopes have primitives to allocate <em>and<\/em> initialize the contents of a segment; secondly, native scope use more efficient allocation underneath, so that not every allocation request is turned into a <code>malloc<\/code> — in fact, if the size of memory to be used is known before hand, clients can also use the bounded variant of native scope, using the <code>NativeScope::boundedScope(long size)<\/code> factory <a href=\"#5\"><sup>5<\/sup><\/a>. Third, a native scope can be used as a single temporal bound for all the segments allocated within it: that is, if the code needs to instantiate other variables, it can keep doing so using the same scope — when the <em>try-with-resource<\/em> statement completes, all resources associated with the scope will be freed.<\/p>\n+<p>There are at least two cases where allocation of native resources occurs <em>outside<\/em> a native scope:<\/p>\n+<ul>\n+<li>structs segments returned by native calls (or passed to upcalls Java methods)<\/li>\n+<li>upcall stubs segments returned by the foreign linker<\/li>\n+<\/ul>\n+<p>In these cases, the API gives us a segment which feature <em>its own<\/em> temporal bounds — this is handy, as we can use the segment to control the lifecycle of the resource allocated by the foreign linker support; but it is also a bit unfortunate: if the surrounding code happens to already have a native scope, these new segments won't be able to interoperate with it, and a separate <em>try-with-resource<\/em> segment should be used.<\/p>\n+<p>To alleviate this problem, and allow <em>all<\/em> segments to be managed using the <em>same<\/em> native scope, the native scope API not only supports the ability to allocate <em>new<\/em> segments, but it also allows to take ownership of <em>existing<\/em> ones. To see an example of this, let's go back to our <code>qsort<\/code> example, and see how we can make it better by using native scopes:<\/p>\n+<div class=\"sourceCode\" id=\"cb19\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb19-1\" title=\"1\"><span class=\"kw\">try<\/span> (NativeScope scope = NativeScope.<span class=\"fu\">unboundedScope<\/span>()) {<\/a>\n+<a class=\"sourceLine\" id=\"cb19-2\" title=\"2\">    comparFunc = comparFunc.<span class=\"fu\">handoff<\/span>(scope);<\/a>\n+<a class=\"sourceLine\" id=\"cb19-3\" title=\"3\">    MemorySegment array = scope.<span class=\"fu\">allocateArray<\/span>(C_INT, <span class=\"kw\">new<\/span> <span class=\"dt\">int<\/span>[] { <span class=\"dv\">0<\/span>, <span class=\"dv\">9<\/span>, <span class=\"dv\">3<\/span>, <span class=\"dv\">4<\/span>, <span class=\"dv\">6<\/span>, <span class=\"dv\">5<\/span>, <span class=\"dv\">1<\/span>, <span class=\"dv\">8<\/span>, <span class=\"dv\">2<\/span>, <span class=\"dv\">7<\/span> });<\/a>\n+<a class=\"sourceLine\" id=\"cb19-4\" title=\"4\">    qsort.<span class=\"fu\">invokeExact<\/span>(array, <span class=\"dv\">10L<\/span>, <span class=\"dv\">4L<\/span>, comparFunc);<\/a>\n+<a class=\"sourceLine\" id=\"cb19-5\" title=\"5\">    <span class=\"dt\">int<\/span>[] sorted = array.<span class=\"fu\">toIntArray<\/span>(); <span class=\"co\">\/\/ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb19-6\" title=\"6\">}<\/a><\/code><\/pre><\/div>\n+<p>Not only native scope helps in making the allocation of the native array simpler (we no longer need to create an heap segment, and dump its contents onto the off-heap array); but we can also use the native scope as an <em>handoff target<\/em> for existing upcall stub segments. When we do that, we obtain a <em>new<\/em> segment, whose temporal bounds are the same as that of the native scope; the old segment will be killed and will no longer be usable. As with all segments returned by native scope, the new segment we get back will be non-closeable — the only way to close it is to close the native scope it belongs to.<\/p>\n+<p>In short, native scopes are a good way to manage the lifecycle of multiple, logically-related segments, and, despite their simplicity, they provide a fairly good usability and performance boost.<\/p>\n+<h3 id=\"varargs\">Varargs<\/h3>\n+<p>Some C functions are <em>variadic<\/em> and can take an arbitrary number of arguments. Perhaps the most common example of this is the <code>printf<\/code> function, defined in the C standard library:<\/p>\n+<div class=\"sourceCode\" id=\"cb20\"><pre class=\"sourceCode c\"><code class=\"sourceCode c\"><a class=\"sourceLine\" id=\"cb20-1\" title=\"1\"><span class=\"dt\">int<\/span> printf(<span class=\"dt\">const<\/span> <span class=\"dt\">char<\/span> *format, ...);<\/a><\/code><\/pre><\/div>\n+<p>This function takes a format string, which features zero or more <em>holes<\/em>, and then can take a number of additional arguments that is identical to the number of holes in the format string.<\/p>\n+<p>The foreign function support can support variadic calls, but with a caveat: the client must provide a specialized Java signature, and a specialized description of the C signature. For instance, let's say we wanted to model the following C call:<\/p>\n+<div class=\"sourceCode\" id=\"cb21\"><pre class=\"sourceCode c\"><code class=\"sourceCode c\"><a class=\"sourceLine\" id=\"cb21-1\" title=\"1\">printf(<span class=\"st\">&quot;%d plus %d equals %d&quot;<\/span>, <span class=\"dv\">2<\/span>, <span class=\"dv\">2<\/span>, <span class=\"dv\">4<\/span>);<\/a><\/code><\/pre><\/div>\n+<p>To do this using the foreign function support provided by Panama we would have to build a <em>specialized<\/em> downcall handle for that call shape <a href=\"#6\"><sup>6<\/sup><\/a>:<\/p>\n+<div class=\"sourceCode\" id=\"cb22\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb22-1\" title=\"1\">MethodHandle printf = CLinker.<span class=\"fu\">getInstance<\/span>().<span class=\"fu\">downcallHandle<\/span>(<\/a>\n+<a class=\"sourceLine\" id=\"cb22-2\" title=\"2\">        LibraryLookup.<span class=\"fu\">ofDefault<\/span>().<span class=\"fu\">lookup<\/span>(<span class=\"st\">&quot;printf&quot;<\/span>).<span class=\"fu\">get<\/span>(),<\/a>\n+<a class=\"sourceLine\" id=\"cb22-3\" title=\"3\">        MethodType.<span class=\"fu\">methodType<\/span>(<span class=\"dt\">int<\/span>.<span class=\"fu\">class<\/span>, MemoryAddress.<span class=\"fu\">class<\/span>, <span class=\"dt\">int<\/span>.<span class=\"fu\">class<\/span>, <span class=\"dt\">int<\/span>.<span class=\"fu\">class<\/span>, <span class=\"dt\">int<\/span>.<span class=\"fu\">class<\/span>),<\/a>\n+<a class=\"sourceLine\" id=\"cb22-4\" title=\"4\">        FunctionDescriptor.<span class=\"fu\">of<\/span>(C_INT, C_POINTER, C_INT, C_INT, C_INT)<\/a>\n+<a class=\"sourceLine\" id=\"cb22-5\" title=\"5\">);<\/a><\/code><\/pre><\/div>\n+<p>Then we can call the specialized downcall handle as usual:<\/p>\n+<div class=\"sourceCode\" id=\"cb23\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb23-1\" title=\"1\">printf.<span class=\"fu\">invoke<\/span>(CLinker.<span class=\"fu\">toCString<\/span>(<span class=\"st\">&quot;%d plus %d equals %d&quot;<\/span>).<span class=\"fu\">address<\/span>(), <span class=\"dv\">2<\/span>, <span class=\"dv\">2<\/span>, <span class=\"dv\">4<\/span>); <span class=\"co\">\/\/prints &quot;2 plus 2 equals 4&quot;<\/span><\/a><\/code><\/pre><\/div>\n+<p>While this works, it is easy to see how such an approach is not very desirable:<\/p>\n+<ul>\n+<li>If the variadic function needs to be called with many different shapes, we have to create many different downcall handles<\/li>\n+<li>while this approach works for downcalls (since the Java code is in charge of determining which and how many arguments should be passed) it fails to scale to upcalls; in that case, the call comes from native code, so we have no way to guarantee that the shape of the upcall stub we have created will match that required by the native function.<\/li>\n+<\/ul>\n+<p>To mitigate these issues, the standard C foreign linker comes equipped with support for C variable argument lists — or <code>va_list<\/code>. When a variadic function is called, C code has to unpack the variadic arguments by creating a <code>va_list<\/code> structure, and then accessing the variadic arguments through the <code>va_list<\/code> one by one (using the <code>va_arg<\/code> macro). To facilitate interop between standard variadic functions and <code>va_list<\/code> many C library functions in fact define <em>two<\/em> flavors of the same function, one using standard variadic signature, one using an extra <code>va_list<\/code> parameter. For instance, in the case of <code>printf<\/code> we can find that a <code>va_list<\/code>-accepting function performing the same task is also defined:<\/p>\n+<div class=\"sourceCode\" id=\"cb24\"><pre class=\"sourceCode c\"><code class=\"sourceCode c\"><a class=\"sourceLine\" id=\"cb24-1\" title=\"1\"><span class=\"dt\">int<\/span> vprintf(<span class=\"dt\">const<\/span> <span class=\"dt\">char<\/span> *format, <span class=\"dt\">va_list<\/span> ap);<\/a><\/code><\/pre><\/div>\n+<p>The behavior of this function is the same as before — the only difference is that the ellipsis notation <code>...<\/code> has been replaced with a single <code>va_list<\/code> parameter; in other words, the function is no longer variadic.<\/p>\n+<p>It is indeed fairly easy to create a downcall for <code>vprintf<\/code>:<\/p>\n+<div class=\"sourceCode\" id=\"cb25\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb25-1\" title=\"1\">MethodHandle vprintf = CLinker.<span class=\"fu\">getInstance<\/span>().<span class=\"fu\">downcallHandle<\/span>(<\/a>\n+<a class=\"sourceLine\" id=\"cb25-2\" title=\"2\">        LibraryLookup.<span class=\"fu\">ofDefault<\/span>().<span class=\"fu\">lookup<\/span>(<span class=\"st\">&quot;vprintf&quot;<\/span>).<span class=\"fu\">get<\/span>(),<\/a>\n+<a class=\"sourceLine\" id=\"cb25-3\" title=\"3\">        MethodType.<span class=\"fu\">methodType<\/span>(<span class=\"dt\">int<\/span>.<span class=\"fu\">class<\/span>, MemoryAddress.<span class=\"fu\">class<\/span>, VaList.<span class=\"fu\">class<\/span>),<\/a>\n+<a class=\"sourceLine\" id=\"cb25-4\" title=\"4\">        FunctionDescriptor.<span class=\"fu\">of<\/span>(C_INT, C_POINTER, C_VA_LIST));<\/a><\/code><\/pre><\/div>\n+<p>Here, the notable thing is that <code>CLinker<\/code> comes equipped with the special <code>C_VA_LIST<\/code> layout (the layout of a <code>va_list<\/code> parameter) as well as a <code>VaList<\/code> carrier, which can be used to construct and represent variable argument lists from Java code.<\/p>\n+<p>To call the <code>vprintf<\/code> handle we need to create an instance of <code>VaList<\/code> which contains the arguments we want to pass to the <code>vprintf<\/code> function — we can do so, as follows:<\/p>\n+<div class=\"sourceCode\" id=\"cb26\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb26-1\" title=\"1\">vprintf.<span class=\"fu\">invoke<\/span>(<\/a>\n+<a class=\"sourceLine\" id=\"cb26-2\" title=\"2\">        CLinker.<span class=\"fu\">toCString<\/span>(<span class=\"st\">&quot;%d plus %d equals %d&quot;<\/span>).<span class=\"fu\">address<\/span>(),<\/a>\n+<a class=\"sourceLine\" id=\"cb26-3\" title=\"3\">        VaList.<span class=\"fu\">make<\/span>(builder -&gt;<\/a>\n+<a class=\"sourceLine\" id=\"cb26-4\" title=\"4\">                        builder.<span class=\"fu\">vargFromInt<\/span>(C_INT, <span class=\"dv\">2<\/span>)<\/a>\n+<a class=\"sourceLine\" id=\"cb26-5\" title=\"5\">                               .<span class=\"fu\">vargFromInt<\/span>(C_INT, <span class=\"dv\">2<\/span>)<\/a>\n+<a class=\"sourceLine\" id=\"cb26-6\" title=\"6\">                               .<span class=\"fu\">vargFromInt<\/span>(C_INT, <span class=\"dv\">4<\/span>))<\/a>\n+<a class=\"sourceLine\" id=\"cb26-7\" title=\"7\">); <span class=\"co\">\/\/prints &quot;2 plus 2 equals 4&quot;<\/span><\/a><\/code><\/pre><\/div>\n+<p>While the callee has to do more work to call the <code>vprintf<\/code> handle, note that that now we're back in a place where the downcall handle <code>vprintf<\/code> can be shared across multiple callees. A <code>VaList<\/code> object created this way has its own lifetime (<code>VaList<\/code> also supports a <code>close<\/code> operation), so it is up to the callee to make sure that the <code>VaList<\/code> instance is closed (or attached to some existing native scope) so as to avoid leaks.<\/p>\n+<p>Another advantage of using <code>VaList<\/code> is that this approach also scales to upcall stubs — it is therefore possible for clients to create upcalls stubs which take a <code>VaList<\/code> and then, from the Java upcall, read the arguments packed inside the <code>VaList<\/code> one by one using the methods provided by the <code>VaList<\/code> API (e.g. <code>VaList::vargAsInt(MemoryLayout)<\/code>), which mimic the behavior of the C <code>va_arg<\/code> macro.<\/p>\n+<h3 id=\"appendix-full-source-code\">Appendix: full source code<\/h3>\n+<p>The full source code containing most of the code shown throughout this document can be seen below:<\/p>\n+<div class=\"sourceCode\" id=\"cb27\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb27-1\" title=\"1\"><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.Addressable;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb27-2\" title=\"2\"><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.CLinker;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb27-3\" title=\"3\"><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.FunctionDescriptor;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb27-4\" title=\"4\"><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.LibraryLookup;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb27-5\" title=\"5\"><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.MemoryAccess;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb27-6\" title=\"6\"><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.MemoryAddress;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb27-7\" title=\"7\"><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.MemorySegment;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb27-8\" title=\"8\"><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.NativeScope;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb27-9\" title=\"9\"><\/a>\n+<a class=\"sourceLine\" id=\"cb27-10\" title=\"10\"><span class=\"kw\">import<\/span><span class=\"im\"> java.lang.invoke.MethodHandle;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb27-11\" title=\"11\"><span class=\"kw\">import<\/span><span class=\"im\"> java.lang.invoke.MethodHandles;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb27-12\" title=\"12\"><span class=\"kw\">import<\/span><span class=\"im\"> java.lang.invoke.MethodType;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb27-13\" title=\"13\"><span class=\"kw\">import<\/span><span class=\"im\"> java.util.Arrays;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb27-14\" title=\"14\"><\/a>\n+<a class=\"sourceLine\" id=\"cb27-15\" title=\"15\"><span class=\"kw\">import static<\/span><span class=\"im\"> jdk.incubator.foreign.CLinker.*;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb27-16\" title=\"16\"><\/a>\n+<a class=\"sourceLine\" id=\"cb27-17\" title=\"17\"><span class=\"kw\">public<\/span> <span class=\"kw\">class<\/span> Examples {<\/a>\n+<a class=\"sourceLine\" id=\"cb27-18\" title=\"18\"><\/a>\n+<a class=\"sourceLine\" id=\"cb27-19\" title=\"19\">    <span class=\"kw\">public<\/span> <span class=\"dt\">static<\/span> <span class=\"dt\">void<\/span> <span class=\"fu\">main<\/span>(<span class=\"bu\">String<\/span>[] args) <span class=\"kw\">throws<\/span> <span class=\"bu\">Throwable<\/span> {<\/a>\n+<a class=\"sourceLine\" id=\"cb27-20\" title=\"20\">        <span class=\"fu\">strlen<\/span>();<\/a>\n+<a class=\"sourceLine\" id=\"cb27-21\" title=\"21\">        <span class=\"fu\">qsort<\/span>();<\/a>\n+<a class=\"sourceLine\" id=\"cb27-22\" title=\"22\">        <span class=\"fu\">printf<\/span>();<\/a>\n+<a class=\"sourceLine\" id=\"cb27-23\" title=\"23\">        <span class=\"fu\">vprintf<\/span>();<\/a>\n+<a class=\"sourceLine\" id=\"cb27-24\" title=\"24\">    }<\/a>\n+<a class=\"sourceLine\" id=\"cb27-25\" title=\"25\"><\/a>\n+<a class=\"sourceLine\" id=\"cb27-26\" title=\"26\">    <span class=\"kw\">public<\/span> <span class=\"dt\">static<\/span> <span class=\"dt\">void<\/span> <span class=\"fu\">strlen<\/span>() <span class=\"kw\">throws<\/span> <span class=\"bu\">Throwable<\/span> {<\/a>\n+<a class=\"sourceLine\" id=\"cb27-27\" title=\"27\">        MethodHandle strlen = CLinker.<span class=\"fu\">getInstance<\/span>().<span class=\"fu\">downcallHandle<\/span>(<\/a>\n+<a class=\"sourceLine\" id=\"cb27-28\" title=\"28\">                LibraryLookup.<span class=\"fu\">ofDefault<\/span>().<span class=\"fu\">lookup<\/span>(<span class=\"st\">&quot;strlen&quot;<\/span>).<span class=\"fu\">get<\/span>(),<\/a>\n+<a class=\"sourceLine\" id=\"cb27-29\" title=\"29\">                MethodType.<span class=\"fu\">methodType<\/span>(<span class=\"dt\">long<\/span>.<span class=\"fu\">class<\/span>, MemoryAddress.<span class=\"fu\">class<\/span>),<\/a>\n+<a class=\"sourceLine\" id=\"cb27-30\" title=\"30\">                FunctionDescriptor.<span class=\"fu\">of<\/span>(C_LONG, C_POINTER)<\/a>\n+<a class=\"sourceLine\" id=\"cb27-31\" title=\"31\">        );<\/a>\n+<a class=\"sourceLine\" id=\"cb27-32\" title=\"32\"><\/a>\n+<a class=\"sourceLine\" id=\"cb27-33\" title=\"33\">        <span class=\"kw\">try<\/span> (MemorySegment hello = CLinker.<span class=\"fu\">toCString<\/span>(<span class=\"st\">&quot;Hello&quot;<\/span>)) {<\/a>\n+<a class=\"sourceLine\" id=\"cb27-34\" title=\"34\">            <span class=\"dt\">long<\/span> len = (<span class=\"dt\">long<\/span>) strlen.<span class=\"fu\">invokeExact<\/span>(hello.<span class=\"fu\">address<\/span>()); <span class=\"co\">\/\/ 5<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb27-35\" title=\"35\">            <span class=\"bu\">System<\/span>.<span class=\"fu\">out<\/span>.<span class=\"fu\">println<\/span>(len);<\/a>\n+<a class=\"sourceLine\" id=\"cb27-36\" title=\"36\">        }<\/a>\n+<a class=\"sourceLine\" id=\"cb27-37\" title=\"37\">    }<\/a>\n+<a class=\"sourceLine\" id=\"cb27-38\" title=\"38\"><\/a>\n+<a class=\"sourceLine\" id=\"cb27-39\" title=\"39\">    <span class=\"dt\">static<\/span> <span class=\"kw\">class<\/span> Qsort {<\/a>\n+<a class=\"sourceLine\" id=\"cb27-40\" title=\"40\">        <span class=\"dt\">static<\/span> <span class=\"dt\">int<\/span> <span class=\"fu\">qsortCompare<\/span>(MemoryAddress addr1, MemoryAddress addr2) {<\/a>\n+<a class=\"sourceLine\" id=\"cb27-41\" title=\"41\">            <span class=\"dt\">int<\/span> v1 = MemoryAccess.<span class=\"fu\">getIntAtOffset<\/span>(MemorySegment.<span class=\"fu\">ofNativeRestricted<\/span>(), addr1.<span class=\"fu\">toRawLongValue<\/span>());<\/a>\n+<a class=\"sourceLine\" id=\"cb27-42\" title=\"42\">            <span class=\"dt\">int<\/span> v2 = MemoryAccess.<span class=\"fu\">getIntAtOffset<\/span>(MemorySegment.<span class=\"fu\">ofNativeRestricted<\/span>(), addr2.<span class=\"fu\">toRawLongValue<\/span>());<\/a>\n+<a class=\"sourceLine\" id=\"cb27-43\" title=\"43\">            <span class=\"kw\">return<\/span> v1 - v2;<\/a>\n+<a class=\"sourceLine\" id=\"cb27-44\" title=\"44\">        }<\/a>\n+<a class=\"sourceLine\" id=\"cb27-45\" title=\"45\">    }<\/a>\n+<a class=\"sourceLine\" id=\"cb27-46\" title=\"46\"><\/a>\n+<a class=\"sourceLine\" id=\"cb27-47\" title=\"47\">    <span class=\"kw\">public<\/span> <span class=\"dt\">static<\/span> <span class=\"dt\">void<\/span> <span class=\"fu\">qsort<\/span>() <span class=\"kw\">throws<\/span> <span class=\"bu\">Throwable<\/span> {<\/a>\n+<a class=\"sourceLine\" id=\"cb27-48\" title=\"48\">        MethodHandle qsort = CLinker.<span class=\"fu\">getInstance<\/span>().<span class=\"fu\">downcallHandle<\/span>(<\/a>\n+<a class=\"sourceLine\" id=\"cb27-49\" title=\"49\">                LibraryLookup.<span class=\"fu\">ofDefault<\/span>().<span class=\"fu\">lookup<\/span>(<span class=\"st\">&quot;qsort&quot;<\/span>).<span class=\"fu\">get<\/span>(),<\/a>\n+<a class=\"sourceLine\" id=\"cb27-50\" title=\"50\">                MethodType.<span class=\"fu\">methodType<\/span>(<span class=\"dt\">void<\/span>.<span class=\"fu\">class<\/span>, MemoryAddress.<span class=\"fu\">class<\/span>, <span class=\"dt\">long<\/span>.<span class=\"fu\">class<\/span>, <span class=\"dt\">long<\/span>.<span class=\"fu\">class<\/span>, MemoryAddress.<span class=\"fu\">class<\/span>),<\/a>\n+<a class=\"sourceLine\" id=\"cb27-51\" title=\"51\">                FunctionDescriptor.<span class=\"fu\">ofVoid<\/span>(C_POINTER, C_LONG, C_LONG, C_POINTER)<\/a>\n+<a class=\"sourceLine\" id=\"cb27-52\" title=\"52\">        );<\/a>\n+<a class=\"sourceLine\" id=\"cb27-53\" title=\"53\"><\/a>\n+<a class=\"sourceLine\" id=\"cb27-54\" title=\"54\">        MethodHandle comparHandle = MethodHandles.<span class=\"fu\">lookup<\/span>()<\/a>\n+<a class=\"sourceLine\" id=\"cb27-55\" title=\"55\">                .<span class=\"fu\">findStatic<\/span>(Qsort.<span class=\"fu\">class<\/span>, <span class=\"st\">&quot;qsortCompare&quot;<\/span>,<\/a>\n+<a class=\"sourceLine\" id=\"cb27-56\" title=\"56\">                        MethodType.<span class=\"fu\">methodType<\/span>(<span class=\"dt\">int<\/span>.<span class=\"fu\">class<\/span>, MemoryAddress.<span class=\"fu\">class<\/span>, MemoryAddress.<span class=\"fu\">class<\/span>));<\/a>\n+<a class=\"sourceLine\" id=\"cb27-57\" title=\"57\"><\/a>\n+<a class=\"sourceLine\" id=\"cb27-58\" title=\"58\">        MemorySegment comparFunc = CLinker.<span class=\"fu\">getInstance<\/span>().<span class=\"fu\">upcallStub<\/span>(<\/a>\n+<a class=\"sourceLine\" id=\"cb27-59\" title=\"59\">                comparHandle,<\/a>\n+<a class=\"sourceLine\" id=\"cb27-60\" title=\"60\">                FunctionDescriptor.<span class=\"fu\">of<\/span>(C_INT, C_POINTER, C_POINTER)<\/a>\n+<a class=\"sourceLine\" id=\"cb27-61\" title=\"61\">        );<\/a>\n+<a class=\"sourceLine\" id=\"cb27-62\" title=\"62\"><\/a>\n+<a class=\"sourceLine\" id=\"cb27-63\" title=\"63\">        <span class=\"kw\">try<\/span> (NativeScope scope = NativeScope.<span class=\"fu\">unboundedScope<\/span>()) {<\/a>\n+<a class=\"sourceLine\" id=\"cb27-64\" title=\"64\">            comparFunc = comparFunc.<span class=\"fu\">handoff<\/span>(scope);<\/a>\n+<a class=\"sourceLine\" id=\"cb27-65\" title=\"65\">            MemorySegment array = scope.<span class=\"fu\">allocateArray<\/span>(C_INT, <span class=\"kw\">new<\/span> <span class=\"dt\">int<\/span>[] { <span class=\"dv\">0<\/span>, <span class=\"dv\">9<\/span>, <span class=\"dv\">3<\/span>, <span class=\"dv\">4<\/span>, <span class=\"dv\">6<\/span>, <span class=\"dv\">5<\/span>, <span class=\"dv\">1<\/span>, <span class=\"dv\">8<\/span>, <span class=\"dv\">2<\/span>, <span class=\"dv\">7<\/span> });<\/a>\n+<a class=\"sourceLine\" id=\"cb27-66\" title=\"66\">            qsort.<span class=\"fu\">invokeExact<\/span>(array.<span class=\"fu\">address<\/span>(), <span class=\"dv\">10L<\/span>, <span class=\"dv\">4L<\/span>, comparFunc.<span class=\"fu\">address<\/span>());<\/a>\n+<a class=\"sourceLine\" id=\"cb27-67\" title=\"67\">            <span class=\"dt\">int<\/span>[] sorted = array.<span class=\"fu\">toIntArray<\/span>(); <span class=\"co\">\/\/ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb27-68\" title=\"68\">            <span class=\"bu\">System<\/span>.<span class=\"fu\">out<\/span>.<span class=\"fu\">println<\/span>(<span class=\"bu\">Arrays<\/span>.<span class=\"fu\">toString<\/span>(sorted));<\/a>\n+<a class=\"sourceLine\" id=\"cb27-69\" title=\"69\">        }<\/a>\n+<a class=\"sourceLine\" id=\"cb27-70\" title=\"70\">    }<\/a>\n+<a class=\"sourceLine\" id=\"cb27-71\" title=\"71\"><\/a>\n+<a class=\"sourceLine\" id=\"cb27-72\" title=\"72\">    <span class=\"kw\">public<\/span> <span class=\"dt\">static<\/span> <span class=\"dt\">void<\/span> <span class=\"fu\">printf<\/span>() <span class=\"kw\">throws<\/span> <span class=\"bu\">Throwable<\/span> {<\/a>\n+<a class=\"sourceLine\" id=\"cb27-73\" title=\"73\">        MethodHandle printf = CLinker.<span class=\"fu\">getInstance<\/span>().<span class=\"fu\">downcallHandle<\/span>(<\/a>\n+<a class=\"sourceLine\" id=\"cb27-74\" title=\"74\">                LibraryLookup.<span class=\"fu\">ofDefault<\/span>().<span class=\"fu\">lookup<\/span>(<span class=\"st\">&quot;printf&quot;<\/span>).<span class=\"fu\">get<\/span>(),<\/a>\n+<a class=\"sourceLine\" id=\"cb27-75\" title=\"75\">                MethodType.<span class=\"fu\">methodType<\/span>(<span class=\"dt\">int<\/span>.<span class=\"fu\">class<\/span>, MemoryAddress.<span class=\"fu\">class<\/span>, <span class=\"dt\">int<\/span>.<span class=\"fu\">class<\/span>, <span class=\"dt\">int<\/span>.<span class=\"fu\">class<\/span>, <span class=\"dt\">int<\/span>.<span class=\"fu\">class<\/span>),<\/a>\n+<a class=\"sourceLine\" id=\"cb27-76\" title=\"76\">                FunctionDescriptor.<span class=\"fu\">of<\/span>(C_INT, C_POINTER, C_INT, C_INT, C_INT)<\/a>\n+<a class=\"sourceLine\" id=\"cb27-77\" title=\"77\">        );<\/a>\n+<a class=\"sourceLine\" id=\"cb27-78\" title=\"78\">        <span class=\"kw\">try<\/span> (MemorySegment s = CLinker.<span class=\"fu\">toCString<\/span>(<span class=\"st\">&quot;%d plus %d equals %d<\/span><span class=\"sc\">\\n<\/span><span class=\"st\">&quot;<\/span>)) {<\/a>\n+<a class=\"sourceLine\" id=\"cb27-79\" title=\"79\">            printf.<span class=\"fu\">invoke<\/span>(s.<span class=\"fu\">address<\/span>(), <span class=\"dv\">2<\/span>, <span class=\"dv\">2<\/span>, <span class=\"dv\">4<\/span>);<\/a>\n+<a class=\"sourceLine\" id=\"cb27-80\" title=\"80\">        }<\/a>\n+<a class=\"sourceLine\" id=\"cb27-81\" title=\"81\">    }<\/a>\n+<a class=\"sourceLine\" id=\"cb27-82\" title=\"82\"><\/a>\n+<a class=\"sourceLine\" id=\"cb27-83\" title=\"83\">    <span class=\"kw\">public<\/span> <span class=\"dt\">static<\/span> <span class=\"dt\">void<\/span> <span class=\"fu\">vprintf<\/span>() <span class=\"kw\">throws<\/span> <span class=\"bu\">Throwable<\/span> {<\/a>\n+<a class=\"sourceLine\" id=\"cb27-84\" title=\"84\"><\/a>\n+<a class=\"sourceLine\" id=\"cb27-85\" title=\"85\">        MethodHandle vprintf = CLinker.<span class=\"fu\">getInstance<\/span>().<span class=\"fu\">downcallHandle<\/span>(<\/a>\n+<a class=\"sourceLine\" id=\"cb27-86\" title=\"86\">                LibraryLookup.<span class=\"fu\">ofDefault<\/span>().<span class=\"fu\">lookup<\/span>(<span class=\"st\">&quot;vprintf&quot;<\/span>).<span class=\"fu\">get<\/span>(),<\/a>\n+<a class=\"sourceLine\" id=\"cb27-87\" title=\"87\">                MethodType.<span class=\"fu\">methodType<\/span>(<span class=\"dt\">int<\/span>.<span class=\"fu\">class<\/span>, MemoryAddress.<span class=\"fu\">class<\/span>, CLinker.<span class=\"fu\">VaList<\/span>.<span class=\"fu\">class<\/span>),<\/a>\n+<a class=\"sourceLine\" id=\"cb27-88\" title=\"88\">                FunctionDescriptor.<span class=\"fu\">of<\/span>(C_INT, C_POINTER, C_VA_LIST));<\/a>\n+<a class=\"sourceLine\" id=\"cb27-89\" title=\"89\"><\/a>\n+<a class=\"sourceLine\" id=\"cb27-90\" title=\"90\">        <span class=\"kw\">try<\/span> (NativeScope scope = NativeScope.<span class=\"fu\">unboundedScope<\/span>()) {<\/a>\n+<a class=\"sourceLine\" id=\"cb27-91\" title=\"91\">            MemorySegment s = CLinker.<span class=\"fu\">toCString<\/span>(<span class=\"st\">&quot;%d plus %d equals %d<\/span><span class=\"sc\">\\n<\/span><span class=\"st\">&quot;<\/span>, scope);<\/a>\n+<a class=\"sourceLine\" id=\"cb27-92\" title=\"92\">            CLinker.<span class=\"fu\">VaList<\/span> vlist = CLinker.<span class=\"fu\">VaList<\/span>.<span class=\"fu\">make<\/span>(builder -&gt;<\/a>\n+<a class=\"sourceLine\" id=\"cb27-93\" title=\"93\">                     builder.<span class=\"fu\">vargFromInt<\/span>(C_INT, <span class=\"dv\">2<\/span>)<\/a>\n+<a class=\"sourceLine\" id=\"cb27-94\" title=\"94\">                            .<span class=\"fu\">vargFromInt<\/span>(C_INT, <span class=\"dv\">2<\/span>)<\/a>\n+<a class=\"sourceLine\" id=\"cb27-95\" title=\"95\">                            .<span class=\"fu\">vargFromInt<\/span>(C_INT, <span class=\"dv\">4<\/span>), scope);<\/a>\n+<a class=\"sourceLine\" id=\"cb27-96\" title=\"96\">            vprintf.<span class=\"fu\">invoke<\/span>(s.<span class=\"fu\">address<\/span>(), vlist);<\/a>\n+<a class=\"sourceLine\" id=\"cb27-97\" title=\"97\">        }<\/a>\n+<a class=\"sourceLine\" id=\"cb27-98\" title=\"98\">    }<\/a>\n+<a class=\"sourceLine\" id=\"cb27-99\" title=\"99\">}<\/a><\/code><\/pre><\/div>\n+<ul>\n+<li><a id=\"1\"\/>(<sup>1<\/sup>):<small> In reality this is not entirely new; even in JNI, when you call a <code>native<\/code> method the VM trusts that the corresponding implementing function in C will feature compatible parameter types and return values; if not a crash might occur.<\/small><\/li>\n+<li><a id=\"2\"\/>(<sup>2<\/sup>):<small> In the fututre we might consider knobs to allow structs returned by value to be allocated on-heap rather than off-heap. If these structs are always passed back and forth in an opaque manner, there could be a significant performance advantage in avoiding an off-heap allocation.<\/small><\/li>\n+<li><a id=\"3a\"\/>(<sup>3a<\/sup>):<small> At the time of writing, support for native method intrinsics has been disabled by default due to some spurious VM crash being detected when running <code>jextract<\/code> with the intrinsics support enabled. While we work to rectify this situation, the intrinsics support can still be enabled using the <code>-Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true<\/code> flag.<\/small><\/li>\n+<li><a id=\"3b\"\/>(<sup>3b<\/sup>):<small> As an advanced option, Panama allows the user to opt-in to remove Java to native thread transitions; while, in the general case it is unsafe doing so (removing thread transitions could have a negative impact on GC for long running native functions, and could crash the VM if the downcall needs to pop back out in Java, e.g. via an upcall), greater efficiency can be achieved; performance sensitive users should consider this option at least for the functions that are called more frquently, assuming that these functions are <em>leaf<\/em> functions (e.g. do not go back to Java via an upcall) and are relatively short-lived.<\/small><\/li>\n+<li><a id=\"4\"\/>(<sup>4<\/sup>):<small> This might change in the future, as we might want to tie the lifecycle of structs created for an upcall to the lifecycle of the upcall itself so that e.g. any segment that are created ahead of calling a Java upcall, are released immediately after the upcall returns<\/small><\/li>\n+<li><a id=\"5\"\/>(<sup>5<\/sup>):<small> We are currently investigating alternate allocation strategies to make allocation inside native scopes even faster<\/small><\/li>\n+<li><a id=\"6\"\/>(<sup>6<\/sup>):<small> On Windows, layouts for variadic arguments have to be adjusted using the <code>CLinker.Win64.asVarArg(ValueLayout)<\/code>; this is necessay because the Windows ABI passes variadic arguments using different rules than the ones used for ordinary arguments.<\/small><\/li>\n+<\/ul>\n+<\/body>\n+<\/html>\n","filename":"doc\/panama_ffi.html","additions":443,"deletions":0,"binary":false,"changes":443,"status":"added"},{"patch":"@@ -0,0 +1,466 @@\n+## State of foreign function support\n+\n+**October 2020**\n+\n+* Adjust reference to NativeScope handoff\n+* Tweak references to restricted segments to use new API\n+* Tweak signature of LibraryLookup::lookup\n+* Replaced usages of ForeignLinker with CLinker, as per new API\n+\n+**Maurizio Cimadamore**\n+\n+In this document we explore the main concepts behind Panama's foreign function support; as we shall see, the central abstraction in the foreign function support is the so called *foreign linker*, an abstraction that allows clients to construct *native* method handles — that is, method handles whose invocation targets a native function defined in some native library. As we shall see, Panama foreign function support is completely expressed in terms of Java code and no intermediate native code is required.\n+\n+### Native addresses\n+\n+Before we dive into the specifics of the foreign function support, it would be useful to briefly recap some of the main concepts we have learned when exploring the [foreign memory access support](http:\/\/cr.openjdk.java.net\/~mcimadamore\/panama\/foreign-memaccess.html). The Foreign Memory Access API allows client to create and manipulate *memory segments*. A memory segment is a view over a memory source (either on- or off-heap) which is spatially bounded, temporally bounded and thread-confined. The guarantees ensure that dereferencing a segment that has been created by Java code is always *safe*, and can never result in a VM crash, or, worse, in silent memory corruption.\n+\n+Now, in the case of memory segments, the above properties (spatial bounds, temporal bounds and confinement) can be known *in full* when the segment is created. But when we interact with native libraries we will often be receiving *raw* pointers; such pointers have no spatial bounds (does a `char*` in C refer to one `char`, or a `char` array of a given size?), no notion of temporal bounds, nor thread-confinement. Raw addresses in our interop support are modelled using the `MemoryAddress` abstraction.\n+\n+A memory address is just what the name implies: it encapsulates a memory address (either on- or off-heap). Since, in order to dereference memory using a memory access var handle, we need a segment, it follows that it is *not* possible to directly dereference a memory address — to do that we need a segment first. So clients can proceed in three different ways here.\n+\n+First, if the memory address is known to belong to a segment the client *already* owns, a *rebase* operation can be performed; in other words, the client can ask the address what is its offset relative to a given segment, and then proceed to dereference the original segment accordingly:\n+\n+```java\n+MemorySegment segment = MemorySegment.allocateNative(100);\n+...\n+MemoryAddress addr = ... \/\/obtain address from native code\n+int x = MemoryAccess.getIntAtOffset(segment, addr.segmentOffset(segment));    \n+```\n+\n+Secondly, if the client does *not* have a segment which contains a given memory address, it can create one *unsafely*, using the `MemoryAddress::asSegmentRestricted`; this can also be useful to inject extra knowledge about spatial bounds which might be available in the native library the client is interacting with:\n+\n+```java\n+MemoryAddress addr = ... \/\/obtain address from native code\n+MemorySegment segment = addr.asSegmentRestricted(100);\n+int x = MemoryAccess.getInt(segment);\n+```\n+\n+Alternatively, the client can fall back to use the so called *everything* segment - that is, a primordial segment which covers the entire native heap. Since this segment is available as a constant, dereference can happen without the need of creating any additional segment instances:\n+\n+```java\n+MemoryAddress addr = ... \/\/obtain address from native code\n+int x = MemoryAccess.getIntAtOffset(MemorySegment.ofNativeRestricted(), addr.toRawLongValue());\n+```\n+\n+Of course, since accessing the entire native heap is inherently *unsafe*, accessing the *everything* segment is considered a *restricted* operation which is only allowed after explicit opt in by setting the `foreign.restricted=permit` runtime flag.\n+\n+`MemoryAddress`, like `MemorySegment` , implements the `Addressable` interface, which is a functional interface whose method projects an entity down to a `MemoryAddress` instance. In the case of `MemoryAddress` such a projection is the identity function; in the case of a memory segment, the projection returns the `MemoryAddres` instance for the segment's base address. This abstraction allows to pass either memory address or memory segments where an address is expected (this is especially useful when generating native bindings).\n+\n+### Symbol lookups\n+\n+The first ingredient of any foreign function support is a mechanism to lookup symbols in native libraries. In traditional Java\/JNI, this is done via the `System::loadLibrary` and `System::load` methods, which internally map into calls to `dlopen`. In Panama, library lookups are modeled more directly, using a  class called`LibraryLookup`  (similar to a method handle lookup),  which provides capabilities to lookup named symbols in a given native library; we can obtain a library lookup in 3 different ways:\n+\n+* `LibraryLookup::ofDefault`  — returns the library lookup which can *see* all the symbols that have been loaded with the VM\n+* `LibraryLookup::ofPath` — creates a library lookup associated with the library found at the given absolute path\n+* `LibraryLookup::ofLibrary` — creates a library lookup associated with the library with given name (this might require setting the `java.library.path` variable accordingly)\n+\n+Once a lookup has been obtained, a client can use it to retrieve handles to library symbols (either global variables or functions) using the `lookup(String)` method, which returns an  `Optional<LibraryLookup.Symbol>`. A lookup symbol is just a proxy for a memory address (in fact, it implements `Addressable`) and a name.\n+\n+For instance, the following code can be used to lookup the `clang_getClangVersion` function provided by the `clang` library:\n+\n+```java\n+LibraryLookup libclang = LibraryLookup.ofLibrary(\"clang\");\n+LibraryLookup.Symbol clangVersion = libclang.lookup(\"clang_getClangVersion\").get();\n+```\n+\n+One crucial distinction between the library loading support of the  Foreign Linker API and of JNI is that JNI libraries are loaded into a  class loader. Furthermore, to preserve [classloader integrity](https:\/\/docs.oracle.com\/javase\/7\/docs\/technotes\/guides\/jni\/jni-12.html#libmanage) integrity, the same JNI library cannot be loaded into more than one  classloader.  The foreign function support described here is more  primitive — the Foreign Linker API allows clients to target native  libraries directly, without any intervening JNI code. Crucially, Java  objects are never passed to and from native code by the Foreign Linker API. Because of this, libraries loaded through the `LibraryLookup` hook are not tied to any class loader and can be (re)loaded as many times as needed.\n+\n+### C Linker\n+\n+At the core of Panama foreign function support we find the `CLinker` abstraction. This abstraction plays a dual role: first, for downcalls, it allows to model native function calls as plain `MethodHandle` calls (see `ForeignLinker::downcallHandle`); second, for upcalls, it allows to convert an existing `MethodHandle` (which might point to some Java method) into a `MemorySegment` which could then be passed to native functions as a function pointer (see `ForeignLinker::upcallStub`):\n+\n+```java\n+interface CLinker {\n+    MethodHandle downcallHandle(Addressable func, MethodType type, FunctionDescriptor function);\n+    MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function);\n+    ...\n+    static CLinker getInstance() { ... }\n+}\n+```\n+\n+In the following sections we will dive deeper into how downcall handles and upcall stubs are created; here we want to focus on the similarities between these two routines. First, both take a `FunctionDescriptor` instance — essentially an aggregate of memory layouts which is used to describe the signature of a foreign function in full. Speaking of C, the `CLinker` class defines many layout constants (one for each main C primitive type) — these layouts can be combined using a `FunctionDescriptor` to describe the signature of a C function. For instance, assuming we have a C function taking a `char*` and returning a `long` we can model such a function with the following descriptor:\n+\n+```java\n+FunctionDescriptor func = FunctionDescriptor.of(CLinker.C_LONG, CLinker.C_POINTER);\n+```\n+\n+The layouts used above will be mapped to the right layout according to the platform we are executing on. This also means that these layouts will be platform dependent and that e.g. `C_LONG` will be a 32 bit value layout on Windows, while being a 64-bit value on Linux.\n+\n+Layouts defined in the `CLinker` class are not only handy, as they already model the C types we want to work on; they also contain hidden pieces of information which the foreign linker support uses in order to compute the calling sequence associated with a given function descriptor. For instance, the two C types `int` and `float` might share a similar memory layout (they both are expressed as 32 bit values), but are typically passed using different machine registers. The layout attributes attached to the C-specific layouts in the `CLinker` class ensures that arguments and return values are interpreted in the correct way.\n+\n+Another similarity between `downcallHandle` and `upcallStub` is that they both accept (either directly, or indirectly) a `MethodType` instance. The method type describes the Java signatures that clients will be using when interacting with said downcall handles, or upcall stubs. The C linker implementation adds constraints on which layouts can be used with which Java carrier — for instance by enforcing that the size of the Java carrier is equal to that of the corresponding layout, or by making sure that certain layouts are associated with specific carriers. The following table shows the Java carrier vs. layout mappings enforced by the Linux\/macOS foreign linker implementation:\n+\n+| C layout      | Java carrier    |\n+| ------------- | --------------- |\n+| `C_BOOL`      | `byte`          |\n+| `C_CHAR`      | `byte`          |\n+| `C_SHORT`     | `short`         |\n+| `C_INT`       | `int`           |\n+| `C_LONG`      | `long`          |\n+| `C_LONGLONG`  | `long`          |\n+| `C_FLOAT`     | `float`         |\n+| `C_DOUBLE`    | `double`        |\n+| `C_POINTER`   | `MemoryAddress` |\n+| `GroupLayout` | `MemorySegment` |\n+\n+Aside from the mapping between primitive layout and primitive Java carriers (which might vary across platforms), it is important to note how all pointer layouts must correspond to a `MemoryAddress` carrier, whereas structs (whose layout is defined by a `GroupLayout`) must be associated with a `MemorySegment` carrier.\n+\n+### Downcalls\n+\n+We will now look at how foreign functions can be called from Java using the foreign linker abstraction. Assume we wanted to call the following function from the standard C library:\n+\n+```c\n+size_t strlen(const char *s);\n+```\n+\n+In order to do that, we have to:\n+\n+* lookup the `strlen` symbol\n+* describe the signature of the C function using the layouts in the `CLinker` class\n+\n+* select a Java signature we want to *overlay* on the native function — this will be the signature that clients of the native method handles will interact with\n+* create a *downcall* native method handle with the above information, using the standard C foreign linker\n+\n+Here's an example of how we might want to do that (a full listing of all the examples in this and subsequent sections will be provided in the [appendix](#appendix: full-source-code)):\n+\n+```java\n+MethodHandle strlen = CLinker.getInstance().downcallHandle(\n+\t\tLibraryLookup.ofDefault().lookup(\"strlen\").get(),\n+        MethodType.methodType(long.class, MemoryAddress.class),\n+        FunctionDescriptor.of(C_LONG, C_POINTER)\n+);\n+```\n+\n+Note that, since the function `strlen` is part of the standard C library, which is loaded with the VM, we can just use the default lookup to look it up. The rest is pretty straightforward — the only tricky detail is how to model `size_t`: typically this type has the size of a pointer, so we can use `C_LONG` on Linux, but we'd have to use `C_LONGLONG` on Windows. On the Java side, we model the `size_t` using a `long` and the pointer is modeled using a `MemoryAddress` parameter.\n+\n+One we have obtained the downcall native method handle, we can just use it as any other method handle:\n+\n+```java\n+long len = strlen.invokeExact(CLinker.toCString(\"Hello\").address()) \/\/ 5\n+```\n+\n+Here we are using one of the helper methods in `CLinker` to convert a Java string into an off-heap memory segment which contains a `NULL` terminated C string. We then pass that segment to the method handle and retrieve our result in a Java `long`. Note how all this has been possible *without* any piece of intervening native code — all the interop code can be expressed in (low level) Java.\n+\n+Now that we have seen the basics of how foreign function calls are supported in Panama, let's add some additional considerations. First, it is important to note that, albeit the interop code is written in Java, the above code can *not* be considered 100% safe. There are many arbitrary decisions to be made when setting up downcall method handles such as the one above, some of which might be obvious to us (e.g. how many parameters does the function take), but which cannot ultimately be verified by the Panama runtime. After all, a symbol in a dynamic library is, mostly a numeric offset and, unless we are using a shared library with debugging information, no type information is attached to a given library symbol. This means that, in this case, the Panama runtime has to *trust* our description of the `strlen` function. For this reason, access to the foreign linker is a restricted operation, which can only be performed if the runtime flag `foreign.restricted=permit` is passed on the command line of the Java launcher <a href=\"#1\"><sup>1<\/sup><\/a>.\n+\n+Finally let's talk about the life-cycle of some of the entities involved here; first, as a downcall native handle wraps a lookup symbol, the library from which the symbol has been loaded will stay loaded until there are reachable downcall handles referring to one of its symbols; in the above example, this consideration is less important, given the use of the default lookup object, which can be assumed to stay alive for the entire duration of the application.\n+\n+Certain functions might return pointers, or structs; it is important to realize that if a function returns a pointer (or a `MemoryAddress`), no life-cycle whatsoever is attached to that pointer. It is then up to the client to e.g. free the memory associated with that pointer, or do nothing (in case the library is responsible for the life-cycle of that pointer). If a library returns a struct by value, things are different, as a *fresh*, confined memory segment is allocated off-heap and returned to the callee. It is the responsibility of the callee to cleanup that struct's segment (using `MemorySegment::close`) <a href=\"#2\"><sup>2<\/sup><\/a>.\n+\n+Performance-wise, the reader might ask how efficient calling a foreign function using a native method handle is; the answer is *very*. The JVM comes with some special support for native method handles, so that, if a give method handle is invoked many times (e.g, inside an *hot* loop), the JIT compiler might decide to just generate a snippet of assembly code required to call the native function, and execute that directly. In most cases, invoking native function this way is as efficient as doing so through JNI <a href=\"#3a\"><sup>3a<\/sup><\/a><a href=\"#3b\"><sup>3b<\/sup><\/a>.\n+\n+### Upcalls\n+\n+Sometimes, it is useful to pass Java code as a function pointer to some native function; we can achieve that by using foreign linker support for upcalls. To demonstrate this, let's consider the following function from the C standard library:\n+\n+```c\n+void qsort(void *base, size_t nmemb, size_t size,\n+           int (*compar)(const void *, const void *));\n+```\n+\n+This is a function that can be used to sort the contents of an array, using a custom comparator function — `compar` — which is passed as a function pointer. To be able to call the `qsort` function from Java we have first to create a downcall native method handle for it:\n+\n+```java\n+MethodHandle qsort = CLinker.getInstance().downcallHandle(\n+\t\tLibraryLookup.ofDefault().lookup(\"qsort\").get(),\n+        MethodType.methodType(void.class, MemoryAddress.class, long.class, long.class, MemoryAddress.class),\n+        FunctionDescriptor.ofVoid(C_POINTER, C_LONG, C_LONG, C_POINTER)\n+);\n+```\n+\n+As before, we use `C_LONG` and `long.class` to map the C `size_t` type, and we use `MemoryAddess.class` both for the first pointer parameter (the array pointer) and the last parameter (the function pointer).\n+\n+This time, in order to invoke the `qsort` downcall handle, we need a *function pointer* to be passed as the last parameter; this is where the upcall support in foreign linker comes in handy, as it allows us to create a function pointer out of an existing method handle. First, let's write a function that can compare two int elements (passed as pointers):\n+\n+```java\n+class Qsort {\n+\tstatic int qsortCompare(MemoryAddress addr1, MemoryAddress addr2) {\n+\t\treturn MemoryAccess.getIntAtOffset(MemorySegment.ofNativeRestricted(), addr1.toRawLongValue()) - \n+\t    \t   MemoryAccess.getIntAtOffset(MemorySegment.ofNativeRestricted(), addr2.toRawLongValue());\n+\t}\n+}\n+```\n+\n+Here we can see that the function is performing some *unsafe* dereference of the pointer contents, by using the *everything* segment. Now let's create a method handle pointing to the comparator function above:\n+\n+```java\n+MethodHandle comparHandle = MethodHandles.lookup()\n+                                         .findStatic(Qsort.class, \"qsortCompare\",\n+                                                     MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class));\n+```\n+\n+Now that we have a method handle for our Java comparator function, we can create a function pointer, using the foreign linker upcall support  — as for downcalls,  we have to describe the signature of the foreign function pointer using the layouts in the `CLinker` class:\n+\n+```java\n+MemorySegment comparFunc = CLinker.getInstance().upcallStub(\n+    comparHandle,\n+    FunctionDescriptor.of(C_INT, C_POINTER, C_POINTER)\n+);\n+```\n+\n+So, we finally have a memory segment — `comparFunc` — containing a stub that can be used to invoke our Java comparator function; this means we now have all we need to call the `qsort` downcall handle:\n+\n+```java\n+MemorySegment array = MemorySegment.allocateNative(4 * 10);\n+array.copyFrom(MemorySegment.ofArray(new int[] { 0, 9, 3, 4, 6, 5, 1, 8, 2, 7 }));\n+qsort.invokeExact(array.address(), 10L, 4L, comparFunc.address());\n+int[] sorted = array.toIntArray(); \/\/ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\n+```\n+\n+The above code creates an off-heap array, then copies the contents of a Java array on it (we shall see in the next [section](#native-scope) ways to do that more succinctly), and then pass the array to the `qsort` handle, along with the comparator function we obtained from the foreign linker.  As a side-effect, after the call, the contents of the off-heap array will be sorted (as instructed by our comparator function, written in Java). We can than extract a new Java array from the segment, which contains the sorted elements. This is a more advanced example, but one that shows how powerful the native interop support provided by the foreign linker abstraction is, allowing full bidirectional interop support between Java and native.\n+\n+As before, we conclude with a quick note on life-cycle. First, the life-cycle of the upcall stub is tied to that of the segment returned by the foreign linker. When the segment is closed, the upcall is uninstalled from the VM and will no longer be a valid function pointer. Second, the life-cycle of structs (if any) passed by value to the Java upcall function is independent from that of the upcall <a href=\"#4\"><sup>4<\/sup><\/a>, so again the user will have to pay attention not to leak memory and to call `MemorySegment::close` on any segments obtained through an upcall.\n+\n+### Native scope\n+\n+Idiomatic C code implicitly relies on stack allocation to allow for concise variable declarations; consider this example:\n+\n+```c\n+void foo(int i, int *size);\n+\n+int size = 5;\n+foo(42, &size);\n+```\n+\n+Here the function `foo` takes an output parameter, a pointer to an `int` variable. Unfortunately (and we have seen part of that pain in the `qsort` example above), implementing this idiom in Panama is not straightforward:\n+\n+```java\n+MethodHandle foo = ...\n+MemorySegment size = MemorySegment.allocateNative(C_INT);\n+MemoryAccess.setInt(size, 5);\n+foo.invokeExact(42, size);\n+```\n+\n+There are a number of issues with the above code snippet:\n+\n+* compared to the C code, it is very verbose\n+* allocation is very slow compared to C; allocating the `size` variable now takes a full `malloc`, while in C the variable was simply stack-allocated\n+* we end up with a standalone segment with its own temporal bounds, which will have to be *closed* later, to avoid leaks\n+\n+To address these problems, Panama provides a `NativeScope` abstraction, which can be used to group allocation so as to achieve superior allocation performance, but also so that groups of logically-related segments can share the same temporal bounds, and can therefore be closed at once (e.g. by using a single *try-with-resources* statement). With the help of native scopes, the above code can be rewritten as follows:\n+\n+```java\n+try (NativeScope scope = NativeScope.unboundedScope()) {\n+\tMemorySegment size = scope.allocate(C_INT, 5);\n+\tfoo.invokeExact(42, size);\n+}\n+```\n+\n+It's easy to see how this code improves over the former in many ways; first, native scopes have primitives to allocate *and* initialize the contents of a segment; secondly, native scope use more efficient allocation underneath, so that not every allocation request is turned into a `malloc` — in fact, if the size of memory to be used is known before hand, clients can also use the bounded variant of native scope, using the `NativeScope::boundedScope(long size)` factory <a href=\"#5\"><sup>5<\/sup><\/a>. Third, a native scope can be used as a single temporal bound for all the segments allocated within it: that is, if the code needs to instantiate other variables, it can keep doing so using the same scope — when the *try-with-resource* statement completes, all resources associated with the scope will be freed.\n+\n+There are at least two cases where allocation of native resources occurs *outside* a native scope:\n+\n+* structs segments returned by native calls (or passed to upcalls Java methods)\n+* upcall stubs segments returned by the foreign linker\n+\n+In these cases, the API gives us a segment which feature *its own* temporal bounds — this is handy, as we can use the segment to control the lifecycle of the resource allocated by the foreign linker support; but it is also a bit unfortunate: if the surrounding code happens to already have a native scope, these new segments won't be able to interoperate with it, and a separate *try-with-resource* segment should be used.\n+\n+To alleviate this problem, and allow *all* segments to be managed using the *same* native scope, the native scope API not only supports the ability to allocate *new* segments, but it also allows to take ownership of *existing* ones. To see an example of this, let's go back to our `qsort` example, and see how we can make it better by using native scopes:\n+\n+```java\n+try (NativeScope scope = NativeScope.unboundedScope()) {\n+    comparFunc = comparFunc.handoff(scope);\n+    MemorySegment array = scope.allocateArray(C_INT, new int[] { 0, 9, 3, 4, 6, 5, 1, 8, 2, 7 });\n+    qsort.invokeExact(array, 10L, 4L, comparFunc);\n+    int[] sorted = array.toIntArray(); \/\/ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\n+}\n+```\n+\n+Not only native scope helps in making the allocation of the native array simpler (we no longer need to create an heap segment, and dump its contents onto the off-heap array); but we can also use the native scope as an *handoff target* for existing upcall stub segments. When we do that, we obtain a *new* segment, whose temporal bounds are the same as that of the native scope; the old segment will be killed and will no longer be usable. As with all segments returned by native scope, the new segment we get back will be non-closeable — the only way to close it is to close the native scope it belongs to.\n+\n+In short, native scopes are a good way to manage the lifecycle of multiple, logically-related segments, and, despite their simplicity, they provide a fairly good usability and performance boost.\n+\n+### Varargs\n+\n+Some C functions are *variadic* and can take an arbitrary number of arguments. Perhaps the most common example of this is the `printf` function, defined in the C standard library:\n+\n+```c\n+int printf(const char *format, ...);\n+```\n+\n+This function takes a format string, which features zero or more *holes*, and then can take a number of additional arguments that is identical to the number of holes in the format string.\n+\n+The foreign function support can support variadic calls, but with a caveat: the client must provide a specialized Java signature, and a specialized description of the C signature. For instance, let's say we wanted to model the following C call:\n+\n+```C\n+printf(\"%d plus %d equals %d\", 2, 2, 4);\n+```\n+\n+To do this using the foreign function support provided by Panama we would have to build a *specialized* downcall handle for that call shape <a href=\"#6\"><sup>6<\/sup><\/a>:\n+\n+```java\n+MethodHandle printf = CLinker.getInstance().downcallHandle(\n+\t\tLibraryLookup.ofDefault().lookup(\"printf\").get(),\n+        MethodType.methodType(int.class, MemoryAddress.class, int.class, int.class, int.class),\n+        FunctionDescriptor.of(C_INT, C_POINTER, C_INT, C_INT, C_INT)\n+);\n+```\n+\n+Then we can call the specialized downcall handle as usual:\n+\n+```java\n+printf.invoke(CLinker.toCString(\"%d plus %d equals %d\").address(), 2, 2, 4); \/\/prints \"2 plus 2 equals 4\"\n+```\n+\n+While this works, it is easy to see how such an approach is not very desirable:\n+\n+* If the variadic function needs to be called with many different shapes, we have to create many different downcall handles\n+* while this approach works for downcalls (since the Java code is in charge of determining which and how many arguments should be passed) it fails to scale to upcalls; in that case, the call comes from native code, so we have no way to guarantee that the shape of the upcall stub we have created will match that required by the native function.\n+\n+To mitigate these issues, the standard C foreign linker comes equipped with support for C variable argument lists — or `va_list`.  When a variadic function is called, C code has to unpack the variadic arguments by creating a `va_list` structure, and then accessing the variadic arguments through the `va_list` one by one (using the `va_arg` macro). To facilitate interop between standard variadic functions and `va_list` many C library functions in fact define *two* flavors of the same function, one using standard variadic signature, one using an extra `va_list` parameter. For instance, in the case of `printf` we can find that a `va_list`-accepting function performing the same task is also defined:\n+\n+```c\n+int vprintf(const char *format, va_list ap);\n+```\n+\n+The behavior of this function is the same as before — the only difference is that the ellipsis notation `...` has been replaced with a single `va_list` parameter; in other words, the function is no longer variadic.\n+\n+It is indeed fairly easy to create a downcall for `vprintf`:\n+\n+```java\n+MethodHandle vprintf = CLinker.getInstance().downcallHandle(\n+\t\tLibraryLookup.ofDefault().lookup(\"vprintf\").get(),\n+\t\tMethodType.methodType(int.class, MemoryAddress.class, VaList.class),\n+        FunctionDescriptor.of(C_INT, C_POINTER, C_VA_LIST));\n+```\n+\n+Here, the notable thing is that `CLinker` comes equipped with the special `C_VA_LIST` layout (the layout of a `va_list` parameter) as well as a `VaList` carrier, which can be used to construct and represent variable argument lists from Java code.\n+\n+To call the `vprintf` handle we need to create an instance of `VaList` which contains the arguments we want to pass to the `vprintf` function — we can do so, as follows:\n+\n+```java\n+vprintf.invoke(\n+\t\tCLinker.toCString(\"%d plus %d equals %d\").address(),\n+        VaList.make(builder ->\n+                   \t\tbuilder.vargFromInt(C_INT, 2)\n+                               .vargFromInt(C_INT, 2)\n+                               .vargFromInt(C_INT, 4))\n+); \/\/prints \"2 plus 2 equals 4\"\n+```\n+\n+While the callee has to do more work to call the `vprintf` handle, note that that now we're back in a place where the downcall handle  `vprintf` can be shared across multiple callees. A `VaList` object created this way has its own lifetime (`VaList` also supports a `close` operation), so it is up to the callee to make sure that the `VaList` instance is closed (or attached to some existing native scope) so as to avoid leaks.\n+\n+Another advantage of using `VaList` is that this approach also scales to upcall stubs — it is therefore possible for clients to create upcalls stubs which take a `VaList` and then, from the Java upcall, read the arguments packed inside the `VaList` one by one using the methods provided by the `VaList` API (e.g. `VaList::vargAsInt(MemoryLayout)`), which mimic the behavior of the C `va_arg` macro.\n+\n+### Appendix: full source code\n+\n+The full source code containing most of the code shown throughout this document can be seen below:\n+\n+```java\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.LibraryLookup;\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.NativeScope;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.Arrays;\n+\n+import static jdk.incubator.foreign.CLinker.*;\n+\n+public class Examples {\n+\n+    public static void main(String[] args) throws Throwable {\n+        strlen();\n+        qsort();\n+        printf();\n+        vprintf();\n+    }\n+\n+    public static void strlen() throws Throwable {\n+        MethodHandle strlen = CLinker.getInstance().downcallHandle(\n+                LibraryLookup.ofDefault().lookup(\"strlen\").get(),\n+                MethodType.methodType(long.class, MemoryAddress.class),\n+                FunctionDescriptor.of(C_LONG, C_POINTER)\n+        );\n+\n+        try (MemorySegment hello = CLinker.toCString(\"Hello\")) {\n+            long len = (long) strlen.invokeExact(hello.address()); \/\/ 5\n+            System.out.println(len);\n+        }\n+    }\n+\n+    static class Qsort {\n+        static int qsortCompare(MemoryAddress addr1, MemoryAddress addr2) {\n+            int v1 = MemoryAccess.getIntAtOffset(MemorySegment.ofNativeRestricted(), addr1.toRawLongValue());\n+            int v2 = MemoryAccess.getIntAtOffset(MemorySegment.ofNativeRestricted(), addr2.toRawLongValue());\n+            return v1 - v2;\n+        }\n+    }\n+\n+    public static void qsort() throws Throwable {\n+        MethodHandle qsort = CLinker.getInstance().downcallHandle(\n+                LibraryLookup.ofDefault().lookup(\"qsort\").get(),\n+                MethodType.methodType(void.class, MemoryAddress.class, long.class, long.class, MemoryAddress.class),\n+                FunctionDescriptor.ofVoid(C_POINTER, C_LONG, C_LONG, C_POINTER)\n+        );\n+\n+        MethodHandle comparHandle = MethodHandles.lookup()\n+                .findStatic(Qsort.class, \"qsortCompare\",\n+                        MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class));\n+\n+        MemorySegment comparFunc = CLinker.getInstance().upcallStub(\n+                comparHandle,\n+                FunctionDescriptor.of(C_INT, C_POINTER, C_POINTER)\n+        );\n+\n+        try (NativeScope scope = NativeScope.unboundedScope()) {\n+            comparFunc = comparFunc.handoff(scope);\n+            MemorySegment array = scope.allocateArray(C_INT, new int[] { 0, 9, 3, 4, 6, 5, 1, 8, 2, 7 });\n+            qsort.invokeExact(array.address(), 10L, 4L, comparFunc.address());\n+            int[] sorted = array.toIntArray(); \/\/ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\n+            System.out.println(Arrays.toString(sorted));\n+        }\n+    }\n+\n+    public static void printf() throws Throwable {\n+        MethodHandle printf = CLinker.getInstance().downcallHandle(\n+                LibraryLookup.ofDefault().lookup(\"printf\").get(),\n+                MethodType.methodType(int.class, MemoryAddress.class, int.class, int.class, int.class),\n+                FunctionDescriptor.of(C_INT, C_POINTER, C_INT, C_INT, C_INT)\n+        );\n+        try (MemorySegment s = CLinker.toCString(\"%d plus %d equals %d\\n\")) {\n+            printf.invoke(s.address(), 2, 2, 4);\n+        }\n+    }\n+\n+    public static void vprintf() throws Throwable {\n+\n+        MethodHandle vprintf = CLinker.getInstance().downcallHandle(\n+                LibraryLookup.ofDefault().lookup(\"vprintf\").get(),\n+                MethodType.methodType(int.class, MemoryAddress.class, CLinker.VaList.class),\n+                FunctionDescriptor.of(C_INT, C_POINTER, C_VA_LIST));\n+\n+        try (NativeScope scope = NativeScope.unboundedScope()) {\n+            MemorySegment s = CLinker.toCString(\"%d plus %d equals %d\\n\", scope);\n+            CLinker.VaList vlist = CLinker.VaList.make(builder ->\n+                     builder.vargFromInt(C_INT, 2)\n+                            .vargFromInt(C_INT, 2)\n+                            .vargFromInt(C_INT, 4), scope);\n+            vprintf.invoke(s.address(), vlist);\n+        }\n+    }\n+}\n+```\n+\n+\n+\n+\n+\n+\n+\n+* <a id=\"1\"\/>(<sup>1<\/sup>):<small> In reality this is not entirely new; even in JNI, when you call a `native` method the VM trusts that the corresponding implementing function in C will feature compatible parameter types and return values; if not a crash might occur.<\/small>\n+* <a id=\"2\"\/>(<sup>2<\/sup>):<small> In the fututre we might consider knobs to allow structs returned by value to be allocated on-heap rather than off-heap. If these structs are always passed back and forth in an opaque manner, there could be a significant performance advantage in avoiding an off-heap allocation.<\/small>\n+* <a id=\"3a\"\/>(<sup>3a<\/sup>):<small> At the time of writing, support for native method intrinsics has been disabled by default due to some spurious VM crash being detected when running `jextract` with the intrinsics support enabled. While we work to rectify this situation, the intrinsics support can still be enabled using the ` -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true` flag.<\/small>\n+* <a id=\"3b\"\/>(<sup>3b<\/sup>):<small> As an advanced option, Panama allows the user to opt-in to remove Java to native thread transitions; while, in the general case it is unsafe doing so (removing thread transitions could have a negative impact on GC for long running native functions, and could crash the VM if the downcall needs to pop back out in Java, e.g. via an upcall), greater efficiency can be achieved; performance sensitive users should consider this option at least for the functions that are called more frquently, assuming that these functions are *leaf* functions (e.g. do not go back to Java via an upcall) and are relatively short-lived.<\/small>\n+* <a id=\"4\"\/>(<sup>4<\/sup>):<small> This might change in the future, as we might want to tie the lifecycle of structs created for an upcall to the lifecycle of the upcall itself so that e.g. any segment that are created ahead of calling a Java upcall, are released immediately after the upcall returns<\/small>\n+* <a id=\"5\"\/>(<sup>5<\/sup>):<small> We are currently investigating alternate allocation strategies to make allocation inside native scopes even faster<\/small>\n+* <a id=\"6\"\/>(<sup>6<\/sup>):<small> On Windows, layouts for variadic arguments have to be adjusted using the `CLinker.Win64.asVarArg(ValueLayout)`; this is necessay because the Windows ABI passes variadic arguments using different rules than the ones used for ordinary arguments.<\/small>\n+\n+\n","filename":"doc\/panama_ffi.md","additions":466,"deletions":0,"binary":false,"changes":466,"status":"added"},{"patch":"@@ -0,0 +1,936 @@\n+<!DOCTYPE html>\n+<html xmlns=\"http:\/\/www.w3.org\/1999\/xhtml\" lang=\"\" xml:lang=\"\">\n+<head>\n+  <meta charset=\"utf-8\" \/>\n+  <meta name=\"generator\" content=\"pandoc\" \/>\n+  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, user-scalable=yes\" \/>\n+  <title>panama_jextract<\/title>\n+  <style type=\"text\/css\">\n+      code{white-space: pre-wrap;}\n+      span.smallcaps{font-variant: small-caps;}\n+      span.underline{text-decoration: underline;}\n+      div.column{display: inline-block; vertical-align: top; width: 50%;}\n+  <\/style>\n+  <style type=\"text\/css\">\n+a.sourceLine { display: inline-block; line-height: 1.25; }\n+a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }\n+a.sourceLine:empty { height: 1.2em; }\n+.sourceCode { overflow: visible; }\n+code.sourceCode { white-space: pre; position: relative; }\n+div.sourceCode { margin: 1em 0; }\n+pre.sourceCode { margin: 0; }\n+@media screen {\n+div.sourceCode { overflow: auto; }\n+}\n+@media print {\n+code.sourceCode { white-space: pre-wrap; }\n+a.sourceLine { text-indent: -1em; padding-left: 1em; }\n+}\n+pre.numberSource a.sourceLine\n+  { position: relative; left: -4em; }\n+pre.numberSource a.sourceLine::before\n+  { content: attr(title);\n+    position: relative; left: -1em; text-align: right; vertical-align: baseline;\n+    border: none; pointer-events: all; display: inline-block;\n+    -webkit-touch-callout: none; -webkit-user-select: none;\n+    -khtml-user-select: none; -moz-user-select: none;\n+    -ms-user-select: none; user-select: none;\n+    padding: 0 4px; width: 4em;\n+    color: #aaaaaa;\n+  }\n+pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }\n+div.sourceCode\n+  {  }\n+@media screen {\n+a.sourceLine::before { text-decoration: underline; }\n+}\n+code span.al { color: #ff0000; font-weight: bold; } \/* Alert *\/\n+code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } \/* Annotation *\/\n+code span.at { color: #7d9029; } \/* Attribute *\/\n+code span.bn { color: #40a070; } \/* BaseN *\/\n+code span.bu { } \/* BuiltIn *\/\n+code span.cf { color: #007020; font-weight: bold; } \/* ControlFlow *\/\n+code span.ch { color: #4070a0; } \/* Char *\/\n+code span.cn { color: #880000; } \/* Constant *\/\n+code span.co { color: #60a0b0; font-style: italic; } \/* Comment *\/\n+code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } \/* CommentVar *\/\n+code span.do { color: #ba2121; font-style: italic; } \/* Documentation *\/\n+code span.dt { color: #902000; } \/* DataType *\/\n+code span.dv { color: #40a070; } \/* DecVal *\/\n+code span.er { color: #ff0000; font-weight: bold; } \/* Error *\/\n+code span.ex { } \/* Extension *\/\n+code span.fl { color: #40a070; } \/* Float *\/\n+code span.fu { color: #06287e; } \/* Function *\/\n+code span.im { } \/* Import *\/\n+code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } \/* Information *\/\n+code span.kw { color: #007020; font-weight: bold; } \/* Keyword *\/\n+code span.op { color: #666666; } \/* Operator *\/\n+code span.ot { color: #007020; } \/* Other *\/\n+code span.pp { color: #bc7a00; } \/* Preprocessor *\/\n+code span.sc { color: #4070a0; } \/* SpecialChar *\/\n+code span.ss { color: #bb6688; } \/* SpecialString *\/\n+code span.st { color: #4070a0; } \/* String *\/\n+code span.va { color: #19177c; } \/* Variable *\/\n+code span.vs { color: #4070a0; } \/* VerbatimString *\/\n+code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } \/* Warning *\/\n+  <\/style>\n+  <link rel=\"stylesheet\" href=\"..\/make\/data\/docs-resources\/resources\/jdk-default.css\" \/>\n+<\/head>\n+<body>\n+<nav id=\"TOC\">\n+<ul>\n+<li><a href=\"#using-the-jextract-tool\">Using the <code>jextract<\/code> tool<\/a><ul>\n+<li><a href=\"#hello-world\">Hello World<\/a><ul>\n+<li><a href=\"#hello-world-c-header-helloworld.h\">Hello World C Header (helloworld.h)<\/a><\/li>\n+<li><a href=\"#hello-world-c-source-helloworld.c\">Hello World C Source (helloworld.c)<\/a><\/li>\n+<li><a href=\"#building-hello-world\">Building Hello World<\/a><\/li>\n+<li><a href=\"#jextract-a-jar-file-for-helloworld.h\">jextract a Jar file for helloworld.h<\/a><\/li>\n+<li><a href=\"#java-program-that-uses-extracted-helloworld-interface\">Java program that uses extracted helloworld interface<\/a><\/li>\n+<li><a href=\"#running-the-java-code-that-invokes-helloworld\">Running the Java code that invokes helloworld<\/a><\/li>\n+<\/ul><\/li>\n+<li><a href=\"#embedding-python-interpreter-in-your-java-program-mac-os\">Embedding Python interpreter in your Java program (Mac OS)<\/a><ul>\n+<li><a href=\"#jextract-python.h\">jextract Python.h<\/a><\/li>\n+<li><a href=\"#java-program-that-uses-extracted-python-interface\">Java program that uses extracted Python interface<\/a><\/li>\n+<li><a href=\"#running-the-java-code-that-calls-python-interpreter\">Running the Java code that calls Python interpreter<\/a><\/li>\n+<\/ul><\/li>\n+<li><a href=\"#using-readline-library-from-java-code-mac-os\">Using readline library from Java code (Mac OS)<\/a><ul>\n+<li><a href=\"#jextract-readline.h\">jextract readline.h<\/a><\/li>\n+<li><a href=\"#java-code-that-uses-readline\">Java code that uses readline<\/a><\/li>\n+<li><a href=\"#running-the-java-code-that-uses-readline\">Running the java code that uses readline<\/a><\/li>\n+<\/ul><\/li>\n+<li><a href=\"#using-libcurl-from-java-mac-os\">Using libcurl from Java (Mac OS)<\/a><ul>\n+<li><a href=\"#jextract-curl.h\">jextract curl.h<\/a><\/li>\n+<li><a href=\"#java-code-that-uses-libcurl\">Java code that uses libcurl<\/a><\/li>\n+<li><a href=\"#running-the-java-code-that-uses-libcurl\">Running the java code that uses libcurl<\/a><\/li>\n+<\/ul><\/li>\n+<li><a href=\"#using-blas-library\">Using BLAS library<\/a><ul>\n+<li><a href=\"#installing-openblas-mac-os\">Installing OpenBLAS (Mac OS)<\/a><\/li>\n+<li><a href=\"#jextracting-cblas.h-macos\">jextracting cblas.h (MacOS)<\/a><\/li>\n+<li><a href=\"#java-sample-code-that-uses-cblas-library\">Java sample code that uses cblas library<\/a><\/li>\n+<li><a href=\"#compiling-and-running-the-above-blas-sample\">Compiling and running the above BLAS sample<\/a><\/li>\n+<\/ul><\/li>\n+<li><a href=\"#using-lapack-library-mac-os\">Using LAPACK library (Mac OS)<\/a><ul>\n+<li><a href=\"#jextracting-lapacke.h\">jextracting lapacke.h<\/a><\/li>\n+<li><a href=\"#java-sample-code-that-uses-lapack-library\">Java sample code that uses LAPACK library<\/a><\/li>\n+<li><a href=\"#compiling-and-running-the-above-lapack-sample\">Compiling and running the above LAPACK sample<\/a><\/li>\n+<\/ul><\/li>\n+<li><a href=\"#using-libproc-library-to-list-processes-from-java-mac-os\">Using libproc library to list processes from Java (Mac OS)<\/a><ul>\n+<li><a href=\"#jextract-libproc.h\">jextract libproc.h<\/a><\/li>\n+<li><a href=\"#java-program-that-uses-libproc-to-list-processes\">Java program that uses libproc to list processes<\/a><\/li>\n+<li><a href=\"#compiling-and-running-the-libproc-sample\">Compiling and running the libproc sample<\/a><\/li>\n+<\/ul><\/li>\n+<li><a href=\"#using-libgit2-from-java-mac-os\">Using libgit2 from Java (Mac OS)<\/a><ul>\n+<li><a href=\"#getting-and-building-libgit2\">Getting and building libgit2<\/a><\/li>\n+<li><a href=\"#jextract-git2.h\">jextract git2.h<\/a><\/li>\n+<li><a href=\"#java-program-that-uses-libgit2-to-clone-github-repo\">Java program that uses libgit2 to clone github repo<\/a><\/li>\n+<li><a href=\"#compiling-and-running-the-libgit2-sample\">Compiling and running the libgit2 sample<\/a><\/li>\n+<li><a href=\"#cloning-a-github-repo-using-the-above-run.sh-command\">Cloning a github repo using the above run.sh command<\/a><\/li>\n+<\/ul><\/li>\n+<li><a href=\"#using-sqlite3-library-from-java-mac-os\">Using sqlite3 library from Java (Mac OS)<\/a><ul>\n+<li><a href=\"#jextract-sqlite3.h\">jextract sqlite3.h<\/a><\/li>\n+<li><a href=\"#java-program-that-uses-sqlite3\">Java program that uses sqlite3<\/a><\/li>\n+<li><a href=\"#compiling-and-running-the-sqlite3-sample\">Compiling and running the sqlite3 sample<\/a><\/li>\n+<\/ul><\/li>\n+<li><a href=\"#using-opengl-library-from-java-mac-os\">Using OpenGL library from Java (Mac OS)<\/a><ul>\n+<li><a href=\"#jextract-glut.h\">jextract glut.h<\/a><\/li>\n+<li><a href=\"#java-program-that-uses-opengl\">Java program that uses OpenGL<\/a><\/li>\n+<li><a href=\"#compiling-and-running-the-opengl-sample\">Compiling and running the OpenGL sample<\/a><\/li>\n+<\/ul><\/li>\n+<li><a href=\"#using-tensorflow-mac-os\">Using tensorflow (Mac OS)<\/a><ul>\n+<li><a href=\"#getting-libtensorflow\">getting libtensorflow<\/a><\/li>\n+<li><a href=\"#jextract-c_api.h\">jextract c_api.h<\/a><\/li>\n+<li><a href=\"#python-program-that-creates-and-saves-model\">Python program that creates and saves model<\/a><\/li>\n+<li><a href=\"#java-program-that-uses-tensorflow-c-api\">Java program that uses Tensorflow C API<\/a><\/li>\n+<li><a href=\"#compiling-and-running-the-java-tensorflow-sample\">Compiling and running the Java Tensorflow sample<\/a><\/li>\n+<\/ul><\/li>\n+<li><a href=\"#using-time.h-mac-os\">Using time.h (Mac OS)<\/a><ul>\n+<li><a href=\"#jextract-time.h\">jextract time.h<\/a><\/li>\n+<li><a href=\"#java-program-that-uses-posix-time-library\">Java program that uses POSIX time library<\/a><\/li>\n+<li><a href=\"#compiling-and-running-the-time-sample\">Compiling and running the time sample<\/a><\/li>\n+<\/ul><\/li>\n+<li><a href=\"#using-libclang-library-mac-os\">Using libclang library (Mac OS)<\/a><ul>\n+<li><a href=\"#jextract-index.h\">jextract Index.h<\/a><\/li>\n+<li><a href=\"#java-program-that-uses-libclang-to-print-ast-of-a-given-c-program\">Java program that uses libclang to print AST of a given C program<\/a><\/li>\n+<li><a href=\"#compiling-and-running-the-libclang-sample\">Compiling and running the libclang sample<\/a><\/li>\n+<\/ul><\/li>\n+<\/ul><\/li>\n+<\/ul>\n+<\/nav>\n+<?xml version=\"1.0\" encoding=\"utf-8\"?>\n+<h1 id=\"using-the-jextract-tool\">Using the <code>jextract<\/code> tool<\/h1>\n+<p><code>jextract<\/code> is a simple - but convenient - tool which generates a Java API from one or more native C headers. The tool can be obtained by building the <a href=\"https:\/\/github.com\/openjdk\/panama-foreign\">foreign-jextract<\/a> branch of Panama foreign repository.<\/p>\n+<p>Interacting with the <code>jextract<\/code> tool usually involves two steps:<\/p>\n+<ol type=\"1\">\n+<li>Use the <code>jextract<\/code> tool to generate a java interface for some C header files<\/li>\n+<li>Write a Java program which invokes the wrapper API points generated by <code>jextract<\/code><\/li>\n+<\/ol>\n+<p>The <code>jextract<\/code> tool provides some basic options in order to control how the extraction process works; these are listed below:<\/p>\n+<ul>\n+<li><code>-C &lt;String&gt;<\/code> - specify arguments to be passed to the underlying Clang parser<\/li>\n+<li><code>-I &lt;String&gt;<\/code> - specify include files path<\/li>\n+<li><code>-l &lt;String&gt;<\/code> - specify a library (name or full absolute path) which should be linked when the generated API is loaded<\/li>\n+<li><code>-d &lt;String&gt;<\/code> - specify where to place generated files<\/li>\n+<li><code>-t &lt;String&gt;<\/code> specify the target package for the generated classes<\/li>\n+<li><code>--filter &lt;String&gt;<\/code> - simple string-based filtering mechanism; only symbols from headers whose absolute path contains the specified string will be included in the generated API<\/li>\n+<li><code>--source<\/code> - generate java sources instead of classfiles<\/li>\n+<\/ul>\n+<p>The remainder of this documents shows some basic usage examples of the <code>jextract<\/code> tool.<\/p>\n+<h2 id=\"hello-world\">Hello World<\/h2>\n+<h3 id=\"hello-world-c-header-helloworld.h\">Hello World C Header (helloworld.h)<\/h3>\n+<div class=\"sourceCode\" id=\"cb1\"><pre class=\"sourceCode c\"><code class=\"sourceCode c\"><a class=\"sourceLine\" id=\"cb1-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb1-2\" title=\"2\"><span class=\"pp\">#ifndef helloworld_h<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb1-3\" title=\"3\"><span class=\"pp\">#define helloworld_h<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb1-4\" title=\"4\"><\/a>\n+<a class=\"sourceLine\" id=\"cb1-5\" title=\"5\"><span class=\"kw\">extern<\/span> <span class=\"dt\">void<\/span> helloworld(<span class=\"dt\">void<\/span>);<\/a>\n+<a class=\"sourceLine\" id=\"cb1-6\" title=\"6\"><\/a>\n+<a class=\"sourceLine\" id=\"cb1-7\" title=\"7\"><span class=\"pp\">#endif <\/span><span class=\"co\">\/* helloworld_h *\/<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb1-8\" title=\"8\"><\/a><\/code><\/pre><\/div>\n+<h3 id=\"hello-world-c-source-helloworld.c\">Hello World C Source (helloworld.c)<\/h3>\n+<div class=\"sourceCode\" id=\"cb2\"><pre class=\"sourceCode c\"><code class=\"sourceCode c\"><a class=\"sourceLine\" id=\"cb2-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb2-2\" title=\"2\"><span class=\"pp\">#include <\/span><span class=\"im\">&lt;stdio.h&gt;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb2-3\" title=\"3\"><\/a>\n+<a class=\"sourceLine\" id=\"cb2-4\" title=\"4\"><span class=\"pp\">#include <\/span><span class=\"im\">&quot;helloworld.h&quot;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb2-5\" title=\"5\"><\/a>\n+<a class=\"sourceLine\" id=\"cb2-6\" title=\"6\"><span class=\"dt\">void<\/span> helloworld(<span class=\"dt\">void<\/span>) {<\/a>\n+<a class=\"sourceLine\" id=\"cb2-7\" title=\"7\">    printf(<span class=\"st\">&quot;Hello World!<\/span><span class=\"sc\">\\n<\/span><span class=\"st\">&quot;<\/span>);<\/a>\n+<a class=\"sourceLine\" id=\"cb2-8\" title=\"8\">}<\/a><\/code><\/pre><\/div>\n+<h3 id=\"building-hello-world\">Building Hello World<\/h3>\n+<div class=\"sourceCode\" id=\"cb3\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><a class=\"sourceLine\" id=\"cb3-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb3-2\" title=\"2\"><span class=\"fu\">cc<\/span> -shared -o libhelloworld.dylib helloworld.c<\/a><\/code><\/pre><\/div>\n+<h3 id=\"jextract-a-jar-file-for-helloworld.h\">jextract a Jar file for helloworld.h<\/h3>\n+<div class=\"sourceCode\" id=\"cb4\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><a class=\"sourceLine\" id=\"cb4-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb4-2\" title=\"2\"><span class=\"ex\">jextract<\/span> -t org.hello -lhelloworld helloworld.h<\/a><\/code><\/pre><\/div>\n+<h3 id=\"java-program-that-uses-extracted-helloworld-interface\">Java program that uses extracted helloworld interface<\/h3>\n+<div class=\"sourceCode\" id=\"cb5\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb5-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb5-2\" title=\"2\"><span class=\"kw\">import static<\/span><span class=\"im\"> org.hello.helloworld_h.*;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb5-3\" title=\"3\"><\/a>\n+<a class=\"sourceLine\" id=\"cb5-4\" title=\"4\"><span class=\"kw\">public<\/span> <span class=\"kw\">class<\/span> HelloWorld {<\/a>\n+<a class=\"sourceLine\" id=\"cb5-5\" title=\"5\">    <span class=\"kw\">public<\/span> <span class=\"dt\">static<\/span> <span class=\"dt\">void<\/span> <span class=\"fu\">main<\/span>(<span class=\"bu\">String<\/span>[] args) {<\/a>\n+<a class=\"sourceLine\" id=\"cb5-6\" title=\"6\">        <span class=\"fu\">helloworld<\/span>();<\/a>\n+<a class=\"sourceLine\" id=\"cb5-7\" title=\"7\">    }<\/a>\n+<a class=\"sourceLine\" id=\"cb5-8\" title=\"8\">}<\/a><\/code><\/pre><\/div>\n+<h3 id=\"running-the-java-code-that-invokes-helloworld\">Running the Java code that invokes helloworld<\/h3>\n+<div class=\"sourceCode\" id=\"cb6\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><a class=\"sourceLine\" id=\"cb6-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb6-2\" title=\"2\"><span class=\"ex\">java<\/span> -Dforeign.restricted=permit --add-modules jdk.incubator.foreign HelloWorld.java<\/a><\/code><\/pre><\/div>\n+<h2 id=\"embedding-python-interpreter-in-your-java-program-mac-os\">Embedding Python interpreter in your Java program (Mac OS)<\/h2>\n+<h3 id=\"jextract-python.h\">jextract Python.h<\/h3>\n+<div class=\"sourceCode\" id=\"cb7\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><a class=\"sourceLine\" id=\"cb7-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb7-2\" title=\"2\"><span class=\"ex\">jextract<\/span> \\<\/a>\n+<a class=\"sourceLine\" id=\"cb7-3\" title=\"3\">  -l python2.7 \\<\/a>\n+<a class=\"sourceLine\" id=\"cb7-4\" title=\"4\">  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\<\/a>\n+<a class=\"sourceLine\" id=\"cb7-5\" title=\"5\">  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/python2.7\/ \\<\/a>\n+<a class=\"sourceLine\" id=\"cb7-6\" title=\"6\">  -t org.python \\<\/a>\n+<a class=\"sourceLine\" id=\"cb7-7\" title=\"7\">   \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/python2.7\/Python.h<\/a><\/code><\/pre><\/div>\n+<h3 id=\"java-program-that-uses-extracted-python-interface\">Java program that uses extracted Python interface<\/h3>\n+<div class=\"sourceCode\" id=\"cb8\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb8-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb8-2\" title=\"2\"><span class=\"kw\">import static<\/span><span class=\"im\"> jdk.incubator.foreign.CLinker.*;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb8-3\" title=\"3\"><span class=\"kw\">import static<\/span><span class=\"im\"> jdk.incubator.foreign.MemoryAddress.NULL;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb8-4\" title=\"4\"><span class=\"co\">\/\/ import jextracted python &#39;header&#39; class<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb8-5\" title=\"5\"><span class=\"kw\">import static<\/span><span class=\"im\"> org.python.Python_h.*;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb8-6\" title=\"6\"><\/a>\n+<a class=\"sourceLine\" id=\"cb8-7\" title=\"7\"><span class=\"kw\">public<\/span> <span class=\"kw\">class<\/span> PythonMain {<\/a>\n+<a class=\"sourceLine\" id=\"cb8-8\" title=\"8\">    <span class=\"kw\">public<\/span> <span class=\"dt\">static<\/span> <span class=\"dt\">void<\/span> <span class=\"fu\">main<\/span>(<span class=\"bu\">String<\/span>[] args) {<\/a>\n+<a class=\"sourceLine\" id=\"cb8-9\" title=\"9\">        <span class=\"bu\">String<\/span> script = <span class=\"st\">&quot;print(sum([33, 55, 66])); print(&#39;Hello from Python!&#39;)<\/span><span class=\"sc\">\\n<\/span><span class=\"st\">&quot;<\/span>;<\/a>\n+<a class=\"sourceLine\" id=\"cb8-10\" title=\"10\"><\/a>\n+<a class=\"sourceLine\" id=\"cb8-11\" title=\"11\">        <span class=\"fu\">Py_Initialize<\/span>();<\/a>\n+<a class=\"sourceLine\" id=\"cb8-12\" title=\"12\">        <span class=\"kw\">try<\/span> (var str = <span class=\"fu\">toCString<\/span>(script)) {<\/a>\n+<a class=\"sourceLine\" id=\"cb8-13\" title=\"13\">            <span class=\"fu\">PyRun_SimpleStringFlags<\/span>(str, NULL);<\/a>\n+<a class=\"sourceLine\" id=\"cb8-14\" title=\"14\">            <span class=\"fu\">Py_Finalize<\/span>();<\/a>\n+<a class=\"sourceLine\" id=\"cb8-15\" title=\"15\">        }<\/a>\n+<a class=\"sourceLine\" id=\"cb8-16\" title=\"16\">    }<\/a>\n+<a class=\"sourceLine\" id=\"cb8-17\" title=\"17\">}<\/a><\/code><\/pre><\/div>\n+<h3 id=\"running-the-java-code-that-calls-python-interpreter\">Running the Java code that calls Python interpreter<\/h3>\n+<div class=\"sourceCode\" id=\"cb9\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><a class=\"sourceLine\" id=\"cb9-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb9-2\" title=\"2\"><span class=\"ex\">java<\/span> -Dforeign.restricted=permit --add-modules jdk.incubator.foreign \\<\/a>\n+<a class=\"sourceLine\" id=\"cb9-3\" title=\"3\">    -Djava.library.path=\/System\/Library\/Frameworks\/Python.framework\/Versions\/2.7\/lib \\<\/a>\n+<a class=\"sourceLine\" id=\"cb9-4\" title=\"4\">    PythonMain.java<\/a><\/code><\/pre><\/div>\n+<h2 id=\"using-readline-library-from-java-code-mac-os\">Using readline library from Java code (Mac OS)<\/h2>\n+<h3 id=\"jextract-readline.h\">jextract readline.h<\/h3>\n+<div class=\"sourceCode\" id=\"cb10\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><a class=\"sourceLine\" id=\"cb10-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb10-2\" title=\"2\"><span class=\"ex\">jextract<\/span> \\<\/a>\n+<a class=\"sourceLine\" id=\"cb10-3\" title=\"3\">  -l readline -t org.unix \\<\/a>\n+<a class=\"sourceLine\" id=\"cb10-4\" title=\"4\">  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\<\/a>\n+<a class=\"sourceLine\" id=\"cb10-5\" title=\"5\">   \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/readline\/readline.h<\/a><\/code><\/pre><\/div>\n+<h3 id=\"java-code-that-uses-readline\">Java code that uses readline<\/h3>\n+<div class=\"sourceCode\" id=\"cb11\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb11-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb11-2\" title=\"2\"><span class=\"kw\">import static<\/span><span class=\"im\"> org.unix.readline_h.*;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb11-3\" title=\"3\"><span class=\"kw\">import static<\/span><span class=\"im\"> jdk.incubator.foreign.CLinker.*;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb11-4\" title=\"4\"><\/a>\n+<a class=\"sourceLine\" id=\"cb11-5\" title=\"5\"><span class=\"kw\">public<\/span> <span class=\"kw\">class<\/span> Readline {<\/a>\n+<a class=\"sourceLine\" id=\"cb11-6\" title=\"6\">    <span class=\"kw\">public<\/span> <span class=\"dt\">static<\/span> <span class=\"dt\">void<\/span> <span class=\"fu\">main<\/span>(<span class=\"bu\">String<\/span>[] args) {<\/a>\n+<a class=\"sourceLine\" id=\"cb11-7\" title=\"7\">        <span class=\"kw\">try<\/span> (var str = <span class=\"fu\">toCString<\/span>(<span class=\"st\">&quot;name? &quot;<\/span>)) {<\/a>\n+<a class=\"sourceLine\" id=\"cb11-8\" title=\"8\">            <span class=\"co\">\/\/ call &quot;readline&quot; API<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb11-9\" title=\"9\">            var p = <span class=\"fu\">readline<\/span>(str);<\/a>\n+<a class=\"sourceLine\" id=\"cb11-10\" title=\"10\"><\/a>\n+<a class=\"sourceLine\" id=\"cb11-11\" title=\"11\">            <span class=\"co\">\/\/ print char* as is<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb11-12\" title=\"12\">            <span class=\"bu\">System<\/span>.<span class=\"fu\">out<\/span>.<span class=\"fu\">println<\/span>(p);<\/a>\n+<a class=\"sourceLine\" id=\"cb11-13\" title=\"13\">            <span class=\"co\">\/\/ convert char* ptr from readline as Java String &amp; print it<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb11-14\" title=\"14\">            <span class=\"bu\">System<\/span>.<span class=\"fu\">out<\/span>.<span class=\"fu\">println<\/span>(<span class=\"st\">&quot;Hello, &quot;<\/span> + <span class=\"fu\">toJavaStringRestricted<\/span>(p));<\/a>\n+<a class=\"sourceLine\" id=\"cb11-15\" title=\"15\">        }<\/a>\n+<a class=\"sourceLine\" id=\"cb11-16\" title=\"16\">    }<\/a>\n+<a class=\"sourceLine\" id=\"cb11-17\" title=\"17\">}<\/a><\/code><\/pre><\/div>\n+<h3 id=\"running-the-java-code-that-uses-readline\">Running the java code that uses readline<\/h3>\n+<pre><code>java -Dforeign.restricted=permit --add-modules jdk.incubator.foreign \\\n+    -Djava.library.path=\/usr\/local\/opt\/readline\/lib\/ Readline.java\n+<\/code><\/pre>\n+<h2 id=\"using-libcurl-from-java-mac-os\">Using libcurl from Java (Mac OS)<\/h2>\n+<h3 id=\"jextract-curl.h\">jextract curl.h<\/h3>\n+<div class=\"sourceCode\" id=\"cb13\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><a class=\"sourceLine\" id=\"cb13-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb13-2\" title=\"2\"><span class=\"ex\">jextract<\/span> -t org.unix -lcurl \\<\/a>\n+<a class=\"sourceLine\" id=\"cb13-3\" title=\"3\">  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/ \\<\/a>\n+<a class=\"sourceLine\" id=\"cb13-4\" title=\"4\">  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/curl\/ \\<\/a>\n+<a class=\"sourceLine\" id=\"cb13-5\" title=\"5\">  \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/curl\/curl.h<\/a><\/code><\/pre><\/div>\n+<h3 id=\"java-code-that-uses-libcurl\">Java code that uses libcurl<\/h3>\n+<div class=\"sourceCode\" id=\"cb14\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb14-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb14-2\" title=\"2\"><span class=\"kw\">import static<\/span><span class=\"im\"> jdk.incubator.foreign.MemoryAddress.NULL;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb14-3\" title=\"3\"><span class=\"kw\">import static<\/span><span class=\"im\"> org.jextract.curl_h.*;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb14-4\" title=\"4\"><span class=\"kw\">import static<\/span><span class=\"im\"> jdk.incubator.foreign.CLinker.*;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb14-5\" title=\"5\"><\/a>\n+<a class=\"sourceLine\" id=\"cb14-6\" title=\"6\"><span class=\"kw\">public<\/span> <span class=\"kw\">class<\/span> CurlMain {<\/a>\n+<a class=\"sourceLine\" id=\"cb14-7\" title=\"7\">   <span class=\"kw\">public<\/span> <span class=\"dt\">static<\/span> <span class=\"dt\">void<\/span> <span class=\"fu\">main<\/span>(<span class=\"bu\">String<\/span>[] args) {<\/a>\n+<a class=\"sourceLine\" id=\"cb14-8\" title=\"8\">       var urlStr = args[<span class=\"dv\">0<\/span>];<\/a>\n+<a class=\"sourceLine\" id=\"cb14-9\" title=\"9\">       <span class=\"fu\">curl_global_init<\/span>(<span class=\"fu\">CURL_GLOBAL_DEFAULT<\/span>());<\/a>\n+<a class=\"sourceLine\" id=\"cb14-10\" title=\"10\">       var curl = <span class=\"fu\">curl_easy_init<\/span>();<\/a>\n+<a class=\"sourceLine\" id=\"cb14-11\" title=\"11\">       <span class=\"kw\">if<\/span>(!curl.<span class=\"fu\">equals<\/span>(NULL)) {<\/a>\n+<a class=\"sourceLine\" id=\"cb14-12\" title=\"12\">           <span class=\"kw\">try<\/span> (var url = <span class=\"fu\">toCString<\/span>(urlStr)) {<\/a>\n+<a class=\"sourceLine\" id=\"cb14-13\" title=\"13\">               <span class=\"fu\">curl_easy_setopt<\/span>(curl, <span class=\"fu\">CURLOPT_URL<\/span>(), url.<span class=\"fu\">address<\/span>());<\/a>\n+<a class=\"sourceLine\" id=\"cb14-14\" title=\"14\">               <span class=\"dt\">int<\/span> res = <span class=\"fu\">curl_easy_perform<\/span>(curl);<\/a>\n+<a class=\"sourceLine\" id=\"cb14-15\" title=\"15\">               <span class=\"kw\">if<\/span> (res != <span class=\"fu\">CURLE_OK<\/span>()) {<\/a>\n+<a class=\"sourceLine\" id=\"cb14-16\" title=\"16\">                   <span class=\"bu\">String<\/span> error = <span class=\"fu\">toJavaStringRestricted<\/span>(<span class=\"fu\">curl_easy_strerror<\/span>(res));<\/a>\n+<a class=\"sourceLine\" id=\"cb14-17\" title=\"17\">                   <span class=\"bu\">System<\/span>.<span class=\"fu\">out<\/span>.<span class=\"fu\">println<\/span>(<span class=\"st\">&quot;Curl error: &quot;<\/span> + error);<\/a>\n+<a class=\"sourceLine\" id=\"cb14-18\" title=\"18\">                   <span class=\"fu\">curl_easy_cleanup<\/span>(curl);<\/a>\n+<a class=\"sourceLine\" id=\"cb14-19\" title=\"19\">               }<\/a>\n+<a class=\"sourceLine\" id=\"cb14-20\" title=\"20\">           }<\/a>\n+<a class=\"sourceLine\" id=\"cb14-21\" title=\"21\">       }<\/a>\n+<a class=\"sourceLine\" id=\"cb14-22\" title=\"22\">       <span class=\"fu\">curl_global_cleanup<\/span>();<\/a>\n+<a class=\"sourceLine\" id=\"cb14-23\" title=\"23\">   }<\/a>\n+<a class=\"sourceLine\" id=\"cb14-24\" title=\"24\">}<\/a><\/code><\/pre><\/div>\n+<h3 id=\"running-the-java-code-that-uses-libcurl\">Running the java code that uses libcurl<\/h3>\n+<div class=\"sourceCode\" id=\"cb15\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><a class=\"sourceLine\" id=\"cb15-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb15-2\" title=\"2\"><span class=\"co\"># run this shell script by passing a URL as first argument<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb15-3\" title=\"3\"><span class=\"ex\">java<\/span> -Dforeign.restricted=permit --add-modules jdk.incubator.foreign \\<\/a>\n+<a class=\"sourceLine\" id=\"cb15-4\" title=\"4\">    -Djava.library.path=\/usr\/lib CurlMain.java <span class=\"va\">$*<\/span><\/a><\/code><\/pre><\/div>\n+<h2 id=\"using-blas-library\">Using BLAS library<\/h2>\n+<p>BLAS is a popular library that allows fast matrix and vector computation: <a href=\"http:\/\/www.netlib.org\/blas\/\">http:\/\/www.netlib.org\/blas\/<\/a>.<\/p>\n+<h3 id=\"installing-openblas-mac-os\">Installing OpenBLAS (Mac OS)<\/h3>\n+<p>On Mac, blas is available as part of the OpenBLAS library: <a href=\"https:\/\/github.com\/xianyi\/OpenBLAS\/wiki\">https:\/\/github.com\/xianyi\/OpenBLAS\/wiki<\/a><\/p>\n+<p>OpenBLAS is an optimized BLAS library based on GotoBLAS2 1.13 BSD version.<\/p>\n+<p>You can install openblas using HomeBrew<\/p>\n+<div class=\"sourceCode\" id=\"cb16\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><a class=\"sourceLine\" id=\"cb16-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb16-2\" title=\"2\"><span class=\"ex\">brew<\/span> install openblas<\/a><\/code><\/pre><\/div>\n+<p>It installs include and lib directories under \/usr\/local\/opt\/openblas<\/p>\n+<h3 id=\"jextracting-cblas.h-macos\">jextracting cblas.h (MacOS)<\/h3>\n+<p>The following command can be used to extract cblas.h on MacOs<\/p>\n+<div class=\"sourceCode\" id=\"cb17\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><a class=\"sourceLine\" id=\"cb17-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb17-2\" title=\"2\"><span class=\"ex\">jextract<\/span> -C <span class=\"st\">&quot;-D FORCE_OPENBLAS_COMPLEX_STRUCT&quot;<\/span> \\<\/a>\n+<a class=\"sourceLine\" id=\"cb17-3\" title=\"3\">  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\<\/a>\n+<a class=\"sourceLine\" id=\"cb17-4\" title=\"4\">  -l openblas -t blas \/usr\/local\/opt\/openblas\/include\/cblas.h<\/a><\/code><\/pre><\/div>\n+<h3 id=\"java-sample-code-that-uses-cblas-library\">Java sample code that uses cblas library<\/h3>\n+<div class=\"sourceCode\" id=\"cb18\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb18-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb18-2\" title=\"2\"><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.MemoryAddress;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb18-3\" title=\"3\"><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.MemoryAccess;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb18-4\" title=\"4\"><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.NativeScope;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb18-5\" title=\"5\"><span class=\"kw\">import<\/span><span class=\"im\"> blas.*;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb18-6\" title=\"6\"><span class=\"kw\">import static<\/span><span class=\"im\"> blas.cblas_h.*;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb18-7\" title=\"7\"><span class=\"kw\">import static<\/span><span class=\"im\"> jdk.incubator.foreign.CLinker.*;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb18-8\" title=\"8\"><\/a>\n+<a class=\"sourceLine\" id=\"cb18-9\" title=\"9\"><span class=\"kw\">public<\/span> <span class=\"kw\">class<\/span> TestBlas {<\/a>\n+<a class=\"sourceLine\" id=\"cb18-10\" title=\"10\">    <span class=\"kw\">public<\/span> <span class=\"dt\">static<\/span> <span class=\"dt\">void<\/span> <span class=\"fu\">main<\/span>(<span class=\"bu\">String<\/span>[] args) {<\/a>\n+<a class=\"sourceLine\" id=\"cb18-11\" title=\"11\">        <span class=\"dt\">int<\/span> Layout;<\/a>\n+<a class=\"sourceLine\" id=\"cb18-12\" title=\"12\">        <span class=\"dt\">int<\/span> transa;<\/a>\n+<a class=\"sourceLine\" id=\"cb18-13\" title=\"13\"><\/a>\n+<a class=\"sourceLine\" id=\"cb18-14\" title=\"14\">        <span class=\"dt\">double<\/span> alpha, beta;<\/a>\n+<a class=\"sourceLine\" id=\"cb18-15\" title=\"15\">        <span class=\"dt\">int<\/span> m, n, lda, incx, incy, i;<\/a>\n+<a class=\"sourceLine\" id=\"cb18-16\" title=\"16\"><\/a>\n+<a class=\"sourceLine\" id=\"cb18-17\" title=\"17\">        Layout = <span class=\"fu\">CblasColMajor<\/span>();<\/a>\n+<a class=\"sourceLine\" id=\"cb18-18\" title=\"18\">        transa = <span class=\"fu\">CblasNoTrans<\/span>();<\/a>\n+<a class=\"sourceLine\" id=\"cb18-19\" title=\"19\"><\/a>\n+<a class=\"sourceLine\" id=\"cb18-20\" title=\"20\">        m = <span class=\"dv\">4<\/span>; <span class=\"co\">\/* Size of Column ( the number of rows ) *\/<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb18-21\" title=\"21\">        n = <span class=\"dv\">4<\/span>; <span class=\"co\">\/* Size of Row ( the number of columns ) *\/<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb18-22\" title=\"22\">        lda = <span class=\"dv\">4<\/span>; <span class=\"co\">\/* Leading dimension of 5 * 4 matrix is 5 *\/<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb18-23\" title=\"23\">        incx = <span class=\"dv\">1<\/span>;<\/a>\n+<a class=\"sourceLine\" id=\"cb18-24\" title=\"24\">        incy = <span class=\"dv\">1<\/span>;<\/a>\n+<a class=\"sourceLine\" id=\"cb18-25\" title=\"25\">        alpha = <span class=\"dv\">1<\/span>;<\/a>\n+<a class=\"sourceLine\" id=\"cb18-26\" title=\"26\">        beta = <span class=\"dv\">0<\/span>;<\/a>\n+<a class=\"sourceLine\" id=\"cb18-27\" title=\"27\"><\/a>\n+<a class=\"sourceLine\" id=\"cb18-28\" title=\"28\">        <span class=\"kw\">try<\/span> (var scope = NativeScope.<span class=\"fu\">unboundedScope<\/span>()) {<\/a>\n+<a class=\"sourceLine\" id=\"cb18-29\" title=\"29\">            var a = scope.<span class=\"fu\">allocateArray<\/span>(C_DOUBLE, <span class=\"kw\">new<\/span> <span class=\"dt\">double<\/span>[] {<\/a>\n+<a class=\"sourceLine\" id=\"cb18-30\" title=\"30\">                <span class=\"fl\">1.<\/span><span class=\"dv\">0<\/span>, <span class=\"fl\">2.<\/span><span class=\"dv\">0<\/span>, <span class=\"fl\">3.<\/span><span class=\"dv\">0<\/span>, <span class=\"fl\">4.<\/span><span class=\"dv\">0<\/span>,<\/a>\n+<a class=\"sourceLine\" id=\"cb18-31\" title=\"31\">                <span class=\"fl\">1.<\/span><span class=\"dv\">0<\/span>, <span class=\"fl\">1.<\/span><span class=\"dv\">0<\/span>, <span class=\"fl\">1.<\/span><span class=\"dv\">0<\/span>, <span class=\"fl\">1.<\/span><span class=\"dv\">0<\/span>,<\/a>\n+<a class=\"sourceLine\" id=\"cb18-32\" title=\"32\">                <span class=\"fl\">3.<\/span><span class=\"dv\">0<\/span>, <span class=\"fl\">4.<\/span><span class=\"dv\">0<\/span>, <span class=\"fl\">5.<\/span><span class=\"dv\">0<\/span>, <span class=\"fl\">6.<\/span><span class=\"dv\">0<\/span>,<\/a>\n+<a class=\"sourceLine\" id=\"cb18-33\" title=\"33\">                <span class=\"fl\">5.<\/span><span class=\"dv\">0<\/span>, <span class=\"fl\">6.<\/span><span class=\"dv\">0<\/span>, <span class=\"fl\">7.<\/span><span class=\"dv\">0<\/span>, <span class=\"fl\">8.<\/span><span class=\"dv\">0<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb18-34\" title=\"34\">            });<\/a>\n+<a class=\"sourceLine\" id=\"cb18-35\" title=\"35\">            var x = scope.<span class=\"fu\">allocateArray<\/span>(C_DOUBLE, <span class=\"kw\">new<\/span> <span class=\"dt\">double<\/span>[] {<\/a>\n+<a class=\"sourceLine\" id=\"cb18-36\" title=\"36\">                <span class=\"fl\">1.<\/span><span class=\"dv\">0<\/span>, <span class=\"fl\">2.<\/span><span class=\"dv\">0<\/span>, <span class=\"fl\">1.<\/span><span class=\"dv\">0<\/span>, <span class=\"fl\">1.<\/span><span class=\"dv\">0<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb18-37\" title=\"37\">            });<\/a>\n+<a class=\"sourceLine\" id=\"cb18-38\" title=\"38\">            var y = scope.<span class=\"fu\">allocateArray<\/span>(C_DOUBLE, n);<\/a>\n+<a class=\"sourceLine\" id=\"cb18-39\" title=\"39\"><\/a>\n+<a class=\"sourceLine\" id=\"cb18-40\" title=\"40\">            <span class=\"fu\">cblas_dgemv<\/span>(Layout, transa, m, n, alpha, a, lda, x, incx, beta, y, incy);<\/a>\n+<a class=\"sourceLine\" id=\"cb18-41\" title=\"41\">            <span class=\"co\">\/* Print y *\/<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb18-42\" title=\"42\">            <span class=\"kw\">for<\/span> (i = <span class=\"dv\">0<\/span>; i &lt; n; i++) {<\/a>\n+<a class=\"sourceLine\" id=\"cb18-43\" title=\"43\">                <span class=\"bu\">System<\/span>.<span class=\"fu\">out<\/span>.<span class=\"fu\">print<\/span>(<span class=\"bu\">String<\/span><span class=\"fu\">.format<\/span>(<span class=\"st\">&quot; y<\/span><span class=\"sc\">%d<\/span><span class=\"st\"> = <\/span><span class=\"sc\">%f\\n<\/span><span class=\"st\">&quot;<\/span>, i, MemoryAccess.<span class=\"fu\">getDoubleAtIndex<\/span>(y, i)));<\/a>\n+<a class=\"sourceLine\" id=\"cb18-44\" title=\"44\">            }<\/a>\n+<a class=\"sourceLine\" id=\"cb18-45\" title=\"45\">        }<\/a>\n+<a class=\"sourceLine\" id=\"cb18-46\" title=\"46\">    }<\/a>\n+<a class=\"sourceLine\" id=\"cb18-47\" title=\"47\">}<\/a><\/code><\/pre><\/div>\n+<h3 id=\"compiling-and-running-the-above-blas-sample\">Compiling and running the above BLAS sample<\/h3>\n+<div class=\"sourceCode\" id=\"cb19\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><a class=\"sourceLine\" id=\"cb19-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb19-2\" title=\"2\"><span class=\"ex\">jextract<\/span> \\<\/a>\n+<a class=\"sourceLine\" id=\"cb19-3\" title=\"3\">  -C <span class=\"st\">&quot;-D FORCE_OPENBLAS_COMPLEX_STRUCT&quot;<\/span> \\<\/a>\n+<a class=\"sourceLine\" id=\"cb19-4\" title=\"4\">  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\<\/a>\n+<a class=\"sourceLine\" id=\"cb19-5\" title=\"5\">  -l openblas -t blas \/usr\/local\/opt\/openblas\/include\/cblas.h<\/a><\/code><\/pre><\/div>\n+<h2 id=\"using-lapack-library-mac-os\">Using LAPACK library (Mac OS)<\/h2>\n+<p>On Mac OS, lapack is installed under \/usr\/local\/opt\/lapack directory.<\/p>\n+<h3 id=\"jextracting-lapacke.h\">jextracting lapacke.h<\/h3>\n+<div class=\"sourceCode\" id=\"cb20\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><a class=\"sourceLine\" id=\"cb20-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb20-2\" title=\"2\"><span class=\"ex\">jextract<\/span> \\<\/a>\n+<a class=\"sourceLine\" id=\"cb20-3\" title=\"3\">   -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\<\/a>\n+<a class=\"sourceLine\" id=\"cb20-4\" title=\"4\">   -l lapacke -t lapack \\<\/a>\n+<a class=\"sourceLine\" id=\"cb20-5\" title=\"5\">   --filter lapacke.h \\<\/a>\n+<a class=\"sourceLine\" id=\"cb20-6\" title=\"6\">   \/usr\/local\/opt\/lapack\/include\/lapacke.h<\/a><\/code><\/pre><\/div>\n+<h3 id=\"java-sample-code-that-uses-lapack-library\">Java sample code that uses LAPACK library<\/h3>\n+<div class=\"sourceCode\" id=\"cb21\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb21-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb21-2\" title=\"2\"><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.MemoryAccess;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb21-3\" title=\"3\"><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.MemoryAddress;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb21-4\" title=\"4\"><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.MemorySegment;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb21-5\" title=\"5\"><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.NativeScope;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb21-6\" title=\"6\"><span class=\"kw\">import<\/span><span class=\"im\"> lapack.*;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb21-7\" title=\"7\"><span class=\"kw\">import static<\/span><span class=\"im\"> lapack.lapacke_h.*;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb21-8\" title=\"8\"><span class=\"kw\">import static<\/span><span class=\"im\"> jdk.incubator.foreign.CLinker.*;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb21-9\" title=\"9\"><\/a>\n+<a class=\"sourceLine\" id=\"cb21-10\" title=\"10\"><span class=\"kw\">public<\/span> <span class=\"kw\">class<\/span> TestLapack {<\/a>\n+<a class=\"sourceLine\" id=\"cb21-11\" title=\"11\">    <span class=\"kw\">public<\/span> <span class=\"dt\">static<\/span> <span class=\"dt\">void<\/span> <span class=\"fu\">main<\/span>(<span class=\"bu\">String<\/span>[] args) {<\/a>\n+<a class=\"sourceLine\" id=\"cb21-12\" title=\"12\"><\/a>\n+<a class=\"sourceLine\" id=\"cb21-13\" title=\"13\">        <span class=\"co\">\/* Locals *\/<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb21-14\" title=\"14\">        <span class=\"kw\">try<\/span> (var scope = NativeScope.<span class=\"fu\">unboundedScope<\/span>()) {<\/a>\n+<a class=\"sourceLine\" id=\"cb21-15\" title=\"15\">            var A = scope.<span class=\"fu\">allocateArray<\/span>(C_DOUBLE, <span class=\"kw\">new<\/span> <span class=\"dt\">double<\/span>[]{<\/a>\n+<a class=\"sourceLine\" id=\"cb21-16\" title=\"16\">                    <span class=\"dv\">1<\/span>, <span class=\"dv\">2<\/span>, <span class=\"dv\">3<\/span>, <span class=\"dv\">4<\/span>, <span class=\"dv\">5<\/span>, <span class=\"dv\">1<\/span>, <span class=\"dv\">3<\/span>, <span class=\"dv\">5<\/span>, <span class=\"dv\">2<\/span>, <span class=\"dv\">4<\/span>, <span class=\"dv\">1<\/span>, <span class=\"dv\">4<\/span>, <span class=\"dv\">2<\/span>, <span class=\"dv\">5<\/span>, <span class=\"dv\">3<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb21-17\" title=\"17\">            });<\/a>\n+<a class=\"sourceLine\" id=\"cb21-18\" title=\"18\">            var b = scope.<span class=\"fu\">allocateArray<\/span>(C_DOUBLE, <span class=\"kw\">new<\/span> <span class=\"dt\">double<\/span>[]{<\/a>\n+<a class=\"sourceLine\" id=\"cb21-19\" title=\"19\">                    -<span class=\"dv\">10<\/span>, <span class=\"dv\">12<\/span>, <span class=\"dv\">14<\/span>, <span class=\"dv\">16<\/span>, <span class=\"dv\">18<\/span>, -<span class=\"dv\">3<\/span>, <span class=\"dv\">14<\/span>, <span class=\"dv\">12<\/span>, <span class=\"dv\">16<\/span>, <span class=\"dv\">16<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb21-20\" title=\"20\">            });<\/a>\n+<a class=\"sourceLine\" id=\"cb21-21\" title=\"21\">            <span class=\"dt\">int<\/span> info, m, n, lda, ldb, nrhs;<\/a>\n+<a class=\"sourceLine\" id=\"cb21-22\" title=\"22\"><\/a>\n+<a class=\"sourceLine\" id=\"cb21-23\" title=\"23\">            <span class=\"co\">\/* Initialization *\/<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb21-24\" title=\"24\">            m = <span class=\"dv\">5<\/span>;<\/a>\n+<a class=\"sourceLine\" id=\"cb21-25\" title=\"25\">            n = <span class=\"dv\">3<\/span>;<\/a>\n+<a class=\"sourceLine\" id=\"cb21-26\" title=\"26\">            nrhs = <span class=\"dv\">2<\/span>;<\/a>\n+<a class=\"sourceLine\" id=\"cb21-27\" title=\"27\">            lda = <span class=\"dv\">5<\/span>;<\/a>\n+<a class=\"sourceLine\" id=\"cb21-28\" title=\"28\">            ldb = <span class=\"dv\">5<\/span>;<\/a>\n+<a class=\"sourceLine\" id=\"cb21-29\" title=\"29\"><\/a>\n+<a class=\"sourceLine\" id=\"cb21-30\" title=\"30\">            <span class=\"co\">\/* Print Entry Matrix *\/<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb21-31\" title=\"31\">            <span class=\"fu\">print_matrix_colmajor<\/span>(<span class=\"st\">&quot;Entry Matrix A&quot;<\/span>, m, n, A, lda );<\/a>\n+<a class=\"sourceLine\" id=\"cb21-32\" title=\"32\">            <span class=\"co\">\/* Print Right Rand Side *\/<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb21-33\" title=\"33\">            <span class=\"fu\">print_matrix_colmajor<\/span>(<span class=\"st\">&quot;Right Hand Side b&quot;<\/span>, n, nrhs, b, ldb );<\/a>\n+<a class=\"sourceLine\" id=\"cb21-34\" title=\"34\">            <span class=\"bu\">System<\/span>.<span class=\"fu\">out<\/span>.<span class=\"fu\">println<\/span>();<\/a>\n+<a class=\"sourceLine\" id=\"cb21-35\" title=\"35\">            <\/a>\n+<a class=\"sourceLine\" id=\"cb21-36\" title=\"36\">            <span class=\"co\">\/* Executable statements *\/<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb21-37\" title=\"37\">            <span class=\"co\">\/\/            printf( &quot;LAPACKE_dgels (col-major, high-level) Example Program Results\\n&quot; );<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb21-38\" title=\"38\">            <span class=\"co\">\/* Solve least squares problem*\/<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb21-39\" title=\"39\">            info = <span class=\"fu\">LAPACKE_dgels<\/span>(<span class=\"fu\">LAPACK_COL_MAJOR<\/span>(), (<span class=\"dt\">byte<\/span>)<span class=\"ch\">&#39;N&#39;<\/span>, m, n, nrhs, A, lda, b, ldb);<\/a>\n+<a class=\"sourceLine\" id=\"cb21-40\" title=\"40\"> <\/a>\n+<a class=\"sourceLine\" id=\"cb21-41\" title=\"41\">            <span class=\"co\">\/* Print Solution *\/<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb21-42\" title=\"42\">            <span class=\"fu\">print_matrix_colmajor<\/span>(<span class=\"st\">&quot;Solution&quot;<\/span>, n, nrhs, b, ldb );<\/a>\n+<a class=\"sourceLine\" id=\"cb21-43\" title=\"43\">            <span class=\"bu\">System<\/span>.<span class=\"fu\">out<\/span>.<span class=\"fu\">println<\/span>();<\/a>\n+<a class=\"sourceLine\" id=\"cb21-44\" title=\"44\">            <span class=\"bu\">System<\/span>.<span class=\"fu\">exit<\/span>(info);<\/a>\n+<a class=\"sourceLine\" id=\"cb21-45\" title=\"45\">        }   <\/a>\n+<a class=\"sourceLine\" id=\"cb21-46\" title=\"46\">    }   <\/a>\n+<a class=\"sourceLine\" id=\"cb21-47\" title=\"47\">    <\/a>\n+<a class=\"sourceLine\" id=\"cb21-48\" title=\"48\">    <span class=\"dt\">static<\/span> <span class=\"dt\">void<\/span> <span class=\"fu\">print_matrix_colmajor<\/span>(<span class=\"bu\">String<\/span> msg, <span class=\"dt\">int<\/span> m, <span class=\"dt\">int<\/span> n, MemorySegment mat, <span class=\"dt\">int<\/span> ldm) {<\/a>\n+<a class=\"sourceLine\" id=\"cb21-49\" title=\"49\">        <span class=\"dt\">int<\/span> i, j;<\/a>\n+<a class=\"sourceLine\" id=\"cb21-50\" title=\"50\">        <span class=\"bu\">System<\/span>.<span class=\"fu\">out.printf<\/span>(<span class=\"st\">&quot;<\/span><span class=\"sc\">\\n<\/span><span class=\"st\"> <\/span><span class=\"sc\">%s\\n<\/span><span class=\"st\">&quot;<\/span>, msg);<\/a>\n+<a class=\"sourceLine\" id=\"cb21-51\" title=\"51\"><\/a>\n+<a class=\"sourceLine\" id=\"cb21-52\" title=\"52\">        <span class=\"kw\">for<\/span>( i = <span class=\"dv\">0<\/span>; i &lt; m; i++ ) {<\/a>\n+<a class=\"sourceLine\" id=\"cb21-53\" title=\"53\">            <span class=\"kw\">for<\/span>( j = <span class=\"dv\">0<\/span>; j &lt; n; j++ ) <span class=\"bu\">System<\/span>.<span class=\"fu\">out.printf<\/span>(<span class=\"st\">&quot; <\/span><span class=\"sc\">%6.2f<\/span><span class=\"st\">&quot;<\/span>, MemoryAccess.<span class=\"fu\">getDoubleAtIndex<\/span>(mat, i+j*ldm));<\/a>\n+<a class=\"sourceLine\" id=\"cb21-54\" title=\"54\">            <span class=\"bu\">System<\/span>.<span class=\"fu\">out.printf<\/span>( <span class=\"st\">&quot;<\/span><span class=\"sc\">\\n<\/span><span class=\"st\">&quot;<\/span> );<\/a>\n+<a class=\"sourceLine\" id=\"cb21-55\" title=\"55\">        }<\/a>\n+<a class=\"sourceLine\" id=\"cb21-56\" title=\"56\">    }<\/a>\n+<a class=\"sourceLine\" id=\"cb21-57\" title=\"57\">}<\/a><\/code><\/pre><\/div>\n+<h3 id=\"compiling-and-running-the-above-lapack-sample\">Compiling and running the above LAPACK sample<\/h3>\n+<div class=\"sourceCode\" id=\"cb22\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><a class=\"sourceLine\" id=\"cb22-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb22-2\" title=\"2\"><span class=\"ex\">java<\/span> -Dforeign.restricted=permit \\<\/a>\n+<a class=\"sourceLine\" id=\"cb22-3\" title=\"3\">    --add-modules jdk.incubator.foreign \\<\/a>\n+<a class=\"sourceLine\" id=\"cb22-4\" title=\"4\">    -Djava.library.path=\/usr\/local\/opt\/lapack\/lib \\<\/a>\n+<a class=\"sourceLine\" id=\"cb22-5\" title=\"5\">    TestLapack.java<\/a><\/code><\/pre><\/div>\n+<h2 id=\"using-libproc-library-to-list-processes-from-java-mac-os\">Using libproc library to list processes from Java (Mac OS)<\/h2>\n+<h3 id=\"jextract-libproc.h\">jextract libproc.h<\/h3>\n+<div class=\"sourceCode\" id=\"cb23\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><a class=\"sourceLine\" id=\"cb23-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb23-2\" title=\"2\"><span class=\"ex\">jextract<\/span> \\<\/a>\n+<a class=\"sourceLine\" id=\"cb23-3\" title=\"3\">  -t org.unix \\<\/a>\n+<a class=\"sourceLine\" id=\"cb23-4\" title=\"4\">  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\<\/a>\n+<a class=\"sourceLine\" id=\"cb23-5\" title=\"5\">  --filter libproc.h \\<\/a>\n+<a class=\"sourceLine\" id=\"cb23-6\" title=\"6\">  \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/libproc.h<\/a><\/code><\/pre><\/div>\n+<h3 id=\"java-program-that-uses-libproc-to-list-processes\">Java program that uses libproc to list processes<\/h3>\n+<div class=\"sourceCode\" id=\"cb24\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb24-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb24-2\" title=\"2\"><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.CLinker;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb24-3\" title=\"3\"><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.MemorySegment;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb24-4\" title=\"4\"><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.NativeScope;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb24-5\" title=\"5\"><span class=\"kw\">import<\/span><span class=\"im\"> org.unix.*;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb24-6\" title=\"6\"><span class=\"kw\">import static<\/span><span class=\"im\"> jdk.incubator.foreign.MemoryAddress.NULL;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb24-7\" title=\"7\"><span class=\"kw\">import static<\/span><span class=\"im\"> org.unix.libproc_h.*;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb24-8\" title=\"8\"><\/a>\n+<a class=\"sourceLine\" id=\"cb24-9\" title=\"9\"><span class=\"kw\">public<\/span> <span class=\"kw\">class<\/span> LibprocMain {<\/a>\n+<a class=\"sourceLine\" id=\"cb24-10\" title=\"10\">    <span class=\"kw\">private<\/span> <span class=\"dt\">static<\/span> <span class=\"dt\">final<\/span> <span class=\"dt\">int<\/span> NAME_BUF_MAX = <span class=\"dv\">256<\/span>;<\/a>\n+<a class=\"sourceLine\" id=\"cb24-11\" title=\"11\"><\/a>\n+<a class=\"sourceLine\" id=\"cb24-12\" title=\"12\">    <span class=\"kw\">public<\/span> <span class=\"dt\">static<\/span> <span class=\"dt\">void<\/span> <span class=\"fu\">main<\/span>(<span class=\"bu\">String<\/span>[] args) {<\/a>\n+<a class=\"sourceLine\" id=\"cb24-13\" title=\"13\">        <span class=\"kw\">try<\/span> (var scope = NativeScope.<span class=\"fu\">unboundedScope<\/span>()) {<\/a>\n+<a class=\"sourceLine\" id=\"cb24-14\" title=\"14\">            <span class=\"co\">\/\/ get the number of processes<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb24-15\" title=\"15\">            <span class=\"dt\">int<\/span> numPids = <span class=\"fu\">proc_listallpids<\/span>(NULL, <span class=\"dv\">0<\/span>);<\/a>\n+<a class=\"sourceLine\" id=\"cb24-16\" title=\"16\">            <span class=\"co\">\/\/ allocate an array<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb24-17\" title=\"17\">            var pids = scope.<span class=\"fu\">allocateArray<\/span>(CLinker.<span class=\"fu\">C_INT<\/span>, numPids);<\/a>\n+<a class=\"sourceLine\" id=\"cb24-18\" title=\"18\">            <span class=\"co\">\/\/ list all the pids into the native array<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb24-19\" title=\"19\">            <span class=\"fu\">proc_listallpids<\/span>(pids, numPids);<\/a>\n+<a class=\"sourceLine\" id=\"cb24-20\" title=\"20\">            <span class=\"co\">\/\/ convert native array to java array<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb24-21\" title=\"21\">            <span class=\"dt\">int<\/span>[] jpids = pids.<span class=\"fu\">toIntArray<\/span>();<\/a>\n+<a class=\"sourceLine\" id=\"cb24-22\" title=\"22\">            <span class=\"co\">\/\/ buffer for process name<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb24-23\" title=\"23\">            var nameBuf = scope.<span class=\"fu\">allocateArray<\/span>(CLinker.<span class=\"fu\">C_CHAR<\/span>, NAME_BUF_MAX);<\/a>\n+<a class=\"sourceLine\" id=\"cb24-24\" title=\"24\">            <span class=\"kw\">for<\/span> (<span class=\"dt\">int<\/span> i = <span class=\"dv\">0<\/span>; i &lt; jpids.<span class=\"fu\">length<\/span>; i++) {<\/a>\n+<a class=\"sourceLine\" id=\"cb24-25\" title=\"25\">                <span class=\"dt\">int<\/span> pid = jpids[i];<\/a>\n+<a class=\"sourceLine\" id=\"cb24-26\" title=\"26\">                <span class=\"co\">\/\/ get the process name<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb24-27\" title=\"27\">                <span class=\"fu\">proc_name<\/span>(pid, nameBuf, NAME_BUF_MAX);<\/a>\n+<a class=\"sourceLine\" id=\"cb24-28\" title=\"28\">                <span class=\"bu\">String<\/span> procName = CLinker.<span class=\"fu\">toJavaString<\/span>(nameBuf);<\/a>\n+<a class=\"sourceLine\" id=\"cb24-29\" title=\"29\">                <span class=\"co\">\/\/ print pid and process name<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb24-30\" title=\"30\">                <span class=\"bu\">System<\/span>.<span class=\"fu\">out.printf<\/span>(<span class=\"st\">&quot;<\/span><span class=\"sc\">%d<\/span><span class=\"st\"> <\/span><span class=\"sc\">%s\\n<\/span><span class=\"st\">&quot;<\/span>, pid, procName);<\/a>\n+<a class=\"sourceLine\" id=\"cb24-31\" title=\"31\">            }<\/a>\n+<a class=\"sourceLine\" id=\"cb24-32\" title=\"32\">        }<\/a>\n+<a class=\"sourceLine\" id=\"cb24-33\" title=\"33\">    }<\/a>\n+<a class=\"sourceLine\" id=\"cb24-34\" title=\"34\">}<\/a><\/code><\/pre><\/div>\n+<h3 id=\"compiling-and-running-the-libproc-sample\">Compiling and running the libproc sample<\/h3>\n+<div class=\"sourceCode\" id=\"cb25\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><a class=\"sourceLine\" id=\"cb25-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb25-2\" title=\"2\"><span class=\"ex\">java<\/span> -Dforeign.restricted=permit \\<\/a>\n+<a class=\"sourceLine\" id=\"cb25-3\" title=\"3\">    --add-modules jdk.incubator.foreign \\<\/a>\n+<a class=\"sourceLine\" id=\"cb25-4\" title=\"4\">    -Djava.library.path=\/usr\/lib LibprocMain.java<\/a><\/code><\/pre><\/div>\n+<h2 id=\"using-libgit2-from-java-mac-os\">Using libgit2 from Java (Mac OS)<\/h2>\n+<h3 id=\"getting-and-building-libgit2\">Getting and building libgit2<\/h3>\n+<ul>\n+<li>Download libgit2 v1.0.0 source from https:\/\/github.com\/libgit2\/libgit2\/releases<\/li>\n+<li>Use cmake to build from libgit2<\/li>\n+<li>Let ${LIBGIT2_HOME} be the directory where you expanded libgit2 sources.<\/li>\n+<li>Let ${LIBGIT2_HOME}\/build be the build directory where libgit2.dylib is built.<\/li>\n+<\/ul>\n+<h3 id=\"jextract-git2.h\">jextract git2.h<\/h3>\n+<div class=\"sourceCode\" id=\"cb26\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><a class=\"sourceLine\" id=\"cb26-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb26-2\" title=\"2\"><span class=\"ex\">jextract<\/span> \\<\/a>\n+<a class=\"sourceLine\" id=\"cb26-3\" title=\"3\">  -t com.github -lgit2 \\<\/a>\n+<a class=\"sourceLine\" id=\"cb26-4\" title=\"4\">  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/ \\<\/a>\n+<a class=\"sourceLine\" id=\"cb26-5\" title=\"5\">  -I <span class=\"va\">${LIBGIT2_HOME}<\/span>\/include\/ \\<\/a>\n+<a class=\"sourceLine\" id=\"cb26-6\" title=\"6\">  -I <span class=\"va\">${LIBGIT2_HOME}<\/span>\/include\/git2 \\<\/a>\n+<a class=\"sourceLine\" id=\"cb26-7\" title=\"7\">  <span class=\"va\">${LIBGIT2_HOME}<\/span>\/include\/git2.h<\/a><\/code><\/pre><\/div>\n+<h3 id=\"java-program-that-uses-libgit2-to-clone-github-repo\">Java program that uses libgit2 to clone github repo<\/h3>\n+<div class=\"sourceCode\" id=\"cb27\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb27-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb27-2\" title=\"2\"><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.MemoryAddress;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb27-3\" title=\"3\"><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.NativeScope;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb27-4\" title=\"4\"><span class=\"kw\">import static<\/span><span class=\"im\"> com.github.git2_h.*;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb27-5\" title=\"5\"><span class=\"kw\">import static<\/span><span class=\"im\"> jdk.incubator.foreign.CLinker.*;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb27-6\" title=\"6\"><span class=\"kw\">import static<\/span><span class=\"im\"> jdk.incubator.foreign.MemoryAddress.NULL;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb27-7\" title=\"7\"><\/a>\n+<a class=\"sourceLine\" id=\"cb27-8\" title=\"8\"><span class=\"kw\">public<\/span> <span class=\"kw\">class<\/span> GitClone {<\/a>\n+<a class=\"sourceLine\" id=\"cb27-9\" title=\"9\">    <span class=\"kw\">public<\/span> <span class=\"dt\">static<\/span> <span class=\"dt\">void<\/span> <span class=\"fu\">main<\/span>(<span class=\"bu\">String<\/span>[] args) {<\/a>\n+<a class=\"sourceLine\" id=\"cb27-10\" title=\"10\">          <span class=\"kw\">if<\/span> (args.<span class=\"fu\">length<\/span> != <span class=\"dv\">2<\/span>) {<\/a>\n+<a class=\"sourceLine\" id=\"cb27-11\" title=\"11\">              <span class=\"bu\">System<\/span>.<span class=\"fu\">err<\/span>.<span class=\"fu\">println<\/span>(<span class=\"st\">&quot;java GitClone &lt;url&gt; &lt;path&gt;&quot;<\/span>);<\/a>\n+<a class=\"sourceLine\" id=\"cb27-12\" title=\"12\">              <span class=\"bu\">System<\/span>.<span class=\"fu\">exit<\/span>(<span class=\"dv\">1<\/span>);<\/a>\n+<a class=\"sourceLine\" id=\"cb27-13\" title=\"13\">          }<\/a>\n+<a class=\"sourceLine\" id=\"cb27-14\" title=\"14\">          <span class=\"fu\">git_libgit2_init<\/span>();<\/a>\n+<a class=\"sourceLine\" id=\"cb27-15\" title=\"15\">          <span class=\"kw\">try<\/span> (var scope = NativeScope.<span class=\"fu\">unboundedScope<\/span>()) {<\/a>\n+<a class=\"sourceLine\" id=\"cb27-16\" title=\"16\">              var repo = scope.<span class=\"fu\">allocate<\/span>(C_POINTER);<\/a>\n+<a class=\"sourceLine\" id=\"cb27-17\" title=\"17\">              var url = <span class=\"fu\">toCString<\/span>(args[<span class=\"dv\">0<\/span>], scope);<\/a>\n+<a class=\"sourceLine\" id=\"cb27-18\" title=\"18\">              var path = <span class=\"fu\">toCString<\/span>(args[<span class=\"dv\">1<\/span>], scope);<\/a>\n+<a class=\"sourceLine\" id=\"cb27-19\" title=\"19\">              <span class=\"bu\">System<\/span>.<span class=\"fu\">out<\/span>.<span class=\"fu\">println<\/span>(<span class=\"fu\">git_clone<\/span>(repo, url, path, NULL));<\/a>\n+<a class=\"sourceLine\" id=\"cb27-20\" title=\"20\">          }<\/a>\n+<a class=\"sourceLine\" id=\"cb27-21\" title=\"21\">          <span class=\"fu\">git_libgit2_shutdown<\/span>();<\/a>\n+<a class=\"sourceLine\" id=\"cb27-22\" title=\"22\">    }<\/a>\n+<a class=\"sourceLine\" id=\"cb27-23\" title=\"23\">}<\/a><\/code><\/pre><\/div>\n+<h3 id=\"compiling-and-running-the-libgit2-sample\">Compiling and running the libgit2 sample<\/h3>\n+<div class=\"sourceCode\" id=\"cb28\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><a class=\"sourceLine\" id=\"cb28-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb28-2\" title=\"2\"><span class=\"co\"># file run.sh<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb28-3\" title=\"3\"><\/a>\n+<a class=\"sourceLine\" id=\"cb28-4\" title=\"4\"><span class=\"ex\">java<\/span> -Dforeign.restricted=permit --add-modules jdk.incubator.foreign \\<\/a>\n+<a class=\"sourceLine\" id=\"cb28-5\" title=\"5\">    -Djava.library.path=<span class=\"va\">${LIBGIT2_HOME}<\/span>\/build\/ \\<\/a>\n+<a class=\"sourceLine\" id=\"cb28-6\" title=\"6\">    GitClone.java <span class=\"va\">$*<\/span><\/a><\/code><\/pre><\/div>\n+<h3 id=\"cloning-a-github-repo-using-the-above-run.sh-command\">Cloning a github repo using the above run.sh command<\/h3>\n+<div class=\"sourceCode\" id=\"cb29\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><a class=\"sourceLine\" id=\"cb29-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb29-2\" title=\"2\"><span class=\"fu\">sh<\/span> run.sh https:\/\/github.com\/libgit2\/libgit2.git libgit2<\/a><\/code><\/pre><\/div>\n+<h2 id=\"using-sqlite3-library-from-java-mac-os\">Using sqlite3 library from Java (Mac OS)<\/h2>\n+<h3 id=\"jextract-sqlite3.h\">jextract sqlite3.h<\/h3>\n+<div class=\"sourceCode\" id=\"cb30\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><a class=\"sourceLine\" id=\"cb30-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb30-2\" title=\"2\"><span class=\"ex\">jextract<\/span> \\<\/a>\n+<a class=\"sourceLine\" id=\"cb30-3\" title=\"3\">  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\<\/a>\n+<a class=\"sourceLine\" id=\"cb30-4\" title=\"4\">  \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/sqlite3.h \\<\/a>\n+<a class=\"sourceLine\" id=\"cb30-5\" title=\"5\">  -t org.sqlite -lsqlite3<\/a><\/code><\/pre><\/div>\n+<h3 id=\"java-program-that-uses-sqlite3\">Java program that uses sqlite3<\/h3>\n+<div class=\"sourceCode\" id=\"cb31\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb31-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb31-2\" title=\"2\"><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.MemoryAddress;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb31-3\" title=\"3\"><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.MemoryAccess;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb31-4\" title=\"4\"><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.NativeScope;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb31-5\" title=\"5\"><span class=\"kw\">import static<\/span><span class=\"im\"> jdk.incubator.foreign.MemoryAddress.NULL;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb31-6\" title=\"6\"><span class=\"kw\">import static<\/span><span class=\"im\"> org.sqlite.sqlite3_h.*;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb31-7\" title=\"7\"><span class=\"kw\">import static<\/span><span class=\"im\"> jdk.incubator.foreign.CLinker.*;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb31-8\" title=\"8\"><\/a>\n+<a class=\"sourceLine\" id=\"cb31-9\" title=\"9\"><span class=\"kw\">public<\/span> <span class=\"kw\">class<\/span> SqliteMain {<\/a>\n+<a class=\"sourceLine\" id=\"cb31-10\" title=\"10\">   <span class=\"kw\">public<\/span> <span class=\"dt\">static<\/span> <span class=\"dt\">void<\/span> <span class=\"fu\">main<\/span>(<span class=\"bu\">String<\/span>[] args) <span class=\"kw\">throws<\/span> <span class=\"bu\">Exception<\/span> {<\/a>\n+<a class=\"sourceLine\" id=\"cb31-11\" title=\"11\">        <span class=\"kw\">try<\/span> (var scope = NativeScope.<span class=\"fu\">unboundedScope<\/span>()) {<\/a>\n+<a class=\"sourceLine\" id=\"cb31-12\" title=\"12\">            <span class=\"co\">\/\/ char** errMsgPtrPtr;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb31-13\" title=\"13\">            var errMsgPtrPtr = scope.<span class=\"fu\">allocate<\/span>(C_POINTER);<\/a>\n+<a class=\"sourceLine\" id=\"cb31-14\" title=\"14\"><\/a>\n+<a class=\"sourceLine\" id=\"cb31-15\" title=\"15\">            <span class=\"co\">\/\/ sqlite3** dbPtrPtr;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb31-16\" title=\"16\">            var dbPtrPtr = scope.<span class=\"fu\">allocate<\/span>(C_POINTER);<\/a>\n+<a class=\"sourceLine\" id=\"cb31-17\" title=\"17\"><\/a>\n+<a class=\"sourceLine\" id=\"cb31-18\" title=\"18\">            <span class=\"dt\">int<\/span> rc = <span class=\"fu\">sqlite3_open<\/span>(<span class=\"fu\">toCString<\/span>(<span class=\"st\">&quot;employee.db&quot;<\/span>,scope), dbPtrPtr);<\/a>\n+<a class=\"sourceLine\" id=\"cb31-19\" title=\"19\">            <span class=\"kw\">if<\/span> (rc != <span class=\"dv\">0<\/span>) {<\/a>\n+<a class=\"sourceLine\" id=\"cb31-20\" title=\"20\">                <span class=\"bu\">System<\/span>.<span class=\"fu\">err<\/span>.<span class=\"fu\">println<\/span>(<span class=\"st\">&quot;sqlite3_open failed: &quot;<\/span> + rc);<\/a>\n+<a class=\"sourceLine\" id=\"cb31-21\" title=\"21\">                <span class=\"kw\">return<\/span>;<\/a>\n+<a class=\"sourceLine\" id=\"cb31-22\" title=\"22\">            } <span class=\"kw\">else<\/span> {<\/a>\n+<a class=\"sourceLine\" id=\"cb31-23\" title=\"23\">                <span class=\"bu\">System<\/span>.<span class=\"fu\">out<\/span>.<span class=\"fu\">println<\/span>(<span class=\"st\">&quot;employee db opened&quot;<\/span>);<\/a>\n+<a class=\"sourceLine\" id=\"cb31-24\" title=\"24\">            }<\/a>\n+<a class=\"sourceLine\" id=\"cb31-25\" title=\"25\"><\/a>\n+<a class=\"sourceLine\" id=\"cb31-26\" title=\"26\">            <span class=\"co\">\/\/ sqlite3* dbPtr;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb31-27\" title=\"27\">            var dbPtr = MemoryAccess.<span class=\"fu\">getAddress<\/span>(dbPtrPtr);<\/a>\n+<a class=\"sourceLine\" id=\"cb31-28\" title=\"28\"><\/a>\n+<a class=\"sourceLine\" id=\"cb31-29\" title=\"29\">            <span class=\"co\">\/\/ create a new table<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb31-30\" title=\"30\">            var sql = <span class=\"fu\">toCString<\/span>(<\/a>\n+<a class=\"sourceLine\" id=\"cb31-31\" title=\"31\">                <span class=\"st\">&quot;CREATE TABLE EMPLOYEE (&quot;<\/span>  +<\/a>\n+<a class=\"sourceLine\" id=\"cb31-32\" title=\"32\">                <span class=\"st\">&quot;  ID INT PRIMARY KEY NOT NULL,&quot;<\/span> +<\/a>\n+<a class=\"sourceLine\" id=\"cb31-33\" title=\"33\">                <span class=\"st\">&quot;  NAME TEXT NOT NULL,&quot;<\/span>    +<\/a>\n+<a class=\"sourceLine\" id=\"cb31-34\" title=\"34\">                <span class=\"st\">&quot;  SALARY REAL NOT NULL )&quot;<\/span>, scope);<\/a>\n+<a class=\"sourceLine\" id=\"cb31-35\" title=\"35\"><\/a>\n+<a class=\"sourceLine\" id=\"cb31-36\" title=\"36\">            rc = <span class=\"fu\">sqlite3_exec<\/span>(dbPtr, sql, NULL, NULL, errMsgPtrPtr);<\/a>\n+<a class=\"sourceLine\" id=\"cb31-37\" title=\"37\"><\/a>\n+<a class=\"sourceLine\" id=\"cb31-38\" title=\"38\">            <span class=\"kw\">if<\/span> (rc != <span class=\"dv\">0<\/span>) {<\/a>\n+<a class=\"sourceLine\" id=\"cb31-39\" title=\"39\">                <span class=\"bu\">System<\/span>.<span class=\"fu\">err<\/span>.<span class=\"fu\">println<\/span>(<span class=\"st\">&quot;sqlite3_exec failed: &quot;<\/span> + rc);<\/a>\n+<a class=\"sourceLine\" id=\"cb31-40\" title=\"40\">                <span class=\"bu\">System<\/span>.<span class=\"fu\">err<\/span>.<span class=\"fu\">println<\/span>(<span class=\"st\">&quot;SQL error: &quot;<\/span> + <span class=\"fu\">toJavaStringRestricted<\/span>(MemoryAccess.<span class=\"fu\">getAddress<\/span>(errMsgPtrPtr)));<\/a>\n+<a class=\"sourceLine\" id=\"cb31-41\" title=\"41\">                <span class=\"fu\">sqlite3_free<\/span>(MemoryAccess.<span class=\"fu\">getAddress<\/span>(errMsgPtrPtr));<\/a>\n+<a class=\"sourceLine\" id=\"cb31-42\" title=\"42\">            } <span class=\"kw\">else<\/span> {<\/a>\n+<a class=\"sourceLine\" id=\"cb31-43\" title=\"43\">                <span class=\"bu\">System<\/span>.<span class=\"fu\">out<\/span>.<span class=\"fu\">println<\/span>(<span class=\"st\">&quot;employee table created&quot;<\/span>);<\/a>\n+<a class=\"sourceLine\" id=\"cb31-44\" title=\"44\">            }<\/a>\n+<a class=\"sourceLine\" id=\"cb31-45\" title=\"45\"><\/a>\n+<a class=\"sourceLine\" id=\"cb31-46\" title=\"46\">            <span class=\"co\">\/\/ insert two rows<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb31-47\" title=\"47\">            sql = <span class=\"fu\">toCString<\/span>(<\/a>\n+<a class=\"sourceLine\" id=\"cb31-48\" title=\"48\">                <span class=\"st\">&quot;INSERT INTO EMPLOYEE (ID,NAME,SALARY) &quot;<\/span> +<\/a>\n+<a class=\"sourceLine\" id=\"cb31-49\" title=\"49\">                    <span class=\"st\">&quot;VALUES (134, &#39;Xyz&#39;, 200000.0); &quot;<\/span> +<\/a>\n+<a class=\"sourceLine\" id=\"cb31-50\" title=\"50\">                <span class=\"st\">&quot;INSERT INTO EMPLOYEE (ID,NAME,SALARY) &quot;<\/span> +<\/a>\n+<a class=\"sourceLine\" id=\"cb31-51\" title=\"51\">                    <span class=\"st\">&quot;VALUES (333, &#39;Abc&#39;, 100000.0);&quot;<\/span>, scope<\/a>\n+<a class=\"sourceLine\" id=\"cb31-52\" title=\"52\">            );<\/a>\n+<a class=\"sourceLine\" id=\"cb31-53\" title=\"53\">            rc = <span class=\"fu\">sqlite3_exec<\/span>(dbPtr, sql, NULL, NULL, errMsgPtrPtr);<\/a>\n+<a class=\"sourceLine\" id=\"cb31-54\" title=\"54\"><\/a>\n+<a class=\"sourceLine\" id=\"cb31-55\" title=\"55\">            <span class=\"kw\">if<\/span> (rc != <span class=\"dv\">0<\/span>) {<\/a>\n+<a class=\"sourceLine\" id=\"cb31-56\" title=\"56\">                <span class=\"bu\">System<\/span>.<span class=\"fu\">err<\/span>.<span class=\"fu\">println<\/span>(<span class=\"st\">&quot;sqlite3_exec failed: &quot;<\/span> + rc);<\/a>\n+<a class=\"sourceLine\" id=\"cb31-57\" title=\"57\">                <span class=\"bu\">System<\/span>.<span class=\"fu\">err<\/span>.<span class=\"fu\">println<\/span>(<span class=\"st\">&quot;SQL error: &quot;<\/span> + <span class=\"fu\">toJavaStringRestricted<\/span>(MemoryAccess.<span class=\"fu\">getAddress<\/span>(errMsgPtrPtr)));<\/a>\n+<a class=\"sourceLine\" id=\"cb31-58\" title=\"58\">                <span class=\"fu\">sqlite3_free<\/span>(MemoryAccess.<span class=\"fu\">getAddress<\/span>(errMsgPtrPtr));<\/a>\n+<a class=\"sourceLine\" id=\"cb31-59\" title=\"59\">            } <span class=\"kw\">else<\/span> {<\/a>\n+<a class=\"sourceLine\" id=\"cb31-60\" title=\"60\">                <span class=\"bu\">System<\/span>.<span class=\"fu\">out<\/span>.<span class=\"fu\">println<\/span>(<span class=\"st\">&quot;rows inserted&quot;<\/span>);<\/a>\n+<a class=\"sourceLine\" id=\"cb31-61\" title=\"61\">            }<\/a>\n+<a class=\"sourceLine\" id=\"cb31-62\" title=\"62\"><\/a>\n+<a class=\"sourceLine\" id=\"cb31-63\" title=\"63\">            <span class=\"dt\">int<\/span>[] rowNum = <span class=\"kw\">new<\/span> <span class=\"dt\">int<\/span>[<span class=\"dv\">1<\/span>];<\/a>\n+<a class=\"sourceLine\" id=\"cb31-64\" title=\"64\">            <span class=\"co\">\/\/ callback to print rows from SELECT query<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb31-65\" title=\"65\">            var callback = sqlite3_exec$callback.<span class=\"fu\">allocate<\/span>((a, argc, argv, columnNames) -&gt; {<\/a>\n+<a class=\"sourceLine\" id=\"cb31-66\" title=\"66\">                <span class=\"bu\">System<\/span>.<span class=\"fu\">out<\/span>.<span class=\"fu\">println<\/span>(<span class=\"st\">&quot;Row num: &quot;<\/span> + rowNum[<span class=\"dv\">0<\/span>]++);<\/a>\n+<a class=\"sourceLine\" id=\"cb31-67\" title=\"67\">                <span class=\"bu\">System<\/span>.<span class=\"fu\">out<\/span>.<span class=\"fu\">println<\/span>(<span class=\"st\">&quot;numColumns = &quot;<\/span> + argc);<\/a>\n+<a class=\"sourceLine\" id=\"cb31-68\" title=\"68\">                var argv_seg = argv.<span class=\"fu\">asSegmentRestricted<\/span>(C_POINTER.<span class=\"fu\">byteSize<\/span>() * argc);<\/a>\n+<a class=\"sourceLine\" id=\"cb31-69\" title=\"69\">                var columnNames_seg = columnNames.<span class=\"fu\">asSegmentRestricted<\/span>(C_POINTER.<span class=\"fu\">byteSize<\/span>() * argc);<\/a>\n+<a class=\"sourceLine\" id=\"cb31-70\" title=\"70\">                <span class=\"kw\">for<\/span> (<span class=\"dt\">int<\/span> i = <span class=\"dv\">0<\/span>; i &lt; argc; i++) {<\/a>\n+<a class=\"sourceLine\" id=\"cb31-71\" title=\"71\">                     <span class=\"bu\">String<\/span> name = <span class=\"fu\">toJavaStringRestricted<\/span>(MemoryAccess.<span class=\"fu\">getAddressAtIndex<\/span>(columnNames_seg, i));<\/a>\n+<a class=\"sourceLine\" id=\"cb31-72\" title=\"72\">                     <span class=\"bu\">String<\/span> value = <span class=\"fu\">toJavaStringRestricted<\/span>(MemoryAccess.<span class=\"fu\">getAddressAtIndex<\/span>(argv_seg, i));<\/a>\n+<a class=\"sourceLine\" id=\"cb31-73\" title=\"73\">                     <span class=\"bu\">System<\/span>.<span class=\"fu\">out.printf<\/span>(<span class=\"st\">&quot;<\/span><span class=\"sc\">%s<\/span><span class=\"st\"> = <\/span><span class=\"sc\">%s\\n<\/span><span class=\"st\">&quot;<\/span>, name, value);<\/a>\n+<a class=\"sourceLine\" id=\"cb31-74\" title=\"74\">                }<\/a>\n+<a class=\"sourceLine\" id=\"cb31-75\" title=\"75\">                <span class=\"kw\">return<\/span> <span class=\"dv\">0<\/span>;<\/a>\n+<a class=\"sourceLine\" id=\"cb31-76\" title=\"76\">            }, scope);<\/a>\n+<a class=\"sourceLine\" id=\"cb31-77\" title=\"77\"><\/a>\n+<a class=\"sourceLine\" id=\"cb31-78\" title=\"78\">            <span class=\"co\">\/\/ select query<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb31-79\" title=\"79\">            sql = <span class=\"fu\">toCString<\/span>(<span class=\"st\">&quot;SELECT * FROM EMPLOYEE&quot;<\/span>, scope);<\/a>\n+<a class=\"sourceLine\" id=\"cb31-80\" title=\"80\">            rc = <span class=\"fu\">sqlite3_exec<\/span>(dbPtr, sql, callback, NULL, errMsgPtrPtr);<\/a>\n+<a class=\"sourceLine\" id=\"cb31-81\" title=\"81\"><\/a>\n+<a class=\"sourceLine\" id=\"cb31-82\" title=\"82\">            <span class=\"kw\">if<\/span> (rc != <span class=\"dv\">0<\/span>) {<\/a>\n+<a class=\"sourceLine\" id=\"cb31-83\" title=\"83\">                <span class=\"bu\">System<\/span>.<span class=\"fu\">err<\/span>.<span class=\"fu\">println<\/span>(<span class=\"st\">&quot;sqlite3_exec failed: &quot;<\/span> + rc);<\/a>\n+<a class=\"sourceLine\" id=\"cb31-84\" title=\"84\">                <span class=\"bu\">System<\/span>.<span class=\"fu\">err<\/span>.<span class=\"fu\">println<\/span>(<span class=\"st\">&quot;SQL error: &quot;<\/span> + <span class=\"fu\">toJavaStringRestricted<\/span>(MemoryAccess.<span class=\"fu\">getAddress<\/span>(errMsgPtrPtr)));<\/a>\n+<a class=\"sourceLine\" id=\"cb31-85\" title=\"85\">                <span class=\"fu\">sqlite3_free<\/span>(MemoryAccess.<span class=\"fu\">getAddress<\/span>(errMsgPtrPtr));<\/a>\n+<a class=\"sourceLine\" id=\"cb31-86\" title=\"86\">            } <span class=\"kw\">else<\/span> {<\/a>\n+<a class=\"sourceLine\" id=\"cb31-87\" title=\"87\">                <span class=\"bu\">System<\/span>.<span class=\"fu\">out<\/span>.<span class=\"fu\">println<\/span>(<span class=\"st\">&quot;done&quot;<\/span>);<\/a>\n+<a class=\"sourceLine\" id=\"cb31-88\" title=\"88\">            }<\/a>\n+<a class=\"sourceLine\" id=\"cb31-89\" title=\"89\"><\/a>\n+<a class=\"sourceLine\" id=\"cb31-90\" title=\"90\">            <span class=\"fu\">sqlite3_close<\/span>(dbPtr);<\/a>\n+<a class=\"sourceLine\" id=\"cb31-91\" title=\"91\">        }<\/a>\n+<a class=\"sourceLine\" id=\"cb31-92\" title=\"92\">    }<\/a>\n+<a class=\"sourceLine\" id=\"cb31-93\" title=\"93\">}<\/a><\/code><\/pre><\/div>\n+<h3 id=\"compiling-and-running-the-sqlite3-sample\">Compiling and running the sqlite3 sample<\/h3>\n+<div class=\"sourceCode\" id=\"cb32\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><a class=\"sourceLine\" id=\"cb32-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb32-2\" title=\"2\"><span class=\"ex\">java<\/span> -Dforeign.restricted=permit \\<\/a>\n+<a class=\"sourceLine\" id=\"cb32-3\" title=\"3\">   --add-modules jdk.incubator.foreign \\<\/a>\n+<a class=\"sourceLine\" id=\"cb32-4\" title=\"4\">   -Djava.library.path=\/usr\/lib SqliteMain.java<\/a><\/code><\/pre><\/div>\n+<h2 id=\"using-opengl-library-from-java-mac-os\">Using OpenGL library from Java (Mac OS)<\/h2>\n+<h3 id=\"jextract-glut.h\">jextract glut.h<\/h3>\n+<div class=\"sourceCode\" id=\"cb33\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><a class=\"sourceLine\" id=\"cb33-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb33-2\" title=\"2\"><span class=\"ex\">jextract<\/span> -t opengl -lGL -l\/System\/Library\/Frameworks\/GLUT.framework\/Versions\/Current\/GLUT \\<\/a>\n+<a class=\"sourceLine\" id=\"cb33-3\" title=\"3\">  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/ \\<\/a>\n+<a class=\"sourceLine\" id=\"cb33-4\" title=\"4\">  -C-F\/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/System\/Library\/Frameworks \\<\/a>\n+<a class=\"sourceLine\" id=\"cb33-5\" title=\"5\">  \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/System\/Library\/Frameworks\/GLUT.framework\/Headers\/glut.h<\/a><\/code><\/pre><\/div>\n+<h3 id=\"java-program-that-uses-opengl\">Java program that uses OpenGL<\/h3>\n+<div class=\"sourceCode\" id=\"cb34\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb34-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb34-2\" title=\"2\"><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.CLinker;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb34-3\" title=\"3\"><span class=\"kw\">import static<\/span><span class=\"im\"> jdk.incubator.foreign.CLinker.*;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb34-4\" title=\"4\"><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.NativeScope;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb34-5\" title=\"5\"><span class=\"kw\">import static<\/span><span class=\"im\"> opengl.glut_h.*;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb34-6\" title=\"6\"><\/a>\n+<a class=\"sourceLine\" id=\"cb34-7\" title=\"7\"><span class=\"kw\">public<\/span> <span class=\"kw\">class<\/span> Teapot {<\/a>\n+<a class=\"sourceLine\" id=\"cb34-8\" title=\"8\">    <span class=\"kw\">private<\/span> <span class=\"dt\">float<\/span> rot = <span class=\"dv\">0<\/span>;<\/a>\n+<a class=\"sourceLine\" id=\"cb34-9\" title=\"9\"><\/a>\n+<a class=\"sourceLine\" id=\"cb34-10\" title=\"10\">    <span class=\"fu\">Teapot<\/span>(NativeScope scope) {<\/a>\n+<a class=\"sourceLine\" id=\"cb34-11\" title=\"11\">        <span class=\"co\">\/\/ Reset Background<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb34-12\" title=\"12\">        <span class=\"fu\">glClearColor<\/span>(<span class=\"fl\">0f<\/span>, <span class=\"fl\">0f<\/span>, <span class=\"fl\">0f<\/span>, <span class=\"fl\">0f<\/span>);<\/a>\n+<a class=\"sourceLine\" id=\"cb34-13\" title=\"13\">        <span class=\"co\">\/\/ Setup Lighting<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb34-14\" title=\"14\">        <span class=\"fu\">glShadeModel<\/span>(<span class=\"fu\">GL_SMOOTH<\/span>());<\/a>\n+<a class=\"sourceLine\" id=\"cb34-15\" title=\"15\">        var pos = scope.<span class=\"fu\">allocateArray<\/span>(C_FLOAT, <span class=\"kw\">new<\/span> <span class=\"dt\">float<\/span>[] {<span class=\"fl\">0.0f<\/span>, <span class=\"fl\">15.0f<\/span>, -<span class=\"fl\">15.0f<\/span>, <span class=\"dv\">0<\/span>});<\/a>\n+<a class=\"sourceLine\" id=\"cb34-16\" title=\"16\">        <span class=\"fu\">glLightfv<\/span>(<span class=\"fu\">GL_LIGHT0<\/span>(), <span class=\"fu\">GL_POSITION<\/span>(), pos);<\/a>\n+<a class=\"sourceLine\" id=\"cb34-17\" title=\"17\">        var spec = scope.<span class=\"fu\">allocateArray<\/span>(C_FLOAT, <span class=\"kw\">new<\/span> <span class=\"dt\">float<\/span>[] {<span class=\"dv\">1<\/span>, <span class=\"dv\">1<\/span>, <span class=\"dv\">1<\/span>, <span class=\"dv\">0<\/span>});<\/a>\n+<a class=\"sourceLine\" id=\"cb34-18\" title=\"18\">        <span class=\"fu\">glLightfv<\/span>(<span class=\"fu\">GL_LIGHT0<\/span>(), <span class=\"fu\">GL_AMBIENT<\/span>(), spec);<\/a>\n+<a class=\"sourceLine\" id=\"cb34-19\" title=\"19\">        <span class=\"fu\">glLightfv<\/span>(<span class=\"fu\">GL_LIGHT0<\/span>(), <span class=\"fu\">GL_DIFFUSE<\/span>(), spec);<\/a>\n+<a class=\"sourceLine\" id=\"cb34-20\" title=\"20\">        <span class=\"fu\">glLightfv<\/span>(<span class=\"fu\">GL_LIGHT0<\/span>(), <span class=\"fu\">GL_SPECULAR<\/span>(), spec);<\/a>\n+<a class=\"sourceLine\" id=\"cb34-21\" title=\"21\">        var shini = scope.<span class=\"fu\">allocate<\/span>(C_FLOAT, <span class=\"dv\">113<\/span>);<\/a>\n+<a class=\"sourceLine\" id=\"cb34-22\" title=\"22\">        <span class=\"fu\">glMaterialfv<\/span>(<span class=\"fu\">GL_FRONT<\/span>(), <span class=\"fu\">GL_SHININESS<\/span>(), shini);<\/a>\n+<a class=\"sourceLine\" id=\"cb34-23\" title=\"23\">        <span class=\"fu\">glEnable<\/span>(<span class=\"fu\">GL_LIGHTING<\/span>());<\/a>\n+<a class=\"sourceLine\" id=\"cb34-24\" title=\"24\">        <span class=\"fu\">glEnable<\/span>(<span class=\"fu\">GL_LIGHT0<\/span>());<\/a>\n+<a class=\"sourceLine\" id=\"cb34-25\" title=\"25\">        <span class=\"fu\">glEnable<\/span>(<span class=\"fu\">GL_DEPTH_TEST<\/span>());<\/a>\n+<a class=\"sourceLine\" id=\"cb34-26\" title=\"26\">    }<\/a>\n+<a class=\"sourceLine\" id=\"cb34-27\" title=\"27\"><\/a>\n+<a class=\"sourceLine\" id=\"cb34-28\" title=\"28\">    <span class=\"dt\">void<\/span> <span class=\"fu\">display<\/span>() {<\/a>\n+<a class=\"sourceLine\" id=\"cb34-29\" title=\"29\">        <span class=\"fu\">glClear<\/span>(<span class=\"fu\">GL_COLOR_BUFFER_BIT<\/span>() | <span class=\"fu\">GL_DEPTH_BUFFER_BIT<\/span>());<\/a>\n+<a class=\"sourceLine\" id=\"cb34-30\" title=\"30\">        <span class=\"fu\">glPushMatrix<\/span>();<\/a>\n+<a class=\"sourceLine\" id=\"cb34-31\" title=\"31\">        <span class=\"fu\">glRotatef<\/span>(-<span class=\"fl\">20f<\/span>, <span class=\"fl\">1f<\/span>, <span class=\"fl\">1f<\/span>, <span class=\"fl\">0f<\/span>);<\/a>\n+<a class=\"sourceLine\" id=\"cb34-32\" title=\"32\">        <span class=\"fu\">glRotatef<\/span>(rot, <span class=\"fl\">0f<\/span>, <span class=\"fl\">1f<\/span>, <span class=\"fl\">0f<\/span>);<\/a>\n+<a class=\"sourceLine\" id=\"cb34-33\" title=\"33\">        <span class=\"fu\">glutSolidTeapot<\/span>(<span class=\"fl\">0.5d<\/span>);<\/a>\n+<a class=\"sourceLine\" id=\"cb34-34\" title=\"34\">        <span class=\"fu\">glPopMatrix<\/span>();<\/a>\n+<a class=\"sourceLine\" id=\"cb34-35\" title=\"35\">        <span class=\"fu\">glutSwapBuffers<\/span>();<\/a>\n+<a class=\"sourceLine\" id=\"cb34-36\" title=\"36\">    }<\/a>\n+<a class=\"sourceLine\" id=\"cb34-37\" title=\"37\"><\/a>\n+<a class=\"sourceLine\" id=\"cb34-38\" title=\"38\">    <span class=\"dt\">void<\/span> <span class=\"fu\">onIdle<\/span>() {<\/a>\n+<a class=\"sourceLine\" id=\"cb34-39\" title=\"39\">        rot += <span class=\"fl\">0.<\/span><span class=\"dv\">1<\/span>;<\/a>\n+<a class=\"sourceLine\" id=\"cb34-40\" title=\"40\">        <span class=\"fu\">glutPostRedisplay<\/span>();<\/a>\n+<a class=\"sourceLine\" id=\"cb34-41\" title=\"41\">    }<\/a>\n+<a class=\"sourceLine\" id=\"cb34-42\" title=\"42\"><\/a>\n+<a class=\"sourceLine\" id=\"cb34-43\" title=\"43\">    <span class=\"kw\">public<\/span> <span class=\"dt\">static<\/span> <span class=\"dt\">void<\/span> <span class=\"fu\">main<\/span>(<span class=\"bu\">String<\/span>[] args) {<\/a>\n+<a class=\"sourceLine\" id=\"cb34-44\" title=\"44\">        <span class=\"kw\">try<\/span> (var scope = NativeScope.<span class=\"fu\">unboundedScope<\/span>()) {<\/a>\n+<a class=\"sourceLine\" id=\"cb34-45\" title=\"45\">            var argc = scope.<span class=\"fu\">allocate<\/span>(C_INT, <span class=\"dv\">0<\/span>);<\/a>\n+<a class=\"sourceLine\" id=\"cb34-46\" title=\"46\">            <span class=\"fu\">glutInit<\/span>(argc, argc);<\/a>\n+<a class=\"sourceLine\" id=\"cb34-47\" title=\"47\">            <span class=\"fu\">glutInitDisplayMode<\/span>(<span class=\"fu\">GLUT_DOUBLE<\/span>() | <span class=\"fu\">GLUT_RGB<\/span>() | <span class=\"fu\">GLUT_DEPTH<\/span>());<\/a>\n+<a class=\"sourceLine\" id=\"cb34-48\" title=\"48\">            <span class=\"fu\">glutInitWindowSize<\/span>(<span class=\"dv\">500<\/span>, <span class=\"dv\">500<\/span>);<\/a>\n+<a class=\"sourceLine\" id=\"cb34-49\" title=\"49\">            <span class=\"fu\">glutCreateWindow<\/span>(CLinker.<span class=\"fu\">toCString<\/span>(<span class=\"st\">&quot;Hello Panama!&quot;<\/span>, scope));<\/a>\n+<a class=\"sourceLine\" id=\"cb34-50\" title=\"50\">            var teapot = <span class=\"kw\">new<\/span> <span class=\"fu\">Teapot<\/span>(scope);<\/a>\n+<a class=\"sourceLine\" id=\"cb34-51\" title=\"51\">            var displayStub = glutDisplayFunc$func.<span class=\"fu\">allocate<\/span>(teapot::display, scope);<\/a>\n+<a class=\"sourceLine\" id=\"cb34-52\" title=\"52\">            var idleStub = glutIdleFunc$func.<span class=\"fu\">allocate<\/span>(teapot::onIdle, scope);<\/a>\n+<a class=\"sourceLine\" id=\"cb34-53\" title=\"53\">            <span class=\"fu\">glutDisplayFunc<\/span>(displayStub);<\/a>\n+<a class=\"sourceLine\" id=\"cb34-54\" title=\"54\">            <span class=\"fu\">glutIdleFunc<\/span>(idleStub);<\/a>\n+<a class=\"sourceLine\" id=\"cb34-55\" title=\"55\">            <span class=\"fu\">glutMainLoop<\/span>();<\/a>\n+<a class=\"sourceLine\" id=\"cb34-56\" title=\"56\">        }<\/a>\n+<a class=\"sourceLine\" id=\"cb34-57\" title=\"57\">    }<\/a>\n+<a class=\"sourceLine\" id=\"cb34-58\" title=\"58\">}<\/a><\/code><\/pre><\/div>\n+<h3 id=\"compiling-and-running-the-opengl-sample\">Compiling and running the OpenGL sample<\/h3>\n+<div class=\"sourceCode\" id=\"cb35\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><a class=\"sourceLine\" id=\"cb35-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb35-2\" title=\"2\"><span class=\"ex\">java<\/span> -XstartOnFirstThread -Dforeign.restricted=permit --add-modules jdk.incubator.foreign \\<\/a>\n+<a class=\"sourceLine\" id=\"cb35-3\" title=\"3\">    -Djava.library.path=.:\/System\/Library\/Frameworks\/OpenGL.framework\/Versions\/Current\/Libraries\/ Teapot.java <span class=\"va\">$*<\/span><\/a><\/code><\/pre><\/div>\n+<h2 id=\"using-tensorflow-mac-os\">Using tensorflow (Mac OS)<\/h2>\n+<h3 id=\"getting-libtensorflow\">getting libtensorflow<\/h3>\n+<ul>\n+<li><p>Download tensorflow library from<\/p>\n+<p>https:\/\/www.tensorflow.org\/install\/lang_c<\/p><\/li>\n+<li><p>extract the downloaded tar in a directory called LIBTENSORFLOW_HOME<\/p><\/li>\n+<\/ul>\n+<h3 id=\"jextract-c_api.h\">jextract c_api.h<\/h3>\n+<div class=\"sourceCode\" id=\"cb36\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><a class=\"sourceLine\" id=\"cb36-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb36-2\" title=\"2\"><span class=\"ex\">jextract<\/span> --source \\<\/a>\n+<a class=\"sourceLine\" id=\"cb36-3\" title=\"3\">  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/ \\<\/a>\n+<a class=\"sourceLine\" id=\"cb36-4\" title=\"4\">  -t org.tensorflow \\<\/a>\n+<a class=\"sourceLine\" id=\"cb36-5\" title=\"5\">  -I <span class=\"va\">${LIBTENSORFLOW_HOME}<\/span>\/include \\<\/a>\n+<a class=\"sourceLine\" id=\"cb36-6\" title=\"6\">  -l <span class=\"va\">${LIBTENSORFLOW_HOME}<\/span>\/lib\/libtensorflow.dylib \\<\/a>\n+<a class=\"sourceLine\" id=\"cb36-7\" title=\"7\">  <span class=\"va\">${LIBTENSORFLOW_HOME}<\/span>\/include\/tensorflow\/c\/c_api.h<\/a>\n+<a class=\"sourceLine\" id=\"cb36-8\" title=\"8\"><\/a>\n+<a class=\"sourceLine\" id=\"cb36-9\" title=\"9\"><span class=\"ex\">javac<\/span> --add-modules jdk.incubator.foreign org\/tensorflow\/*.java<\/a><\/code><\/pre><\/div>\n+<h3 id=\"python-program-that-creates-and-saves-model\">Python program that creates and saves model<\/h3>\n+<p>The following Python program should be run to create and save model which will read and printed by a Java program.<\/p>\n+<p>Note: you need to install tensorflow package to run this python script.<\/p>\n+<div class=\"sourceCode\" id=\"cb37\"><pre class=\"sourceCode python\"><code class=\"sourceCode python\"><a class=\"sourceLine\" id=\"cb37-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb37-2\" title=\"2\"><span class=\"im\">import<\/span> tensorflow <span class=\"im\">as<\/span> tf<\/a>\n+<a class=\"sourceLine\" id=\"cb37-3\" title=\"3\"><span class=\"im\">from<\/span> tensorflow.keras <span class=\"im\">import<\/span> models, layers<\/a>\n+<a class=\"sourceLine\" id=\"cb37-4\" title=\"4\"><span class=\"im\">from<\/span> tensorflow.keras.datasets <span class=\"im\">import<\/span> mnist<\/a>\n+<a class=\"sourceLine\" id=\"cb37-5\" title=\"5\"><\/a>\n+<a class=\"sourceLine\" id=\"cb37-6\" title=\"6\">model <span class=\"op\">=<\/span> tf.keras.models.Sequential([<\/a>\n+<a class=\"sourceLine\" id=\"cb37-7\" title=\"7\">  tf.keras.layers.Flatten(input_shape<span class=\"op\">=<\/span>(<span class=\"dv\">28<\/span>, <span class=\"dv\">28<\/span>)),<\/a>\n+<a class=\"sourceLine\" id=\"cb37-8\" title=\"8\">  tf.keras.layers.Dense(<span class=\"dv\">128<\/span>,activation<span class=\"op\">=<\/span><span class=\"st\">&#39;relu&#39;<\/span>),<\/a>\n+<a class=\"sourceLine\" id=\"cb37-9\" title=\"9\">  tf.keras.layers.Dense(<span class=\"dv\">10<\/span>, activation<span class=\"op\">=<\/span><span class=\"st\">&#39;softmax&#39;<\/span>)<\/a>\n+<a class=\"sourceLine\" id=\"cb37-10\" title=\"10\">])<\/a>\n+<a class=\"sourceLine\" id=\"cb37-11\" title=\"11\"><\/a>\n+<a class=\"sourceLine\" id=\"cb37-12\" title=\"12\">model.<span class=\"bu\">compile<\/span>(<\/a>\n+<a class=\"sourceLine\" id=\"cb37-13\" title=\"13\">    loss<span class=\"op\">=<\/span><span class=\"st\">&#39;sparse_categorical_crossentropy&#39;<\/span>,<\/a>\n+<a class=\"sourceLine\" id=\"cb37-14\" title=\"14\">    optimizer<span class=\"op\">=<\/span>tf.keras.optimizers.Adam(<span class=\"fl\">0.001<\/span>),<\/a>\n+<a class=\"sourceLine\" id=\"cb37-15\" title=\"15\">    metrics<span class=\"op\">=<\/span>[<span class=\"st\">&#39;accuracy&#39;<\/span>],<\/a>\n+<a class=\"sourceLine\" id=\"cb37-16\" title=\"16\">)<\/a>\n+<a class=\"sourceLine\" id=\"cb37-17\" title=\"17\"><\/a>\n+<a class=\"sourceLine\" id=\"cb37-18\" title=\"18\"><span class=\"bu\">print<\/span>(model.summary())<\/a>\n+<a class=\"sourceLine\" id=\"cb37-19\" title=\"19\"><\/a>\n+<a class=\"sourceLine\" id=\"cb37-20\" title=\"20\">(train_images, train_labels), (test_images, test_labels) <span class=\"op\">=<\/span> mnist.load_data()<\/a>\n+<a class=\"sourceLine\" id=\"cb37-21\" title=\"21\"><\/a>\n+<a class=\"sourceLine\" id=\"cb37-22\" title=\"22\">train_images <span class=\"op\">=<\/span> train_images<span class=\"op\">\/<\/span><span class=\"fl\">255.0<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb37-23\" title=\"23\">test_images <span class=\"op\">=<\/span> test_images<span class=\"op\">\/<\/span><span class=\"fl\">255.0<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb37-24\" title=\"24\"><\/a>\n+<a class=\"sourceLine\" id=\"cb37-25\" title=\"25\">model.fit(train_images, train_labels,<\/a>\n+<a class=\"sourceLine\" id=\"cb37-26\" title=\"26\">    epochs<span class=\"op\">=<\/span><span class=\"dv\">4<\/span>, batch_size<span class=\"op\">=<\/span><span class=\"dv\">128<\/span>, verbose<span class=\"op\">=<\/span><span class=\"dv\">1<\/span>)<\/a>\n+<a class=\"sourceLine\" id=\"cb37-27\" title=\"27\"><\/a>\n+<a class=\"sourceLine\" id=\"cb37-28\" title=\"28\">test_loss, test_accuracy <span class=\"op\">=<\/span> model.evaluate(test_images, test_labels)<\/a>\n+<a class=\"sourceLine\" id=\"cb37-29\" title=\"29\"><\/a>\n+<a class=\"sourceLine\" id=\"cb37-30\" title=\"30\"><span class=\"bu\">print<\/span>(test_loss, test_accuracy)<\/a>\n+<a class=\"sourceLine\" id=\"cb37-31\" title=\"31\"><\/a>\n+<a class=\"sourceLine\" id=\"cb37-32\" title=\"32\">model.save(<span class=\"st\">&quot;saved_mnist_model&quot;<\/span>)<\/a><\/code><\/pre><\/div>\n+<h3 id=\"java-program-that-uses-tensorflow-c-api\">Java program that uses Tensorflow C API<\/h3>\n+<div class=\"sourceCode\" id=\"cb38\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb38-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb38-2\" title=\"2\"><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.*;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb38-3\" title=\"3\"><span class=\"kw\">import static<\/span><span class=\"im\"> jdk.incubator.foreign.CLinker.*;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb38-4\" title=\"4\"><span class=\"kw\">import static<\/span><span class=\"im\"> jdk.incubator.foreign.MemoryAccess.*;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb38-5\" title=\"5\"><span class=\"kw\">import static<\/span><span class=\"im\"> jdk.incubator.foreign.MemoryAddress.*;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb38-6\" title=\"6\"><span class=\"kw\">import static<\/span><span class=\"im\"> org.tensorflow.c_api_h.*;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb38-7\" title=\"7\"><\/a>\n+<a class=\"sourceLine\" id=\"cb38-8\" title=\"8\"><span class=\"co\">\/\/ simple program that loads saved model and prints basic info on operations in it<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb38-9\" title=\"9\"><\/a>\n+<a class=\"sourceLine\" id=\"cb38-10\" title=\"10\"><span class=\"kw\">public<\/span> <span class=\"kw\">class<\/span> TensorflowLoadSavedModel {<\/a>\n+<a class=\"sourceLine\" id=\"cb38-11\" title=\"11\">    <span class=\"kw\">public<\/span> <span class=\"dt\">static<\/span> <span class=\"dt\">void<\/span> <span class=\"fu\">main<\/span>(<span class=\"bu\">String<\/span><span class=\"kw\">... <\/span>args) <span class=\"kw\">throws<\/span> <span class=\"bu\">Exception<\/span> {<\/a>\n+<a class=\"sourceLine\" id=\"cb38-12\" title=\"12\">        <span class=\"bu\">System<\/span>.<span class=\"fu\">out<\/span>.<span class=\"fu\">println<\/span>(<span class=\"st\">&quot;TensorFlow C library version: &quot;<\/span> + <span class=\"fu\">toJavaStringRestricted<\/span>(<span class=\"fu\">TF_Version<\/span>()));<\/a>\n+<a class=\"sourceLine\" id=\"cb38-13\" title=\"13\"><\/a>\n+<a class=\"sourceLine\" id=\"cb38-14\" title=\"14\">        <span class=\"kw\">if<\/span> (args.<span class=\"fu\">length<\/span> == <span class=\"dv\">0<\/span>) {<\/a>\n+<a class=\"sourceLine\" id=\"cb38-15\" title=\"15\">            <span class=\"bu\">System<\/span>.<span class=\"fu\">err<\/span>.<span class=\"fu\">println<\/span>(<span class=\"st\">&quot;java TensorflowLoadSavedModel &lt;saved model dir&gt;&quot;<\/span>);<\/a>\n+<a class=\"sourceLine\" id=\"cb38-16\" title=\"16\">            <span class=\"bu\">System<\/span>.<span class=\"fu\">exit<\/span>(<span class=\"dv\">1<\/span>);<\/a>\n+<a class=\"sourceLine\" id=\"cb38-17\" title=\"17\">        }<\/a>\n+<a class=\"sourceLine\" id=\"cb38-18\" title=\"18\"><\/a>\n+<a class=\"sourceLine\" id=\"cb38-19\" title=\"19\">        <span class=\"kw\">try<\/span> (var scope = NativeScope.<span class=\"fu\">unboundedScope<\/span>()) {<\/a>\n+<a class=\"sourceLine\" id=\"cb38-20\" title=\"20\">            var graph = <span class=\"fu\">TF_NewGraph<\/span>();<\/a>\n+<a class=\"sourceLine\" id=\"cb38-21\" title=\"21\">            var status = <span class=\"fu\">TF_NewStatus<\/span>();<\/a>\n+<a class=\"sourceLine\" id=\"cb38-22\" title=\"22\">            var sessionOpts = <span class=\"fu\">TF_NewSessionOptions<\/span>();<\/a>\n+<a class=\"sourceLine\" id=\"cb38-23\" title=\"23\"><\/a>\n+<a class=\"sourceLine\" id=\"cb38-24\" title=\"24\">            var savedModelDir = <span class=\"fu\">toCString<\/span>(args[<span class=\"dv\">0<\/span>], scope);<\/a>\n+<a class=\"sourceLine\" id=\"cb38-25\" title=\"25\">            var tags = scope.<span class=\"fu\">allocate<\/span>(C_POINTER, <span class=\"fu\">toCString<\/span>(<span class=\"st\">&quot;serve&quot;<\/span>, scope));<\/a>\n+<a class=\"sourceLine\" id=\"cb38-26\" title=\"26\">            var session = <span class=\"fu\">TF_LoadSessionFromSavedModel<\/span>(sessionOpts, NULL, savedModelDir, tags, <span class=\"dv\">1<\/span>, graph, NULL, status);<\/a>\n+<a class=\"sourceLine\" id=\"cb38-27\" title=\"27\"><\/a>\n+<a class=\"sourceLine\" id=\"cb38-28\" title=\"28\">            <span class=\"kw\">if<\/span> (<span class=\"fu\">TF_GetCode<\/span>(status) != <span class=\"fu\">TF_OK<\/span>()) {<\/a>\n+<a class=\"sourceLine\" id=\"cb38-29\" title=\"29\">                <span class=\"bu\">System<\/span>.<span class=\"fu\">err.printf<\/span>(<span class=\"st\">&quot;cannot load session from saved model: <\/span><span class=\"sc\">%s\\n<\/span><span class=\"st\">&quot;<\/span>,<\/a>\n+<a class=\"sourceLine\" id=\"cb38-30\" title=\"30\">                    <span class=\"fu\">toJavaStringRestricted<\/span>(<span class=\"fu\">TF_Message<\/span>(status)));<\/a>\n+<a class=\"sourceLine\" id=\"cb38-31\" title=\"31\">            } <span class=\"kw\">else<\/span> {<\/a>\n+<a class=\"sourceLine\" id=\"cb38-32\" title=\"32\">                <span class=\"bu\">System<\/span>.<span class=\"fu\">err<\/span>.<span class=\"fu\">println<\/span>(<span class=\"st\">&quot;load session from saved model works!&quot;<\/span>);<\/a>\n+<a class=\"sourceLine\" id=\"cb38-33\" title=\"33\">            }<\/a>\n+<a class=\"sourceLine\" id=\"cb38-34\" title=\"34\"><\/a>\n+<a class=\"sourceLine\" id=\"cb38-35\" title=\"35\">            <span class=\"co\">\/\/ print operations<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb38-36\" title=\"36\">            var size = scope.<span class=\"fu\">allocate<\/span>(C_LONG_LONG);<\/a>\n+<a class=\"sourceLine\" id=\"cb38-37\" title=\"37\">            var operation = NULL;<\/a>\n+<a class=\"sourceLine\" id=\"cb38-38\" title=\"38\">            <span class=\"kw\">while<\/span> (!(operation = <span class=\"fu\">TF_GraphNextOperation<\/span>(graph, size)).<span class=\"fu\">equals<\/span>(NULL)) {<\/a>\n+<a class=\"sourceLine\" id=\"cb38-39\" title=\"39\">                <span class=\"bu\">System<\/span>.<span class=\"fu\">out.printf<\/span>(<span class=\"st\">&quot;<\/span><span class=\"sc\">%s<\/span><span class=\"st\"> : <\/span><span class=\"sc\">%s\\n<\/span><span class=\"st\">&quot;<\/span>,<\/a>\n+<a class=\"sourceLine\" id=\"cb38-40\" title=\"40\">                    <span class=\"fu\">toJavaStringRestricted<\/span>(<span class=\"fu\">TF_OperationName<\/span>(operation)),<\/a>\n+<a class=\"sourceLine\" id=\"cb38-41\" title=\"41\">                    <span class=\"fu\">toJavaStringRestricted<\/span>(<span class=\"fu\">TF_OperationOpType<\/span>(operation)));<\/a>\n+<a class=\"sourceLine\" id=\"cb38-42\" title=\"42\">            }<\/a>\n+<a class=\"sourceLine\" id=\"cb38-43\" title=\"43\"><\/a>\n+<a class=\"sourceLine\" id=\"cb38-44\" title=\"44\">            <span class=\"fu\">TF_DeleteGraph<\/span>(graph);<\/a>\n+<a class=\"sourceLine\" id=\"cb38-45\" title=\"45\">            <span class=\"fu\">TF_DeleteSession<\/span>(session, status);<\/a>\n+<a class=\"sourceLine\" id=\"cb38-46\" title=\"46\">            <span class=\"fu\">TF_DeleteSessionOptions<\/span>(sessionOpts);<\/a>\n+<a class=\"sourceLine\" id=\"cb38-47\" title=\"47\">            <span class=\"fu\">TF_DeleteStatus<\/span>(status);<\/a>\n+<a class=\"sourceLine\" id=\"cb38-48\" title=\"48\">        }<\/a>\n+<a class=\"sourceLine\" id=\"cb38-49\" title=\"49\">    }<\/a>\n+<a class=\"sourceLine\" id=\"cb38-50\" title=\"50\">}<\/a><\/code><\/pre><\/div>\n+<h3 id=\"compiling-and-running-the-java-tensorflow-sample\">Compiling and running the Java Tensorflow sample<\/h3>\n+<div class=\"sourceCode\" id=\"cb39\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><a class=\"sourceLine\" id=\"cb39-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb39-2\" title=\"2\"><span class=\"ex\">java<\/span> -Dforeign.restricted=permit --add-modules jdk.incubator.foreign \\<\/a>\n+<a class=\"sourceLine\" id=\"cb39-3\" title=\"3\">   TensorflowLoadSavedModel.java saved_mnist_model<\/a><\/code><\/pre><\/div>\n+<h2 id=\"using-time.h-mac-os\">Using time.h (Mac OS)<\/h2>\n+<h3 id=\"jextract-time.h\">jextract time.h<\/h3>\n+<div class=\"sourceCode\" id=\"cb40\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><a class=\"sourceLine\" id=\"cb40-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb40-2\" title=\"2\"><span class=\"ex\">jextract<\/span> -t org.unix \\<\/a>\n+<a class=\"sourceLine\" id=\"cb40-3\" title=\"3\">  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\<\/a>\n+<a class=\"sourceLine\" id=\"cb40-4\" title=\"4\">   \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/time.h<\/a><\/code><\/pre><\/div>\n+<h3 id=\"java-program-that-uses-posix-time-library\">Java program that uses POSIX time library<\/h3>\n+<div class=\"sourceCode\" id=\"cb41\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb41-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb41-2\" title=\"2\"><span class=\"kw\">import static<\/span><span class=\"im\"> org.unix.time_h.*;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb41-3\" title=\"3\"><span class=\"kw\">import static<\/span><span class=\"im\"> jdk.incubator.foreign.CLinker.*;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb41-4\" title=\"4\"><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.*;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb41-5\" title=\"5\"><\/a>\n+<a class=\"sourceLine\" id=\"cb41-6\" title=\"6\"><span class=\"kw\">public<\/span> <span class=\"kw\">class<\/span> PanamaTime {<\/a>\n+<a class=\"sourceLine\" id=\"cb41-7\" title=\"7\">    <span class=\"kw\">public<\/span> <span class=\"dt\">static<\/span> <span class=\"dt\">void<\/span> <span class=\"fu\">main<\/span>(<span class=\"bu\">String<\/span>[] args) {<\/a>\n+<a class=\"sourceLine\" id=\"cb41-8\" title=\"8\">        <span class=\"kw\">try<\/span> (NativeScope scope = NativeScope.<span class=\"fu\">unboundedScope<\/span>()) {<\/a>\n+<a class=\"sourceLine\" id=\"cb41-9\" title=\"9\">            var now = scope.<span class=\"fu\">allocate<\/span>(C_LONG, <span class=\"bu\">System<\/span>.<span class=\"fu\">currentTimeMillis<\/span>() \/ <span class=\"dv\">1000<\/span>);<\/a>\n+<a class=\"sourceLine\" id=\"cb41-10\" title=\"10\">            MemorySegment time = tm.<span class=\"fu\">allocate<\/span>(scope);<\/a>\n+<a class=\"sourceLine\" id=\"cb41-11\" title=\"11\">            <span class=\"fu\">localtime_r<\/span>(now, time);<\/a>\n+<a class=\"sourceLine\" id=\"cb41-12\" title=\"12\">            <span class=\"bu\">System<\/span>.<span class=\"fu\">err.printf<\/span>(<span class=\"st\">&quot;Time = <\/span><span class=\"sc\">%d<\/span><span class=\"st\">:<\/span><span class=\"sc\">%d\\n<\/span><span class=\"st\">&quot;<\/span>, tm.<span class=\"fu\">tm_hour<\/span>$<span class=\"fu\">get<\/span>(time), tm.<span class=\"fu\">tm_min<\/span>$<span class=\"fu\">get<\/span>(time));<\/a>\n+<a class=\"sourceLine\" id=\"cb41-13\" title=\"13\">        }<\/a>\n+<a class=\"sourceLine\" id=\"cb41-14\" title=\"14\">    }<\/a>\n+<a class=\"sourceLine\" id=\"cb41-15\" title=\"15\">}<\/a><\/code><\/pre><\/div>\n+<h3 id=\"compiling-and-running-the-time-sample\">Compiling and running the time sample<\/h3>\n+<div class=\"sourceCode\" id=\"cb42\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><a class=\"sourceLine\" id=\"cb42-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb42-2\" title=\"2\"><span class=\"ex\">java<\/span> -Dforeign.restricted=permit --add-modules jdk.incubator.foreign PanamaTime.java<\/a><\/code><\/pre><\/div>\n+<h2 id=\"using-libclang-library-mac-os\">Using libclang library (Mac OS)<\/h2>\n+<h3 id=\"jextract-index.h\">jextract Index.h<\/h3>\n+<div class=\"sourceCode\" id=\"cb43\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><a class=\"sourceLine\" id=\"cb43-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb43-2\" title=\"2\"><span class=\"co\"># LIBCLANG_HOME is the directory where you&#39;ve installed llvm 9.x or above<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb43-3\" title=\"3\"><\/a>\n+<a class=\"sourceLine\" id=\"cb43-4\" title=\"4\"><span class=\"ex\">jextract<\/span> --source -t org.llvm.clang -lclang \\<\/a>\n+<a class=\"sourceLine\" id=\"cb43-5\" title=\"5\">  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/ \\<\/a>\n+<a class=\"sourceLine\" id=\"cb43-6\" title=\"6\">  -I <span class=\"va\">${LIBCLANG_HOME}<\/span>\/include\/ \\<\/a>\n+<a class=\"sourceLine\" id=\"cb43-7\" title=\"7\">  -I <span class=\"va\">${LIBCLANG_HOME}<\/span>\/include\/clang-c \\<\/a>\n+<a class=\"sourceLine\" id=\"cb43-8\" title=\"8\">  <span class=\"va\">${LIBCLANG_HOME}<\/span>\/include\/clang-c\/Index.h<\/a>\n+<a class=\"sourceLine\" id=\"cb43-9\" title=\"9\"><span class=\"ex\">javac<\/span> --add-modules jdk.incubator.foreign org\/llvm\/clang\/*.java<\/a><\/code><\/pre><\/div>\n+<h3 id=\"java-program-that-uses-libclang-to-print-ast-of-a-given-c-program\">Java program that uses libclang to print AST of a given C program<\/h3>\n+<div class=\"sourceCode\" id=\"cb44\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb44-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb44-2\" title=\"2\"><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.*;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb44-3\" title=\"3\"><span class=\"kw\">import static<\/span><span class=\"im\"> jdk.incubator.foreign.CLinker.*;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb44-4\" title=\"4\"><span class=\"kw\">import static<\/span><span class=\"im\"> jdk.incubator.foreign.MemoryAddress.NULL;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb44-5\" title=\"5\"><span class=\"kw\">import static<\/span><span class=\"im\"> org.llvm.clang.Index_h.*;<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb44-6\" title=\"6\"><\/a>\n+<a class=\"sourceLine\" id=\"cb44-7\" title=\"7\"><span class=\"kw\">public<\/span> <span class=\"kw\">class<\/span> ASTPrinter {<\/a>\n+<a class=\"sourceLine\" id=\"cb44-8\" title=\"8\">    <span class=\"kw\">private<\/span> <span class=\"dt\">static<\/span> <span class=\"bu\">String<\/span> <span class=\"fu\">asJavaString<\/span>(MemorySegment clangStr) {<\/a>\n+<a class=\"sourceLine\" id=\"cb44-9\" title=\"9\">        <span class=\"bu\">String<\/span> str = <span class=\"fu\">toJavaStringRestricted<\/span>(<span class=\"fu\">clang_getCString<\/span>(clangStr));<\/a>\n+<a class=\"sourceLine\" id=\"cb44-10\" title=\"10\">        <span class=\"fu\">clang_disposeString<\/span>(clangStr);<\/a>\n+<a class=\"sourceLine\" id=\"cb44-11\" title=\"11\">        <span class=\"kw\">return<\/span> str;<\/a>\n+<a class=\"sourceLine\" id=\"cb44-12\" title=\"12\">    }<\/a>\n+<a class=\"sourceLine\" id=\"cb44-13\" title=\"13\"><\/a>\n+<a class=\"sourceLine\" id=\"cb44-14\" title=\"14\">    <span class=\"kw\">public<\/span> <span class=\"dt\">static<\/span> <span class=\"dt\">void<\/span> <span class=\"fu\">main<\/span>(<span class=\"bu\">String<\/span>[] args) {<\/a>\n+<a class=\"sourceLine\" id=\"cb44-15\" title=\"15\">        <span class=\"kw\">if<\/span> (args.<span class=\"fu\">length<\/span> == <span class=\"dv\">0<\/span>) {<\/a>\n+<a class=\"sourceLine\" id=\"cb44-16\" title=\"16\">            <span class=\"bu\">System<\/span>.<span class=\"fu\">err<\/span>.<span class=\"fu\">println<\/span>(<span class=\"st\">&quot;java ASTPrinter &lt;C source or header&gt;&quot;<\/span>);<\/a>\n+<a class=\"sourceLine\" id=\"cb44-17\" title=\"17\">            <span class=\"bu\">System<\/span>.<span class=\"fu\">exit<\/span>(<span class=\"dv\">1<\/span>);<\/a>\n+<a class=\"sourceLine\" id=\"cb44-18\" title=\"18\">        }<\/a>\n+<a class=\"sourceLine\" id=\"cb44-19\" title=\"19\"><\/a>\n+<a class=\"sourceLine\" id=\"cb44-20\" title=\"20\">        <span class=\"kw\">try<\/span> (var scope = NativeScope.<span class=\"fu\">unboundedScope<\/span>()) {<\/a>\n+<a class=\"sourceLine\" id=\"cb44-21\" title=\"21\">            <span class=\"co\">\/\/ parse the C header\/source passed from the command line<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb44-22\" title=\"22\">            var index = <span class=\"fu\">clang_createIndex<\/span>(<span class=\"dv\">0<\/span>, <span class=\"dv\">0<\/span>);<\/a>\n+<a class=\"sourceLine\" id=\"cb44-23\" title=\"23\">            var tu = <span class=\"fu\">clang_parseTranslationUnit<\/span>(index, <span class=\"fu\">toCString<\/span>(args[<span class=\"dv\">0<\/span>], scope),<\/a>\n+<a class=\"sourceLine\" id=\"cb44-24\" title=\"24\">                    NULL, <span class=\"dv\">0<\/span>, NULL, <span class=\"dv\">0<\/span>, <span class=\"fu\">CXTranslationUnit_None<\/span>());<\/a>\n+<a class=\"sourceLine\" id=\"cb44-25\" title=\"25\">            <span class=\"co\">\/\/ array trick to update within lambda<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb44-26\" title=\"26\">            var level = <span class=\"kw\">new<\/span> <span class=\"dt\">int<\/span>[<span class=\"dv\">1<\/span>];<\/a>\n+<a class=\"sourceLine\" id=\"cb44-27\" title=\"27\">            var visitor = <span class=\"kw\">new<\/span> MemorySegment[<span class=\"dv\">1<\/span>];<\/a>\n+<a class=\"sourceLine\" id=\"cb44-28\" title=\"28\"><\/a>\n+<a class=\"sourceLine\" id=\"cb44-29\" title=\"29\">            <span class=\"co\">\/\/ clang Cursor visitor callback<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb44-30\" title=\"30\">            visitor[<span class=\"dv\">0<\/span>] = clang_visitChildren$visitor.<span class=\"fu\">allocate<\/span>((cursor, parent, data) -&gt; {<\/a>\n+<a class=\"sourceLine\" id=\"cb44-31\" title=\"31\">                var kind = <span class=\"fu\">clang_getCursorKind<\/span>(cursor);<\/a>\n+<a class=\"sourceLine\" id=\"cb44-32\" title=\"32\">                var name = <span class=\"fu\">asJavaString<\/span>(<span class=\"fu\">clang_getCursorSpelling<\/span>(cursor));<\/a>\n+<a class=\"sourceLine\" id=\"cb44-33\" title=\"33\">                var kindName = <span class=\"fu\">asJavaString<\/span>(<span class=\"fu\">clang_getCursorKindSpelling<\/span>(kind));<\/a>\n+<a class=\"sourceLine\" id=\"cb44-34\" title=\"34\">                <span class=\"bu\">System<\/span>.<span class=\"fu\">out.printf<\/span>(<span class=\"st\">&quot;<\/span><span class=\"sc\">%s<\/span><span class=\"st\"> <\/span><span class=\"sc\">%s<\/span><span class=\"st\"> <\/span><span class=\"sc\">%s<\/span><span class=\"st\">&quot;<\/span>, <span class=\"st\">&quot; &quot;<\/span>.<span class=\"fu\">repeat<\/span>(level[<span class=\"dv\">0<\/span>]), kindName, name);<\/a>\n+<a class=\"sourceLine\" id=\"cb44-35\" title=\"35\">                var type = <span class=\"fu\">clang_getCursorType<\/span>(cursor);<\/a>\n+<a class=\"sourceLine\" id=\"cb44-36\" title=\"36\">                <span class=\"kw\">if<\/span> (CXType.<span class=\"fu\">kind<\/span>$<span class=\"fu\">get<\/span>(type) != <span class=\"fu\">CXType_Invalid<\/span>()) {<\/a>\n+<a class=\"sourceLine\" id=\"cb44-37\" title=\"37\">                    var typeName = <span class=\"fu\">asJavaString<\/span>(<span class=\"fu\">clang_getTypeSpelling<\/span>(type));<\/a>\n+<a class=\"sourceLine\" id=\"cb44-38\" title=\"38\">                    <span class=\"bu\">System<\/span>.<span class=\"fu\">out.printf<\/span>(<span class=\"st\">&quot; &lt;<\/span><span class=\"sc\">%s<\/span><span class=\"st\">&gt;&quot;<\/span>, typeName);<\/a>\n+<a class=\"sourceLine\" id=\"cb44-39\" title=\"39\">                }<\/a>\n+<a class=\"sourceLine\" id=\"cb44-40\" title=\"40\">                <span class=\"bu\">System<\/span>.<span class=\"fu\">out<\/span>.<span class=\"fu\">println<\/span>();<\/a>\n+<a class=\"sourceLine\" id=\"cb44-41\" title=\"41\"><\/a>\n+<a class=\"sourceLine\" id=\"cb44-42\" title=\"42\">                <span class=\"co\">\/\/ visit children<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb44-43\" title=\"43\">                level[<span class=\"dv\">0<\/span>]++;<\/a>\n+<a class=\"sourceLine\" id=\"cb44-44\" title=\"44\">                <span class=\"fu\">clang_visitChildren<\/span>(cursor, visitor[<span class=\"dv\">0<\/span>], NULL);<\/a>\n+<a class=\"sourceLine\" id=\"cb44-45\" title=\"45\">                level[<span class=\"dv\">0<\/span>]--;<\/a>\n+<a class=\"sourceLine\" id=\"cb44-46\" title=\"46\"><\/a>\n+<a class=\"sourceLine\" id=\"cb44-47\" title=\"47\">                <span class=\"kw\">return<\/span> <span class=\"fu\">CXChildVisit_Continue<\/span>();<\/a>\n+<a class=\"sourceLine\" id=\"cb44-48\" title=\"48\">            });<\/a>\n+<a class=\"sourceLine\" id=\"cb44-49\" title=\"49\"><\/a>\n+<a class=\"sourceLine\" id=\"cb44-50\" title=\"50\">            <span class=\"co\">\/\/ get the AST root and visit it<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb44-51\" title=\"51\">            var root = <span class=\"fu\">clang_getTranslationUnitCursor<\/span>(tu);<\/a>\n+<a class=\"sourceLine\" id=\"cb44-52\" title=\"52\">            <span class=\"fu\">clang_visitChildren<\/span>(root, visitor[<span class=\"dv\">0<\/span>], NULL);<\/a>\n+<a class=\"sourceLine\" id=\"cb44-53\" title=\"53\"><\/a>\n+<a class=\"sourceLine\" id=\"cb44-54\" title=\"54\">            <span class=\"fu\">clang_disposeTranslationUnit<\/span>(tu);<\/a>\n+<a class=\"sourceLine\" id=\"cb44-55\" title=\"55\">            <span class=\"fu\">clang_disposeIndex<\/span>(index);<\/a>\n+<a class=\"sourceLine\" id=\"cb44-56\" title=\"56\">        }<\/a>\n+<a class=\"sourceLine\" id=\"cb44-57\" title=\"57\">    }<\/a>\n+<a class=\"sourceLine\" id=\"cb44-58\" title=\"58\">}<\/a><\/code><\/pre><\/div>\n+<h3 id=\"compiling-and-running-the-libclang-sample\">Compiling and running the libclang sample<\/h3>\n+<div class=\"sourceCode\" id=\"cb45\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><a class=\"sourceLine\" id=\"cb45-1\" title=\"1\"><\/a>\n+<a class=\"sourceLine\" id=\"cb45-2\" title=\"2\"><span class=\"ex\">java<\/span> -Dforeign.restricted=permit --add-modules jdk.incubator.foreign \\<\/a>\n+<a class=\"sourceLine\" id=\"cb45-3\" title=\"3\">    ASTPrinter.java <span class=\"va\">$*<\/span><\/a><\/code><\/pre><\/div>\n+<\/body>\n+<\/html>\n","filename":"doc\/panama_jextract.html","additions":936,"deletions":0,"binary":false,"changes":936,"status":"added"},{"patch":"@@ -0,0 +1,1027 @@\n+<?xml version=\"1.0\" encoding=\"utf-8\"?>\n+\n+# Using the `jextract` tool\n+\n+`jextract` is a simple - but convenient - tool which generates a Java API from one or more native C headers. The tool can be obtained by building the [foreign-jextract](https:\/\/github.com\/openjdk\/panama-foreign) branch of Panama foreign repository.\n+\n+Interacting with the `jextract` tool usually involves two steps:\n+\n+1. Use the `jextract` tool to generate a java interface for some C header files\n+2. Write a Java program which invokes the wrapper API points generated by `jextract`\n+\n+The `jextract` tool provides some basic options in order to control how the extraction process works; these are listed below:\n+\n+* `-C <String>` - specify arguments to be passed to the underlying Clang parser\n+* `-I <String>` - specify include files path\n+* `-l <String>` - specify a library (name or full absolute path) which should be linked when the generated API is loaded\n+* `-d <String>` - specify where to place generated files\n+* `-t <String>`  specify the target package for the generated classes\n+* `--filter <String>` - simple string-based filtering mechanism; only symbols from headers whose absolute path contains the specified string will be included in the generated API\n+* `--source` - generate java sources instead of classfiles\n+\n+The remainder of this documents shows some basic usage examples of the `jextract` tool.\n+\n+## Hello World\n+\n+### Hello World C Header (helloworld.h)\n+\n+```C\n+\n+#ifndef helloworld_h\n+#define helloworld_h\n+\n+extern void helloworld(void);\n+\n+#endif \/* helloworld_h *\/\n+\n+\n+```\n+\n+### Hello World C Source (helloworld.c)\n+\n+```C\n+\n+#include <stdio.h>\n+\n+#include \"helloworld.h\"\n+\n+void helloworld(void) {\n+    printf(\"Hello World!\\n\");\n+}\n+\n+```\n+\n+### Building Hello World\n+\n+```sh\n+\n+cc -shared -o libhelloworld.dylib helloworld.c\n+\n+```\n+\n+\n+### jextract a Jar file for helloworld.h\n+\n+```sh\n+\n+jextract -t org.hello -lhelloworld helloworld.h\n+\n+```\n+\n+### Java program that uses extracted helloworld interface\n+\n+```java\n+\n+import static org.hello.helloworld_h.*;\n+\n+public class HelloWorld {\n+    public static void main(String[] args) {\n+        helloworld();\n+    }\n+}\n+\n+```\n+\n+### Running the Java code that invokes helloworld\n+\n+```sh\n+\n+java -Dforeign.restricted=permit --add-modules jdk.incubator.foreign HelloWorld.java\n+\n+```\n+\n+## Embedding Python interpreter in your Java program (Mac OS)\n+\n+### jextract Python.h\n+\n+```sh\n+\n+jextract \\\n+  -l python2.7 \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/python2.7\/ \\\n+  -t org.python \\\n+   \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/python2.7\/Python.h\n+\n+```\n+\n+### Java program that uses extracted Python interface\n+\n+```java\n+\n+import static jdk.incubator.foreign.CLinker.*;\n+import static jdk.incubator.foreign.MemoryAddress.NULL;\n+\/\/ import jextracted python 'header' class\n+import static org.python.Python_h.*;\n+\n+public class PythonMain {\n+    public static void main(String[] args) {\n+        String script = \"print(sum([33, 55, 66])); print('Hello from Python!')\\n\";\n+\n+        Py_Initialize();\n+        try (var str = toCString(script)) {\n+            PyRun_SimpleStringFlags(str, NULL);\n+            Py_Finalize();\n+        }\n+    }\n+}\n+\n+```\n+\n+### Running the Java code that calls Python interpreter\n+\n+```sh\n+\n+java -Dforeign.restricted=permit --add-modules jdk.incubator.foreign \\\n+    -Djava.library.path=\/System\/Library\/Frameworks\/Python.framework\/Versions\/2.7\/lib \\\n+    PythonMain.java\n+\n+```\n+\n+## Using readline library from Java code (Mac OS)\n+\n+### jextract readline.h\n+\n+```sh\n+\n+jextract \\\n+  -l readline -t org.unix \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\\n+   \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/readline\/readline.h\n+\n+```\n+\n+### Java code that uses readline\n+\n+```java\n+\n+import static org.unix.readline_h.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+\n+public class Readline {\n+    public static void main(String[] args) {\n+        try (var str = toCString(\"name? \")) {\n+            \/\/ call \"readline\" API\n+            var p = readline(str);\n+\n+            \/\/ print char* as is\n+            System.out.println(p);\n+            \/\/ convert char* ptr from readline as Java String & print it\n+            System.out.println(\"Hello, \" + toJavaStringRestricted(p));\n+        }\n+    }\n+}\n+\n+```\n+\n+### Running the java code that uses readline\n+\n+```\n+java -Dforeign.restricted=permit --add-modules jdk.incubator.foreign \\\n+    -Djava.library.path=\/usr\/local\/opt\/readline\/lib\/ Readline.java\n+\n+```\n+\n+## Using libcurl from Java (Mac OS)\n+\n+### jextract curl.h\n+\n+```sh\n+\n+jextract -t org.unix -lcurl \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/ \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/curl\/ \\\n+  \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/curl\/curl.h\n+\n+```\n+\n+### Java code that uses libcurl\n+\n+```java\n+\n+import static jdk.incubator.foreign.MemoryAddress.NULL;\n+import static org.jextract.curl_h.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+\n+public class CurlMain {\n+   public static void main(String[] args) {\n+       var urlStr = args[0];\n+       curl_global_init(CURL_GLOBAL_DEFAULT());\n+       var curl = curl_easy_init();\n+       if(!curl.equals(NULL)) {\n+           try (var url = toCString(urlStr)) {\n+               curl_easy_setopt(curl, CURLOPT_URL(), url.address());\n+               int res = curl_easy_perform(curl);\n+               if (res != CURLE_OK()) {\n+                   String error = toJavaStringRestricted(curl_easy_strerror(res));\n+                   System.out.println(\"Curl error: \" + error);\n+                   curl_easy_cleanup(curl);\n+               }\n+           }\n+       }\n+       curl_global_cleanup();\n+   }\n+}\n+\n+```\n+\n+### Running the java code that uses libcurl\n+\n+```sh\n+\n+# run this shell script by passing a URL as first argument\n+java -Dforeign.restricted=permit --add-modules jdk.incubator.foreign \\\n+    -Djava.library.path=\/usr\/lib CurlMain.java $*\n+\n+```\n+\n+## Using BLAS library\n+\n+BLAS is a popular library that allows fast matrix and vector computation: [http:\/\/www.netlib.org\/blas\/](http:\/\/www.netlib.org\/blas\/).\n+\n+### Installing OpenBLAS (Mac OS)\n+\n+On Mac, blas is available as part of the OpenBLAS library: [https:\/\/github.com\/xianyi\/OpenBLAS\/wiki](https:\/\/github.com\/xianyi\/OpenBLAS\/wiki)\n+\n+OpenBLAS is an optimized BLAS library based on GotoBLAS2 1.13 BSD version.\n+\n+You can install openblas using HomeBrew\n+\n+```sh\n+\n+brew install openblas\n+\n+```\n+\n+It installs include and lib directories under \/usr\/local\/opt\/openblas\n+\n+### jextracting cblas.h (MacOS)\n+\n+The following command can be used to extract cblas.h on MacOs\n+\n+```sh\n+\n+jextract -C \"-D FORCE_OPENBLAS_COMPLEX_STRUCT\" \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\\n+  -l openblas -t blas \/usr\/local\/opt\/openblas\/include\/cblas.h\n+\n+```\n+\n+### Java sample code that uses cblas library\n+\n+```java\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.NativeScope;\n+import blas.*;\n+import static blas.cblas_h.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+\n+public class TestBlas {\n+    public static void main(String[] args) {\n+        int Layout;\n+        int transa;\n+\n+        double alpha, beta;\n+        int m, n, lda, incx, incy, i;\n+\n+        Layout = CblasColMajor();\n+        transa = CblasNoTrans();\n+\n+        m = 4; \/* Size of Column ( the number of rows ) *\/\n+        n = 4; \/* Size of Row ( the number of columns ) *\/\n+        lda = 4; \/* Leading dimension of 5 * 4 matrix is 5 *\/\n+        incx = 1;\n+        incy = 1;\n+        alpha = 1;\n+        beta = 0;\n+\n+        try (var scope = NativeScope.unboundedScope()) {\n+            var a = scope.allocateArray(C_DOUBLE, new double[] {\n+                1.0, 2.0, 3.0, 4.0,\n+                1.0, 1.0, 1.0, 1.0,\n+                3.0, 4.0, 5.0, 6.0,\n+                5.0, 6.0, 7.0, 8.0\n+            });\n+            var x = scope.allocateArray(C_DOUBLE, new double[] {\n+                1.0, 2.0, 1.0, 1.0\n+            });\n+            var y = scope.allocateArray(C_DOUBLE, n);\n+\n+            cblas_dgemv(Layout, transa, m, n, alpha, a, lda, x, incx, beta, y, incy);\n+            \/* Print y *\/\n+            for (i = 0; i < n; i++) {\n+                System.out.print(String.format(\" y%d = %f\\n\", i, MemoryAccess.getDoubleAtIndex(y, i)));\n+            }\n+        }\n+    }\n+}\n+```\n+\n+### Compiling and running the above BLAS sample\n+\n+```sh\n+\n+jextract \\\n+  -C \"-D FORCE_OPENBLAS_COMPLEX_STRUCT\" \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\\n+  -l openblas -t blas \/usr\/local\/opt\/openblas\/include\/cblas.h\n+\n+```\n+\n+## Using LAPACK library (Mac OS)\n+\n+On Mac OS, lapack is installed under \/usr\/local\/opt\/lapack directory.\n+\n+### jextracting lapacke.h\n+\n+```sh\n+\n+jextract \\\n+   -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\\n+   -l lapacke -t lapack \\\n+   --filter lapacke.h \\\n+   \/usr\/local\/opt\/lapack\/include\/lapacke.h\n+\n+```\n+\n+### Java sample code that uses LAPACK library\n+\n+```java\n+\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.NativeScope;\n+import lapack.*;\n+import static lapack.lapacke_h.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+\n+public class TestLapack {\n+    public static void main(String[] args) {\n+\n+        \/* Locals *\/\n+        try (var scope = NativeScope.unboundedScope()) {\n+            var A = scope.allocateArray(C_DOUBLE, new double[]{\n+                    1, 2, 3, 4, 5, 1, 3, 5, 2, 4, 1, 4, 2, 5, 3\n+            });\n+            var b = scope.allocateArray(C_DOUBLE, new double[]{\n+                    -10, 12, 14, 16, 18, -3, 14, 12, 16, 16\n+            });\n+            int info, m, n, lda, ldb, nrhs;\n+\n+            \/* Initialization *\/\n+            m = 5;\n+            n = 3;\n+            nrhs = 2;\n+            lda = 5;\n+            ldb = 5;\n+\n+            \/* Print Entry Matrix *\/\n+            print_matrix_colmajor(\"Entry Matrix A\", m, n, A, lda );\n+            \/* Print Right Rand Side *\/\n+            print_matrix_colmajor(\"Right Hand Side b\", n, nrhs, b, ldb );\n+            System.out.println();\n+            \n+            \/* Executable statements *\/\n+            \/\/            printf( \"LAPACKE_dgels (col-major, high-level) Example Program Results\\n\" );\n+            \/* Solve least squares problem*\/\n+            info = LAPACKE_dgels(LAPACK_COL_MAJOR(), (byte)'N', m, n, nrhs, A, lda, b, ldb);\n+ \n+            \/* Print Solution *\/\n+            print_matrix_colmajor(\"Solution\", n, nrhs, b, ldb );\n+            System.out.println();\n+            System.exit(info);\n+        }   \n+    }   \n+    \n+    static void print_matrix_colmajor(String msg, int m, int n, MemorySegment mat, int ldm) {\n+        int i, j;\n+        System.out.printf(\"\\n %s\\n\", msg);\n+\n+        for( i = 0; i < m; i++ ) {\n+            for( j = 0; j < n; j++ ) System.out.printf(\" %6.2f\", MemoryAccess.getDoubleAtIndex(mat, i+j*ldm));\n+            System.out.printf( \"\\n\" );\n+        }\n+    }\n+}\n+\n+```\n+\n+### Compiling and running the above LAPACK sample\n+\n+```sh\n+\n+java -Dforeign.restricted=permit \\\n+    --add-modules jdk.incubator.foreign \\\n+    -Djava.library.path=\/usr\/local\/opt\/lapack\/lib \\\n+    TestLapack.java\n+\n+```\n+## Using libproc library to list processes from Java (Mac OS)\n+\n+### jextract libproc.h\n+\n+```sh\n+\n+jextract \\\n+  -t org.unix \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\\n+  --filter libproc.h \\\n+  \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/libproc.h\n+\n+```\n+\n+### Java program that uses libproc to list processes\n+\n+```java\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.NativeScope;\n+import org.unix.*;\n+import static jdk.incubator.foreign.MemoryAddress.NULL;\n+import static org.unix.libproc_h.*;\n+\n+public class LibprocMain {\n+    private static final int NAME_BUF_MAX = 256;\n+\n+    public static void main(String[] args) {\n+        try (var scope = NativeScope.unboundedScope()) {\n+            \/\/ get the number of processes\n+            int numPids = proc_listallpids(NULL, 0);\n+            \/\/ allocate an array\n+            var pids = scope.allocateArray(CLinker.C_INT, numPids);\n+            \/\/ list all the pids into the native array\n+            proc_listallpids(pids, numPids);\n+            \/\/ convert native array to java array\n+            int[] jpids = pids.toIntArray();\n+            \/\/ buffer for process name\n+            var nameBuf = scope.allocateArray(CLinker.C_CHAR, NAME_BUF_MAX);\n+            for (int i = 0; i < jpids.length; i++) {\n+                int pid = jpids[i];\n+                \/\/ get the process name\n+                proc_name(pid, nameBuf, NAME_BUF_MAX);\n+                String procName = CLinker.toJavaString(nameBuf);\n+                \/\/ print pid and process name\n+                System.out.printf(\"%d %s\\n\", pid, procName);\n+            }\n+        }\n+    }\n+}\n+\n+```\n+\n+### Compiling and running the libproc sample\n+\n+```sh\n+\n+java -Dforeign.restricted=permit \\\n+    --add-modules jdk.incubator.foreign \\\n+    -Djava.library.path=\/usr\/lib LibprocMain.java\n+\n+```\n+\n+## Using libgit2 from Java (Mac OS)\n+\n+### Getting and building libgit2\n+\n+* Download libgit2 v1.0.0 source from https:\/\/github.com\/libgit2\/libgit2\/releases\n+* Use cmake to build from libgit2\n+* Let ${LIBGIT2_HOME} be the directory where you expanded libgit2 sources.\n+* Let ${LIBGIT2_HOME}\/build be the build directory where libgit2.dylib is built.\n+\n+### jextract git2.h\n+\n+```sh\n+\n+jextract \\\n+  -t com.github -lgit2 \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/ \\\n+  -I ${LIBGIT2_HOME}\/include\/ \\\n+  -I ${LIBGIT2_HOME}\/include\/git2 \\\n+  ${LIBGIT2_HOME}\/include\/git2.h\n+\n+```\n+\n+### Java program that uses libgit2 to clone github repo\n+\n+```java\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.NativeScope;\n+import static com.github.git2_h.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+import static jdk.incubator.foreign.MemoryAddress.NULL;\n+\n+public class GitClone {\n+    public static void main(String[] args) {\n+          if (args.length != 2) {\n+              System.err.println(\"java GitClone <url> <path>\");\n+              System.exit(1);\n+          }\n+          git_libgit2_init();\n+          try (var scope = NativeScope.unboundedScope()) {\n+              var repo = scope.allocate(C_POINTER);\n+              var url = toCString(args[0], scope);\n+              var path = toCString(args[1], scope);\n+              System.out.println(git_clone(repo, url, path, NULL));\n+          }\n+          git_libgit2_shutdown();\n+    }\n+}\n+\n+```\n+\n+### Compiling and running the libgit2 sample\n+\n+```sh\n+\n+# file run.sh\n+\n+java -Dforeign.restricted=permit --add-modules jdk.incubator.foreign \\\n+    -Djava.library.path=${LIBGIT2_HOME}\/build\/ \\\n+    GitClone.java $*\n+```\n+\n+### Cloning a github repo using the above run.sh command\n+\n+```sh\n+\n+sh run.sh https:\/\/github.com\/libgit2\/libgit2.git libgit2\n+\n+```\n+\n+## Using sqlite3 library from Java (Mac OS)\n+\n+\n+### jextract sqlite3.h\n+\n+```sh\n+\n+jextract \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\\n+  \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/sqlite3.h \\\n+  -t org.sqlite -lsqlite3\n+\n+```\n+### Java program that uses sqlite3\n+\n+```java\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.NativeScope;\n+import static jdk.incubator.foreign.MemoryAddress.NULL;\n+import static org.sqlite.sqlite3_h.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+\n+public class SqliteMain {\n+   public static void main(String[] args) throws Exception {\n+        try (var scope = NativeScope.unboundedScope()) {\n+            \/\/ char** errMsgPtrPtr;\n+            var errMsgPtrPtr = scope.allocate(C_POINTER);\n+\n+            \/\/ sqlite3** dbPtrPtr;\n+            var dbPtrPtr = scope.allocate(C_POINTER);\n+\n+            int rc = sqlite3_open(toCString(\"employee.db\",scope), dbPtrPtr);\n+            if (rc != 0) {\n+                System.err.println(\"sqlite3_open failed: \" + rc);\n+                return;\n+            } else {\n+                System.out.println(\"employee db opened\");\n+            }\n+\n+            \/\/ sqlite3* dbPtr;\n+            var dbPtr = MemoryAccess.getAddress(dbPtrPtr);\n+\n+            \/\/ create a new table\n+            var sql = toCString(\n+                \"CREATE TABLE EMPLOYEE (\"  +\n+                \"  ID INT PRIMARY KEY NOT NULL,\" +\n+                \"  NAME TEXT NOT NULL,\"    +\n+                \"  SALARY REAL NOT NULL )\", scope);\n+\n+            rc = sqlite3_exec(dbPtr, sql, NULL, NULL, errMsgPtrPtr);\n+\n+            if (rc != 0) {\n+                System.err.println(\"sqlite3_exec failed: \" + rc);\n+                System.err.println(\"SQL error: \" + toJavaStringRestricted(MemoryAccess.getAddress(errMsgPtrPtr)));\n+                sqlite3_free(MemoryAccess.getAddress(errMsgPtrPtr));\n+            } else {\n+                System.out.println(\"employee table created\");\n+            }\n+\n+            \/\/ insert two rows\n+            sql = toCString(\n+                \"INSERT INTO EMPLOYEE (ID,NAME,SALARY) \" +\n+                    \"VALUES (134, 'Xyz', 200000.0); \" +\n+                \"INSERT INTO EMPLOYEE (ID,NAME,SALARY) \" +\n+                    \"VALUES (333, 'Abc', 100000.0);\", scope\n+            );\n+            rc = sqlite3_exec(dbPtr, sql, NULL, NULL, errMsgPtrPtr);\n+\n+            if (rc != 0) {\n+                System.err.println(\"sqlite3_exec failed: \" + rc);\n+                System.err.println(\"SQL error: \" + toJavaStringRestricted(MemoryAccess.getAddress(errMsgPtrPtr)));\n+                sqlite3_free(MemoryAccess.getAddress(errMsgPtrPtr));\n+            } else {\n+                System.out.println(\"rows inserted\");\n+            }\n+\n+            int[] rowNum = new int[1];\n+            \/\/ callback to print rows from SELECT query\n+            var callback = sqlite3_exec$callback.allocate((a, argc, argv, columnNames) -> {\n+                System.out.println(\"Row num: \" + rowNum[0]++);\n+                System.out.println(\"numColumns = \" + argc);\n+                var argv_seg = argv.asSegmentRestricted(C_POINTER.byteSize() * argc);\n+                var columnNames_seg = columnNames.asSegmentRestricted(C_POINTER.byteSize() * argc);\n+                for (int i = 0; i < argc; i++) {\n+                     String name = toJavaStringRestricted(MemoryAccess.getAddressAtIndex(columnNames_seg, i));\n+                     String value = toJavaStringRestricted(MemoryAccess.getAddressAtIndex(argv_seg, i));\n+                     System.out.printf(\"%s = %s\\n\", name, value);\n+                }\n+                return 0;\n+            }, scope);\n+\n+            \/\/ select query\n+            sql = toCString(\"SELECT * FROM EMPLOYEE\", scope);\n+            rc = sqlite3_exec(dbPtr, sql, callback, NULL, errMsgPtrPtr);\n+\n+            if (rc != 0) {\n+                System.err.println(\"sqlite3_exec failed: \" + rc);\n+                System.err.println(\"SQL error: \" + toJavaStringRestricted(MemoryAccess.getAddress(errMsgPtrPtr)));\n+                sqlite3_free(MemoryAccess.getAddress(errMsgPtrPtr));\n+            } else {\n+                System.out.println(\"done\");\n+            }\n+\n+            sqlite3_close(dbPtr);\n+        }\n+    }\n+}\n+\n+```\n+\n+### Compiling and running the sqlite3 sample\n+\n+```sh\n+\n+java -Dforeign.restricted=permit \\\n+   --add-modules jdk.incubator.foreign \\\n+   -Djava.library.path=\/usr\/lib SqliteMain.java\n+\n+```\n+\n+## Using OpenGL library from Java (Mac OS)\n+\n+### jextract glut.h\n+\n+```sh\n+\n+jextract -t opengl -lGL -l\/System\/Library\/Frameworks\/GLUT.framework\/Versions\/Current\/GLUT \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/ \\\n+  -C-F\/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/System\/Library\/Frameworks \\\n+  \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/System\/Library\/Frameworks\/GLUT.framework\/Headers\/glut.h\n+\n+```\n+### Java program that uses OpenGL\n+\n+```java\n+\n+import jdk.incubator.foreign.CLinker;\n+import static jdk.incubator.foreign.CLinker.*;\n+import jdk.incubator.foreign.NativeScope;\n+import static opengl.glut_h.*;\n+\n+public class Teapot {\n+    private float rot = 0;\n+\n+    Teapot(NativeScope scope) {\n+        \/\/ Reset Background\n+        glClearColor(0f, 0f, 0f, 0f);\n+        \/\/ Setup Lighting\n+        glShadeModel(GL_SMOOTH());\n+        var pos = scope.allocateArray(C_FLOAT, new float[] {0.0f, 15.0f, -15.0f, 0});\n+        glLightfv(GL_LIGHT0(), GL_POSITION(), pos);\n+        var spec = scope.allocateArray(C_FLOAT, new float[] {1, 1, 1, 0});\n+        glLightfv(GL_LIGHT0(), GL_AMBIENT(), spec);\n+        glLightfv(GL_LIGHT0(), GL_DIFFUSE(), spec);\n+        glLightfv(GL_LIGHT0(), GL_SPECULAR(), spec);\n+        var shini = scope.allocate(C_FLOAT, 113);\n+        glMaterialfv(GL_FRONT(), GL_SHININESS(), shini);\n+        glEnable(GL_LIGHTING());\n+        glEnable(GL_LIGHT0());\n+        glEnable(GL_DEPTH_TEST());\n+    }\n+\n+    void display() {\n+        glClear(GL_COLOR_BUFFER_BIT() | GL_DEPTH_BUFFER_BIT());\n+        glPushMatrix();\n+        glRotatef(-20f, 1f, 1f, 0f);\n+        glRotatef(rot, 0f, 1f, 0f);\n+        glutSolidTeapot(0.5d);\n+        glPopMatrix();\n+        glutSwapBuffers();\n+    }\n+\n+    void onIdle() {\n+        rot += 0.1;\n+        glutPostRedisplay();\n+    }\n+\n+    public static void main(String[] args) {\n+        try (var scope = NativeScope.unboundedScope()) {\n+            var argc = scope.allocate(C_INT, 0);\n+            glutInit(argc, argc);\n+            glutInitDisplayMode(GLUT_DOUBLE() | GLUT_RGB() | GLUT_DEPTH());\n+            glutInitWindowSize(500, 500);\n+            glutCreateWindow(CLinker.toCString(\"Hello Panama!\", scope));\n+            var teapot = new Teapot(scope);\n+            var displayStub = glutDisplayFunc$func.allocate(teapot::display, scope);\n+            var idleStub = glutIdleFunc$func.allocate(teapot::onIdle, scope);\n+            glutDisplayFunc(displayStub);\n+            glutIdleFunc(idleStub);\n+            glutMainLoop();\n+        }\n+    }\n+}\n+\n+```\n+\n+### Compiling and running the OpenGL sample\n+\n+```sh\n+\n+java -XstartOnFirstThread -Dforeign.restricted=permit --add-modules jdk.incubator.foreign \\\n+    -Djava.library.path=.:\/System\/Library\/Frameworks\/OpenGL.framework\/Versions\/Current\/Libraries\/ Teapot.java $*\n+\n+```\n+\n+## Using tensorflow (Mac OS)\n+\n+### getting libtensorflow\n+\n+* Download tensorflow library from\n+\n+    https:\/\/www.tensorflow.org\/install\/lang_c\n+\n+* extract the downloaded tar in a directory called LIBTENSORFLOW_HOME\n+\n+###  jextract c_api.h\n+\n+```sh\n+\n+jextract --source \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/ \\\n+  -t org.tensorflow \\\n+  -I ${LIBTENSORFLOW_HOME}\/include \\\n+  -l ${LIBTENSORFLOW_HOME}\/lib\/libtensorflow.dylib \\\n+  ${LIBTENSORFLOW_HOME}\/include\/tensorflow\/c\/c_api.h\n+\n+javac --add-modules jdk.incubator.foreign org\/tensorflow\/*.java\n+\n+```\n+\n+### Python program that creates and saves model\n+\n+The following Python program should be run to create and save model\n+which will read and printed by a Java program.\n+\n+Note: you need to install tensorflow package to run this python script.\n+\n+```python\n+\n+import tensorflow as tf\n+from tensorflow.keras import models, layers\n+from tensorflow.keras.datasets import mnist\n+\n+model = tf.keras.models.Sequential([\n+  tf.keras.layers.Flatten(input_shape=(28, 28)),\n+  tf.keras.layers.Dense(128,activation='relu'),\n+  tf.keras.layers.Dense(10, activation='softmax')\n+])\n+\n+model.compile(\n+    loss='sparse_categorical_crossentropy',\n+    optimizer=tf.keras.optimizers.Adam(0.001),\n+    metrics=['accuracy'],\n+)\n+\n+print(model.summary())\n+\n+(train_images, train_labels), (test_images, test_labels) = mnist.load_data()\n+\n+train_images = train_images\/255.0\n+test_images = test_images\/255.0\n+\n+model.fit(train_images, train_labels,\n+    epochs=4, batch_size=128, verbose=1)\n+\n+test_loss, test_accuracy = model.evaluate(test_images, test_labels)\n+\n+print(test_loss, test_accuracy)\n+\n+model.save(\"saved_mnist_model\")\n+\n+```\n+\n+### Java program that uses Tensorflow C API\n+\n+```java\n+\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+import static jdk.incubator.foreign.MemoryAccess.*;\n+import static jdk.incubator.foreign.MemoryAddress.*;\n+import static org.tensorflow.c_api_h.*;\n+\n+\/\/ simple program that loads saved model and prints basic info on operations in it\n+\n+public class TensorflowLoadSavedModel {\n+    public static void main(String... args) throws Exception {\n+        System.out.println(\"TensorFlow C library version: \" + toJavaStringRestricted(TF_Version()));\n+\n+        if (args.length == 0) {\n+            System.err.println(\"java TensorflowLoadSavedModel <saved model dir>\");\n+            System.exit(1);\n+        }\n+\n+        try (var scope = NativeScope.unboundedScope()) {\n+            var graph = TF_NewGraph();\n+            var status = TF_NewStatus();\n+            var sessionOpts = TF_NewSessionOptions();\n+\n+            var savedModelDir = toCString(args[0], scope);\n+            var tags = scope.allocate(C_POINTER, toCString(\"serve\", scope));\n+            var session = TF_LoadSessionFromSavedModel(sessionOpts, NULL, savedModelDir, tags, 1, graph, NULL, status);\n+\n+            if (TF_GetCode(status) != TF_OK()) {\n+                System.err.printf(\"cannot load session from saved model: %s\\n\",\n+                    toJavaStringRestricted(TF_Message(status)));\n+            } else {\n+                System.err.println(\"load session from saved model works!\");\n+            }\n+\n+            \/\/ print operations\n+            var size = scope.allocate(C_LONG_LONG);\n+            var operation = NULL;\n+            while (!(operation = TF_GraphNextOperation(graph, size)).equals(NULL)) {\n+                System.out.printf(\"%s : %s\\n\",\n+                    toJavaStringRestricted(TF_OperationName(operation)),\n+                    toJavaStringRestricted(TF_OperationOpType(operation)));\n+            }\n+\n+            TF_DeleteGraph(graph);\n+            TF_DeleteSession(session, status);\n+            TF_DeleteSessionOptions(sessionOpts);\n+            TF_DeleteStatus(status);\n+        }\n+    }\n+}\n+\n+```\n+\n+### Compiling and running the Java Tensorflow sample\n+\n+```sh\n+\n+java -Dforeign.restricted=permit --add-modules jdk.incubator.foreign \\\n+   TensorflowLoadSavedModel.java saved_mnist_model\n+\n+```\n+\n+## Using time.h (Mac OS)\n+\n+### jextract time.h\n+\n+\n+```sh\n+\n+jextract -t org.unix \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\\n+   \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/time.h\n+\n+```\n+\n+### Java program that uses POSIX time library\n+\n+```java\n+\n+import static org.unix.time_h.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+import jdk.incubator.foreign.*;\n+\n+public class PanamaTime {\n+    public static void main(String[] args) {\n+        try (NativeScope scope = NativeScope.unboundedScope()) {\n+            var now = scope.allocate(C_LONG, System.currentTimeMillis() \/ 1000);\n+            MemorySegment time = tm.allocate(scope);\n+            localtime_r(now, time);\n+            System.err.printf(\"Time = %d:%d\\n\", tm.tm_hour$get(time), tm.tm_min$get(time));\n+        }\n+    }\n+}\n+\n+```\n+\n+### Compiling and running the time sample\n+\n+\n+```sh\n+\n+java -Dforeign.restricted=permit --add-modules jdk.incubator.foreign PanamaTime.java\n+\n+```\n+\n+## Using libclang library (Mac OS)\n+\n+### jextract Index.h\n+\n+```sh\n+\n+# LIBCLANG_HOME is the directory where you've installed llvm 9.x or above\n+\n+jextract --source -t org.llvm.clang -lclang \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/ \\\n+  -I ${LIBCLANG_HOME}\/include\/ \\\n+  -I ${LIBCLANG_HOME}\/include\/clang-c \\\n+  ${LIBCLANG_HOME}\/include\/clang-c\/Index.h\n+javac --add-modules jdk.incubator.foreign org\/llvm\/clang\/*.java\n+\n+```\n+\n+### Java program that uses libclang to print AST of a given C program\n+\n+```java\n+\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+import static jdk.incubator.foreign.MemoryAddress.NULL;\n+import static org.llvm.clang.Index_h.*;\n+\n+public class ASTPrinter {\n+    private static String asJavaString(MemorySegment clangStr) {\n+        String str = toJavaStringRestricted(clang_getCString(clangStr));\n+        clang_disposeString(clangStr);\n+        return str;\n+    }\n+\n+    public static void main(String[] args) {\n+        if (args.length == 0) {\n+            System.err.println(\"java ASTPrinter <C source or header>\");\n+            System.exit(1);\n+        }\n+\n+        try (var scope = NativeScope.unboundedScope()) {\n+            \/\/ parse the C header\/source passed from the command line\n+            var index = clang_createIndex(0, 0);\n+            var tu = clang_parseTranslationUnit(index, toCString(args[0], scope),\n+                    NULL, 0, NULL, 0, CXTranslationUnit_None());\n+            \/\/ array trick to update within lambda\n+            var level = new int[1];\n+            var visitor = new MemorySegment[1];\n+\n+            \/\/ clang Cursor visitor callback\n+            visitor[0] = clang_visitChildren$visitor.allocate((cursor, parent, data) -> {\n+                var kind = clang_getCursorKind(cursor);\n+                var name = asJavaString(clang_getCursorSpelling(cursor));\n+                var kindName = asJavaString(clang_getCursorKindSpelling(kind));\n+                System.out.printf(\"%s %s %s\", \" \".repeat(level[0]), kindName, name);\n+                var type = clang_getCursorType(cursor);\n+                if (CXType.kind$get(type) != CXType_Invalid()) {\n+                    var typeName = asJavaString(clang_getTypeSpelling(type));\n+                    System.out.printf(\" <%s>\", typeName);\n+                }\n+                System.out.println();\n+\n+                \/\/ visit children\n+                level[0]++;\n+                clang_visitChildren(cursor, visitor[0], NULL);\n+                level[0]--;\n+\n+                return CXChildVisit_Continue();\n+            });\n+\n+            \/\/ get the AST root and visit it\n+            var root = clang_getTranslationUnitCursor(tu);\n+            clang_visitChildren(root, visitor[0], NULL);\n+\n+            clang_disposeTranslationUnit(tu);\n+            clang_disposeIndex(index);\n+        }\n+    }\n+}\n+\n+```\n+\n+### Compiling and running the libclang sample\n+\n+```sh\n+\n+java -Dforeign.restricted=permit --add-modules jdk.incubator.foreign \\\n+    ASTPrinter.java $*\n+\n+```\n","filename":"doc\/panama_jextract.md","additions":1027,"deletions":0,"binary":false,"changes":1027,"status":"added"},{"patch":"@@ -0,0 +1,284 @@\n+<!DOCTYPE html>\n+<html xmlns=\"http:\/\/www.w3.org\/1999\/xhtml\" lang=\"\" xml:lang=\"\">\n+<head>\n+  <meta charset=\"utf-8\" \/>\n+  <meta name=\"generator\" content=\"pandoc\" \/>\n+  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, user-scalable=yes\" \/>\n+  <title>panama_memaccess<\/title>\n+  <style type=\"text\/css\">\n+      code{white-space: pre-wrap;}\n+      span.smallcaps{font-variant: small-caps;}\n+      span.underline{text-decoration: underline;}\n+      div.column{display: inline-block; vertical-align: top; width: 50%;}\n+  <\/style>\n+  <style type=\"text\/css\">\n+a.sourceLine { display: inline-block; line-height: 1.25; }\n+a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }\n+a.sourceLine:empty { height: 1.2em; }\n+.sourceCode { overflow: visible; }\n+code.sourceCode { white-space: pre; position: relative; }\n+div.sourceCode { margin: 1em 0; }\n+pre.sourceCode { margin: 0; }\n+@media screen {\n+div.sourceCode { overflow: auto; }\n+}\n+@media print {\n+code.sourceCode { white-space: pre-wrap; }\n+a.sourceLine { text-indent: -1em; padding-left: 1em; }\n+}\n+pre.numberSource a.sourceLine\n+  { position: relative; left: -4em; }\n+pre.numberSource a.sourceLine::before\n+  { content: attr(title);\n+    position: relative; left: -1em; text-align: right; vertical-align: baseline;\n+    border: none; pointer-events: all; display: inline-block;\n+    -webkit-touch-callout: none; -webkit-user-select: none;\n+    -khtml-user-select: none; -moz-user-select: none;\n+    -ms-user-select: none; user-select: none;\n+    padding: 0 4px; width: 4em;\n+    color: #aaaaaa;\n+  }\n+pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }\n+div.sourceCode\n+  {  }\n+@media screen {\n+a.sourceLine::before { text-decoration: underline; }\n+}\n+code span.al { color: #ff0000; font-weight: bold; } \/* Alert *\/\n+code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } \/* Annotation *\/\n+code span.at { color: #7d9029; } \/* Attribute *\/\n+code span.bn { color: #40a070; } \/* BaseN *\/\n+code span.bu { } \/* BuiltIn *\/\n+code span.cf { color: #007020; font-weight: bold; } \/* ControlFlow *\/\n+code span.ch { color: #4070a0; } \/* Char *\/\n+code span.cn { color: #880000; } \/* Constant *\/\n+code span.co { color: #60a0b0; font-style: italic; } \/* Comment *\/\n+code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } \/* CommentVar *\/\n+code span.do { color: #ba2121; font-style: italic; } \/* Documentation *\/\n+code span.dt { color: #902000; } \/* DataType *\/\n+code span.dv { color: #40a070; } \/* DecVal *\/\n+code span.er { color: #ff0000; font-weight: bold; } \/* Error *\/\n+code span.ex { } \/* Extension *\/\n+code span.fl { color: #40a070; } \/* Float *\/\n+code span.fu { color: #06287e; } \/* Function *\/\n+code span.im { } \/* Import *\/\n+code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } \/* Information *\/\n+code span.kw { color: #007020; font-weight: bold; } \/* Keyword *\/\n+code span.op { color: #666666; } \/* Operator *\/\n+code span.ot { color: #007020; } \/* Other *\/\n+code span.pp { color: #bc7a00; } \/* Preprocessor *\/\n+code span.sc { color: #4070a0; } \/* SpecialChar *\/\n+code span.ss { color: #bb6688; } \/* SpecialString *\/\n+code span.st { color: #4070a0; } \/* String *\/\n+code span.va { color: #19177c; } \/* Variable *\/\n+code span.vs { color: #4070a0; } \/* VerbatimString *\/\n+code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } \/* Warning *\/\n+  <\/style>\n+  <link rel=\"stylesheet\" href=\"..\/make\/data\/docs-resources\/resources\/jdk-default.css\" \/>\n+<\/head>\n+<body>\n+<nav id=\"TOC\">\n+<ul>\n+<li><a href=\"#state-of-foreign-memory-support\">State of foreign memory support<\/a><ul>\n+<li><a href=\"#segments\">Segments<\/a><\/li>\n+<li><a href=\"#memory-access-handles\">Memory access handles<\/a><\/li>\n+<li><a href=\"#safety\">Safety<\/a><\/li>\n+<li><a href=\"#layouts\">Layouts<\/a><\/li>\n+<li><a href=\"#var-handle-combinators\">Var handle combinators<\/a><\/li>\n+<li><a href=\"#segment-accessors\">Segment accessors<\/a><\/li>\n+<li><a href=\"#interoperability\">Interoperability<\/a><\/li>\n+<li><a href=\"#unsafe-segments\">Unsafe segments<\/a><\/li>\n+<li><a href=\"#confinement\">Confinement<\/a><\/li>\n+<li><a href=\"#implicit-deallocation\">Implicit deallocation<\/a><\/li>\n+<\/ul><\/li>\n+<\/ul>\n+<\/nav>\n+<h2 id=\"state-of-foreign-memory-support\">State of foreign memory support<\/h2>\n+<p><strong>October 2020<\/strong><\/p>\n+<ul>\n+<li>Reflect latest API changes in handoff\/implicit deallocation<\/li>\n+<li>Updated section on restricted segments reflecting new, simpler API<\/li>\n+<li>Revamped section on confinement to add description of shared segments<\/li>\n+<li>Added section on implicit deallocation<\/li>\n+<\/ul>\n+<p><strong>Maurizio Cimadamore<\/strong><\/p>\n+<p>A crucial part of any native interop story lies in the ability of accessing off-heap memory in an efficient fashion. Panama achieves this goal through the so called Foreign Memory Access API. This API has been made available as an incubating API in Java <a href=\"https:\/\/openjdk.java.net\/jeps\/370\">14<\/a> ad <a href=\"https:\/\/openjdk.java.net\/jeps\/383\">15<\/a>, and is, to date, the most mature part of the Panama interop story.<\/p>\n+<h3 id=\"segments\">Segments<\/h3>\n+<p>Memory segments are abstractions which can be used to model memory regions, located either on- or off- the Java heap. Segments can be allocated from native memory (e.g. like a <code>malloc<\/code>), or can be wrapped around existing memory sources (e.g. a Java array or a <code>ByteBuffer<\/code>). Memory segments provide <em>strong<\/em> guarantees which make memory dereference operation <em>safe<\/em>. More specifically, each segment provides:<\/p>\n+<ul>\n+<li><em>spatial bounds<\/em> - that is, a segment has a base address and a size, and accessing a segment outside those boundaries is forbidden<\/li>\n+<li><em>temporal bounds<\/em> - that is, a segment has a <em>state<\/em> - meaning that it can be used and then <em>closed<\/em> when the memory backing the segment is no longer needed (note, this might trigger deallocation of said memory)<\/li>\n+<li><em>thread-confinement<\/em> - that is, a segment is a view over a memory region that is <em>owned<\/em> by the thread which created it. Attempting to dereference or close a segment outside the confinement thread is forbidden (this is crucial to avoid access vs. close races in multi-threaded scenario)<\/li>\n+<\/ul>\n+<p>For instance, the following snippet allocates 100 bytes off-heap:<\/p>\n+<div class=\"sourceCode\" id=\"cb1\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb1-1\" title=\"1\"><span class=\"kw\">try<\/span> (MemorySegment segment = MemorySegment.<span class=\"fu\">allocateNative<\/span>(<span class=\"dv\">100<\/span>)) {<\/a>\n+<a class=\"sourceLine\" id=\"cb1-2\" title=\"2\">    ...<\/a>\n+<a class=\"sourceLine\" id=\"cb1-3\" title=\"3\">} <span class=\"co\">\/\/ frees memory<\/span><\/a><\/code><\/pre><\/div>\n+<p>Since segments are <code>AutoCloseable<\/code> they can be used inside a <em>try-with-resources<\/em> statement, which helps ensure that memory will be released when the segment is no longer needed.<\/p>\n+<p>Memory segments support <em>slicing<\/em> — that is, given a segment, it is possible to create a new segment whose spatial bounds are stricter than that of the original segment:<\/p>\n+<div class=\"sourceCode\" id=\"cb2\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb2-1\" title=\"1\">MemorySegment segment = MemorySement.<span class=\"fu\">allocateNative<\/span>(<span class=\"dv\">10<\/span>);<\/a>\n+<a class=\"sourceLine\" id=\"cb2-2\" title=\"2\">MemorySegment slice = segment.<span class=\"fu\">asSlice<\/span>(<span class=\"dv\">4<\/span>, <span class=\"dv\">4<\/span>);<\/a><\/code><\/pre><\/div>\n+<p>The above code creates a slice that starts at offset 4 and has a length of 4 bytes. Slices have the <em>same<\/em> temporal bounds as the parent segment - this means that when the parent segment is closed, all the slices derived from it are also closed. The opposite is also true, closing a slice closes the parent segment (and all the other slices derived from it). If a library wants to share a slice, but prevent a client from closing it (could be useful e.g. when implementing a slab allocator), the library could prevent a client from closing the slice by creating a <em>non-closeable<\/em> view:<\/p>\n+<div class=\"sourceCode\" id=\"cb3\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb3-1\" title=\"1\">MemorySegment sharedSlice = slice.<span class=\"fu\">withAccessModes<\/span>(ALL_ACCESS &amp; ~CLOSE);<\/a><\/code><\/pre><\/div>\n+<p>Any attempt to call <code>close<\/code> on <code>sharedSlice<\/code> will be met with an exception. Memory segments support various access modes (including those for read\/write access) which can be used to constrain the set of operations available to clients.<\/p>\n+<h3 id=\"memory-access-handles\">Memory access handles<\/h3>\n+<p>Dereferencing memory associated with segments is made possible by using <em>memory access var handles<\/em>. A memory access var handle is a special kind of var handle which takes a memory segment access coordinate, together with a byte offset — the offset, relative to the segment's base address at which the dereference operation should occur. A memory access var handle can be obtained as follows:<\/p>\n+<div class=\"sourceCode\" id=\"cb4\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb4-1\" title=\"1\">VarHandle intHandle = MemoryHandles.<span class=\"fu\">varHandle<\/span>(<span class=\"dt\">int<\/span>.<span class=\"fu\">class<\/span>, <span class=\"bu\">ByteOrder<\/span>.<span class=\"fu\">nativeOrder<\/span>())    <\/a><\/code><\/pre><\/div>\n+<p>To create a dereference handle we have to specify a carrier type — the type we want to use e.g. to extract values from memory, as well as to whether any byte swapping should be applied when contents are read from or stored to memory. Additionally, the user can supply an extra alignment parameter (not shown here) — this can be useful to impose additional constraints on how memory dereferences should occur; for instance, a client might want to prevent access to misaligned 32 bit values.<\/p>\n+<p>For instance, to read 10 int values from a segment, we can write the following code:<\/p>\n+<div class=\"sourceCode\" id=\"cb5\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb5-1\" title=\"1\">MemorySegment segment = ...<\/a>\n+<a class=\"sourceLine\" id=\"cb5-2\" title=\"2\"><span class=\"dt\">int<\/span>[] values = <span class=\"kw\">new<\/span> <span class=\"dt\">int<\/span>[<span class=\"dv\">10<\/span>];<\/a>\n+<a class=\"sourceLine\" id=\"cb5-3\" title=\"3\"><span class=\"kw\">for<\/span> (<span class=\"dt\">int<\/span> i = <span class=\"dv\">0<\/span> ; i &lt; values.<span class=\"fu\">length<\/span> ; i++) {<\/a>\n+<a class=\"sourceLine\" id=\"cb5-4\" title=\"4\">    values[i] = (<span class=\"dt\">int<\/span>)intHandle.<span class=\"fu\">get<\/span>(segment, (<span class=\"dt\">long<\/span>)i * <span class=\"dv\">4<\/span>);<\/a>\n+<a class=\"sourceLine\" id=\"cb5-5\" title=\"5\">}<\/a><\/code><\/pre><\/div>\n+<p>Memory access var handles (as any other var handle) are <em>strongly<\/em> typed; and to get maximum efficiency, it is generally necessary to introduce casts to make sure that the access coordinates match the expected types — in this case we have to cast <code>i * 4<\/code> into a long; similarly, since the signature polymorphic method <code>VarHandle::get<\/code> notionally returns <code>Object<\/code> a cast is necessary to force the right return type the var handle operation.<\/p>\n+<p>Note that, since the offset of the dereference operation is expressed in bytes, we have to manually compute the starting offset, by multiplying the logical index <code>i<\/code> by <code>4<\/code> — the size (in bytes) of a Java int value; this is not dissimilar to what happens with the <code>ByteBuffer<\/code> absolute get\/put methods. We shall see later how memory layouts help us achieving higher level, structured access.<\/p>\n+<h3 id=\"safety\">Safety<\/h3>\n+<p>The memory access API provides basic safety guarantees for memory dereference operations. More specifically, dereferencing memory should either succeed, or result in a runtime exception - but, crucially, should never result in a VM crash, or, more subtly, in memory corruption occurring <em>outside<\/em> the region of memory associated with a memory segment.<\/p>\n+<p>To enforce this, strong spatial and temporal checks are enforced upon every access. Consider the following code:<\/p>\n+<div class=\"sourceCode\" id=\"cb6\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb6-1\" title=\"1\">MemorySegment segment = MemorySegment.<span class=\"fu\">allocateNative<\/span>(<span class=\"dv\">10<\/span>);<\/a>\n+<a class=\"sourceLine\" id=\"cb6-2\" title=\"2\">intHandle.<span class=\"fu\">get<\/span>(segment, <span class=\"dv\">8<\/span>); <span class=\"co\">\/\/throws ISE<\/span><\/a><\/code><\/pre><\/div>\n+<p>The above code leads to a runtime exception, as we trying to access memory outside the segment's bounds — the access operation starts at offset 8 (which is within bounds), but ends at offset 11 (which is outside bounds).<\/p>\n+<p>Similarly, attempting to access an already closed segment leads to a failure:<\/p>\n+<div class=\"sourceCode\" id=\"cb7\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb7-1\" title=\"1\">segment.<span class=\"fu\">close<\/span>();<\/a>\n+<a class=\"sourceLine\" id=\"cb7-2\" title=\"2\">intHandle.<span class=\"fu\">get<\/span>(segment, <span class=\"dv\">0<\/span>); <span class=\"co\">\/\/throws ISE<\/span><\/a><\/code><\/pre><\/div>\n+<p>This time, the access occurs within the spatial bounds implied by the segment, but when access occurs, the segment has already been <em>closed<\/em>, so the access operation fails. This is crucial to guarantee safety: since memory segments ensure <em>deterministic deallocation<\/em>, the above code might end up attempting to dereference already freed memory.<\/p>\n+<p>On top of basic spatial and temporal bound guarantees, memory segments also enforce thread-confinement guarantees, which will be discussed in a later <a href=\"#Confinement\">section<\/a>. Note that, while these checks might seem expensive when considered in isolation, the Foreign Memory Access API is designed and implemented such that the JIT compiler can hoist most, if not all, such checks outside hot loops. Hence, memory access efficiency is not negatively impacted by the safety requirements of the API.<\/p>\n+<h3 id=\"layouts\">Layouts<\/h3>\n+<p>Expressing byte offsets (as in the <a href=\"#memory-access-handles\">above<\/a> example) can lead to code that is hard to read, and very fragile — as memory layout invariants are captured, implicitly, in the constants used to scale offsets. To address this issue, we add a <em>memory layout<\/em> API which allows clients to define memory layouts <em>programmatically<\/em>. For instance, the layout of the array used in the above example can be expressed using the following code:<\/p>\n+<div class=\"sourceCode\" id=\"cb8\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb8-1\" title=\"1\">MemoryLayout intArray = MemoryLayout.<span class=\"fu\">ofSequence<\/span>(<span class=\"dv\">10<\/span>, MemoryLayout.<span class=\"fu\">ofValueBits<\/span>(<span class=\"dv\">32<\/span>));<\/a><\/code><\/pre><\/div>\n+<p>That is, our layout is a repetition of 10 elements whose size is 32 bit each. The advantage of defining a memory layout upfront, using an API, is that we can then query on the layout — for instance we can compute the offset of the 3rd element of the array:<\/p>\n+<div class=\"sourceCode\" id=\"cb9\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb9-1\" title=\"1\"><span class=\"dt\">long<\/span> element3 = intArray.<span class=\"fu\">byteOffset<\/span>(PathElement.<span class=\"fu\">sequenceElement<\/span>(<span class=\"dv\">3<\/span>)); <span class=\"co\">\/\/ 12<\/span><\/a><\/code><\/pre><\/div>\n+<p>To specify which nested layout element should be used for the offset calculation we use a so called <em>layout path<\/em> - that is, a selection expression that navigates the layout, from the <em>root<\/em> layout, down to the leaf layout we wish to select (in this case the 3rd layout element in the sequence).<\/p>\n+<p>Layouts can also be used to obtain memory access var handles; so we can rewrite the above example as follows:<\/p>\n+<div class=\"sourceCode\" id=\"cb10\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb10-1\" title=\"1\">MemorySegment segment = ...<\/a>\n+<a class=\"sourceLine\" id=\"cb10-2\" title=\"2\"><span class=\"dt\">int<\/span>[] values = <span class=\"kw\">new<\/span> <span class=\"dt\">int<\/span>[<span class=\"dv\">10<\/span>];<\/a>\n+<a class=\"sourceLine\" id=\"cb10-3\" title=\"3\">VarHandle elemHandle = intArray.<span class=\"fu\">varHandle<\/span>(<span class=\"dt\">int<\/span>.<span class=\"fu\">class<\/span>, PathElement.<span class=\"fu\">sequenceElement<\/span>());<\/a>\n+<a class=\"sourceLine\" id=\"cb10-4\" title=\"4\"><span class=\"kw\">for<\/span> (<span class=\"dt\">int<\/span> i = <span class=\"dv\">0<\/span> ; i &lt; values.<span class=\"fu\">length<\/span> ; i++) {<\/a>\n+<a class=\"sourceLine\" id=\"cb10-5\" title=\"5\">    values[i] = (<span class=\"dt\">int<\/span>)elemHandle.<span class=\"fu\">get<\/span>(segment, (<span class=\"dt\">long<\/span>)i);<\/a>\n+<a class=\"sourceLine\" id=\"cb10-6\" title=\"6\">}<\/a><\/code><\/pre><\/div>\n+<p>In the above, <code>elemHandle<\/code> is a var handle whose type is <code>int<\/code> , which takes two access coordinates:<\/p>\n+<ol type=\"1\">\n+<li>a <code>MemorySegment<\/code> instance; the segment whose memory should be dereferenced<\/li>\n+<li>a <em>logical<\/em> index, which is used to select the element of the sequence we want to access<\/li>\n+<\/ol>\n+<p>In other words, manual offset computation is no longer needed — offsets and strides can in fact be derived from the layout object.<\/p>\n+<p>Memory layouts shine when structured access is needed — consider the following C declaration:<\/p>\n+<div class=\"sourceCode\" id=\"cb11\"><pre class=\"sourceCode c\"><code class=\"sourceCode c\"><a class=\"sourceLine\" id=\"cb11-1\" title=\"1\"><span class=\"kw\">typedef<\/span> <span class=\"kw\">struct<\/span> {<\/a>\n+<a class=\"sourceLine\" id=\"cb11-2\" title=\"2\">    <span class=\"dt\">char<\/span> kind;<\/a>\n+<a class=\"sourceLine\" id=\"cb11-3\" title=\"3\">    <span class=\"dt\">int<\/span> value;<\/a>\n+<a class=\"sourceLine\" id=\"cb11-4\" title=\"4\">} TaggedValues[<span class=\"dv\">5<\/span>];<\/a><\/code><\/pre><\/div>\n+<p>The above C declaration can be modeled using the layout below:<\/p>\n+<div class=\"sourceCode\" id=\"cb12\"><pre class=\"sourceCode javascript\"><code class=\"sourceCode javascript\"><a class=\"sourceLine\" id=\"cb12-1\" title=\"1\">SequenceLayout taggedValues <span class=\"op\">=<\/span> <span class=\"va\">MemoryLayout<\/span>.<span class=\"at\">ofSequence<\/span>(<span class=\"dv\">5<\/span><span class=\"op\">,<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb12-2\" title=\"2\">    <span class=\"va\">MemoryLayout<\/span>.<span class=\"at\">ofStruct<\/span>(<\/a>\n+<a class=\"sourceLine\" id=\"cb12-3\" title=\"3\">        <span class=\"va\">MemoryLayout<\/span>.<span class=\"at\">ofValueBits<\/span>(<span class=\"dv\">8<\/span><span class=\"op\">,<\/span> <span class=\"va\">ByteOrder<\/span>.<span class=\"at\">nativeOrder<\/span>()).<span class=\"at\">withName<\/span>(<span class=\"st\">&quot;kind&quot;<\/span>)<span class=\"op\">,<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb12-4\" title=\"4\">        <span class=\"va\">MemoryLayout<\/span>.<span class=\"at\">ofPaddingBits<\/span>(<span class=\"dv\">24<\/span>)<span class=\"op\">,<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb12-5\" title=\"5\">        <span class=\"va\">MemoryLayout<\/span>.<span class=\"at\">ofValueBits<\/span>(<span class=\"dv\">32<\/span><span class=\"op\">,<\/span> <span class=\"va\">ByteOrder<\/span>.<span class=\"at\">nativeOrder<\/span>()).<span class=\"at\">withName<\/span>(<span class=\"st\">&quot;value&quot;<\/span>)<\/a>\n+<a class=\"sourceLine\" id=\"cb12-6\" title=\"6\">    )<\/a>\n+<a class=\"sourceLine\" id=\"cb12-7\" title=\"7\">).<span class=\"at\">withName<\/span>(<span class=\"st\">&quot;TaggedValues&quot;<\/span>)<span class=\"op\">;<\/span><\/a><\/code><\/pre><\/div>\n+<p>Here we assume that we need to insert some padding after the <code>kind<\/code> field to honor the alignment requirements of the <code>value<\/code> field <a href=\"#1\"><sup>1<\/sup><\/a>. Now, if we had to access the <code>value<\/code> field of all the elements of the array using manual offset computation, the code would quickly become pretty hard to read — on each iteration we would have to remember that the stride of the array is 8 bytes and that the offset of the <code>value<\/code> field relative to the <code>TaggedValue<\/code> struct is 4 bytes. This gives us an access expression like <code>(i * 8) + 4<\/code>, where <code>i<\/code> is the index of the element whose <code>value<\/code> field needs to be accessed.<\/p>\n+<p>With memory layouts, we can simply compute, once and for all, the memory access var handle to access the <code>value<\/code> field inside the sequence, as follows:<\/p>\n+<div class=\"sourceCode\" id=\"cb13\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb13-1\" title=\"1\">VarHandle valuesHandle = taggedValues.<span class=\"fu\">varHandle<\/span>(<span class=\"dt\">int<\/span>.<span class=\"fu\">class<\/span>,<\/a>\n+<a class=\"sourceLine\" id=\"cb13-2\" title=\"2\">                                               PathElement.<span class=\"fu\">sequenceElement<\/span>(),<\/a>\n+<a class=\"sourceLine\" id=\"cb13-3\" title=\"3\">                                               PathElement.<span class=\"fu\">groupElement<\/span>(<span class=\"st\">&quot;value&quot;<\/span>));<\/a><\/code><\/pre><\/div>\n+<p>When using this var handle, no manual offset computation will be required: the resulting <code>valuesHandle<\/code> will feature an additional <code>long<\/code> coordinate which can be used to select the desired <code>value<\/code> field from the sequence.<\/p>\n+<h3 id=\"var-handle-combinators\">Var handle combinators<\/h3>\n+<p>The attentive reader might have noted how rich the var handles returned by the layout API are, compared to the simple memory access var handle we have seen at play <a href=\"#memory-access-handles\">here<\/a>. How do we go from a simple access var handle that takes a byte offset to a var handle that can dereference a complex layout path? The answer is, by using var handle <em>combinators<\/em>. Developers familiar with the method handle API know how simpler method handles can be combined into more complex ones using the various combinator methods in the <code>MethodHandles<\/code> API. These methods allow, for instance, to insert (or bind) arguments into a target method handle, filter return values, permute arguments and much more.<\/p>\n+<p>Sadly, none of these features are available when working with var handles. The Foreign Memory Access API rectifies this, by adding a rich set of var handle combinators in the <code>MemoryHandles<\/code> class; with these tools, developers can express var handle transformations such as:<\/p>\n+<ul>\n+<li>mapping a var handle carrier type into a different one, using an embedding\/projection method handle pairs<\/li>\n+<li>filter one or more var handle access coordinates using unary filters<\/li>\n+<li>permute var handle access coordinates<\/li>\n+<li>bind concrete access coordinates to an existing var handle<\/li>\n+<\/ul>\n+<p>Without diving too deep, let's consider how we might want to take a basic memory access handle and turn it into a var handle which dereference a segment at a specific offset (again using the <code>taggedValues<\/code> layout defined previously):<\/p>\n+<div class=\"sourceCode\" id=\"cb14\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb14-1\" title=\"1\">VarHandle intHandle = MemoryHandles.<span class=\"fu\">varHandle<\/span>(<span class=\"dt\">int<\/span>.<span class=\"fu\">class<\/span>, <span class=\"bu\">ByteOrder<\/span>.<span class=\"fu\">nativeOrder<\/span>()); <span class=\"co\">\/\/ (MS, J) -&gt; I<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb14-2\" title=\"2\"><span class=\"dt\">long<\/span> offsetOfValue = taggedValues.<span class=\"fu\">byteOffset<\/span>(PathElement.<span class=\"fu\">sequenceElement<\/span>(<span class=\"dv\">0<\/span>),<\/a>\n+<a class=\"sourceLine\" id=\"cb14-3\" title=\"3\">                                             PathElement.<span class=\"fu\">groupElement<\/span>(<span class=\"st\">&quot;value&quot;<\/span>));<\/a>\n+<a class=\"sourceLine\" id=\"cb14-4\" title=\"4\">VarHandle valueHandle = MemoryHandles.<span class=\"fu\">insertCoordinates<\/span>(intHandle, <span class=\"dv\">0<\/span>, offsetOfValue); <span class=\"co\">\/\/ (MS) -&gt; I<\/span><\/a><\/code><\/pre><\/div>\n+<p>We have been able to derive, from a basic memory access var handle, a new var handle that dereferences a segment at a given fixed offset. It is easy to see how other, richer, var handles obtained using the layout API can be constructed manually using the var handle combinator API.<\/p>\n+<h3 id=\"segment-accessors\">Segment accessors<\/h3>\n+<p>Building complex memory access var handles using layout paths and the combinator API is useful, especially for structured access. But in simple cases, creating a <code>VarHandle<\/code> just to be able to read an int value at a given segment offset can be perceived as overkill. For this reason, the foreign memory access API provides ready-made static accessors in the <code>MemoryAccess<\/code> class, which allows to dereference a segment in various ways. For instance, if a client wants to read an int value from a segment, one of the following methods can be used:<\/p>\n+<ul>\n+<li><code>MemoryAccess::getInt(MemorySegment)<\/code> — reads an int value (4 bytes) starting at the segment's base address<\/li>\n+<li><code>MemoryAccess::getIntAtOffset(MemorySegment, long)<\/code> — reads an int value (4 bytes) starting at the address <code>A = B + O<\/code> where <code>B<\/code> is the segment's base address, and <code>O<\/code> is an offset (in bytes) supplied by the client<\/li>\n+<li><code>MemoryAccess::getIntAtIndex(MemorySegment, long)<\/code> — reads an int value (4 bytes) starting at the address <code>A = B + (4 * I)<\/code> where <code>B<\/code> is the segment's base address, and <code>I<\/code> is a logical index supplied by the client; this accessor is useful for mimicking array access.<\/li>\n+<\/ul>\n+<p>In other words, at least in simple cases, memory dereference operations can be achieved without the need of going through the <code>VarHandle<\/code> API; of course in more complex cases (structured and\/or multidimensional access, fenced access) the full power of the <code>VarHandle<\/code> API might still come in handy.<\/p>\n+<h3 id=\"interoperability\">Interoperability<\/h3>\n+<p>Memory segments are pretty flexible when it comes to interacting with existing memory sources. For instance it is possible to:<\/p>\n+<ul>\n+<li>create segment from a Java array<\/li>\n+<li>convert a segment into a Java array<\/li>\n+<li>create a segment from a byte buffer<\/li>\n+<li>convert a segment into a byte buffer<\/li>\n+<\/ul>\n+<p>For instance, thanks to bi-directional integration with the byte buffer API, it is possible for users to create a memory segment, and then de-reference it using the byte buffer API, as follows:<\/p>\n+<div class=\"sourceCode\" id=\"cb15\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb15-1\" title=\"1\">MemorySegment segment = ...<\/a>\n+<a class=\"sourceLine\" id=\"cb15-2\" title=\"2\"><span class=\"dt\">int<\/span>[] values = <span class=\"kw\">new<\/span> <span class=\"dt\">int<\/span>[<span class=\"dv\">10<\/span>];<\/a>\n+<a class=\"sourceLine\" id=\"cb15-3\" title=\"3\"><span class=\"bu\">ByteBuffer<\/span> bb = segment.<span class=\"fu\">asByteBuffer<\/span>();<\/a>\n+<a class=\"sourceLine\" id=\"cb15-4\" title=\"4\"><span class=\"kw\">for<\/span> (<span class=\"dt\">int<\/span> i = <span class=\"dv\">0<\/span> ; i &lt; values.<span class=\"fu\">length<\/span> ; i++) {<\/a>\n+<a class=\"sourceLine\" id=\"cb15-5\" title=\"5\">    values[i] = bb.<span class=\"fu\">getInt<\/span>();<\/a>\n+<a class=\"sourceLine\" id=\"cb15-6\" title=\"6\">}<\/a><\/code><\/pre><\/div>\n+<p>The only thing to remember is that, when a byte buffer view is created out of a memory segment, the buffer has the same temporal bound and thread-confinement guarantees as those of the segment it originated from. This means that if the segment is closed, any subsequent attempt to dereference its memory via a (previously obtained) byte buffer view will fail with an exception.<\/p>\n+<h3 id=\"unsafe-segments\">Unsafe segments<\/h3>\n+<p>It is sometimes necessary to create a segment out of an existing memory source, which might be managed by native code. This is the case, for instance, if we want to create a segment out of memory managed by a custom allocator.<\/p>\n+<p>The ByteBuffer API allows such a move, through a JNI <a href=\"https:\/\/docs.oracle.com\/javase\/8\/docs\/technotes\/guides\/jni\/spec\/functions.html#NewDirectByteBuffer\">method<\/a>, namely <code>NewDirectByteBuffer<\/code>. This native method can be used to wrap a long address in a fresh byte buffer instance which is then returned to unsuspecting Java code.<\/p>\n+<p>Memory segments provide a similar capability - that is, given an address (which might have been obtained through some native calls), it is possible to wrap a segment around it, with given spatial, temporal and confinement bounds; a cleanup action to be executed when the segment is closed might also be specified.<\/p>\n+<p>For instance, assuming we have an address pointing at some externally managed memory block, we can construct an <em>unsafe<\/em> segment, as follows:<\/p>\n+<div class=\"sourceCode\" id=\"cb16\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb16-1\" title=\"1\">MemoryAddress addr = MemoryAddress.<span class=\"fu\">ofLong<\/span>(someLongAddr);<\/a>\n+<a class=\"sourceLine\" id=\"cb16-2\" title=\"2\">var unsafeSegment = addr.<span class=\"fu\">asSegmentRestricted<\/span>(<span class=\"dv\">10<\/span>);<\/a><\/code><\/pre><\/div>\n+<p>The above code creates a new confined unsafe segment from a given address; the size of the segment is 10 bytes; the confinement thread is the current thread, and there's no cleanup action associated with the segment (that can be changed as needed by calling <code>MemorySegment::withCleanupAction<\/code>).<\/p>\n+<p>Of course, segments created this way are completely <em>unsafe<\/em>. There is no way for the runtime to verify that the provided address indeed points to a valid memory location, or that the size of the memory region pointed to by <code>addr<\/code> is indeed 10 bytes. Similarly, there are no guarantees that the underlying memory region associated with <code>addr<\/code> will not be deallocated <em>prior<\/em> to the call to <code>MemorySegment::close<\/code>.<\/p>\n+<p>For these reasons, creating unsafe segments is a <em>restricted<\/em> operation in the Foreign Memory Access API. Restricted operations can only be performed if the running application has set a read-only runtime property — <code>foreign.restricted=permit<\/code>. Any attempt to call restricted operations without said runtime property will fail with a runtime exception.<\/p>\n+<p>We plan, in the future, to make access to restricted operations more integrated with the module system; that is, certain modules might <em>require<\/em> restricted native access; when an application which depends on said modules is executed, the user might need to provide <em>permissions<\/em> to said modules to perform restricted native operations, or the runtime will refuse to build the application's module graph.<\/p>\n+<h3 id=\"confinement\">Confinement<\/h3>\n+<p>In addition to spatial and temporal bounds, segments also feature thread-confinement. That is, a segment is <em>owned<\/em> by the thread which created it, and no other thread can access the contents on the segment, or perform certain operations (such as <code>close<\/code>) on it. Thread confinement, while restrictive, is crucial to guarantee optimal memory access performance even in a multi-threaded environment.<\/p>\n+<p>The Foreign Memory Access API provides several ways to relax the thread confinement barriers. First, threads can cooperatively share segments by performing explicit <em>handoff<\/em> operations, where a thread releases its ownership on a given segment and transfers it onto another thread. Consider the following code:<\/p>\n+<div class=\"sourceCode\" id=\"cb17\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb17-1\" title=\"1\">MemorySegment segmentA = MemorySegment.<span class=\"fu\">allocateNative<\/span>(<span class=\"dv\">10<\/span>); <span class=\"co\">\/\/ confined by thread A<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb17-2\" title=\"2\">...<\/a>\n+<a class=\"sourceLine\" id=\"cb17-3\" title=\"3\">var segmentB = segmentA.<span class=\"fu\">handoff<\/span>(threadB); <span class=\"co\">\/\/ confined by thread B<\/span><\/a><\/code><\/pre><\/div>\n+<p>This pattern of access is also known as <em>serial confinement<\/em> and might be useful in producer\/consumer use cases where only one thread at a time needs to access a segment. Note that, to make the handoff operation safe, the API <em>kills<\/em> the original segment (as if <code>close<\/code> was called, but without releasing the underlying memory) and returns a <em>new<\/em> segment with the correct owner. That is, handoff operations are <em>terminal operations<\/em> (like <code>MemorySegment::close<\/code>). The implementation also makes sure that all writes by the first thread are flushed into memory by the time the second thread accesses the segment.<\/p>\n+<p>When serial confinement is not enough, clients can optionally remove thread ownership, that is, turn a confined segment into a <em>shared<\/em> one which can be accessed — and closed — concurrently, by multiple threads<a href=\"#2\"><sup>2<\/sup><\/a>. As before, sharing a segment kills the original segment and returns a new segment with no owner thread:<\/p>\n+<div class=\"sourceCode\" id=\"cb18\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb18-1\" title=\"1\">MemorySegment segmentA = MemorySegment.<span class=\"fu\">allocateNative<\/span>(<span class=\"dv\">10<\/span>); <span class=\"co\">\/\/ confined by thread A<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb18-2\" title=\"2\">...<\/a>\n+<a class=\"sourceLine\" id=\"cb18-3\" title=\"3\">var sharedSegment = segmentA.<span class=\"fu\">share<\/span>() <span class=\"co\">\/\/ shared segment<\/span><\/a><\/code><\/pre><\/div>\n+<p>A shared segments is especially useful when multiple threads need to operate on the segment's contents in <em>parallel<\/em> (e.g. using a framework such as Fork\/Join) — by obtaining a <code>Spliterator<\/code> instance out of a memory segment. For instance to sum all the 32 bit values of a memory segment in parallel, we can use the following code:<\/p>\n+<div class=\"sourceCode\" id=\"cb19\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb19-1\" title=\"1\">SequenceLayout seq = MemoryLayout.<span class=\"fu\">ofSequence<\/span>(<span class=\"dv\">1_000_000<\/span>, MemoryLayouts.<span class=\"fu\">JAVA_INT<\/span>);<\/a>\n+<a class=\"sourceLine\" id=\"cb19-2\" title=\"2\">SequenceLayout seq_bulk = seq.<span class=\"fu\">reshape<\/span>(-<span class=\"dv\">1<\/span>, <span class=\"dv\">100<\/span>);<\/a>\n+<a class=\"sourceLine\" id=\"cb19-3\" title=\"3\">VarHandle intHandle = seq.<span class=\"fu\">varHandle<\/span>(<span class=\"dt\">int<\/span>.<span class=\"fu\">class<\/span>, <span class=\"fu\">sequenceElement<\/span>());    <\/a>\n+<a class=\"sourceLine\" id=\"cb19-4\" title=\"4\"><\/a>\n+<a class=\"sourceLine\" id=\"cb19-5\" title=\"5\"><span class=\"dt\">int<\/span> sum = StreamSupport.<span class=\"fu\">stream<\/span>(MemorySegment.<span class=\"fu\">spliterator<\/span>(segment.<span class=\"fu\">share<\/span>(), seq_bulk), <span class=\"kw\">true<\/span>)<\/a>\n+<a class=\"sourceLine\" id=\"cb19-6\" title=\"6\">                .<span class=\"fu\">mapToInt<\/span>(slice -&gt; {<\/a>\n+<a class=\"sourceLine\" id=\"cb19-7\" title=\"7\">                    <span class=\"dt\">int<\/span> res = <span class=\"dv\">0<\/span>;<\/a>\n+<a class=\"sourceLine\" id=\"cb19-8\" title=\"8\">                    <span class=\"kw\">for<\/span> (<span class=\"dt\">int<\/span> i = <span class=\"dv\">0<\/span>; i &lt; <span class=\"dv\">100<\/span> ; i++) {<\/a>\n+<a class=\"sourceLine\" id=\"cb19-9\" title=\"9\">                        res += MemoryAccess.<span class=\"fu\">getIntAtIndex<\/span>(slice, i);<\/a>\n+<a class=\"sourceLine\" id=\"cb19-10\" title=\"10\">                    }<\/a>\n+<a class=\"sourceLine\" id=\"cb19-11\" title=\"11\">                    <span class=\"kw\">return<\/span> res;<\/a>\n+<a class=\"sourceLine\" id=\"cb19-12\" title=\"12\">                }).<span class=\"fu\">sum<\/span>();<\/a><\/code><\/pre><\/div>\n+<p>The <code>MemorySegment::spliterator<\/code> takes a segment, a <em>sequence<\/em> layout and returns a spliterator instance which splits the segment into chunks which corresponds to the elements in the provided sequence layout. Here, we want to sum elements in an array which contains a million of elements; now, doing a parallel sum where each computation processes <em>exactly<\/em> one element would be inefficient, so instead we use the layout API to derive a <em>bulk<\/em> sequence layout. The bulk layout is a sequence layout which has the same size of the original layouts, but where the elements are arranged into groups of 100 elements — which should make it more amenable to parallel processing.<\/p>\n+<p>Once we have the spliterator, we can use it to construct a parallel stream and sum the contents of the segment in parallel. Since the segment operated upon by the spliterator is shared, the segment can be accessed from multiple threads concurrently; the spliterator API ensures that the access occurs in a regular fashion: a slice is created from the original segment, and given to a thread to perform some computation — thus ensuring that no two threads can ever operate concurrently on the same memory region.<\/p>\n+<p>Shared segment can also be useful to perform serial confinement in cases where the thread handing off the segment does not know which other thread will continue the work on the segment, for instance:<\/p>\n+<div class=\"sourceCode\" id=\"cb20\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb20-1\" title=\"1\"><span class=\"co\">\/\/ thread A<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb20-2\" title=\"2\">MemorySegment segment = MemorySegment.<span class=\"fu\">allocateNative<\/span>(<span class=\"dv\">10<\/span>); <span class=\"co\">\/\/ confined by thread A<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb20-3\" title=\"3\"><span class=\"co\">\/\/do some work<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb20-4\" title=\"4\">segment = segment.<span class=\"fu\">share<\/span>();<\/a>\n+<a class=\"sourceLine\" id=\"cb20-5\" title=\"5\"><\/a>\n+<a class=\"sourceLine\" id=\"cb20-6\" title=\"6\"><span class=\"co\">\/\/ thread B<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb20-7\" title=\"7\">segment.<span class=\"fu\">handoff<\/span>(<span class=\"bu\">Thread<\/span>.<span class=\"fu\">currentThread<\/span>()); <span class=\"co\">\/\/ now confined by thread B<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb20-8\" title=\"8\"><span class=\"co\">\/\/ do some more work<\/span><\/a><\/code><\/pre><\/div>\n+<p>That is, multiple threads can <em>race<\/em> to acquire a given shared segment — the API ensures that only one of them will succeed in acquiring ownership of the shared segment.<\/p>\n+<h3 id=\"implicit-deallocation\">Implicit deallocation<\/h3>\n+<p>While memory segment feature <em>deterministic deallocation<\/em> they can also be registered against a <code>Cleaner<\/code>, to make sure that the memory resources associated with a segment are released when the GC determines that the segment is no longer <em>reachable<\/em>:<\/p>\n+<div class=\"sourceCode\" id=\"cb21\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><a class=\"sourceLine\" id=\"cb21-1\" title=\"1\">MemorySegment segment = MemorySegment.<span class=\"fu\">allocateNative<\/span>(<span class=\"dv\">100<\/span>);<\/a>\n+<a class=\"sourceLine\" id=\"cb21-2\" title=\"2\">Cleaner cleaner = Cleaner.<span class=\"fu\">create<\/span>();<\/a>\n+<a class=\"sourceLine\" id=\"cb21-3\" title=\"3\">segment = segment.<span class=\"fu\">registerCleaner<\/span>(cleaner);<\/a>\n+<a class=\"sourceLine\" id=\"cb21-4\" title=\"4\"><span class=\"co\">\/\/ do some work<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb21-5\" title=\"5\">segment = <span class=\"kw\">null<\/span>; <span class=\"co\">\/\/ Cleaner might reclaim the segment memory now<\/span><\/a><\/code><\/pre><\/div>\n+<p>As for handoff, registering a segment with a cleaner <em>kills<\/em> the current segment and returns a new one which features implicit deallocation; this is also a <em>terminal operation<\/em>. Note that registering a segment with a cleaner doesn't prevent clients from calling <code>MemorySegment::close<\/code> explicitly on the returned segment; the API will guarantee that the segment's cleanup action will be called at most once — either explicitly, or implicitly (by a cleaner). Moreover, since an unreachable segment cannot (by definition) be accessed by any thread, the cleaner can always release any memory resources associated with an unreachable segment, regardless of whether it is a confined, or a shared segment.<\/p>\n+<ul>\n+<li><a id=\"1\"\/>(<sup>1<\/sup>):<small> In general, deriving a complete layout from a C <code>struct<\/code> declaration is no trivial matter, and it's one of those areas where tooling can help greatly.<\/small><\/li>\n+<li><a id=\"2\"\/>(<sup>2<\/sup>):<small> Shared segments rely on VM thread-local handshakes (JEP <a href=\"https:\/\/openjdk.java.net\/jeps\/312\">312<\/a>) to implement lock-free, safe, shared memory access; that is, when it comes to memory access, there should no difference in performance between a shared segment and a confined segment. On the other hand, <code>MemorySegment::close<\/code> might be slower on shared segments than on confined ones.<\/small><\/li>\n+<\/ul>\n+<\/body>\n+<\/html>\n","filename":"doc\/panama_memaccess.html","additions":284,"deletions":0,"binary":false,"changes":284,"status":"added"},{"patch":"@@ -0,0 +1,313 @@\n+## State of foreign memory support\n+\n+**October 2020**\n+\n+* Reflect latest API changes in handoff\/implicit deallocation\n+* Updated section on restricted segments reflecting new, simpler API\n+* Revamped section on confinement to add description of shared segments\n+* Added section on implicit deallocation\n+\n+**Maurizio Cimadamore**\n+\n+A crucial part of any native interop story lies in the ability of accessing off-heap memory in an efficient fashion. Panama achieves this goal through the so called Foreign Memory Access API. This API has been made available as an incubating API in Java [14](https:\/\/openjdk.java.net\/jeps\/370) ad [15](https:\/\/openjdk.java.net\/jeps\/383), and is, to date, the most mature part of the Panama interop story.\n+\n+### Segments\n+\n+Memory segments are abstractions which can be used to model memory regions, located either on- or off- the Java heap. Segments can be allocated from native memory (e.g. like a `malloc`), or can be wrapped around existing memory sources (e.g. a Java array or a `ByteBuffer`). Memory segments provide *strong* guarantees which make memory dereference operation *safe*. More specifically, each segment provides:\n+\n+* *spatial bounds* - that is, a segment has a base address and a size, and accessing a segment outside those boundaries is forbidden\n+* *temporal bounds* - that is, a segment has a _state_ - meaning that it can be used and then _closed_ when the memory backing the segment is no longer needed (note, this might trigger deallocation of said memory)\n+* *thread-confinement*  - that is, a segment is a view over a memory region that is *owned* by the thread which created it. Attempting to dereference  or close a segment outside the confinement thread is forbidden (this is crucial to avoid access vs. close races in multi-threaded scenario)\n+\n+For instance, the following snippet allocates 100 bytes off-heap:\n+\n+```java\n+try (MemorySegment segment = MemorySegment.allocateNative(100)) {\n+    ...\n+} \/\/ frees memory\n+```\n+\n+Since segments are `AutoCloseable` they can be used inside a *try-with-resources* statement, which helps ensure that memory will be released when the segment is no longer needed.\n+\n+Memory segments support *slicing* — that is, given a segment, it is possible to create a new segment whose spatial bounds are stricter than that of the original segment:\n+\n+```java\n+MemorySegment segment = MemorySement.allocateNative(10);\n+MemorySegment slice = segment.asSlice(4, 4);\n+```\n+\n+The above code creates a slice that starts at offset 4 and has a length of 4 bytes. Slices have the *same* temporal bounds as the parent segment - this means that when the parent segment is closed, all the slices derived from it are also closed. The opposite is also true, closing a slice closes the parent segment (and all the other slices derived from it). If a library wants to share a slice, but prevent a client from closing it (could be useful e.g. when implementing a slab allocator), the library could prevent a client from closing the slice by creating a *non-closeable* view:\n+\n+```java\n+MemorySegment sharedSlice = slice.withAccessModes(ALL_ACCESS & ~CLOSE);\n+```\n+\n+Any attempt to call `close` on `sharedSlice` will be met with an exception. Memory segments support various access modes (including those for read\/write access) which can be used to constrain the set of operations available to clients.\n+\n+### Memory access handles\n+\n+Dereferencing memory associated with segments is made possible by using *memory access var handles*. A memory access var handle is a special kind of var handle which takes a memory segment access coordinate, together with a byte offset — the offset, relative to the segment's base address at which the dereference operation should occur. A memory access var handle can be obtained as follows:\n+\n+```java\n+VarHandle intHandle = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder())    \n+```\n+\n+To create a dereference handle we have to specify a carrier type — the type we want to use e.g. to extract values from memory, as well as to whether any byte swapping should be applied when contents are read from or stored to memory. Additionally, the user can supply an extra alignment parameter (not shown here) — this can be useful to impose additional constraints on how memory dereferences should occur; for instance, a client might want to prevent access to misaligned 32 bit values.\n+\n+For instance, to read 10 int values from a segment, we can write the following code:\n+\n+```java\n+MemorySegment segment = ...\n+int[] values = new int[10];\n+for (int i = 0 ; i < values.length ; i++) {\n+    values[i] = (int)intHandle.get(segment, (long)i * 4);\n+}\n+```\n+\n+Memory access var handles (as any other var handle) are *strongly* typed; and to get maximum efficiency, it is generally necessary to introduce casts to make sure that the access coordinates match the expected types — in this case we have to cast `i * 4` into a long; similarly, since the signature polymorphic method `VarHandle::get` notionally returns `Object` a cast is necessary to force the right return type the var handle operation.\n+\n+Note that, since the offset of the dereference operation is expressed in bytes, we have to manually compute the starting offset, by multiplying the logical index `i` by `4` — the size (in bytes) of a Java int value; this is not dissimilar to what happens with the `ByteBuffer` absolute get\/put methods. We shall see later how memory layouts help us achieving higher level, structured access.\n+\n+### Safety\n+\n+The memory access API provides basic safety guarantees for memory dereference operations. More specifically, dereferencing memory should either succeed, or result in a runtime exception - but, crucially, should never result in a VM crash, or, more subtly, in memory corruption occurring *outside* the region of memory associated with a memory segment.\n+\n+To enforce this, strong spatial and temporal checks are enforced upon every access. Consider the following code:\n+\n+```java\n+MemorySegment segment = MemorySegment.allocateNative(10);\n+intHandle.get(segment, 8); \/\/throws ISE\n+```\n+\n+The above code leads to a runtime exception, as we trying to access memory outside the segment's bounds — the access operation starts at offset 8 (which is within bounds), but ends at offset 11 (which is outside bounds).\n+\n+Similarly, attempting to access an already closed segment leads to a failure:\n+\n+```java\n+segment.close();\n+intHandle.get(segment, 0); \/\/throws ISE\n+```\n+\n+This time, the access occurs within the spatial bounds implied by the segment, but when access occurs, the segment has already been *closed*, so the access operation fails. This is crucial to guarantee safety: since memory segments ensure *deterministic deallocation*, the above code might end up attempting to dereference already freed memory.\n+\n+On top of basic spatial and temporal bound guarantees, memory segments also enforce thread-confinement guarantees, which will be discussed in a later [section](#Confinement). Note that, while these checks might seem expensive when considered in isolation, the Foreign Memory Access API is designed and implemented such that the JIT compiler can hoist most, if not all, such checks outside hot loops. Hence, memory access efficiency is not negatively impacted by the safety requirements of the API.\n+\n+### Layouts\n+\n+Expressing byte offsets (as in the [above](#memory-access-handles) example) can lead to code that is hard to read, and very fragile — as memory layout invariants are captured, implicitly, in the constants used to scale offsets. To address this issue, we add a *memory layout* API which allows clients to define memory layouts *programmatically*. For instance, the layout of the array used in the above example can be expressed using the following code:\n+\n+```java\n+MemoryLayout intArray = MemoryLayout.ofSequence(10, MemoryLayout.ofValueBits(32));\n+```\n+\n+That is, our layout is a repetition of 10 elements whose size is 32 bit each. The advantage of defining a memory layout upfront, using an API, is that we can then query on the layout — for instance we can compute the offset of the 3rd element of the array:\n+\n+```java\n+long element3 = intArray.byteOffset(PathElement.sequenceElement(3)); \/\/ 12\n+```\n+\n+To specify which nested layout element should be used for the offset calculation we use a so called *layout path* - that is, a selection expression that navigates the layout, from the *root* layout, down to the leaf layout we wish to select (in this case the 3rd layout element in the sequence).\n+\n+Layouts can also be used to obtain memory access var handles; so we can rewrite the above example as follows:\n+\n+```java\n+MemorySegment segment = ...\n+int[] values = new int[10];\n+VarHandle elemHandle = intArray.varHandle(int.class, PathElement.sequenceElement());\n+for (int i = 0 ; i < values.length ; i++) {\n+    values[i] = (int)elemHandle.get(segment, (long)i);\n+}\n+```\n+\n+In the above, `elemHandle` is a var handle whose type is `int` , which takes two access coordinates:\n+\n+1. a `MemorySegment` instance; the segment whose memory should be dereferenced\n+2. a *logical* index, which is used to select the element of the sequence we want to access\n+\n+In other words, manual offset computation is no longer needed — offsets and strides can in fact be derived from the layout object.\n+\n+Memory layouts shine when structured access is needed — consider the following C declaration:\n+\n+```c\n+typedef struct {\n+\tchar kind;\n+    int value;\n+} TaggedValues[5];\n+```\n+\n+The above C declaration can be modeled using the layout below:\n+\n+```javascript\n+SequenceLayout taggedValues = MemoryLayout.ofSequence(5,\n+    MemoryLayout.ofStruct(\n+        MemoryLayout.ofValueBits(8, ByteOrder.nativeOrder()).withName(\"kind\"),\n+        MemoryLayout.ofPaddingBits(24),\n+        MemoryLayout.ofValueBits(32, ByteOrder.nativeOrder()).withName(\"value\")\n+    )\n+).withName(\"TaggedValues\");\n+```\n+\n+Here we assume that we need to insert some padding after the `kind` field to honor the alignment requirements of the `value` field <a href=\"#1\"><sup>1<\/sup><\/a>. Now, if we had to access the `value` field of all the elements of the array using manual offset computation, the code would quickly become pretty hard to read — on each iteration we would have to remember that the stride of the array is 8 bytes and that the offset of the `value` field relative to the `TaggedValue` struct is 4 bytes. This gives us an access expression like `(i * 8) + 4`, where `i` is the index of the element whose `value` field needs to be accessed.\n+\n+With memory layouts, we can simply compute, once and for all, the memory access var handle to access the `value` field inside the sequence, as follows:\n+\n+```java\n+VarHandle valuesHandle = taggedValues.varHandle(int.class,\n+                                               PathElement.sequenceElement(),\n+                                               PathElement.groupElement(\"value\"));\n+```\n+\n+When using this var handle, no manual offset computation will be required: the resulting `valuesHandle` will feature an additional `long` coordinate which can be used to select  the desired `value` field from the sequence.\n+\n+### Var handle combinators\n+\n+The attentive reader might have noted how rich the var handles returned by the layout API are, compared to the simple memory access var handle we have seen at play [here](#memory-access-handles). How do we go from a simple access var handle that takes a byte offset to a var handle that can dereference a complex layout path? The answer is, by using var handle *combinators*. Developers familiar with the method handle API know how simpler method handles can be combined into more complex ones using the various combinator methods in the `MethodHandles` API. These methods allow, for instance, to insert (or bind) arguments into a target method handle, filter return values, permute arguments and much more.\n+\n+Sadly, none of these features are available when working with var handles. The Foreign Memory Access API rectifies this, by adding a rich set of var handle combinators in the `MemoryHandles` class; with these tools, developers can express var handle transformations such as:\n+\n+* mapping a var handle carrier type into a different one, using an embedding\/projection method handle pairs\n+* filter one or more var handle access coordinates using unary filters\n+* permute var handle access coordinates\n+* bind concrete access coordinates to an existing var handle\n+\n+Without diving too deep, let's consider how we might want to take a basic memory access handle and turn it into a var handle which dereference a segment at a specific offset (again using the `taggedValues` layout defined previously):\n+\n+```java\n+VarHandle intHandle = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder()); \/\/ (MS, J) -> I\n+long offsetOfValue = taggedValues.byteOffset(PathElement.sequenceElement(0),\n+                                             PathElement.groupElement(\"value\"));\n+VarHandle valueHandle = MemoryHandles.insertCoordinates(intHandle, 0, offsetOfValue); \/\/ (MS) -> I\n+```\n+\n+We have been able to derive, from a basic memory access var handle, a new var handle that dereferences a segment at a given fixed offset. It is easy to see how other, richer, var handles obtained using the layout API can be constructed manually using the var handle combinator API.\n+\n+### Segment accessors\n+\n+Building complex memory access var handles using layout paths and the combinator API is useful, especially for structured access. But in simple cases, creating a `VarHandle` just to be able to read an int value at a given segment offset can be perceived as overkill. For this reason, the foreign memory access API provides ready-made static accessors in the `MemoryAccess` class, which allows to dereference a segment in various ways. For instance, if a client wants to read an int value from a segment, one of the following methods can be used:\n+\n+* `MemoryAccess::getInt(MemorySegment)` — reads an int value (4 bytes) starting at the segment's base address\n+* `MemoryAccess::getIntAtOffset(MemorySegment, long)` — reads an int value (4 bytes) starting at the address `A = B + O` where `B` is the segment's base address, and `O` is an offset (in bytes) supplied by the client\n+* `MemoryAccess::getIntAtIndex(MemorySegment, long)` — reads an int value (4 bytes) starting at the address `A = B + (4 * I)` where `B` is the segment's base address, and `I` is a logical index supplied by the client; this accessor is useful for mimicking array access.\n+\n+In other words, at least in simple cases, memory dereference operations can be achieved without the need of going through the `VarHandle` API; of course in more complex cases (structured and\/or multidimensional access, fenced access) the full power of the `VarHandle` API might still come in handy.\n+\n+### Interoperability\n+\n+Memory segments are pretty flexible when it comes to interacting with existing memory sources. For instance it is possible to:\n+\n+* create segment from a Java array\n+* convert a segment into a Java array\n+* create a segment from a byte buffer\n+* convert a segment into a byte buffer\n+\n+For instance, thanks to bi-directional integration with the byte buffer API, it is possible for users to create a memory segment, and then de-reference it using the byte buffer API, as follows:\n+\n+```java\n+MemorySegment segment = ...\n+int[] values = new int[10];\n+ByteBuffer bb = segment.asByteBuffer();\n+for (int i = 0 ; i < values.length ; i++) {\n+    values[i] = bb.getInt();\n+}\n+```\n+\n+The only thing to remember is that, when a byte buffer view is created out of a memory segment, the buffer has the same temporal bound and thread-confinement guarantees as those of the segment it originated from. This means that if the segment is closed, any subsequent attempt to dereference its memory via a (previously obtained) byte buffer view will fail with an exception.\n+\n+### Unsafe segments\n+\n+It is sometimes necessary to create a segment out of an existing memory source, which might be managed by native code. This is the case, for instance, if we want to create a segment out of memory managed by a custom allocator.\n+\n+The ByteBuffer API allows such a move, through a JNI [method](https:\/\/docs.oracle.com\/javase\/8\/docs\/technotes\/guides\/jni\/spec\/functions.html#NewDirectByteBuffer), namely `NewDirectByteBuffer`. This native method can be used to wrap a long address in a fresh byte buffer instance which is then returned to unsuspecting Java code.\n+\n+Memory segments provide a similar capability - that is, given an address (which might have been obtained through some native calls), it is possible to wrap a segment around it, with given spatial, temporal and confinement bounds; a cleanup action to be executed when the segment is closed might also be specified.\n+\n+For instance, assuming we have an address pointing at some externally managed memory block, we can construct an *unsafe* segment, as follows:\n+\n+```java\n+MemoryAddress addr = MemoryAddress.ofLong(someLongAddr);\n+var unsafeSegment = addr.asSegmentRestricted(10);\n+```\n+\n+The above code creates a new confined unsafe segment from a given address; the size of the segment is 10 bytes; the confinement thread is the current thread, and there's no cleanup action associated with the segment (that can be changed as needed by calling `MemorySegment::withCleanupAction`).\n+\n+Of course, segments created this way are completely *unsafe*. There is no way for the runtime to verify that the provided address indeed points to a valid memory location, or that the size of the memory region pointed to by `addr` is indeed 10 bytes. Similarly, there are no guarantees that the underlying memory region associated with `addr` will not be deallocated *prior* to the call to `MemorySegment::close`.\n+\n+For these reasons, creating unsafe segments is a *restricted* operation in the Foreign Memory Access API. Restricted operations can only be performed if the running application has set a read-only runtime property — `foreign.restricted=permit`. Any attempt to call restricted operations without said runtime property will fail with a runtime exception.\n+\n+We plan, in the future, to make access to restricted operations more integrated with the module system; that is, certain modules might *require* restricted native access; when an application which depends on said modules is executed, the user might need to provide *permissions* to said modules to perform restricted native operations, or the runtime will refuse to build the application's module graph.\n+\n+### Confinement\n+\n+In addition to spatial and temporal bounds, segments also feature thread-confinement. That is, a segment is *owned* by the thread which created it, and no other thread can access the contents on the segment, or perform certain operations (such as `close`) on it. Thread confinement, while restrictive, is crucial to guarantee optimal memory access performance even in a multi-threaded environment.\n+\n+The Foreign Memory Access API provides several ways to relax the thread confinement barriers. First, threads can cooperatively share segments by performing explicit *handoff* operations, where a thread releases its ownership on a given segment and transfers it onto another thread. Consider the following code:\n+\n+```java\n+MemorySegment segmentA = MemorySegment.allocateNative(10); \/\/ confined by thread A\n+...\n+var segmentB = segmentA.handoff(threadB); \/\/ confined by thread B\n+```\n+\n+This pattern of access is also known as *serial confinement* and might be useful in producer\/consumer use cases where only one thread at a time needs to access a segment. Note that, to make the handoff operation safe, the API *kills* the original segment (as if `close` was called, but without releasing the underlying memory) and returns a *new* segment with the correct owner. That is, handoff operations are *terminal operations* (like `MemorySegment::close`). The implementation also makes sure that all writes by the first thread are flushed into memory by the time the second thread accesses the segment.\n+\n+When serial confinement is not enough, clients can optionally remove thread ownership, that is, turn a confined segment into a *shared* one which can be accessed — and closed — concurrently, by multiple threads<a href=\"#2\"><sup>2<\/sup><\/a>. As before, sharing a segment kills the original segment and returns a new segment with no owner thread:\n+\n+```java\n+MemorySegment segmentA = MemorySegment.allocateNative(10); \/\/ confined by thread A\n+...\n+var sharedSegment = segmentA.share() \/\/ shared segment\n+```\n+\n+A shared segments is especially useful when multiple threads need to operate on the segment's contents in *parallel* (e.g. using a framework such as Fork\/Join) — by obtaining a `Spliterator` instance out of a memory segment. For instance to sum all the 32 bit values of a memory segment in parallel, we can use the following code:\n+\n+```java\n+SequenceLayout seq = MemoryLayout.ofSequence(1_000_000, MemoryLayouts.JAVA_INT);\n+SequenceLayout seq_bulk = seq.reshape(-1, 100);\n+VarHandle intHandle = seq.varHandle(int.class, sequenceElement());    \n+\n+int sum = StreamSupport.stream(MemorySegment.spliterator(segment.share(), seq_bulk), true)\n+                .mapToInt(slice -> {\n+\t\t\t\t\tint res = 0;\n+        \t\t\tfor (int i = 0; i < 100 ; i++) {\n+            \t\t\tres += MemoryAccess.getIntAtIndex(slice, i);\n+        \t\t\t}\n+        \t\t\treturn res;\n+                }).sum();\n+```\n+\n+The `MemorySegment::spliterator` takes a segment, a *sequence* layout and returns a spliterator instance which splits the segment into chunks which corresponds to the elements in the provided sequence layout. Here, we want to sum elements in an array which contains a million of elements; now, doing a parallel sum where each computation processes *exactly* one element would be inefficient, so instead we use the layout API to derive a *bulk* sequence layout. The bulk layout is a sequence layout which has the same size of the original layouts, but where the elements are arranged into groups of 100 elements — which should make it more amenable to parallel processing.\n+\n+Once we have the spliterator, we can use it to construct a parallel stream and sum the contents of the segment in parallel. Since the segment operated upon by the spliterator is shared, the segment can be accessed from multiple threads concurrently; the spliterator API ensures that the access occurs in a regular fashion: a slice is created from the original segment, and given to a thread to perform some computation — thus ensuring that no two threads can ever operate concurrently on the same memory region.\n+\n+Shared segment can also be useful to perform serial confinement in cases where the thread handing off the segment does not know which other thread will continue the work on the segment, for instance:\n+\n+```java\n+\/\/ thread A\n+MemorySegment segment = MemorySegment.allocateNative(10); \/\/ confined by thread A\n+\/\/do some work\n+segment = segment.share();\n+\n+\/\/ thread B\n+segment.handoff(Thread.currentThread()); \/\/ now confined by thread B\n+\/\/ do some more work\n+```\n+\n+That is, multiple threads can *race* to acquire a given shared segment — the API ensures that only one of them will succeed in acquiring ownership of the shared segment.\n+\n+### Implicit deallocation\n+\n+While memory segment feature *deterministic deallocation* they can also be registered against a `Cleaner`, to make sure that the memory resources associated with a segment are released when the GC determines that the segment is no longer *reachable*:\n+\n+```java\n+MemorySegment segment = MemorySegment.allocateNative(100);\n+Cleaner cleaner = Cleaner.create();\n+segment = segment.registerCleaner(cleaner);\n+\/\/ do some work\n+segment = null; \/\/ Cleaner might reclaim the segment memory now\n+```\n+\n+As for handoff, registering a segment with a cleaner *kills* the current segment and returns a new one which features implicit deallocation; this is also a *terminal operation*. Note that registering a segment with a cleaner doesn't prevent clients from calling `MemorySegment::close` explicitly on the returned segment; the API will guarantee that the segment's cleanup action will be called at most once — either explicitly, or implicitly (by a cleaner). Moreover, since an unreachable segment cannot (by definition) be accessed by any thread, the cleaner can always release any memory resources associated with an unreachable segment, regardless of whether it is a confined, or a shared segment.\n+\n+* <a id=\"1\"\/>(<sup>1<\/sup>):<small> In general, deriving a complete layout from a C `struct` declaration is no trivial matter, and it's one of those areas where tooling can help greatly.<\/small>\n+* <a id=\"2\"\/>(<sup>2<\/sup>):<small> Shared segments rely on VM thread-local handshakes (JEP [312](https:\/\/openjdk.java.net\/jeps\/312)) to implement lock-free, safe, shared memory access; that is, when it comes to memory access, there should no difference in performance between a shared segment and a confined segment. On the other hand, `MemorySegment::close` might be slower on shared segments than on confined ones.<\/small>\n+\n","filename":"doc\/panama_memaccess.md","additions":313,"deletions":0,"binary":false,"changes":313,"status":"added"},{"patch":"@@ -0,0 +1,203 @@\n+#\n+# Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+################################################################################\n+# Setup libclang from llvm project\n+################################################################################\n+AC_DEFUN_ONCE([LIB_SETUP_LIBCLANG],\n+[\n+  AC_ARG_WITH([libclang], [AS_HELP_STRING([--with-libclang=<path to llvm>],\n+      [Specify path of llvm installation containing libclang. Pre-built llvm\n+      binary can be downloaded from http:\/\/llvm.org\/releases\/download.html])])\n+  AC_ARG_WITH([libclang-lib], [AS_HELP_STRING([--with-libclang-lib=<path>],\n+      [Specify where to find libclang binary, so\/dylib\/lib ])])\n+  AC_ARG_WITH([libclang-include], [AS_HELP_STRING([--with-libclang-include=<path>],\n+      [Specify where to find libclang header files, clang-c\/Index.h ])])\n+  AC_ARG_WITH([libclang-include-aux], [AS_HELP_STRING([--with-libclang-include-aux=<path>],\n+      [Specify where to find libclang auxiliary header files, lib\/clang\/<clang-version>\/include\/stddef.h ])])\n+  AC_ARG_WITH([libclang-bin], [AS_HELP_STRING([--with-libclang-bin=<path>],\n+      [Specify where to find clang binary, libclang.dll ])])\n+  AC_ARG_WITH([libclang-version], [AS_HELP_STRING([--with-libclang-version=<version>],\n+      [Specify which libclang version to use ])])\n+\n+  if test \"x$with_libclang\" = \"xno\"; then\n+    AC_MSG_CHECKING([if libclang should be enabled])\n+    AC_MSG_RESULT([no, forced])\n+    ENABLE_LIBCLANG=\"false\"\n+  else\n+    if test \"x$with_libclang\" != \"x\"; then\n+      AC_MSG_CHECKING([if libclang should be enabled])\n+      AC_MSG_RESULT([yes, forced])\n+      ENABLE_LIBCLANG_FORCED=\"true\"\n+    else\n+      ENABLE_LIBCLANG_FORCED=\"false\"\n+    fi\n+    ENABLE_LIBCLANG=\"true\"\n+\n+    AC_MSG_CHECKING([libclang version to be used])\n+    if test \"x$with_libclang_version\" != \"x\"; then\n+      LIBCLANG_VERSION=\"$with_libclang_version\"\n+      AC_MSG_RESULT([$LIBCLANG_VERSION (manually specified)])\n+    else\n+      LIBCLANG_VERSION=\"9\"\n+      AC_MSG_RESULT([$LIBCLANG_VERSION (default)])\n+    fi\n+\n+    if test \"x$with_libclang\" != \"x\" -a \"x$with_libclang\" != \"xyes\"; then\n+      CLANG_LIB_PATH=\"$with_libclang\/lib\"\n+      CLANG_BIN_PATH=\"$with_libclang\/bin\"\n+      CLANG_INCLUDE_PATH=\"$with_libclang\/include\"\n+\n+      AC_MSG_CHECKING([libclang auxiliary include path])\n+      if test \"x$with_libclang_include_aux\" != \"x\"; then\n+        CLANG_INCLUDE_AUX_PATH=\"$with_libclang_include_aux\"\n+        AC_MSG_RESULT([$CLANG_INCLUDE_AUX_PATH])\n+        if test \"x$with_libclang_version\" != \"x\"; then\n+          AC_MSG_WARN([--with-libclang-include-aux was specified. Manually specified value of --with-libclang-version was ignored])\n+        fi        \n+      else \n+        # There may be more than one version of clang matching the specifed version.\n+        # Pick the last one if there are more than one versions.\n+        VER=`$LS $with_libclang\/lib\/clang\/ | $GREP \"^$LIBCLANG_VERSION\" | $TAIL -n1`\n+        if test \"x$VER\" = \"x\"; then\n+          AC_MSG_ERROR([Can not find libclang version matching the specified version: '$LIBCLANG_VERSION' in\n+            $($FIND $with_libclang\/lib\/clang\/ -mindepth 1 -maxdepth 1)])\n+        fi        \n+        CLANG_INCLUDE_AUX_PATH=\"$with_libclang\/lib\/clang\/$VER\/include\"\n+        AC_MSG_RESULT([$CLANG_INCLUDE_AUX_PATH])\n+      fi      \n+    fi\n+\n+    if test \"x$with_libclang_lib\" != \"x\"; then\n+      CLANG_LIB_PATH=\"$with_libclang_lib\"\n+    fi\n+    if test \"x$with_libclang_include\" != \"x\"; then\n+      CLANG_INCLUDE_PATH=\"$with_libclang_include\"\n+    fi\n+    if test \"x$with_libclang_bin\" != \"x\"; then\n+      CLANG_BIN_PATH=\"$with_libclang_bin\"\n+    fi\n+\n+    dnl Only for Windows platform now, as we don't need bin yet for other platform\n+    if test \"x$OPENJDK_TARGET_OS\" = xwindows; then\n+        UTIL_FIXUP_PATH(CLANG_BIN_PATH)\n+    else\n+        CLANG_BIN_PATH=\"\"\n+    fi\n+\n+    UTIL_FIXUP_PATH(CLANG_INCLUDE_PATH)\n+    UTIL_FIXUP_PATH(CLANG_LIB_PATH)\n+    UTIL_FIXUP_PATH(CLANG_INCLUDE_AUX_PATH)\n+\n+    if test \"x$CLANG_INCLUDE_PATH\" != \"x\"; then\n+        LIBCLANG_CPPFLAGS=\"-I$CLANG_INCLUDE_PATH\"\n+    else\n+        LIBCLANG_CPPFLAGS=\"\"\n+    fi\n+\n+    if test \"x$CLANG_LIB_PATH\" != \"x\"; then\n+      if test \"x$TOOLCHAIN_TYPE\" = \"xmicrosoft\"; then\n+        LIBCLANG_LDFLAGS=\"\/LIBPATH:$CLANG_LIB_PATH\"\n+        LIBCLANG_LIBS=\"$CLANG_LIB_PATH\/libclang.lib\"\n+      else\n+        LIBCLANG_LDFLAGS=\"-L$CLANG_LIB_PATH\"\n+        LIBCLANG_LIBS=\"-lclang\"\n+      fi\n+    else\n+        LIBCLANG_LDFLAGS=\"\"\n+    fi\n+\n+    OLD_CPPFLAGS=$CPPFLAGS\n+    OLD_LDFLAGS=$LDFLAGS\n+    OLD_LIBS=$LIBS\n+\n+    CPPFLAGS=\"$LIBCLANG_CPPFLAGS\"\n+    LDFLAGS=\"$LIBCLANG_LDFLAGS\"\n+    LIBS=\"\"\n+\n+    OLD_CXX=$CXX\n+    OLD_CXXCPP=$CXXCPP\n+    CXX=\"$FIXPATH $CXX\"\n+    CXXCPP=\"$FIXPATH $CXXCPP\"\n+\n+    AC_CHECK_HEADER(\"clang-c\/Index.h\", [], [ENABLE_LIBCLANG=\"false\"])\n+    if test \"x$ENABLE_LIBCLANG\" = \"xtrue\"; then\n+      if test \"x$TOOLCHAIN_TYPE\" = \"xmicrosoft\" || test \"x$COMPILE_TYPE\" = \"xcross\"; then\n+        # Just trust the lib is there\n+        LIBS=$LIBCLANG_LIBS\n+      else\n+        AC_CHECK_LIB(clang, clang_getClangVersion, [], [ENABLE_LIBCLANG=\"false\"])\n+      fi\n+    fi\n+\n+    CXX=$OLD_CXX\n+    CXXCPP=$OLD_CXXCPP\n+\n+    if test \"x$ENABLE_LIBCLANG\" = \"xfalse\"; then\n+      if test \"x$ENABLE_LIBCLANG_FORCED\" = \"xtrue\"; then\n+        AC_MSG_ERROR([Cannot locate libclang or headers at the specified locations:\n+            $CLANG_LIB_PATH\n+            $CLANG_INCLUDE_PATH])\n+      else\n+        AC_MSG_CHECKING([if libclang should be enabled])\n+        AC_MSG_RESULT([no, not found])\n+        AC_MSG_ERROR([Cannot locate libclang! You can download pre-built llvm\n+            binary from http:\/\/llvm.org\/releases\/download.html, then specify the\n+            location using --with-libclang])\n+      fi\n+    fi\n+\n+    LIBCLANG_LIBS=\"$LIBS\"\n+\n+    LIBS=\"$OLD_LIBS\"\n+    LDFLAGS=\"$OLD_LDFLAGS\"\n+    CPPFLAGS=\"$OLD_CPPFLAGS\"\n+  fi\n+\n+  if test \"x$ENABLE_LIBCLANG\" = \"xfalse\"; then\n+    CLANG_INCLUDE_PATH=\"\"\n+    CLANG_INCLUDE_AUX_PATH=\"\"\n+    CLANG_LIB_PATH=\"\"\n+    LIBCLANG_CPPFLAGS=\"\"\n+    LIBCLANG_LDFLAGS=\"\"\n+    LIBCLANG_LIBS=\"\"\n+  else\n+    if test \"x$OPENJDK_TARGET_OS\" = xwindows; then\n+      CLANG_LIBNAME=[$CLANG_BIN_PATH][\"\/libclang\"][$SHARED_LIBRARY_SUFFIX]\n+    else\n+      CLANG_LIBNAME=[$CLANG_LIB_PATH\/$LIBRARY_PREFIX][\"clang\"][$SHARED_LIBRARY_SUFFIX]\n+    fi\n+    UTIL_REMOVE_SYMBOLIC_LINKS(CLANG_LIBNAME)\n+  fi\n+\n+  AC_SUBST(ENABLE_LIBCLANG)\n+  AC_SUBST(CLANG_INCLUDE_PATH)\n+  AC_SUBST(CLANG_INCLUDE_AUX_PATH)\n+  AC_SUBST(CLANG_LIB_PATH)\n+  AC_SUBST(CLANG_LIBNAME)\n+  AC_SUBST(LIBCLANG_CPPFLAGS)\n+  AC_SUBST(LIBCLANG_LDFLAGS)\n+  AC_SUBST(LIBCLANG_LIBS)\n+])\n","filename":"make\/autoconf\/lib-clang.m4","additions":203,"deletions":0,"binary":false,"changes":203,"status":"added"},{"patch":"@@ -36,0 +36,1 @@\n+m4_include([lib-clang.m4])\n@@ -108,0 +109,1 @@\n+  LIB_SETUP_LIBCLANG\n","filename":"make\/autoconf\/libraries.m4","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -137,0 +137,9 @@\n+ENABLE_LIBCLANG:=@ENABLE_LIBCLANG@\n+CLANG_LIB_PATH:=@CLANG_LIB_PATH@\n+CLANG_INCLUDE_PATH:=@CLANG_INCLUDE_PATH@\n+CLANG_INCLUDE_AUX_PATH:=@CLANG_INCLUDE_AUX_PATH@\n+CLANG_LIBNAME:=@CLANG_LIBNAME@\n+LIBCLANG_CPPFLAGS:=@LIBCLANG_CPPFLAGS@\n+LIBCLANG_LDFLAGS:=@LIBCLANG_LDFLAGS@\n+LIBCLANG_LIBS:=@LIBCLANG_LIBS@\n+\n@@ -608,0 +617,1 @@\n+SET_JCLANG_LIBRARY_ORIGIN=@SET_JCLANG_LIBRARY_ORIGIN@\n","filename":"make\/autoconf\/spec.gmk.in","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+\tjdk.incubator.jextract \\\n","filename":"make\/conf\/build-module-sets.conf","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+\tjdk.incubator.jextract \\\n","filename":"make\/conf\/docs-modules.conf","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -422,1 +422,1 @@\n-            dependencies: [\"devkit\", \"gtest\", \"graphviz\", \"pandoc\"],\n+            dependencies: [\"devkit\", \"gtest\", \"graphviz\", \"pandoc\", \"libclang\"],\n@@ -441,1 +441,1 @@\n-            dependencies: [\"devkit\", \"gtest\", \"pandoc\"],\n+            dependencies: [\"devkit\", \"gtest\", \"pandoc\", \"libclang\"],\n@@ -453,1 +453,1 @@\n-            dependencies: [\"devkit\", \"gtest\", \"pandoc\"],\n+            dependencies: [\"devkit\", \"gtest\", \"pandoc\", \"libclang\"],\n@@ -722,1 +722,1 @@\n-                \"boot_jdk\", \"devkit\", \"graphviz\", \"pandoc\", buildJdkDep,\n+                \"boot_jdk\", \"devkit\", \"graphviz\", \"pandoc\", buildJdkDep, \"libclang\"\n@@ -1104,0 +1104,7 @@\n+        libclang: {\n+            organization: common.organization,\n+            module: \"libclang-\" + input.build_platform,\n+            ext: \"tar.gz\",\n+            revision: \"9.0.0+\" + (input.build_platform == \"macosx_x64\" ? \"2.0\" : \"1.0\")\n+        },\n+\n","filename":"make\/conf\/jib-profiles.js","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,186 @@\n+#!\/bin\/bash\n+#\n+# Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+# This script generates a libclang bundle. On linux by building it from source\n+# using a devkit, which should match the devkit used to build the JDK. On Macos\n+# prebuilt binaries are downloaded and repackaged. On Windows, the binary LLVM\n+# distribution needs to be downloaded and installed manually first.\n+#\n+# Set MAKE_ARGS to add parameters to make. Ex:\n+#\n+# $ MAKE_ARGS=-j32 bash createLibclangBundle.sh\n+#\n+# The llvm\/clang build is very resource intensive at the end so often needs\n+# to be restarted a few times before it fully succeeds.\n+#\n+# The script tries to behave well on multiple invocations, only performing steps\n+# not already done. To redo a step, manually delete the target files from that\n+# step.\n+\n+LLVM_VERSION=9.0.0\n+\n+BUNDLE_NAME=libclang-$LLVM_VERSION.tar.gz\n+\n+SCRIPT_DIR=\"$(cd \"$(dirname $0)\" > \/dev\/null && pwd)\"\n+OUTPUT_DIR=\"${SCRIPT_DIR}\/..\/..\/build\/libclang\"\n+SRC_DIR=\"$OUTPUT_DIR\/src\"\n+BUILD_DIR=\"$OUTPUT_DIR\/build\"\n+DOWNLOAD_DIR=\"$OUTPUT_DIR\/download\"\n+INSTALL_DIR=\"$OUTPUT_DIR\/install\"\n+IMAGE_DIR=\"$OUTPUT_DIR\/image\"\n+\n+OS_NAME=$(uname -s)\n+case $OS_NAME in\n+  Linux)\n+    USAGE=\"$0 <devkit dir>\"\n+\n+    if [ \"$1\" = \"\" ]; then\n+      echo $USAGE\n+      exit 1\n+    fi\n+    DEVKIT_DIR=\"$1\"\n+\n+    LIB_SUFFIX=.so\n+\n+    # Download source distros\n+    mkdir -p $DOWNLOAD_DIR\n+    cd $DOWNLOAD_DIR\n+    LLVM_FILE=llvm-$LLVM_VERSION.src.tar.xz\n+    if [ ! -f $LLVM_FILE ]; then\n+      wget http:\/\/releases.llvm.org\/$LLVM_VERSION\/$LLVM_FILE\n+    fi\n+    CLANG_FILE=cfe-$LLVM_VERSION.src.tar.xz\n+    if [ ! -f $CLANG_FILE ]; then\n+      wget http:\/\/releases.llvm.org\/$LLVM_VERSION\/$CLANG_FILE\n+    fi\n+\n+\n+    # Unpack src\n+    mkdir -p $SRC_DIR\n+    cd $SRC_DIR\n+    LLVM_DIRNAME=llvm-$LLVM_VERSION.src\n+    LLVM_DIR=$SRC_DIR\/$LLVM_DIRNAME\n+    if [ ! -d $LLVM_DIRNAME ]; then\n+      echo \"Unpacking $LLVM_FILE\"\n+      tar xf $DOWNLOAD_DIR\/$LLVM_FILE\n+    fi\n+    CLANG_DIRNAME=cfe-$LLVM_VERSION.src\n+    CLANG_DIR=$LLVM_DIRNAME\/tools\/$CLANG_DIRNAME\n+    if [ ! -d $CLANG_DIR ]; then\n+      echo \"Unpacking $CLANG_FILE\"\n+      (cd $LLVM_DIR\/tools && tar xf $DOWNLOAD_DIR\/$CLANG_FILE)\n+    fi\n+\n+    # Build\n+    mkdir -p $BUILD_DIR\n+    cd $BUILD_DIR\n+\n+    #init cmake\n+    if [ ! -e cmake ]; then\n+      cmake -G 'Unix Makefiles' \\\n+            -DCMAKE_INSTALL_PREFIX=..\/install \\\n+            -DCMAKE_BUILD_TYPE=Release \\\n+            -DCMAKE_C_COMPILER=$DEVKIT_DIR\/bin\/gcc \\\n+            -DCMAKE_CXX_COMPILER=$DEVKIT_DIR\/bin\/g++ \\\n+            -DCMAKE_C_FLAGS=\"-static-libgcc\" \\\n+            -DCMAKE_CXX_FLAGS=\"-static-libgcc -static-libstdc++\" \\\n+            -DLLVM_ENABLE_TERMINFO=no \\\n+            $LLVM_DIR\n+    fi\n+\n+    # Run with nice to keep system usable during build.\n+    nice make $MAKE_ARGS libclang\n+    nice make $MAKE_ARGS install\n+    ;;\n+  Darwin)\n+    LIB_SUFFIX=\".dylib\"\n+\n+    # Download binaries\n+    mkdir -p $DOWNLOAD_DIR\n+    cd $DOWNLOAD_DIR\n+    LLVM_FILE=clang+llvm-$LLVM_VERSION-x86_64-darwin-apple.tar.xz\n+    if [ ! -f $LLVM_FILE ]; then\n+      echo http:\/\/releases.llvm.org\/$LLVM_VERSION\/$LLVM_FILE\n+      curl -O http:\/\/releases.llvm.org\/$LLVM_VERSION\/$LLVM_FILE\n+    fi\n+\n+    # Extract binaries\n+    cd $OUTPUT_DIR\n+    LLVM_DIRNAME=clang+llvm-$LLVM_VERSION-x86_64-darwin-apple\n+    LLVM_DIR=$OUTPUT_DIR\/$LLVM_DIRNAME\n+    INSTALL_DIR=$LLVM_DIR\n+    if [ ! -d $LLVM_DIRNAME ]; then\n+      echo \"Unpacking $LLVM_FILE\"\n+      tar xf $DOWNLOAD_DIR\/$LLVM_FILE\n+    fi\n+    ;;\n+  CYGWIN*)\n+    if [ \"$1\" = \"\" ]; then\n+      echo \"Download and install http:\/\/releases.llvm.org\/$LLVM_VERSION\/LLVM-$LLVM_VERSION-win64.exe\"\n+      echo \"Then run: $0 <path to install dir>\"\n+      exit 1\n+    fi\n+    INSTALL_DIR=\"$(cygpath -m -s \"$1\")\"\n+    echo \"Copying from $INSTALL_DIR\"\n+    LIB_SUFFIX=\".lib\"\n+\n+    if [ ! -e $IMAGE_DIR\/bin\/libclang.dll ]; then\n+      echo \"Copying libclang.dll to image\"\n+      mkdir -p $IMAGE_DIR\/bin\n+      cp -a $INSTALL_DIR\/bin\/libclang.* $IMAGE_DIR\/bin\/\n+    fi\n+    ;;\n+  *)\n+    echo \" Unsupported OS: $OS_NAME\"\n+    exit 1\n+    ;;\n+esac\n+\n+mkdir -p $IMAGE_DIR\n+# Extract what we need into an image\n+if [ ! -e $IMAGE_DIR\/lib\/libclang$LIB_SUFFIX ]; then\n+  echo \"Copying libclang$LIB_SUFFIX to image\"\n+  mkdir -p $IMAGE_DIR\/lib\n+  cp -a $INSTALL_DIR\/lib\/libclang.* $IMAGE_DIR\/lib\/\n+fi\n+if [ ! -e $IMAGE_DIR\/include\/clang-c ]; then\n+  echo \"Copying include to image\"\n+  mkdir -p $IMAGE_DIR\/include\n+  cp -a $INSTALL_DIR\/include\/. $IMAGE_DIR\/include\/\n+fi\n+if [ ! -e $IMAGE_DIR\/lib\/clang\/$LLVM_VERSION\/include\/stddef.h ]; then\n+  echo \"Copying lib\/clang\/*\/include to image\"\n+  mkdir -p $IMAGE_DIR\/lib\/clang\/$LLVM_VERSION\/include\n+  cp -a $INSTALL_DIR\/lib\/clang\/$LLVM_VERSION\/include\/. \\\n+     $IMAGE_DIR\/lib\/clang\/$LLVM_VERSION\/include\/\n+fi\n+\n+# Create bundle\n+if [ ! -e $OUTPUT_DIR\/$BUNDLE_NAME ]; then\n+  echo \"Creating $OUTPUT_DIR\/$BUNDLE_NAME\"\n+  cd $IMAGE_DIR\n+  tar zcf $OUTPUT_DIR\/$BUNDLE_NAME *\n+fi\n","filename":"make\/devkit\/createLibclangBundle.sh","additions":186,"deletions":0,"binary":false,"changes":186,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+#\n+# Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+include CopyCommon.gmk\n+\n+################################################################################\n+\n+ifeq ($(ENABLE_LIBCLANG), true)\n+\n+  ifeq ($(OPENJDK_BUILD_OS), windows)\n+      LIB_PATH := $(CLANG_LIBNAME)\n+      LINK_MACRO := install-file\n+  else\n+      LIB_PATH := $(CLANG_LIB_PATH)\/$(LIBRARY_PREFIX)clang$(SHARED_LIBRARY_SUFFIX)\n+      LINK_MACRO := link-file-absolute\n+  endif\n+\n+  $(eval $(call SetupCopyFiles, COPY_CLANG_LIB, \\\n+      FILES := $(wildcard $(LIB_PATH)*), \\\n+      DEST := $(SUPPORT_OUTPUTDIR)\/modules_libs\/$(MODULE), \\\n+      MACRO := $(LINK_MACRO), \\\n+  ))\n+\n+  $(eval $(call SetupCopyFiles, COPY_CLANG_HEADERS, \\\n+      DEST := $(CONF_DST_DIR)\/jextract, \\\n+      FILES := $(wildcard $(CLANG_INCLUDE_AUX_PATH)\/*.h), \\\n+  ))\n+\n+  TARGETS := $(COPY_CLANG_LIB) $(COPY_CLANG_HEADERS)\n+\n+endif\n+\n+################################################################################\n","filename":"make\/modules\/jdk.incubator.jextract\/Copy.gmk","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+COPY += .properties .template\n","filename":"make\/modules\/jdk.incubator.jextract\/Java.gmk","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+#\n+# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+include LauncherCommon.gmk\n+\n+$(eval $(call SetupBuildLauncher, jextract,\\\n+    CFLAGS := -DENABLE_ARG_FILES, \\\n+    JAVA_ARGS := -Dforeign.restricted=permit, \\\n+    MAIN_CLASS := jdk.incubator.jextract.JextractTool, \\\n+))\n","filename":"make\/modules\/jdk.incubator.jextract\/Launcher.gmk","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -178,1 +178,2 @@\n-        jdk.jlink;\n+        jdk.jlink,\n+        jdk.incubator.jextract;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,9 @@\n+Files in jdk.internal.clang.libclang package are jextract generated and then modified.\n+jextract was run using \"sh extract.sh\" on Mac OS.\n+\n+Manual modifications:\n+\n+* GNU\/CP copyright header added\n+* Generated C_LONG layouts are replaced with C_LONGLONG for portability\n+* Index_h_1.libName was manually added to handle platform dependency of\n+libclang shared library. \n","filename":"src\/jdk.incubator.jextract\/share\/classes\/README","additions":9,"deletions":0,"binary":false,"changes":9,"status":"added"},{"patch":"@@ -0,0 +1,8 @@\n+jextract --source -t jdk.internal.clang.libclang -lclang \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/ \\\n+  -I ${LIBCLANG_HOME}\/include\/ \\\n+  -I ${LIBCLANG_HOME}\/include\/clang-c \\\n+  --filter ${LIBCLANG_HOME}\/include\/clang-c\/CXString.h \\\n+  --filter ${LIBCLANG_HOME}\/include\/clang-c\/CXErrorCode.h \\\n+  --filter ${LIBCLANG_HOME}\/include\/clang-c\/Index.h \\\n+  ${LIBCLANG_HOME}\/include\/clang-c\/Index.h\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/extract.sh","additions":8,"deletions":0,"binary":false,"changes":8,"status":"added"},{"patch":"@@ -0,0 +1,540 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.incubator.jextract;\n+\n+import java.lang.constant.Constable;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.internal.jextract.impl.DeclarationImpl;\n+\n+\/**\n+ * Instances of this class are used to model declaration elements in the foreign language.\n+ * All declarations have a position (see {@link Position}) and a name. Instances of this class\n+ * support the <em>visitor<\/em> pattern (see {@link Declaration#accept(Visitor, Object)} and\n+ * {@link Visitor}).\n+ *\/\n+public interface Declaration {\n+\n+    \/**\n+     * The position associated with this declaration.\n+     * @return The position associated with this declaration.\n+     *\/\n+    Position pos();\n+\n+    \/**\n+     * The name associated with this declaration.\n+     * @return The name associated with this declaration.\n+     *\/\n+    String name();\n+\n+    \/**\n+     * Get a declaration with specified attribute.\n+     * Set the values to the specified attribute while other attributes remains unchanged. If the specified attribute\n+     * already exist, the new values are replacing the old ones. By not specifying any value, the attribute will become\n+     * empty as {@link #getAttribute(String) getAttribute(name).isEmpty()} will return true.\n+     * @param name The attribute name\n+     * @param values More attribute values\n+     * @return the Declaration with attributes\n+     *\/\n+    Declaration withAttribute(String name, Constable... values);\n+\n+    \/**\n+     * Get a declaration without current attributes\n+     * @return the Declatation without any attributes\n+     *\/\n+    Declaration stripAttributes();\n+\n+    \/**\n+     * The values of the specified attribute.\n+     * @param name The attribute to retrieve\n+     * @return The list of values associate with this attribute\n+     *\/\n+    Optional<List<Constable>> getAttribute(String name);\n+\n+    \/**\n+     * The attributes associated with this declaration\n+     * @return The attributes associated with this declaration\n+     *\/\n+    Set<String> attributeNames();\n+\n+    \/**\n+     * Entry point for visiting declaration instances.\n+     * @param visitor the declaration visitor.\n+     * @param data optional data to be passed to the visitor.\n+     * @param <R> the visitor's return type.\n+     * @param <D> the visitor's argument type.\n+     * @return the result of visiting this declaration through the specified declaration visitor.\n+     *\/\n+    <R,D> R accept(Visitor<R, D> visitor, D data);\n+\n+    \/**\n+     * Compares the specified object with this Declaration for equality.  Returns\n+     * {@code true} if and only if the specified object is also a Declaration and both\n+     * the declarations are <i>equal<\/i>.\n+     *\n+     * @param o the object to be compared for equality with this Declaration\n+     * @return {@code true} if the specified object is equal to this Declaration\n+     *\/\n+    boolean equals(Object o);\n+\n+    \/**\n+     * Returns the hash code value for this Declaration.\n+     *\n+     * @return the hash code value for this Declaration.\n+     *\/\n+    int hashCode();\n+\n+    \/**\n+     * A function declaration.\n+     *\/\n+    interface Function extends Declaration {\n+        \/**\n+         * The parameters associated with this function declaration.\n+         * @return The parameters associated with this function declaration.\n+         *\/\n+        List<Variable> parameters();\n+\n+        \/**\n+         * The foreign type associated with this function declaration.\n+         * @return The foreign type associated with this function declaration.\n+         *\/\n+        Type.Function type();\n+    }\n+\n+    \/**\n+     * A scoped declaration is a container for one or more nested declarations. This declaration can be used to model\n+     * several constructs in the foreign languages, such as (but not limited to) structs, unions and structs (see also\n+     * {@link Scoped.Kind}).\n+     *\/\n+    interface Scoped extends Declaration {\n+\n+        \/**\n+         * The scoped declaration kind.\n+         *\/\n+        enum Kind {\n+            \/**\n+             * Namespace declaration.\n+             *\/\n+            NAMESPACE,\n+            \/**\n+             * Class declaration.\n+             *\/\n+            CLASS,\n+            \/**\n+             * Enum declaration.\n+             *\/\n+            ENUM,\n+            \/**\n+             * Struct declaration.\n+             *\/\n+            STRUCT,\n+            \/**\n+             * Union declaration.\n+             *\/\n+            UNION,\n+            \/**\n+             * Bitfields declaration.\n+             *\/\n+            BITFIELDS,\n+            \/**\n+             * Toplevel declaration.\n+             *\/\n+            TOPLEVEL;\n+        }\n+\n+        \/**\n+         * The member declarations associated with this scoped declaration.\n+         * @return The member declarations associated with this scoped declaration.\n+         *\/\n+        List<Declaration> members();\n+\n+        \/**\n+         * The (optional) layout associated with this scoped declaration.\n+         * @return The (optional) layout associated with this scoped declaration.\n+         *\n+         * @implSpec a layout is present if the scoped declaration kind is one of {@link Kind#STRUCT}, {@link Kind#UNION},\n+         * {@link Kind#ENUM}, {@link Kind#BITFIELDS}, {@link Kind#CLASS} <em>and<\/em> if this declaration models an entity in the foreign\n+         * language that is associated with a <em>definition<\/em>.\n+         *\/\n+        Optional<MemoryLayout> layout();\n+\n+        \/**\n+         * The scoped declaration kind.\n+         * @return The scoped declaration kind.\n+         *\/\n+        Kind kind();\n+    }\n+\n+    \/**\n+     * A typedef declaration\n+     *\/\n+    interface Typedef extends Declaration {\n+        \/**\n+         * The canonical type associated with this typedef declaration.\n+         * @return The canonical type associated with this typedef declaration.\n+         *\/\n+        Type type();\n+    }\n+\n+    \/**\n+     * A variable declaration.\n+     *\/\n+    interface Variable extends Declaration {\n+        \/**\n+         * The variable declaration kind.\n+         *\/\n+        enum Kind {\n+            \/**\n+             * Global variable declaration.\n+             *\/\n+            GLOBAL,\n+            \/**\n+             * Field declaration.\n+             *\/\n+            FIELD,\n+            \/**\n+             * Bitfield declaration.\n+             *\/\n+            BITFIELD,\n+            \/**\n+             * Function parameter declaration.\n+             *\/\n+            PARAMETER;\n+        }\n+\n+        \/**\n+         * The type associated with this variable declaration.\n+         * @return The type associated with this variable declaration.\n+         *\/\n+        Type type();\n+\n+        \/**\n+         * The optional layout associated with this variable declaration.\n+         * @return The optional layout associated with this variable declaration.\n+         *\/\n+        Optional<MemoryLayout> layout();\n+\n+        \/**\n+         * The kind associated with this variable declaration.\n+         * @return The kind associated with this variable declaration.\n+         *\/\n+        Kind kind();\n+    }\n+\n+    \/**\n+     * A constant value declaration.\n+     *\/\n+    interface Constant extends Declaration {\n+        \/**\n+         * The value associated with this constant declaration.\n+         * @return The value associated with this constant declaration.\n+         *\/\n+        Object value();\n+\n+        \/**\n+         * The type associated with this constant declaration.\n+         * @return The type associated with this constant declaration.\n+         *\/\n+        Type type();\n+    }\n+\n+    \/**\n+     * Declaration visitor interface.\n+     * @param <R> the visitor's return type.\n+     * @param <P> the visitor's parameter type.\n+     *\/\n+    interface Visitor<R,P> {\n+        \/**\n+         * Visit a scoped declaration.\n+         * @param d the scoped declaration.\n+         * @param p the visitor parameter.\n+         * @return the result of visiting the given scoped declaration through this visitor object.\n+         *\/\n+        default R visitScoped(Scoped d, P p) { return visitDeclaration(d, p); }\n+\n+        \/**\n+         * Visit a function declaration.\n+         * @param d the function declaration.\n+         * @param p the visitor parameter.\n+         * @return the result of visiting the given function declaration through this visitor object.\n+         *\/\n+        default R visitFunction(Function d, P p) { return visitDeclaration(d, p); }\n+\n+        \/**\n+         * Visit a variable declaration.\n+         * @param d the variable declaration.\n+         * @param p the visitor parameter.\n+         * @return the result of visiting the given variable declaration through this visitor object.\n+         *\/\n+        default R visitVariable(Variable d, P p) { return visitDeclaration(d, p); }\n+\n+        \/**\n+         * Visit a constant declaration.\n+         * @param d the constant declaration.\n+         * @param p the visitor parameter.\n+         * @return the result of visiting the given constant declaration through this visitor object.\n+         *\/\n+        default R visitConstant(Constant d, P p) { return visitDeclaration(d, p); }\n+\n+        \/**\n+         * Visit a typedef declaration.\n+         * @param d the typedef declaration.\n+         * @param p the visitor parameter.\n+         * @return the result of visiting the given typedef declaration through this visitor object.\n+         *\/\n+        default R visitTypedef(Typedef d, P p) { return visitDeclaration(d, p); }\n+\n+        \/**\n+         * Visit a declaration.\n+         * @param d the declaration.\n+         * @param p the visitor parameter.\n+         * @return the result of visiting the given declaration through this visitor object.\n+         *\/\n+        default R visitDeclaration(Declaration d, P p) { throw new UnsupportedOperationException(); }\n+    }\n+\n+    \/**\n+     * Creates a new constant declaration with given name and type.\n+     * @param pos the constant declaration position.\n+     * @param name the constant declaration name.\n+     * @param value the constant declaration value.\n+     * @param type the constant declaration type.\n+     * @return a new constant declaration with given name and type.\n+     *\/\n+    static Declaration.Constant constant(Position pos, String name, Object value, Type type) {\n+        return new DeclarationImpl.ConstantImpl(type, value, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new global variable declaration with given name and type.\n+     * @param pos the global variable declaration position.\n+     * @param name the global variable declaration name.\n+     * @param type the global variable declaration type.\n+     * @return a new global variable declaration with given name and type.\n+     *\/\n+    static Declaration.Variable globalVariable(Position pos, String name, Type type) {\n+        return new DeclarationImpl.VariableImpl(type, Declaration.Variable.Kind.GLOBAL, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new field declaration with given name and type.\n+     * @param pos the field declaration position.\n+     * @param name the field declaration name.\n+     * @param type the field declaration type.\n+     * @return a new field declaration with given name and type.\n+     *\/\n+    static Declaration.Variable field(Position pos, String name, Type type) {\n+        return new DeclarationImpl.VariableImpl(type, Declaration.Variable.Kind.FIELD, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new bitfield declaration with given name, type and layout.\n+     * @param pos the bitfield declaration position.\n+     * @param name the bitfield declaration name.\n+     * @param type the bitfield declaration type.\n+     * @param layout the bitfield declaration layout.\n+     * @return a new bitfield declaration with given name, type and layout.\n+     *\/\n+    static Declaration.Variable bitfield(Position pos, String name, Type type, MemoryLayout layout) {\n+        return new DeclarationImpl.VariableImpl(type, layout, Declaration.Variable.Kind.BITFIELD, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new parameter declaration with given name and type.\n+     * @param pos the parameter declaration position.\n+     * @param name the parameter declaration name.\n+     * @param type the parameter declaration type.\n+     * @return a new parameter declaration with given name and type.\n+     *\/\n+    static Declaration.Variable parameter(Position pos, String name, Type type) {\n+        return new DeclarationImpl.VariableImpl(type, Declaration.Variable.Kind.PARAMETER, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new toplevel declaration with given member declarations.\n+     * @param pos the toplevel declaration position.\n+     * @param decls the toplevel declaration member declarations.\n+     * @return a new toplevel declaration with given member declarations.\n+     *\/\n+    static Declaration.Scoped toplevel(Position pos, Declaration... decls) {\n+        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.TOPLEVEL, declList, \"<toplevel>\", pos);\n+    }\n+\n+    \/**\n+     * Creates a new namespace declaration with given name and member declarations.\n+     * @param pos the namespace declaration position.\n+     * @param name the namespace declaration name.\n+     * @param decls the namespace declaration member declarations.\n+     * @return a new namespace declaration with given name and member declarations.\n+     *\/\n+    static Declaration.Scoped namespace(Position pos, String name, Declaration... decls) {\n+        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.NAMESPACE, declList, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new bitfields group declaration with given name and layout.\n+     * @param pos the bitfields group declaration position.\n+     * @param name the bitfields group declaration name.\n+     * @param layout the bitfields group declaration layout.\n+     * @param bitfields the bitfields group member declarations.\n+     * @return a new bitfields group declaration with given name and layout.\n+     *\/\n+    static Declaration.Scoped bitfields(Position pos, String name, MemoryLayout layout, Declaration.Variable... bitfields) {\n+        List<Declaration> declList = Stream.of(bitfields).collect(Collectors.toList());\n+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.BITFIELDS, layout, declList, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new struct declaration with given name and member declarations.\n+     * @param pos the struct declaration position.\n+     * @param name the struct declaration name.\n+     * @param decls the struct declaration member declarations.\n+     * @return a new struct declaration with given name, layout and member declarations.\n+     *\/\n+    static Declaration.Scoped struct(Position pos, String name, Declaration... decls) {\n+        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.STRUCT, declList, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new struct declaration with given name, layout and member declarations.\n+     * @param pos the struct declaration position.\n+     * @param name the struct declaration name.\n+     * @param layout the struct declaration layout.\n+     * @param decls the struct declaration member declarations.\n+     * @return a new struct declaration with given name, layout and member declarations.\n+     *\/\n+    static Declaration.Scoped struct(Position pos, String name, MemoryLayout layout, Declaration... decls) {\n+        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.STRUCT, layout, declList, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new union declaration with given name and member declarations.\n+     * @param pos the union declaration position.\n+     * @param name the union declaration name.\n+     * @param decls the union declaration member declarations.\n+     * @return a new union declaration with given name and member declarations.\n+     *\/\n+    static Declaration.Scoped union(Position pos, String name, Declaration... decls) {\n+        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        return new DeclarationImpl.ScopedImpl(Scoped.Kind.UNION, declList, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new union declaration with given name, layout and member declarations.\n+     * @param pos the union declaration position.\n+     * @param name the union declaration name.\n+     * @param layout the union declaration layout.\n+     * @param decls the union declaration member declarations.\n+     * @return a new union declaration with given name, layout and member declarations.\n+     *\/\n+    static Declaration.Scoped union(Position pos, String name, MemoryLayout layout, Declaration... decls) {\n+        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.UNION, layout, declList, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new class declaration with given name and member declarations.\n+     * @param pos the class declaration position.\n+     * @param name the class declaration name.\n+     * @param decls the class declaration member declarations.\n+     * @return a new class declaration with given name and member declarations.\n+     *\/\n+    static Declaration.Scoped class_(Position pos, String name, Declaration... decls) {\n+        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.CLASS, declList, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new class declaration with given name, layout and member declarations.\n+     * @param pos the class declaration position.\n+     * @param name the class declaration name.\n+     * @param layout the class declaration layout.\n+     * @param decls the class declaration member declarations.\n+     * @return a new class declaration with given name, layout and member declarations.\n+     *\/\n+    static Declaration.Scoped class_(Position pos, String name, MemoryLayout layout, Declaration... decls) {\n+        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.CLASS, layout, declList, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new enum declaration with given name and member declarations.\n+     * @param pos the enum declaration position.\n+     * @param name the enum declaration name.\n+     * @param decls the enum declaration member declarations.\n+     * @return a new enum declaration with given name, layout and member declarations.\n+     *\/\n+    static Declaration.Scoped enum_(Position pos, String name, Declaration... decls) {\n+        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.ENUM, declList, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new enum declaration with given name, layout and member declarations.\n+     * @param pos the enum declaration position.\n+     * @param name the enum declaration name.\n+     * @param layout the enum declaration layout.\n+     * @param decls the enum declaration member declarations.\n+     * @return a new enum declaration with given name, layout and member declarations.\n+     *\/\n+    static Declaration.Scoped enum_(Position pos, String name, MemoryLayout layout, Declaration... decls) {\n+        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.ENUM, layout, declList, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new function declaration with given name, type and parameter declarations.\n+     * @param pos the function declaration position.\n+     * @param name the function declaration name.\n+     * @param type the function declaration type.\n+     * @param params the function declaration parameter declarations.\n+     * @return a new function declaration with given name, type and parameter declarations.\n+     *\/\n+    static Declaration.Function function(Position pos, String name, Type.Function type, Declaration.Variable... params) {\n+        List<Variable> paramList = Stream.of(params).collect(Collectors.toList());\n+        return new DeclarationImpl.FunctionImpl(type, paramList, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new typedef declaration with given name and declared type.\n+     * @param pos the typedef declaration position.\n+     * @param name the typedef declaration name.\n+     * @param type the typedef type\n+     * @return a new type declaration with given name and declared type.\n+     *\/\n+    static Declaration.Typedef typedef(Position pos, String name, Type type) {\n+        return new DeclarationImpl.TypedefImpl(type, name, pos, null);\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/incubator\/jextract\/Declaration.java","additions":540,"deletions":0,"binary":false,"changes":540,"status":"added"},{"patch":"@@ -0,0 +1,319 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.incubator.jextract;\n+\n+import jdk.internal.jextract.impl.ClangException;\n+import jdk.internal.jextract.impl.Filter;\n+import jdk.internal.jextract.impl.OutputFactory;\n+import jdk.internal.jextract.impl.Parser;\n+import jdk.internal.jextract.impl.Options;\n+import jdk.internal.jextract.impl.Writer;\n+import jdk.internal.joptsimple.OptionException;\n+import jdk.internal.joptsimple.OptionParser;\n+import jdk.internal.joptsimple.OptionSet;\n+\n+import javax.tools.JavaFileObject;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.text.MessageFormat;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.ResourceBundle;\n+import java.util.spi.ToolProvider;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Simple extraction tool which generates a minimal Java API. Such an API consists mainly of static methods,\n+ * where for each native function a static method is added which calls the underlying native method handles.\n+ * Similarly, for struct fields and global variables, static accessors (getter and setter) are generated\n+ * on top of the underlying memory access var handles. For each struct, a static layout field is generated.\n+ *\/\n+public final class JextractTool {\n+    private static final String MESSAGES_RESOURCE = \"jdk.internal.jextract.impl.resources.Messages\";\n+\n+    private static final ResourceBundle MESSAGES_BUNDLE;\n+    static {\n+        MESSAGES_BUNDLE = ResourceBundle.getBundle(MESSAGES_RESOURCE, Locale.getDefault());\n+    }\n+\n+    public static final boolean DEBUG = Boolean.getBoolean(\"jextract.debug\");\n+\n+    \/\/ error codes\n+    private static final int SUCCESS       = 0;\n+    private static final int OPTION_ERROR  = 1;\n+    private static final int INPUT_ERROR   = 2;\n+    private static final int CLANG_ERROR   = 3;\n+    private static final int RUNTIME_ERROR = 4;\n+    private static final int OUTPUT_ERROR  = 5;\n+\n+    private final PrintWriter out;\n+    private final PrintWriter err;\n+\n+    private static String format(String msgId, Object... args) {\n+        return new MessageFormat(MESSAGES_BUNDLE.getString(msgId)).format(args);\n+    }\n+\n+    private JextractTool(PrintWriter out, PrintWriter err) {\n+        this.out = out;\n+        this.err = err;\n+    }\n+\n+    private static Path generateTmpSource(List<Path> headers) {\n+        assert headers.size() > 1;\n+        try {\n+            Path tmpFile = Files.createTempFile(\"jextract\", \".h\");\n+            tmpFile.toFile().deleteOnExit();\n+            Files.write(tmpFile, headers.stream().\n+                    map(src -> \"#include \\\"\" + src + \"\\\"\").\n+                    collect(Collectors.toList()));\n+            return tmpFile;\n+        } catch (IOException ioExp) {\n+            throw new UncheckedIOException(ioExp);\n+        }\n+    }\n+\n+    \/**\n+     * Parse input files into a toplevel declaration with given options.\n+     * @param parserOptions options to be passed to the parser.\n+     * @return a toplevel declaration.\n+     *\/\n+    public static Declaration.Scoped parse(List<Path> headers, String... parserOptions) {\n+        Path source = headers.size() > 1? generateTmpSource(headers) : headers.iterator().next();\n+        return new Parser().parse(source, Stream.of(parserOptions).collect(Collectors.toList()));\n+    }\n+\n+    public static Declaration.Scoped filter(Declaration.Scoped decl, String... includedNames) {\n+        return Filter.filter(decl, includedNames);\n+    }\n+\n+    public static List<JavaFileObject> generate(Declaration.Scoped decl, String headerName,\n+                                                String targetPkg, List<String> libNames) {\n+        return List.of(OutputFactory.generateWrapped(decl, headerName, targetPkg, libNames));\n+    }\n+\n+    \/**\n+     * Write resulting {@link JavaFileObject} instances into specified destination path.\n+     * @param dest the destination path.\n+     * @param compileSources whether to compile .java sources or not\n+     * @param files the {@link JavaFileObject} instances to be written.\n+     *\/\n+    public static void write(Path dest, boolean compileSources, List<JavaFileObject> files) throws UncheckedIOException {\n+        try {\n+            new Writer(dest, files).writeAll(compileSources);\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n+    }\n+\n+    private int printHelp(OptionParser parser, int exitCode) {\n+        try {\n+            parser.printHelpOn(err);\n+        } catch (IOException ignored) {}\n+        return exitCode;\n+    }\n+\n+    \/**\n+     * Main entry point to run the JextractTool\n+     *\n+     * @param args command line options passed\n+     *\/\n+    public static void main(String[] args) {\n+        if (args.length == 0) {\n+            System.err.println(\"Expected a header file\");\n+            return;\n+        }\n+\n+        JextractTool m = new JextractTool(new PrintWriter(System.out, true), new PrintWriter(System.err, true));\n+        System.exit(m.run(args));\n+    }\n+\n+    private int run(String[] args) {\n+        OptionParser parser = new OptionParser(false);\n+        parser.accepts(\"C\", format(\"help.C\")).withRequiredArg();\n+        parser.accepts(\"I\", format(\"help.I\")).withRequiredArg();\n+        parser.accepts(\"d\", format(\"help.d\")).withRequiredArg();\n+        parser.accepts(\"filter\", format(\"help.filter\")).withRequiredArg();\n+        parser.accepts(\"l\", format(\"help.l\")).withRequiredArg();\n+        parser.accepts(\"source\", format(\"help.source\"));\n+        parser.acceptsAll(List.of(\"t\", \"target-package\"), format(\"help.t\")).withRequiredArg();\n+        parser.acceptsAll(List.of(\"?\", \"h\", \"help\"), format(\"help.h\")).forHelp();\n+        parser.nonOptions(format(\"help.non.option\"));\n+\n+        OptionSet optionSet;\n+        try {\n+            optionSet = parser.parse(args);\n+        } catch (OptionException oe) {\n+            return printHelp(parser, OPTION_ERROR);\n+        }\n+\n+        if (optionSet.has(\"h\")) {\n+            return printHelp(parser, SUCCESS);\n+        }\n+\n+        if (optionSet.nonOptionArguments().size() != 1) {\n+            return printHelp(parser, OPTION_ERROR);\n+        }\n+\n+        Options.Builder builder = Options.builder();\n+        if (optionSet.has(\"I\")) {\n+            optionSet.valuesOf(\"I\").forEach(p -> builder.addClangArg(\"-I\" + p));\n+        }\n+\n+        Path builtinInc = Paths.get(System.getProperty(\"java.home\"), \"conf\", \"jextract\");\n+        builder.addClangArg(\"-I\" + builtinInc);\n+\n+        if (optionSet.has(\"C\")) {\n+            optionSet.valuesOf(\"C\").forEach(p -> builder.addClangArg((String) p));\n+        }\n+\n+        if (optionSet.has(\"filter\")) {\n+            optionSet.valuesOf(\"filter\").forEach(p -> builder.addFilter((String) p));\n+        }\n+\n+        if (optionSet.has(\"d\")) {\n+            builder.setOutputDir(optionSet.valueOf(\"d\").toString());\n+        }\n+\n+        if (optionSet.has(\"source\")) {\n+            builder.setGenerateSource();\n+        }\n+        boolean librariesSpecified = optionSet.has(\"l\");\n+        if (librariesSpecified) {\n+            for (Object arg : optionSet.valuesOf(\"l\")) {\n+                String lib = (String)arg;\n+                if (lib.indexOf(File.separatorChar) == -1) {\n+                    builder.addLibraryName(lib);\n+                } else {\n+                    Path libPath = Paths.get(lib);\n+                    if (libPath.isAbsolute() && Files.isRegularFile(libPath)) {\n+                        builder.addLibraryName(lib);\n+                    } else {\n+                        err.println(format(\"l.option.value.invalid\", lib));\n+                        return OPTION_ERROR;\n+                    }\n+                }\n+            }\n+        }\n+\n+        String targetPackage = optionSet.has(\"t\") ? (String) optionSet.valueOf(\"t\") : \"\";\n+        builder.setTargetPackage(targetPackage);\n+\n+        Options options = builder.build();\n+\n+        Path header = Paths.get(optionSet.nonOptionArguments().get(0).toString());\n+        if (!Files.isReadable(header)) {\n+            err.println(format(\"cannot.read.header.file\", header));\n+            return INPUT_ERROR;\n+        }\n+        if (!(Files.isRegularFile(header))) {\n+            err.println(format(\"not.a.file\", header));\n+            return INPUT_ERROR;\n+        }\n+\n+        List<JavaFileObject> files = null;\n+        try {\n+            Declaration.Scoped toplevel = parse(List.of(header), options.clangArgs.toArray(new String[0]));\n+\n+            \/\/filter\n+            if (!options.filters.isEmpty()) {\n+                toplevel = filter(toplevel, options.filters.toArray(new String[0]));\n+            }\n+\n+            if (JextractTool.DEBUG) {\n+                System.out.println(toplevel);\n+            }\n+\n+            files = generate(\n+                toplevel, header.getFileName().toString(),\n+                options.targetPackage, options.libraryNames);\n+        } catch (ClangException ce) {\n+            err.println(ce.getMessage());\n+            if (JextractTool.DEBUG) {\n+                ce.printStackTrace(err);\n+            }\n+            return CLANG_ERROR;\n+        } catch (RuntimeException re) {\n+            err.println(re.getMessage());\n+            if (JextractTool.DEBUG) {\n+                re.printStackTrace(err);\n+            }\n+            return RUNTIME_ERROR;\n+        }\n+\n+        try {\n+            Path output = Path.of(options.outputDir);\n+            write(output, !options.source, files);\n+        } catch (UncheckedIOException uioe) {\n+            err.println(uioe.getMessage());\n+            if (JextractTool.DEBUG) {\n+                uioe.printStackTrace(err);\n+            }\n+            return OUTPUT_ERROR;\n+        } catch (RuntimeException re) {\n+            err.println(re.getMessage());\n+            if (JextractTool.DEBUG) {\n+                re.printStackTrace(err);\n+            }\n+            return RUNTIME_ERROR;\n+        }\n+\n+        return SUCCESS;\n+    }\n+\n+    \/**\n+     * ToolProvider implementation for jextract tool.\n+     *\/\n+    public static class JextractToolProvider implements ToolProvider {\n+        public JextractToolProvider() {}\n+\n+        @Override\n+        public String name() {\n+            return \"jextract\";\n+        }\n+\n+        @Override\n+        public int run(PrintWriter out, PrintWriter err, String... args) {\n+            \/\/ defensive check to throw security exception early.\n+            \/\/ Note that the successful run of jextract under security\n+            \/\/ manager would require far more permissions like loading\n+            \/\/ library (clang), file system access etc.\n+            if (System.getSecurityManager() != null) {\n+                System.getSecurityManager().\n+                    checkPermission(new RuntimePermission(\"jextract\"));\n+            }\n+\n+            JextractTool instance = new JextractTool(out, err);\n+            return instance.run(args);\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/incubator\/jextract\/JextractTool.java","additions":319,"deletions":0,"binary":false,"changes":319,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.incubator.jextract;\n+\n+import java.nio.file.Path;\n+\n+\/**\n+ * Instances of this class model are used to model source code positions.\n+ *\/\n+public interface Position {\n+\n+    \/**\n+     * The input file to which this position refers to.\n+     * @return The input file to which this position refers to.\n+     *\/\n+    Path path();\n+\n+    \/**\n+     * The line number associated with this position.\n+     * @return The line number associated with this position.\n+     *\/\n+    int line();\n+\n+    \/**\n+     * The column number associated with this position.\n+     * @return The column number associated with this position.\n+     *\/\n+    int col();\n+\n+    \/**\n+     * An empty position instance; this can be used to model <em>synthetic<\/em> program elements which are not\n+     * defined in any input file.\n+     *\/\n+    Position NO_POSITION = new Position() {\n+        @Override\n+        public Path path() {\n+            return null;\n+        }\n+\n+        @Override\n+        public int line() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public int col() {\n+            return 0;\n+        }\n+    };\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/incubator\/jextract\/Position.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,514 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.incubator.jextract;\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.internal.jextract.impl.LayoutUtils;\n+import jdk.internal.jextract.impl.TypeImpl;\n+import jdk.internal.jextract.impl.UnsupportedLayouts;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.OptionalLong;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Instances of this class are used to model types in the foreign language.\n+ * Instances of this class support the <em>visitor<\/em> pattern (see {@link Type#accept(Type.Visitor, Object)} and\n+ * {@link Type.Visitor}).\n+ *\/\n+public interface Type {\n+\n+    \/**\n+     * Is this type the erroneous type?\n+     * @return true, if this type is the erroneous type.\n+     *\/\n+    boolean isErroneous();\n+\n+    \/**\n+     * Entry point for visiting type instances.\n+     * @param visitor the type visitor.\n+     * @param data optional data to be passed to the visitor.\n+     * @param <R> the visitor's return type.\n+     * @param <D> the visitor's argument type.\n+     * @return the result of visiting this type through the specified type visitor.\n+     *\/\n+    <R,D> R accept(Visitor<R, D> visitor, D data);\n+\n+    \/**\n+     * Compares the specified object with this Type for equality.  Returns\n+     * {@code true} if and only if the specified object is also a Type and both\n+     * the Types are <i>equal<\/i>.\n+     *\n+     * @param o the object to be compared for equality with this Type\n+     * @return {@code true} if the specified object is equal to this Type\n+     *\/\n+    boolean equals(Object o);\n+\n+    \/**\n+     * Returns the hash code value for this Type.\n+     *\n+     * @return the hash code value for this Type.\n+     *\/\n+    int hashCode();\n+\n+    \/**\n+     * A primitive type.\n+     *\/\n+    interface Primitive extends Type {\n+\n+        \/**\n+         * The primitive type kind.\n+         *\/\n+        enum Kind {\n+            \/**\n+             * {@code void} type.\n+             *\/\n+            Void(\"void\", null),\n+            \/**\n+             * {@code Bool} type.\n+             *\/\n+            Bool(\"_Bool\", CLinker.C_CHAR),\n+            \/**\n+             * {@code char} type.\n+             *\/\n+            Char(\"char\", CLinker.C_CHAR),\n+            \/**\n+             * {@code char16} type.\n+             *\/\n+            Char16(\"char16\", UnsupportedLayouts.CHAR16),\n+            \/**\n+             * {@code short} type.\n+             *\/\n+            Short(\"short\", CLinker.C_SHORT),\n+            \/**\n+             * {@code int} type.\n+             *\/\n+            Int(\"int\", CLinker.C_INT),\n+            \/**\n+             * {@code long} type.\n+             *\/\n+            Long(\"long\", CLinker.C_LONG),\n+            \/**\n+             * {@code long long} type.\n+             *\/\n+            LongLong(\"long long\", CLinker.C_LONG_LONG),\n+            \/**\n+             * {@code int128} type.\n+             *\/\n+            Int128(\"__int128\", UnsupportedLayouts.__INT128),\n+            \/**\n+             * {@code float} type.\n+             *\/\n+            Float(\"float\", CLinker.C_FLOAT),\n+            \/**\n+             * {@code double} type.\n+             *\/\n+            Double(\"double\",CLinker.C_DOUBLE),\n+            \/**\n+              * {@code long double} type.\n+              *\/\n+            LongDouble(\"long double\", UnsupportedLayouts.LONG_DOUBLE),\n+            \/**\n+             * {@code float128} type.\n+             *\/\n+            Float128(\"float128\", UnsupportedLayouts._FLOAT128),\n+            \/**\n+             * {@code float16} type.\n+             *\/\n+            HalfFloat(\"__fp16\", UnsupportedLayouts.__FP16),\n+            \/**\n+             * {@code wchar} type.\n+             *\/\n+            WChar(\"wchar_t\", UnsupportedLayouts.WCHAR_T);\n+\n+            private final String typeName;\n+            private final MemoryLayout layout;\n+\n+            Kind(String typeName, MemoryLayout layout) {\n+                this.typeName = typeName;\n+                this.layout = layout;\n+            }\n+\n+            public String typeName() {\n+                return typeName;\n+            }\n+\n+            \/**\n+             * The primitive type (optional) layout.\n+             * @return The primitive type (optional) layout.\n+             *\/\n+            public Optional<MemoryLayout> layout() {\n+                return Optional.ofNullable(layout);\n+            }\n+        }\n+\n+        \/**\n+         * The primitive type kind.\n+         * @return The primitive type kind.\n+         *\/\n+        Kind kind();\n+    }\n+\n+    \/**\n+     * Instances of this class are used to model types which are associated to a declaration in the foreign language\n+     * (see {@link Declaration}).\n+     *\/\n+    interface Declared extends Type {\n+        \/**\n+         * The declaration to this type refers to.\n+         * @return The declaration to this type refers to.\n+         *\/\n+        Declaration.Scoped tree();\n+    }\n+\n+    \/**\n+     * A function type.\n+     *\/\n+    interface Function extends Type {\n+        \/**\n+         * Is this function type a variable-arity?\n+         * @return true, if this function type is a variable-arity.\n+         *\/\n+        boolean varargs();\n+\n+        \/**\n+         * The function formal parameter types.\n+         * @return The function formal parameter types.\n+         *\/\n+        List<Type> argumentTypes();\n+\n+        \/**\n+         * The function return type.\n+         * @return The function return type.\n+         *\/\n+        Type returnType();\n+    }\n+\n+    \/**\n+     * An array type. Array types feature an element type and an optional size. As such they can also be used to\n+     * model array types.\n+     *\/\n+    interface Array extends Type {\n+\n+        \/**\n+         * The array type kind.\n+         *\/\n+        enum Kind {\n+            \/**\n+             * Vector kind.\n+             *\/\n+            VECTOR,\n+            \/**\n+             * Array kind.\n+             *\/\n+            ARRAY,\n+            \/**\n+             * Incomplete array kind.\n+             *\/\n+            INCOMPLETE_ARRAY;\n+        }\n+\n+        \/**\n+         * The array type kind.\n+         * @return The array type kind.\n+         *\/\n+        Kind kind();\n+\n+        \/**\n+         * The (optional) array element count.\n+         * @return The (optional) array element count.\n+         *\n+         * @implSpec an element count is present if the array type kind is one of {@link Kind#VECTOR}, {@link Kind#ARRAY}.\n+         *\/\n+        OptionalLong elementCount();\n+\n+        \/**\n+         * The array type element type.\n+         * @return The array type element type.\n+         *\/\n+        Type elementType();\n+    }\n+\n+    \/**\n+     * A delegated type is used to model a type which contains an indirection to some other underlying type. For instance,\n+     * a delegated type can be used to model foreign pointers, where the indirection is used to model the pointee type.\n+     *\/\n+    interface Delegated extends Type {\n+\n+        \/**\n+         * The delegated type kind.\n+         *\/\n+        enum Kind {\n+            \/**\n+             * Type-defined type.\n+             *\/\n+            TYPEDEF,\n+            \/**\n+             * Pointer type.\n+             *\/\n+            POINTER,\n+            \/**\n+             * Signed type.\n+             *\/\n+            SIGNED,\n+            \/**\n+             * Unsigned type.\n+             *\/\n+            UNSIGNED,\n+            \/**\n+             * Atomic type.\n+             *\/\n+            ATOMIC,\n+            \/**\n+             * Volatile type.\n+             *\/\n+            VOLATILE,\n+            \/**\n+             * Complex type.\n+             *\/\n+            COMPLEX;\n+        }\n+\n+        \/**\n+         * The delegated type kind.\n+         * @return The delegated type kind.\n+         *\/\n+        Kind kind();\n+\n+        \/**\n+         * The delegated type (optional) name.\n+         * @return The delegated type (optional) name.\n+         *\n+         * @implSpec an element count is present if the array type kind is one of {@link Kind#TYPEDEF}.\n+         *\/\n+        Optional<String> name();\n+\n+        \/**\n+         * The delegated type underlying type.\n+         * @return The delegated type underlying type.\n+         *\/\n+        Type type();\n+    }\n+\n+    \/**\n+     * Type visitor interface.\n+     * @param <R> the visitor's return type.\n+     * @param <P> the visitor's parameter type.\n+     *\/\n+    interface Visitor<R,P> {\n+        \/**\n+         * Visit a primitive type.\n+         * @param t the primitive type.\n+         * @param p the visitor parameter.\n+         * @return the result of visiting the given primitive type through this visitor object.\n+         *\/\n+        default R visitPrimitive(Primitive t, P p) { return visitType(t, p); }\n+\n+        \/**\n+         * Visit a function type.\n+         * @param t the function type.\n+         * @param p the visitor parameter.\n+         * @return the result of visiting the given function type through this visitor object.\n+         *\/\n+        default R visitFunction(Function t, P p) { return visitType(t, p); }\n+\n+        \/**\n+         * Visit a declared type.\n+         * @param t the declared type.\n+         * @param p the visitor parameter.\n+         * @return the result of visiting the given declared type through this visitor object.\n+         *\/\n+        default R visitDeclared(Declared t, P p) { return visitType(t, p); }\n+\n+        \/**\n+         * Visit a delegated type.\n+         * @param t the delegated type.\n+         * @param p the visitor parameter.\n+         * @return the result of visiting the given delegated type through this visitor object.\n+         *\/\n+        default R visitDelegated(Delegated t, P p) { return visitType(t, p); }\n+\n+        \/**\n+         * Visit an array type.\n+         * @param t the array type.\n+         * @param p the visitor parameter.\n+         * @return the result of visiting the given array type through this visitor object.\n+         *\/\n+        default R visitArray(Array t, P p) { return visitType(t, p); }\n+\n+        \/**\n+         * Visit a type.\n+         * @param t the type.\n+         * @param p the visitor parameter.\n+         * @return the result of visiting the given type through this visitor object.\n+         *\/\n+        default R visitType(Type t, P p) { throw new UnsupportedOperationException(); }\n+    }\n+\n+    \/**\n+     * Compute the layout for a given type.\n+     * @param t the type.\n+     * @return the layout for given type.\n+     *\/\n+    static Optional<MemoryLayout> layoutFor(Type t) {\n+        return LayoutUtils.getLayout(t);\n+    }\n+\n+    \/**\n+     * Compute the function descriptor for a given function type.\n+     * @param function the function type.\n+     * @return the function descriptor for given function type.\n+     *\/\n+    static Optional<FunctionDescriptor> descriptorFor(Function function) {\n+        return LayoutUtils.getDescriptor(function);\n+    }\n+\n+    \/**\n+     * Create the {@code void} type.\n+     * @return the {@code void} type.\n+     *\/\n+    static Type.Primitive void_() {\n+        return new TypeImpl.PrimitiveImpl(Type.Primitive.Kind.Void);\n+    }\n+\n+    \/**\n+     * Creates a new primitive type given kind.\n+     * @param kind the primitive type kind.\n+     * @return a new primitive type with given kind.\n+     *\/\n+    static Type.Primitive primitive(Type.Primitive.Kind kind) {\n+        return new TypeImpl.PrimitiveImpl(kind);\n+    }\n+\n+    \/**\n+     * Creates a new qualified type given kind and underlying type.\n+     * @param kind the qualified type kind.\n+     * @param type the qualified type underlying type.\n+     * @return a new qualified type with given name and underlying type.\n+     *\/\n+    static Type.Delegated qualified(Type.Delegated.Kind kind, Type type) {\n+        return new TypeImpl.QualifiedImpl(kind, type);\n+    }\n+\n+    \/**\n+     * Creates a new typedef type given name and underlying type.\n+     * @param name the typedef type name.\n+     * @param aliased the typeef type underlying type.\n+     * @return a new typedef type with given name and underlying type.\n+     *\/\n+    static Type.Delegated typedef(String name, Type aliased) {\n+        return new TypeImpl.QualifiedImpl(Delegated.Kind.TYPEDEF, name, aliased);\n+    }\n+\n+    \/**\n+     * Creates a new pointer type with no associated pointee information.\n+     * @return a new pointer type with no associated pointee information.\n+     *\/\n+    static Type.Delegated pointer() {\n+        return new TypeImpl.PointerImpl(() -> new TypeImpl.PrimitiveImpl(Type.Primitive.Kind.Void));\n+    }\n+\n+    \/**\n+     * Creates a new pointer type with given pointee type.\n+     * @param pointee the pointee type.\n+     * @return a new pointer type with given pointee type.\n+     *\/\n+    static Type.Delegated pointer(Type pointee) {\n+        return new TypeImpl.PointerImpl(() -> pointee);\n+    }\n+\n+    \/**\n+     * Creates a new pointer type with given pointee type.\n+     * @param pointee factory to (lazily) build the pointee type.\n+     * @return a new pointer type with given pointee type (lazily built from factory).\n+     *\/\n+    static Type.Delegated pointer(Supplier<Type> pointee) {\n+        return new TypeImpl.PointerImpl(pointee);\n+    }\n+\n+    \/**\n+     * Creates a new function type with given parameter types and return type.\n+     * @param varargs is this function type variable-arity?\n+     * @param returnType the function type return type.\n+     * @param arguments the function type formal parameter types.\n+     * @return a new function type with given parameter types and return type.\n+     *\/\n+    static Type.Function function(boolean varargs, Type returnType, Type... arguments) {\n+        return new TypeImpl.FunctionImpl(varargs, Stream.of(arguments).collect(Collectors.toList()), returnType);\n+    }\n+\n+    \/**\n+     * Creates a new declared type with given foreign declaration.\n+     * @param tree the foreign declaration the type refers to.\n+     * @return  a new declared type with given foreign declaration.\n+     *\/\n+    static Type.Declared declared(Declaration.Scoped tree) {\n+        return new TypeImpl.DeclaredImpl(tree);\n+    }\n+\n+    \/**\n+     * Creates a new vector type with given element count and element type.\n+     * @param elementCount the vector type element count.\n+     * @param elementType the vector type element type.\n+     * @return a new vector type with given element count and element type.\n+     *\/\n+    static Type.Array vector(long elementCount, Type elementType) {\n+        return new TypeImpl.ArrayImpl(Array.Kind.VECTOR, elementCount, elementType);\n+    }\n+\n+    \/**\n+     * Creates a new array type with given element count and element type.\n+     * @param elementCount the array type element count.\n+     * @param elementType the array type element type.\n+     * @return a new array type with given element count and element type.\n+     *\/\n+    static Type.Array array(long elementCount, Type elementType) {\n+        return new TypeImpl.ArrayImpl(Array.Kind.ARRAY, elementCount, elementType);\n+    }\n+\n+    \/**\n+     * Creates a new array type with given element type.\n+     * @param elementType the array type element type.\n+     * @return a new array type with given element type.\n+     *\/\n+    static Type.Array array(Type elementType) {\n+        return new TypeImpl.ArrayImpl(Array.Kind.INCOMPLETE_ARRAY, elementType);\n+    }\n+\n+    \/**\n+     * Creates an erroneous type.\n+     * @return an erroneous type.\n+     *\/\n+    static Type error() {\n+        return TypeImpl.ERROR;\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/incubator\/jextract\/Type.java","additions":514,"deletions":0,"binary":false,"changes":514,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.clang;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+\/**\n+ * Represents the C++ access control level of a member or of a base class.\n+ *\/\n+public enum AccessSpecifier {\n+    InvalidAccessSpecifier(0),\n+    Public(1),\n+    Protected(2),\n+    Private(3);\n+\n+    private final int value;\n+\n+    AccessSpecifier(int value) {\n+        this.value = value;\n+    }\n+\n+    public int value() {\n+        return value;\n+    }\n+\n+    private final static Map<Integer, AccessSpecifier> lookup;\n+\n+    static {\n+        lookup = new HashMap<>();\n+        for (AccessSpecifier e: AccessSpecifier.values()) {\n+            lookup.put(e.value(), e);\n+        }\n+    }\n+\n+    public final static AccessSpecifier valueOf(int value) {\n+        AccessSpecifier x = lookup.get(value);\n+        if (null == x) {\n+            throw new NoSuchElementException(\"Invalid AccessSpecifier kind value: \" + value);\n+        }\n+        return x;\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/AccessSpecifier.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.clang;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+public enum CallingConvention {\n+\n+    Default(0),\n+    C(1),\n+    X86StdCall(2),\n+    X86FastCall(3),\n+    X86ThisCall(4),\n+    X86Pascal(5),\n+    AAPCS(6),\n+    AAPCS_VFP(7),\n+    PnaclCall(8),\n+    IntelOclBicc(9),\n+    X86_64Win64(10),\n+    X86_64SysV(11),\n+    Invalid(100),\n+    Unexposed(200);\n+\n+    private final int value;\n+\n+    CallingConvention(int value) {\n+        this.value = value;\n+    }\n+\n+    public int value() {\n+        return value;\n+    }\n+\n+    private final static Map<Integer, CallingConvention> lookup;\n+\n+    static {\n+        lookup = new HashMap<>();\n+        for (CallingConvention e: CallingConvention.values()) {\n+            lookup.put(e.value(), e);\n+        }\n+    }\n+\n+    public final static CallingConvention valueOf(int value) {\n+        CallingConvention x = lookup.get(value);\n+        if (null == x) {\n+            throw new NoSuchElementException();\n+        }\n+        return x;\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/CallingConvention.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,403 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.clang;\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.internal.clang.libclang.Index_h;\n+\n+import java.util.ArrayList;\n+import java.util.stream.Stream;\n+\n+public final class Cursor {\n+\n+    private final MemorySegment cursor;\n+    private final int kind;\n+\n+    Cursor(MemorySegment cursor) {\n+        this.cursor = cursor;\n+        kind = Index_h.clang_getCursorKind(cursor);\n+    }\n+\n+    public boolean isDeclaration() {\n+        return Index_h.clang_isDeclaration(kind) != 0;\n+    }\n+\n+    public boolean isPreprocessing() {\n+        return Index_h.clang_isPreprocessing(kind) != 0;\n+    }\n+\n+    public boolean isInvalid() {\n+        return Index_h.clang_isInvalid(kind) != 0;\n+    }\n+\n+    public boolean isDefinition() {\n+        return Index_h.clang_isCursorDefinition(cursor) != 0;\n+    }\n+\n+    public boolean isAttribute() { return Index_h.clang_isAttribute(kind) != 0; }\n+\n+    public boolean isAnonymousStruct() {\n+        return Index_h.clang_Cursor_isAnonymousRecordDecl(cursor) != 0;\n+    }\n+\n+    public boolean isMacroFunctionLike() {\n+        return Index_h.clang_Cursor_isMacroFunctionLike(cursor) != 0;\n+    }\n+\n+    public String spelling() {\n+        return LibClang.CXStrToString(\n+                Index_h.clang_getCursorSpelling(cursor));\n+    }\n+\n+    public String USR() {\n+        return LibClang.CXStrToString(\n+                Index_h.clang_getCursorUSR(cursor));\n+    }\n+\n+    public String prettyPrinted(PrintingPolicy policy) {\n+        return LibClang.CXStrToString(\n+                Index_h.clang_getCursorPrettyPrinted(cursor, policy.ptr()));\n+    }\n+\n+    public String prettyPrinted() {\n+        try (PrintingPolicy policy = getPrintingPolicy()) {\n+            return prettyPrinted(policy);\n+        }\n+    }\n+\n+    public String displayName() {\n+        return LibClang.CXStrToString(\n+                Index_h.clang_getCursorDisplayName(cursor));\n+    }\n+\n+    public boolean equalCursor(Cursor other) {\n+        return Index_h.clang_equalCursors(cursor, other.cursor) != 0;\n+    }\n+\n+    public Type type() {\n+        return new Type(Index_h.clang_getCursorType(cursor));\n+    }\n+\n+    public Type getEnumDeclIntegerType() {\n+        return new Type(Index_h.clang_getEnumDeclIntegerType(cursor));\n+    }\n+\n+    public boolean isEnumDeclScoped() {\n+        return Index_h.clang_EnumDecl_isScoped(cursor) != 0;\n+    }\n+\n+    public Cursor getDefinition() {\n+        return new Cursor(Index_h.clang_getCursorDefinition(cursor));\n+    }\n+\n+    public SourceLocation getSourceLocation() {\n+        MemorySegment loc = Index_h.clang_getCursorLocation(cursor);\n+        if (Index_h.clang_equalLocations(loc, Index_h.clang_getNullLocation()) != 0) {\n+            return null;\n+        }\n+        return new SourceLocation(loc);\n+    }\n+\n+    public SourceRange getExtent() {\n+        MemorySegment range = Index_h.clang_getCursorExtent(cursor);\n+        if (Index_h.clang_Range_isNull(range) != 0) {\n+            return null;\n+        }\n+        return new SourceRange(range);\n+    }\n+\n+    public int numberOfArgs() {\n+        return Index_h.clang_Cursor_getNumArguments(cursor);\n+    }\n+\n+    public Cursor getArgument(int idx) {\n+        return new Cursor(Index_h.clang_Cursor_getArgument(cursor, idx));\n+    }\n+\n+    public int numberOfTemplateArgs() {\n+        return Index_h.clang_Cursor_getNumTemplateArguments(cursor);\n+    }\n+\n+    public TemplateArgumentKind getTemplateArgumentKind(int idx) {\n+        int kind = Index_h.clang_Cursor_getTemplateArgumentKind(cursor, idx);\n+        return TemplateArgumentKind.valueOf(kind);\n+    }\n+\n+    public Type getTemplateArgumentType(int idx) {\n+        return new Type(Index_h.clang_Cursor_getTemplateArgumentType(cursor, idx));\n+    }\n+\n+    public long getTemplateArgumentValue(int idx) {\n+        return Index_h.clang_Cursor_getTemplateArgumentValue(cursor, idx);\n+    }\n+\n+    public long getTemplateArgumentUnsignedValue(int idx) {\n+        return Index_h.clang_Cursor_getTemplateArgumentUnsignedValue(cursor, idx);\n+    }\n+\n+    public CursorKind getTemplateCursorKind() {\n+        return CursorKind.valueOf(Index_h.clang_getTemplateCursorKind(cursor));\n+    }\n+\n+    \/\/ C long long, 64-bit\n+    public long getEnumConstantValue() {\n+        return Index_h.clang_getEnumConstantDeclValue(cursor);\n+    }\n+\n+    \/\/ C unsigned long long, 64-bit\n+    public long getEnumConstantUnsignedValue() {\n+        return Index_h.clang_getEnumConstantDeclUnsignedValue(cursor);\n+    }\n+\n+    public boolean isBitField() {\n+        return Index_h.clang_Cursor_isBitField(cursor) != 0;\n+    }\n+\n+    \/**\n+     * Returns true if the base class specified by this cursor is virtual.\n+     *\/\n+    public boolean isVirtualBase() {\n+        return Index_h.clang_isVirtualBase(cursor) != 0;\n+    }\n+\n+    public int getBitFieldWidth() {\n+        return Index_h.clang_getFieldDeclBitWidth(cursor);\n+    }\n+\n+    public CursorKind kind() {\n+        return CursorKind.valueOf(kind);\n+    }\n+\n+    public int kind0() {\n+        return kind;\n+    }\n+\n+    \/**\n+     * Determine if a C++ constructor is a converting constructor.\n+     *\/\n+    public boolean isConvertingConstructor() {\n+        return Index_h.clang_CXXConstructor_isConvertingConstructor(cursor) != 0;\n+    }\n+\n+    \/**\n+     * Determine if a C++ constructor is a copy constructor.\n+     *\/\n+    public boolean isCopyConstructor() {\n+        return Index_h.clang_CXXConstructor_isCopyConstructor(cursor) != 0;\n+    }\n+\n+    \/**\n+     * Determine if a C++ constructor is the default constructor.\n+     *\/\n+    public boolean isDefaultConstructor() {\n+        return Index_h.clang_CXXConstructor_isDefaultConstructor(cursor) != 0;\n+    }\n+\n+    \/**\n+     * Determine if a C++ constructor is a move constructor.\n+     *\/\n+    public boolean isMoveConstructor() {\n+        return Index_h.clang_CXXConstructor_isMoveConstructor(cursor) != 0;\n+    }\n+\n+    \/**\n+     * Determine if a C++ field is declared 'mutable'.\n+     *\/\n+    public boolean isMutableField() {\n+        return Index_h.clang_CXXField_isMutable(cursor) != 0;\n+    }\n+\n+    \/**\n+     * Determine if a C++ method is declared '= default'.\n+     *\/\n+    public boolean isDefaultedMethod() {\n+        return Index_h.clang_CXXMethod_isDefaulted(cursor) != 0;\n+    }\n+\n+    \/**\n+     * Determine if a C++ member function is pure virtual.\n+     *\/\n+    public boolean isPureVirtualMethod() {\n+        return Index_h.clang_CXXMethod_isPureVirtual(cursor) != 0;\n+    }\n+\n+    \/**\n+     * Determine if a C++ member function or member function template is\n+     * declared 'static'.\n+     *\/\n+    public boolean isStaticMethod() {\n+        return Index_h.clang_CXXMethod_isStatic(cursor) != 0;\n+    }\n+\n+    \/**\n+     * Determine if a C++ member function is explicitly declared 'virtual'\n+     * or if it overrides a virtual method from one of the base classes.\n+     *\/\n+    public boolean isVirtualMethod() {\n+        return Index_h.clang_CXXMethod_isVirtual(cursor) != 0;\n+    }\n+\n+    public boolean isConstructor() {\n+        return kind() == CursorKind.Constructor;\n+    }\n+\n+    public boolean isDestructor() {\n+        return kind() == CursorKind.Destructor;\n+    }\n+\n+    \/**\n+     * Determine if a C++ record is abstract, i.e. whether a class or struct\n+     * has a pure virtual member function.\n+     *\/\n+    public boolean isAbstractClass() {\n+        return Index_h.clang_CXXRecord_isAbstract(cursor) != 0;\n+    }\n+\n+    \/**\n+     * Determine if a C++ member function or member function template is\n+     * declared 'const'.\n+     *\/\n+    public boolean isConstMethod() {\n+        return Index_h.clang_CXXMethod_isConst(cursor) != 0;\n+    }\n+\n+    public AccessSpecifier accessSpecifier() {\n+        int acc = Index_h.clang_getCXXAccessSpecifier(cursor);\n+        return AccessSpecifier.valueOf(acc);\n+    }\n+\n+    \/**\n+     * Determine the number of overloaded declarations referenced by a\n+     * \\c CursorKind.OverloadedDeclRef cursor.\n+     *\n+     * \\returns The number of overloaded declarations referenced by \\c cursor. If it\n+     * is not a \\c CursorKind.OverloadedDeclRef cursor, returns 0.\n+     *\/\n+    public int numberOfOverloadedDecls() {\n+        return Index_h.clang_getNumOverloadedDecls(cursor);\n+    }\n+\n+    \/**\n+     * Retrieve a cursor for one of the overloaded declarations referenced\n+     * by a \\c CXCursor_OverloadedDeclRef cursor.\n+     *\n+     *\n+     * \\param index The zero-based index into the set of overloaded declarations in\n+     * the cursor.\n+     *\n+     * \\returns A cursor representing the declaration referenced by the given\n+     * \\c cursor at the specified \\c index. If the cursor does not have an\n+     * associated set of overloaded declarations, or if the index is out of bounds,\n+     * returns \\c clang_getNullCursor();\n+     *\/\n+    public Cursor getOverloadedDecl(int index) {\n+        return new Cursor(Index_h.clang_getOverloadedDecl(cursor, index));\n+    }\n+\n+    \/**\n+     * For a cursor that is a reference, retrieve a cursor representing the entity that it references.\n+     *\/\n+    public Cursor getCursorReferenced() {\n+        return new Cursor(Index_h.clang_getCursorReferenced(cursor));\n+    }\n+\n+    \/**\n+     * Given a cursor that may represent a specialization or instantiation of a template,\n+     * retrieve the cursor that represents the template that it specializes or from which\n+     * it was instantiated.\n+     *\/\n+    public Cursor getSpecializedCursorTemplate() {\n+        return new Cursor(Index_h.clang_getSpecializedCursorTemplate(cursor));\n+    }\n+\n+    private static class CursorChildren {\n+        private static final ArrayList<Cursor> children = new ArrayList<>();\n+        private static final MemorySegment callback = Index_h.CXCursorVisitor.allocate((c, p, d) -> {\n+            MemorySegment copy = MemorySegment.allocateNative(c.byteSize());\n+            copy.copyFrom(c);\n+            Cursor cursor = new Cursor(copy);\n+            children.add(cursor);\n+            return Index_h.CXChildVisit_Continue();\n+        });\n+\n+        synchronized static Stream<Cursor> get(Cursor c) {\n+            try {\n+                Index_h.clang_visitChildren(c.cursor, callback, MemoryAddress.NULL);\n+                return new ArrayList<>(children).stream();\n+            } finally {\n+                children.clear();\n+            }\n+        }\n+    }\n+\n+    public Stream<Cursor> children() {\n+        return CursorChildren.get(this);\n+    }\n+\n+    public Stream<Cursor> allChildren() {\n+        return children().flatMap(c -> Stream.concat(Stream.of(c), c.children()));\n+    }\n+\n+    public String getMangling() {\n+        return LibClang.CXStrToString(\n+                Index_h.clang_Cursor_getMangling(cursor));\n+    }\n+\n+    public TranslationUnit getTranslationUnit() {\n+        return new TranslationUnit(Index_h.clang_Cursor_getTranslationUnit(cursor));\n+    }\n+\n+    private MemoryAddress eval0() {\n+        return Index_h.clang_Cursor_Evaluate(cursor);\n+    }\n+\n+    public EvalResult eval() {\n+        MemoryAddress ptr = eval0();\n+        return ptr == MemoryAddress.NULL ? EvalResult.erroneous : new EvalResult(ptr);\n+    }\n+\n+    public PrintingPolicy getPrintingPolicy() {\n+        return new PrintingPolicy(Index_h.clang_getCursorPrintingPolicy(cursor));\n+    }\n+\n+    @Override\n+    public boolean equals(Object other) {\n+        if (this == other) {\n+            return true;\n+        }\n+        if (!(other instanceof Cursor)) {\n+            return false;\n+        }\n+        return (Index_h.clang_equalCursors(cursor, ((Cursor)other).cursor) != 0);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return spelling().hashCode();\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/Cursor.java","additions":403,"deletions":0,"binary":false,"changes":403,"status":"added"},{"patch":"@@ -0,0 +1,300 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.clang;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+public enum CursorKind {\n+\n+    UnexposedDecl(1),\n+    StructDecl(2),\n+    UnionDecl(3),\n+    ClassDecl(4),\n+    EnumDecl(5),\n+    FieldDecl(6),\n+    EnumConstantDecl(7),\n+    FunctionDecl(8),\n+    VarDecl(9),\n+    ParmDecl(10),\n+    ObjCInterfaceDecl(11),\n+    ObjCCategoryDecl(12),\n+    ObjCProtocolDecl(13),\n+    ObjCPropertyDecl(14),\n+    ObjCIvarDecl(15),\n+    ObjCInstanceMethodDecl(16),\n+    ObjCClassMethodDecl(17),\n+    ObjCImplementationDecl(18),\n+    ObjCCategoryImplDecl(19),\n+    TypedefDecl(20),\n+    CXXMethod(21),\n+    Namespace(22),\n+    LinkageSpec(23),\n+    Constructor(24),\n+    Destructor(25),\n+    ConversionFunction(26),\n+    TemplateTypeParameter(27),\n+    NonTypeTemplateParameter(28),\n+    TemplateTemplateParameter(29),\n+    FunctionTemplate(30),\n+    ClassTemplate(31),\n+    ClassTemplatePartialSpecialization(32),\n+    NamespaceAlias(33),\n+    UsingDirective(34),\n+    UsingDeclaration(35),\n+    TypeAliasDecl(36),\n+    ObjCSynthesizeDecl(37),\n+    ObjCDynamicDecl(38),\n+    CXXAccessSpecifier(39),\n+    ObjCSuperClassRef(40),\n+    ObjCProtocolRef(41),\n+    ObjCClassRef(42),\n+    TypeRef(43),\n+    CXXBaseSpecifier(44),\n+    TemplateRef(45),\n+    NamespaceRef(46),\n+    MemberRef(47),\n+    LabelRef(48),\n+    OverloadedDeclRef(49),\n+    VariableRef(50),\n+    InvalidFile(70),\n+    NoDeclFound(71),\n+    NotImplemented(72),\n+    InvalidCode(73),\n+    UnexposedExpr(100),\n+    DeclRefExpr(101),\n+    MemberRefExpr(102),\n+    CallExpr(103),\n+    ObjCMessageExpr(104),\n+    BlockExpr(105),\n+    IntegerLiteral(106),\n+    FloatingLiteral(107),\n+    ImaginaryLiteral(108),\n+    StringLiteral(109),\n+    CharacterLiteral(110),\n+    ParenExpr(111),\n+    UnaryOperator(112),\n+    ArraySubscriptExpr(113),\n+    BinaryOperator(114),\n+    CompoundAssignOperator(115),\n+    ConditionalOperator(116),\n+    CStyleCastExpr(117),\n+    CompoundLiteralExpr(118),\n+    InitListExpr(119),\n+    AddrLabelExpr(120),\n+    StmtExpr(121),\n+    GenericSelectionExpr(122),\n+    GNUNullExpr(123),\n+    CXXStaticCastExpr(124),\n+    CXXDynamicCastExpr(125),\n+    CXXReinterpretCastExpr(126),\n+    CXXConstCastExpr(127),\n+    CXXFunctionalCastExpr(128),\n+    CXXTypeidExpr(129),\n+    CXXBoolLiteralExpr(130),\n+    CXXNullPtrLiteralExpr(131),\n+    CXXThisExpr(132),\n+    CXXThrowExpr(133),\n+    CXXNewExpr(134),\n+    CXXDeleteExpr(135),\n+    UnaryExpr(136),\n+    ObjCStringLiteral(137),\n+    ObjCEncodeExpr(138),\n+    ObjCSelectorExpr(139),\n+    ObjCProtocolExpr(140),\n+    ObjCBridgedCastExpr(141),\n+    PackExpansionExpr(142),\n+    SizeOfPackExpr(143),\n+    LambdaExpr(144),\n+    ObjCBoolLiteralExpr(145),\n+    ObjCSelfExpr(146),\n+    OMPArraySectionExpr(147),\n+    ObjCAvailabilityCheckExpr(148),\n+    FixedPointLiteral(149),\n+    UnexposedStmt(200),\n+    LabelStmt(201),\n+    CompoundStmt(202),\n+    CaseStmt(203),\n+    DefaultStmt(204),\n+    IfStmt(205),\n+    SwitchStmt(206),\n+    WhileStmt(207),\n+    DoStmt(208),\n+    ForStmt(209),\n+    GotoStmt(210),\n+    IndirectGotoStmt(211),\n+    ContinueStmt(212),\n+    BreakStmt(213),\n+    ReturnStmt(214),\n+    GCCAsmStmt(215),\n+    AsmStmt(215),\n+    ObjCAtTryStmt(216),\n+    ObjCAtCatchStmt(217),\n+    ObjCAtFinallyStmt(218),\n+    ObjCAtThrowStmt(219),\n+    ObjCAtSynchronizedStmt(220),\n+    ObjCAutoreleasePoolStmt(221),\n+    ObjCForCollectionStmt(222),\n+    CXXCatchStmt(223),\n+    CXXTryStmt(224),\n+    CXXForRangeStmt(225),\n+    SEHTryStmt(226),\n+    SEHExceptStmt(227),\n+    SEHFinallyStmt(228),\n+    MSAsmStmt(229),\n+    NullStmt(230),\n+    DeclStmt(231),\n+    OMPParallelDirective(232),\n+    OMPSimdDirective(233),\n+    OMPForDirective(234),\n+    OMPSectionsDirective(235),\n+    OMPSectionDirective(236),\n+    OMPSingleDirective(237),\n+    OMPParallelForDirective(238),\n+    OMPParallelSectionsDirective(239),\n+    OMPTaskDirective(240),\n+    OMPMasterDirective(241),\n+    OMPCriticalDirective(242),\n+    OMPTaskyieldDirective(243),\n+    OMPBarrierDirective(244),\n+    OMPTaskwaitDirective(245),\n+    OMPFlushDirective(246),\n+    SEHLeaveStmt(247),\n+    OMPOrderedDirective(248),\n+    OMPAtomicDirective(249),\n+    OMPForSimdDirective(250),\n+    OMPParallelForSimdDirective(251),\n+    OMPTargetDirective(252),\n+    OMPTeamsDirective(253),\n+    OMPTaskgroupDirective(254),\n+    OMPCancellationPointDirective(255),\n+    OMPCancelDirective(256),\n+    OMPTargetDataDirective(257),\n+    OMPTaskLoopDirective(258),\n+    OMPTaskLoopSimdDirective(259),\n+    OMPDistributeDirective(260),\n+    OMPTargetEnterDataDirective(261),\n+    OMPTargetExitDataDirective(262),\n+    OMPTargetParallelDirective(263),\n+    OMPTargetParallelForDirective(264),\n+    OMPTargetUpdateDirective(265),\n+    OMPDistributeParallelForDirective(266),\n+    OMPDistributeParallelForSimdDirective(267),\n+    OMPDistributeSimdDirective(268),\n+    OMPTargetParallelForSimdDirective(269),\n+    OMPTargetSimdDirective(270),\n+    OMPTeamsDistributeDirective(271),\n+    OMPTeamsDistributeSimdDirective(272),\n+    OMPTeamsDistributeParallelForSimdDirective(273),\n+    OMPTeamsDistributeParallelForDirective(274),\n+    OMPTargetTeamsDirective(275),\n+    OMPTargetTeamsDistributeDirective(276),\n+    OMPTargetTeamsDistributeParallelForDirective(277),\n+    OMPTargetTeamsDistributeParallelForSimdDirective(278),\n+    OMPTargetTeamsDistributeSimdDirective(279),\n+    BuiltinBitCastExpr(280),\n+    TranslationUnit(300),\n+    UnexposedAttr(400),\n+    IBActionAttr(401),\n+    IBOutletAttr(402),\n+    IBOutletCollectionAttr(403),\n+    CXXFinalAttr(404),\n+    CXXOverrideAttr(405),\n+    AnnotateAttr(406),\n+    AsmLabelAttr(407),\n+    PackedAttr(408),\n+    PureAttr(409),\n+    ConstAttr(410),\n+    NoDuplicateAttr(411),\n+    CUDAConstantAttr(412),\n+    CUDADeviceAttr(413),\n+    CUDAGlobalAttr(414),\n+    CUDAHostAttr(415),\n+    CUDASharedAttr(416),\n+    VisibilityAttr(417),\n+    DLLExport(418),\n+    DLLImport(419),\n+    NSReturnsRetained(420),\n+    NSReturnsNotRetained(421),\n+    NSReturnsAutoreleased(422),\n+    NSConsumesSelf(423),\n+    NSConsumed(424),\n+    ObjCException(425),\n+    ObjCNSObject(426),\n+    ObjCIndependentClass(427),\n+    ObjCPreciseLifetime(428),\n+    ObjCReturnsInnerPointer(429),\n+    ObjCRequiresSuper(430),\n+    ObjCRootClass(431),\n+    ObjCSubclassingRestricted(432),\n+    ObjCExplicitProtocolImpl(433),\n+    ObjCDesignatedInitializer(434),\n+    ObjCRuntimeVisible(435),\n+    ObjCBoxable(436),\n+    FlagEnum(437),\n+    ConvergentAttr(438),\n+    WarnUnusedAttr(439),\n+    WarnUnusedResultAttr(440),\n+    AlignedAttr(441),\n+    PreprocessingDirective(500),\n+    MacroDefinition(501),\n+    MacroExpansion(502),\n+    MacroInstantiation(502),\n+    InclusionDirective(503),\n+    ModuleImportDecl(600),\n+    TypeAliasTemplateDecl(601),\n+    StaticAssert(602),\n+    FriendDecl(603),\n+    OverloadCandidate(700);\n+\n+    private final int value;\n+\n+    CursorKind(int value) {\n+        this.value = value;\n+    }\n+\n+    public int value() {\n+        return value;\n+    }\n+\n+    private final static Map<Integer, CursorKind> lookup;\n+\n+    static {\n+        lookup = new HashMap<>();\n+        for (CursorKind e: CursorKind.values()) {\n+            lookup.put(e.value(), e);\n+        }\n+    }\n+\n+    public final static CursorKind valueOf(int value) {\n+        CursorKind x = lookup.get(value);\n+        if (null == x) {\n+            throw new NoSuchElementException(\"Invalid Cursor kind value: \" + value);\n+        }\n+        return x;\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/CursorKind.java","additions":300,"deletions":0,"binary":false,"changes":300,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.clang;\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.internal.clang.libclang.Index_h;\n+\n+public class Diagnostic {\n+    final MemoryAddress ptr;\n+\n+    \/\/ Various Diagnostic severity levels - from Clang enum CXDiagnosticSeverity\n+\n+    \/**\n+     * A diagnostic that has been suppressed, e.g., by a command-line\n+     * option.\n+     *\/\n+    public static final int CXDiagnostic_Ignored = 0;\n+\n+    \/**\n+     * This diagnostic is a note that should be attached to the\n+     * previous (non-note) diagnostic.\n+     *\/\n+    public static final int CXDiagnostic_Note    = 1;\n+\n+    \/**\n+     * This diagnostic indicates suspicious code that may not be\n+     * wrong.\n+     *\/\n+    public static final int CXDiagnostic_Warning = 2;\n+\n+    \/**\n+     * This diagnostic indicates that the code is ill-formed.\n+     *\/\n+    public static final int CXDiagnostic_Error   = 3;\n+\n+    \/**\n+     * This diagnostic indicates that the code is ill-formed such\n+     * that future parser recovery is unlikely to produce useful\n+     * results.\n+     *\/\n+    public static final int CXDiagnostic_Fatal   = 4;\n+\n+    Diagnostic(MemoryAddress ptr) {\n+        this.ptr = ptr;\n+    }\n+\n+    public int severity() {\n+        return Index_h.clang_getDiagnosticSeverity(ptr);\n+    }\n+\n+    public SourceLocation location() {\n+        return new SourceLocation(Index_h.clang_getDiagnosticLocation(ptr));\n+    }\n+\n+    public String spelling() {\n+        return LibClang.CXStrToString(\n+                Index_h.clang_getDiagnosticSpelling(ptr));\n+    }\n+\n+    public void dispose() {\n+        Index_h.clang_disposeDiagnostic(ptr);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return LibClang.CXStrToString(\n+                Index_h.clang_formatDiagnostic(ptr,\n+                    Index_h.clang_defaultDiagnosticDisplayOptions()));\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/Diagnostic.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.clang;\n+\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.function.Function;\n+\n+import static java.util.stream.Collectors.toMap;\n+import static jdk.internal.clang.libclang.Index_h.CXError_ASTReadError;\n+import static jdk.internal.clang.libclang.Index_h.CXError_Crashed;\n+import static jdk.internal.clang.libclang.Index_h.CXError_Failure;\n+import static jdk.internal.clang.libclang.Index_h.CXError_InvalidArguments;\n+import static jdk.internal.clang.libclang.Index_h.CXError_Success;\n+\n+public enum ErrorCode {\n+    Success(CXError_Success()),\n+    Failure(CXError_Failure()),\n+    Crashed(CXError_Crashed()),\n+    InvalidArguments(CXError_InvalidArguments()),\n+    ASTReadError(CXError_ASTReadError());\n+\n+    private final int code;\n+\n+    ErrorCode(int code) {\n+        this.code = code;\n+    }\n+\n+    public int code() {\n+        return code;\n+    }\n+\n+    private static final Map<Integer, ErrorCode> lookup = Arrays.stream(values())\n+            .collect(toMap(ErrorCode::code, Function.identity()));\n+\n+    public static ErrorCode valueOf(int code) {\n+        return lookup.computeIfAbsent(code, k -> { throw new NoSuchElementException(\"No ErrorCode with code: \" + k); });\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/ErrorCode.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.clang;\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.internal.clang.libclang.Index_h;\n+\n+public class EvalResult implements AutoCloseable {\n+    private MemoryAddress ptr;\n+\n+    public EvalResult(MemoryAddress ptr) {\n+        this.ptr = ptr;\n+    }\n+\n+    public enum Kind {\n+        Integral,\n+        FloatingPoint,\n+        StrLiteral,\n+        Erroneous,\n+        Unknown\n+    }\n+\n+    private int getKind0() {\n+        return Index_h.clang_EvalResult_getKind(ptr);\n+    }\n+\n+    public Kind getKind() {\n+        int code = getKind0();\n+        switch (code) {\n+            case 1: return Kind.Integral;\n+            case 2: return Kind.FloatingPoint;\n+            case 3: case 4: case 5:\n+                return Kind.StrLiteral;\n+            default:\n+                return Kind.Unknown;\n+        }\n+    }\n+\n+    private long getAsInt0() {\n+        return Index_h.clang_EvalResult_getAsLongLong(ptr);\n+    }\n+\n+    public long getAsInt() {\n+        Kind kind = getKind();\n+        switch (kind) {\n+            case Integral:\n+                return getAsInt0();\n+            default:\n+                throw new IllegalStateException(\"Unexpected kind: \" + kind);\n+        }\n+    }\n+\n+    private double getAsFloat0() {\n+        return Index_h.clang_EvalResult_getAsDouble(ptr);\n+    }\n+\n+    public double getAsFloat() {\n+        Kind kind = getKind();\n+        switch (kind) {\n+            case FloatingPoint:\n+                return getAsFloat0();\n+            default:\n+                throw new IllegalStateException(\"Unexpected kind: \" + kind);\n+        }\n+    }\n+\n+    private String getAsString0() {\n+        MemoryAddress value = Index_h.clang_EvalResult_getAsStr(ptr);\n+        return CLinker.toJavaStringRestricted(value);\n+    }\n+\n+    public String getAsString() {\n+        Kind kind = getKind();\n+        switch (kind) {\n+            case StrLiteral:\n+                return getAsString0();\n+            default:\n+                throw new IllegalStateException(\"Unexpected kind: \" + kind);\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        if (ptr != MemoryAddress.NULL) {\n+            Index_h.clang_EvalResult_dispose(ptr);\n+            ptr = MemoryAddress.NULL;\n+        }\n+    }\n+\n+    final static EvalResult erroneous = new EvalResult(MemoryAddress.NULL) {\n+        @Override\n+        public Kind getKind() {\n+            return Kind.Erroneous;\n+        }\n+\n+        @Override\n+        public void close() {\n+            \/\/do nothing\n+        }\n+    };\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/EvalResult.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.clang;\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryHandles;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.NativeScope;\n+import jdk.internal.clang.libclang.Index_h;\n+\n+import java.lang.invoke.VarHandle;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+\n+public class Index implements AutoCloseable {\n+    \/\/ Pointer to CXIndex\n+    private MemoryAddress ptr;\n+    \/\/ Set of TranslationUnit\n+    public final List<TranslationUnit> translationUnits;\n+\n+    Index(MemoryAddress ptr) {\n+        this.ptr = ptr;\n+        translationUnits = new ArrayList<>();\n+    }\n+\n+    public static class UnsavedFile {\n+        final String file;\n+        final String contents;\n+\n+        private UnsavedFile(Path path, String contents) {\n+            this.file = path.toAbsolutePath().toString();\n+            this.contents = contents;\n+        }\n+\n+        public static UnsavedFile of(Path path, String contents) {\n+            return new UnsavedFile(path, contents);\n+        }\n+    }\n+\n+    public static class ParsingFailedException extends RuntimeException {\n+        private static final long serialVersionUID = -1L;\n+        private final Path srcFile;\n+        private final ErrorCode code;\n+\n+        public ParsingFailedException(Path srcFile, ErrorCode code) {\n+            super(\"Failed to parse \" + srcFile.toAbsolutePath().toString() + \": \" + code);\n+            this.srcFile = srcFile;\n+            this.code = code;\n+        }\n+    }\n+\n+    private static final VarHandle VH_MemoryAddress =\n+            MemoryHandles.asAddressVarHandle(CLinker.C_POINTER.varHandle(long.class));\n+\n+    public TranslationUnit parseTU(String file, Consumer<Diagnostic> dh, int options, String... args)\n+    throws ParsingFailedException {\n+        try (NativeScope scope = NativeScope.unboundedScope()) {\n+            MemorySegment src = CLinker.toCString(file, scope);\n+            MemorySegment cargs = scope.allocateArray(CLinker.C_POINTER, args.length);\n+            for (int i = 0 ; i < args.length ; i++) {\n+                MemoryAccess.setAddressAtIndex(cargs, i, CLinker.toCString(args[i], scope));\n+            }\n+            MemorySegment outAddress = scope.allocate(CLinker.C_POINTER);\n+            ErrorCode code = ErrorCode.valueOf(Index_h.clang_parseTranslationUnit2(\n+                    ptr,\n+                    src,\n+                    cargs == null ? MemoryAddress.NULL : cargs,\n+                    args.length, MemoryAddress.NULL,\n+                    0,\n+                    options,\n+                    outAddress));\n+\n+            MemoryAddress tu = (MemoryAddress) VH_MemoryAddress.get(outAddress);\n+            TranslationUnit rv = new TranslationUnit(tu);\n+            \/\/ even if we failed to parse, we might still have diagnostics\n+            rv.processDiagnostics(dh);\n+\n+            if (code != ErrorCode.Success) {\n+                throw new ParsingFailedException(Path.of(file).toAbsolutePath(), code);\n+            }\n+\n+            translationUnits.add(rv);\n+            return rv;\n+        }\n+    }\n+\n+    private int defaultOptions(boolean detailedPreprocessorRecord) {\n+        int rv = Index_h.CXTranslationUnit_ForSerialization();\n+        rv |= Index_h.CXTranslationUnit_SkipFunctionBodies();\n+        if (detailedPreprocessorRecord) {\n+            rv |= Index_h.CXTranslationUnit_DetailedPreprocessingRecord();\n+        }\n+        return rv;\n+    }\n+\n+    public TranslationUnit parse(String file, Consumer<Diagnostic> dh, boolean detailedPreprocessorRecord, String... args)\n+    throws ParsingFailedException {\n+        return parseTU(file, dh, defaultOptions(detailedPreprocessorRecord), args);\n+    }\n+\n+    public TranslationUnit parse(String file, boolean detailedPreprocessorRecord, String... args)\n+    throws ParsingFailedException {\n+        return parse(file, dh -> {}, detailedPreprocessorRecord, args);\n+    }\n+\n+    @Override\n+    public void close() {\n+        dispose();\n+    }\n+\n+    public void dispose() {\n+        for (TranslationUnit tu: translationUnits) {\n+            tu.dispose();\n+        }\n+        if (ptr != MemoryAddress.NULL) {\n+            Index_h.clang_disposeIndex(ptr);\n+        }\n+        ptr = MemoryAddress.NULL;\n+    }\n+\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/Index.java","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.clang;\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.LibraryLookup;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.internal.clang.libclang.Index_h;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+\n+public class LibClang {\n+    private static final boolean DEBUG = Boolean.getBoolean(\"libclang.debug\");\n+    private static final boolean CRASH_RECOVERY = Boolean.getBoolean(\"libclang.crash_recovery\");\n+    private static final boolean IS_WINDOWS = System.getProperty(\"os.name\").startsWith(\"Windows\");\n+\n+    private final static MemorySegment disableCrashRecovery =\n+            CLinker.toCString(\"LIBCLANG_DISABLE_CRASH_RECOVERY=\" + CRASH_RECOVERY)\n+                .withAccessModes(MemorySegment.READ);\n+\n+    static {\n+        if (!CRASH_RECOVERY) {\n+            \/\/this is an hack - needed because clang_toggleCrashRecovery only takes effect _after_ the\n+            \/\/first call to createIndex.\n+            try {\n+                CLinker linker = CLinker.getInstance();\n+                String putenv = IS_WINDOWS ? \"_putenv\" : \"putenv\";\n+                MethodHandle PUT_ENV = linker.downcallHandle(LibraryLookup.ofDefault().lookup(putenv).get(),\n+                                MethodType.methodType(int.class, MemoryAddress.class),\n+                                FunctionDescriptor.of(CLinker.C_INT, CLinker.C_POINTER));\n+                int res = (int) PUT_ENV.invokeExact(disableCrashRecovery.address());\n+            } catch (Throwable ex) {\n+                throw new ExceptionInInitializerError(ex);\n+            }\n+        }\n+    }\n+\n+    public static Index createIndex(boolean local) {\n+        Index index = new Index(Index_h.clang_createIndex(local ? 1 : 0, 0));\n+        if (DEBUG) {\n+            System.err.println(\"LibClang crash recovery \" + (CRASH_RECOVERY ? \"enabled\" : \"disabled\"));\n+        }\n+        return index;\n+    }\n+\n+    public static String CXStrToString(MemorySegment cxstr) {\n+        MemoryAddress buf = Index_h.clang_getCString(cxstr);\n+        String str = CLinker.toJavaStringRestricted(buf);\n+        Index_h.clang_disposeString(cxstr);\n+        return str;\n+    }\n+\n+    public static String version() {\n+        return CXStrToString(Index_h.clang_getClangVersion());\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/LibClang.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.clang;\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.internal.clang.libclang.Index_h;\n+\n+public final class PrintingPolicy implements AutoCloseable {\n+    private MemoryAddress policy;\n+\n+    PrintingPolicy(MemoryAddress policy) {\n+        this.policy = policy;\n+    }\n+\n+    MemoryAddress ptr() {\n+        return policy;\n+    }\n+\n+    @Override\n+    public void close() {\n+        dispose();\n+    }\n+\n+    public void dispose() {\n+        if (policy != MemoryAddress.NULL) {\n+            Index_h.clang_PrintingPolicy_dispose(policy);\n+            policy = MemoryAddress.NULL;\n+        }\n+    }\n+\n+    public boolean getProperty(PrintingPolicyProperty prop) {\n+        return Index_h.clang_PrintingPolicy_getProperty(policy, prop.value()) != 0;\n+    }\n+\n+    public void setProperty(PrintingPolicyProperty prop, boolean value) {\n+        Index_h.clang_PrintingPolicy_setProperty(policy, prop.value(), value? 1 : 0);\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/PrintingPolicy.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.clang;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+public enum PrintingPolicyProperty {\n+    Indentation(0),\n+    SuppressSpecifiers(1),\n+    SuppressTagKeyword(2),\n+    IncludeTagDefinition(3),\n+    SuppressScope(4),\n+    SuppressUnwrittenScope(5),\n+    SuppressInitializers(6),\n+    ConstantArraySizeAsWritten(7),\n+    AnonymousTagLocations(8),\n+    SuppressStrongLifetime(9),\n+    SuppressLifetimeQualifiers(10),\n+    SuppressTemplateArgsInCXXConstructors(11),\n+    Bool(12),\n+    Restrict(13),\n+    Alignof(14),\n+    UnderscoreAlignof(15),\n+    UseVoidForZeroParams(16),\n+    TerseOutput(17),\n+    PolishForDeclaration(18),\n+    Half(19),\n+    MSWChar(20),\n+    IncludeNewlines(21),\n+    MSVCFormatting(22),\n+    ConstantsAsWritten(23),\n+    SuppressImplicitBase(24),\n+    FullyQualifiedName(25),\n+    LastProperty(25);\n+\n+    private final int value;\n+\n+    PrintingPolicyProperty(int value) {\n+        this.value = value;\n+    }\n+\n+    public int value() {\n+        return value;\n+    }\n+\n+    private final static Map<Integer, PrintingPolicyProperty> lookup;\n+\n+    static {\n+        lookup = new HashMap<>();\n+        for (PrintingPolicyProperty e: PrintingPolicyProperty.values()) {\n+            lookup.put(e.value(), e);\n+        }\n+    }\n+\n+    public final static PrintingPolicyProperty valueOf(int value) {\n+        PrintingPolicyProperty x = lookup.get(value);\n+        if (null == x) {\n+            throw new NoSuchElementException(\"Invalid PrintingPolicyProperty value: \" + value);\n+        }\n+        return x;\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/PrintingPolicyProperty.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.clang;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+public enum RefQualifierKind {\n+    \/** No ref-qualifier was provided. *\/\n+    CXRefQualifier_None(0),\n+    \/** An lvalue ref-qualifier was provided (\\c &). *\/\n+    CXRefQualifier_LValue(1),\n+    \/** An rvalue ref-qualifier was provided (\\c &&). *\/\n+    CXRefQualifier_RValue(2);\n+\n+    private final int value;\n+\n+    RefQualifierKind(int value) {\n+        this.value = value;\n+    }\n+\n+    public int value() {\n+        return value;\n+    }\n+\n+    private final static Map<Integer, RefQualifierKind> lookup;\n+\n+    static {\n+        lookup = new HashMap<>();\n+        for (RefQualifierKind e: RefQualifierKind.values()) {\n+            lookup.put(e.value(), e);\n+        }\n+    }\n+\n+    public final static RefQualifierKind valueOf(int value) {\n+        RefQualifierKind x = lookup.get(value);\n+        if (null == x) {\n+            throw new NoSuchElementException(\"Invalid RefQualifierKind kind value: \" + value);\n+        }\n+        return x;\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/RefQualifierKind.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.clang;\n+\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.function.Function;\n+\n+import static java.util.stream.Collectors.toMap;\n+import static jdk.internal.clang.libclang.Index_h.CXSaveError_InvalidTU;\n+import static jdk.internal.clang.libclang.Index_h.CXSaveError_None;\n+import static jdk.internal.clang.libclang.Index_h.CXSaveError_TranslationErrors;\n+import static jdk.internal.clang.libclang.Index_h.CXSaveError_Unknown;\n+\n+public enum SaveError {\n+    None(CXSaveError_None()),\n+    Unknown(CXSaveError_Unknown()),\n+    TranslationErrors(CXSaveError_TranslationErrors()),\n+    InvalidTU(CXSaveError_InvalidTU());\n+\n+    private final int code;\n+\n+    SaveError(int code) {\n+        this.code = code;\n+    }\n+\n+    public int code() {\n+        return code;\n+    }\n+\n+    private static final Map<Integer, SaveError> lookup = Arrays.stream(values())\n+            .collect(toMap(SaveError::code, Function.identity()));\n+\n+    public static SaveError valueOf(int code) {\n+        return lookup.computeIfAbsent(code, k -> { throw new NoSuchElementException(\"No SaveError with code: \" + k); });\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/SaveError.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.clang;\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.internal.clang.libclang.Index_h;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Objects;\n+\n+public class SourceLocation {\n+\n+    private final MemorySegment loc;\n+\n+    SourceLocation(MemorySegment loc) {\n+        this.loc = loc;\n+    }\n+\n+    @FunctionalInterface\n+    private interface LocationFactory {\n+        void get(MemorySegment loc, Addressable file,\n+                 Addressable line, Addressable column, Addressable offset);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private Location getLocation(LocationFactory fn) {\n+        try (MemorySegment file = MemorySegment.allocateNative(CLinker.C_POINTER);\n+             MemorySegment line = MemorySegment.allocateNative(CLinker.C_INT);\n+             MemorySegment col = MemorySegment.allocateNative(CLinker.C_INT);\n+             MemorySegment offset = MemorySegment.allocateNative(CLinker.C_INT)) {\n+\n+            fn.get(loc, file, line, col, offset);\n+            MemoryAddress fname = MemoryAccess.getAddress(file);\n+\n+\n+            String str = fname == MemoryAddress.NULL ?\n+                    null :\n+                    LibClang.CXStrToString(Index_h.clang_getFileName(fname));\n+\n+            return new Location(str, MemoryAccess.getInt(line),\n+                MemoryAccess.getInt(col), MemoryAccess.getInt(offset));\n+        }\n+    }\n+\n+    public Location getFileLocation() { return getLocation(Index_h::clang_getFileLocation); }\n+    public Location getExpansionLocation() { return getLocation(Index_h::clang_getExpansionLocation); }\n+    public Location getSpellingLocation() { return getLocation(Index_h::clang_getSpellingLocation); }\n+    public boolean isInSystemHeader() {\n+        return Index_h.clang_Location_isInSystemHeader(loc) != 0;\n+    }\n+\n+    public boolean isFromMainFile() {\n+        return Index_h.clang_Location_isFromMainFile(loc) != 0;\n+    }\n+\n+    @Override\n+    public boolean equals(Object other) {\n+        if (this == other) {\n+            return true;\n+        }\n+        if (!(other instanceof SourceLocation)) {\n+            return false;\n+        }\n+        SourceLocation sloc = (SourceLocation)other;\n+        return Objects.equals(getFileLocation(), sloc.getFileLocation());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return getFileLocation().hashCode();\n+    }\n+\n+    public final static class Location {\n+        private final Path path;\n+        private final int line;\n+        private final int column;\n+        private final int offset;\n+\n+        private Location(String filename, int line, int column, int offset) {\n+            if (filename == null || filename.isEmpty()) {\n+                this.path = null;\n+            } else {\n+                this.path = Paths.get(filename);\n+            }\n+\n+            this.line = line;\n+            this.column = column;\n+            this.offset = offset;\n+        }\n+\n+        public Path path() {\n+            return path;\n+        }\n+\n+        public int line() {\n+            return line;\n+        }\n+\n+        public int column() {\n+            return column;\n+        }\n+\n+        public int offset() {\n+            return offset;\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            if (this == other) {\n+                return true;\n+            }\n+            if (!(other instanceof Location)) {\n+                return false;\n+            }\n+            Location loc = (Location)other;\n+            return Objects.equals(path, loc.path) &&\n+                line == loc.line && column == loc.column &&\n+                offset == loc.offset;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hashCode(path) ^ line ^ column ^ offset;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return Objects.toString(path) + \":\" + line + \":\" + column + \":\" + offset;\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/SourceLocation.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.clang;\n+\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.internal.clang.libclang.Index_h;\n+\n+public class SourceRange {\n+    final MemorySegment range;\n+\n+    SourceRange(MemorySegment range) {\n+        this.range = range;\n+    }\n+\n+    public SourceLocation getBegin() {\n+        MemorySegment loc = Index_h.clang_getRangeStart(range);\n+        return new SourceLocation(loc);\n+    }\n+\n+    public SourceLocation getEnd() {\n+        MemorySegment loc = Index_h.clang_getRangeEnd(range);\n+        return new SourceLocation(loc);\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/SourceRange.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.clang;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+\/**\n+ * Describes the kind of a template argument.\n+ *\/\n+public enum TemplateArgumentKind {\n+    Null(0),\n+    Type(1),\n+    Declaration(2),\n+    NullPtr(3),\n+    Integral(4),\n+    Template(5),\n+    TemplateExpansion(6),\n+    Expression(7),\n+    Pack(8),\n+    \/* Indicates an error case, preventing the kind from being deduced. *\/\n+    Invalid(9);\n+\n+    private final int value;\n+\n+    TemplateArgumentKind(int value) {\n+        this.value = value;\n+    }\n+\n+    public int value() {\n+        return value;\n+    }\n+\n+    private final static Map<Integer, TemplateArgumentKind> lookup;\n+\n+    static {\n+        lookup = new HashMap<>();\n+        for (TemplateArgumentKind e: TemplateArgumentKind.values()) {\n+            lookup.put(e.value(), e);\n+        }\n+    }\n+\n+    public final static TemplateArgumentKind valueOf(int value) {\n+        TemplateArgumentKind x = lookup.get(value);\n+        if (null == x) {\n+            throw new NoSuchElementException(\"Invalid TemplateArgumentKind kind value: \" + value);\n+        }\n+        return x;\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/TemplateArgumentKind.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,223 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.clang;\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.NativeScope;\n+import jdk.internal.clang.libclang.Index_h;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+\n+public class TranslationUnit implements AutoCloseable {\n+\n+    private MemoryAddress tu;\n+\n+    TranslationUnit(MemoryAddress tu) {\n+        this.tu = tu;\n+    }\n+\n+    public Cursor getCursor() {\n+        return new Cursor(Index_h.clang_getTranslationUnitCursor(tu));\n+    }\n+\n+    public Diagnostic[] getDiagnostics() {\n+        int cntDiags = Index_h.clang_getNumDiagnostics(tu);\n+        Diagnostic[] rv = new Diagnostic[cntDiags];\n+        for (int i = 0; i < cntDiags; i++) {\n+            MemoryAddress diag = Index_h.clang_getDiagnostic(tu, i);\n+            rv[i] = new Diagnostic(diag);\n+        }\n+\n+        return rv;\n+    }\n+\n+    public final void save(Path path) throws TranslationUnitSaveException {\n+        try (MemorySegment pathStr = CLinker.toCString(path.toAbsolutePath().toString())) {\n+            SaveError res = SaveError.valueOf(Index_h.clang_saveTranslationUnit(tu, pathStr, 0));\n+            if (res != SaveError.None) {\n+                throw new TranslationUnitSaveException(path, res);\n+            }\n+        }\n+    }\n+\n+    void processDiagnostics(Consumer<Diagnostic> dh) {\n+        Objects.requireNonNull(dh);\n+        for (Diagnostic diag : getDiagnostics()) {\n+            dh.accept(diag);\n+        }\n+    }\n+\n+    static long FILENAME_OFFSET = Index_h.CXUnsavedFile.$LAYOUT().bitOffset(MemoryLayout.PathElement.groupElement(\"Filename\")) \/ 8;\n+    static long CONTENTS_OFFSET = Index_h.CXUnsavedFile.$LAYOUT().bitOffset(MemoryLayout.PathElement.groupElement(\"Contents\")) \/ 8;\n+    static long LENGTH_OFFSET = Index_h.CXUnsavedFile.$LAYOUT().bitOffset(MemoryLayout.PathElement.groupElement(\"Length\")) \/ 8;\n+\n+    public void reparse(Index.UnsavedFile... inMemoryFiles) {\n+        try (NativeScope scope = NativeScope.unboundedScope()) {\n+            MemorySegment files = inMemoryFiles.length == 0 ?\n+                    null :\n+                    scope.allocateArray(Index_h.CXUnsavedFile.$LAYOUT(), inMemoryFiles.length);\n+            for (int i = 0; i < inMemoryFiles.length; i++) {\n+                MemorySegment start = files.asSlice(i * Index_h.CXUnsavedFile.$LAYOUT().byteSize());\n+                MemoryAccess.setAddress(start.asSlice(FILENAME_OFFSET), CLinker.toCString(inMemoryFiles[i].file, scope));\n+                MemoryAccess.setAddress(start.asSlice(CONTENTS_OFFSET), CLinker.toCString(inMemoryFiles[i].contents, scope));\n+                MemoryAccess.setLong(start.asSlice(LENGTH_OFFSET), inMemoryFiles[i].contents.length());\n+            }\n+            ErrorCode code = ErrorCode.valueOf(Index_h.clang_reparseTranslationUnit(\n+                        tu,\n+                        inMemoryFiles.length,\n+                        files == null ? MemoryAddress.NULL : files,\n+                        Index_h.clang_defaultReparseOptions(tu)));\n+\n+            if (code != ErrorCode.Success) {\n+                throw new IllegalStateException(\"Re-parsing failed: \" + code);\n+            }\n+        }\n+    }\n+\n+    public void reparse(Consumer<Diagnostic> dh, Index.UnsavedFile... inMemoryFiles) {\n+        reparse(inMemoryFiles);\n+        processDiagnostics(dh);\n+    }\n+\n+    public String[] tokens(SourceRange range) {\n+        Tokens tokens = tokenize(range);\n+        String rv[] = new String[tokens.size()];\n+        for (int i = 0; i < rv.length; i++) {\n+            rv[i] = tokens.getToken(i).spelling();\n+        }\n+        return rv;\n+    }\n+\n+    public Tokens tokenize(SourceRange range) {\n+        MemorySegment p = MemorySegment.allocateNative(CLinker.C_POINTER);\n+        MemorySegment pCnt = MemorySegment.allocateNative(CLinker.C_INT);\n+        Index_h.clang_tokenize(tu, range.range, p, pCnt);\n+        Tokens rv = new Tokens(MemoryAccess.getAddress(p), MemoryAccess.getInt(pCnt));\n+        return rv;\n+    }\n+\n+    @Override\n+    public void close() {\n+        dispose();\n+    }\n+\n+    public void dispose() {\n+        if (tu != MemoryAddress.NULL) {\n+            Index_h.clang_disposeTranslationUnit(tu);\n+            tu = MemoryAddress.NULL;\n+        }\n+    }\n+\n+    public class Tokens {\n+        private final MemoryAddress ar;\n+        private final int size;\n+\n+        Tokens(MemoryAddress ar, int size) {\n+            this.ar = ar;\n+            this.size = size;\n+        }\n+\n+        public void dispose() {\n+            Index_h.clang_disposeTokens(tu, ar, size);\n+        }\n+\n+        public int size() {\n+            return size;\n+        }\n+\n+        public MemorySegment getTokenSegment(int idx) {\n+            MemoryAddress p = ar.addOffset(idx * Index_h.CXToken.$LAYOUT().byteSize());\n+            return p.asSegmentRestricted(Index_h.CXToken.$LAYOUT().byteSize())\n+                    .share();\n+        }\n+\n+        public Token getToken(int index) {\n+            return new Token(getTokenSegment(index));\n+        }\n+\n+        @Override\n+        public String toString() {\n+            StringBuilder sb = new StringBuilder();\n+            for (int i = 0; i < size; i++) {\n+                MemorySegment s = Index_h.clang_getTokenSpelling(tu, getTokenSegment(i));\n+                sb.append(\"Token[\");\n+                sb.append(i);\n+                sb.append(\"]=\");\n+                sb.append(LibClang.CXStrToString(s));\n+                sb.append(\"\\n\");\n+            }\n+            return sb.toString();\n+        }\n+    }\n+\n+    public class Token {\n+        final MemorySegment token;\n+\n+        Token(MemorySegment token) {\n+            this.token = token;\n+        }\n+\n+        public int kind() {\n+            return Index_h.clang_getTokenKind(token);\n+        }\n+\n+        public String spelling() {\n+            MemorySegment s = Index_h.clang_getTokenSpelling(\n+                    tu, token);\n+            return LibClang.CXStrToString(s);\n+        }\n+\n+        public SourceLocation getLocation() {\n+            return new SourceLocation(Index_h.clang_getTokenLocation(\n+                    tu, token));\n+        }\n+\n+        public SourceRange getExtent() {\n+            return new SourceRange(Index_h.clang_getTokenExtent(\n+                    tu, token));\n+        }\n+    }\n+\n+    public static class TranslationUnitSaveException extends IOException {\n+\n+        static final long serialVersionUID = 1L;\n+\n+        private final SaveError error;\n+\n+        TranslationUnitSaveException(Path path, SaveError error) {\n+            super(\"Cannot save translation unit to: \" + path.toAbsolutePath() + \". Error: \" + error);\n+            this.error = error;\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/TranslationUnit.java","additions":223,"deletions":0,"binary":false,"changes":223,"status":"added"},{"patch":"@@ -0,0 +1,234 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.clang;\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.internal.clang.libclang.Index_h;\n+\n+\n+public final class Type {\n+    private final MemorySegment type;\n+    Type(MemorySegment type) {\n+        this.type = type;\n+    }\n+\n+    public boolean isInvalid() {\n+        return kind() == TypeKind.Invalid;\n+    }\n+\n+    \/\/ Function Types\n+    public boolean isVariadic() {\n+        return Index_h.clang_isFunctionTypeVariadic(type) != 0;\n+    }\n+    public Type resultType() {\n+        return new Type(Index_h.clang_getResultType(type));\n+    }\n+    public int numberOfArgs() {\n+        return Index_h.clang_getNumArgTypes(type);\n+    }\n+    public Type argType(int idx) {\n+        return new Type(Index_h.clang_getArgType(type, idx));\n+    }\n+    private int getCallingConvention0() {\n+        return Index_h.clang_getFunctionTypeCallingConv(type);\n+    }\n+\n+    public CallingConvention getCallingConvention() {\n+        int v = getCallingConvention0();\n+        return CallingConvention.valueOf(v);\n+    }\n+\n+    \/**\n+     * Retrieve the ref-qualifier kind of a function or method.\n+     *\n+     * The ref-qualifier is returned for C++ functions or methods. For other types\n+     * or non-C++ declarations, CXRefQualifier_None is returned.\n+     *\/\n+    public RefQualifierKind getRefQualifier() {\n+        int refKind = Index_h.clang_Type_getCXXRefQualifier(type);\n+        return RefQualifierKind.valueOf(refKind);\n+    }\n+\n+    public boolean isPointer() {\n+        var kind = kind();\n+        return kind == TypeKind.Pointer ||\n+            kind == TypeKind.BlockPointer || kind == TypeKind.MemberPointer;\n+    }\n+\n+    public boolean isReference() {\n+        var kind = kind();\n+        return kind == TypeKind.LValueReference || kind == TypeKind.RValueReference;\n+    }\n+\n+    public boolean isArray() {\n+        var kind = kind();\n+        return kind == TypeKind.ConstantArray ||\n+           kind == TypeKind.IncompleteArray ||\n+           kind == TypeKind.VariableArray ||\n+           kind == TypeKind.DependentSizedArray;\n+    }\n+\n+    \/\/ Pointer type\n+    public Type getPointeeType() {\n+        return new Type(Index_h.clang_getPointeeType(type));\n+    }\n+\n+    \/\/ array\/vector type\n+    public Type getElementType() {\n+        return new Type(Index_h.clang_getElementType(type));\n+    }\n+\n+    public long getNumberOfElements() {\n+        return Index_h.clang_getNumElements(type);\n+    }\n+\n+    \/\/ Struct\/RecordType\n+    private long getOffsetOf0(String fieldName) {\n+        try (MemorySegment cfname = CLinker.toCString(fieldName)) {\n+            return Index_h.clang_Type_getOffsetOf(type, cfname);\n+        }\n+    }\n+\n+    public long getOffsetOf(String fieldName) {\n+        long res = getOffsetOf0(fieldName);\n+        if(TypeLayoutError.isError(res)) {\n+            throw new TypeLayoutError(res, String.format(\"type: %s, fieldName: %s\", this, fieldName));\n+        }\n+        return res;\n+    }\n+\n+    \/\/ Typedef\n+    \/**\n+     * Return the canonical type for a Type.\n+     *\n+     * Clang's type system explicitly models typedefs and all the ways\n+     * a specific type can be represented.  The canonical type is the underlying\n+     * type with all the \"sugar\" removed.  For example, if 'T' is a typedef\n+     * for 'int', the canonical type for 'T' would be 'int'.\n+     *\/\n+    public Type canonicalType() {\n+        return new Type(Index_h.clang_getCanonicalType(type));\n+    }\n+\n+    \/**\n+     * Determine whether a Type has the \"const\" qualifier set,\n+     * without looking through typedefs that may have added \"const\" at a\n+     * different level.\n+     *\/\n+    public boolean isConstQualifierdType() {\n+        return Index_h.clang_isConstQualifiedType(type) != 0;\n+    }\n+\n+    \/**\n+     * Determine whether a Type has the \"volatile\" qualifier set,\n+     * without looking through typedefs that may have added \"volatile\" at\n+     * a different level.\n+     *\/\n+    public boolean isVolatileQualified() {\n+        return Index_h.clang_isVolatileQualifiedType(type) != 0;\n+    }\n+\n+    \/**\n+     * Return true if the Type is a POD (plain old data) type, and false\n+     * otherwise.\n+     *\/\n+    public boolean isPODType() {\n+        return Index_h.clang_isPODType(type) != 0;\n+    }\n+\n+    \/\/ Template support\n+    \/**\n+     * Returns the number of template arguments for given template\n+     * specialization, or -1 if type \\c T is not a template specialization.\n+     *\/\n+    public int numberOfTemplateArgs() {\n+        return Index_h.clang_Type_getNumTemplateArguments(type);\n+    }\n+\n+    \/**\n+     * Returns the type template argument of a template class specialization\n+     * at given index.\n+     *\n+     * This function only returns template type arguments and does not handle\n+     * template template arguments or variadic packs.\n+     *\/\n+    public Type templateArgAsType(int idx) {\n+        return new Type(Index_h.clang_Type_getTemplateArgumentAsType(type, idx));\n+    }\n+\n+    public String spelling() {\n+        return LibClang.CXStrToString(Index_h.clang_getTypeSpelling(type));\n+    }\n+\n+    public int kind0() {\n+        return Index_h.CXType.kind$get(type);\n+    }\n+\n+    private long size0() {\n+        return Index_h.clang_Type_getSizeOf(type);\n+    }\n+\n+    public long size() {\n+        long res = size0();\n+        if(TypeLayoutError.isError(res)) {\n+            throw new TypeLayoutError(res, String.format(\"type: %s\", this));\n+        }\n+        return res;\n+    }\n+\n+    public TypeKind kind() {\n+        int v = kind0();\n+        TypeKind rv = TypeKind.valueOf(v);\n+        \/\/ TODO: Atomic type doesn't work\n+        return rv;\n+    }\n+\n+    public Cursor getDeclarationCursor() {\n+        return new Cursor(Index_h.clang_getTypeDeclaration(type));\n+    }\n+\n+    public boolean equalType(Type other) {\n+        return Index_h.clang_equalTypes(type, other.type) != 0;\n+    }\n+\n+    @Override\n+    public boolean equals(Object other) {\n+        if (this == other) {\n+            return true;\n+        }\n+        if (!(other instanceof Type)) {\n+            return false;\n+        }\n+        return equalType((Type) other);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return spelling().hashCode();\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/Type.java","additions":234,"deletions":0,"binary":false,"changes":234,"status":"added"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.clang;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+public enum TypeKind {\n+\n+    Invalid(0),\n+    Unexposed(1),\n+    Void(2),\n+    Bool(3),\n+    Char_U(4),\n+    UChar(5),\n+    Char16(6),\n+    Char32(7),\n+    UShort(8),\n+    UInt(9),\n+    ULong(10),\n+    ULongLong(11),\n+    UInt128(12),\n+    Char_S(13),\n+    SChar(14),\n+    WChar(15),\n+    Short(16),\n+    Int(17),\n+    Long(18),\n+    LongLong(19),\n+    Int128(20),\n+    Float(21),\n+    Double(22),\n+    LongDouble(23),\n+    NullPtr(24),\n+    Overload(25),\n+    Dependent(26),\n+    ObjCId(27),\n+    ObjCClass(28),\n+    ObjCSel(29),\n+    Float128(30),\n+    Half(31),\n+    Float16(32),\n+    ShortAccum(33),\n+    Accum(34),\n+    LongAccum(35),\n+    UShortAccum(36),\n+    UAccum(37),\n+    ULongAccum(38),\n+    Complex(100),\n+    Pointer(101),\n+    BlockPointer(102),\n+    LValueReference(103),\n+    RValueReference(104),\n+    Record(105),\n+    Enum(106),\n+    Typedef(107),\n+    ObjCInterface(108),\n+    ObjCObjectPointer(109),\n+    FunctionNoProto(110),\n+    FunctionProto(111),\n+    ConstantArray(112),\n+    Vector(113),\n+    IncompleteArray(114),\n+    VariableArray(115),\n+    DependentSizedArray(116),\n+    MemberPointer(117),\n+    Auto(118),\n+    Elaborated(119),\n+    Pipe(120),\n+    OCLImage1dRO(121),\n+    OCLImage1dArrayRO(122),\n+    OCLImage1dBufferRO(123),\n+    OCLImage2dRO(124),\n+    OCLImage2dArrayRO(125),\n+    OCLImage2dDepthRO(126),\n+    OCLImage2dArrayDepthRO(127),\n+    OCLImage2dMSAARO(128),\n+    OCLImage2dArrayMSAARO(129),\n+    OCLImage2dMSAADepthRO(130),\n+    OCLImage2dArrayMSAADepthRO(131),\n+    OCLImage3dRO(132),\n+    OCLImage1dWO(133),\n+    OCLImage1dArrayWO(134),\n+    OCLImage1dBufferWO(135),\n+    OCLImage2dWO(136),\n+    OCLImage2dArrayWO(137),\n+    OCLImage2dDepthWO(138),\n+    OCLImage2dArrayDepthWO(139),\n+    OCLImage2dMSAAWO(140),\n+    OCLImage2dArrayMSAAWO(141),\n+    OCLImage2dMSAADepthWO(142),\n+    OCLImage2dArrayMSAADepthWO(143),\n+    OCLImage3dWO(144),\n+    OCLImage1dRW(145),\n+    OCLImage1dArrayRW(146),\n+    OCLImage1dBufferRW(147),\n+    OCLImage2dRW(148),\n+    OCLImage2dArrayRW(149),\n+    OCLImage2dDepthRW(150),\n+    OCLImage2dArrayDepthRW(151),\n+    OCLImage2dMSAARW(152),\n+    OCLImage2dArrayMSAARW(153),\n+    OCLImage2dMSAADepthRW(154),\n+    OCLImage2dArrayMSAADepthRW(155),\n+    OCLImage3dRW(156),\n+    OCLSampler(157),\n+    OCLEvent(158),\n+    OCLQueue(159),\n+    OCLReserveID(160),\n+    ObjCObject(161),\n+    ObjCTypeParam(162),\n+    Attributed(163),\n+    OCLIntelSubgroupAVCMcePayload(164),\n+    OCLIntelSubgroupAVCImePayload(165),\n+    OCLIntelSubgroupAVCRefPayload(166),\n+    OCLIntelSubgroupAVCSicPayload(167),\n+    OCLIntelSubgroupAVCMceResult(168),\n+    OCLIntelSubgroupAVCImeResult(169),\n+    OCLIntelSubgroupAVCRefResult(170),\n+    OCLIntelSubgroupAVCSicResult(171),\n+    OCLIntelSubgroupAVCImeResultSingleRefStreamout(172),\n+    OCLIntelSubgroupAVCImeResultDualRefStreamout(173),\n+    OCLIntelSubgroupAVCImeSingleRefStreamin(174),\n+    OCLIntelSubgroupAVCImeDualRefStreamin(175),\n+    ExtVector(176),\n+    Atomic(177);\n+\n+    private final int value;\n+\n+    TypeKind(int value) {\n+        this.value = value;\n+    }\n+\n+    public int value() {\n+        return value;\n+    }\n+\n+    private final static Map<Integer, TypeKind> lookup;\n+\n+    static {\n+        lookup = new HashMap<>();\n+        for (TypeKind e: TypeKind.values()) {\n+            lookup.put(e.value(), e);\n+        }\n+    }\n+\n+    public final static TypeKind valueOf(int value) {\n+        TypeKind x = lookup.get(value);\n+        if (null == x) {\n+            throw new NoSuchElementException(\"kind = \" + value);\n+        }\n+        return x;\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/TypeKind.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.clang;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+public class TypeLayoutError extends IllegalStateException {\n+\n+    private static final long serialVersionUID = 0L;\n+\n+    private final Kind kind;\n+\n+    public TypeLayoutError(long value, String message) {\n+        super(Kind.valueOf(value) + \". \" + message);\n+        this.kind = Kind.valueOf(value);\n+    }\n+\n+    public Kind kind() {\n+        return kind;\n+    }\n+\n+    public static boolean isError(long value) {\n+        return Kind.isError(value);\n+    }\n+\n+    public enum Kind {\n+        Invalid(-1),\n+        Incomplete(-2),\n+        Dependent(-3),\n+        NotConstantSize(-4),\n+        InvalidFieldName(-5);\n+\n+        private final long value;\n+\n+        Kind(long value) {\n+            this.value = value;\n+        }\n+\n+        private final static Map<Long, Kind> lookup;\n+\n+        static {\n+            lookup = new HashMap<>();\n+            for (Kind e: Kind.values()) {\n+                lookup.put(e.value, e);\n+            }\n+        }\n+\n+        public final static Kind valueOf(long value) {\n+            Kind x = lookup.get(value);\n+            if (null == x) {\n+                throw new NoSuchElementException(\"TypeLayoutError = \" + value);\n+            }\n+            return x;\n+        }\n+\n+        public static boolean isError(long value) {\n+            return lookup.containsKey(value);\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/TypeLayoutError.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,12328 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package jdk.internal.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+public class Index_h extends Index_h_1 {\n+\n+    \/* package-private *\/ Index_h() {}\n+    public static int CINDEX_VERSION_MAJOR() {\n+        return (int)0L;\n+    }\n+    public static int CINDEX_VERSION_MINOR() {\n+        return (int)59L;\n+    }\n+    public static int CXError_Success() {\n+        return (int)0L;\n+    }\n+    public static int CXError_Failure() {\n+        return (int)1L;\n+    }\n+    public static int CXError_Crashed() {\n+        return (int)2L;\n+    }\n+    public static int CXError_InvalidArguments() {\n+        return (int)3L;\n+    }\n+    public static int CXError_ASTReadError() {\n+        return (int)4L;\n+    }\n+    public static class CXString {\n+\n+        static final MemoryLayout CXString$struct$LAYOUT = MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        );\n+        public static MemoryLayout $LAYOUT() {\n+            return CXString.CXString$struct$LAYOUT;\n+        }\n+        static final VarHandle data$VH = MemoryHandles.asAddressVarHandle(CXString$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"data\")));\n+        public static VarHandle data$VH() {\n+            return CXString.data$VH;\n+        }\n+        public static MemoryAddress data$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXString.data$VH.get(seg);\n+        }\n+        public static void data$set( MemorySegment seg, MemoryAddress x) {\n+            CXString.data$VH.set(seg, x);\n+        }\n+        public static MemoryAddress data$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXString.data$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void data$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXString.data$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle private_flags$VH = CXString$struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"private_flags\"));\n+        public static VarHandle private_flags$VH() {\n+            return CXString.private_flags$VH;\n+        }\n+        public static int private_flags$get(MemorySegment seg) {\n+            return (int)CXString.private_flags$VH.get(seg);\n+        }\n+        public static void private_flags$set( MemorySegment seg, int x) {\n+            CXString.private_flags$VH.set(seg, x);\n+        }\n+        public static int private_flags$get(MemorySegment seg, long index) {\n+            return (int)CXString.private_flags$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void private_flags$set(MemorySegment seg, long index, int x) {\n+            CXString.private_flags$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public static long sizeof() { return $LAYOUT().byteSize(); }\n+        public static MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\n+        public static MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n+        public static MemorySegment allocateArray(int len) {\n+            return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }        public static MemorySegment allocateArray(int len, NativeScope scope) {\n+            return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }\n+        public static MemorySegment allocatePointer() {\n+            return MemorySegment.allocateNative(C_POINTER);\n+        }\n+        public static MemorySegment allocatePointer(NativeScope scope) {\n+            return scope.allocate(C_POINTER);\n+        }\n+        public static MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\n+    }\n+\n+    public static class CXStringSet {\n+\n+        static final MemoryLayout CXStringSet$struct$LAYOUT = MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"Strings\"),\n+            C_INT.withName(\"Count\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        );\n+        public static MemoryLayout $LAYOUT() {\n+            return CXStringSet.CXStringSet$struct$LAYOUT;\n+        }\n+        static final VarHandle Strings$VH = MemoryHandles.asAddressVarHandle(CXStringSet$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"Strings\")));\n+        public static VarHandle Strings$VH() {\n+            return CXStringSet.Strings$VH;\n+        }\n+        public static MemoryAddress Strings$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXStringSet.Strings$VH.get(seg);\n+        }\n+        public static void Strings$set( MemorySegment seg, MemoryAddress x) {\n+            CXStringSet.Strings$VH.set(seg, x);\n+        }\n+        public static MemoryAddress Strings$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXStringSet.Strings$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void Strings$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXStringSet.Strings$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle Count$VH = CXStringSet$struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"Count\"));\n+        public static VarHandle Count$VH() {\n+            return CXStringSet.Count$VH;\n+        }\n+        public static int Count$get(MemorySegment seg) {\n+            return (int)CXStringSet.Count$VH.get(seg);\n+        }\n+        public static void Count$set( MemorySegment seg, int x) {\n+            CXStringSet.Count$VH.set(seg, x);\n+        }\n+        public static int Count$get(MemorySegment seg, long index) {\n+            return (int)CXStringSet.Count$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void Count$set(MemorySegment seg, long index, int x) {\n+            CXStringSet.Count$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public static long sizeof() { return $LAYOUT().byteSize(); }\n+        public static MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\n+        public static MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n+        public static MemorySegment allocateArray(int len) {\n+            return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }        public static MemorySegment allocateArray(int len, NativeScope scope) {\n+            return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }\n+        public static MemorySegment allocatePointer() {\n+            return MemorySegment.allocateNative(C_POINTER);\n+        }\n+        public static MemorySegment allocatePointer(NativeScope scope) {\n+            return scope.allocate(C_POINTER);\n+        }\n+        public static MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\n+    }\n+\n+    public static MethodHandle clang_getCString$MH() {\n+        return RuntimeHelper.requireNonNull(constants$0.clang_getCString$MH,\"clang_getCString\");\n+    }\n+    public static MemoryAddress clang_getCString ( MemorySegment string) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$0.clang_getCString$MH, \"clang_getCString\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(string);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_disposeString$MH() {\n+        return RuntimeHelper.requireNonNull(constants$0.clang_disposeString$MH,\"clang_disposeString\");\n+    }\n+    public static void clang_disposeString ( MemorySegment string) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$0.clang_disposeString$MH, \"clang_disposeString\");\n+        try {\n+            mh$.invokeExact(string);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_disposeStringSet$MH() {\n+        return RuntimeHelper.requireNonNull(constants$0.clang_disposeStringSet$MH,\"clang_disposeStringSet\");\n+    }\n+    public static void clang_disposeStringSet ( Addressable set) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$0.clang_disposeStringSet$MH, \"clang_disposeStringSet\");\n+        try {\n+            mh$.invokeExact(set.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class CXUnsavedFile {\n+\n+        static final MemoryLayout CXUnsavedFile$struct$LAYOUT = MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"Filename\"),\n+            C_POINTER.withName(\"Contents\"),\n+            C_LONG_LONG.withName(\"Length\")\n+        ).withName(\"CXUnsavedFile\");\n+        public static MemoryLayout $LAYOUT() {\n+            return CXUnsavedFile.CXUnsavedFile$struct$LAYOUT;\n+        }\n+        static final VarHandle Filename$VH = MemoryHandles.asAddressVarHandle(CXUnsavedFile$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"Filename\")));\n+        public static VarHandle Filename$VH() {\n+            return CXUnsavedFile.Filename$VH;\n+        }\n+        public static MemoryAddress Filename$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXUnsavedFile.Filename$VH.get(seg);\n+        }\n+        public static void Filename$set( MemorySegment seg, MemoryAddress x) {\n+            CXUnsavedFile.Filename$VH.set(seg, x);\n+        }\n+        public static MemoryAddress Filename$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXUnsavedFile.Filename$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void Filename$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXUnsavedFile.Filename$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle Contents$VH = MemoryHandles.asAddressVarHandle(CXUnsavedFile$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"Contents\")));\n+        public static VarHandle Contents$VH() {\n+            return CXUnsavedFile.Contents$VH;\n+        }\n+        public static MemoryAddress Contents$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXUnsavedFile.Contents$VH.get(seg);\n+        }\n+        public static void Contents$set( MemorySegment seg, MemoryAddress x) {\n+            CXUnsavedFile.Contents$VH.set(seg, x);\n+        }\n+        public static MemoryAddress Contents$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXUnsavedFile.Contents$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void Contents$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXUnsavedFile.Contents$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle Length$VH = CXUnsavedFile$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"Length\"));\n+        public static VarHandle Length$VH() {\n+            return CXUnsavedFile.Length$VH;\n+        }\n+        public static long Length$get(MemorySegment seg) {\n+            return (long)CXUnsavedFile.Length$VH.get(seg);\n+        }\n+        public static void Length$set( MemorySegment seg, long x) {\n+            CXUnsavedFile.Length$VH.set(seg, x);\n+        }\n+        public static long Length$get(MemorySegment seg, long index) {\n+            return (long)CXUnsavedFile.Length$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void Length$set(MemorySegment seg, long index, long x) {\n+            CXUnsavedFile.Length$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public static long sizeof() { return $LAYOUT().byteSize(); }\n+        public static MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\n+        public static MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n+        public static MemorySegment allocateArray(int len) {\n+            return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }        public static MemorySegment allocateArray(int len, NativeScope scope) {\n+            return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }\n+        public static MemorySegment allocatePointer() {\n+            return MemorySegment.allocateNative(C_POINTER);\n+        }\n+        public static MemorySegment allocatePointer(NativeScope scope) {\n+            return scope.allocate(C_POINTER);\n+        }\n+        public static MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\n+    }\n+\n+    public static int CXAvailability_Available() {\n+        return (int)0L;\n+    }\n+    public static int CXAvailability_Deprecated() {\n+        return (int)1L;\n+    }\n+    public static int CXAvailability_NotAvailable() {\n+        return (int)2L;\n+    }\n+    public static int CXAvailability_NotAccessible() {\n+        return (int)3L;\n+    }\n+    public static class CXVersion {\n+\n+        static final MemoryLayout CXVersion$struct$LAYOUT = MemoryLayout.ofStruct(\n+            C_INT.withName(\"Major\"),\n+            C_INT.withName(\"Minor\"),\n+            C_INT.withName(\"Subminor\")\n+        ).withName(\"CXVersion\");\n+        public static MemoryLayout $LAYOUT() {\n+            return CXVersion.CXVersion$struct$LAYOUT;\n+        }\n+        static final VarHandle Major$VH = CXVersion$struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"Major\"));\n+        public static VarHandle Major$VH() {\n+            return CXVersion.Major$VH;\n+        }\n+        public static int Major$get(MemorySegment seg) {\n+            return (int)CXVersion.Major$VH.get(seg);\n+        }\n+        public static void Major$set( MemorySegment seg, int x) {\n+            CXVersion.Major$VH.set(seg, x);\n+        }\n+        public static int Major$get(MemorySegment seg, long index) {\n+            return (int)CXVersion.Major$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void Major$set(MemorySegment seg, long index, int x) {\n+            CXVersion.Major$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle Minor$VH = CXVersion$struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"Minor\"));\n+        public static VarHandle Minor$VH() {\n+            return CXVersion.Minor$VH;\n+        }\n+        public static int Minor$get(MemorySegment seg) {\n+            return (int)CXVersion.Minor$VH.get(seg);\n+        }\n+        public static void Minor$set( MemorySegment seg, int x) {\n+            CXVersion.Minor$VH.set(seg, x);\n+        }\n+        public static int Minor$get(MemorySegment seg, long index) {\n+            return (int)CXVersion.Minor$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void Minor$set(MemorySegment seg, long index, int x) {\n+            CXVersion.Minor$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle Subminor$VH = CXVersion$struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"Subminor\"));\n+        public static VarHandle Subminor$VH() {\n+            return CXVersion.Subminor$VH;\n+        }\n+        public static int Subminor$get(MemorySegment seg) {\n+            return (int)CXVersion.Subminor$VH.get(seg);\n+        }\n+        public static void Subminor$set( MemorySegment seg, int x) {\n+            CXVersion.Subminor$VH.set(seg, x);\n+        }\n+        public static int Subminor$get(MemorySegment seg, long index) {\n+            return (int)CXVersion.Subminor$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void Subminor$set(MemorySegment seg, long index, int x) {\n+            CXVersion.Subminor$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public static long sizeof() { return $LAYOUT().byteSize(); }\n+        public static MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\n+        public static MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n+        public static MemorySegment allocateArray(int len) {\n+            return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }        public static MemorySegment allocateArray(int len, NativeScope scope) {\n+            return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }\n+        public static MemorySegment allocatePointer() {\n+            return MemorySegment.allocateNative(C_POINTER);\n+        }\n+        public static MemorySegment allocatePointer(NativeScope scope) {\n+            return scope.allocate(C_POINTER);\n+        }\n+        public static MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\n+    }\n+\n+    public static int CXCursor_ExceptionSpecificationKind_None() {\n+        return (int)0L;\n+    }\n+    public static int CXCursor_ExceptionSpecificationKind_DynamicNone() {\n+        return (int)1L;\n+    }\n+    public static int CXCursor_ExceptionSpecificationKind_Dynamic() {\n+        return (int)2L;\n+    }\n+    public static int CXCursor_ExceptionSpecificationKind_MSAny() {\n+        return (int)3L;\n+    }\n+    public static int CXCursor_ExceptionSpecificationKind_BasicNoexcept() {\n+        return (int)4L;\n+    }\n+    public static int CXCursor_ExceptionSpecificationKind_ComputedNoexcept() {\n+        return (int)5L;\n+    }\n+    public static int CXCursor_ExceptionSpecificationKind_Unevaluated() {\n+        return (int)6L;\n+    }\n+    public static int CXCursor_ExceptionSpecificationKind_Uninstantiated() {\n+        return (int)7L;\n+    }\n+    public static int CXCursor_ExceptionSpecificationKind_Unparsed() {\n+        return (int)8L;\n+    }\n+    public static int CXCursor_ExceptionSpecificationKind_NoThrow() {\n+        return (int)9L;\n+    }\n+    public static MethodHandle clang_createIndex$MH() {\n+        return RuntimeHelper.requireNonNull(constants$0.clang_createIndex$MH,\"clang_createIndex\");\n+    }\n+    public static MemoryAddress clang_createIndex ( int excludeDeclarationsFromPCH,  int displayDiagnostics) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$0.clang_createIndex$MH, \"clang_createIndex\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(excludeDeclarationsFromPCH, displayDiagnostics);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_disposeIndex$MH() {\n+        return RuntimeHelper.requireNonNull(constants$0.clang_disposeIndex$MH,\"clang_disposeIndex\");\n+    }\n+    public static void clang_disposeIndex ( Addressable index) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$0.clang_disposeIndex$MH, \"clang_disposeIndex\");\n+        try {\n+            mh$.invokeExact(index.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXGlobalOpt_None() {\n+        return (int)0L;\n+    }\n+    public static int CXGlobalOpt_ThreadBackgroundPriorityForIndexing() {\n+        return (int)1L;\n+    }\n+    public static int CXGlobalOpt_ThreadBackgroundPriorityForEditing() {\n+        return (int)2L;\n+    }\n+    public static int CXGlobalOpt_ThreadBackgroundPriorityForAll() {\n+        return (int)3L;\n+    }\n+    public static MethodHandle clang_CXIndex_setGlobalOptions$MH() {\n+        return RuntimeHelper.requireNonNull(constants$0.clang_CXIndex_setGlobalOptions$MH,\"clang_CXIndex_setGlobalOptions\");\n+    }\n+    public static void clang_CXIndex_setGlobalOptions ( Addressable x0,  int options) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$0.clang_CXIndex_setGlobalOptions$MH, \"clang_CXIndex_setGlobalOptions\");\n+        try {\n+            mh$.invokeExact(x0.address(), options);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$0 {\n+\n+        static final FunctionDescriptor clang_getCString$FUNC = FunctionDescriptor.of(C_POINTER,\n+            MemoryLayout.ofStruct(\n+                C_POINTER.withName(\"data\"),\n+                C_INT.withName(\"private_flags\"),\n+                MemoryLayout.ofPaddingBits(32)\n+            )\n+        );\n+        static final MethodHandle clang_getCString$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCString\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$0.clang_getCString$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_disposeString$FUNC = FunctionDescriptor.ofVoid(\n+            MemoryLayout.ofStruct(\n+                C_POINTER.withName(\"data\"),\n+                C_INT.withName(\"private_flags\"),\n+                MemoryLayout.ofPaddingBits(32)\n+            )\n+        );\n+        static final MethodHandle clang_disposeString$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_disposeString\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)V\",\n+            constants$0.clang_disposeString$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_disposeStringSet$FUNC = FunctionDescriptor.ofVoid(\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_disposeStringSet$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_disposeStringSet\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)V\",\n+            constants$0.clang_disposeStringSet$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_createIndex$FUNC = FunctionDescriptor.of(C_POINTER,\n+            C_INT,\n+            C_INT\n+        );\n+        static final MethodHandle clang_createIndex$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_createIndex\",\n+            \"(II)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$0.clang_createIndex$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_disposeIndex$FUNC = FunctionDescriptor.ofVoid(\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_disposeIndex$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_disposeIndex\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)V\",\n+            constants$0.clang_disposeIndex$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_CXIndex_setGlobalOptions$FUNC = FunctionDescriptor.ofVoid(\n+            C_POINTER,\n+            C_INT\n+        );\n+        static final MethodHandle clang_CXIndex_setGlobalOptions$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_CXIndex_setGlobalOptions\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;I)V\",\n+            constants$0.clang_CXIndex_setGlobalOptions$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_CXIndex_getGlobalOptions$MH() {\n+        return RuntimeHelper.requireNonNull(constants$1.clang_CXIndex_getGlobalOptions$MH,\"clang_CXIndex_getGlobalOptions\");\n+    }\n+    public static int clang_CXIndex_getGlobalOptions ( Addressable x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$1.clang_CXIndex_getGlobalOptions$MH, \"clang_CXIndex_getGlobalOptions\");\n+        try {\n+            return (int)mh$.invokeExact(x0.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_CXIndex_setInvocationEmissionPathOption$MH() {\n+        return RuntimeHelper.requireNonNull(constants$1.clang_CXIndex_setInvocationEmissionPathOption$MH,\"clang_CXIndex_setInvocationEmissionPathOption\");\n+    }\n+    public static void clang_CXIndex_setInvocationEmissionPathOption ( Addressable x0,  Addressable Path) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$1.clang_CXIndex_setInvocationEmissionPathOption$MH, \"clang_CXIndex_setInvocationEmissionPathOption\");\n+        try {\n+            mh$.invokeExact(x0.address(), Path.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getFileName$MH() {\n+        return RuntimeHelper.requireNonNull(constants$1.clang_getFileName$MH,\"clang_getFileName\");\n+    }\n+    public static MemorySegment clang_getFileName ( Addressable SFile) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$1.clang_getFileName$MH, \"clang_getFileName\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(SFile.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getFileTime$MH() {\n+        return RuntimeHelper.requireNonNull(constants$1.clang_getFileTime$MH,\"clang_getFileTime\");\n+    }\n+    public static long clang_getFileTime ( Addressable SFile) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$1.clang_getFileTime$MH, \"clang_getFileTime\");\n+        try {\n+            return (long)mh$.invokeExact(SFile.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class CXFileUniqueID {\n+\n+        static final MemoryLayout CXFileUniqueID$struct$LAYOUT = MemoryLayout.ofStruct(\n+            MemoryLayout.ofSequence(3, C_LONG_LONG).withName(\"data\")\n+        );\n+        public static MemoryLayout $LAYOUT() {\n+            return CXFileUniqueID.CXFileUniqueID$struct$LAYOUT;\n+        }\n+        public static MemorySegment data$slice(MemorySegment seg) {\n+            return RuntimeHelper.nonCloseableNonTransferableSegment(seg.asSlice(0, 24));\n+        }\n+        public static long sizeof() { return $LAYOUT().byteSize(); }\n+        public static MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\n+        public static MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n+        public static MemorySegment allocateArray(int len) {\n+            return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }        public static MemorySegment allocateArray(int len, NativeScope scope) {\n+            return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }\n+        public static MemorySegment allocatePointer() {\n+            return MemorySegment.allocateNative(C_POINTER);\n+        }\n+        public static MemorySegment allocatePointer(NativeScope scope) {\n+            return scope.allocate(C_POINTER);\n+        }\n+        public static MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\n+    }\n+\n+    public static MethodHandle clang_getFileUniqueID$MH() {\n+        return RuntimeHelper.requireNonNull(constants$1.clang_getFileUniqueID$MH,\"clang_getFileUniqueID\");\n+    }\n+    public static int clang_getFileUniqueID ( Addressable file,  Addressable outID) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$1.clang_getFileUniqueID$MH, \"clang_getFileUniqueID\");\n+        try {\n+            return (int)mh$.invokeExact(file.address(), outID.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_isFileMultipleIncludeGuarded$MH() {\n+        return RuntimeHelper.requireNonNull(constants$1.clang_isFileMultipleIncludeGuarded$MH,\"clang_isFileMultipleIncludeGuarded\");\n+    }\n+    public static int clang_isFileMultipleIncludeGuarded ( Addressable tu,  Addressable file) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$1.clang_isFileMultipleIncludeGuarded$MH, \"clang_isFileMultipleIncludeGuarded\");\n+        try {\n+            return (int)mh$.invokeExact(tu.address(), file.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$1 {\n+\n+        static final FunctionDescriptor clang_CXIndex_getGlobalOptions$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_CXIndex_getGlobalOptions$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_CXIndex_getGlobalOptions\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+            constants$1.clang_CXIndex_getGlobalOptions$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_CXIndex_setInvocationEmissionPathOption$FUNC = FunctionDescriptor.ofVoid(\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_CXIndex_setInvocationEmissionPathOption$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_CXIndex_setInvocationEmissionPathOption\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)V\",\n+            constants$1.clang_CXIndex_setInvocationEmissionPathOption$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getFileName$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getFileName$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getFileName\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$1.clang_getFileName$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getFileTime$FUNC = FunctionDescriptor.of(C_LONG_LONG,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getFileTime$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getFileTime\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)J\",\n+            constants$1.clang_getFileTime$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getFileUniqueID$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getFileUniqueID$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getFileUniqueID\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+            constants$1.clang_getFileUniqueID$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_isFileMultipleIncludeGuarded$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_isFileMultipleIncludeGuarded$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_isFileMultipleIncludeGuarded\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+            constants$1.clang_isFileMultipleIncludeGuarded$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_getFile$MH() {\n+        return RuntimeHelper.requireNonNull(constants$2.clang_getFile$MH,\"clang_getFile\");\n+    }\n+    public static MemoryAddress clang_getFile ( Addressable tu,  Addressable file_name) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$2.clang_getFile$MH, \"clang_getFile\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(tu.address(), file_name.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getFileContents$MH() {\n+        return RuntimeHelper.requireNonNull(constants$2.clang_getFileContents$MH,\"clang_getFileContents\");\n+    }\n+    public static MemoryAddress clang_getFileContents ( Addressable tu,  Addressable file,  Addressable size) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$2.clang_getFileContents$MH, \"clang_getFileContents\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(tu.address(), file.address(), size.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_File_isEqual$MH() {\n+        return RuntimeHelper.requireNonNull(constants$2.clang_File_isEqual$MH,\"clang_File_isEqual\");\n+    }\n+    public static int clang_File_isEqual ( Addressable file1,  Addressable file2) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$2.clang_File_isEqual$MH, \"clang_File_isEqual\");\n+        try {\n+            return (int)mh$.invokeExact(file1.address(), file2.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_File_tryGetRealPathName$MH() {\n+        return RuntimeHelper.requireNonNull(constants$2.clang_File_tryGetRealPathName$MH,\"clang_File_tryGetRealPathName\");\n+    }\n+    public static MemorySegment clang_File_tryGetRealPathName ( Addressable file) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$2.clang_File_tryGetRealPathName$MH, \"clang_File_tryGetRealPathName\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(file.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class CXSourceLocation {\n+\n+        static final MemoryLayout CXSourceLocation$struct$LAYOUT = MemoryLayout.ofStruct(\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+            C_INT.withName(\"int_data\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        );\n+        public static MemoryLayout $LAYOUT() {\n+            return CXSourceLocation.CXSourceLocation$struct$LAYOUT;\n+        }\n+        public static MemorySegment ptr_data$slice(MemorySegment seg) {\n+            return RuntimeHelper.nonCloseableNonTransferableSegment(seg.asSlice(0, 16));\n+        }\n+        static final VarHandle int_data$VH = CXSourceLocation$struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"int_data\"));\n+        public static VarHandle int_data$VH() {\n+            return CXSourceLocation.int_data$VH;\n+        }\n+        public static int int_data$get(MemorySegment seg) {\n+            return (int)CXSourceLocation.int_data$VH.get(seg);\n+        }\n+        public static void int_data$set( MemorySegment seg, int x) {\n+            CXSourceLocation.int_data$VH.set(seg, x);\n+        }\n+        public static int int_data$get(MemorySegment seg, long index) {\n+            return (int)CXSourceLocation.int_data$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void int_data$set(MemorySegment seg, long index, int x) {\n+            CXSourceLocation.int_data$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public static long sizeof() { return $LAYOUT().byteSize(); }\n+        public static MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\n+        public static MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n+        public static MemorySegment allocateArray(int len) {\n+            return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }        public static MemorySegment allocateArray(int len, NativeScope scope) {\n+            return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }\n+        public static MemorySegment allocatePointer() {\n+            return MemorySegment.allocateNative(C_POINTER);\n+        }\n+        public static MemorySegment allocatePointer(NativeScope scope) {\n+            return scope.allocate(C_POINTER);\n+        }\n+        public static MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\n+    }\n+\n+    public static class CXSourceRange {\n+\n+        static final MemoryLayout CXSourceRange$struct$LAYOUT = MemoryLayout.ofStruct(\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+            C_INT.withName(\"begin_int_data\"),\n+            C_INT.withName(\"end_int_data\")\n+        );\n+        public static MemoryLayout $LAYOUT() {\n+            return CXSourceRange.CXSourceRange$struct$LAYOUT;\n+        }\n+        public static MemorySegment ptr_data$slice(MemorySegment seg) {\n+            return RuntimeHelper.nonCloseableNonTransferableSegment(seg.asSlice(0, 16));\n+        }\n+        static final VarHandle begin_int_data$VH = CXSourceRange$struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"begin_int_data\"));\n+        public static VarHandle begin_int_data$VH() {\n+            return CXSourceRange.begin_int_data$VH;\n+        }\n+        public static int begin_int_data$get(MemorySegment seg) {\n+            return (int)CXSourceRange.begin_int_data$VH.get(seg);\n+        }\n+        public static void begin_int_data$set( MemorySegment seg, int x) {\n+            CXSourceRange.begin_int_data$VH.set(seg, x);\n+        }\n+        public static int begin_int_data$get(MemorySegment seg, long index) {\n+            return (int)CXSourceRange.begin_int_data$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void begin_int_data$set(MemorySegment seg, long index, int x) {\n+            CXSourceRange.begin_int_data$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle end_int_data$VH = CXSourceRange$struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"end_int_data\"));\n+        public static VarHandle end_int_data$VH() {\n+            return CXSourceRange.end_int_data$VH;\n+        }\n+        public static int end_int_data$get(MemorySegment seg) {\n+            return (int)CXSourceRange.end_int_data$VH.get(seg);\n+        }\n+        public static void end_int_data$set( MemorySegment seg, int x) {\n+            CXSourceRange.end_int_data$VH.set(seg, x);\n+        }\n+        public static int end_int_data$get(MemorySegment seg, long index) {\n+            return (int)CXSourceRange.end_int_data$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void end_int_data$set(MemorySegment seg, long index, int x) {\n+            CXSourceRange.end_int_data$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public static long sizeof() { return $LAYOUT().byteSize(); }\n+        public static MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\n+        public static MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n+        public static MemorySegment allocateArray(int len) {\n+            return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }        public static MemorySegment allocateArray(int len, NativeScope scope) {\n+            return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }\n+        public static MemorySegment allocatePointer() {\n+            return MemorySegment.allocateNative(C_POINTER);\n+        }\n+        public static MemorySegment allocatePointer(NativeScope scope) {\n+            return scope.allocate(C_POINTER);\n+        }\n+        public static MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\n+    }\n+\n+    public static MethodHandle clang_getNullLocation$MH() {\n+        return RuntimeHelper.requireNonNull(constants$2.clang_getNullLocation$MH,\"clang_getNullLocation\");\n+    }\n+    public static MemorySegment clang_getNullLocation () {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$2.clang_getNullLocation$MH, \"clang_getNullLocation\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact();\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_equalLocations$MH() {\n+        return RuntimeHelper.requireNonNull(constants$2.clang_equalLocations$MH,\"clang_equalLocations\");\n+    }\n+    public static int clang_equalLocations ( MemorySegment loc1,  MemorySegment loc2) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$2.clang_equalLocations$MH, \"clang_equalLocations\");\n+        try {\n+            return (int)mh$.invokeExact(loc1, loc2);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$2 {\n+\n+        static final FunctionDescriptor clang_getFile$FUNC = FunctionDescriptor.of(C_POINTER,\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getFile$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getFile\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$2.clang_getFile$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getFileContents$FUNC = FunctionDescriptor.of(C_POINTER,\n+            C_POINTER,\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getFileContents$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getFileContents\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$2.clang_getFileContents$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_File_isEqual$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_File_isEqual$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_File_isEqual\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+            constants$2.clang_File_isEqual$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_File_tryGetRealPathName$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_File_tryGetRealPathName$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_File_tryGetRealPathName\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$2.clang_File_tryGetRealPathName$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getNullLocation$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+            C_INT.withName(\"int_data\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ));\n+        static final MethodHandle clang_getNullLocation$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getNullLocation\",\n+            \"()Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$2.clang_getNullLocation$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_equalLocations$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+                C_INT.withName(\"int_data\"),\n+                MemoryLayout.ofPaddingBits(32)\n+            ),\n+            MemoryLayout.ofStruct(\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+                C_INT.withName(\"int_data\"),\n+                MemoryLayout.ofPaddingBits(32)\n+            )\n+        );\n+        static final MethodHandle clang_equalLocations$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_equalLocations\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$2.clang_equalLocations$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_getLocation$MH() {\n+        return RuntimeHelper.requireNonNull(constants$3.clang_getLocation$MH,\"clang_getLocation\");\n+    }\n+    public static MemorySegment clang_getLocation ( Addressable tu,  Addressable file,  int line,  int column) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$3.clang_getLocation$MH, \"clang_getLocation\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(tu.address(), file.address(), line, column);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getLocationForOffset$MH() {\n+        return RuntimeHelper.requireNonNull(constants$3.clang_getLocationForOffset$MH,\"clang_getLocationForOffset\");\n+    }\n+    public static MemorySegment clang_getLocationForOffset ( Addressable tu,  Addressable file,  int offset) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$3.clang_getLocationForOffset$MH, \"clang_getLocationForOffset\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(tu.address(), file.address(), offset);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Location_isInSystemHeader$MH() {\n+        return RuntimeHelper.requireNonNull(constants$3.clang_Location_isInSystemHeader$MH,\"clang_Location_isInSystemHeader\");\n+    }\n+    public static int clang_Location_isInSystemHeader ( MemorySegment location) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$3.clang_Location_isInSystemHeader$MH, \"clang_Location_isInSystemHeader\");\n+        try {\n+            return (int)mh$.invokeExact(location);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Location_isFromMainFile$MH() {\n+        return RuntimeHelper.requireNonNull(constants$3.clang_Location_isFromMainFile$MH,\"clang_Location_isFromMainFile\");\n+    }\n+    public static int clang_Location_isFromMainFile ( MemorySegment location) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$3.clang_Location_isFromMainFile$MH, \"clang_Location_isFromMainFile\");\n+        try {\n+            return (int)mh$.invokeExact(location);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getNullRange$MH() {\n+        return RuntimeHelper.requireNonNull(constants$3.clang_getNullRange$MH,\"clang_getNullRange\");\n+    }\n+    public static MemorySegment clang_getNullRange () {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$3.clang_getNullRange$MH, \"clang_getNullRange\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact();\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getRange$MH() {\n+        return RuntimeHelper.requireNonNull(constants$3.clang_getRange$MH,\"clang_getRange\");\n+    }\n+    public static MemorySegment clang_getRange ( MemorySegment begin,  MemorySegment end) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$3.clang_getRange$MH, \"clang_getRange\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(begin, end);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$3 {\n+\n+        static final FunctionDescriptor clang_getLocation$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+            C_INT.withName(\"int_data\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            C_POINTER,\n+            C_POINTER,\n+            C_INT,\n+            C_INT\n+        );\n+        static final MethodHandle clang_getLocation$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getLocation\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;II)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$3.clang_getLocation$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getLocationForOffset$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+            C_INT.withName(\"int_data\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            C_POINTER,\n+            C_POINTER,\n+            C_INT\n+        );\n+        static final MethodHandle clang_getLocationForOffset$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getLocationForOffset\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;I)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$3.clang_getLocationForOffset$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Location_isInSystemHeader$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+                C_INT.withName(\"int_data\"),\n+                MemoryLayout.ofPaddingBits(32)\n+            )\n+        );\n+        static final MethodHandle clang_Location_isInSystemHeader$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Location_isInSystemHeader\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$3.clang_Location_isInSystemHeader$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Location_isFromMainFile$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+                C_INT.withName(\"int_data\"),\n+                MemoryLayout.ofPaddingBits(32)\n+            )\n+        );\n+        static final MethodHandle clang_Location_isFromMainFile$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Location_isFromMainFile\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$3.clang_Location_isFromMainFile$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getNullRange$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+            C_INT.withName(\"begin_int_data\"),\n+            C_INT.withName(\"end_int_data\")\n+        ));\n+        static final MethodHandle clang_getNullRange$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getNullRange\",\n+            \"()Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$3.clang_getNullRange$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getRange$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+            C_INT.withName(\"begin_int_data\"),\n+            C_INT.withName(\"end_int_data\")\n+        ),\n+            MemoryLayout.ofStruct(\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+                C_INT.withName(\"int_data\"),\n+                MemoryLayout.ofPaddingBits(32)\n+            ),\n+            MemoryLayout.ofStruct(\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+                C_INT.withName(\"int_data\"),\n+                MemoryLayout.ofPaddingBits(32)\n+            )\n+        );\n+        static final MethodHandle clang_getRange$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getRange\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$3.clang_getRange$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_equalRanges$MH() {\n+        return RuntimeHelper.requireNonNull(constants$4.clang_equalRanges$MH,\"clang_equalRanges\");\n+    }\n+    public static int clang_equalRanges ( MemorySegment range1,  MemorySegment range2) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$4.clang_equalRanges$MH, \"clang_equalRanges\");\n+        try {\n+            return (int)mh$.invokeExact(range1, range2);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Range_isNull$MH() {\n+        return RuntimeHelper.requireNonNull(constants$4.clang_Range_isNull$MH,\"clang_Range_isNull\");\n+    }\n+    public static int clang_Range_isNull ( MemorySegment range) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$4.clang_Range_isNull$MH, \"clang_Range_isNull\");\n+        try {\n+            return (int)mh$.invokeExact(range);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getExpansionLocation$MH() {\n+        return RuntimeHelper.requireNonNull(constants$4.clang_getExpansionLocation$MH,\"clang_getExpansionLocation\");\n+    }\n+    public static void clang_getExpansionLocation ( MemorySegment location,  Addressable file,  Addressable line,  Addressable column,  Addressable offset) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$4.clang_getExpansionLocation$MH, \"clang_getExpansionLocation\");\n+        try {\n+            mh$.invokeExact(location, file.address(), line.address(), column.address(), offset.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getPresumedLocation$MH() {\n+        return RuntimeHelper.requireNonNull(constants$4.clang_getPresumedLocation$MH,\"clang_getPresumedLocation\");\n+    }\n+    public static void clang_getPresumedLocation ( MemorySegment location,  Addressable filename,  Addressable line,  Addressable column) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$4.clang_getPresumedLocation$MH, \"clang_getPresumedLocation\");\n+        try {\n+            mh$.invokeExact(location, filename.address(), line.address(), column.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getInstantiationLocation$MH() {\n+        return RuntimeHelper.requireNonNull(constants$4.clang_getInstantiationLocation$MH,\"clang_getInstantiationLocation\");\n+    }\n+    public static void clang_getInstantiationLocation ( MemorySegment location,  Addressable file,  Addressable line,  Addressable column,  Addressable offset) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$4.clang_getInstantiationLocation$MH, \"clang_getInstantiationLocation\");\n+        try {\n+            mh$.invokeExact(location, file.address(), line.address(), column.address(), offset.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getSpellingLocation$MH() {\n+        return RuntimeHelper.requireNonNull(constants$4.clang_getSpellingLocation$MH,\"clang_getSpellingLocation\");\n+    }\n+    public static void clang_getSpellingLocation ( MemorySegment location,  Addressable file,  Addressable line,  Addressable column,  Addressable offset) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$4.clang_getSpellingLocation$MH, \"clang_getSpellingLocation\");\n+        try {\n+            mh$.invokeExact(location, file.address(), line.address(), column.address(), offset.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$4 {\n+\n+        static final FunctionDescriptor clang_equalRanges$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+                C_INT.withName(\"begin_int_data\"),\n+                C_INT.withName(\"end_int_data\")\n+            ),\n+            MemoryLayout.ofStruct(\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+                C_INT.withName(\"begin_int_data\"),\n+                C_INT.withName(\"end_int_data\")\n+            )\n+        );\n+        static final MethodHandle clang_equalRanges$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_equalRanges\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$4.clang_equalRanges$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Range_isNull$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+                C_INT.withName(\"begin_int_data\"),\n+                C_INT.withName(\"end_int_data\")\n+            )\n+        );\n+        static final MethodHandle clang_Range_isNull$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Range_isNull\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$4.clang_Range_isNull$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getExpansionLocation$FUNC = FunctionDescriptor.ofVoid(\n+            MemoryLayout.ofStruct(\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+                C_INT.withName(\"int_data\"),\n+                MemoryLayout.ofPaddingBits(32)\n+            ),\n+            C_POINTER,\n+            C_POINTER,\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getExpansionLocation$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getExpansionLocation\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)V\",\n+            constants$4.clang_getExpansionLocation$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getPresumedLocation$FUNC = FunctionDescriptor.ofVoid(\n+            MemoryLayout.ofStruct(\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+                C_INT.withName(\"int_data\"),\n+                MemoryLayout.ofPaddingBits(32)\n+            ),\n+            C_POINTER,\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getPresumedLocation$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getPresumedLocation\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)V\",\n+            constants$4.clang_getPresumedLocation$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getInstantiationLocation$FUNC = FunctionDescriptor.ofVoid(\n+            MemoryLayout.ofStruct(\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+                C_INT.withName(\"int_data\"),\n+                MemoryLayout.ofPaddingBits(32)\n+            ),\n+            C_POINTER,\n+            C_POINTER,\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getInstantiationLocation$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getInstantiationLocation\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)V\",\n+            constants$4.clang_getInstantiationLocation$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getSpellingLocation$FUNC = FunctionDescriptor.ofVoid(\n+            MemoryLayout.ofStruct(\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+                C_INT.withName(\"int_data\"),\n+                MemoryLayout.ofPaddingBits(32)\n+            ),\n+            C_POINTER,\n+            C_POINTER,\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getSpellingLocation$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getSpellingLocation\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)V\",\n+            constants$4.clang_getSpellingLocation$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_getFileLocation$MH() {\n+        return RuntimeHelper.requireNonNull(constants$5.clang_getFileLocation$MH,\"clang_getFileLocation\");\n+    }\n+    public static void clang_getFileLocation ( MemorySegment location,  Addressable file,  Addressable line,  Addressable column,  Addressable offset) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$5.clang_getFileLocation$MH, \"clang_getFileLocation\");\n+        try {\n+            mh$.invokeExact(location, file.address(), line.address(), column.address(), offset.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getRangeStart$MH() {\n+        return RuntimeHelper.requireNonNull(constants$5.clang_getRangeStart$MH,\"clang_getRangeStart\");\n+    }\n+    public static MemorySegment clang_getRangeStart ( MemorySegment range) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$5.clang_getRangeStart$MH, \"clang_getRangeStart\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(range);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getRangeEnd$MH() {\n+        return RuntimeHelper.requireNonNull(constants$5.clang_getRangeEnd$MH,\"clang_getRangeEnd\");\n+    }\n+    public static MemorySegment clang_getRangeEnd ( MemorySegment range) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$5.clang_getRangeEnd$MH, \"clang_getRangeEnd\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(range);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class CXSourceRangeList {\n+\n+        static final MemoryLayout CXSourceRangeList$struct$LAYOUT = MemoryLayout.ofStruct(\n+            C_INT.withName(\"count\"),\n+            MemoryLayout.ofPaddingBits(32),\n+            C_POINTER.withName(\"ranges\")\n+        );\n+        public static MemoryLayout $LAYOUT() {\n+            return CXSourceRangeList.CXSourceRangeList$struct$LAYOUT;\n+        }\n+        static final VarHandle count$VH = CXSourceRangeList$struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"count\"));\n+        public static VarHandle count$VH() {\n+            return CXSourceRangeList.count$VH;\n+        }\n+        public static int count$get(MemorySegment seg) {\n+            return (int)CXSourceRangeList.count$VH.get(seg);\n+        }\n+        public static void count$set( MemorySegment seg, int x) {\n+            CXSourceRangeList.count$VH.set(seg, x);\n+        }\n+        public static int count$get(MemorySegment seg, long index) {\n+            return (int)CXSourceRangeList.count$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void count$set(MemorySegment seg, long index, int x) {\n+            CXSourceRangeList.count$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle ranges$VH = MemoryHandles.asAddressVarHandle(CXSourceRangeList$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"ranges\")));\n+        public static VarHandle ranges$VH() {\n+            return CXSourceRangeList.ranges$VH;\n+        }\n+        public static MemoryAddress ranges$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXSourceRangeList.ranges$VH.get(seg);\n+        }\n+        public static void ranges$set( MemorySegment seg, MemoryAddress x) {\n+            CXSourceRangeList.ranges$VH.set(seg, x);\n+        }\n+        public static MemoryAddress ranges$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXSourceRangeList.ranges$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void ranges$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXSourceRangeList.ranges$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public static long sizeof() { return $LAYOUT().byteSize(); }\n+        public static MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\n+        public static MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n+        public static MemorySegment allocateArray(int len) {\n+            return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }        public static MemorySegment allocateArray(int len, NativeScope scope) {\n+            return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }\n+        public static MemorySegment allocatePointer() {\n+            return MemorySegment.allocateNative(C_POINTER);\n+        }\n+        public static MemorySegment allocatePointer(NativeScope scope) {\n+            return scope.allocate(C_POINTER);\n+        }\n+        public static MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\n+    }\n+\n+    public static MethodHandle clang_getSkippedRanges$MH() {\n+        return RuntimeHelper.requireNonNull(constants$5.clang_getSkippedRanges$MH,\"clang_getSkippedRanges\");\n+    }\n+    public static MemoryAddress clang_getSkippedRanges ( Addressable tu,  Addressable file) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$5.clang_getSkippedRanges$MH, \"clang_getSkippedRanges\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(tu.address(), file.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getAllSkippedRanges$MH() {\n+        return RuntimeHelper.requireNonNull(constants$5.clang_getAllSkippedRanges$MH,\"clang_getAllSkippedRanges\");\n+    }\n+    public static MemoryAddress clang_getAllSkippedRanges ( Addressable tu) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$5.clang_getAllSkippedRanges$MH, \"clang_getAllSkippedRanges\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(tu.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_disposeSourceRangeList$MH() {\n+        return RuntimeHelper.requireNonNull(constants$5.clang_disposeSourceRangeList$MH,\"clang_disposeSourceRangeList\");\n+    }\n+    public static void clang_disposeSourceRangeList ( Addressable ranges) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$5.clang_disposeSourceRangeList$MH, \"clang_disposeSourceRangeList\");\n+        try {\n+            mh$.invokeExact(ranges.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXDiagnostic_Ignored() {\n+        return (int)0L;\n+    }\n+    public static int CXDiagnostic_Note() {\n+        return (int)1L;\n+    }\n+    public static int CXDiagnostic_Warning() {\n+        return (int)2L;\n+    }\n+    public static int CXDiagnostic_Error() {\n+        return (int)3L;\n+    }\n+    public static int CXDiagnostic_Fatal() {\n+        return (int)4L;\n+    }\n+    public static class constants$5 {\n+\n+        static final FunctionDescriptor clang_getFileLocation$FUNC = FunctionDescriptor.ofVoid(\n+            MemoryLayout.ofStruct(\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+                C_INT.withName(\"int_data\"),\n+                MemoryLayout.ofPaddingBits(32)\n+            ),\n+            C_POINTER,\n+            C_POINTER,\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getFileLocation$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getFileLocation\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)V\",\n+            constants$5.clang_getFileLocation$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getRangeStart$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+            C_INT.withName(\"int_data\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            MemoryLayout.ofStruct(\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+                C_INT.withName(\"begin_int_data\"),\n+                C_INT.withName(\"end_int_data\")\n+            )\n+        );\n+        static final MethodHandle clang_getRangeStart$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getRangeStart\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$5.clang_getRangeStart$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getRangeEnd$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+            C_INT.withName(\"int_data\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            MemoryLayout.ofStruct(\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+                C_INT.withName(\"begin_int_data\"),\n+                C_INT.withName(\"end_int_data\")\n+            )\n+        );\n+        static final MethodHandle clang_getRangeEnd$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getRangeEnd\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$5.clang_getRangeEnd$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getSkippedRanges$FUNC = FunctionDescriptor.of(C_POINTER,\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getSkippedRanges$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getSkippedRanges\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$5.clang_getSkippedRanges$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getAllSkippedRanges$FUNC = FunctionDescriptor.of(C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getAllSkippedRanges$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getAllSkippedRanges\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$5.clang_getAllSkippedRanges$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_disposeSourceRangeList$FUNC = FunctionDescriptor.ofVoid(\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_disposeSourceRangeList$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_disposeSourceRangeList\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)V\",\n+            constants$5.clang_disposeSourceRangeList$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_getNumDiagnosticsInSet$MH() {\n+        return RuntimeHelper.requireNonNull(constants$6.clang_getNumDiagnosticsInSet$MH,\"clang_getNumDiagnosticsInSet\");\n+    }\n+    public static int clang_getNumDiagnosticsInSet ( Addressable Diags) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$6.clang_getNumDiagnosticsInSet$MH, \"clang_getNumDiagnosticsInSet\");\n+        try {\n+            return (int)mh$.invokeExact(Diags.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getDiagnosticInSet$MH() {\n+        return RuntimeHelper.requireNonNull(constants$6.clang_getDiagnosticInSet$MH,\"clang_getDiagnosticInSet\");\n+    }\n+    public static MemoryAddress clang_getDiagnosticInSet ( Addressable Diags,  int Index) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$6.clang_getDiagnosticInSet$MH, \"clang_getDiagnosticInSet\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(Diags.address(), Index);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXLoadDiag_None() {\n+        return (int)0L;\n+    }\n+    public static int CXLoadDiag_Unknown() {\n+        return (int)1L;\n+    }\n+    public static int CXLoadDiag_CannotLoad() {\n+        return (int)2L;\n+    }\n+    public static int CXLoadDiag_InvalidFile() {\n+        return (int)3L;\n+    }\n+    public static MethodHandle clang_loadDiagnostics$MH() {\n+        return RuntimeHelper.requireNonNull(constants$6.clang_loadDiagnostics$MH,\"clang_loadDiagnostics\");\n+    }\n+    public static MemoryAddress clang_loadDiagnostics ( Addressable file,  Addressable error,  Addressable errorString) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$6.clang_loadDiagnostics$MH, \"clang_loadDiagnostics\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(file.address(), error.address(), errorString.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_disposeDiagnosticSet$MH() {\n+        return RuntimeHelper.requireNonNull(constants$6.clang_disposeDiagnosticSet$MH,\"clang_disposeDiagnosticSet\");\n+    }\n+    public static void clang_disposeDiagnosticSet ( Addressable Diags) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$6.clang_disposeDiagnosticSet$MH, \"clang_disposeDiagnosticSet\");\n+        try {\n+            mh$.invokeExact(Diags.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getChildDiagnostics$MH() {\n+        return RuntimeHelper.requireNonNull(constants$6.clang_getChildDiagnostics$MH,\"clang_getChildDiagnostics\");\n+    }\n+    public static MemoryAddress clang_getChildDiagnostics ( Addressable D) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$6.clang_getChildDiagnostics$MH, \"clang_getChildDiagnostics\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(D.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getNumDiagnostics$MH() {\n+        return RuntimeHelper.requireNonNull(constants$6.clang_getNumDiagnostics$MH,\"clang_getNumDiagnostics\");\n+    }\n+    public static int clang_getNumDiagnostics ( Addressable Unit) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$6.clang_getNumDiagnostics$MH, \"clang_getNumDiagnostics\");\n+        try {\n+            return (int)mh$.invokeExact(Unit.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$6 {\n+\n+        static final FunctionDescriptor clang_getNumDiagnosticsInSet$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getNumDiagnosticsInSet$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getNumDiagnosticsInSet\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+            constants$6.clang_getNumDiagnosticsInSet$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getDiagnosticInSet$FUNC = FunctionDescriptor.of(C_POINTER,\n+            C_POINTER,\n+            C_INT\n+        );\n+        static final MethodHandle clang_getDiagnosticInSet$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getDiagnosticInSet\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;I)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$6.clang_getDiagnosticInSet$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_loadDiagnostics$FUNC = FunctionDescriptor.of(C_POINTER,\n+            C_POINTER,\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_loadDiagnostics$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_loadDiagnostics\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$6.clang_loadDiagnostics$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_disposeDiagnosticSet$FUNC = FunctionDescriptor.ofVoid(\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_disposeDiagnosticSet$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_disposeDiagnosticSet\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)V\",\n+            constants$6.clang_disposeDiagnosticSet$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getChildDiagnostics$FUNC = FunctionDescriptor.of(C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getChildDiagnostics$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getChildDiagnostics\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$6.clang_getChildDiagnostics$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getNumDiagnostics$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getNumDiagnostics$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getNumDiagnostics\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+            constants$6.clang_getNumDiagnostics$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_getDiagnostic$MH() {\n+        return RuntimeHelper.requireNonNull(constants$7.clang_getDiagnostic$MH,\"clang_getDiagnostic\");\n+    }\n+    public static MemoryAddress clang_getDiagnostic ( Addressable Unit,  int Index) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$7.clang_getDiagnostic$MH, \"clang_getDiagnostic\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(Unit.address(), Index);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getDiagnosticSetFromTU$MH() {\n+        return RuntimeHelper.requireNonNull(constants$7.clang_getDiagnosticSetFromTU$MH,\"clang_getDiagnosticSetFromTU\");\n+    }\n+    public static MemoryAddress clang_getDiagnosticSetFromTU ( Addressable Unit) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$7.clang_getDiagnosticSetFromTU$MH, \"clang_getDiagnosticSetFromTU\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(Unit.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_disposeDiagnostic$MH() {\n+        return RuntimeHelper.requireNonNull(constants$7.clang_disposeDiagnostic$MH,\"clang_disposeDiagnostic\");\n+    }\n+    public static void clang_disposeDiagnostic ( Addressable Diagnostic) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$7.clang_disposeDiagnostic$MH, \"clang_disposeDiagnostic\");\n+        try {\n+            mh$.invokeExact(Diagnostic.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXDiagnostic_DisplaySourceLocation() {\n+        return (int)1L;\n+    }\n+    public static int CXDiagnostic_DisplayColumn() {\n+        return (int)2L;\n+    }\n+    public static int CXDiagnostic_DisplaySourceRanges() {\n+        return (int)4L;\n+    }\n+    public static int CXDiagnostic_DisplayOption() {\n+        return (int)8L;\n+    }\n+    public static int CXDiagnostic_DisplayCategoryId() {\n+        return (int)16L;\n+    }\n+    public static int CXDiagnostic_DisplayCategoryName() {\n+        return (int)32L;\n+    }\n+    public static MethodHandle clang_formatDiagnostic$MH() {\n+        return RuntimeHelper.requireNonNull(constants$7.clang_formatDiagnostic$MH,\"clang_formatDiagnostic\");\n+    }\n+    public static MemorySegment clang_formatDiagnostic ( Addressable Diagnostic,  int Options) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$7.clang_formatDiagnostic$MH, \"clang_formatDiagnostic\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(Diagnostic.address(), Options);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_defaultDiagnosticDisplayOptions$MH() {\n+        return RuntimeHelper.requireNonNull(constants$7.clang_defaultDiagnosticDisplayOptions$MH,\"clang_defaultDiagnosticDisplayOptions\");\n+    }\n+    public static int clang_defaultDiagnosticDisplayOptions () {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$7.clang_defaultDiagnosticDisplayOptions$MH, \"clang_defaultDiagnosticDisplayOptions\");\n+        try {\n+            return (int)mh$.invokeExact();\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getDiagnosticSeverity$MH() {\n+        return RuntimeHelper.requireNonNull(constants$7.clang_getDiagnosticSeverity$MH,\"clang_getDiagnosticSeverity\");\n+    }\n+    public static int clang_getDiagnosticSeverity ( Addressable x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$7.clang_getDiagnosticSeverity$MH, \"clang_getDiagnosticSeverity\");\n+        try {\n+            return (int)mh$.invokeExact(x0.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$7 {\n+\n+        static final FunctionDescriptor clang_getDiagnostic$FUNC = FunctionDescriptor.of(C_POINTER,\n+            C_POINTER,\n+            C_INT\n+        );\n+        static final MethodHandle clang_getDiagnostic$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getDiagnostic\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;I)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$7.clang_getDiagnostic$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getDiagnosticSetFromTU$FUNC = FunctionDescriptor.of(C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getDiagnosticSetFromTU$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getDiagnosticSetFromTU\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$7.clang_getDiagnosticSetFromTU$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_disposeDiagnostic$FUNC = FunctionDescriptor.ofVoid(\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_disposeDiagnostic$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_disposeDiagnostic\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)V\",\n+            constants$7.clang_disposeDiagnostic$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_formatDiagnostic$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            C_POINTER,\n+            C_INT\n+        );\n+        static final MethodHandle clang_formatDiagnostic$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_formatDiagnostic\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;I)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$7.clang_formatDiagnostic$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_defaultDiagnosticDisplayOptions$FUNC = FunctionDescriptor.of(C_INT);\n+        static final MethodHandle clang_defaultDiagnosticDisplayOptions$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_defaultDiagnosticDisplayOptions\",\n+            \"()I\",\n+            constants$7.clang_defaultDiagnosticDisplayOptions$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getDiagnosticSeverity$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getDiagnosticSeverity$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getDiagnosticSeverity\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+            constants$7.clang_getDiagnosticSeverity$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_getDiagnosticLocation$MH() {\n+        return RuntimeHelper.requireNonNull(constants$8.clang_getDiagnosticLocation$MH,\"clang_getDiagnosticLocation\");\n+    }\n+    public static MemorySegment clang_getDiagnosticLocation ( Addressable x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$8.clang_getDiagnosticLocation$MH, \"clang_getDiagnosticLocation\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(x0.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getDiagnosticSpelling$MH() {\n+        return RuntimeHelper.requireNonNull(constants$8.clang_getDiagnosticSpelling$MH,\"clang_getDiagnosticSpelling\");\n+    }\n+    public static MemorySegment clang_getDiagnosticSpelling ( Addressable x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$8.clang_getDiagnosticSpelling$MH, \"clang_getDiagnosticSpelling\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(x0.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getDiagnosticOption$MH() {\n+        return RuntimeHelper.requireNonNull(constants$8.clang_getDiagnosticOption$MH,\"clang_getDiagnosticOption\");\n+    }\n+    public static MemorySegment clang_getDiagnosticOption ( Addressable Diag,  Addressable Disable) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$8.clang_getDiagnosticOption$MH, \"clang_getDiagnosticOption\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(Diag.address(), Disable.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getDiagnosticCategory$MH() {\n+        return RuntimeHelper.requireNonNull(constants$8.clang_getDiagnosticCategory$MH,\"clang_getDiagnosticCategory\");\n+    }\n+    public static int clang_getDiagnosticCategory ( Addressable x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$8.clang_getDiagnosticCategory$MH, \"clang_getDiagnosticCategory\");\n+        try {\n+            return (int)mh$.invokeExact(x0.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getDiagnosticCategoryName$MH() {\n+        return RuntimeHelper.requireNonNull(constants$8.clang_getDiagnosticCategoryName$MH,\"clang_getDiagnosticCategoryName\");\n+    }\n+    public static MemorySegment clang_getDiagnosticCategoryName ( int Category) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$8.clang_getDiagnosticCategoryName$MH, \"clang_getDiagnosticCategoryName\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(Category);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getDiagnosticCategoryText$MH() {\n+        return RuntimeHelper.requireNonNull(constants$8.clang_getDiagnosticCategoryText$MH,\"clang_getDiagnosticCategoryText\");\n+    }\n+    public static MemorySegment clang_getDiagnosticCategoryText ( Addressable x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$8.clang_getDiagnosticCategoryText$MH, \"clang_getDiagnosticCategoryText\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(x0.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$8 {\n+\n+        static final FunctionDescriptor clang_getDiagnosticLocation$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+            C_INT.withName(\"int_data\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getDiagnosticLocation$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getDiagnosticLocation\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$8.clang_getDiagnosticLocation$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getDiagnosticSpelling$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getDiagnosticSpelling$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getDiagnosticSpelling\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$8.clang_getDiagnosticSpelling$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getDiagnosticOption$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getDiagnosticOption$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getDiagnosticOption\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$8.clang_getDiagnosticOption$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getDiagnosticCategory$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getDiagnosticCategory$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getDiagnosticCategory\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+            constants$8.clang_getDiagnosticCategory$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getDiagnosticCategoryName$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            C_INT\n+        );\n+        static final MethodHandle clang_getDiagnosticCategoryName$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getDiagnosticCategoryName\",\n+            \"(I)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$8.clang_getDiagnosticCategoryName$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getDiagnosticCategoryText$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getDiagnosticCategoryText$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getDiagnosticCategoryText\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$8.clang_getDiagnosticCategoryText$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_getDiagnosticNumRanges$MH() {\n+        return RuntimeHelper.requireNonNull(constants$9.clang_getDiagnosticNumRanges$MH,\"clang_getDiagnosticNumRanges\");\n+    }\n+    public static int clang_getDiagnosticNumRanges ( Addressable x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$9.clang_getDiagnosticNumRanges$MH, \"clang_getDiagnosticNumRanges\");\n+        try {\n+            return (int)mh$.invokeExact(x0.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getDiagnosticRange$MH() {\n+        return RuntimeHelper.requireNonNull(constants$9.clang_getDiagnosticRange$MH,\"clang_getDiagnosticRange\");\n+    }\n+    public static MemorySegment clang_getDiagnosticRange ( Addressable Diagnostic,  int Range) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$9.clang_getDiagnosticRange$MH, \"clang_getDiagnosticRange\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(Diagnostic.address(), Range);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getDiagnosticNumFixIts$MH() {\n+        return RuntimeHelper.requireNonNull(constants$9.clang_getDiagnosticNumFixIts$MH,\"clang_getDiagnosticNumFixIts\");\n+    }\n+    public static int clang_getDiagnosticNumFixIts ( Addressable Diagnostic) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$9.clang_getDiagnosticNumFixIts$MH, \"clang_getDiagnosticNumFixIts\");\n+        try {\n+            return (int)mh$.invokeExact(Diagnostic.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getDiagnosticFixIt$MH() {\n+        return RuntimeHelper.requireNonNull(constants$9.clang_getDiagnosticFixIt$MH,\"clang_getDiagnosticFixIt\");\n+    }\n+    public static MemorySegment clang_getDiagnosticFixIt ( Addressable Diagnostic,  int FixIt,  Addressable ReplacementRange) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$9.clang_getDiagnosticFixIt$MH, \"clang_getDiagnosticFixIt\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(Diagnostic.address(), FixIt, ReplacementRange.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getTranslationUnitSpelling$MH() {\n+        return RuntimeHelper.requireNonNull(constants$9.clang_getTranslationUnitSpelling$MH,\"clang_getTranslationUnitSpelling\");\n+    }\n+    public static MemorySegment clang_getTranslationUnitSpelling ( Addressable CTUnit) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$9.clang_getTranslationUnitSpelling$MH, \"clang_getTranslationUnitSpelling\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(CTUnit.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_createTranslationUnitFromSourceFile$MH() {\n+        return RuntimeHelper.requireNonNull(constants$9.clang_createTranslationUnitFromSourceFile$MH,\"clang_createTranslationUnitFromSourceFile\");\n+    }\n+    public static MemoryAddress clang_createTranslationUnitFromSourceFile ( Addressable CIdx,  Addressable source_filename,  int num_clang_command_line_args,  Addressable clang_command_line_args,  int num_unsaved_files,  Addressable unsaved_files) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$9.clang_createTranslationUnitFromSourceFile$MH, \"clang_createTranslationUnitFromSourceFile\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(CIdx.address(), source_filename.address(), num_clang_command_line_args, clang_command_line_args.address(), num_unsaved_files, unsaved_files.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$9 {\n+\n+        static final FunctionDescriptor clang_getDiagnosticNumRanges$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getDiagnosticNumRanges$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getDiagnosticNumRanges\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+            constants$9.clang_getDiagnosticNumRanges$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getDiagnosticRange$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+            C_INT.withName(\"begin_int_data\"),\n+            C_INT.withName(\"end_int_data\")\n+        ),\n+            C_POINTER,\n+            C_INT\n+        );\n+        static final MethodHandle clang_getDiagnosticRange$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getDiagnosticRange\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;I)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$9.clang_getDiagnosticRange$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getDiagnosticNumFixIts$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getDiagnosticNumFixIts$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getDiagnosticNumFixIts\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+            constants$9.clang_getDiagnosticNumFixIts$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getDiagnosticFixIt$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            C_POINTER,\n+            C_INT,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getDiagnosticFixIt$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getDiagnosticFixIt\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;ILjdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$9.clang_getDiagnosticFixIt$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getTranslationUnitSpelling$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getTranslationUnitSpelling$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getTranslationUnitSpelling\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$9.clang_getTranslationUnitSpelling$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_createTranslationUnitFromSourceFile$FUNC = FunctionDescriptor.of(C_POINTER,\n+            C_POINTER,\n+            C_POINTER,\n+            C_INT,\n+            C_POINTER,\n+            C_INT,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_createTranslationUnitFromSourceFile$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_createTranslationUnitFromSourceFile\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;ILjdk\/incubator\/foreign\/MemoryAddress;ILjdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$9.clang_createTranslationUnitFromSourceFile$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_createTranslationUnit$MH() {\n+        return RuntimeHelper.requireNonNull(constants$10.clang_createTranslationUnit$MH,\"clang_createTranslationUnit\");\n+    }\n+    public static MemoryAddress clang_createTranslationUnit ( Addressable CIdx,  Addressable ast_filename) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$10.clang_createTranslationUnit$MH, \"clang_createTranslationUnit\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(CIdx.address(), ast_filename.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_createTranslationUnit2$MH() {\n+        return RuntimeHelper.requireNonNull(constants$10.clang_createTranslationUnit2$MH,\"clang_createTranslationUnit2\");\n+    }\n+    public static int clang_createTranslationUnit2 ( Addressable CIdx,  Addressable ast_filename,  Addressable out_TU) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$10.clang_createTranslationUnit2$MH, \"clang_createTranslationUnit2\");\n+        try {\n+            return (int)mh$.invokeExact(CIdx.address(), ast_filename.address(), out_TU.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXTranslationUnit_None() {\n+        return (int)0L;\n+    }\n+    public static int CXTranslationUnit_DetailedPreprocessingRecord() {\n+        return (int)1L;\n+    }\n+    public static int CXTranslationUnit_Incomplete() {\n+        return (int)2L;\n+    }\n+    public static int CXTranslationUnit_PrecompiledPreamble() {\n+        return (int)4L;\n+    }\n+    public static int CXTranslationUnit_CacheCompletionResults() {\n+        return (int)8L;\n+    }\n+    public static int CXTranslationUnit_ForSerialization() {\n+        return (int)16L;\n+    }\n+    public static int CXTranslationUnit_CXXChainedPCH() {\n+        return (int)32L;\n+    }\n+    public static int CXTranslationUnit_SkipFunctionBodies() {\n+        return (int)64L;\n+    }\n+    public static int CXTranslationUnit_IncludeBriefCommentsInCodeCompletion() {\n+        return (int)128L;\n+    }\n+    public static int CXTranslationUnit_CreatePreambleOnFirstParse() {\n+        return (int)256L;\n+    }\n+    public static int CXTranslationUnit_KeepGoing() {\n+        return (int)512L;\n+    }\n+    public static int CXTranslationUnit_SingleFileParse() {\n+        return (int)1024L;\n+    }\n+    public static int CXTranslationUnit_LimitSkipFunctionBodiesToPreamble() {\n+        return (int)2048L;\n+    }\n+    public static int CXTranslationUnit_IncludeAttributedTypes() {\n+        return (int)4096L;\n+    }\n+    public static int CXTranslationUnit_VisitImplicitAttributes() {\n+        return (int)8192L;\n+    }\n+    public static int CXTranslationUnit_IgnoreNonErrorsFromIncludedFiles() {\n+        return (int)16384L;\n+    }\n+    public static int CXTranslationUnit_RetainExcludedConditionalBlocks() {\n+        return (int)32768L;\n+    }\n+    public static MethodHandle clang_defaultEditingTranslationUnitOptions$MH() {\n+        return RuntimeHelper.requireNonNull(constants$10.clang_defaultEditingTranslationUnitOptions$MH,\"clang_defaultEditingTranslationUnitOptions\");\n+    }\n+    public static int clang_defaultEditingTranslationUnitOptions () {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$10.clang_defaultEditingTranslationUnitOptions$MH, \"clang_defaultEditingTranslationUnitOptions\");\n+        try {\n+            return (int)mh$.invokeExact();\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_parseTranslationUnit$MH() {\n+        return RuntimeHelper.requireNonNull(constants$10.clang_parseTranslationUnit$MH,\"clang_parseTranslationUnit\");\n+    }\n+    public static MemoryAddress clang_parseTranslationUnit ( Addressable CIdx,  Addressable source_filename,  Addressable command_line_args,  int num_command_line_args,  Addressable unsaved_files,  int num_unsaved_files,  int options) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$10.clang_parseTranslationUnit$MH, \"clang_parseTranslationUnit\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(CIdx.address(), source_filename.address(), command_line_args.address(), num_command_line_args, unsaved_files.address(), num_unsaved_files, options);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_parseTranslationUnit2$MH() {\n+        return RuntimeHelper.requireNonNull(constants$10.clang_parseTranslationUnit2$MH,\"clang_parseTranslationUnit2\");\n+    }\n+    public static int clang_parseTranslationUnit2 ( Addressable CIdx,  Addressable source_filename,  Addressable command_line_args,  int num_command_line_args,  Addressable unsaved_files,  int num_unsaved_files,  int options,  Addressable out_TU) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$10.clang_parseTranslationUnit2$MH, \"clang_parseTranslationUnit2\");\n+        try {\n+            return (int)mh$.invokeExact(CIdx.address(), source_filename.address(), command_line_args.address(), num_command_line_args, unsaved_files.address(), num_unsaved_files, options, out_TU.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_parseTranslationUnit2FullArgv$MH() {\n+        return RuntimeHelper.requireNonNull(constants$10.clang_parseTranslationUnit2FullArgv$MH,\"clang_parseTranslationUnit2FullArgv\");\n+    }\n+    public static int clang_parseTranslationUnit2FullArgv ( Addressable CIdx,  Addressable source_filename,  Addressable command_line_args,  int num_command_line_args,  Addressable unsaved_files,  int num_unsaved_files,  int options,  Addressable out_TU) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$10.clang_parseTranslationUnit2FullArgv$MH, \"clang_parseTranslationUnit2FullArgv\");\n+        try {\n+            return (int)mh$.invokeExact(CIdx.address(), source_filename.address(), command_line_args.address(), num_command_line_args, unsaved_files.address(), num_unsaved_files, options, out_TU.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXSaveTranslationUnit_None() {\n+        return (int)0L;\n+    }\n+    public static class constants$10 {\n+\n+        static final FunctionDescriptor clang_createTranslationUnit$FUNC = FunctionDescriptor.of(C_POINTER,\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_createTranslationUnit$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_createTranslationUnit\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$10.clang_createTranslationUnit$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_createTranslationUnit2$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER,\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_createTranslationUnit2$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_createTranslationUnit2\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+            constants$10.clang_createTranslationUnit2$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_defaultEditingTranslationUnitOptions$FUNC = FunctionDescriptor.of(C_INT);\n+        static final MethodHandle clang_defaultEditingTranslationUnitOptions$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_defaultEditingTranslationUnitOptions\",\n+            \"()I\",\n+            constants$10.clang_defaultEditingTranslationUnitOptions$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_parseTranslationUnit$FUNC = FunctionDescriptor.of(C_POINTER,\n+            C_POINTER,\n+            C_POINTER,\n+            C_POINTER,\n+            C_INT,\n+            C_POINTER,\n+            C_INT,\n+            C_INT\n+        );\n+        static final MethodHandle clang_parseTranslationUnit$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_parseTranslationUnit\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;ILjdk\/incubator\/foreign\/MemoryAddress;II)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$10.clang_parseTranslationUnit$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_parseTranslationUnit2$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER,\n+            C_POINTER,\n+            C_POINTER,\n+            C_INT,\n+            C_POINTER,\n+            C_INT,\n+            C_INT,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_parseTranslationUnit2$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_parseTranslationUnit2\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;ILjdk\/incubator\/foreign\/MemoryAddress;IILjdk\/incubator\/foreign\/MemoryAddress;)I\",\n+            constants$10.clang_parseTranslationUnit2$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_parseTranslationUnit2FullArgv$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER,\n+            C_POINTER,\n+            C_POINTER,\n+            C_INT,\n+            C_POINTER,\n+            C_INT,\n+            C_INT,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_parseTranslationUnit2FullArgv$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_parseTranslationUnit2FullArgv\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;ILjdk\/incubator\/foreign\/MemoryAddress;IILjdk\/incubator\/foreign\/MemoryAddress;)I\",\n+            constants$10.clang_parseTranslationUnit2FullArgv$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_defaultSaveOptions$MH() {\n+        return RuntimeHelper.requireNonNull(constants$11.clang_defaultSaveOptions$MH,\"clang_defaultSaveOptions\");\n+    }\n+    public static int clang_defaultSaveOptions ( Addressable TU) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$11.clang_defaultSaveOptions$MH, \"clang_defaultSaveOptions\");\n+        try {\n+            return (int)mh$.invokeExact(TU.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXSaveError_None() {\n+        return (int)0L;\n+    }\n+    public static int CXSaveError_Unknown() {\n+        return (int)1L;\n+    }\n+    public static int CXSaveError_TranslationErrors() {\n+        return (int)2L;\n+    }\n+    public static int CXSaveError_InvalidTU() {\n+        return (int)3L;\n+    }\n+    public static MethodHandle clang_saveTranslationUnit$MH() {\n+        return RuntimeHelper.requireNonNull(constants$11.clang_saveTranslationUnit$MH,\"clang_saveTranslationUnit\");\n+    }\n+    public static int clang_saveTranslationUnit ( Addressable TU,  Addressable FileName,  int options) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$11.clang_saveTranslationUnit$MH, \"clang_saveTranslationUnit\");\n+        try {\n+            return (int)mh$.invokeExact(TU.address(), FileName.address(), options);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_suspendTranslationUnit$MH() {\n+        return RuntimeHelper.requireNonNull(constants$11.clang_suspendTranslationUnit$MH,\"clang_suspendTranslationUnit\");\n+    }\n+    public static int clang_suspendTranslationUnit ( Addressable x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$11.clang_suspendTranslationUnit$MH, \"clang_suspendTranslationUnit\");\n+        try {\n+            return (int)mh$.invokeExact(x0.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_disposeTranslationUnit$MH() {\n+        return RuntimeHelper.requireNonNull(constants$11.clang_disposeTranslationUnit$MH,\"clang_disposeTranslationUnit\");\n+    }\n+    public static void clang_disposeTranslationUnit ( Addressable x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$11.clang_disposeTranslationUnit$MH, \"clang_disposeTranslationUnit\");\n+        try {\n+            mh$.invokeExact(x0.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXReparse_None() {\n+        return (int)0L;\n+    }\n+    public static MethodHandle clang_defaultReparseOptions$MH() {\n+        return RuntimeHelper.requireNonNull(constants$11.clang_defaultReparseOptions$MH,\"clang_defaultReparseOptions\");\n+    }\n+    public static int clang_defaultReparseOptions ( Addressable TU) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$11.clang_defaultReparseOptions$MH, \"clang_defaultReparseOptions\");\n+        try {\n+            return (int)mh$.invokeExact(TU.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_reparseTranslationUnit$MH() {\n+        return RuntimeHelper.requireNonNull(constants$11.clang_reparseTranslationUnit$MH,\"clang_reparseTranslationUnit\");\n+    }\n+    public static int clang_reparseTranslationUnit ( Addressable TU,  int num_unsaved_files,  Addressable unsaved_files,  int options) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$11.clang_reparseTranslationUnit$MH, \"clang_reparseTranslationUnit\");\n+        try {\n+            return (int)mh$.invokeExact(TU.address(), num_unsaved_files, unsaved_files.address(), options);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXTUResourceUsage_AST() {\n+        return (int)1L;\n+    }\n+    public static int CXTUResourceUsage_Identifiers() {\n+        return (int)2L;\n+    }\n+    public static int CXTUResourceUsage_Selectors() {\n+        return (int)3L;\n+    }\n+    public static int CXTUResourceUsage_GlobalCompletionResults() {\n+        return (int)4L;\n+    }\n+    public static int CXTUResourceUsage_SourceManagerContentCache() {\n+        return (int)5L;\n+    }\n+    public static int CXTUResourceUsage_AST_SideTables() {\n+        return (int)6L;\n+    }\n+    public static int CXTUResourceUsage_SourceManager_Membuffer_Malloc() {\n+        return (int)7L;\n+    }\n+    public static int CXTUResourceUsage_SourceManager_Membuffer_MMap() {\n+        return (int)8L;\n+    }\n+    public static int CXTUResourceUsage_ExternalASTSource_Membuffer_Malloc() {\n+        return (int)9L;\n+    }\n+    public static int CXTUResourceUsage_ExternalASTSource_Membuffer_MMap() {\n+        return (int)10L;\n+    }\n+    public static int CXTUResourceUsage_Preprocessor() {\n+        return (int)11L;\n+    }\n+    public static int CXTUResourceUsage_PreprocessingRecord() {\n+        return (int)12L;\n+    }\n+    public static int CXTUResourceUsage_SourceManager_DataStructures() {\n+        return (int)13L;\n+    }\n+    public static int CXTUResourceUsage_Preprocessor_HeaderSearch() {\n+        return (int)14L;\n+    }\n+    public static int CXTUResourceUsage_MEMORY_IN_BYTES_BEGIN() {\n+        return (int)1L;\n+    }\n+    public static int CXTUResourceUsage_MEMORY_IN_BYTES_END() {\n+        return (int)14L;\n+    }\n+    public static int CXTUResourceUsage_First() {\n+        return (int)1L;\n+    }\n+    public static int CXTUResourceUsage_Last() {\n+        return (int)14L;\n+    }\n+    public static class constants$11 {\n+\n+        static final FunctionDescriptor clang_defaultSaveOptions$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_defaultSaveOptions$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_defaultSaveOptions\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+            constants$11.clang_defaultSaveOptions$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_saveTranslationUnit$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER,\n+            C_POINTER,\n+            C_INT\n+        );\n+        static final MethodHandle clang_saveTranslationUnit$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_saveTranslationUnit\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;I)I\",\n+            constants$11.clang_saveTranslationUnit$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_suspendTranslationUnit$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_suspendTranslationUnit$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_suspendTranslationUnit\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+            constants$11.clang_suspendTranslationUnit$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_disposeTranslationUnit$FUNC = FunctionDescriptor.ofVoid(\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_disposeTranslationUnit$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_disposeTranslationUnit\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)V\",\n+            constants$11.clang_disposeTranslationUnit$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_defaultReparseOptions$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_defaultReparseOptions$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_defaultReparseOptions\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+            constants$11.clang_defaultReparseOptions$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_reparseTranslationUnit$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER,\n+            C_INT,\n+            C_POINTER,\n+            C_INT\n+        );\n+        static final MethodHandle clang_reparseTranslationUnit$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_reparseTranslationUnit\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;ILjdk\/incubator\/foreign\/MemoryAddress;I)I\",\n+            constants$11.clang_reparseTranslationUnit$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_getTUResourceUsageName$MH() {\n+        return RuntimeHelper.requireNonNull(constants$12.clang_getTUResourceUsageName$MH,\"clang_getTUResourceUsageName\");\n+    }\n+    public static MemoryAddress clang_getTUResourceUsageName ( int kind) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$12.clang_getTUResourceUsageName$MH, \"clang_getTUResourceUsageName\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(kind);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class CXTUResourceUsageEntry {\n+\n+        static final MemoryLayout CXTUResourceUsageEntry$struct$LAYOUT = MemoryLayout.ofStruct(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.ofPaddingBits(32),\n+            C_LONG_LONG.withName(\"amount\")\n+        ).withName(\"CXTUResourceUsageEntry\");\n+        public static MemoryLayout $LAYOUT() {\n+            return CXTUResourceUsageEntry.CXTUResourceUsageEntry$struct$LAYOUT;\n+        }\n+        static final VarHandle kind$VH = CXTUResourceUsageEntry$struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"kind\"));\n+        public static VarHandle kind$VH() {\n+            return CXTUResourceUsageEntry.kind$VH;\n+        }\n+        public static int kind$get(MemorySegment seg) {\n+            return (int)CXTUResourceUsageEntry.kind$VH.get(seg);\n+        }\n+        public static void kind$set( MemorySegment seg, int x) {\n+            CXTUResourceUsageEntry.kind$VH.set(seg, x);\n+        }\n+        public static int kind$get(MemorySegment seg, long index) {\n+            return (int)CXTUResourceUsageEntry.kind$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void kind$set(MemorySegment seg, long index, int x) {\n+            CXTUResourceUsageEntry.kind$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle amount$VH = CXTUResourceUsageEntry$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"amount\"));\n+        public static VarHandle amount$VH() {\n+            return CXTUResourceUsageEntry.amount$VH;\n+        }\n+        public static long amount$get(MemorySegment seg) {\n+            return (long)CXTUResourceUsageEntry.amount$VH.get(seg);\n+        }\n+        public static void amount$set( MemorySegment seg, long x) {\n+            CXTUResourceUsageEntry.amount$VH.set(seg, x);\n+        }\n+        public static long amount$get(MemorySegment seg, long index) {\n+            return (long)CXTUResourceUsageEntry.amount$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void amount$set(MemorySegment seg, long index, long x) {\n+            CXTUResourceUsageEntry.amount$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public static long sizeof() { return $LAYOUT().byteSize(); }\n+        public static MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\n+        public static MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n+        public static MemorySegment allocateArray(int len) {\n+            return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }        public static MemorySegment allocateArray(int len, NativeScope scope) {\n+            return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }\n+        public static MemorySegment allocatePointer() {\n+            return MemorySegment.allocateNative(C_POINTER);\n+        }\n+        public static MemorySegment allocatePointer(NativeScope scope) {\n+            return scope.allocate(C_POINTER);\n+        }\n+        public static MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\n+    }\n+\n+    public static class CXTUResourceUsage {\n+\n+        static final MemoryLayout CXTUResourceUsage$struct$LAYOUT = MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"numEntries\"),\n+            MemoryLayout.ofPaddingBits(32),\n+            C_POINTER.withName(\"entries\")\n+        ).withName(\"CXTUResourceUsage\");\n+        public static MemoryLayout $LAYOUT() {\n+            return CXTUResourceUsage.CXTUResourceUsage$struct$LAYOUT;\n+        }\n+        static final VarHandle data$VH = MemoryHandles.asAddressVarHandle(CXTUResourceUsage$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"data\")));\n+        public static VarHandle data$VH() {\n+            return CXTUResourceUsage.data$VH;\n+        }\n+        public static MemoryAddress data$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXTUResourceUsage.data$VH.get(seg);\n+        }\n+        public static void data$set( MemorySegment seg, MemoryAddress x) {\n+            CXTUResourceUsage.data$VH.set(seg, x);\n+        }\n+        public static MemoryAddress data$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXTUResourceUsage.data$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void data$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXTUResourceUsage.data$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle numEntries$VH = CXTUResourceUsage$struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"numEntries\"));\n+        public static VarHandle numEntries$VH() {\n+            return CXTUResourceUsage.numEntries$VH;\n+        }\n+        public static int numEntries$get(MemorySegment seg) {\n+            return (int)CXTUResourceUsage.numEntries$VH.get(seg);\n+        }\n+        public static void numEntries$set( MemorySegment seg, int x) {\n+            CXTUResourceUsage.numEntries$VH.set(seg, x);\n+        }\n+        public static int numEntries$get(MemorySegment seg, long index) {\n+            return (int)CXTUResourceUsage.numEntries$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void numEntries$set(MemorySegment seg, long index, int x) {\n+            CXTUResourceUsage.numEntries$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle entries$VH = MemoryHandles.asAddressVarHandle(CXTUResourceUsage$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"entries\")));\n+        public static VarHandle entries$VH() {\n+            return CXTUResourceUsage.entries$VH;\n+        }\n+        public static MemoryAddress entries$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXTUResourceUsage.entries$VH.get(seg);\n+        }\n+        public static void entries$set( MemorySegment seg, MemoryAddress x) {\n+            CXTUResourceUsage.entries$VH.set(seg, x);\n+        }\n+        public static MemoryAddress entries$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXTUResourceUsage.entries$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void entries$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXTUResourceUsage.entries$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public static long sizeof() { return $LAYOUT().byteSize(); }\n+        public static MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\n+        public static MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n+        public static MemorySegment allocateArray(int len) {\n+            return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }        public static MemorySegment allocateArray(int len, NativeScope scope) {\n+            return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }\n+        public static MemorySegment allocatePointer() {\n+            return MemorySegment.allocateNative(C_POINTER);\n+        }\n+        public static MemorySegment allocatePointer(NativeScope scope) {\n+            return scope.allocate(C_POINTER);\n+        }\n+        public static MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\n+    }\n+\n+    public static MethodHandle clang_getCXTUResourceUsage$MH() {\n+        return RuntimeHelper.requireNonNull(constants$12.clang_getCXTUResourceUsage$MH,\"clang_getCXTUResourceUsage\");\n+    }\n+    public static MemorySegment clang_getCXTUResourceUsage ( Addressable TU) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$12.clang_getCXTUResourceUsage$MH, \"clang_getCXTUResourceUsage\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(TU.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_disposeCXTUResourceUsage$MH() {\n+        return RuntimeHelper.requireNonNull(constants$12.clang_disposeCXTUResourceUsage$MH,\"clang_disposeCXTUResourceUsage\");\n+    }\n+    public static void clang_disposeCXTUResourceUsage ( MemorySegment usage) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$12.clang_disposeCXTUResourceUsage$MH, \"clang_disposeCXTUResourceUsage\");\n+        try {\n+            mh$.invokeExact(usage);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getTranslationUnitTargetInfo$MH() {\n+        return RuntimeHelper.requireNonNull(constants$12.clang_getTranslationUnitTargetInfo$MH,\"clang_getTranslationUnitTargetInfo\");\n+    }\n+    public static MemoryAddress clang_getTranslationUnitTargetInfo ( Addressable CTUnit) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$12.clang_getTranslationUnitTargetInfo$MH, \"clang_getTranslationUnitTargetInfo\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(CTUnit.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_TargetInfo_dispose$MH() {\n+        return RuntimeHelper.requireNonNull(constants$12.clang_TargetInfo_dispose$MH,\"clang_TargetInfo_dispose\");\n+    }\n+    public static void clang_TargetInfo_dispose ( Addressable Info) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$12.clang_TargetInfo_dispose$MH, \"clang_TargetInfo_dispose\");\n+        try {\n+            mh$.invokeExact(Info.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_TargetInfo_getTriple$MH() {\n+        return RuntimeHelper.requireNonNull(constants$12.clang_TargetInfo_getTriple$MH,\"clang_TargetInfo_getTriple\");\n+    }\n+    public static MemorySegment clang_TargetInfo_getTriple ( Addressable Info) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$12.clang_TargetInfo_getTriple$MH, \"clang_TargetInfo_getTriple\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(Info.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$12 {\n+\n+        static final FunctionDescriptor clang_getTUResourceUsageName$FUNC = FunctionDescriptor.of(C_POINTER,\n+            C_INT\n+        );\n+        static final MethodHandle clang_getTUResourceUsageName$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getTUResourceUsageName\",\n+            \"(I)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$12.clang_getTUResourceUsageName$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getCXTUResourceUsage$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"numEntries\"),\n+            MemoryLayout.ofPaddingBits(32),\n+            C_POINTER.withName(\"entries\")\n+        ).withName(\"CXTUResourceUsage\"),\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getCXTUResourceUsage$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCXTUResourceUsage\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$12.clang_getCXTUResourceUsage$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_disposeCXTUResourceUsage$FUNC = FunctionDescriptor.ofVoid(\n+            MemoryLayout.ofStruct(\n+                C_POINTER.withName(\"data\"),\n+                C_INT.withName(\"numEntries\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                C_POINTER.withName(\"entries\")\n+            ).withName(\"CXTUResourceUsage\")\n+        );\n+        static final MethodHandle clang_disposeCXTUResourceUsage$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_disposeCXTUResourceUsage\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)V\",\n+            constants$12.clang_disposeCXTUResourceUsage$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getTranslationUnitTargetInfo$FUNC = FunctionDescriptor.of(C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getTranslationUnitTargetInfo$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getTranslationUnitTargetInfo\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$12.clang_getTranslationUnitTargetInfo$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_TargetInfo_dispose$FUNC = FunctionDescriptor.ofVoid(\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_TargetInfo_dispose$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_TargetInfo_dispose\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)V\",\n+            constants$12.clang_TargetInfo_dispose$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_TargetInfo_getTriple$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_TargetInfo_getTriple$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_TargetInfo_getTriple\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$12.clang_TargetInfo_getTriple$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_TargetInfo_getPointerWidth$MH() {\n+        return RuntimeHelper.requireNonNull(constants$13.clang_TargetInfo_getPointerWidth$MH,\"clang_TargetInfo_getPointerWidth\");\n+    }\n+    public static int clang_TargetInfo_getPointerWidth ( Addressable Info) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$13.clang_TargetInfo_getPointerWidth$MH, \"clang_TargetInfo_getPointerWidth\");\n+        try {\n+            return (int)mh$.invokeExact(Info.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXCursor_UnexposedDecl() {\n+        return (int)1L;\n+    }\n+    public static int CXCursor_StructDecl() {\n+        return (int)2L;\n+    }\n+    public static int CXCursor_UnionDecl() {\n+        return (int)3L;\n+    }\n+    public static int CXCursor_ClassDecl() {\n+        return (int)4L;\n+    }\n+    public static int CXCursor_EnumDecl() {\n+        return (int)5L;\n+    }\n+    public static int CXCursor_FieldDecl() {\n+        return (int)6L;\n+    }\n+    public static int CXCursor_EnumConstantDecl() {\n+        return (int)7L;\n+    }\n+    public static int CXCursor_FunctionDecl() {\n+        return (int)8L;\n+    }\n+    public static int CXCursor_VarDecl() {\n+        return (int)9L;\n+    }\n+    public static int CXCursor_ParmDecl() {\n+        return (int)10L;\n+    }\n+    public static int CXCursor_ObjCInterfaceDecl() {\n+        return (int)11L;\n+    }\n+    public static int CXCursor_ObjCCategoryDecl() {\n+        return (int)12L;\n+    }\n+    public static int CXCursor_ObjCProtocolDecl() {\n+        return (int)13L;\n+    }\n+    public static int CXCursor_ObjCPropertyDecl() {\n+        return (int)14L;\n+    }\n+    public static int CXCursor_ObjCIvarDecl() {\n+        return (int)15L;\n+    }\n+    public static int CXCursor_ObjCInstanceMethodDecl() {\n+        return (int)16L;\n+    }\n+    public static int CXCursor_ObjCClassMethodDecl() {\n+        return (int)17L;\n+    }\n+    public static int CXCursor_ObjCImplementationDecl() {\n+        return (int)18L;\n+    }\n+    public static int CXCursor_ObjCCategoryImplDecl() {\n+        return (int)19L;\n+    }\n+    public static int CXCursor_TypedefDecl() {\n+        return (int)20L;\n+    }\n+    public static int CXCursor_CXXMethod() {\n+        return (int)21L;\n+    }\n+    public static int CXCursor_Namespace() {\n+        return (int)22L;\n+    }\n+    public static int CXCursor_LinkageSpec() {\n+        return (int)23L;\n+    }\n+    public static int CXCursor_Constructor() {\n+        return (int)24L;\n+    }\n+    public static int CXCursor_Destructor() {\n+        return (int)25L;\n+    }\n+    public static int CXCursor_ConversionFunction() {\n+        return (int)26L;\n+    }\n+    public static int CXCursor_TemplateTypeParameter() {\n+        return (int)27L;\n+    }\n+    public static int CXCursor_NonTypeTemplateParameter() {\n+        return (int)28L;\n+    }\n+    public static int CXCursor_TemplateTemplateParameter() {\n+        return (int)29L;\n+    }\n+    public static int CXCursor_FunctionTemplate() {\n+        return (int)30L;\n+    }\n+    public static int CXCursor_ClassTemplate() {\n+        return (int)31L;\n+    }\n+    public static int CXCursor_ClassTemplatePartialSpecialization() {\n+        return (int)32L;\n+    }\n+    public static int CXCursor_NamespaceAlias() {\n+        return (int)33L;\n+    }\n+    public static int CXCursor_UsingDirective() {\n+        return (int)34L;\n+    }\n+    public static int CXCursor_UsingDeclaration() {\n+        return (int)35L;\n+    }\n+    public static int CXCursor_TypeAliasDecl() {\n+        return (int)36L;\n+    }\n+    public static int CXCursor_ObjCSynthesizeDecl() {\n+        return (int)37L;\n+    }\n+    public static int CXCursor_ObjCDynamicDecl() {\n+        return (int)38L;\n+    }\n+    public static int CXCursor_CXXAccessSpecifier() {\n+        return (int)39L;\n+    }\n+    public static int CXCursor_FirstDecl() {\n+        return (int)1L;\n+    }\n+    public static int CXCursor_LastDecl() {\n+        return (int)39L;\n+    }\n+    public static int CXCursor_FirstRef() {\n+        return (int)40L;\n+    }\n+    public static int CXCursor_ObjCSuperClassRef() {\n+        return (int)40L;\n+    }\n+    public static int CXCursor_ObjCProtocolRef() {\n+        return (int)41L;\n+    }\n+    public static int CXCursor_ObjCClassRef() {\n+        return (int)42L;\n+    }\n+    public static int CXCursor_TypeRef() {\n+        return (int)43L;\n+    }\n+    public static int CXCursor_CXXBaseSpecifier() {\n+        return (int)44L;\n+    }\n+    public static int CXCursor_TemplateRef() {\n+        return (int)45L;\n+    }\n+    public static int CXCursor_NamespaceRef() {\n+        return (int)46L;\n+    }\n+    public static int CXCursor_MemberRef() {\n+        return (int)47L;\n+    }\n+    public static int CXCursor_LabelRef() {\n+        return (int)48L;\n+    }\n+    public static int CXCursor_OverloadedDeclRef() {\n+        return (int)49L;\n+    }\n+    public static int CXCursor_VariableRef() {\n+        return (int)50L;\n+    }\n+    public static int CXCursor_LastRef() {\n+        return (int)50L;\n+    }\n+    public static int CXCursor_FirstInvalid() {\n+        return (int)70L;\n+    }\n+    public static int CXCursor_InvalidFile() {\n+        return (int)70L;\n+    }\n+    public static int CXCursor_NoDeclFound() {\n+        return (int)71L;\n+    }\n+    public static int CXCursor_NotImplemented() {\n+        return (int)72L;\n+    }\n+    public static int CXCursor_InvalidCode() {\n+        return (int)73L;\n+    }\n+    public static int CXCursor_LastInvalid() {\n+        return (int)73L;\n+    }\n+    public static int CXCursor_FirstExpr() {\n+        return (int)100L;\n+    }\n+    public static int CXCursor_UnexposedExpr() {\n+        return (int)100L;\n+    }\n+    public static int CXCursor_DeclRefExpr() {\n+        return (int)101L;\n+    }\n+    public static int CXCursor_MemberRefExpr() {\n+        return (int)102L;\n+    }\n+    public static int CXCursor_CallExpr() {\n+        return (int)103L;\n+    }\n+    public static int CXCursor_ObjCMessageExpr() {\n+        return (int)104L;\n+    }\n+    public static int CXCursor_BlockExpr() {\n+        return (int)105L;\n+    }\n+    public static int CXCursor_IntegerLiteral() {\n+        return (int)106L;\n+    }\n+    public static int CXCursor_FloatingLiteral() {\n+        return (int)107L;\n+    }\n+    public static int CXCursor_ImaginaryLiteral() {\n+        return (int)108L;\n+    }\n+    public static int CXCursor_StringLiteral() {\n+        return (int)109L;\n+    }\n+    public static int CXCursor_CharacterLiteral() {\n+        return (int)110L;\n+    }\n+    public static int CXCursor_ParenExpr() {\n+        return (int)111L;\n+    }\n+    public static int CXCursor_UnaryOperator() {\n+        return (int)112L;\n+    }\n+    public static int CXCursor_ArraySubscriptExpr() {\n+        return (int)113L;\n+    }\n+    public static int CXCursor_BinaryOperator() {\n+        return (int)114L;\n+    }\n+    public static int CXCursor_CompoundAssignOperator() {\n+        return (int)115L;\n+    }\n+    public static int CXCursor_ConditionalOperator() {\n+        return (int)116L;\n+    }\n+    public static int CXCursor_CStyleCastExpr() {\n+        return (int)117L;\n+    }\n+    public static int CXCursor_CompoundLiteralExpr() {\n+        return (int)118L;\n+    }\n+    public static int CXCursor_InitListExpr() {\n+        return (int)119L;\n+    }\n+    public static int CXCursor_AddrLabelExpr() {\n+        return (int)120L;\n+    }\n+    public static int CXCursor_StmtExpr() {\n+        return (int)121L;\n+    }\n+    public static int CXCursor_GenericSelectionExpr() {\n+        return (int)122L;\n+    }\n+    public static int CXCursor_GNUNullExpr() {\n+        return (int)123L;\n+    }\n+    public static int CXCursor_CXXStaticCastExpr() {\n+        return (int)124L;\n+    }\n+    public static int CXCursor_CXXDynamicCastExpr() {\n+        return (int)125L;\n+    }\n+    public static int CXCursor_CXXReinterpretCastExpr() {\n+        return (int)126L;\n+    }\n+    public static int CXCursor_CXXConstCastExpr() {\n+        return (int)127L;\n+    }\n+    public static int CXCursor_CXXFunctionalCastExpr() {\n+        return (int)128L;\n+    }\n+    public static int CXCursor_CXXTypeidExpr() {\n+        return (int)129L;\n+    }\n+    public static int CXCursor_CXXBoolLiteralExpr() {\n+        return (int)130L;\n+    }\n+    public static int CXCursor_CXXNullPtrLiteralExpr() {\n+        return (int)131L;\n+    }\n+    public static int CXCursor_CXXThisExpr() {\n+        return (int)132L;\n+    }\n+    public static int CXCursor_CXXThrowExpr() {\n+        return (int)133L;\n+    }\n+    public static int CXCursor_CXXNewExpr() {\n+        return (int)134L;\n+    }\n+    public static int CXCursor_CXXDeleteExpr() {\n+        return (int)135L;\n+    }\n+    public static int CXCursor_UnaryExpr() {\n+        return (int)136L;\n+    }\n+    public static int CXCursor_ObjCStringLiteral() {\n+        return (int)137L;\n+    }\n+    public static int CXCursor_ObjCEncodeExpr() {\n+        return (int)138L;\n+    }\n+    public static int CXCursor_ObjCSelectorExpr() {\n+        return (int)139L;\n+    }\n+    public static int CXCursor_ObjCProtocolExpr() {\n+        return (int)140L;\n+    }\n+    public static int CXCursor_ObjCBridgedCastExpr() {\n+        return (int)141L;\n+    }\n+    public static int CXCursor_PackExpansionExpr() {\n+        return (int)142L;\n+    }\n+    public static int CXCursor_SizeOfPackExpr() {\n+        return (int)143L;\n+    }\n+    public static int CXCursor_LambdaExpr() {\n+        return (int)144L;\n+    }\n+    public static int CXCursor_ObjCBoolLiteralExpr() {\n+        return (int)145L;\n+    }\n+    public static int CXCursor_ObjCSelfExpr() {\n+        return (int)146L;\n+    }\n+    public static int CXCursor_OMPArraySectionExpr() {\n+        return (int)147L;\n+    }\n+    public static int CXCursor_ObjCAvailabilityCheckExpr() {\n+        return (int)148L;\n+    }\n+    public static int CXCursor_FixedPointLiteral() {\n+        return (int)149L;\n+    }\n+    public static int CXCursor_LastExpr() {\n+        return (int)149L;\n+    }\n+    public static int CXCursor_FirstStmt() {\n+        return (int)200L;\n+    }\n+    public static int CXCursor_UnexposedStmt() {\n+        return (int)200L;\n+    }\n+    public static int CXCursor_LabelStmt() {\n+        return (int)201L;\n+    }\n+    public static int CXCursor_CompoundStmt() {\n+        return (int)202L;\n+    }\n+    public static int CXCursor_CaseStmt() {\n+        return (int)203L;\n+    }\n+    public static int CXCursor_DefaultStmt() {\n+        return (int)204L;\n+    }\n+    public static int CXCursor_IfStmt() {\n+        return (int)205L;\n+    }\n+    public static int CXCursor_SwitchStmt() {\n+        return (int)206L;\n+    }\n+    public static int CXCursor_WhileStmt() {\n+        return (int)207L;\n+    }\n+    public static int CXCursor_DoStmt() {\n+        return (int)208L;\n+    }\n+    public static int CXCursor_ForStmt() {\n+        return (int)209L;\n+    }\n+    public static int CXCursor_GotoStmt() {\n+        return (int)210L;\n+    }\n+    public static int CXCursor_IndirectGotoStmt() {\n+        return (int)211L;\n+    }\n+    public static int CXCursor_ContinueStmt() {\n+        return (int)212L;\n+    }\n+    public static int CXCursor_BreakStmt() {\n+        return (int)213L;\n+    }\n+    public static int CXCursor_ReturnStmt() {\n+        return (int)214L;\n+    }\n+    public static int CXCursor_GCCAsmStmt() {\n+        return (int)215L;\n+    }\n+    public static int CXCursor_AsmStmt() {\n+        return (int)215L;\n+    }\n+    public static int CXCursor_ObjCAtTryStmt() {\n+        return (int)216L;\n+    }\n+    public static int CXCursor_ObjCAtCatchStmt() {\n+        return (int)217L;\n+    }\n+    public static int CXCursor_ObjCAtFinallyStmt() {\n+        return (int)218L;\n+    }\n+    public static int CXCursor_ObjCAtThrowStmt() {\n+        return (int)219L;\n+    }\n+    public static int CXCursor_ObjCAtSynchronizedStmt() {\n+        return (int)220L;\n+    }\n+    public static int CXCursor_ObjCAutoreleasePoolStmt() {\n+        return (int)221L;\n+    }\n+    public static int CXCursor_ObjCForCollectionStmt() {\n+        return (int)222L;\n+    }\n+    public static int CXCursor_CXXCatchStmt() {\n+        return (int)223L;\n+    }\n+    public static int CXCursor_CXXTryStmt() {\n+        return (int)224L;\n+    }\n+    public static int CXCursor_CXXForRangeStmt() {\n+        return (int)225L;\n+    }\n+    public static int CXCursor_SEHTryStmt() {\n+        return (int)226L;\n+    }\n+    public static int CXCursor_SEHExceptStmt() {\n+        return (int)227L;\n+    }\n+    public static int CXCursor_SEHFinallyStmt() {\n+        return (int)228L;\n+    }\n+    public static int CXCursor_MSAsmStmt() {\n+        return (int)229L;\n+    }\n+    public static int CXCursor_NullStmt() {\n+        return (int)230L;\n+    }\n+    public static int CXCursor_DeclStmt() {\n+        return (int)231L;\n+    }\n+    public static int CXCursor_OMPParallelDirective() {\n+        return (int)232L;\n+    }\n+    public static int CXCursor_OMPSimdDirective() {\n+        return (int)233L;\n+    }\n+    public static int CXCursor_OMPForDirective() {\n+        return (int)234L;\n+    }\n+    public static int CXCursor_OMPSectionsDirective() {\n+        return (int)235L;\n+    }\n+    public static int CXCursor_OMPSectionDirective() {\n+        return (int)236L;\n+    }\n+    public static int CXCursor_OMPSingleDirective() {\n+        return (int)237L;\n+    }\n+    public static int CXCursor_OMPParallelForDirective() {\n+        return (int)238L;\n+    }\n+    public static int CXCursor_OMPParallelSectionsDirective() {\n+        return (int)239L;\n+    }\n+    public static int CXCursor_OMPTaskDirective() {\n+        return (int)240L;\n+    }\n+    public static int CXCursor_OMPMasterDirective() {\n+        return (int)241L;\n+    }\n+    public static int CXCursor_OMPCriticalDirective() {\n+        return (int)242L;\n+    }\n+    public static int CXCursor_OMPTaskyieldDirective() {\n+        return (int)243L;\n+    }\n+    public static int CXCursor_OMPBarrierDirective() {\n+        return (int)244L;\n+    }\n+    public static int CXCursor_OMPTaskwaitDirective() {\n+        return (int)245L;\n+    }\n+    public static int CXCursor_OMPFlushDirective() {\n+        return (int)246L;\n+    }\n+    public static int CXCursor_SEHLeaveStmt() {\n+        return (int)247L;\n+    }\n+    public static int CXCursor_OMPOrderedDirective() {\n+        return (int)248L;\n+    }\n+    public static int CXCursor_OMPAtomicDirective() {\n+        return (int)249L;\n+    }\n+    public static int CXCursor_OMPForSimdDirective() {\n+        return (int)250L;\n+    }\n+    public static int CXCursor_OMPParallelForSimdDirective() {\n+        return (int)251L;\n+    }\n+    public static int CXCursor_OMPTargetDirective() {\n+        return (int)252L;\n+    }\n+    public static int CXCursor_OMPTeamsDirective() {\n+        return (int)253L;\n+    }\n+    public static int CXCursor_OMPTaskgroupDirective() {\n+        return (int)254L;\n+    }\n+    public static int CXCursor_OMPCancellationPointDirective() {\n+        return (int)255L;\n+    }\n+    public static int CXCursor_OMPCancelDirective() {\n+        return (int)256L;\n+    }\n+    public static int CXCursor_OMPTargetDataDirective() {\n+        return (int)257L;\n+    }\n+    public static int CXCursor_OMPTaskLoopDirective() {\n+        return (int)258L;\n+    }\n+    public static int CXCursor_OMPTaskLoopSimdDirective() {\n+        return (int)259L;\n+    }\n+    public static int CXCursor_OMPDistributeDirective() {\n+        return (int)260L;\n+    }\n+    public static int CXCursor_OMPTargetEnterDataDirective() {\n+        return (int)261L;\n+    }\n+    public static int CXCursor_OMPTargetExitDataDirective() {\n+        return (int)262L;\n+    }\n+    public static int CXCursor_OMPTargetParallelDirective() {\n+        return (int)263L;\n+    }\n+    public static int CXCursor_OMPTargetParallelForDirective() {\n+        return (int)264L;\n+    }\n+    public static int CXCursor_OMPTargetUpdateDirective() {\n+        return (int)265L;\n+    }\n+    public static int CXCursor_OMPDistributeParallelForDirective() {\n+        return (int)266L;\n+    }\n+    public static int CXCursor_OMPDistributeParallelForSimdDirective() {\n+        return (int)267L;\n+    }\n+    public static int CXCursor_OMPDistributeSimdDirective() {\n+        return (int)268L;\n+    }\n+    public static int CXCursor_OMPTargetParallelForSimdDirective() {\n+        return (int)269L;\n+    }\n+    public static int CXCursor_OMPTargetSimdDirective() {\n+        return (int)270L;\n+    }\n+    public static int CXCursor_OMPTeamsDistributeDirective() {\n+        return (int)271L;\n+    }\n+    public static int CXCursor_OMPTeamsDistributeSimdDirective() {\n+        return (int)272L;\n+    }\n+    public static int CXCursor_OMPTeamsDistributeParallelForSimdDirective() {\n+        return (int)273L;\n+    }\n+    public static int CXCursor_OMPTeamsDistributeParallelForDirective() {\n+        return (int)274L;\n+    }\n+    public static int CXCursor_OMPTargetTeamsDirective() {\n+        return (int)275L;\n+    }\n+    public static int CXCursor_OMPTargetTeamsDistributeDirective() {\n+        return (int)276L;\n+    }\n+    public static int CXCursor_OMPTargetTeamsDistributeParallelForDirective() {\n+        return (int)277L;\n+    }\n+    public static int CXCursor_OMPTargetTeamsDistributeParallelForSimdDirective() {\n+        return (int)278L;\n+    }\n+    public static int CXCursor_OMPTargetTeamsDistributeSimdDirective() {\n+        return (int)279L;\n+    }\n+    public static int CXCursor_BuiltinBitCastExpr() {\n+        return (int)280L;\n+    }\n+    public static int CXCursor_OMPMasterTaskLoopDirective() {\n+        return (int)281L;\n+    }\n+    public static int CXCursor_OMPParallelMasterTaskLoopDirective() {\n+        return (int)282L;\n+    }\n+    public static int CXCursor_OMPMasterTaskLoopSimdDirective() {\n+        return (int)283L;\n+    }\n+    public static int CXCursor_OMPParallelMasterTaskLoopSimdDirective() {\n+        return (int)284L;\n+    }\n+    public static int CXCursor_LastStmt() {\n+        return (int)284L;\n+    }\n+    public static int CXCursor_TranslationUnit() {\n+        return (int)300L;\n+    }\n+    public static int CXCursor_FirstAttr() {\n+        return (int)400L;\n+    }\n+    public static int CXCursor_UnexposedAttr() {\n+        return (int)400L;\n+    }\n+    public static int CXCursor_IBActionAttr() {\n+        return (int)401L;\n+    }\n+    public static int CXCursor_IBOutletAttr() {\n+        return (int)402L;\n+    }\n+    public static int CXCursor_IBOutletCollectionAttr() {\n+        return (int)403L;\n+    }\n+    public static int CXCursor_CXXFinalAttr() {\n+        return (int)404L;\n+    }\n+    public static int CXCursor_CXXOverrideAttr() {\n+        return (int)405L;\n+    }\n+    public static int CXCursor_AnnotateAttr() {\n+        return (int)406L;\n+    }\n+    public static int CXCursor_AsmLabelAttr() {\n+        return (int)407L;\n+    }\n+    public static int CXCursor_PackedAttr() {\n+        return (int)408L;\n+    }\n+    public static int CXCursor_PureAttr() {\n+        return (int)409L;\n+    }\n+    public static int CXCursor_ConstAttr() {\n+        return (int)410L;\n+    }\n+    public static int CXCursor_NoDuplicateAttr() {\n+        return (int)411L;\n+    }\n+    public static int CXCursor_CUDAConstantAttr() {\n+        return (int)412L;\n+    }\n+    public static int CXCursor_CUDADeviceAttr() {\n+        return (int)413L;\n+    }\n+    public static int CXCursor_CUDAGlobalAttr() {\n+        return (int)414L;\n+    }\n+    public static int CXCursor_CUDAHostAttr() {\n+        return (int)415L;\n+    }\n+    public static int CXCursor_CUDASharedAttr() {\n+        return (int)416L;\n+    }\n+    public static int CXCursor_VisibilityAttr() {\n+        return (int)417L;\n+    }\n+    public static int CXCursor_DLLExport() {\n+        return (int)418L;\n+    }\n+    public static int CXCursor_DLLImport() {\n+        return (int)419L;\n+    }\n+    public static int CXCursor_NSReturnsRetained() {\n+        return (int)420L;\n+    }\n+    public static int CXCursor_NSReturnsNotRetained() {\n+        return (int)421L;\n+    }\n+    public static int CXCursor_NSReturnsAutoreleased() {\n+        return (int)422L;\n+    }\n+    public static int CXCursor_NSConsumesSelf() {\n+        return (int)423L;\n+    }\n+    public static int CXCursor_NSConsumed() {\n+        return (int)424L;\n+    }\n+    public static int CXCursor_ObjCException() {\n+        return (int)425L;\n+    }\n+    public static int CXCursor_ObjCNSObject() {\n+        return (int)426L;\n+    }\n+    public static int CXCursor_ObjCIndependentClass() {\n+        return (int)427L;\n+    }\n+    public static int CXCursor_ObjCPreciseLifetime() {\n+        return (int)428L;\n+    }\n+    public static int CXCursor_ObjCReturnsInnerPointer() {\n+        return (int)429L;\n+    }\n+    public static int CXCursor_ObjCRequiresSuper() {\n+        return (int)430L;\n+    }\n+    public static int CXCursor_ObjCRootClass() {\n+        return (int)431L;\n+    }\n+    public static int CXCursor_ObjCSubclassingRestricted() {\n+        return (int)432L;\n+    }\n+    public static int CXCursor_ObjCExplicitProtocolImpl() {\n+        return (int)433L;\n+    }\n+    public static int CXCursor_ObjCDesignatedInitializer() {\n+        return (int)434L;\n+    }\n+    public static int CXCursor_ObjCRuntimeVisible() {\n+        return (int)435L;\n+    }\n+    public static int CXCursor_ObjCBoxable() {\n+        return (int)436L;\n+    }\n+    public static int CXCursor_FlagEnum() {\n+        return (int)437L;\n+    }\n+    public static int CXCursor_ConvergentAttr() {\n+        return (int)438L;\n+    }\n+    public static int CXCursor_WarnUnusedAttr() {\n+        return (int)439L;\n+    }\n+    public static int CXCursor_WarnUnusedResultAttr() {\n+        return (int)440L;\n+    }\n+    public static int CXCursor_AlignedAttr() {\n+        return (int)441L;\n+    }\n+    public static int CXCursor_LastAttr() {\n+        return (int)441L;\n+    }\n+    public static int CXCursor_PreprocessingDirective() {\n+        return (int)500L;\n+    }\n+    public static int CXCursor_MacroDefinition() {\n+        return (int)501L;\n+    }\n+    public static int CXCursor_MacroExpansion() {\n+        return (int)502L;\n+    }\n+    public static int CXCursor_MacroInstantiation() {\n+        return (int)502L;\n+    }\n+    public static int CXCursor_InclusionDirective() {\n+        return (int)503L;\n+    }\n+    public static int CXCursor_FirstPreprocessing() {\n+        return (int)500L;\n+    }\n+    public static int CXCursor_LastPreprocessing() {\n+        return (int)503L;\n+    }\n+    public static int CXCursor_ModuleImportDecl() {\n+        return (int)600L;\n+    }\n+    public static int CXCursor_TypeAliasTemplateDecl() {\n+        return (int)601L;\n+    }\n+    public static int CXCursor_StaticAssert() {\n+        return (int)602L;\n+    }\n+    public static int CXCursor_FriendDecl() {\n+        return (int)603L;\n+    }\n+    public static int CXCursor_FirstExtraDecl() {\n+        return (int)600L;\n+    }\n+    public static int CXCursor_LastExtraDecl() {\n+        return (int)603L;\n+    }\n+    public static int CXCursor_OverloadCandidate() {\n+        return (int)700L;\n+    }\n+    public static int CXTSK_Undeclared() {\n+        return (int)0L;\n+    }\n+    public static int CXTSK_ImplicitInstantiation() {\n+        return (int)1L;\n+    }\n+    public static int CXTSK_ExplicitSpecialization() {\n+        return (int)2L;\n+    }\n+    public static int CXTSK_ExplicitInstantiationDeclaration() {\n+        return (int)3L;\n+    }\n+    public static int CXTSK_ExplicitInstantiationDefinition() {\n+        return (int)4L;\n+    }\n+    public static class CXCursor {\n+\n+        static final MemoryLayout CXCursor$struct$LAYOUT = MemoryLayout.ofStruct(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+        );\n+        public static MemoryLayout $LAYOUT() {\n+            return CXCursor.CXCursor$struct$LAYOUT;\n+        }\n+        static final VarHandle kind$VH = CXCursor$struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"kind\"));\n+        public static VarHandle kind$VH() {\n+            return CXCursor.kind$VH;\n+        }\n+        public static int kind$get(MemorySegment seg) {\n+            return (int)CXCursor.kind$VH.get(seg);\n+        }\n+        public static void kind$set( MemorySegment seg, int x) {\n+            CXCursor.kind$VH.set(seg, x);\n+        }\n+        public static int kind$get(MemorySegment seg, long index) {\n+            return (int)CXCursor.kind$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void kind$set(MemorySegment seg, long index, int x) {\n+            CXCursor.kind$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle xdata$VH = CXCursor$struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"xdata\"));\n+        public static VarHandle xdata$VH() {\n+            return CXCursor.xdata$VH;\n+        }\n+        public static int xdata$get(MemorySegment seg) {\n+            return (int)CXCursor.xdata$VH.get(seg);\n+        }\n+        public static void xdata$set( MemorySegment seg, int x) {\n+            CXCursor.xdata$VH.set(seg, x);\n+        }\n+        public static int xdata$get(MemorySegment seg, long index) {\n+            return (int)CXCursor.xdata$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void xdata$set(MemorySegment seg, long index, int x) {\n+            CXCursor.xdata$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public static MemorySegment data$slice(MemorySegment seg) {\n+            return RuntimeHelper.nonCloseableNonTransferableSegment(seg.asSlice(8, 24));\n+        }\n+        public static long sizeof() { return $LAYOUT().byteSize(); }\n+        public static MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\n+        public static MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n+        public static MemorySegment allocateArray(int len) {\n+            return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }        public static MemorySegment allocateArray(int len, NativeScope scope) {\n+            return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }\n+        public static MemorySegment allocatePointer() {\n+            return MemorySegment.allocateNative(C_POINTER);\n+        }\n+        public static MemorySegment allocatePointer(NativeScope scope) {\n+            return scope.allocate(C_POINTER);\n+        }\n+        public static MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\n+    }\n+\n+    public static MethodHandle clang_getNullCursor$MH() {\n+        return RuntimeHelper.requireNonNull(constants$13.clang_getNullCursor$MH,\"clang_getNullCursor\");\n+    }\n+    public static MemorySegment clang_getNullCursor () {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$13.clang_getNullCursor$MH, \"clang_getNullCursor\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact();\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getTranslationUnitCursor$MH() {\n+        return RuntimeHelper.requireNonNull(constants$13.clang_getTranslationUnitCursor$MH,\"clang_getTranslationUnitCursor\");\n+    }\n+    public static MemorySegment clang_getTranslationUnitCursor ( Addressable x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$13.clang_getTranslationUnitCursor$MH, \"clang_getTranslationUnitCursor\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(x0.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_equalCursors$MH() {\n+        return RuntimeHelper.requireNonNull(constants$13.clang_equalCursors$MH,\"clang_equalCursors\");\n+    }\n+    public static int clang_equalCursors ( MemorySegment x0,  MemorySegment x1) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$13.clang_equalCursors$MH, \"clang_equalCursors\");\n+        try {\n+            return (int)mh$.invokeExact(x0, x1);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_isNull$MH() {\n+        return RuntimeHelper.requireNonNull(constants$13.clang_Cursor_isNull$MH,\"clang_Cursor_isNull\");\n+    }\n+    public static int clang_Cursor_isNull ( MemorySegment cursor) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$13.clang_Cursor_isNull$MH, \"clang_Cursor_isNull\");\n+        try {\n+            return (int)mh$.invokeExact(cursor);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_hashCursor$MH() {\n+        return RuntimeHelper.requireNonNull(constants$13.clang_hashCursor$MH,\"clang_hashCursor\");\n+    }\n+    public static int clang_hashCursor ( MemorySegment x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$13.clang_hashCursor$MH, \"clang_hashCursor\");\n+        try {\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$13 {\n+\n+        static final FunctionDescriptor clang_TargetInfo_getPointerWidth$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_TargetInfo_getPointerWidth$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_TargetInfo_getPointerWidth\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+            constants$13.clang_TargetInfo_getPointerWidth$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getNullCursor$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+        ));\n+        static final MethodHandle clang_getNullCursor$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getNullCursor\",\n+            \"()Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$13.clang_getNullCursor$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getTranslationUnitCursor$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+        ),\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getTranslationUnitCursor$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getTranslationUnitCursor\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$13.clang_getTranslationUnitCursor$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_equalCursors$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_equalCursors$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_equalCursors\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$13.clang_equalCursors$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Cursor_isNull$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Cursor_isNull$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Cursor_isNull\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$13.clang_Cursor_isNull$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_hashCursor$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_hashCursor$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_hashCursor\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$13.clang_hashCursor$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_getCursorKind$MH() {\n+        return RuntimeHelper.requireNonNull(constants$14.clang_getCursorKind$MH,\"clang_getCursorKind\");\n+    }\n+    public static int clang_getCursorKind ( MemorySegment x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$14.clang_getCursorKind$MH, \"clang_getCursorKind\");\n+        try {\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_isDeclaration$MH() {\n+        return RuntimeHelper.requireNonNull(constants$14.clang_isDeclaration$MH,\"clang_isDeclaration\");\n+    }\n+    public static int clang_isDeclaration ( int x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$14.clang_isDeclaration$MH, \"clang_isDeclaration\");\n+        try {\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_isInvalidDeclaration$MH() {\n+        return RuntimeHelper.requireNonNull(constants$14.clang_isInvalidDeclaration$MH,\"clang_isInvalidDeclaration\");\n+    }\n+    public static int clang_isInvalidDeclaration ( MemorySegment x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$14.clang_isInvalidDeclaration$MH, \"clang_isInvalidDeclaration\");\n+        try {\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_isReference$MH() {\n+        return RuntimeHelper.requireNonNull(constants$14.clang_isReference$MH,\"clang_isReference\");\n+    }\n+    public static int clang_isReference ( int x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$14.clang_isReference$MH, \"clang_isReference\");\n+        try {\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_isExpression$MH() {\n+        return RuntimeHelper.requireNonNull(constants$14.clang_isExpression$MH,\"clang_isExpression\");\n+    }\n+    public static int clang_isExpression ( int x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$14.clang_isExpression$MH, \"clang_isExpression\");\n+        try {\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_isStatement$MH() {\n+        return RuntimeHelper.requireNonNull(constants$14.clang_isStatement$MH,\"clang_isStatement\");\n+    }\n+    public static int clang_isStatement ( int x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$14.clang_isStatement$MH, \"clang_isStatement\");\n+        try {\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$14 {\n+\n+        static final FunctionDescriptor clang_getCursorKind$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getCursorKind$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCursorKind\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$14.clang_getCursorKind$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_isDeclaration$FUNC = FunctionDescriptor.of(C_INT,\n+            C_INT\n+        );\n+        static final MethodHandle clang_isDeclaration$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_isDeclaration\",\n+            \"(I)I\",\n+            constants$14.clang_isDeclaration$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_isInvalidDeclaration$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_isInvalidDeclaration$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_isInvalidDeclaration\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$14.clang_isInvalidDeclaration$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_isReference$FUNC = FunctionDescriptor.of(C_INT,\n+            C_INT\n+        );\n+        static final MethodHandle clang_isReference$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_isReference\",\n+            \"(I)I\",\n+            constants$14.clang_isReference$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_isExpression$FUNC = FunctionDescriptor.of(C_INT,\n+            C_INT\n+        );\n+        static final MethodHandle clang_isExpression$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_isExpression\",\n+            \"(I)I\",\n+            constants$14.clang_isExpression$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_isStatement$FUNC = FunctionDescriptor.of(C_INT,\n+            C_INT\n+        );\n+        static final MethodHandle clang_isStatement$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_isStatement\",\n+            \"(I)I\",\n+            constants$14.clang_isStatement$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_isAttribute$MH() {\n+        return RuntimeHelper.requireNonNull(constants$15.clang_isAttribute$MH,\"clang_isAttribute\");\n+    }\n+    public static int clang_isAttribute ( int x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$15.clang_isAttribute$MH, \"clang_isAttribute\");\n+        try {\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_hasAttrs$MH() {\n+        return RuntimeHelper.requireNonNull(constants$15.clang_Cursor_hasAttrs$MH,\"clang_Cursor_hasAttrs\");\n+    }\n+    public static int clang_Cursor_hasAttrs ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$15.clang_Cursor_hasAttrs$MH, \"clang_Cursor_hasAttrs\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_isInvalid$MH() {\n+        return RuntimeHelper.requireNonNull(constants$15.clang_isInvalid$MH,\"clang_isInvalid\");\n+    }\n+    public static int clang_isInvalid ( int x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$15.clang_isInvalid$MH, \"clang_isInvalid\");\n+        try {\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_isTranslationUnit$MH() {\n+        return RuntimeHelper.requireNonNull(constants$15.clang_isTranslationUnit$MH,\"clang_isTranslationUnit\");\n+    }\n+    public static int clang_isTranslationUnit ( int x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$15.clang_isTranslationUnit$MH, \"clang_isTranslationUnit\");\n+        try {\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_isPreprocessing$MH() {\n+        return RuntimeHelper.requireNonNull(constants$15.clang_isPreprocessing$MH,\"clang_isPreprocessing\");\n+    }\n+    public static int clang_isPreprocessing ( int x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$15.clang_isPreprocessing$MH, \"clang_isPreprocessing\");\n+        try {\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_isUnexposed$MH() {\n+        return RuntimeHelper.requireNonNull(constants$15.clang_isUnexposed$MH,\"clang_isUnexposed\");\n+    }\n+    public static int clang_isUnexposed ( int x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$15.clang_isUnexposed$MH, \"clang_isUnexposed\");\n+        try {\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXLinkage_Invalid() {\n+        return (int)0L;\n+    }\n+    public static int CXLinkage_NoLinkage() {\n+        return (int)1L;\n+    }\n+    public static int CXLinkage_Internal() {\n+        return (int)2L;\n+    }\n+    public static int CXLinkage_UniqueExternal() {\n+        return (int)3L;\n+    }\n+    public static int CXLinkage_External() {\n+        return (int)4L;\n+    }\n+    public static class constants$15 {\n+\n+        static final FunctionDescriptor clang_isAttribute$FUNC = FunctionDescriptor.of(C_INT,\n+            C_INT\n+        );\n+        static final MethodHandle clang_isAttribute$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_isAttribute\",\n+            \"(I)I\",\n+            constants$15.clang_isAttribute$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Cursor_hasAttrs$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Cursor_hasAttrs$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Cursor_hasAttrs\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$15.clang_Cursor_hasAttrs$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_isInvalid$FUNC = FunctionDescriptor.of(C_INT,\n+            C_INT\n+        );\n+        static final MethodHandle clang_isInvalid$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_isInvalid\",\n+            \"(I)I\",\n+            constants$15.clang_isInvalid$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_isTranslationUnit$FUNC = FunctionDescriptor.of(C_INT,\n+            C_INT\n+        );\n+        static final MethodHandle clang_isTranslationUnit$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_isTranslationUnit\",\n+            \"(I)I\",\n+            constants$15.clang_isTranslationUnit$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_isPreprocessing$FUNC = FunctionDescriptor.of(C_INT,\n+            C_INT\n+        );\n+        static final MethodHandle clang_isPreprocessing$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_isPreprocessing\",\n+            \"(I)I\",\n+            constants$15.clang_isPreprocessing$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_isUnexposed$FUNC = FunctionDescriptor.of(C_INT,\n+            C_INT\n+        );\n+        static final MethodHandle clang_isUnexposed$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_isUnexposed\",\n+            \"(I)I\",\n+            constants$15.clang_isUnexposed$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_getCursorLinkage$MH() {\n+        return RuntimeHelper.requireNonNull(constants$16.clang_getCursorLinkage$MH,\"clang_getCursorLinkage\");\n+    }\n+    public static int clang_getCursorLinkage ( MemorySegment cursor) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$16.clang_getCursorLinkage$MH, \"clang_getCursorLinkage\");\n+        try {\n+            return (int)mh$.invokeExact(cursor);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXVisibility_Invalid() {\n+        return (int)0L;\n+    }\n+    public static int CXVisibility_Hidden() {\n+        return (int)1L;\n+    }\n+    public static int CXVisibility_Protected() {\n+        return (int)2L;\n+    }\n+    public static int CXVisibility_Default() {\n+        return (int)3L;\n+    }\n+    public static MethodHandle clang_getCursorVisibility$MH() {\n+        return RuntimeHelper.requireNonNull(constants$16.clang_getCursorVisibility$MH,\"clang_getCursorVisibility\");\n+    }\n+    public static int clang_getCursorVisibility ( MemorySegment cursor) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$16.clang_getCursorVisibility$MH, \"clang_getCursorVisibility\");\n+        try {\n+            return (int)mh$.invokeExact(cursor);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getCursorAvailability$MH() {\n+        return RuntimeHelper.requireNonNull(constants$16.clang_getCursorAvailability$MH,\"clang_getCursorAvailability\");\n+    }\n+    public static int clang_getCursorAvailability ( MemorySegment cursor) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$16.clang_getCursorAvailability$MH, \"clang_getCursorAvailability\");\n+        try {\n+            return (int)mh$.invokeExact(cursor);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class CXPlatformAvailability {\n+\n+        static final MemoryLayout CXPlatformAvailability$struct$LAYOUT = MemoryLayout.ofStruct(\n+            MemoryLayout.ofStruct(\n+                C_POINTER.withName(\"data\"),\n+                C_INT.withName(\"private_flags\"),\n+                MemoryLayout.ofPaddingBits(32)\n+            ).withName(\"Platform\"),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"Major\"),\n+                C_INT.withName(\"Minor\"),\n+                C_INT.withName(\"Subminor\")\n+            ).withName(\"Introduced\"),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"Major\"),\n+                C_INT.withName(\"Minor\"),\n+                C_INT.withName(\"Subminor\")\n+            ).withName(\"Deprecated\"),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"Major\"),\n+                C_INT.withName(\"Minor\"),\n+                C_INT.withName(\"Subminor\")\n+            ).withName(\"Obsoleted\"),\n+            C_INT.withName(\"Unavailable\"),\n+            MemoryLayout.ofStruct(\n+                C_POINTER.withName(\"data\"),\n+                C_INT.withName(\"private_flags\"),\n+                MemoryLayout.ofPaddingBits(32)\n+            ).withName(\"Message\")\n+        ).withName(\"CXPlatformAvailability\");\n+        public static MemoryLayout $LAYOUT() {\n+            return CXPlatformAvailability.CXPlatformAvailability$struct$LAYOUT;\n+        }\n+        public static MemorySegment Platform$slice(MemorySegment seg) {\n+            return RuntimeHelper.nonCloseableNonTransferableSegment(seg.asSlice(0, 16));\n+        }\n+        public static MemorySegment Introduced$slice(MemorySegment seg) {\n+            return RuntimeHelper.nonCloseableNonTransferableSegment(seg.asSlice(16, 12));\n+        }\n+        public static MemorySegment Deprecated$slice(MemorySegment seg) {\n+            return RuntimeHelper.nonCloseableNonTransferableSegment(seg.asSlice(28, 12));\n+        }\n+        public static MemorySegment Obsoleted$slice(MemorySegment seg) {\n+            return RuntimeHelper.nonCloseableNonTransferableSegment(seg.asSlice(40, 12));\n+        }\n+        static final VarHandle Unavailable$VH = CXPlatformAvailability$struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"Unavailable\"));\n+        public static VarHandle Unavailable$VH() {\n+            return CXPlatformAvailability.Unavailable$VH;\n+        }\n+        public static int Unavailable$get(MemorySegment seg) {\n+            return (int)CXPlatformAvailability.Unavailable$VH.get(seg);\n+        }\n+        public static void Unavailable$set( MemorySegment seg, int x) {\n+            CXPlatformAvailability.Unavailable$VH.set(seg, x);\n+        }\n+        public static int Unavailable$get(MemorySegment seg, long index) {\n+            return (int)CXPlatformAvailability.Unavailable$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void Unavailable$set(MemorySegment seg, long index, int x) {\n+            CXPlatformAvailability.Unavailable$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public static MemorySegment Message$slice(MemorySegment seg) {\n+            return RuntimeHelper.nonCloseableNonTransferableSegment(seg.asSlice(56, 16));\n+        }\n+        public static long sizeof() { return $LAYOUT().byteSize(); }\n+        public static MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\n+        public static MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n+        public static MemorySegment allocateArray(int len) {\n+            return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }        public static MemorySegment allocateArray(int len, NativeScope scope) {\n+            return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }\n+        public static MemorySegment allocatePointer() {\n+            return MemorySegment.allocateNative(C_POINTER);\n+        }\n+        public static MemorySegment allocatePointer(NativeScope scope) {\n+            return scope.allocate(C_POINTER);\n+        }\n+        public static MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\n+    }\n+\n+    public static MethodHandle clang_getCursorPlatformAvailability$MH() {\n+        return RuntimeHelper.requireNonNull(constants$16.clang_getCursorPlatformAvailability$MH,\"clang_getCursorPlatformAvailability\");\n+    }\n+    public static int clang_getCursorPlatformAvailability ( MemorySegment cursor,  Addressable always_deprecated,  Addressable deprecated_message,  Addressable always_unavailable,  Addressable unavailable_message,  Addressable availability,  int availability_size) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$16.clang_getCursorPlatformAvailability$MH, \"clang_getCursorPlatformAvailability\");\n+        try {\n+            return (int)mh$.invokeExact(cursor, always_deprecated.address(), deprecated_message.address(), always_unavailable.address(), unavailable_message.address(), availability.address(), availability_size);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_disposeCXPlatformAvailability$MH() {\n+        return RuntimeHelper.requireNonNull(constants$16.clang_disposeCXPlatformAvailability$MH,\"clang_disposeCXPlatformAvailability\");\n+    }\n+    public static void clang_disposeCXPlatformAvailability ( Addressable availability) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$16.clang_disposeCXPlatformAvailability$MH, \"clang_disposeCXPlatformAvailability\");\n+        try {\n+            mh$.invokeExact(availability.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXLanguage_Invalid() {\n+        return (int)0L;\n+    }\n+    public static int CXLanguage_C() {\n+        return (int)1L;\n+    }\n+    public static int CXLanguage_ObjC() {\n+        return (int)2L;\n+    }\n+    public static int CXLanguage_CPlusPlus() {\n+        return (int)3L;\n+    }\n+    public static MethodHandle clang_getCursorLanguage$MH() {\n+        return RuntimeHelper.requireNonNull(constants$16.clang_getCursorLanguage$MH,\"clang_getCursorLanguage\");\n+    }\n+    public static int clang_getCursorLanguage ( MemorySegment cursor) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$16.clang_getCursorLanguage$MH, \"clang_getCursorLanguage\");\n+        try {\n+            return (int)mh$.invokeExact(cursor);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXTLS_None() {\n+        return (int)0L;\n+    }\n+    public static int CXTLS_Dynamic() {\n+        return (int)1L;\n+    }\n+    public static int CXTLS_Static() {\n+        return (int)2L;\n+    }\n+    public static class constants$16 {\n+\n+        static final FunctionDescriptor clang_getCursorLinkage$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getCursorLinkage$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCursorLinkage\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$16.clang_getCursorLinkage$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getCursorVisibility$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getCursorVisibility$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCursorVisibility\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$16.clang_getCursorVisibility$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getCursorAvailability$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getCursorAvailability$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCursorAvailability\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$16.clang_getCursorAvailability$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getCursorPlatformAvailability$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            ),\n+            C_POINTER,\n+            C_POINTER,\n+            C_POINTER,\n+            C_POINTER,\n+            C_POINTER,\n+            C_INT\n+        );\n+        static final MethodHandle clang_getCursorPlatformAvailability$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCursorPlatformAvailability\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;I)I\",\n+            constants$16.clang_getCursorPlatformAvailability$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_disposeCXPlatformAvailability$FUNC = FunctionDescriptor.ofVoid(\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_disposeCXPlatformAvailability$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_disposeCXPlatformAvailability\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)V\",\n+            constants$16.clang_disposeCXPlatformAvailability$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getCursorLanguage$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getCursorLanguage$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCursorLanguage\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$16.clang_getCursorLanguage$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_getCursorTLSKind$MH() {\n+        return RuntimeHelper.requireNonNull(constants$17.clang_getCursorTLSKind$MH,\"clang_getCursorTLSKind\");\n+    }\n+    public static int clang_getCursorTLSKind ( MemorySegment cursor) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$17.clang_getCursorTLSKind$MH, \"clang_getCursorTLSKind\");\n+        try {\n+            return (int)mh$.invokeExact(cursor);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_getTranslationUnit$MH() {\n+        return RuntimeHelper.requireNonNull(constants$17.clang_Cursor_getTranslationUnit$MH,\"clang_Cursor_getTranslationUnit\");\n+    }\n+    public static MemoryAddress clang_Cursor_getTranslationUnit ( MemorySegment x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$17.clang_Cursor_getTranslationUnit$MH, \"clang_Cursor_getTranslationUnit\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_createCXCursorSet$MH() {\n+        return RuntimeHelper.requireNonNull(constants$17.clang_createCXCursorSet$MH,\"clang_createCXCursorSet\");\n+    }\n+    public static MemoryAddress clang_createCXCursorSet () {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$17.clang_createCXCursorSet$MH, \"clang_createCXCursorSet\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact();\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_disposeCXCursorSet$MH() {\n+        return RuntimeHelper.requireNonNull(constants$17.clang_disposeCXCursorSet$MH,\"clang_disposeCXCursorSet\");\n+    }\n+    public static void clang_disposeCXCursorSet ( Addressable cset) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$17.clang_disposeCXCursorSet$MH, \"clang_disposeCXCursorSet\");\n+        try {\n+            mh$.invokeExact(cset.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_CXCursorSet_contains$MH() {\n+        return RuntimeHelper.requireNonNull(constants$17.clang_CXCursorSet_contains$MH,\"clang_CXCursorSet_contains\");\n+    }\n+    public static int clang_CXCursorSet_contains ( Addressable cset,  MemorySegment cursor) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$17.clang_CXCursorSet_contains$MH, \"clang_CXCursorSet_contains\");\n+        try {\n+            return (int)mh$.invokeExact(cset.address(), cursor);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_CXCursorSet_insert$MH() {\n+        return RuntimeHelper.requireNonNull(constants$17.clang_CXCursorSet_insert$MH,\"clang_CXCursorSet_insert\");\n+    }\n+    public static int clang_CXCursorSet_insert ( Addressable cset,  MemorySegment cursor) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$17.clang_CXCursorSet_insert$MH, \"clang_CXCursorSet_insert\");\n+        try {\n+            return (int)mh$.invokeExact(cset.address(), cursor);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$17 {\n+\n+        static final FunctionDescriptor clang_getCursorTLSKind$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getCursorTLSKind$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCursorTLSKind\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$17.clang_getCursorTLSKind$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Cursor_getTranslationUnit$FUNC = FunctionDescriptor.of(C_POINTER,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Cursor_getTranslationUnit$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Cursor_getTranslationUnit\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$17.clang_Cursor_getTranslationUnit$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_createCXCursorSet$FUNC = FunctionDescriptor.of(C_POINTER);\n+        static final MethodHandle clang_createCXCursorSet$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_createCXCursorSet\",\n+            \"()Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$17.clang_createCXCursorSet$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_disposeCXCursorSet$FUNC = FunctionDescriptor.ofVoid(\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_disposeCXCursorSet$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_disposeCXCursorSet\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)V\",\n+            constants$17.clang_disposeCXCursorSet$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_CXCursorSet_contains$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_CXCursorSet_contains$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_CXCursorSet_contains\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$17.clang_CXCursorSet_contains$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_CXCursorSet_insert$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_CXCursorSet_insert$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_CXCursorSet_insert\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$17.clang_CXCursorSet_insert$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_getCursorSemanticParent$MH() {\n+        return RuntimeHelper.requireNonNull(constants$18.clang_getCursorSemanticParent$MH,\"clang_getCursorSemanticParent\");\n+    }\n+    public static MemorySegment clang_getCursorSemanticParent ( MemorySegment cursor) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$18.clang_getCursorSemanticParent$MH, \"clang_getCursorSemanticParent\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(cursor);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getCursorLexicalParent$MH() {\n+        return RuntimeHelper.requireNonNull(constants$18.clang_getCursorLexicalParent$MH,\"clang_getCursorLexicalParent\");\n+    }\n+    public static MemorySegment clang_getCursorLexicalParent ( MemorySegment cursor) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$18.clang_getCursorLexicalParent$MH, \"clang_getCursorLexicalParent\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(cursor);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getOverriddenCursors$MH() {\n+        return RuntimeHelper.requireNonNull(constants$18.clang_getOverriddenCursors$MH,\"clang_getOverriddenCursors\");\n+    }\n+    public static void clang_getOverriddenCursors ( MemorySegment cursor,  Addressable overridden,  Addressable num_overridden) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$18.clang_getOverriddenCursors$MH, \"clang_getOverriddenCursors\");\n+        try {\n+            mh$.invokeExact(cursor, overridden.address(), num_overridden.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_disposeOverriddenCursors$MH() {\n+        return RuntimeHelper.requireNonNull(constants$18.clang_disposeOverriddenCursors$MH,\"clang_disposeOverriddenCursors\");\n+    }\n+    public static void clang_disposeOverriddenCursors ( Addressable overridden) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$18.clang_disposeOverriddenCursors$MH, \"clang_disposeOverriddenCursors\");\n+        try {\n+            mh$.invokeExact(overridden.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getIncludedFile$MH() {\n+        return RuntimeHelper.requireNonNull(constants$18.clang_getIncludedFile$MH,\"clang_getIncludedFile\");\n+    }\n+    public static MemoryAddress clang_getIncludedFile ( MemorySegment cursor) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$18.clang_getIncludedFile$MH, \"clang_getIncludedFile\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(cursor);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getCursor$MH() {\n+        return RuntimeHelper.requireNonNull(constants$18.clang_getCursor$MH,\"clang_getCursor\");\n+    }\n+    public static MemorySegment clang_getCursor ( Addressable x0,  MemorySegment x1) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$18.clang_getCursor$MH, \"clang_getCursor\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(x0.address(), x1);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$18 {\n+\n+        static final FunctionDescriptor clang_getCursorSemanticParent$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getCursorSemanticParent$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCursorSemanticParent\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$18.clang_getCursorSemanticParent$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getCursorLexicalParent$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getCursorLexicalParent$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCursorLexicalParent\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$18.clang_getCursorLexicalParent$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getOverriddenCursors$FUNC = FunctionDescriptor.ofVoid(\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            ),\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getOverriddenCursors$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getOverriddenCursors\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)V\",\n+            constants$18.clang_getOverriddenCursors$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_disposeOverriddenCursors$FUNC = FunctionDescriptor.ofVoid(\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_disposeOverriddenCursors$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_disposeOverriddenCursors\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)V\",\n+            constants$18.clang_disposeOverriddenCursors$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getIncludedFile$FUNC = FunctionDescriptor.of(C_POINTER,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getIncludedFile$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getIncludedFile\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$18.clang_getIncludedFile$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getCursor$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+        ),\n+            C_POINTER,\n+            MemoryLayout.ofStruct(\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+                C_INT.withName(\"int_data\"),\n+                MemoryLayout.ofPaddingBits(32)\n+            )\n+        );\n+        static final MethodHandle clang_getCursor$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCursor\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$18.clang_getCursor$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_getCursorLocation$MH() {\n+        return RuntimeHelper.requireNonNull(constants$19.clang_getCursorLocation$MH,\"clang_getCursorLocation\");\n+    }\n+    public static MemorySegment clang_getCursorLocation ( MemorySegment x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$19.clang_getCursorLocation$MH, \"clang_getCursorLocation\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getCursorExtent$MH() {\n+        return RuntimeHelper.requireNonNull(constants$19.clang_getCursorExtent$MH,\"clang_getCursorExtent\");\n+    }\n+    public static MemorySegment clang_getCursorExtent ( MemorySegment x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$19.clang_getCursorExtent$MH, \"clang_getCursorExtent\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXType_Invalid() {\n+        return (int)0L;\n+    }\n+    public static int CXType_Unexposed() {\n+        return (int)1L;\n+    }\n+    public static int CXType_Void() {\n+        return (int)2L;\n+    }\n+    public static int CXType_Bool() {\n+        return (int)3L;\n+    }\n+    public static int CXType_Char_U() {\n+        return (int)4L;\n+    }\n+    public static int CXType_UChar() {\n+        return (int)5L;\n+    }\n+    public static int CXType_Char16() {\n+        return (int)6L;\n+    }\n+    public static int CXType_Char32() {\n+        return (int)7L;\n+    }\n+    public static int CXType_UShort() {\n+        return (int)8L;\n+    }\n+    public static int CXType_UInt() {\n+        return (int)9L;\n+    }\n+    public static int CXType_ULong() {\n+        return (int)10L;\n+    }\n+    public static int CXType_ULongLong() {\n+        return (int)11L;\n+    }\n+    public static int CXType_UInt128() {\n+        return (int)12L;\n+    }\n+    public static int CXType_Char_S() {\n+        return (int)13L;\n+    }\n+    public static int CXType_SChar() {\n+        return (int)14L;\n+    }\n+    public static int CXType_WChar() {\n+        return (int)15L;\n+    }\n+    public static int CXType_Short() {\n+        return (int)16L;\n+    }\n+    public static int CXType_Int() {\n+        return (int)17L;\n+    }\n+    public static int CXType_Long() {\n+        return (int)18L;\n+    }\n+    public static int CXType_LongLong() {\n+        return (int)19L;\n+    }\n+    public static int CXType_Int128() {\n+        return (int)20L;\n+    }\n+    public static int CXType_Float() {\n+        return (int)21L;\n+    }\n+    public static int CXType_Double() {\n+        return (int)22L;\n+    }\n+    public static int CXType_LongDouble() {\n+        return (int)23L;\n+    }\n+    public static int CXType_NullPtr() {\n+        return (int)24L;\n+    }\n+    public static int CXType_Overload() {\n+        return (int)25L;\n+    }\n+    public static int CXType_Dependent() {\n+        return (int)26L;\n+    }\n+    public static int CXType_ObjCId() {\n+        return (int)27L;\n+    }\n+    public static int CXType_ObjCClass() {\n+        return (int)28L;\n+    }\n+    public static int CXType_ObjCSel() {\n+        return (int)29L;\n+    }\n+    public static int CXType_Float128() {\n+        return (int)30L;\n+    }\n+    public static int CXType_Half() {\n+        return (int)31L;\n+    }\n+    public static int CXType_Float16() {\n+        return (int)32L;\n+    }\n+    public static int CXType_ShortAccum() {\n+        return (int)33L;\n+    }\n+    public static int CXType_Accum() {\n+        return (int)34L;\n+    }\n+    public static int CXType_LongAccum() {\n+        return (int)35L;\n+    }\n+    public static int CXType_UShortAccum() {\n+        return (int)36L;\n+    }\n+    public static int CXType_UAccum() {\n+        return (int)37L;\n+    }\n+    public static int CXType_ULongAccum() {\n+        return (int)38L;\n+    }\n+    public static int CXType_FirstBuiltin() {\n+        return (int)2L;\n+    }\n+    public static int CXType_LastBuiltin() {\n+        return (int)38L;\n+    }\n+    public static int CXType_Complex() {\n+        return (int)100L;\n+    }\n+    public static int CXType_Pointer() {\n+        return (int)101L;\n+    }\n+    public static int CXType_BlockPointer() {\n+        return (int)102L;\n+    }\n+    public static int CXType_LValueReference() {\n+        return (int)103L;\n+    }\n+    public static int CXType_RValueReference() {\n+        return (int)104L;\n+    }\n+    public static int CXType_Record() {\n+        return (int)105L;\n+    }\n+    public static int CXType_Enum() {\n+        return (int)106L;\n+    }\n+    public static int CXType_Typedef() {\n+        return (int)107L;\n+    }\n+    public static int CXType_ObjCInterface() {\n+        return (int)108L;\n+    }\n+    public static int CXType_ObjCObjectPointer() {\n+        return (int)109L;\n+    }\n+    public static int CXType_FunctionNoProto() {\n+        return (int)110L;\n+    }\n+    public static int CXType_FunctionProto() {\n+        return (int)111L;\n+    }\n+    public static int CXType_ConstantArray() {\n+        return (int)112L;\n+    }\n+    public static int CXType_Vector() {\n+        return (int)113L;\n+    }\n+    public static int CXType_IncompleteArray() {\n+        return (int)114L;\n+    }\n+    public static int CXType_VariableArray() {\n+        return (int)115L;\n+    }\n+    public static int CXType_DependentSizedArray() {\n+        return (int)116L;\n+    }\n+    public static int CXType_MemberPointer() {\n+        return (int)117L;\n+    }\n+    public static int CXType_Auto() {\n+        return (int)118L;\n+    }\n+    public static int CXType_Elaborated() {\n+        return (int)119L;\n+    }\n+    public static int CXType_Pipe() {\n+        return (int)120L;\n+    }\n+    public static int CXType_OCLImage1dRO() {\n+        return (int)121L;\n+    }\n+    public static int CXType_OCLImage1dArrayRO() {\n+        return (int)122L;\n+    }\n+    public static int CXType_OCLImage1dBufferRO() {\n+        return (int)123L;\n+    }\n+    public static int CXType_OCLImage2dRO() {\n+        return (int)124L;\n+    }\n+    public static int CXType_OCLImage2dArrayRO() {\n+        return (int)125L;\n+    }\n+    public static int CXType_OCLImage2dDepthRO() {\n+        return (int)126L;\n+    }\n+    public static int CXType_OCLImage2dArrayDepthRO() {\n+        return (int)127L;\n+    }\n+    public static int CXType_OCLImage2dMSAARO() {\n+        return (int)128L;\n+    }\n+    public static int CXType_OCLImage2dArrayMSAARO() {\n+        return (int)129L;\n+    }\n+    public static int CXType_OCLImage2dMSAADepthRO() {\n+        return (int)130L;\n+    }\n+    public static int CXType_OCLImage2dArrayMSAADepthRO() {\n+        return (int)131L;\n+    }\n+    public static int CXType_OCLImage3dRO() {\n+        return (int)132L;\n+    }\n+    public static int CXType_OCLImage1dWO() {\n+        return (int)133L;\n+    }\n+    public static int CXType_OCLImage1dArrayWO() {\n+        return (int)134L;\n+    }\n+    public static int CXType_OCLImage1dBufferWO() {\n+        return (int)135L;\n+    }\n+    public static int CXType_OCLImage2dWO() {\n+        return (int)136L;\n+    }\n+    public static int CXType_OCLImage2dArrayWO() {\n+        return (int)137L;\n+    }\n+    public static int CXType_OCLImage2dDepthWO() {\n+        return (int)138L;\n+    }\n+    public static int CXType_OCLImage2dArrayDepthWO() {\n+        return (int)139L;\n+    }\n+    public static int CXType_OCLImage2dMSAAWO() {\n+        return (int)140L;\n+    }\n+    public static int CXType_OCLImage2dArrayMSAAWO() {\n+        return (int)141L;\n+    }\n+    public static int CXType_OCLImage2dMSAADepthWO() {\n+        return (int)142L;\n+    }\n+    public static int CXType_OCLImage2dArrayMSAADepthWO() {\n+        return (int)143L;\n+    }\n+    public static int CXType_OCLImage3dWO() {\n+        return (int)144L;\n+    }\n+    public static int CXType_OCLImage1dRW() {\n+        return (int)145L;\n+    }\n+    public static int CXType_OCLImage1dArrayRW() {\n+        return (int)146L;\n+    }\n+    public static int CXType_OCLImage1dBufferRW() {\n+        return (int)147L;\n+    }\n+    public static int CXType_OCLImage2dRW() {\n+        return (int)148L;\n+    }\n+    public static int CXType_OCLImage2dArrayRW() {\n+        return (int)149L;\n+    }\n+    public static int CXType_OCLImage2dDepthRW() {\n+        return (int)150L;\n+    }\n+    public static int CXType_OCLImage2dArrayDepthRW() {\n+        return (int)151L;\n+    }\n+    public static int CXType_OCLImage2dMSAARW() {\n+        return (int)152L;\n+    }\n+    public static int CXType_OCLImage2dArrayMSAARW() {\n+        return (int)153L;\n+    }\n+    public static int CXType_OCLImage2dMSAADepthRW() {\n+        return (int)154L;\n+    }\n+    public static int CXType_OCLImage2dArrayMSAADepthRW() {\n+        return (int)155L;\n+    }\n+    public static int CXType_OCLImage3dRW() {\n+        return (int)156L;\n+    }\n+    public static int CXType_OCLSampler() {\n+        return (int)157L;\n+    }\n+    public static int CXType_OCLEvent() {\n+        return (int)158L;\n+    }\n+    public static int CXType_OCLQueue() {\n+        return (int)159L;\n+    }\n+    public static int CXType_OCLReserveID() {\n+        return (int)160L;\n+    }\n+    public static int CXType_ObjCObject() {\n+        return (int)161L;\n+    }\n+    public static int CXType_ObjCTypeParam() {\n+        return (int)162L;\n+    }\n+    public static int CXType_Attributed() {\n+        return (int)163L;\n+    }\n+    public static int CXType_OCLIntelSubgroupAVCMcePayload() {\n+        return (int)164L;\n+    }\n+    public static int CXType_OCLIntelSubgroupAVCImePayload() {\n+        return (int)165L;\n+    }\n+    public static int CXType_OCLIntelSubgroupAVCRefPayload() {\n+        return (int)166L;\n+    }\n+    public static int CXType_OCLIntelSubgroupAVCSicPayload() {\n+        return (int)167L;\n+    }\n+    public static int CXType_OCLIntelSubgroupAVCMceResult() {\n+        return (int)168L;\n+    }\n+    public static int CXType_OCLIntelSubgroupAVCImeResult() {\n+        return (int)169L;\n+    }\n+    public static int CXType_OCLIntelSubgroupAVCRefResult() {\n+        return (int)170L;\n+    }\n+    public static int CXType_OCLIntelSubgroupAVCSicResult() {\n+        return (int)171L;\n+    }\n+    public static int CXType_OCLIntelSubgroupAVCImeResultSingleRefStreamout() {\n+        return (int)172L;\n+    }\n+    public static int CXType_OCLIntelSubgroupAVCImeResultDualRefStreamout() {\n+        return (int)173L;\n+    }\n+    public static int CXType_OCLIntelSubgroupAVCImeSingleRefStreamin() {\n+        return (int)174L;\n+    }\n+    public static int CXType_OCLIntelSubgroupAVCImeDualRefStreamin() {\n+        return (int)175L;\n+    }\n+    public static int CXType_ExtVector() {\n+        return (int)176L;\n+    }\n+    public static int CXCallingConv_Default() {\n+        return (int)0L;\n+    }\n+    public static int CXCallingConv_C() {\n+        return (int)1L;\n+    }\n+    public static int CXCallingConv_X86StdCall() {\n+        return (int)2L;\n+    }\n+    public static int CXCallingConv_X86FastCall() {\n+        return (int)3L;\n+    }\n+    public static int CXCallingConv_X86ThisCall() {\n+        return (int)4L;\n+    }\n+    public static int CXCallingConv_X86Pascal() {\n+        return (int)5L;\n+    }\n+    public static int CXCallingConv_AAPCS() {\n+        return (int)6L;\n+    }\n+    public static int CXCallingConv_AAPCS_VFP() {\n+        return (int)7L;\n+    }\n+    public static int CXCallingConv_X86RegCall() {\n+        return (int)8L;\n+    }\n+    public static int CXCallingConv_IntelOclBicc() {\n+        return (int)9L;\n+    }\n+    public static int CXCallingConv_Win64() {\n+        return (int)10L;\n+    }\n+    public static int CXCallingConv_X86_64Win64() {\n+        return (int)10L;\n+    }\n+    public static int CXCallingConv_X86_64SysV() {\n+        return (int)11L;\n+    }\n+    public static int CXCallingConv_X86VectorCall() {\n+        return (int)12L;\n+    }\n+    public static int CXCallingConv_Swift() {\n+        return (int)13L;\n+    }\n+    public static int CXCallingConv_PreserveMost() {\n+        return (int)14L;\n+    }\n+    public static int CXCallingConv_PreserveAll() {\n+        return (int)15L;\n+    }\n+    public static int CXCallingConv_AArch64VectorCall() {\n+        return (int)16L;\n+    }\n+    public static int CXCallingConv_Invalid() {\n+        return (int)100L;\n+    }\n+    public static int CXCallingConv_Unexposed() {\n+        return (int)200L;\n+    }\n+    public static class CXType {\n+\n+        static final MemoryLayout CXType$struct$LAYOUT = MemoryLayout.ofStruct(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.ofPaddingBits(32),\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+        );\n+        public static MemoryLayout $LAYOUT() {\n+            return CXType.CXType$struct$LAYOUT;\n+        }\n+        static final VarHandle kind$VH = CXType$struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"kind\"));\n+        public static VarHandle kind$VH() {\n+            return CXType.kind$VH;\n+        }\n+        public static int kind$get(MemorySegment seg) {\n+            return (int)CXType.kind$VH.get(seg);\n+        }\n+        public static void kind$set( MemorySegment seg, int x) {\n+            CXType.kind$VH.set(seg, x);\n+        }\n+        public static int kind$get(MemorySegment seg, long index) {\n+            return (int)CXType.kind$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void kind$set(MemorySegment seg, long index, int x) {\n+            CXType.kind$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public static MemorySegment data$slice(MemorySegment seg) {\n+            return RuntimeHelper.nonCloseableNonTransferableSegment(seg.asSlice(8, 16));\n+        }\n+        public static long sizeof() { return $LAYOUT().byteSize(); }\n+        public static MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\n+        public static MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n+        public static MemorySegment allocateArray(int len) {\n+            return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }        public static MemorySegment allocateArray(int len, NativeScope scope) {\n+            return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }\n+        public static MemorySegment allocatePointer() {\n+            return MemorySegment.allocateNative(C_POINTER);\n+        }\n+        public static MemorySegment allocatePointer(NativeScope scope) {\n+            return scope.allocate(C_POINTER);\n+        }\n+        public static MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\n+    }\n+\n+    public static MethodHandle clang_getCursorType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$19.clang_getCursorType$MH,\"clang_getCursorType\");\n+    }\n+    public static MemorySegment clang_getCursorType ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$19.clang_getCursorType$MH, \"clang_getCursorType\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getTypeSpelling$MH() {\n+        return RuntimeHelper.requireNonNull(constants$19.clang_getTypeSpelling$MH,\"clang_getTypeSpelling\");\n+    }\n+    public static MemorySegment clang_getTypeSpelling ( MemorySegment CT) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$19.clang_getTypeSpelling$MH, \"clang_getTypeSpelling\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(CT);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getTypedefDeclUnderlyingType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$19.clang_getTypedefDeclUnderlyingType$MH,\"clang_getTypedefDeclUnderlyingType\");\n+    }\n+    public static MemorySegment clang_getTypedefDeclUnderlyingType ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$19.clang_getTypedefDeclUnderlyingType$MH, \"clang_getTypedefDeclUnderlyingType\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getEnumDeclIntegerType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$19.clang_getEnumDeclIntegerType$MH,\"clang_getEnumDeclIntegerType\");\n+    }\n+    public static MemorySegment clang_getEnumDeclIntegerType ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$19.clang_getEnumDeclIntegerType$MH, \"clang_getEnumDeclIntegerType\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$19 {\n+\n+        static final FunctionDescriptor clang_getCursorLocation$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+            C_INT.withName(\"int_data\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getCursorLocation$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCursorLocation\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$19.clang_getCursorLocation$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getCursorExtent$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+            C_INT.withName(\"begin_int_data\"),\n+            C_INT.withName(\"end_int_data\")\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getCursorExtent$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCursorExtent\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$19.clang_getCursorExtent$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getCursorType$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.ofPaddingBits(32),\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getCursorType$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCursorType\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$19.clang_getCursorType$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getTypeSpelling$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getTypeSpelling$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getTypeSpelling\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$19.clang_getTypeSpelling$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getTypedefDeclUnderlyingType$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.ofPaddingBits(32),\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getTypedefDeclUnderlyingType$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getTypedefDeclUnderlyingType\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$19.clang_getTypedefDeclUnderlyingType$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getEnumDeclIntegerType$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.ofPaddingBits(32),\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getEnumDeclIntegerType$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getEnumDeclIntegerType\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$19.clang_getEnumDeclIntegerType$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_getEnumConstantDeclValue$MH() {\n+        return RuntimeHelper.requireNonNull(constants$20.clang_getEnumConstantDeclValue$MH,\"clang_getEnumConstantDeclValue\");\n+    }\n+    public static long clang_getEnumConstantDeclValue ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$20.clang_getEnumConstantDeclValue$MH, \"clang_getEnumConstantDeclValue\");\n+        try {\n+            return (long)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getEnumConstantDeclUnsignedValue$MH() {\n+        return RuntimeHelper.requireNonNull(constants$20.clang_getEnumConstantDeclUnsignedValue$MH,\"clang_getEnumConstantDeclUnsignedValue\");\n+    }\n+    public static long clang_getEnumConstantDeclUnsignedValue ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$20.clang_getEnumConstantDeclUnsignedValue$MH, \"clang_getEnumConstantDeclUnsignedValue\");\n+        try {\n+            return (long)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getFieldDeclBitWidth$MH() {\n+        return RuntimeHelper.requireNonNull(constants$20.clang_getFieldDeclBitWidth$MH,\"clang_getFieldDeclBitWidth\");\n+    }\n+    public static int clang_getFieldDeclBitWidth ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$20.clang_getFieldDeclBitWidth$MH, \"clang_getFieldDeclBitWidth\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_getNumArguments$MH() {\n+        return RuntimeHelper.requireNonNull(constants$20.clang_Cursor_getNumArguments$MH,\"clang_Cursor_getNumArguments\");\n+    }\n+    public static int clang_Cursor_getNumArguments ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$20.clang_Cursor_getNumArguments$MH, \"clang_Cursor_getNumArguments\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_getArgument$MH() {\n+        return RuntimeHelper.requireNonNull(constants$20.clang_Cursor_getArgument$MH,\"clang_Cursor_getArgument\");\n+    }\n+    public static MemorySegment clang_Cursor_getArgument ( MemorySegment C,  int i) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$20.clang_Cursor_getArgument$MH, \"clang_Cursor_getArgument\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(C, i);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXTemplateArgumentKind_Null() {\n+        return (int)0L;\n+    }\n+    public static int CXTemplateArgumentKind_Type() {\n+        return (int)1L;\n+    }\n+    public static int CXTemplateArgumentKind_Declaration() {\n+        return (int)2L;\n+    }\n+    public static int CXTemplateArgumentKind_NullPtr() {\n+        return (int)3L;\n+    }\n+    public static int CXTemplateArgumentKind_Integral() {\n+        return (int)4L;\n+    }\n+    public static int CXTemplateArgumentKind_Template() {\n+        return (int)5L;\n+    }\n+    public static int CXTemplateArgumentKind_TemplateExpansion() {\n+        return (int)6L;\n+    }\n+    public static int CXTemplateArgumentKind_Expression() {\n+        return (int)7L;\n+    }\n+    public static int CXTemplateArgumentKind_Pack() {\n+        return (int)8L;\n+    }\n+    public static int CXTemplateArgumentKind_Invalid() {\n+        return (int)9L;\n+    }\n+    public static MethodHandle clang_Cursor_getNumTemplateArguments$MH() {\n+        return RuntimeHelper.requireNonNull(constants$20.clang_Cursor_getNumTemplateArguments$MH,\"clang_Cursor_getNumTemplateArguments\");\n+    }\n+    public static int clang_Cursor_getNumTemplateArguments ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$20.clang_Cursor_getNumTemplateArguments$MH, \"clang_Cursor_getNumTemplateArguments\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$20 {\n+\n+        static final FunctionDescriptor clang_getEnumConstantDeclValue$FUNC = FunctionDescriptor.of(C_LONG_LONG,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getEnumConstantDeclValue$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getEnumConstantDeclValue\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)J\",\n+            constants$20.clang_getEnumConstantDeclValue$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getEnumConstantDeclUnsignedValue$FUNC = FunctionDescriptor.of(C_LONG_LONG,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getEnumConstantDeclUnsignedValue$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getEnumConstantDeclUnsignedValue\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)J\",\n+            constants$20.clang_getEnumConstantDeclUnsignedValue$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getFieldDeclBitWidth$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getFieldDeclBitWidth$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getFieldDeclBitWidth\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$20.clang_getFieldDeclBitWidth$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Cursor_getNumArguments$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Cursor_getNumArguments$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Cursor_getNumArguments\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$20.clang_Cursor_getNumArguments$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Cursor_getArgument$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            ),\n+            C_INT\n+        );\n+        static final MethodHandle clang_Cursor_getArgument$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Cursor_getArgument\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;I)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$20.clang_Cursor_getArgument$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Cursor_getNumTemplateArguments$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Cursor_getNumTemplateArguments$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Cursor_getNumTemplateArguments\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$20.clang_Cursor_getNumTemplateArguments$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_Cursor_getTemplateArgumentKind$MH() {\n+        return RuntimeHelper.requireNonNull(constants$21.clang_Cursor_getTemplateArgumentKind$MH,\"clang_Cursor_getTemplateArgumentKind\");\n+    }\n+    public static int clang_Cursor_getTemplateArgumentKind ( MemorySegment C,  int I) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$21.clang_Cursor_getTemplateArgumentKind$MH, \"clang_Cursor_getTemplateArgumentKind\");\n+        try {\n+            return (int)mh$.invokeExact(C, I);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_getTemplateArgumentType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$21.clang_Cursor_getTemplateArgumentType$MH,\"clang_Cursor_getTemplateArgumentType\");\n+    }\n+    public static MemorySegment clang_Cursor_getTemplateArgumentType ( MemorySegment C,  int I) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$21.clang_Cursor_getTemplateArgumentType$MH, \"clang_Cursor_getTemplateArgumentType\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(C, I);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_getTemplateArgumentValue$MH() {\n+        return RuntimeHelper.requireNonNull(constants$21.clang_Cursor_getTemplateArgumentValue$MH,\"clang_Cursor_getTemplateArgumentValue\");\n+    }\n+    public static long clang_Cursor_getTemplateArgumentValue ( MemorySegment C,  int I) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$21.clang_Cursor_getTemplateArgumentValue$MH, \"clang_Cursor_getTemplateArgumentValue\");\n+        try {\n+            return (long)mh$.invokeExact(C, I);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_getTemplateArgumentUnsignedValue$MH() {\n+        return RuntimeHelper.requireNonNull(constants$21.clang_Cursor_getTemplateArgumentUnsignedValue$MH,\"clang_Cursor_getTemplateArgumentUnsignedValue\");\n+    }\n+    public static long clang_Cursor_getTemplateArgumentUnsignedValue ( MemorySegment C,  int I) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$21.clang_Cursor_getTemplateArgumentUnsignedValue$MH, \"clang_Cursor_getTemplateArgumentUnsignedValue\");\n+        try {\n+            return (long)mh$.invokeExact(C, I);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_equalTypes$MH() {\n+        return RuntimeHelper.requireNonNull(constants$21.clang_equalTypes$MH,\"clang_equalTypes\");\n+    }\n+    public static int clang_equalTypes ( MemorySegment A,  MemorySegment B) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$21.clang_equalTypes$MH, \"clang_equalTypes\");\n+        try {\n+            return (int)mh$.invokeExact(A, B);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getCanonicalType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$21.clang_getCanonicalType$MH,\"clang_getCanonicalType\");\n+    }\n+    public static MemorySegment clang_getCanonicalType ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$21.clang_getCanonicalType$MH, \"clang_getCanonicalType\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$21 {\n+\n+        static final FunctionDescriptor clang_Cursor_getTemplateArgumentKind$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            ),\n+            C_INT\n+        );\n+        static final MethodHandle clang_Cursor_getTemplateArgumentKind$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Cursor_getTemplateArgumentKind\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;I)I\",\n+            constants$21.clang_Cursor_getTemplateArgumentKind$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Cursor_getTemplateArgumentType$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.ofPaddingBits(32),\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            ),\n+            C_INT\n+        );\n+        static final MethodHandle clang_Cursor_getTemplateArgumentType$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Cursor_getTemplateArgumentType\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;I)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$21.clang_Cursor_getTemplateArgumentType$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Cursor_getTemplateArgumentValue$FUNC = FunctionDescriptor.of(C_LONG_LONG,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            ),\n+            C_INT\n+        );\n+        static final MethodHandle clang_Cursor_getTemplateArgumentValue$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Cursor_getTemplateArgumentValue\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;I)J\",\n+            constants$21.clang_Cursor_getTemplateArgumentValue$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Cursor_getTemplateArgumentUnsignedValue$FUNC = FunctionDescriptor.of(C_LONG_LONG,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            ),\n+            C_INT\n+        );\n+        static final MethodHandle clang_Cursor_getTemplateArgumentUnsignedValue$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Cursor_getTemplateArgumentUnsignedValue\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;I)J\",\n+            constants$21.clang_Cursor_getTemplateArgumentUnsignedValue$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_equalTypes$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_equalTypes$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_equalTypes\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$21.clang_equalTypes$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getCanonicalType$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.ofPaddingBits(32),\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getCanonicalType$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCanonicalType\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$21.clang_getCanonicalType$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_getLocalUnqualifiedType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$22.clang_getLocalUnqualifiedType$MH,\"clang_getLocalUnqualifiedType\");\n+    }\n+    public static MemorySegment clang_getLocalUnqualifiedType ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$22.clang_getLocalUnqualifiedType$MH, \"clang_getLocalUnqualifiedType\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_isConstQualifiedType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$22.clang_isConstQualifiedType$MH,\"clang_isConstQualifiedType\");\n+    }\n+    public static int clang_isConstQualifiedType ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$22.clang_isConstQualifiedType$MH, \"clang_isConstQualifiedType\");\n+        try {\n+            return (int)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_isMacroFunctionLike$MH() {\n+        return RuntimeHelper.requireNonNull(constants$22.clang_Cursor_isMacroFunctionLike$MH,\"clang_Cursor_isMacroFunctionLike\");\n+    }\n+    public static int clang_Cursor_isMacroFunctionLike ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$22.clang_Cursor_isMacroFunctionLike$MH, \"clang_Cursor_isMacroFunctionLike\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_isMacroBuiltin$MH() {\n+        return RuntimeHelper.requireNonNull(constants$22.clang_Cursor_isMacroBuiltin$MH,\"clang_Cursor_isMacroBuiltin\");\n+    }\n+    public static int clang_Cursor_isMacroBuiltin ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$22.clang_Cursor_isMacroBuiltin$MH, \"clang_Cursor_isMacroBuiltin\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_isFunctionInlined$MH() {\n+        return RuntimeHelper.requireNonNull(constants$22.clang_Cursor_isFunctionInlined$MH,\"clang_Cursor_isFunctionInlined\");\n+    }\n+    public static int clang_Cursor_isFunctionInlined ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$22.clang_Cursor_isFunctionInlined$MH, \"clang_Cursor_isFunctionInlined\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_isVolatileQualifiedType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$22.clang_isVolatileQualifiedType$MH,\"clang_isVolatileQualifiedType\");\n+    }\n+    public static int clang_isVolatileQualifiedType ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$22.clang_isVolatileQualifiedType$MH, \"clang_isVolatileQualifiedType\");\n+        try {\n+            return (int)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$22 {\n+\n+        static final FunctionDescriptor clang_getLocalUnqualifiedType$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.ofPaddingBits(32),\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getLocalUnqualifiedType$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getLocalUnqualifiedType\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$22.clang_getLocalUnqualifiedType$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_isConstQualifiedType$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_isConstQualifiedType$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_isConstQualifiedType\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$22.clang_isConstQualifiedType$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Cursor_isMacroFunctionLike$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Cursor_isMacroFunctionLike$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Cursor_isMacroFunctionLike\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$22.clang_Cursor_isMacroFunctionLike$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Cursor_isMacroBuiltin$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Cursor_isMacroBuiltin$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Cursor_isMacroBuiltin\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$22.clang_Cursor_isMacroBuiltin$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Cursor_isFunctionInlined$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Cursor_isFunctionInlined$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Cursor_isFunctionInlined\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$22.clang_Cursor_isFunctionInlined$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_isVolatileQualifiedType$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_isVolatileQualifiedType$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_isVolatileQualifiedType\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$22.clang_isVolatileQualifiedType$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_isRestrictQualifiedType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$23.clang_isRestrictQualifiedType$MH,\"clang_isRestrictQualifiedType\");\n+    }\n+    public static int clang_isRestrictQualifiedType ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$23.clang_isRestrictQualifiedType$MH, \"clang_isRestrictQualifiedType\");\n+        try {\n+            return (int)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getAddressSpace$MH() {\n+        return RuntimeHelper.requireNonNull(constants$23.clang_getAddressSpace$MH,\"clang_getAddressSpace\");\n+    }\n+    public static int clang_getAddressSpace ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$23.clang_getAddressSpace$MH, \"clang_getAddressSpace\");\n+        try {\n+            return (int)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getTypedefName$MH() {\n+        return RuntimeHelper.requireNonNull(constants$23.clang_getTypedefName$MH,\"clang_getTypedefName\");\n+    }\n+    public static MemorySegment clang_getTypedefName ( MemorySegment CT) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$23.clang_getTypedefName$MH, \"clang_getTypedefName\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(CT);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getPointeeType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$23.clang_getPointeeType$MH,\"clang_getPointeeType\");\n+    }\n+    public static MemorySegment clang_getPointeeType ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$23.clang_getPointeeType$MH, \"clang_getPointeeType\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getTypeDeclaration$MH() {\n+        return RuntimeHelper.requireNonNull(constants$23.clang_getTypeDeclaration$MH,\"clang_getTypeDeclaration\");\n+    }\n+    public static MemorySegment clang_getTypeDeclaration ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$23.clang_getTypeDeclaration$MH, \"clang_getTypeDeclaration\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getDeclObjCTypeEncoding$MH() {\n+        return RuntimeHelper.requireNonNull(constants$23.clang_getDeclObjCTypeEncoding$MH,\"clang_getDeclObjCTypeEncoding\");\n+    }\n+    public static MemorySegment clang_getDeclObjCTypeEncoding ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$23.clang_getDeclObjCTypeEncoding$MH, \"clang_getDeclObjCTypeEncoding\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$23 {\n+\n+        static final FunctionDescriptor clang_isRestrictQualifiedType$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_isRestrictQualifiedType$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_isRestrictQualifiedType\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$23.clang_isRestrictQualifiedType$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getAddressSpace$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getAddressSpace$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getAddressSpace\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$23.clang_getAddressSpace$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getTypedefName$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getTypedefName$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getTypedefName\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$23.clang_getTypedefName$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getPointeeType$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.ofPaddingBits(32),\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getPointeeType$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getPointeeType\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$23.clang_getPointeeType$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getTypeDeclaration$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getTypeDeclaration$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getTypeDeclaration\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$23.clang_getTypeDeclaration$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getDeclObjCTypeEncoding$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getDeclObjCTypeEncoding$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getDeclObjCTypeEncoding\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$23.clang_getDeclObjCTypeEncoding$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_Type_getObjCEncoding$MH() {\n+        return RuntimeHelper.requireNonNull(constants$24.clang_Type_getObjCEncoding$MH,\"clang_Type_getObjCEncoding\");\n+    }\n+    public static MemorySegment clang_Type_getObjCEncoding ( MemorySegment type) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$24.clang_Type_getObjCEncoding$MH, \"clang_Type_getObjCEncoding\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(type);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getTypeKindSpelling$MH() {\n+        return RuntimeHelper.requireNonNull(constants$24.clang_getTypeKindSpelling$MH,\"clang_getTypeKindSpelling\");\n+    }\n+    public static MemorySegment clang_getTypeKindSpelling ( int K) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$24.clang_getTypeKindSpelling$MH, \"clang_getTypeKindSpelling\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(K);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getFunctionTypeCallingConv$MH() {\n+        return RuntimeHelper.requireNonNull(constants$24.clang_getFunctionTypeCallingConv$MH,\"clang_getFunctionTypeCallingConv\");\n+    }\n+    public static int clang_getFunctionTypeCallingConv ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$24.clang_getFunctionTypeCallingConv$MH, \"clang_getFunctionTypeCallingConv\");\n+        try {\n+            return (int)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getResultType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$24.clang_getResultType$MH,\"clang_getResultType\");\n+    }\n+    public static MemorySegment clang_getResultType ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$24.clang_getResultType$MH, \"clang_getResultType\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getExceptionSpecificationType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$24.clang_getExceptionSpecificationType$MH,\"clang_getExceptionSpecificationType\");\n+    }\n+    public static int clang_getExceptionSpecificationType ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$24.clang_getExceptionSpecificationType$MH, \"clang_getExceptionSpecificationType\");\n+        try {\n+            return (int)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getNumArgTypes$MH() {\n+        return RuntimeHelper.requireNonNull(constants$24.clang_getNumArgTypes$MH,\"clang_getNumArgTypes\");\n+    }\n+    public static int clang_getNumArgTypes ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$24.clang_getNumArgTypes$MH, \"clang_getNumArgTypes\");\n+        try {\n+            return (int)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$24 {\n+\n+        static final FunctionDescriptor clang_Type_getObjCEncoding$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Type_getObjCEncoding$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Type_getObjCEncoding\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$24.clang_Type_getObjCEncoding$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getTypeKindSpelling$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            C_INT\n+        );\n+        static final MethodHandle clang_getTypeKindSpelling$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getTypeKindSpelling\",\n+            \"(I)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$24.clang_getTypeKindSpelling$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getFunctionTypeCallingConv$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getFunctionTypeCallingConv$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getFunctionTypeCallingConv\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$24.clang_getFunctionTypeCallingConv$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getResultType$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.ofPaddingBits(32),\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getResultType$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getResultType\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$24.clang_getResultType$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getExceptionSpecificationType$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getExceptionSpecificationType$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getExceptionSpecificationType\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$24.clang_getExceptionSpecificationType$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getNumArgTypes$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getNumArgTypes$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getNumArgTypes\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$24.clang_getNumArgTypes$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_getArgType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$25.clang_getArgType$MH,\"clang_getArgType\");\n+    }\n+    public static MemorySegment clang_getArgType ( MemorySegment T,  int i) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$25.clang_getArgType$MH, \"clang_getArgType\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(T, i);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Type_getObjCObjectBaseType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$25.clang_Type_getObjCObjectBaseType$MH,\"clang_Type_getObjCObjectBaseType\");\n+    }\n+    public static MemorySegment clang_Type_getObjCObjectBaseType ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$25.clang_Type_getObjCObjectBaseType$MH, \"clang_Type_getObjCObjectBaseType\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Type_getNumObjCProtocolRefs$MH() {\n+        return RuntimeHelper.requireNonNull(constants$25.clang_Type_getNumObjCProtocolRefs$MH,\"clang_Type_getNumObjCProtocolRefs\");\n+    }\n+    public static int clang_Type_getNumObjCProtocolRefs ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$25.clang_Type_getNumObjCProtocolRefs$MH, \"clang_Type_getNumObjCProtocolRefs\");\n+        try {\n+            return (int)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Type_getObjCProtocolDecl$MH() {\n+        return RuntimeHelper.requireNonNull(constants$25.clang_Type_getObjCProtocolDecl$MH,\"clang_Type_getObjCProtocolDecl\");\n+    }\n+    public static MemorySegment clang_Type_getObjCProtocolDecl ( MemorySegment T,  int i) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$25.clang_Type_getObjCProtocolDecl$MH, \"clang_Type_getObjCProtocolDecl\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(T, i);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Type_getNumObjCTypeArgs$MH() {\n+        return RuntimeHelper.requireNonNull(constants$25.clang_Type_getNumObjCTypeArgs$MH,\"clang_Type_getNumObjCTypeArgs\");\n+    }\n+    public static int clang_Type_getNumObjCTypeArgs ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$25.clang_Type_getNumObjCTypeArgs$MH, \"clang_Type_getNumObjCTypeArgs\");\n+        try {\n+            return (int)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Type_getObjCTypeArg$MH() {\n+        return RuntimeHelper.requireNonNull(constants$25.clang_Type_getObjCTypeArg$MH,\"clang_Type_getObjCTypeArg\");\n+    }\n+    public static MemorySegment clang_Type_getObjCTypeArg ( MemorySegment T,  int i) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$25.clang_Type_getObjCTypeArg$MH, \"clang_Type_getObjCTypeArg\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(T, i);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$25 {\n+\n+        static final FunctionDescriptor clang_getArgType$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.ofPaddingBits(32),\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            ),\n+            C_INT\n+        );\n+        static final MethodHandle clang_getArgType$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getArgType\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;I)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$25.clang_getArgType$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Type_getObjCObjectBaseType$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.ofPaddingBits(32),\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Type_getObjCObjectBaseType$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Type_getObjCObjectBaseType\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$25.clang_Type_getObjCObjectBaseType$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Type_getNumObjCProtocolRefs$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Type_getNumObjCProtocolRefs$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Type_getNumObjCProtocolRefs\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$25.clang_Type_getNumObjCProtocolRefs$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Type_getObjCProtocolDecl$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            ),\n+            C_INT\n+        );\n+        static final MethodHandle clang_Type_getObjCProtocolDecl$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Type_getObjCProtocolDecl\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;I)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$25.clang_Type_getObjCProtocolDecl$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Type_getNumObjCTypeArgs$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Type_getNumObjCTypeArgs$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Type_getNumObjCTypeArgs\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$25.clang_Type_getNumObjCTypeArgs$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Type_getObjCTypeArg$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.ofPaddingBits(32),\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            ),\n+            C_INT\n+        );\n+        static final MethodHandle clang_Type_getObjCTypeArg$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Type_getObjCTypeArg\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;I)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$25.clang_Type_getObjCTypeArg$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_isFunctionTypeVariadic$MH() {\n+        return RuntimeHelper.requireNonNull(constants$26.clang_isFunctionTypeVariadic$MH,\"clang_isFunctionTypeVariadic\");\n+    }\n+    public static int clang_isFunctionTypeVariadic ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$26.clang_isFunctionTypeVariadic$MH, \"clang_isFunctionTypeVariadic\");\n+        try {\n+            return (int)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getCursorResultType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$26.clang_getCursorResultType$MH,\"clang_getCursorResultType\");\n+    }\n+    public static MemorySegment clang_getCursorResultType ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$26.clang_getCursorResultType$MH, \"clang_getCursorResultType\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getCursorExceptionSpecificationType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$26.clang_getCursorExceptionSpecificationType$MH,\"clang_getCursorExceptionSpecificationType\");\n+    }\n+    public static int clang_getCursorExceptionSpecificationType ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$26.clang_getCursorExceptionSpecificationType$MH, \"clang_getCursorExceptionSpecificationType\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_isPODType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$26.clang_isPODType$MH,\"clang_isPODType\");\n+    }\n+    public static int clang_isPODType ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$26.clang_isPODType$MH, \"clang_isPODType\");\n+        try {\n+            return (int)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getElementType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$26.clang_getElementType$MH,\"clang_getElementType\");\n+    }\n+    public static MemorySegment clang_getElementType ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$26.clang_getElementType$MH, \"clang_getElementType\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getNumElements$MH() {\n+        return RuntimeHelper.requireNonNull(constants$26.clang_getNumElements$MH,\"clang_getNumElements\");\n+    }\n+    public static long clang_getNumElements ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$26.clang_getNumElements$MH, \"clang_getNumElements\");\n+        try {\n+            return (long)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$26 {\n+\n+        static final FunctionDescriptor clang_isFunctionTypeVariadic$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_isFunctionTypeVariadic$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_isFunctionTypeVariadic\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$26.clang_isFunctionTypeVariadic$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getCursorResultType$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.ofPaddingBits(32),\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getCursorResultType$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCursorResultType\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$26.clang_getCursorResultType$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getCursorExceptionSpecificationType$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getCursorExceptionSpecificationType$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCursorExceptionSpecificationType\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$26.clang_getCursorExceptionSpecificationType$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_isPODType$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_isPODType$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_isPODType\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$26.clang_isPODType$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getElementType$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.ofPaddingBits(32),\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getElementType$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getElementType\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$26.clang_getElementType$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getNumElements$FUNC = FunctionDescriptor.of(C_LONG_LONG,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getNumElements$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getNumElements\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)J\",\n+            constants$26.clang_getNumElements$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_getArrayElementType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$27.clang_getArrayElementType$MH,\"clang_getArrayElementType\");\n+    }\n+    public static MemorySegment clang_getArrayElementType ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$27.clang_getArrayElementType$MH, \"clang_getArrayElementType\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getArraySize$MH() {\n+        return RuntimeHelper.requireNonNull(constants$27.clang_getArraySize$MH,\"clang_getArraySize\");\n+    }\n+    public static long clang_getArraySize ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$27.clang_getArraySize$MH, \"clang_getArraySize\");\n+        try {\n+            return (long)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Type_getNamedType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$27.clang_Type_getNamedType$MH,\"clang_Type_getNamedType\");\n+    }\n+    public static MemorySegment clang_Type_getNamedType ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$27.clang_Type_getNamedType$MH, \"clang_Type_getNamedType\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Type_isTransparentTagTypedef$MH() {\n+        return RuntimeHelper.requireNonNull(constants$27.clang_Type_isTransparentTagTypedef$MH,\"clang_Type_isTransparentTagTypedef\");\n+    }\n+    public static int clang_Type_isTransparentTagTypedef ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$27.clang_Type_isTransparentTagTypedef$MH, \"clang_Type_isTransparentTagTypedef\");\n+        try {\n+            return (int)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXTypeNullability_NonNull() {\n+        return (int)0L;\n+    }\n+    public static int CXTypeNullability_Nullable() {\n+        return (int)1L;\n+    }\n+    public static int CXTypeNullability_Unspecified() {\n+        return (int)2L;\n+    }\n+    public static int CXTypeNullability_Invalid() {\n+        return (int)3L;\n+    }\n+    public static MethodHandle clang_Type_getNullability$MH() {\n+        return RuntimeHelper.requireNonNull(constants$27.clang_Type_getNullability$MH,\"clang_Type_getNullability\");\n+    }\n+    public static int clang_Type_getNullability ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$27.clang_Type_getNullability$MH, \"clang_Type_getNullability\");\n+        try {\n+            return (int)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXTypeLayoutError_Invalid() {\n+        return (int)-1L;\n+    }\n+    public static int CXTypeLayoutError_Incomplete() {\n+        return (int)-2L;\n+    }\n+    public static int CXTypeLayoutError_Dependent() {\n+        return (int)-3L;\n+    }\n+    public static int CXTypeLayoutError_NotConstantSize() {\n+        return (int)-4L;\n+    }\n+    public static int CXTypeLayoutError_InvalidFieldName() {\n+        return (int)-5L;\n+    }\n+    public static int CXTypeLayoutError_Undeduced() {\n+        return (int)-6L;\n+    }\n+    public static MethodHandle clang_Type_getAlignOf$MH() {\n+        return RuntimeHelper.requireNonNull(constants$27.clang_Type_getAlignOf$MH,\"clang_Type_getAlignOf\");\n+    }\n+    public static long clang_Type_getAlignOf ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$27.clang_Type_getAlignOf$MH, \"clang_Type_getAlignOf\");\n+        try {\n+            return (long)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$27 {\n+\n+        static final FunctionDescriptor clang_getArrayElementType$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.ofPaddingBits(32),\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getArrayElementType$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getArrayElementType\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$27.clang_getArrayElementType$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getArraySize$FUNC = FunctionDescriptor.of(C_LONG_LONG,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getArraySize$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getArraySize\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)J\",\n+            constants$27.clang_getArraySize$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Type_getNamedType$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.ofPaddingBits(32),\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Type_getNamedType$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Type_getNamedType\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$27.clang_Type_getNamedType$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Type_isTransparentTagTypedef$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Type_isTransparentTagTypedef$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Type_isTransparentTagTypedef\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$27.clang_Type_isTransparentTagTypedef$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Type_getNullability$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Type_getNullability$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Type_getNullability\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$27.clang_Type_getNullability$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Type_getAlignOf$FUNC = FunctionDescriptor.of(C_LONG_LONG,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Type_getAlignOf$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Type_getAlignOf\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)J\",\n+            constants$27.clang_Type_getAlignOf$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_Type_getClassType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$28.clang_Type_getClassType$MH,\"clang_Type_getClassType\");\n+    }\n+    public static MemorySegment clang_Type_getClassType ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$28.clang_Type_getClassType$MH, \"clang_Type_getClassType\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Type_getSizeOf$MH() {\n+        return RuntimeHelper.requireNonNull(constants$28.clang_Type_getSizeOf$MH,\"clang_Type_getSizeOf\");\n+    }\n+    public static long clang_Type_getSizeOf ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$28.clang_Type_getSizeOf$MH, \"clang_Type_getSizeOf\");\n+        try {\n+            return (long)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Type_getOffsetOf$MH() {\n+        return RuntimeHelper.requireNonNull(constants$28.clang_Type_getOffsetOf$MH,\"clang_Type_getOffsetOf\");\n+    }\n+    public static long clang_Type_getOffsetOf ( MemorySegment T,  Addressable S) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$28.clang_Type_getOffsetOf$MH, \"clang_Type_getOffsetOf\");\n+        try {\n+            return (long)mh$.invokeExact(T, S.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Type_getModifiedType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$28.clang_Type_getModifiedType$MH,\"clang_Type_getModifiedType\");\n+    }\n+    public static MemorySegment clang_Type_getModifiedType ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$28.clang_Type_getModifiedType$MH, \"clang_Type_getModifiedType\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_getOffsetOfField$MH() {\n+        return RuntimeHelper.requireNonNull(constants$28.clang_Cursor_getOffsetOfField$MH,\"clang_Cursor_getOffsetOfField\");\n+    }\n+    public static long clang_Cursor_getOffsetOfField ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$28.clang_Cursor_getOffsetOfField$MH, \"clang_Cursor_getOffsetOfField\");\n+        try {\n+            return (long)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_isAnonymous$MH() {\n+        return RuntimeHelper.requireNonNull(constants$28.clang_Cursor_isAnonymous$MH,\"clang_Cursor_isAnonymous\");\n+    }\n+    public static int clang_Cursor_isAnonymous ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$28.clang_Cursor_isAnonymous$MH, \"clang_Cursor_isAnonymous\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$28 {\n+\n+        static final FunctionDescriptor clang_Type_getClassType$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.ofPaddingBits(32),\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Type_getClassType$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Type_getClassType\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$28.clang_Type_getClassType$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Type_getSizeOf$FUNC = FunctionDescriptor.of(C_LONG_LONG,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Type_getSizeOf$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Type_getSizeOf\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)J\",\n+            constants$28.clang_Type_getSizeOf$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Type_getOffsetOf$FUNC = FunctionDescriptor.of(C_LONG_LONG,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            ),\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_Type_getOffsetOf$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Type_getOffsetOf\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemoryAddress;)J\",\n+            constants$28.clang_Type_getOffsetOf$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Type_getModifiedType$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.ofPaddingBits(32),\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Type_getModifiedType$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Type_getModifiedType\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$28.clang_Type_getModifiedType$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Cursor_getOffsetOfField$FUNC = FunctionDescriptor.of(C_LONG_LONG,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Cursor_getOffsetOfField$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Cursor_getOffsetOfField\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)J\",\n+            constants$28.clang_Cursor_getOffsetOfField$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Cursor_isAnonymous$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Cursor_isAnonymous$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Cursor_isAnonymous\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$28.clang_Cursor_isAnonymous$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_Cursor_isAnonymousRecordDecl$MH() {\n+        return RuntimeHelper.requireNonNull(constants$29.clang_Cursor_isAnonymousRecordDecl$MH,\"clang_Cursor_isAnonymousRecordDecl\");\n+    }\n+    public static int clang_Cursor_isAnonymousRecordDecl ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$29.clang_Cursor_isAnonymousRecordDecl$MH, \"clang_Cursor_isAnonymousRecordDecl\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_isInlineNamespace$MH() {\n+        return RuntimeHelper.requireNonNull(constants$29.clang_Cursor_isInlineNamespace$MH,\"clang_Cursor_isInlineNamespace\");\n+    }\n+    public static int clang_Cursor_isInlineNamespace ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$29.clang_Cursor_isInlineNamespace$MH, \"clang_Cursor_isInlineNamespace\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXRefQualifier_None() {\n+        return (int)0L;\n+    }\n+    public static int CXRefQualifier_LValue() {\n+        return (int)1L;\n+    }\n+    public static int CXRefQualifier_RValue() {\n+        return (int)2L;\n+    }\n+    public static MethodHandle clang_Type_getNumTemplateArguments$MH() {\n+        return RuntimeHelper.requireNonNull(constants$29.clang_Type_getNumTemplateArguments$MH,\"clang_Type_getNumTemplateArguments\");\n+    }\n+    public static int clang_Type_getNumTemplateArguments ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$29.clang_Type_getNumTemplateArguments$MH, \"clang_Type_getNumTemplateArguments\");\n+        try {\n+            return (int)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Type_getTemplateArgumentAsType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$29.clang_Type_getTemplateArgumentAsType$MH,\"clang_Type_getTemplateArgumentAsType\");\n+    }\n+    public static MemorySegment clang_Type_getTemplateArgumentAsType ( MemorySegment T,  int i) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$29.clang_Type_getTemplateArgumentAsType$MH, \"clang_Type_getTemplateArgumentAsType\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(T, i);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Type_getCXXRefQualifier$MH() {\n+        return RuntimeHelper.requireNonNull(constants$29.clang_Type_getCXXRefQualifier$MH,\"clang_Type_getCXXRefQualifier\");\n+    }\n+    public static int clang_Type_getCXXRefQualifier ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$29.clang_Type_getCXXRefQualifier$MH, \"clang_Type_getCXXRefQualifier\");\n+        try {\n+            return (int)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_isBitField$MH() {\n+        return RuntimeHelper.requireNonNull(constants$29.clang_Cursor_isBitField$MH,\"clang_Cursor_isBitField\");\n+    }\n+    public static int clang_Cursor_isBitField ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$29.clang_Cursor_isBitField$MH, \"clang_Cursor_isBitField\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$29 {\n+\n+        static final FunctionDescriptor clang_Cursor_isAnonymousRecordDecl$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Cursor_isAnonymousRecordDecl$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Cursor_isAnonymousRecordDecl\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$29.clang_Cursor_isAnonymousRecordDecl$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Cursor_isInlineNamespace$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Cursor_isInlineNamespace$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Cursor_isInlineNamespace\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$29.clang_Cursor_isInlineNamespace$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Type_getNumTemplateArguments$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Type_getNumTemplateArguments$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Type_getNumTemplateArguments\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$29.clang_Type_getNumTemplateArguments$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Type_getTemplateArgumentAsType$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.ofPaddingBits(32),\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            ),\n+            C_INT\n+        );\n+        static final MethodHandle clang_Type_getTemplateArgumentAsType$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Type_getTemplateArgumentAsType\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;I)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$29.clang_Type_getTemplateArgumentAsType$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Type_getCXXRefQualifier$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Type_getCXXRefQualifier$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Type_getCXXRefQualifier\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$29.clang_Type_getCXXRefQualifier$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Cursor_isBitField$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Cursor_isBitField$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Cursor_isBitField\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$29.clang_Cursor_isBitField$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_isVirtualBase$MH() {\n+        return RuntimeHelper.requireNonNull(constants$30.clang_isVirtualBase$MH,\"clang_isVirtualBase\");\n+    }\n+    public static int clang_isVirtualBase ( MemorySegment x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$30.clang_isVirtualBase$MH, \"clang_isVirtualBase\");\n+        try {\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CX_CXXInvalidAccessSpecifier() {\n+        return (int)0L;\n+    }\n+    public static int CX_CXXPublic() {\n+        return (int)1L;\n+    }\n+    public static int CX_CXXProtected() {\n+        return (int)2L;\n+    }\n+    public static int CX_CXXPrivate() {\n+        return (int)3L;\n+    }\n+    public static MethodHandle clang_getCXXAccessSpecifier$MH() {\n+        return RuntimeHelper.requireNonNull(constants$30.clang_getCXXAccessSpecifier$MH,\"clang_getCXXAccessSpecifier\");\n+    }\n+    public static int clang_getCXXAccessSpecifier ( MemorySegment x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$30.clang_getCXXAccessSpecifier$MH, \"clang_getCXXAccessSpecifier\");\n+        try {\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CX_SC_Invalid() {\n+        return (int)0L;\n+    }\n+    public static int CX_SC_None() {\n+        return (int)1L;\n+    }\n+    public static int CX_SC_Extern() {\n+        return (int)2L;\n+    }\n+    public static int CX_SC_Static() {\n+        return (int)3L;\n+    }\n+    public static int CX_SC_PrivateExtern() {\n+        return (int)4L;\n+    }\n+    public static int CX_SC_OpenCLWorkGroupLocal() {\n+        return (int)5L;\n+    }\n+    public static int CX_SC_Auto() {\n+        return (int)6L;\n+    }\n+    public static int CX_SC_Register() {\n+        return (int)7L;\n+    }\n+    public static MethodHandle clang_Cursor_getStorageClass$MH() {\n+        return RuntimeHelper.requireNonNull(constants$30.clang_Cursor_getStorageClass$MH,\"clang_Cursor_getStorageClass\");\n+    }\n+    public static int clang_Cursor_getStorageClass ( MemorySegment x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$30.clang_Cursor_getStorageClass$MH, \"clang_Cursor_getStorageClass\");\n+        try {\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getNumOverloadedDecls$MH() {\n+        return RuntimeHelper.requireNonNull(constants$30.clang_getNumOverloadedDecls$MH,\"clang_getNumOverloadedDecls\");\n+    }\n+    public static int clang_getNumOverloadedDecls ( MemorySegment cursor) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$30.clang_getNumOverloadedDecls$MH, \"clang_getNumOverloadedDecls\");\n+        try {\n+            return (int)mh$.invokeExact(cursor);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getOverloadedDecl$MH() {\n+        return RuntimeHelper.requireNonNull(constants$30.clang_getOverloadedDecl$MH,\"clang_getOverloadedDecl\");\n+    }\n+    public static MemorySegment clang_getOverloadedDecl ( MemorySegment cursor,  int index) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$30.clang_getOverloadedDecl$MH, \"clang_getOverloadedDecl\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(cursor, index);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getIBOutletCollectionType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$30.clang_getIBOutletCollectionType$MH,\"clang_getIBOutletCollectionType\");\n+    }\n+    public static MemorySegment clang_getIBOutletCollectionType ( MemorySegment x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$30.clang_getIBOutletCollectionType$MH, \"clang_getIBOutletCollectionType\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXChildVisit_Break() {\n+        return (int)0L;\n+    }\n+    public static int CXChildVisit_Continue() {\n+        return (int)1L;\n+    }\n+    public static int CXChildVisit_Recurse() {\n+        return (int)2L;\n+    }\n+    public static class constants$30 {\n+\n+        static final FunctionDescriptor clang_isVirtualBase$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_isVirtualBase$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_isVirtualBase\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$30.clang_isVirtualBase$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getCXXAccessSpecifier$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getCXXAccessSpecifier$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCXXAccessSpecifier\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$30.clang_getCXXAccessSpecifier$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Cursor_getStorageClass$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Cursor_getStorageClass$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Cursor_getStorageClass\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$30.clang_Cursor_getStorageClass$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getNumOverloadedDecls$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getNumOverloadedDecls$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getNumOverloadedDecls\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$30.clang_getNumOverloadedDecls$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getOverloadedDecl$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            ),\n+            C_INT\n+        );\n+        static final MethodHandle clang_getOverloadedDecl$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getOverloadedDecl\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;I)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$30.clang_getOverloadedDecl$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getIBOutletCollectionType$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.ofPaddingBits(32),\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getIBOutletCollectionType$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getIBOutletCollectionType\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$30.clang_getIBOutletCollectionType$FUNC, false\n+        );\n+    }\n+\n+    public interface CXCursorVisitor {\n+\n+        int apply(jdk.incubator.foreign.MemorySegment x0, jdk.incubator.foreign.MemorySegment x1, jdk.incubator.foreign.MemoryAddress x2);\n+        static MemorySegment allocate(CXCursorVisitor fi) {\n+            return RuntimeHelper.upcallStub(CXCursorVisitor.class, fi, constants$31.CXCursorVisitor$FUNC, \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemoryAddress;)I\");\n+        }\n+        static MemorySegment allocate(CXCursorVisitor fi, NativeScope scope) {\n+            return allocate(fi).handoff(scope);\n+        }\n+    }\n+\n+    public static MethodHandle clang_visitChildren$MH() {\n+        return RuntimeHelper.requireNonNull(constants$31.clang_visitChildren$MH,\"clang_visitChildren\");\n+    }\n+    public static int clang_visitChildren ( MemorySegment parent,  Addressable visitor,  Addressable client_data) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$31.clang_visitChildren$MH, \"clang_visitChildren\");\n+        try {\n+            return (int)mh$.invokeExact(parent, visitor.address(), client_data.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_visitTemplateSpecializations$MH() {\n+        return RuntimeHelper.requireNonNull(constants$31.clang_visitTemplateSpecializations$MH,\"clang_visitTemplateSpecializations\");\n+    }\n+    public static int clang_visitTemplateSpecializations ( MemorySegment parent,  Addressable visitor,  Addressable client_data) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$31.clang_visitTemplateSpecializations$MH, \"clang_visitTemplateSpecializations\");\n+        try {\n+            return (int)mh$.invokeExact(parent, visitor.address(), client_data.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_visitTemplateSpecializationChildren$MH() {\n+        return RuntimeHelper.requireNonNull(constants$31.clang_visitTemplateSpecializationChildren$MH,\"clang_visitTemplateSpecializationChildren\");\n+    }\n+    public static int clang_visitTemplateSpecializationChildren ( MemorySegment classTemplate,  Addressable visitor,  Addressable client_data) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$31.clang_visitTemplateSpecializationChildren$MH, \"clang_visitTemplateSpecializationChildren\");\n+        try {\n+            return (int)mh$.invokeExact(classTemplate, visitor.address(), client_data.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public interface CXCursorVisitorBlock {\n+\n+        int apply(jdk.incubator.foreign.MemorySegment x0, jdk.incubator.foreign.MemorySegment x1);\n+        static MemorySegment allocate(CXCursorVisitorBlock fi) {\n+            return RuntimeHelper.upcallStub(CXCursorVisitorBlock.class, fi, constants$31.CXCursorVisitorBlock$FUNC, \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemorySegment;)I\");\n+        }\n+        static MemorySegment allocate(CXCursorVisitorBlock fi, NativeScope scope) {\n+            return allocate(fi).handoff(scope);\n+        }\n+    }\n+\n+    public static MethodHandle clang_visitChildrenWithBlock$MH() {\n+        return RuntimeHelper.requireNonNull(constants$31.clang_visitChildrenWithBlock$MH,\"clang_visitChildrenWithBlock\");\n+    }\n+    public static int clang_visitChildrenWithBlock ( MemorySegment parent,  Addressable block) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$31.clang_visitChildrenWithBlock$MH, \"clang_visitChildrenWithBlock\");\n+        try {\n+            return (int)mh$.invokeExact(parent, block.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$31 {\n+\n+        static final FunctionDescriptor CXCursorVisitor$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            ),\n+            C_POINTER\n+        );\n+        static final FunctionDescriptor clang_visitChildren$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            ),\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_visitChildren$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_visitChildren\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+            constants$31.clang_visitChildren$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_visitTemplateSpecializations$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            ),\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_visitTemplateSpecializations$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_visitTemplateSpecializations\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+            constants$31.clang_visitTemplateSpecializations$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_visitTemplateSpecializationChildren$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            ),\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_visitTemplateSpecializationChildren$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_visitTemplateSpecializationChildren\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+            constants$31.clang_visitTemplateSpecializationChildren$FUNC, false\n+        );\n+        static final FunctionDescriptor CXCursorVisitorBlock$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final FunctionDescriptor clang_visitChildrenWithBlock$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            ),\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_visitChildrenWithBlock$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_visitChildrenWithBlock\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+            constants$31.clang_visitChildrenWithBlock$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_getCursorUSR$MH() {\n+        return RuntimeHelper.requireNonNull(constants$32.clang_getCursorUSR$MH,\"clang_getCursorUSR\");\n+    }\n+    public static MemorySegment clang_getCursorUSR ( MemorySegment x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$32.clang_getCursorUSR$MH, \"clang_getCursorUSR\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_constructUSR_ObjCClass$MH() {\n+        return RuntimeHelper.requireNonNull(constants$32.clang_constructUSR_ObjCClass$MH,\"clang_constructUSR_ObjCClass\");\n+    }\n+    public static MemorySegment clang_constructUSR_ObjCClass ( Addressable class_name) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$32.clang_constructUSR_ObjCClass$MH, \"clang_constructUSR_ObjCClass\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(class_name.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_constructUSR_ObjCCategory$MH() {\n+        return RuntimeHelper.requireNonNull(constants$32.clang_constructUSR_ObjCCategory$MH,\"clang_constructUSR_ObjCCategory\");\n+    }\n+    public static MemorySegment clang_constructUSR_ObjCCategory ( Addressable class_name,  Addressable category_name) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$32.clang_constructUSR_ObjCCategory$MH, \"clang_constructUSR_ObjCCategory\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(class_name.address(), category_name.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_constructUSR_ObjCProtocol$MH() {\n+        return RuntimeHelper.requireNonNull(constants$32.clang_constructUSR_ObjCProtocol$MH,\"clang_constructUSR_ObjCProtocol\");\n+    }\n+    public static MemorySegment clang_constructUSR_ObjCProtocol ( Addressable protocol_name) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$32.clang_constructUSR_ObjCProtocol$MH, \"clang_constructUSR_ObjCProtocol\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(protocol_name.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_constructUSR_ObjCIvar$MH() {\n+        return RuntimeHelper.requireNonNull(constants$32.clang_constructUSR_ObjCIvar$MH,\"clang_constructUSR_ObjCIvar\");\n+    }\n+    public static MemorySegment clang_constructUSR_ObjCIvar ( Addressable name,  MemorySegment classUSR) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$32.clang_constructUSR_ObjCIvar$MH, \"clang_constructUSR_ObjCIvar\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(name.address(), classUSR);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_constructUSR_ObjCMethod$MH() {\n+        return RuntimeHelper.requireNonNull(constants$32.clang_constructUSR_ObjCMethod$MH,\"clang_constructUSR_ObjCMethod\");\n+    }\n+    public static MemorySegment clang_constructUSR_ObjCMethod ( Addressable name,  int isInstanceMethod,  MemorySegment classUSR) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$32.clang_constructUSR_ObjCMethod$MH, \"clang_constructUSR_ObjCMethod\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(name.address(), isInstanceMethod, classUSR);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$32 {\n+\n+        static final FunctionDescriptor clang_getCursorUSR$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getCursorUSR$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCursorUSR\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$32.clang_getCursorUSR$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_constructUSR_ObjCClass$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_constructUSR_ObjCClass$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_constructUSR_ObjCClass\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$32.clang_constructUSR_ObjCClass$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_constructUSR_ObjCCategory$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_constructUSR_ObjCCategory$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_constructUSR_ObjCCategory\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$32.clang_constructUSR_ObjCCategory$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_constructUSR_ObjCProtocol$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_constructUSR_ObjCProtocol$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_constructUSR_ObjCProtocol\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$32.clang_constructUSR_ObjCProtocol$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_constructUSR_ObjCIvar$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            C_POINTER,\n+            MemoryLayout.ofStruct(\n+                C_POINTER.withName(\"data\"),\n+                C_INT.withName(\"private_flags\"),\n+                MemoryLayout.ofPaddingBits(32)\n+            )\n+        );\n+        static final MethodHandle clang_constructUSR_ObjCIvar$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_constructUSR_ObjCIvar\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$32.clang_constructUSR_ObjCIvar$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_constructUSR_ObjCMethod$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            C_POINTER,\n+            C_INT,\n+            MemoryLayout.ofStruct(\n+                C_POINTER.withName(\"data\"),\n+                C_INT.withName(\"private_flags\"),\n+                MemoryLayout.ofPaddingBits(32)\n+            )\n+        );\n+        static final MethodHandle clang_constructUSR_ObjCMethod$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_constructUSR_ObjCMethod\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;ILjdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$32.clang_constructUSR_ObjCMethod$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_constructUSR_ObjCProperty$MH() {\n+        return RuntimeHelper.requireNonNull(constants$33.clang_constructUSR_ObjCProperty$MH,\"clang_constructUSR_ObjCProperty\");\n+    }\n+    public static MemorySegment clang_constructUSR_ObjCProperty ( Addressable property,  MemorySegment classUSR) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$33.clang_constructUSR_ObjCProperty$MH, \"clang_constructUSR_ObjCProperty\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(property.address(), classUSR);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getCursorSpelling$MH() {\n+        return RuntimeHelper.requireNonNull(constants$33.clang_getCursorSpelling$MH,\"clang_getCursorSpelling\");\n+    }\n+    public static MemorySegment clang_getCursorSpelling ( MemorySegment x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$33.clang_getCursorSpelling$MH, \"clang_getCursorSpelling\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_getSpellingNameRange$MH() {\n+        return RuntimeHelper.requireNonNull(constants$33.clang_Cursor_getSpellingNameRange$MH,\"clang_Cursor_getSpellingNameRange\");\n+    }\n+    public static MemorySegment clang_Cursor_getSpellingNameRange ( MemorySegment x0,  int pieceIndex,  int options) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$33.clang_Cursor_getSpellingNameRange$MH, \"clang_Cursor_getSpellingNameRange\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(x0, pieceIndex, options);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXPrintingPolicy_Indentation() {\n+        return (int)0L;\n+    }\n+    public static int CXPrintingPolicy_SuppressSpecifiers() {\n+        return (int)1L;\n+    }\n+    public static int CXPrintingPolicy_SuppressTagKeyword() {\n+        return (int)2L;\n+    }\n+    public static int CXPrintingPolicy_IncludeTagDefinition() {\n+        return (int)3L;\n+    }\n+    public static int CXPrintingPolicy_SuppressScope() {\n+        return (int)4L;\n+    }\n+    public static int CXPrintingPolicy_SuppressUnwrittenScope() {\n+        return (int)5L;\n+    }\n+    public static int CXPrintingPolicy_SuppressInitializers() {\n+        return (int)6L;\n+    }\n+    public static int CXPrintingPolicy_ConstantArraySizeAsWritten() {\n+        return (int)7L;\n+    }\n+    public static int CXPrintingPolicy_AnonymousTagLocations() {\n+        return (int)8L;\n+    }\n+    public static int CXPrintingPolicy_SuppressStrongLifetime() {\n+        return (int)9L;\n+    }\n+    public static int CXPrintingPolicy_SuppressLifetimeQualifiers() {\n+        return (int)10L;\n+    }\n+    public static int CXPrintingPolicy_SuppressTemplateArgsInCXXConstructors() {\n+        return (int)11L;\n+    }\n+    public static int CXPrintingPolicy_Bool() {\n+        return (int)12L;\n+    }\n+    public static int CXPrintingPolicy_Restrict() {\n+        return (int)13L;\n+    }\n+    public static int CXPrintingPolicy_Alignof() {\n+        return (int)14L;\n+    }\n+    public static int CXPrintingPolicy_UnderscoreAlignof() {\n+        return (int)15L;\n+    }\n+    public static int CXPrintingPolicy_UseVoidForZeroParams() {\n+        return (int)16L;\n+    }\n+    public static int CXPrintingPolicy_TerseOutput() {\n+        return (int)17L;\n+    }\n+    public static int CXPrintingPolicy_PolishForDeclaration() {\n+        return (int)18L;\n+    }\n+    public static int CXPrintingPolicy_Half() {\n+        return (int)19L;\n+    }\n+    public static int CXPrintingPolicy_MSWChar() {\n+        return (int)20L;\n+    }\n+    public static int CXPrintingPolicy_IncludeNewlines() {\n+        return (int)21L;\n+    }\n+    public static int CXPrintingPolicy_MSVCFormatting() {\n+        return (int)22L;\n+    }\n+    public static int CXPrintingPolicy_ConstantsAsWritten() {\n+        return (int)23L;\n+    }\n+    public static int CXPrintingPolicy_SuppressImplicitBase() {\n+        return (int)24L;\n+    }\n+    public static int CXPrintingPolicy_FullyQualifiedName() {\n+        return (int)25L;\n+    }\n+    public static int CXPrintingPolicy_LastProperty() {\n+        return (int)25L;\n+    }\n+    public static MethodHandle clang_PrintingPolicy_getProperty$MH() {\n+        return RuntimeHelper.requireNonNull(constants$33.clang_PrintingPolicy_getProperty$MH,\"clang_PrintingPolicy_getProperty\");\n+    }\n+    public static int clang_PrintingPolicy_getProperty ( Addressable Policy,  int Property) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$33.clang_PrintingPolicy_getProperty$MH, \"clang_PrintingPolicy_getProperty\");\n+        try {\n+            return (int)mh$.invokeExact(Policy.address(), Property);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_PrintingPolicy_setProperty$MH() {\n+        return RuntimeHelper.requireNonNull(constants$33.clang_PrintingPolicy_setProperty$MH,\"clang_PrintingPolicy_setProperty\");\n+    }\n+    public static void clang_PrintingPolicy_setProperty ( Addressable Policy,  int Property,  int Value) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$33.clang_PrintingPolicy_setProperty$MH, \"clang_PrintingPolicy_setProperty\");\n+        try {\n+            mh$.invokeExact(Policy.address(), Property, Value);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getCursorPrintingPolicy$MH() {\n+        return RuntimeHelper.requireNonNull(constants$33.clang_getCursorPrintingPolicy$MH,\"clang_getCursorPrintingPolicy\");\n+    }\n+    public static MemoryAddress clang_getCursorPrintingPolicy ( MemorySegment x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$33.clang_getCursorPrintingPolicy$MH, \"clang_getCursorPrintingPolicy\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$33 {\n+\n+        static final FunctionDescriptor clang_constructUSR_ObjCProperty$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            C_POINTER,\n+            MemoryLayout.ofStruct(\n+                C_POINTER.withName(\"data\"),\n+                C_INT.withName(\"private_flags\"),\n+                MemoryLayout.ofPaddingBits(32)\n+            )\n+        );\n+        static final MethodHandle clang_constructUSR_ObjCProperty$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_constructUSR_ObjCProperty\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$33.clang_constructUSR_ObjCProperty$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getCursorSpelling$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getCursorSpelling$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCursorSpelling\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$33.clang_getCursorSpelling$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Cursor_getSpellingNameRange$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+            C_INT.withName(\"begin_int_data\"),\n+            C_INT.withName(\"end_int_data\")\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            ),\n+            C_INT,\n+            C_INT\n+        );\n+        static final MethodHandle clang_Cursor_getSpellingNameRange$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Cursor_getSpellingNameRange\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;II)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$33.clang_Cursor_getSpellingNameRange$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_PrintingPolicy_getProperty$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER,\n+            C_INT\n+        );\n+        static final MethodHandle clang_PrintingPolicy_getProperty$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_PrintingPolicy_getProperty\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;I)I\",\n+            constants$33.clang_PrintingPolicy_getProperty$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_PrintingPolicy_setProperty$FUNC = FunctionDescriptor.ofVoid(\n+            C_POINTER,\n+            C_INT,\n+            C_INT\n+        );\n+        static final MethodHandle clang_PrintingPolicy_setProperty$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_PrintingPolicy_setProperty\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;II)V\",\n+            constants$33.clang_PrintingPolicy_setProperty$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getCursorPrintingPolicy$FUNC = FunctionDescriptor.of(C_POINTER,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getCursorPrintingPolicy$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCursorPrintingPolicy\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$33.clang_getCursorPrintingPolicy$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_PrintingPolicy_dispose$MH() {\n+        return RuntimeHelper.requireNonNull(constants$34.clang_PrintingPolicy_dispose$MH,\"clang_PrintingPolicy_dispose\");\n+    }\n+    public static void clang_PrintingPolicy_dispose ( Addressable Policy) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$34.clang_PrintingPolicy_dispose$MH, \"clang_PrintingPolicy_dispose\");\n+        try {\n+            mh$.invokeExact(Policy.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getCursorPrettyPrinted$MH() {\n+        return RuntimeHelper.requireNonNull(constants$34.clang_getCursorPrettyPrinted$MH,\"clang_getCursorPrettyPrinted\");\n+    }\n+    public static MemorySegment clang_getCursorPrettyPrinted ( MemorySegment Cursor,  Addressable Policy) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$34.clang_getCursorPrettyPrinted$MH, \"clang_getCursorPrettyPrinted\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(Cursor, Policy.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getTypePrintingPolicy$MH() {\n+        return RuntimeHelper.requireNonNull(constants$34.clang_getTypePrintingPolicy$MH,\"clang_getTypePrintingPolicy\");\n+    }\n+    public static MemoryAddress clang_getTypePrintingPolicy ( MemorySegment x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$34.clang_getTypePrintingPolicy$MH, \"clang_getTypePrintingPolicy\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getTypePrettyPrinted$MH() {\n+        return RuntimeHelper.requireNonNull(constants$34.clang_getTypePrettyPrinted$MH,\"clang_getTypePrettyPrinted\");\n+    }\n+    public static MemorySegment clang_getTypePrettyPrinted ( MemorySegment CT,  Addressable Policy) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$34.clang_getTypePrettyPrinted$MH, \"clang_getTypePrettyPrinted\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(CT, Policy.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getCursorDisplayName$MH() {\n+        return RuntimeHelper.requireNonNull(constants$34.clang_getCursorDisplayName$MH,\"clang_getCursorDisplayName\");\n+    }\n+    public static MemorySegment clang_getCursorDisplayName ( MemorySegment x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$34.clang_getCursorDisplayName$MH, \"clang_getCursorDisplayName\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getCursorReferenced$MH() {\n+        return RuntimeHelper.requireNonNull(constants$34.clang_getCursorReferenced$MH,\"clang_getCursorReferenced\");\n+    }\n+    public static MemorySegment clang_getCursorReferenced ( MemorySegment x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$34.clang_getCursorReferenced$MH, \"clang_getCursorReferenced\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$34 {\n+\n+        static final FunctionDescriptor clang_PrintingPolicy_dispose$FUNC = FunctionDescriptor.ofVoid(\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_PrintingPolicy_dispose$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_PrintingPolicy_dispose\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)V\",\n+            constants$34.clang_PrintingPolicy_dispose$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getCursorPrettyPrinted$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            ),\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getCursorPrettyPrinted$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCursorPrettyPrinted\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$34.clang_getCursorPrettyPrinted$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getTypePrintingPolicy$FUNC = FunctionDescriptor.of(C_POINTER,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getTypePrintingPolicy$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getTypePrintingPolicy\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$34.clang_getTypePrintingPolicy$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getTypePrettyPrinted$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            ),\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getTypePrettyPrinted$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getTypePrettyPrinted\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$34.clang_getTypePrettyPrinted$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getCursorDisplayName$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getCursorDisplayName$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCursorDisplayName\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$34.clang_getCursorDisplayName$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getCursorReferenced$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getCursorReferenced$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCursorReferenced\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$34.clang_getCursorReferenced$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_getCursorDefinition$MH() {\n+        return RuntimeHelper.requireNonNull(constants$35.clang_getCursorDefinition$MH,\"clang_getCursorDefinition\");\n+    }\n+    public static MemorySegment clang_getCursorDefinition ( MemorySegment x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$35.clang_getCursorDefinition$MH, \"clang_getCursorDefinition\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_isCursorDefinition$MH() {\n+        return RuntimeHelper.requireNonNull(constants$35.clang_isCursorDefinition$MH,\"clang_isCursorDefinition\");\n+    }\n+    public static int clang_isCursorDefinition ( MemorySegment x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$35.clang_isCursorDefinition$MH, \"clang_isCursorDefinition\");\n+        try {\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getCanonicalCursor$MH() {\n+        return RuntimeHelper.requireNonNull(constants$35.clang_getCanonicalCursor$MH,\"clang_getCanonicalCursor\");\n+    }\n+    public static MemorySegment clang_getCanonicalCursor ( MemorySegment x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$35.clang_getCanonicalCursor$MH, \"clang_getCanonicalCursor\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_getObjCSelectorIndex$MH() {\n+        return RuntimeHelper.requireNonNull(constants$35.clang_Cursor_getObjCSelectorIndex$MH,\"clang_Cursor_getObjCSelectorIndex\");\n+    }\n+    public static int clang_Cursor_getObjCSelectorIndex ( MemorySegment x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$35.clang_Cursor_getObjCSelectorIndex$MH, \"clang_Cursor_getObjCSelectorIndex\");\n+        try {\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_isDynamicCall$MH() {\n+        return RuntimeHelper.requireNonNull(constants$35.clang_Cursor_isDynamicCall$MH,\"clang_Cursor_isDynamicCall\");\n+    }\n+    public static int clang_Cursor_isDynamicCall ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$35.clang_Cursor_isDynamicCall$MH, \"clang_Cursor_isDynamicCall\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_getReceiverType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$35.clang_Cursor_getReceiverType$MH,\"clang_Cursor_getReceiverType\");\n+    }\n+    public static MemorySegment clang_Cursor_getReceiverType ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$35.clang_Cursor_getReceiverType$MH, \"clang_Cursor_getReceiverType\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXObjCPropertyAttr_noattr() {\n+        return (int)0L;\n+    }\n+    public static int CXObjCPropertyAttr_readonly() {\n+        return (int)1L;\n+    }\n+    public static int CXObjCPropertyAttr_getter() {\n+        return (int)2L;\n+    }\n+    public static int CXObjCPropertyAttr_assign() {\n+        return (int)4L;\n+    }\n+    public static int CXObjCPropertyAttr_readwrite() {\n+        return (int)8L;\n+    }\n+    public static int CXObjCPropertyAttr_retain() {\n+        return (int)16L;\n+    }\n+    public static int CXObjCPropertyAttr_copy() {\n+        return (int)32L;\n+    }\n+    public static int CXObjCPropertyAttr_nonatomic() {\n+        return (int)64L;\n+    }\n+    public static int CXObjCPropertyAttr_setter() {\n+        return (int)128L;\n+    }\n+    public static int CXObjCPropertyAttr_atomic() {\n+        return (int)256L;\n+    }\n+    public static int CXObjCPropertyAttr_weak() {\n+        return (int)512L;\n+    }\n+    public static int CXObjCPropertyAttr_strong() {\n+        return (int)1024L;\n+    }\n+    public static int CXObjCPropertyAttr_unsafe_unretained() {\n+        return (int)2048L;\n+    }\n+    public static int CXObjCPropertyAttr_class() {\n+        return (int)4096L;\n+    }\n+    public static class constants$35 {\n+\n+        static final FunctionDescriptor clang_getCursorDefinition$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getCursorDefinition$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCursorDefinition\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$35.clang_getCursorDefinition$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_isCursorDefinition$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_isCursorDefinition$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_isCursorDefinition\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$35.clang_isCursorDefinition$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getCanonicalCursor$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getCanonicalCursor$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCanonicalCursor\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$35.clang_getCanonicalCursor$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Cursor_getObjCSelectorIndex$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Cursor_getObjCSelectorIndex$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Cursor_getObjCSelectorIndex\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$35.clang_Cursor_getObjCSelectorIndex$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Cursor_isDynamicCall$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Cursor_isDynamicCall$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Cursor_isDynamicCall\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$35.clang_Cursor_isDynamicCall$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Cursor_getReceiverType$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.ofPaddingBits(32),\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Cursor_getReceiverType$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Cursor_getReceiverType\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$35.clang_Cursor_getReceiverType$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_Cursor_getObjCPropertyAttributes$MH() {\n+        return RuntimeHelper.requireNonNull(constants$36.clang_Cursor_getObjCPropertyAttributes$MH,\"clang_Cursor_getObjCPropertyAttributes\");\n+    }\n+    public static int clang_Cursor_getObjCPropertyAttributes ( MemorySegment C,  int reserved) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$36.clang_Cursor_getObjCPropertyAttributes$MH, \"clang_Cursor_getObjCPropertyAttributes\");\n+        try {\n+            return (int)mh$.invokeExact(C, reserved);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_getObjCPropertyGetterName$MH() {\n+        return RuntimeHelper.requireNonNull(constants$36.clang_Cursor_getObjCPropertyGetterName$MH,\"clang_Cursor_getObjCPropertyGetterName\");\n+    }\n+    public static MemorySegment clang_Cursor_getObjCPropertyGetterName ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$36.clang_Cursor_getObjCPropertyGetterName$MH, \"clang_Cursor_getObjCPropertyGetterName\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_getObjCPropertySetterName$MH() {\n+        return RuntimeHelper.requireNonNull(constants$36.clang_Cursor_getObjCPropertySetterName$MH,\"clang_Cursor_getObjCPropertySetterName\");\n+    }\n+    public static MemorySegment clang_Cursor_getObjCPropertySetterName ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$36.clang_Cursor_getObjCPropertySetterName$MH, \"clang_Cursor_getObjCPropertySetterName\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXObjCDeclQualifier_None() {\n+        return (int)0L;\n+    }\n+    public static int CXObjCDeclQualifier_In() {\n+        return (int)1L;\n+    }\n+    public static int CXObjCDeclQualifier_Inout() {\n+        return (int)2L;\n+    }\n+    public static int CXObjCDeclQualifier_Out() {\n+        return (int)4L;\n+    }\n+    public static int CXObjCDeclQualifier_Bycopy() {\n+        return (int)8L;\n+    }\n+    public static int CXObjCDeclQualifier_Byref() {\n+        return (int)16L;\n+    }\n+    public static int CXObjCDeclQualifier_Oneway() {\n+        return (int)32L;\n+    }\n+    public static MethodHandle clang_Cursor_getObjCDeclQualifiers$MH() {\n+        return RuntimeHelper.requireNonNull(constants$36.clang_Cursor_getObjCDeclQualifiers$MH,\"clang_Cursor_getObjCDeclQualifiers\");\n+    }\n+    public static int clang_Cursor_getObjCDeclQualifiers ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$36.clang_Cursor_getObjCDeclQualifiers$MH, \"clang_Cursor_getObjCDeclQualifiers\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_isObjCOptional$MH() {\n+        return RuntimeHelper.requireNonNull(constants$36.clang_Cursor_isObjCOptional$MH,\"clang_Cursor_isObjCOptional\");\n+    }\n+    public static int clang_Cursor_isObjCOptional ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$36.clang_Cursor_isObjCOptional$MH, \"clang_Cursor_isObjCOptional\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_isVariadic$MH() {\n+        return RuntimeHelper.requireNonNull(constants$36.clang_Cursor_isVariadic$MH,\"clang_Cursor_isVariadic\");\n+    }\n+    public static int clang_Cursor_isVariadic ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$36.clang_Cursor_isVariadic$MH, \"clang_Cursor_isVariadic\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$36 {\n+\n+        static final FunctionDescriptor clang_Cursor_getObjCPropertyAttributes$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            ),\n+            C_INT\n+        );\n+        static final MethodHandle clang_Cursor_getObjCPropertyAttributes$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Cursor_getObjCPropertyAttributes\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;I)I\",\n+            constants$36.clang_Cursor_getObjCPropertyAttributes$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Cursor_getObjCPropertyGetterName$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Cursor_getObjCPropertyGetterName$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Cursor_getObjCPropertyGetterName\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$36.clang_Cursor_getObjCPropertyGetterName$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Cursor_getObjCPropertySetterName$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Cursor_getObjCPropertySetterName$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Cursor_getObjCPropertySetterName\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$36.clang_Cursor_getObjCPropertySetterName$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Cursor_getObjCDeclQualifiers$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Cursor_getObjCDeclQualifiers$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Cursor_getObjCDeclQualifiers\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$36.clang_Cursor_getObjCDeclQualifiers$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Cursor_isObjCOptional$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Cursor_isObjCOptional$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Cursor_isObjCOptional\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$36.clang_Cursor_isObjCOptional$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Cursor_isVariadic$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Cursor_isVariadic$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Cursor_isVariadic\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$36.clang_Cursor_isVariadic$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_Cursor_isExternalSymbol$MH() {\n+        return RuntimeHelper.requireNonNull(constants$37.clang_Cursor_isExternalSymbol$MH,\"clang_Cursor_isExternalSymbol\");\n+    }\n+    public static int clang_Cursor_isExternalSymbol ( MemorySegment C,  Addressable language,  Addressable definedIn,  Addressable isGenerated) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$37.clang_Cursor_isExternalSymbol$MH, \"clang_Cursor_isExternalSymbol\");\n+        try {\n+            return (int)mh$.invokeExact(C, language.address(), definedIn.address(), isGenerated.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_getCommentRange$MH() {\n+        return RuntimeHelper.requireNonNull(constants$37.clang_Cursor_getCommentRange$MH,\"clang_Cursor_getCommentRange\");\n+    }\n+    public static MemorySegment clang_Cursor_getCommentRange ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$37.clang_Cursor_getCommentRange$MH, \"clang_Cursor_getCommentRange\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_getRawCommentText$MH() {\n+        return RuntimeHelper.requireNonNull(constants$37.clang_Cursor_getRawCommentText$MH,\"clang_Cursor_getRawCommentText\");\n+    }\n+    public static MemorySegment clang_Cursor_getRawCommentText ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$37.clang_Cursor_getRawCommentText$MH, \"clang_Cursor_getRawCommentText\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_getBriefCommentText$MH() {\n+        return RuntimeHelper.requireNonNull(constants$37.clang_Cursor_getBriefCommentText$MH,\"clang_Cursor_getBriefCommentText\");\n+    }\n+    public static MemorySegment clang_Cursor_getBriefCommentText ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$37.clang_Cursor_getBriefCommentText$MH, \"clang_Cursor_getBriefCommentText\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_getMangling$MH() {\n+        return RuntimeHelper.requireNonNull(constants$37.clang_Cursor_getMangling$MH,\"clang_Cursor_getMangling\");\n+    }\n+    public static MemorySegment clang_Cursor_getMangling ( MemorySegment x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$37.clang_Cursor_getMangling$MH, \"clang_Cursor_getMangling\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_getCXXManglings$MH() {\n+        return RuntimeHelper.requireNonNull(constants$37.clang_Cursor_getCXXManglings$MH,\"clang_Cursor_getCXXManglings\");\n+    }\n+    public static MemoryAddress clang_Cursor_getCXXManglings ( MemorySegment x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$37.clang_Cursor_getCXXManglings$MH, \"clang_Cursor_getCXXManglings\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$37 {\n+\n+        static final FunctionDescriptor clang_Cursor_isExternalSymbol$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            ),\n+            C_POINTER,\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_Cursor_isExternalSymbol$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Cursor_isExternalSymbol\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+            constants$37.clang_Cursor_isExternalSymbol$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Cursor_getCommentRange$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+            C_INT.withName(\"begin_int_data\"),\n+            C_INT.withName(\"end_int_data\")\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Cursor_getCommentRange$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Cursor_getCommentRange\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$37.clang_Cursor_getCommentRange$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Cursor_getRawCommentText$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Cursor_getRawCommentText$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Cursor_getRawCommentText\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$37.clang_Cursor_getRawCommentText$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Cursor_getBriefCommentText$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Cursor_getBriefCommentText$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Cursor_getBriefCommentText\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$37.clang_Cursor_getBriefCommentText$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Cursor_getMangling$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Cursor_getMangling$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Cursor_getMangling\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$37.clang_Cursor_getMangling$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Cursor_getCXXManglings$FUNC = FunctionDescriptor.of(C_POINTER,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Cursor_getCXXManglings$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Cursor_getCXXManglings\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$37.clang_Cursor_getCXXManglings$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_Cursor_getObjCManglings$MH() {\n+        return RuntimeHelper.requireNonNull(constants$38.clang_Cursor_getObjCManglings$MH,\"clang_Cursor_getObjCManglings\");\n+    }\n+    public static MemoryAddress clang_Cursor_getObjCManglings ( MemorySegment x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$38.clang_Cursor_getObjCManglings$MH, \"clang_Cursor_getObjCManglings\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_getModule$MH() {\n+        return RuntimeHelper.requireNonNull(constants$38.clang_Cursor_getModule$MH,\"clang_Cursor_getModule\");\n+    }\n+    public static MemoryAddress clang_Cursor_getModule ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$38.clang_Cursor_getModule$MH, \"clang_Cursor_getModule\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getModuleForFile$MH() {\n+        return RuntimeHelper.requireNonNull(constants$38.clang_getModuleForFile$MH,\"clang_getModuleForFile\");\n+    }\n+    public static MemoryAddress clang_getModuleForFile ( Addressable x0,  Addressable x1) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$38.clang_getModuleForFile$MH, \"clang_getModuleForFile\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(x0.address(), x1.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Module_getASTFile$MH() {\n+        return RuntimeHelper.requireNonNull(constants$38.clang_Module_getASTFile$MH,\"clang_Module_getASTFile\");\n+    }\n+    public static MemoryAddress clang_Module_getASTFile ( Addressable Module) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$38.clang_Module_getASTFile$MH, \"clang_Module_getASTFile\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(Module.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Module_getParent$MH() {\n+        return RuntimeHelper.requireNonNull(constants$38.clang_Module_getParent$MH,\"clang_Module_getParent\");\n+    }\n+    public static MemoryAddress clang_Module_getParent ( Addressable Module) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$38.clang_Module_getParent$MH, \"clang_Module_getParent\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(Module.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Module_getName$MH() {\n+        return RuntimeHelper.requireNonNull(constants$38.clang_Module_getName$MH,\"clang_Module_getName\");\n+    }\n+    public static MemorySegment clang_Module_getName ( Addressable Module) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$38.clang_Module_getName$MH, \"clang_Module_getName\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(Module.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$38 {\n+\n+        static final FunctionDescriptor clang_Cursor_getObjCManglings$FUNC = FunctionDescriptor.of(C_POINTER,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Cursor_getObjCManglings$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Cursor_getObjCManglings\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$38.clang_Cursor_getObjCManglings$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Cursor_getModule$FUNC = FunctionDescriptor.of(C_POINTER,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Cursor_getModule$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Cursor_getModule\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$38.clang_Cursor_getModule$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getModuleForFile$FUNC = FunctionDescriptor.of(C_POINTER,\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getModuleForFile$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getModuleForFile\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$38.clang_getModuleForFile$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Module_getASTFile$FUNC = FunctionDescriptor.of(C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_Module_getASTFile$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Module_getASTFile\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$38.clang_Module_getASTFile$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Module_getParent$FUNC = FunctionDescriptor.of(C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_Module_getParent$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Module_getParent\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$38.clang_Module_getParent$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Module_getName$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_Module_getName$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Module_getName\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$38.clang_Module_getName$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_Module_getFullName$MH() {\n+        return RuntimeHelper.requireNonNull(constants$39.clang_Module_getFullName$MH,\"clang_Module_getFullName\");\n+    }\n+    public static MemorySegment clang_Module_getFullName ( Addressable Module) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$39.clang_Module_getFullName$MH, \"clang_Module_getFullName\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(Module.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Module_isSystem$MH() {\n+        return RuntimeHelper.requireNonNull(constants$39.clang_Module_isSystem$MH,\"clang_Module_isSystem\");\n+    }\n+    public static int clang_Module_isSystem ( Addressable Module) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$39.clang_Module_isSystem$MH, \"clang_Module_isSystem\");\n+        try {\n+            return (int)mh$.invokeExact(Module.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Module_getNumTopLevelHeaders$MH() {\n+        return RuntimeHelper.requireNonNull(constants$39.clang_Module_getNumTopLevelHeaders$MH,\"clang_Module_getNumTopLevelHeaders\");\n+    }\n+    public static int clang_Module_getNumTopLevelHeaders ( Addressable x0,  Addressable Module) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$39.clang_Module_getNumTopLevelHeaders$MH, \"clang_Module_getNumTopLevelHeaders\");\n+        try {\n+            return (int)mh$.invokeExact(x0.address(), Module.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Module_getTopLevelHeader$MH() {\n+        return RuntimeHelper.requireNonNull(constants$39.clang_Module_getTopLevelHeader$MH,\"clang_Module_getTopLevelHeader\");\n+    }\n+    public static MemoryAddress clang_Module_getTopLevelHeader ( Addressable x0,  Addressable Module,  int Index) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$39.clang_Module_getTopLevelHeader$MH, \"clang_Module_getTopLevelHeader\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(x0.address(), Module.address(), Index);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_CXXConstructor_isConvertingConstructor$MH() {\n+        return RuntimeHelper.requireNonNull(constants$39.clang_CXXConstructor_isConvertingConstructor$MH,\"clang_CXXConstructor_isConvertingConstructor\");\n+    }\n+    public static int clang_CXXConstructor_isConvertingConstructor ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$39.clang_CXXConstructor_isConvertingConstructor$MH, \"clang_CXXConstructor_isConvertingConstructor\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_CXXConstructor_isCopyConstructor$MH() {\n+        return RuntimeHelper.requireNonNull(constants$39.clang_CXXConstructor_isCopyConstructor$MH,\"clang_CXXConstructor_isCopyConstructor\");\n+    }\n+    public static int clang_CXXConstructor_isCopyConstructor ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$39.clang_CXXConstructor_isCopyConstructor$MH, \"clang_CXXConstructor_isCopyConstructor\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$39 {\n+\n+        static final FunctionDescriptor clang_Module_getFullName$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_Module_getFullName$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Module_getFullName\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$39.clang_Module_getFullName$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Module_isSystem$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_Module_isSystem$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Module_isSystem\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+            constants$39.clang_Module_isSystem$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Module_getNumTopLevelHeaders$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_Module_getNumTopLevelHeaders$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Module_getNumTopLevelHeaders\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+            constants$39.clang_Module_getNumTopLevelHeaders$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Module_getTopLevelHeader$FUNC = FunctionDescriptor.of(C_POINTER,\n+            C_POINTER,\n+            C_POINTER,\n+            C_INT\n+        );\n+        static final MethodHandle clang_Module_getTopLevelHeader$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Module_getTopLevelHeader\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;I)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$39.clang_Module_getTopLevelHeader$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_CXXConstructor_isConvertingConstructor$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_CXXConstructor_isConvertingConstructor$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_CXXConstructor_isConvertingConstructor\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$39.clang_CXXConstructor_isConvertingConstructor$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_CXXConstructor_isCopyConstructor$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_CXXConstructor_isCopyConstructor$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_CXXConstructor_isCopyConstructor\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$39.clang_CXXConstructor_isCopyConstructor$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_CXXConstructor_isDefaultConstructor$MH() {\n+        return RuntimeHelper.requireNonNull(constants$40.clang_CXXConstructor_isDefaultConstructor$MH,\"clang_CXXConstructor_isDefaultConstructor\");\n+    }\n+    public static int clang_CXXConstructor_isDefaultConstructor ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$40.clang_CXXConstructor_isDefaultConstructor$MH, \"clang_CXXConstructor_isDefaultConstructor\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_CXXConstructor_isMoveConstructor$MH() {\n+        return RuntimeHelper.requireNonNull(constants$40.clang_CXXConstructor_isMoveConstructor$MH,\"clang_CXXConstructor_isMoveConstructor\");\n+    }\n+    public static int clang_CXXConstructor_isMoveConstructor ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$40.clang_CXXConstructor_isMoveConstructor$MH, \"clang_CXXConstructor_isMoveConstructor\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_CXXField_isMutable$MH() {\n+        return RuntimeHelper.requireNonNull(constants$40.clang_CXXField_isMutable$MH,\"clang_CXXField_isMutable\");\n+    }\n+    public static int clang_CXXField_isMutable ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$40.clang_CXXField_isMutable$MH, \"clang_CXXField_isMutable\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_CXXMethod_isDefaulted$MH() {\n+        return RuntimeHelper.requireNonNull(constants$40.clang_CXXMethod_isDefaulted$MH,\"clang_CXXMethod_isDefaulted\");\n+    }\n+    public static int clang_CXXMethod_isDefaulted ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$40.clang_CXXMethod_isDefaulted$MH, \"clang_CXXMethod_isDefaulted\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_CXXMethod_isPureVirtual$MH() {\n+        return RuntimeHelper.requireNonNull(constants$40.clang_CXXMethod_isPureVirtual$MH,\"clang_CXXMethod_isPureVirtual\");\n+    }\n+    public static int clang_CXXMethod_isPureVirtual ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$40.clang_CXXMethod_isPureVirtual$MH, \"clang_CXXMethod_isPureVirtual\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_CXXMethod_isStatic$MH() {\n+        return RuntimeHelper.requireNonNull(constants$40.clang_CXXMethod_isStatic$MH,\"clang_CXXMethod_isStatic\");\n+    }\n+    public static int clang_CXXMethod_isStatic ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$40.clang_CXXMethod_isStatic$MH, \"clang_CXXMethod_isStatic\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$40 {\n+\n+        static final FunctionDescriptor clang_CXXConstructor_isDefaultConstructor$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_CXXConstructor_isDefaultConstructor$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_CXXConstructor_isDefaultConstructor\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$40.clang_CXXConstructor_isDefaultConstructor$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_CXXConstructor_isMoveConstructor$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_CXXConstructor_isMoveConstructor$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_CXXConstructor_isMoveConstructor\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$40.clang_CXXConstructor_isMoveConstructor$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_CXXField_isMutable$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_CXXField_isMutable$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_CXXField_isMutable\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$40.clang_CXXField_isMutable$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_CXXMethod_isDefaulted$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_CXXMethod_isDefaulted$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_CXXMethod_isDefaulted\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$40.clang_CXXMethod_isDefaulted$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_CXXMethod_isPureVirtual$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_CXXMethod_isPureVirtual$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_CXXMethod_isPureVirtual\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$40.clang_CXXMethod_isPureVirtual$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_CXXMethod_isStatic$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_CXXMethod_isStatic$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_CXXMethod_isStatic\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$40.clang_CXXMethod_isStatic$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_CXXMethod_isVirtual$MH() {\n+        return RuntimeHelper.requireNonNull(constants$41.clang_CXXMethod_isVirtual$MH,\"clang_CXXMethod_isVirtual\");\n+    }\n+    public static int clang_CXXMethod_isVirtual ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$41.clang_CXXMethod_isVirtual$MH, \"clang_CXXMethod_isVirtual\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_CXXRecord_isAbstract$MH() {\n+        return RuntimeHelper.requireNonNull(constants$41.clang_CXXRecord_isAbstract$MH,\"clang_CXXRecord_isAbstract\");\n+    }\n+    public static int clang_CXXRecord_isAbstract ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$41.clang_CXXRecord_isAbstract$MH, \"clang_CXXRecord_isAbstract\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_EnumDecl_isScoped$MH() {\n+        return RuntimeHelper.requireNonNull(constants$41.clang_EnumDecl_isScoped$MH,\"clang_EnumDecl_isScoped\");\n+    }\n+    public static int clang_EnumDecl_isScoped ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$41.clang_EnumDecl_isScoped$MH, \"clang_EnumDecl_isScoped\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_CXXMethod_isConst$MH() {\n+        return RuntimeHelper.requireNonNull(constants$41.clang_CXXMethod_isConst$MH,\"clang_CXXMethod_isConst\");\n+    }\n+    public static int clang_CXXMethod_isConst ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$41.clang_CXXMethod_isConst$MH, \"clang_CXXMethod_isConst\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getTemplateCursorKind$MH() {\n+        return RuntimeHelper.requireNonNull(constants$41.clang_getTemplateCursorKind$MH,\"clang_getTemplateCursorKind\");\n+    }\n+    public static int clang_getTemplateCursorKind ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$41.clang_getTemplateCursorKind$MH, \"clang_getTemplateCursorKind\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getTemplateSpecializationKind$MH() {\n+        return RuntimeHelper.requireNonNull(constants$41.clang_getTemplateSpecializationKind$MH,\"clang_getTemplateSpecializationKind\");\n+    }\n+    public static int clang_getTemplateSpecializationKind ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$41.clang_getTemplateSpecializationKind$MH, \"clang_getTemplateSpecializationKind\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$41 {\n+\n+        static final FunctionDescriptor clang_CXXMethod_isVirtual$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_CXXMethod_isVirtual$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_CXXMethod_isVirtual\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$41.clang_CXXMethod_isVirtual$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_CXXRecord_isAbstract$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_CXXRecord_isAbstract$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_CXXRecord_isAbstract\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$41.clang_CXXRecord_isAbstract$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_EnumDecl_isScoped$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_EnumDecl_isScoped$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_EnumDecl_isScoped\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$41.clang_EnumDecl_isScoped$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_CXXMethod_isConst$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_CXXMethod_isConst$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_CXXMethod_isConst\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$41.clang_CXXMethod_isConst$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getTemplateCursorKind$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getTemplateCursorKind$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getTemplateCursorKind\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$41.clang_getTemplateCursorKind$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getTemplateSpecializationKind$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getTemplateSpecializationKind$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getTemplateSpecializationKind\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$41.clang_getTemplateSpecializationKind$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_getSpecializedCursorTemplate$MH() {\n+        return RuntimeHelper.requireNonNull(constants$42.clang_getSpecializedCursorTemplate$MH,\"clang_getSpecializedCursorTemplate\");\n+    }\n+    public static MemorySegment clang_getSpecializedCursorTemplate ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$42.clang_getSpecializedCursorTemplate$MH, \"clang_getSpecializedCursorTemplate\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getCursorReferenceNameRange$MH() {\n+        return RuntimeHelper.requireNonNull(constants$42.clang_getCursorReferenceNameRange$MH,\"clang_getCursorReferenceNameRange\");\n+    }\n+    public static MemorySegment clang_getCursorReferenceNameRange ( MemorySegment C,  int NameFlags,  int PieceIndex) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$42.clang_getCursorReferenceNameRange$MH, \"clang_getCursorReferenceNameRange\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(C, NameFlags, PieceIndex);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXNameRange_WantQualifier() {\n+        return (int)1L;\n+    }\n+    public static int CXNameRange_WantTemplateArgs() {\n+        return (int)2L;\n+    }\n+    public static int CXNameRange_WantSinglePiece() {\n+        return (int)4L;\n+    }\n+    public static int CXToken_Punctuation() {\n+        return (int)0L;\n+    }\n+    public static int CXToken_Keyword() {\n+        return (int)1L;\n+    }\n+    public static int CXToken_Identifier() {\n+        return (int)2L;\n+    }\n+    public static int CXToken_Literal() {\n+        return (int)3L;\n+    }\n+    public static int CXToken_Comment() {\n+        return (int)4L;\n+    }\n+    public static class CXToken {\n+\n+        static final MemoryLayout CXToken$struct$LAYOUT = MemoryLayout.ofStruct(\n+            MemoryLayout.ofSequence(4, C_INT).withName(\"int_data\"),\n+            C_POINTER.withName(\"ptr_data\")\n+        );\n+        public static MemoryLayout $LAYOUT() {\n+            return CXToken.CXToken$struct$LAYOUT;\n+        }\n+        public static MemorySegment int_data$slice(MemorySegment seg) {\n+            return RuntimeHelper.nonCloseableNonTransferableSegment(seg.asSlice(0, 16));\n+        }\n+        static final VarHandle ptr_data$VH = MemoryHandles.asAddressVarHandle(CXToken$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"ptr_data\")));\n+        public static VarHandle ptr_data$VH() {\n+            return CXToken.ptr_data$VH;\n+        }\n+        public static MemoryAddress ptr_data$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXToken.ptr_data$VH.get(seg);\n+        }\n+        public static void ptr_data$set( MemorySegment seg, MemoryAddress x) {\n+            CXToken.ptr_data$VH.set(seg, x);\n+        }\n+        public static MemoryAddress ptr_data$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXToken.ptr_data$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void ptr_data$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXToken.ptr_data$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public static long sizeof() { return $LAYOUT().byteSize(); }\n+        public static MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\n+        public static MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n+        public static MemorySegment allocateArray(int len) {\n+            return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }        public static MemorySegment allocateArray(int len, NativeScope scope) {\n+            return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }\n+        public static MemorySegment allocatePointer() {\n+            return MemorySegment.allocateNative(C_POINTER);\n+        }\n+        public static MemorySegment allocatePointer(NativeScope scope) {\n+            return scope.allocate(C_POINTER);\n+        }\n+        public static MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\n+    }\n+\n+    public static MethodHandle clang_getToken$MH() {\n+        return RuntimeHelper.requireNonNull(constants$42.clang_getToken$MH,\"clang_getToken\");\n+    }\n+    public static MemoryAddress clang_getToken ( Addressable TU,  MemorySegment Location) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$42.clang_getToken$MH, \"clang_getToken\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(TU.address(), Location);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getTokenKind$MH() {\n+        return RuntimeHelper.requireNonNull(constants$42.clang_getTokenKind$MH,\"clang_getTokenKind\");\n+    }\n+    public static int clang_getTokenKind ( MemorySegment x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$42.clang_getTokenKind$MH, \"clang_getTokenKind\");\n+        try {\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getTokenSpelling$MH() {\n+        return RuntimeHelper.requireNonNull(constants$42.clang_getTokenSpelling$MH,\"clang_getTokenSpelling\");\n+    }\n+    public static MemorySegment clang_getTokenSpelling ( Addressable x0,  MemorySegment x1) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$42.clang_getTokenSpelling$MH, \"clang_getTokenSpelling\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(x0.address(), x1);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getTokenLocation$MH() {\n+        return RuntimeHelper.requireNonNull(constants$42.clang_getTokenLocation$MH,\"clang_getTokenLocation\");\n+    }\n+    public static MemorySegment clang_getTokenLocation ( Addressable x0,  MemorySegment x1) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$42.clang_getTokenLocation$MH, \"clang_getTokenLocation\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(x0.address(), x1);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$42 {\n+\n+        static final FunctionDescriptor clang_getSpecializedCursorTemplate$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getSpecializedCursorTemplate$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getSpecializedCursorTemplate\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$42.clang_getSpecializedCursorTemplate$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getCursorReferenceNameRange$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+            C_INT.withName(\"begin_int_data\"),\n+            C_INT.withName(\"end_int_data\")\n+        ),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            ),\n+            C_INT,\n+            C_INT\n+        );\n+        static final MethodHandle clang_getCursorReferenceNameRange$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCursorReferenceNameRange\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;II)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$42.clang_getCursorReferenceNameRange$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getToken$FUNC = FunctionDescriptor.of(C_POINTER,\n+            C_POINTER,\n+            MemoryLayout.ofStruct(\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+                C_INT.withName(\"int_data\"),\n+                MemoryLayout.ofPaddingBits(32)\n+            )\n+        );\n+        static final MethodHandle clang_getToken$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getToken\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$42.clang_getToken$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getTokenKind$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                MemoryLayout.ofSequence(4, C_INT).withName(\"int_data\"),\n+                C_POINTER.withName(\"ptr_data\")\n+            )\n+        );\n+        static final MethodHandle clang_getTokenKind$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getTokenKind\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$42.clang_getTokenKind$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getTokenSpelling$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            C_POINTER,\n+            MemoryLayout.ofStruct(\n+                MemoryLayout.ofSequence(4, C_INT).withName(\"int_data\"),\n+                C_POINTER.withName(\"ptr_data\")\n+            )\n+        );\n+        static final MethodHandle clang_getTokenSpelling$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getTokenSpelling\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$42.clang_getTokenSpelling$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getTokenLocation$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+            C_INT.withName(\"int_data\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            C_POINTER,\n+            MemoryLayout.ofStruct(\n+                MemoryLayout.ofSequence(4, C_INT).withName(\"int_data\"),\n+                C_POINTER.withName(\"ptr_data\")\n+            )\n+        );\n+        static final MethodHandle clang_getTokenLocation$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getTokenLocation\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$42.clang_getTokenLocation$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_getTokenExtent$MH() {\n+        return RuntimeHelper.requireNonNull(constants$43.clang_getTokenExtent$MH,\"clang_getTokenExtent\");\n+    }\n+    public static MemorySegment clang_getTokenExtent ( Addressable x0,  MemorySegment x1) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$43.clang_getTokenExtent$MH, \"clang_getTokenExtent\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(x0.address(), x1);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_tokenize$MH() {\n+        return RuntimeHelper.requireNonNull(constants$43.clang_tokenize$MH,\"clang_tokenize\");\n+    }\n+    public static void clang_tokenize ( Addressable TU,  MemorySegment Range,  Addressable Tokens,  Addressable NumTokens) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$43.clang_tokenize$MH, \"clang_tokenize\");\n+        try {\n+            mh$.invokeExact(TU.address(), Range, Tokens.address(), NumTokens.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_annotateTokens$MH() {\n+        return RuntimeHelper.requireNonNull(constants$43.clang_annotateTokens$MH,\"clang_annotateTokens\");\n+    }\n+    public static void clang_annotateTokens ( Addressable TU,  Addressable Tokens,  int NumTokens,  Addressable Cursors) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$43.clang_annotateTokens$MH, \"clang_annotateTokens\");\n+        try {\n+            mh$.invokeExact(TU.address(), Tokens.address(), NumTokens, Cursors.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_disposeTokens$MH() {\n+        return RuntimeHelper.requireNonNull(constants$43.clang_disposeTokens$MH,\"clang_disposeTokens\");\n+    }\n+    public static void clang_disposeTokens ( Addressable TU,  Addressable Tokens,  int NumTokens) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$43.clang_disposeTokens$MH, \"clang_disposeTokens\");\n+        try {\n+            mh$.invokeExact(TU.address(), Tokens.address(), NumTokens);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getCursorKindSpelling$MH() {\n+        return RuntimeHelper.requireNonNull(constants$43.clang_getCursorKindSpelling$MH,\"clang_getCursorKindSpelling\");\n+    }\n+    public static MemorySegment clang_getCursorKindSpelling ( int Kind) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$43.clang_getCursorKindSpelling$MH, \"clang_getCursorKindSpelling\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(Kind);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getDefinitionSpellingAndExtent$MH() {\n+        return RuntimeHelper.requireNonNull(constants$43.clang_getDefinitionSpellingAndExtent$MH,\"clang_getDefinitionSpellingAndExtent\");\n+    }\n+    public static void clang_getDefinitionSpellingAndExtent ( MemorySegment x0,  Addressable startBuf,  Addressable endBuf,  Addressable startLine,  Addressable startColumn,  Addressable endLine,  Addressable endColumn) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$43.clang_getDefinitionSpellingAndExtent$MH, \"clang_getDefinitionSpellingAndExtent\");\n+        try {\n+            mh$.invokeExact(x0, startBuf.address(), endBuf.address(), startLine.address(), startColumn.address(), endLine.address(), endColumn.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$43 {\n+\n+        static final FunctionDescriptor clang_getTokenExtent$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+            C_INT.withName(\"begin_int_data\"),\n+            C_INT.withName(\"end_int_data\")\n+        ),\n+            C_POINTER,\n+            MemoryLayout.ofStruct(\n+                MemoryLayout.ofSequence(4, C_INT).withName(\"int_data\"),\n+                C_POINTER.withName(\"ptr_data\")\n+            )\n+        );\n+        static final MethodHandle clang_getTokenExtent$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getTokenExtent\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$43.clang_getTokenExtent$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_tokenize$FUNC = FunctionDescriptor.ofVoid(\n+            C_POINTER,\n+            MemoryLayout.ofStruct(\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+                C_INT.withName(\"begin_int_data\"),\n+                C_INT.withName(\"end_int_data\")\n+            ),\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_tokenize$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_tokenize\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)V\",\n+            constants$43.clang_tokenize$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_annotateTokens$FUNC = FunctionDescriptor.ofVoid(\n+            C_POINTER,\n+            C_POINTER,\n+            C_INT,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_annotateTokens$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_annotateTokens\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;ILjdk\/incubator\/foreign\/MemoryAddress;)V\",\n+            constants$43.clang_annotateTokens$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_disposeTokens$FUNC = FunctionDescriptor.ofVoid(\n+            C_POINTER,\n+            C_POINTER,\n+            C_INT\n+        );\n+        static final MethodHandle clang_disposeTokens$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_disposeTokens\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;I)V\",\n+            constants$43.clang_disposeTokens$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getCursorKindSpelling$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            C_INT\n+        );\n+        static final MethodHandle clang_getCursorKindSpelling$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCursorKindSpelling\",\n+            \"(I)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$43.clang_getCursorKindSpelling$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getDefinitionSpellingAndExtent$FUNC = FunctionDescriptor.ofVoid(\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            ),\n+            C_POINTER,\n+            C_POINTER,\n+            C_POINTER,\n+            C_POINTER,\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getDefinitionSpellingAndExtent$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getDefinitionSpellingAndExtent\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)V\",\n+            constants$43.clang_getDefinitionSpellingAndExtent$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_enableStackTraces$MH() {\n+        return RuntimeHelper.requireNonNull(constants$44.clang_enableStackTraces$MH,\"clang_enableStackTraces\");\n+    }\n+    public static void clang_enableStackTraces () {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$44.clang_enableStackTraces$MH, \"clang_enableStackTraces\");\n+        try {\n+            mh$.invokeExact();\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public interface clang_executeOnThread$fn {\n+\n+        void apply(jdk.incubator.foreign.MemoryAddress x0);\n+        static MemorySegment allocate(clang_executeOnThread$fn fi) {\n+            return RuntimeHelper.upcallStub(clang_executeOnThread$fn.class, fi, constants$44.clang_executeOnThread$fn$FUNC, \"(Ljdk\/incubator\/foreign\/MemoryAddress;)V\");\n+        }\n+        static MemorySegment allocate(clang_executeOnThread$fn fi, NativeScope scope) {\n+            return allocate(fi).handoff(scope);\n+        }\n+    }\n+\n+    public static MethodHandle clang_executeOnThread$MH() {\n+        return RuntimeHelper.requireNonNull(constants$44.clang_executeOnThread$MH,\"clang_executeOnThread\");\n+    }\n+    public static void clang_executeOnThread ( Addressable fn,  Addressable user_data,  int stack_size) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$44.clang_executeOnThread$MH, \"clang_executeOnThread\");\n+        try {\n+            mh$.invokeExact(fn.address(), user_data.address(), stack_size);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class CXCompletionResult {\n+\n+        static final MemoryLayout CXCompletionResult$struct$LAYOUT = MemoryLayout.ofStruct(\n+            C_INT.withName(\"CursorKind\"),\n+            MemoryLayout.ofPaddingBits(32),\n+            C_POINTER.withName(\"CompletionString\")\n+        );\n+        public static MemoryLayout $LAYOUT() {\n+            return CXCompletionResult.CXCompletionResult$struct$LAYOUT;\n+        }\n+        static final VarHandle CursorKind$VH = CXCompletionResult$struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"CursorKind\"));\n+        public static VarHandle CursorKind$VH() {\n+            return CXCompletionResult.CursorKind$VH;\n+        }\n+        public static int CursorKind$get(MemorySegment seg) {\n+            return (int)CXCompletionResult.CursorKind$VH.get(seg);\n+        }\n+        public static void CursorKind$set( MemorySegment seg, int x) {\n+            CXCompletionResult.CursorKind$VH.set(seg, x);\n+        }\n+        public static int CursorKind$get(MemorySegment seg, long index) {\n+            return (int)CXCompletionResult.CursorKind$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void CursorKind$set(MemorySegment seg, long index, int x) {\n+            CXCompletionResult.CursorKind$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle CompletionString$VH = MemoryHandles.asAddressVarHandle(CXCompletionResult$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"CompletionString\")));\n+        public static VarHandle CompletionString$VH() {\n+            return CXCompletionResult.CompletionString$VH;\n+        }\n+        public static MemoryAddress CompletionString$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXCompletionResult.CompletionString$VH.get(seg);\n+        }\n+        public static void CompletionString$set( MemorySegment seg, MemoryAddress x) {\n+            CXCompletionResult.CompletionString$VH.set(seg, x);\n+        }\n+        public static MemoryAddress CompletionString$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXCompletionResult.CompletionString$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void CompletionString$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXCompletionResult.CompletionString$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public static long sizeof() { return $LAYOUT().byteSize(); }\n+        public static MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\n+        public static MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n+        public static MemorySegment allocateArray(int len) {\n+            return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }        public static MemorySegment allocateArray(int len, NativeScope scope) {\n+            return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }\n+        public static MemorySegment allocatePointer() {\n+            return MemorySegment.allocateNative(C_POINTER);\n+        }\n+        public static MemorySegment allocatePointer(NativeScope scope) {\n+            return scope.allocate(C_POINTER);\n+        }\n+        public static MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\n+    }\n+\n+    public static int CXCompletionChunk_Optional() {\n+        return (int)0L;\n+    }\n+    public static int CXCompletionChunk_TypedText() {\n+        return (int)1L;\n+    }\n+    public static int CXCompletionChunk_Text() {\n+        return (int)2L;\n+    }\n+    public static int CXCompletionChunk_Placeholder() {\n+        return (int)3L;\n+    }\n+    public static int CXCompletionChunk_Informative() {\n+        return (int)4L;\n+    }\n+    public static int CXCompletionChunk_CurrentParameter() {\n+        return (int)5L;\n+    }\n+    public static int CXCompletionChunk_LeftParen() {\n+        return (int)6L;\n+    }\n+    public static int CXCompletionChunk_RightParen() {\n+        return (int)7L;\n+    }\n+    public static int CXCompletionChunk_LeftBracket() {\n+        return (int)8L;\n+    }\n+    public static int CXCompletionChunk_RightBracket() {\n+        return (int)9L;\n+    }\n+    public static int CXCompletionChunk_LeftBrace() {\n+        return (int)10L;\n+    }\n+    public static int CXCompletionChunk_RightBrace() {\n+        return (int)11L;\n+    }\n+    public static int CXCompletionChunk_LeftAngle() {\n+        return (int)12L;\n+    }\n+    public static int CXCompletionChunk_RightAngle() {\n+        return (int)13L;\n+    }\n+    public static int CXCompletionChunk_Comma() {\n+        return (int)14L;\n+    }\n+    public static int CXCompletionChunk_ResultType() {\n+        return (int)15L;\n+    }\n+    public static int CXCompletionChunk_Colon() {\n+        return (int)16L;\n+    }\n+    public static int CXCompletionChunk_SemiColon() {\n+        return (int)17L;\n+    }\n+    public static int CXCompletionChunk_Equal() {\n+        return (int)18L;\n+    }\n+    public static int CXCompletionChunk_HorizontalSpace() {\n+        return (int)19L;\n+    }\n+    public static int CXCompletionChunk_VerticalSpace() {\n+        return (int)20L;\n+    }\n+    public static MethodHandle clang_getCompletionChunkKind$MH() {\n+        return RuntimeHelper.requireNonNull(constants$44.clang_getCompletionChunkKind$MH,\"clang_getCompletionChunkKind\");\n+    }\n+    public static int clang_getCompletionChunkKind ( Addressable completion_string,  int chunk_number) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$44.clang_getCompletionChunkKind$MH, \"clang_getCompletionChunkKind\");\n+        try {\n+            return (int)mh$.invokeExact(completion_string.address(), chunk_number);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getCompletionChunkText$MH() {\n+        return RuntimeHelper.requireNonNull(constants$44.clang_getCompletionChunkText$MH,\"clang_getCompletionChunkText\");\n+    }\n+    public static MemorySegment clang_getCompletionChunkText ( Addressable completion_string,  int chunk_number) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$44.clang_getCompletionChunkText$MH, \"clang_getCompletionChunkText\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(completion_string.address(), chunk_number);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getCompletionChunkCompletionString$MH() {\n+        return RuntimeHelper.requireNonNull(constants$44.clang_getCompletionChunkCompletionString$MH,\"clang_getCompletionChunkCompletionString\");\n+    }\n+    public static MemoryAddress clang_getCompletionChunkCompletionString ( Addressable completion_string,  int chunk_number) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$44.clang_getCompletionChunkCompletionString$MH, \"clang_getCompletionChunkCompletionString\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(completion_string.address(), chunk_number);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$44 {\n+\n+        static final FunctionDescriptor clang_enableStackTraces$FUNC = FunctionDescriptor.ofVoid();\n+        static final MethodHandle clang_enableStackTraces$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_enableStackTraces\",\n+            \"()V\",\n+            constants$44.clang_enableStackTraces$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_executeOnThread$fn$FUNC = FunctionDescriptor.ofVoid(\n+            C_POINTER\n+        );\n+        static final FunctionDescriptor clang_executeOnThread$FUNC = FunctionDescriptor.ofVoid(\n+            C_POINTER,\n+            C_POINTER,\n+            C_INT\n+        );\n+        static final MethodHandle clang_executeOnThread$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_executeOnThread\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;I)V\",\n+            constants$44.clang_executeOnThread$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getCompletionChunkKind$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER,\n+            C_INT\n+        );\n+        static final MethodHandle clang_getCompletionChunkKind$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCompletionChunkKind\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;I)I\",\n+            constants$44.clang_getCompletionChunkKind$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getCompletionChunkText$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            C_POINTER,\n+            C_INT\n+        );\n+        static final MethodHandle clang_getCompletionChunkText$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCompletionChunkText\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;I)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$44.clang_getCompletionChunkText$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getCompletionChunkCompletionString$FUNC = FunctionDescriptor.of(C_POINTER,\n+            C_POINTER,\n+            C_INT\n+        );\n+        static final MethodHandle clang_getCompletionChunkCompletionString$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCompletionChunkCompletionString\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;I)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$44.clang_getCompletionChunkCompletionString$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_getNumCompletionChunks$MH() {\n+        return RuntimeHelper.requireNonNull(constants$45.clang_getNumCompletionChunks$MH,\"clang_getNumCompletionChunks\");\n+    }\n+    public static int clang_getNumCompletionChunks ( Addressable completion_string) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$45.clang_getNumCompletionChunks$MH, \"clang_getNumCompletionChunks\");\n+        try {\n+            return (int)mh$.invokeExact(completion_string.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getCompletionPriority$MH() {\n+        return RuntimeHelper.requireNonNull(constants$45.clang_getCompletionPriority$MH,\"clang_getCompletionPriority\");\n+    }\n+    public static int clang_getCompletionPriority ( Addressable completion_string) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$45.clang_getCompletionPriority$MH, \"clang_getCompletionPriority\");\n+        try {\n+            return (int)mh$.invokeExact(completion_string.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getCompletionAvailability$MH() {\n+        return RuntimeHelper.requireNonNull(constants$45.clang_getCompletionAvailability$MH,\"clang_getCompletionAvailability\");\n+    }\n+    public static int clang_getCompletionAvailability ( Addressable completion_string) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$45.clang_getCompletionAvailability$MH, \"clang_getCompletionAvailability\");\n+        try {\n+            return (int)mh$.invokeExact(completion_string.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getCompletionNumAnnotations$MH() {\n+        return RuntimeHelper.requireNonNull(constants$45.clang_getCompletionNumAnnotations$MH,\"clang_getCompletionNumAnnotations\");\n+    }\n+    public static int clang_getCompletionNumAnnotations ( Addressable completion_string) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$45.clang_getCompletionNumAnnotations$MH, \"clang_getCompletionNumAnnotations\");\n+        try {\n+            return (int)mh$.invokeExact(completion_string.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getCompletionAnnotation$MH() {\n+        return RuntimeHelper.requireNonNull(constants$45.clang_getCompletionAnnotation$MH,\"clang_getCompletionAnnotation\");\n+    }\n+    public static MemorySegment clang_getCompletionAnnotation ( Addressable completion_string,  int annotation_number) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$45.clang_getCompletionAnnotation$MH, \"clang_getCompletionAnnotation\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(completion_string.address(), annotation_number);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getCompletionParent$MH() {\n+        return RuntimeHelper.requireNonNull(constants$45.clang_getCompletionParent$MH,\"clang_getCompletionParent\");\n+    }\n+    public static MemorySegment clang_getCompletionParent ( Addressable completion_string,  Addressable kind) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$45.clang_getCompletionParent$MH, \"clang_getCompletionParent\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(completion_string.address(), kind.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$45 {\n+\n+        static final FunctionDescriptor clang_getNumCompletionChunks$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getNumCompletionChunks$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getNumCompletionChunks\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+            constants$45.clang_getNumCompletionChunks$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getCompletionPriority$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getCompletionPriority$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCompletionPriority\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+            constants$45.clang_getCompletionPriority$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getCompletionAvailability$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getCompletionAvailability$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCompletionAvailability\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+            constants$45.clang_getCompletionAvailability$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getCompletionNumAnnotations$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getCompletionNumAnnotations$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCompletionNumAnnotations\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+            constants$45.clang_getCompletionNumAnnotations$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getCompletionAnnotation$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            C_POINTER,\n+            C_INT\n+        );\n+        static final MethodHandle clang_getCompletionAnnotation$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCompletionAnnotation\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;I)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$45.clang_getCompletionAnnotation$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getCompletionParent$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getCompletionParent$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCompletionParent\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$45.clang_getCompletionParent$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_getCompletionBriefComment$MH() {\n+        return RuntimeHelper.requireNonNull(constants$46.clang_getCompletionBriefComment$MH,\"clang_getCompletionBriefComment\");\n+    }\n+    public static MemorySegment clang_getCompletionBriefComment ( Addressable completion_string) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$46.clang_getCompletionBriefComment$MH, \"clang_getCompletionBriefComment\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(completion_string.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getCursorCompletionString$MH() {\n+        return RuntimeHelper.requireNonNull(constants$46.clang_getCursorCompletionString$MH,\"clang_getCursorCompletionString\");\n+    }\n+    public static MemoryAddress clang_getCursorCompletionString ( MemorySegment cursor) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$46.clang_getCursorCompletionString$MH, \"clang_getCursorCompletionString\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(cursor);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class CXCodeCompleteResults {\n+\n+        static final MemoryLayout CXCodeCompleteResults$struct$LAYOUT = MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"Results\"),\n+            C_INT.withName(\"NumResults\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        );\n+        public static MemoryLayout $LAYOUT() {\n+            return CXCodeCompleteResults.CXCodeCompleteResults$struct$LAYOUT;\n+        }\n+        static final VarHandle Results$VH = MemoryHandles.asAddressVarHandle(CXCodeCompleteResults$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"Results\")));\n+        public static VarHandle Results$VH() {\n+            return CXCodeCompleteResults.Results$VH;\n+        }\n+        public static MemoryAddress Results$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXCodeCompleteResults.Results$VH.get(seg);\n+        }\n+        public static void Results$set( MemorySegment seg, MemoryAddress x) {\n+            CXCodeCompleteResults.Results$VH.set(seg, x);\n+        }\n+        public static MemoryAddress Results$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXCodeCompleteResults.Results$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void Results$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXCodeCompleteResults.Results$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle NumResults$VH = CXCodeCompleteResults$struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"NumResults\"));\n+        public static VarHandle NumResults$VH() {\n+            return CXCodeCompleteResults.NumResults$VH;\n+        }\n+        public static int NumResults$get(MemorySegment seg) {\n+            return (int)CXCodeCompleteResults.NumResults$VH.get(seg);\n+        }\n+        public static void NumResults$set( MemorySegment seg, int x) {\n+            CXCodeCompleteResults.NumResults$VH.set(seg, x);\n+        }\n+        public static int NumResults$get(MemorySegment seg, long index) {\n+            return (int)CXCodeCompleteResults.NumResults$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void NumResults$set(MemorySegment seg, long index, int x) {\n+            CXCodeCompleteResults.NumResults$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public static long sizeof() { return $LAYOUT().byteSize(); }\n+        public static MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\n+        public static MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n+        public static MemorySegment allocateArray(int len) {\n+            return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }        public static MemorySegment allocateArray(int len, NativeScope scope) {\n+            return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }\n+        public static MemorySegment allocatePointer() {\n+            return MemorySegment.allocateNative(C_POINTER);\n+        }\n+        public static MemorySegment allocatePointer(NativeScope scope) {\n+            return scope.allocate(C_POINTER);\n+        }\n+        public static MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\n+    }\n+\n+    public static MethodHandle clang_getCompletionNumFixIts$MH() {\n+        return RuntimeHelper.requireNonNull(constants$46.clang_getCompletionNumFixIts$MH,\"clang_getCompletionNumFixIts\");\n+    }\n+    public static int clang_getCompletionNumFixIts ( Addressable results,  int completion_index) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$46.clang_getCompletionNumFixIts$MH, \"clang_getCompletionNumFixIts\");\n+        try {\n+            return (int)mh$.invokeExact(results.address(), completion_index);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getCompletionFixIt$MH() {\n+        return RuntimeHelper.requireNonNull(constants$46.clang_getCompletionFixIt$MH,\"clang_getCompletionFixIt\");\n+    }\n+    public static MemorySegment clang_getCompletionFixIt ( Addressable results,  int completion_index,  int fixit_index,  Addressable replacement_range) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$46.clang_getCompletionFixIt$MH, \"clang_getCompletionFixIt\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(results.address(), completion_index, fixit_index, replacement_range.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXCodeComplete_IncludeMacros() {\n+        return (int)1L;\n+    }\n+    public static int CXCodeComplete_IncludeCodePatterns() {\n+        return (int)2L;\n+    }\n+    public static int CXCodeComplete_IncludeBriefComments() {\n+        return (int)4L;\n+    }\n+    public static int CXCodeComplete_SkipPreamble() {\n+        return (int)8L;\n+    }\n+    public static int CXCodeComplete_IncludeCompletionsWithFixIts() {\n+        return (int)16L;\n+    }\n+    public static int CXCompletionContext_Unexposed() {\n+        return (int)0L;\n+    }\n+    public static int CXCompletionContext_AnyType() {\n+        return (int)1L;\n+    }\n+    public static int CXCompletionContext_AnyValue() {\n+        return (int)2L;\n+    }\n+    public static int CXCompletionContext_ObjCObjectValue() {\n+        return (int)4L;\n+    }\n+    public static int CXCompletionContext_ObjCSelectorValue() {\n+        return (int)8L;\n+    }\n+    public static int CXCompletionContext_CXXClassTypeValue() {\n+        return (int)16L;\n+    }\n+    public static int CXCompletionContext_DotMemberAccess() {\n+        return (int)32L;\n+    }\n+    public static int CXCompletionContext_ArrowMemberAccess() {\n+        return (int)64L;\n+    }\n+    public static int CXCompletionContext_ObjCPropertyAccess() {\n+        return (int)128L;\n+    }\n+    public static int CXCompletionContext_EnumTag() {\n+        return (int)256L;\n+    }\n+    public static int CXCompletionContext_UnionTag() {\n+        return (int)512L;\n+    }\n+    public static int CXCompletionContext_StructTag() {\n+        return (int)1024L;\n+    }\n+    public static int CXCompletionContext_ClassTag() {\n+        return (int)2048L;\n+    }\n+    public static int CXCompletionContext_Namespace() {\n+        return (int)4096L;\n+    }\n+    public static int CXCompletionContext_NestedNameSpecifier() {\n+        return (int)8192L;\n+    }\n+    public static int CXCompletionContext_ObjCInterface() {\n+        return (int)16384L;\n+    }\n+    public static int CXCompletionContext_ObjCProtocol() {\n+        return (int)32768L;\n+    }\n+    public static int CXCompletionContext_ObjCCategory() {\n+        return (int)65536L;\n+    }\n+    public static int CXCompletionContext_ObjCInstanceMessage() {\n+        return (int)131072L;\n+    }\n+    public static int CXCompletionContext_ObjCClassMessage() {\n+        return (int)262144L;\n+    }\n+    public static int CXCompletionContext_ObjCSelectorName() {\n+        return (int)524288L;\n+    }\n+    public static int CXCompletionContext_MacroName() {\n+        return (int)1048576L;\n+    }\n+    public static int CXCompletionContext_NaturalLanguage() {\n+        return (int)2097152L;\n+    }\n+    public static int CXCompletionContext_IncludedFile() {\n+        return (int)4194304L;\n+    }\n+    public static int CXCompletionContext_Unknown() {\n+        return (int)8388607L;\n+    }\n+    public static MethodHandle clang_defaultCodeCompleteOptions$MH() {\n+        return RuntimeHelper.requireNonNull(constants$46.clang_defaultCodeCompleteOptions$MH,\"clang_defaultCodeCompleteOptions\");\n+    }\n+    public static int clang_defaultCodeCompleteOptions () {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$46.clang_defaultCodeCompleteOptions$MH, \"clang_defaultCodeCompleteOptions\");\n+        try {\n+            return (int)mh$.invokeExact();\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_codeCompleteAt$MH() {\n+        return RuntimeHelper.requireNonNull(constants$46.clang_codeCompleteAt$MH,\"clang_codeCompleteAt\");\n+    }\n+    public static MemoryAddress clang_codeCompleteAt ( Addressable TU,  Addressable complete_filename,  int complete_line,  int complete_column,  Addressable unsaved_files,  int num_unsaved_files,  int options) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$46.clang_codeCompleteAt$MH, \"clang_codeCompleteAt\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(TU.address(), complete_filename.address(), complete_line, complete_column, unsaved_files.address(), num_unsaved_files, options);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$46 {\n+\n+        static final FunctionDescriptor clang_getCompletionBriefComment$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getCompletionBriefComment$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCompletionBriefComment\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$46.clang_getCompletionBriefComment$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getCursorCompletionString$FUNC = FunctionDescriptor.of(C_POINTER,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_getCursorCompletionString$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCursorCompletionString\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$46.clang_getCursorCompletionString$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getCompletionNumFixIts$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER,\n+            C_INT\n+        );\n+        static final MethodHandle clang_getCompletionNumFixIts$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCompletionNumFixIts\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;I)I\",\n+            constants$46.clang_getCompletionNumFixIts$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getCompletionFixIt$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            C_POINTER,\n+            C_INT,\n+            C_INT,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getCompletionFixIt$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getCompletionFixIt\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;IILjdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$46.clang_getCompletionFixIt$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_defaultCodeCompleteOptions$FUNC = FunctionDescriptor.of(C_INT);\n+        static final MethodHandle clang_defaultCodeCompleteOptions$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_defaultCodeCompleteOptions\",\n+            \"()I\",\n+            constants$46.clang_defaultCodeCompleteOptions$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_codeCompleteAt$FUNC = FunctionDescriptor.of(C_POINTER,\n+            C_POINTER,\n+            C_POINTER,\n+            C_INT,\n+            C_INT,\n+            C_POINTER,\n+            C_INT,\n+            C_INT\n+        );\n+        static final MethodHandle clang_codeCompleteAt$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_codeCompleteAt\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;IILjdk\/incubator\/foreign\/MemoryAddress;II)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$46.clang_codeCompleteAt$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_sortCodeCompletionResults$MH() {\n+        return RuntimeHelper.requireNonNull(constants$47.clang_sortCodeCompletionResults$MH,\"clang_sortCodeCompletionResults\");\n+    }\n+    public static void clang_sortCodeCompletionResults ( Addressable Results,  int NumResults) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$47.clang_sortCodeCompletionResults$MH, \"clang_sortCodeCompletionResults\");\n+        try {\n+            mh$.invokeExact(Results.address(), NumResults);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_disposeCodeCompleteResults$MH() {\n+        return RuntimeHelper.requireNonNull(constants$47.clang_disposeCodeCompleteResults$MH,\"clang_disposeCodeCompleteResults\");\n+    }\n+    public static void clang_disposeCodeCompleteResults ( Addressable Results) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$47.clang_disposeCodeCompleteResults$MH, \"clang_disposeCodeCompleteResults\");\n+        try {\n+            mh$.invokeExact(Results.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_codeCompleteGetNumDiagnostics$MH() {\n+        return RuntimeHelper.requireNonNull(constants$47.clang_codeCompleteGetNumDiagnostics$MH,\"clang_codeCompleteGetNumDiagnostics\");\n+    }\n+    public static int clang_codeCompleteGetNumDiagnostics ( Addressable Results) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$47.clang_codeCompleteGetNumDiagnostics$MH, \"clang_codeCompleteGetNumDiagnostics\");\n+        try {\n+            return (int)mh$.invokeExact(Results.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_codeCompleteGetDiagnostic$MH() {\n+        return RuntimeHelper.requireNonNull(constants$47.clang_codeCompleteGetDiagnostic$MH,\"clang_codeCompleteGetDiagnostic\");\n+    }\n+    public static MemoryAddress clang_codeCompleteGetDiagnostic ( Addressable Results,  int Index) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$47.clang_codeCompleteGetDiagnostic$MH, \"clang_codeCompleteGetDiagnostic\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(Results.address(), Index);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_codeCompleteGetContexts$MH() {\n+        return RuntimeHelper.requireNonNull(constants$47.clang_codeCompleteGetContexts$MH,\"clang_codeCompleteGetContexts\");\n+    }\n+    public static long clang_codeCompleteGetContexts ( Addressable Results) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$47.clang_codeCompleteGetContexts$MH, \"clang_codeCompleteGetContexts\");\n+        try {\n+            return (long)mh$.invokeExact(Results.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_codeCompleteGetContainerKind$MH() {\n+        return RuntimeHelper.requireNonNull(constants$47.clang_codeCompleteGetContainerKind$MH,\"clang_codeCompleteGetContainerKind\");\n+    }\n+    public static int clang_codeCompleteGetContainerKind ( Addressable Results,  Addressable IsIncomplete) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$47.clang_codeCompleteGetContainerKind$MH, \"clang_codeCompleteGetContainerKind\");\n+        try {\n+            return (int)mh$.invokeExact(Results.address(), IsIncomplete.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$47 {\n+\n+        static final FunctionDescriptor clang_sortCodeCompletionResults$FUNC = FunctionDescriptor.ofVoid(\n+            C_POINTER,\n+            C_INT\n+        );\n+        static final MethodHandle clang_sortCodeCompletionResults$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_sortCodeCompletionResults\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;I)V\",\n+            constants$47.clang_sortCodeCompletionResults$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_disposeCodeCompleteResults$FUNC = FunctionDescriptor.ofVoid(\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_disposeCodeCompleteResults$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_disposeCodeCompleteResults\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)V\",\n+            constants$47.clang_disposeCodeCompleteResults$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_codeCompleteGetNumDiagnostics$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_codeCompleteGetNumDiagnostics$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_codeCompleteGetNumDiagnostics\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+            constants$47.clang_codeCompleteGetNumDiagnostics$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_codeCompleteGetDiagnostic$FUNC = FunctionDescriptor.of(C_POINTER,\n+            C_POINTER,\n+            C_INT\n+        );\n+        static final MethodHandle clang_codeCompleteGetDiagnostic$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_codeCompleteGetDiagnostic\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;I)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$47.clang_codeCompleteGetDiagnostic$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_codeCompleteGetContexts$FUNC = FunctionDescriptor.of(C_LONG_LONG,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_codeCompleteGetContexts$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_codeCompleteGetContexts\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)J\",\n+            constants$47.clang_codeCompleteGetContexts$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_codeCompleteGetContainerKind$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_codeCompleteGetContainerKind$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_codeCompleteGetContainerKind\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+            constants$47.clang_codeCompleteGetContainerKind$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_codeCompleteGetContainerUSR$MH() {\n+        return RuntimeHelper.requireNonNull(constants$48.clang_codeCompleteGetContainerUSR$MH,\"clang_codeCompleteGetContainerUSR\");\n+    }\n+    public static MemorySegment clang_codeCompleteGetContainerUSR ( Addressable Results) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$48.clang_codeCompleteGetContainerUSR$MH, \"clang_codeCompleteGetContainerUSR\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(Results.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_codeCompleteGetObjCSelector$MH() {\n+        return RuntimeHelper.requireNonNull(constants$48.clang_codeCompleteGetObjCSelector$MH,\"clang_codeCompleteGetObjCSelector\");\n+    }\n+    public static MemorySegment clang_codeCompleteGetObjCSelector ( Addressable Results) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$48.clang_codeCompleteGetObjCSelector$MH, \"clang_codeCompleteGetObjCSelector\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(Results.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getClangVersion$MH() {\n+        return RuntimeHelper.requireNonNull(constants$48.clang_getClangVersion$MH,\"clang_getClangVersion\");\n+    }\n+    public static MemorySegment clang_getClangVersion () {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$48.clang_getClangVersion$MH, \"clang_getClangVersion\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact();\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_toggleCrashRecovery$MH() {\n+        return RuntimeHelper.requireNonNull(constants$48.clang_toggleCrashRecovery$MH,\"clang_toggleCrashRecovery\");\n+    }\n+    public static void clang_toggleCrashRecovery ( int isEnabled) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$48.clang_toggleCrashRecovery$MH, \"clang_toggleCrashRecovery\");\n+        try {\n+            mh$.invokeExact(isEnabled);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public interface CXInclusionVisitor {\n+\n+        void apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, int x2, jdk.incubator.foreign.MemoryAddress x3);\n+        static MemorySegment allocate(CXInclusionVisitor fi) {\n+            return RuntimeHelper.upcallStub(CXInclusionVisitor.class, fi, constants$48.CXInclusionVisitor$FUNC, \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;ILjdk\/incubator\/foreign\/MemoryAddress;)V\");\n+        }\n+        static MemorySegment allocate(CXInclusionVisitor fi, NativeScope scope) {\n+            return allocate(fi).handoff(scope);\n+        }\n+    }\n+\n+    public static MethodHandle clang_getInclusions$MH() {\n+        return RuntimeHelper.requireNonNull(constants$48.clang_getInclusions$MH,\"clang_getInclusions\");\n+    }\n+    public static void clang_getInclusions ( Addressable tu,  Addressable visitor,  Addressable client_data) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$48.clang_getInclusions$MH, \"clang_getInclusions\");\n+        try {\n+            mh$.invokeExact(tu.address(), visitor.address(), client_data.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXEval_Int() {\n+        return (int)1L;\n+    }\n+    public static int CXEval_Float() {\n+        return (int)2L;\n+    }\n+    public static int CXEval_ObjCStrLiteral() {\n+        return (int)3L;\n+    }\n+    public static int CXEval_StrLiteral() {\n+        return (int)4L;\n+    }\n+    public static int CXEval_CFStr() {\n+        return (int)5L;\n+    }\n+    public static int CXEval_Other() {\n+        return (int)6L;\n+    }\n+    public static int CXEval_UnExposed() {\n+        return (int)0L;\n+    }\n+    public static class constants$48 {\n+\n+        static final FunctionDescriptor clang_codeCompleteGetContainerUSR$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_codeCompleteGetContainerUSR$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_codeCompleteGetContainerUSR\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$48.clang_codeCompleteGetContainerUSR$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_codeCompleteGetObjCSelector$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_codeCompleteGetObjCSelector$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_codeCompleteGetObjCSelector\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$48.clang_codeCompleteGetObjCSelector$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getClangVersion$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ));\n+        static final MethodHandle clang_getClangVersion$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getClangVersion\",\n+            \"()Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$48.clang_getClangVersion$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_toggleCrashRecovery$FUNC = FunctionDescriptor.ofVoid(\n+            C_INT\n+        );\n+        static final MethodHandle clang_toggleCrashRecovery$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_toggleCrashRecovery\",\n+            \"(I)V\",\n+            constants$48.clang_toggleCrashRecovery$FUNC, false\n+        );\n+        static final FunctionDescriptor CXInclusionVisitor$FUNC = FunctionDescriptor.ofVoid(\n+            C_POINTER,\n+            C_POINTER,\n+            C_INT,\n+            C_POINTER\n+        );\n+        static final FunctionDescriptor clang_getInclusions$FUNC = FunctionDescriptor.ofVoid(\n+            C_POINTER,\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getInclusions$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getInclusions\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)V\",\n+            constants$48.clang_getInclusions$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_Cursor_Evaluate$MH() {\n+        return RuntimeHelper.requireNonNull(constants$49.clang_Cursor_Evaluate$MH,\"clang_Cursor_Evaluate\");\n+    }\n+    public static MemoryAddress clang_Cursor_Evaluate ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$49.clang_Cursor_Evaluate$MH, \"clang_Cursor_Evaluate\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_EvalResult_getKind$MH() {\n+        return RuntimeHelper.requireNonNull(constants$49.clang_EvalResult_getKind$MH,\"clang_EvalResult_getKind\");\n+    }\n+    public static int clang_EvalResult_getKind ( Addressable E) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$49.clang_EvalResult_getKind$MH, \"clang_EvalResult_getKind\");\n+        try {\n+            return (int)mh$.invokeExact(E.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_EvalResult_getAsInt$MH() {\n+        return RuntimeHelper.requireNonNull(constants$49.clang_EvalResult_getAsInt$MH,\"clang_EvalResult_getAsInt\");\n+    }\n+    public static int clang_EvalResult_getAsInt ( Addressable E) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$49.clang_EvalResult_getAsInt$MH, \"clang_EvalResult_getAsInt\");\n+        try {\n+            return (int)mh$.invokeExact(E.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_EvalResult_getAsLongLong$MH() {\n+        return RuntimeHelper.requireNonNull(constants$49.clang_EvalResult_getAsLongLong$MH,\"clang_EvalResult_getAsLongLong\");\n+    }\n+    public static long clang_EvalResult_getAsLongLong ( Addressable E) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$49.clang_EvalResult_getAsLongLong$MH, \"clang_EvalResult_getAsLongLong\");\n+        try {\n+            return (long)mh$.invokeExact(E.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_EvalResult_isUnsignedInt$MH() {\n+        return RuntimeHelper.requireNonNull(constants$49.clang_EvalResult_isUnsignedInt$MH,\"clang_EvalResult_isUnsignedInt\");\n+    }\n+    public static int clang_EvalResult_isUnsignedInt ( Addressable E) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$49.clang_EvalResult_isUnsignedInt$MH, \"clang_EvalResult_isUnsignedInt\");\n+        try {\n+            return (int)mh$.invokeExact(E.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_EvalResult_getAsUnsigned$MH() {\n+        return RuntimeHelper.requireNonNull(constants$49.clang_EvalResult_getAsUnsigned$MH,\"clang_EvalResult_getAsUnsigned\");\n+    }\n+    public static long clang_EvalResult_getAsUnsigned ( Addressable E) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$49.clang_EvalResult_getAsUnsigned$MH, \"clang_EvalResult_getAsUnsigned\");\n+        try {\n+            return (long)mh$.invokeExact(E.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$49 {\n+\n+        static final FunctionDescriptor clang_Cursor_Evaluate$FUNC = FunctionDescriptor.of(C_POINTER,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            )\n+        );\n+        static final MethodHandle clang_Cursor_Evaluate$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Cursor_Evaluate\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$49.clang_Cursor_Evaluate$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_EvalResult_getKind$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_EvalResult_getKind$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_EvalResult_getKind\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+            constants$49.clang_EvalResult_getKind$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_EvalResult_getAsInt$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_EvalResult_getAsInt$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_EvalResult_getAsInt\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+            constants$49.clang_EvalResult_getAsInt$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_EvalResult_getAsLongLong$FUNC = FunctionDescriptor.of(C_LONG_LONG,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_EvalResult_getAsLongLong$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_EvalResult_getAsLongLong\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)J\",\n+            constants$49.clang_EvalResult_getAsLongLong$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_EvalResult_isUnsignedInt$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_EvalResult_isUnsignedInt$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_EvalResult_isUnsignedInt\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+            constants$49.clang_EvalResult_isUnsignedInt$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_EvalResult_getAsUnsigned$FUNC = FunctionDescriptor.of(C_LONG_LONG,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_EvalResult_getAsUnsigned$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_EvalResult_getAsUnsigned\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)J\",\n+            constants$49.clang_EvalResult_getAsUnsigned$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_EvalResult_getAsDouble$MH() {\n+        return RuntimeHelper.requireNonNull(constants$50.clang_EvalResult_getAsDouble$MH,\"clang_EvalResult_getAsDouble\");\n+    }\n+    public static double clang_EvalResult_getAsDouble ( Addressable E) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$50.clang_EvalResult_getAsDouble$MH, \"clang_EvalResult_getAsDouble\");\n+        try {\n+            return (double)mh$.invokeExact(E.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_EvalResult_getAsStr$MH() {\n+        return RuntimeHelper.requireNonNull(constants$50.clang_EvalResult_getAsStr$MH,\"clang_EvalResult_getAsStr\");\n+    }\n+    public static MemoryAddress clang_EvalResult_getAsStr ( Addressable E) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$50.clang_EvalResult_getAsStr$MH, \"clang_EvalResult_getAsStr\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(E.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_EvalResult_dispose$MH() {\n+        return RuntimeHelper.requireNonNull(constants$50.clang_EvalResult_dispose$MH,\"clang_EvalResult_dispose\");\n+    }\n+    public static void clang_EvalResult_dispose ( Addressable E) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$50.clang_EvalResult_dispose$MH, \"clang_EvalResult_dispose\");\n+        try {\n+            mh$.invokeExact(E.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getRemappings$MH() {\n+        return RuntimeHelper.requireNonNull(constants$50.clang_getRemappings$MH,\"clang_getRemappings\");\n+    }\n+    public static MemoryAddress clang_getRemappings ( Addressable path) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$50.clang_getRemappings$MH, \"clang_getRemappings\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(path.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getRemappingsFromFileList$MH() {\n+        return RuntimeHelper.requireNonNull(constants$50.clang_getRemappingsFromFileList$MH,\"clang_getRemappingsFromFileList\");\n+    }\n+    public static MemoryAddress clang_getRemappingsFromFileList ( Addressable filePaths,  int numFiles) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$50.clang_getRemappingsFromFileList$MH, \"clang_getRemappingsFromFileList\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(filePaths.address(), numFiles);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_remap_getNumFiles$MH() {\n+        return RuntimeHelper.requireNonNull(constants$50.clang_remap_getNumFiles$MH,\"clang_remap_getNumFiles\");\n+    }\n+    public static int clang_remap_getNumFiles ( Addressable x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$50.clang_remap_getNumFiles$MH, \"clang_remap_getNumFiles\");\n+        try {\n+            return (int)mh$.invokeExact(x0.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$50 {\n+\n+        static final FunctionDescriptor clang_EvalResult_getAsDouble$FUNC = FunctionDescriptor.of(C_DOUBLE,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_EvalResult_getAsDouble$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_EvalResult_getAsDouble\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)D\",\n+            constants$50.clang_EvalResult_getAsDouble$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_EvalResult_getAsStr$FUNC = FunctionDescriptor.of(C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_EvalResult_getAsStr$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_EvalResult_getAsStr\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$50.clang_EvalResult_getAsStr$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_EvalResult_dispose$FUNC = FunctionDescriptor.ofVoid(\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_EvalResult_dispose$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_EvalResult_dispose\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)V\",\n+            constants$50.clang_EvalResult_dispose$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getRemappings$FUNC = FunctionDescriptor.of(C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_getRemappings$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getRemappings\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$50.clang_getRemappings$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_getRemappingsFromFileList$FUNC = FunctionDescriptor.of(C_POINTER,\n+            C_POINTER,\n+            C_INT\n+        );\n+        static final MethodHandle clang_getRemappingsFromFileList$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_getRemappingsFromFileList\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;I)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$50.clang_getRemappingsFromFileList$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_remap_getNumFiles$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_remap_getNumFiles$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_remap_getNumFiles\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+            constants$50.clang_remap_getNumFiles$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_remap_getFilenames$MH() {\n+        return RuntimeHelper.requireNonNull(constants$51.clang_remap_getFilenames$MH,\"clang_remap_getFilenames\");\n+    }\n+    public static void clang_remap_getFilenames ( Addressable x0,  int index,  Addressable original,  Addressable transformed) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$51.clang_remap_getFilenames$MH, \"clang_remap_getFilenames\");\n+        try {\n+            mh$.invokeExact(x0.address(), index, original.address(), transformed.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_remap_dispose$MH() {\n+        return RuntimeHelper.requireNonNull(constants$51.clang_remap_dispose$MH,\"clang_remap_dispose\");\n+    }\n+    public static void clang_remap_dispose ( Addressable x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$51.clang_remap_dispose$MH, \"clang_remap_dispose\");\n+        try {\n+            mh$.invokeExact(x0.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXVisit_Break() {\n+        return (int)0L;\n+    }\n+    public static int CXVisit_Continue() {\n+        return (int)1L;\n+    }\n+    public static class CXCursorAndRangeVisitor {\n+\n+        static final MemoryLayout CXCursorAndRangeVisitor$struct$LAYOUT = MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"context\"),\n+            C_POINTER.withName(\"visit\")\n+        ).withName(\"CXCursorAndRangeVisitor\");\n+        public static MemoryLayout $LAYOUT() {\n+            return CXCursorAndRangeVisitor.CXCursorAndRangeVisitor$struct$LAYOUT;\n+        }\n+        static final VarHandle context$VH = MemoryHandles.asAddressVarHandle(CXCursorAndRangeVisitor$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"context\")));\n+        public static VarHandle context$VH() {\n+            return CXCursorAndRangeVisitor.context$VH;\n+        }\n+        public static MemoryAddress context$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXCursorAndRangeVisitor.context$VH.get(seg);\n+        }\n+        public static void context$set( MemorySegment seg, MemoryAddress x) {\n+            CXCursorAndRangeVisitor.context$VH.set(seg, x);\n+        }\n+        public static MemoryAddress context$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXCursorAndRangeVisitor.context$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void context$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXCursorAndRangeVisitor.context$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public interface visit {\n+\n+            int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemorySegment x1, jdk.incubator.foreign.MemorySegment x2);\n+            static MemorySegment allocate(visit fi) {\n+                return RuntimeHelper.upcallStub(visit.class, fi, constants$51.visit$FUNC, \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemorySegment;)I\");\n+            }\n+            static MemorySegment allocate(visit fi, NativeScope scope) {\n+                return allocate(fi).handoff(scope);\n+            }\n+        }\n+\n+        static final VarHandle visit$VH = MemoryHandles.asAddressVarHandle(CXCursorAndRangeVisitor$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"visit\")));\n+        public static VarHandle visit$VH() {\n+            return CXCursorAndRangeVisitor.visit$VH;\n+        }\n+        public static MemoryAddress visit$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXCursorAndRangeVisitor.visit$VH.get(seg);\n+        }\n+        public static void visit$set( MemorySegment seg, MemoryAddress x) {\n+            CXCursorAndRangeVisitor.visit$VH.set(seg, x);\n+        }\n+        public static MemoryAddress visit$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXCursorAndRangeVisitor.visit$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void visit$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXCursorAndRangeVisitor.visit$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public static long sizeof() { return $LAYOUT().byteSize(); }\n+        public static MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\n+        public static MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n+        public static MemorySegment allocateArray(int len) {\n+            return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }        public static MemorySegment allocateArray(int len, NativeScope scope) {\n+            return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }\n+        public static MemorySegment allocatePointer() {\n+            return MemorySegment.allocateNative(C_POINTER);\n+        }\n+        public static MemorySegment allocatePointer(NativeScope scope) {\n+            return scope.allocate(C_POINTER);\n+        }\n+        public static MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\n+    }\n+\n+    public static int CXResult_Success() {\n+        return (int)0L;\n+    }\n+    public static int CXResult_Invalid() {\n+        return (int)1L;\n+    }\n+    public static int CXResult_VisitBreak() {\n+        return (int)2L;\n+    }\n+    public static MethodHandle clang_findReferencesInFile$MH() {\n+        return RuntimeHelper.requireNonNull(constants$51.clang_findReferencesInFile$MH,\"clang_findReferencesInFile\");\n+    }\n+    public static int clang_findReferencesInFile ( MemorySegment cursor,  Addressable file,  MemorySegment visitor) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$51.clang_findReferencesInFile$MH, \"clang_findReferencesInFile\");\n+        try {\n+            return (int)mh$.invokeExact(cursor, file.address(), visitor);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_findIncludesInFile$MH() {\n+        return RuntimeHelper.requireNonNull(constants$51.clang_findIncludesInFile$MH,\"clang_findIncludesInFile\");\n+    }\n+    public static int clang_findIncludesInFile ( Addressable TU,  Addressable file,  MemorySegment visitor) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$51.clang_findIncludesInFile$MH, \"clang_findIncludesInFile\");\n+        try {\n+            return (int)mh$.invokeExact(TU.address(), file.address(), visitor);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public interface CXCursorAndRangeVisitorBlock {\n+\n+        int apply(jdk.incubator.foreign.MemorySegment x0, jdk.incubator.foreign.MemorySegment x1);\n+        static MemorySegment allocate(CXCursorAndRangeVisitorBlock fi) {\n+            return RuntimeHelper.upcallStub(CXCursorAndRangeVisitorBlock.class, fi, constants$51.CXCursorAndRangeVisitorBlock$FUNC, \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemorySegment;)I\");\n+        }\n+        static MemorySegment allocate(CXCursorAndRangeVisitorBlock fi, NativeScope scope) {\n+            return allocate(fi).handoff(scope);\n+        }\n+    }\n+\n+    public static class constants$51 {\n+\n+        static final FunctionDescriptor clang_remap_getFilenames$FUNC = FunctionDescriptor.ofVoid(\n+            C_POINTER,\n+            C_INT,\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_remap_getFilenames$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_remap_getFilenames\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;ILjdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)V\",\n+            constants$51.clang_remap_getFilenames$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_remap_dispose$FUNC = FunctionDescriptor.ofVoid(\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_remap_dispose$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_remap_dispose\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)V\",\n+            constants$51.clang_remap_dispose$FUNC, false\n+        );\n+        static final FunctionDescriptor visit$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            ),\n+            MemoryLayout.ofStruct(\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+                C_INT.withName(\"begin_int_data\"),\n+                C_INT.withName(\"end_int_data\")\n+            )\n+        );\n+        static final FunctionDescriptor clang_findReferencesInFile$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            ),\n+            C_POINTER,\n+            MemoryLayout.ofStruct(\n+                C_POINTER.withName(\"context\"),\n+                C_POINTER.withName(\"visit\")\n+            ).withName(\"CXCursorAndRangeVisitor\")\n+        );\n+        static final MethodHandle clang_findReferencesInFile$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_findReferencesInFile\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$51.clang_findReferencesInFile$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_findIncludesInFile$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER,\n+            C_POINTER,\n+            MemoryLayout.ofStruct(\n+                C_POINTER.withName(\"context\"),\n+                C_POINTER.withName(\"visit\")\n+            ).withName(\"CXCursorAndRangeVisitor\")\n+        );\n+        static final MethodHandle clang_findIncludesInFile$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_findIncludesInFile\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+            constants$51.clang_findIncludesInFile$FUNC, false\n+        );\n+        static final FunctionDescriptor CXCursorAndRangeVisitorBlock$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            ),\n+            MemoryLayout.ofStruct(\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+                C_INT.withName(\"begin_int_data\"),\n+                C_INT.withName(\"end_int_data\")\n+            )\n+        );\n+    }\n+\n+    public static MethodHandle clang_findReferencesInFileWithBlock$MH() {\n+        return RuntimeHelper.requireNonNull(constants$52.clang_findReferencesInFileWithBlock$MH,\"clang_findReferencesInFileWithBlock\");\n+    }\n+    public static int clang_findReferencesInFileWithBlock ( MemorySegment x0,  Addressable x1,  Addressable x2) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$52.clang_findReferencesInFileWithBlock$MH, \"clang_findReferencesInFileWithBlock\");\n+        try {\n+            return (int)mh$.invokeExact(x0, x1.address(), x2.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_findIncludesInFileWithBlock$MH() {\n+        return RuntimeHelper.requireNonNull(constants$52.clang_findIncludesInFileWithBlock$MH,\"clang_findIncludesInFileWithBlock\");\n+    }\n+    public static int clang_findIncludesInFileWithBlock ( Addressable x0,  Addressable x1,  Addressable x2) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$52.clang_findIncludesInFileWithBlock$MH, \"clang_findIncludesInFileWithBlock\");\n+        try {\n+            return (int)mh$.invokeExact(x0.address(), x1.address(), x2.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class CXIdxLoc {\n+\n+        static final MemoryLayout CXIdxLoc$struct$LAYOUT = MemoryLayout.ofStruct(\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+            C_INT.withName(\"int_data\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        );\n+        public static MemoryLayout $LAYOUT() {\n+            return CXIdxLoc.CXIdxLoc$struct$LAYOUT;\n+        }\n+        public static MemorySegment ptr_data$slice(MemorySegment seg) {\n+            return RuntimeHelper.nonCloseableNonTransferableSegment(seg.asSlice(0, 16));\n+        }\n+        static final VarHandle int_data$VH = CXIdxLoc$struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"int_data\"));\n+        public static VarHandle int_data$VH() {\n+            return CXIdxLoc.int_data$VH;\n+        }\n+        public static int int_data$get(MemorySegment seg) {\n+            return (int)CXIdxLoc.int_data$VH.get(seg);\n+        }\n+        public static void int_data$set( MemorySegment seg, int x) {\n+            CXIdxLoc.int_data$VH.set(seg, x);\n+        }\n+        public static int int_data$get(MemorySegment seg, long index) {\n+            return (int)CXIdxLoc.int_data$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void int_data$set(MemorySegment seg, long index, int x) {\n+            CXIdxLoc.int_data$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public static long sizeof() { return $LAYOUT().byteSize(); }\n+        public static MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\n+        public static MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n+        public static MemorySegment allocateArray(int len) {\n+            return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }        public static MemorySegment allocateArray(int len, NativeScope scope) {\n+            return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }\n+        public static MemorySegment allocatePointer() {\n+            return MemorySegment.allocateNative(C_POINTER);\n+        }\n+        public static MemorySegment allocatePointer(NativeScope scope) {\n+            return scope.allocate(C_POINTER);\n+        }\n+        public static MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\n+    }\n+\n+    public static class CXIdxIncludedFileInfo {\n+\n+        static final MemoryLayout CXIdxIncludedFileInfo$struct$LAYOUT = MemoryLayout.ofStruct(\n+            MemoryLayout.ofStruct(\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+                C_INT.withName(\"int_data\"),\n+                MemoryLayout.ofPaddingBits(32)\n+            ).withName(\"hashLoc\"),\n+            C_POINTER.withName(\"filename\"),\n+            C_POINTER.withName(\"file\"),\n+            C_INT.withName(\"isImport\"),\n+            C_INT.withName(\"isAngled\"),\n+            C_INT.withName(\"isModuleImport\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        );\n+        public static MemoryLayout $LAYOUT() {\n+            return CXIdxIncludedFileInfo.CXIdxIncludedFileInfo$struct$LAYOUT;\n+        }\n+        public static MemorySegment hashLoc$slice(MemorySegment seg) {\n+            return RuntimeHelper.nonCloseableNonTransferableSegment(seg.asSlice(0, 24));\n+        }\n+        static final VarHandle filename$VH = MemoryHandles.asAddressVarHandle(CXIdxIncludedFileInfo$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"filename\")));\n+        public static VarHandle filename$VH() {\n+            return CXIdxIncludedFileInfo.filename$VH;\n+        }\n+        public static MemoryAddress filename$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxIncludedFileInfo.filename$VH.get(seg);\n+        }\n+        public static void filename$set( MemorySegment seg, MemoryAddress x) {\n+            CXIdxIncludedFileInfo.filename$VH.set(seg, x);\n+        }\n+        public static MemoryAddress filename$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxIncludedFileInfo.filename$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void filename$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXIdxIncludedFileInfo.filename$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle file$VH = MemoryHandles.asAddressVarHandle(CXIdxIncludedFileInfo$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"file\")));\n+        public static VarHandle file$VH() {\n+            return CXIdxIncludedFileInfo.file$VH;\n+        }\n+        public static MemoryAddress file$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxIncludedFileInfo.file$VH.get(seg);\n+        }\n+        public static void file$set( MemorySegment seg, MemoryAddress x) {\n+            CXIdxIncludedFileInfo.file$VH.set(seg, x);\n+        }\n+        public static MemoryAddress file$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxIncludedFileInfo.file$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void file$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXIdxIncludedFileInfo.file$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle isImport$VH = CXIdxIncludedFileInfo$struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"isImport\"));\n+        public static VarHandle isImport$VH() {\n+            return CXIdxIncludedFileInfo.isImport$VH;\n+        }\n+        public static int isImport$get(MemorySegment seg) {\n+            return (int)CXIdxIncludedFileInfo.isImport$VH.get(seg);\n+        }\n+        public static void isImport$set( MemorySegment seg, int x) {\n+            CXIdxIncludedFileInfo.isImport$VH.set(seg, x);\n+        }\n+        public static int isImport$get(MemorySegment seg, long index) {\n+            return (int)CXIdxIncludedFileInfo.isImport$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void isImport$set(MemorySegment seg, long index, int x) {\n+            CXIdxIncludedFileInfo.isImport$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle isAngled$VH = CXIdxIncludedFileInfo$struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"isAngled\"));\n+        public static VarHandle isAngled$VH() {\n+            return CXIdxIncludedFileInfo.isAngled$VH;\n+        }\n+        public static int isAngled$get(MemorySegment seg) {\n+            return (int)CXIdxIncludedFileInfo.isAngled$VH.get(seg);\n+        }\n+        public static void isAngled$set( MemorySegment seg, int x) {\n+            CXIdxIncludedFileInfo.isAngled$VH.set(seg, x);\n+        }\n+        public static int isAngled$get(MemorySegment seg, long index) {\n+            return (int)CXIdxIncludedFileInfo.isAngled$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void isAngled$set(MemorySegment seg, long index, int x) {\n+            CXIdxIncludedFileInfo.isAngled$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle isModuleImport$VH = CXIdxIncludedFileInfo$struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"isModuleImport\"));\n+        public static VarHandle isModuleImport$VH() {\n+            return CXIdxIncludedFileInfo.isModuleImport$VH;\n+        }\n+        public static int isModuleImport$get(MemorySegment seg) {\n+            return (int)CXIdxIncludedFileInfo.isModuleImport$VH.get(seg);\n+        }\n+        public static void isModuleImport$set( MemorySegment seg, int x) {\n+            CXIdxIncludedFileInfo.isModuleImport$VH.set(seg, x);\n+        }\n+        public static int isModuleImport$get(MemorySegment seg, long index) {\n+            return (int)CXIdxIncludedFileInfo.isModuleImport$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void isModuleImport$set(MemorySegment seg, long index, int x) {\n+            CXIdxIncludedFileInfo.isModuleImport$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public static long sizeof() { return $LAYOUT().byteSize(); }\n+        public static MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\n+        public static MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n+        public static MemorySegment allocateArray(int len) {\n+            return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }        public static MemorySegment allocateArray(int len, NativeScope scope) {\n+            return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }\n+        public static MemorySegment allocatePointer() {\n+            return MemorySegment.allocateNative(C_POINTER);\n+        }\n+        public static MemorySegment allocatePointer(NativeScope scope) {\n+            return scope.allocate(C_POINTER);\n+        }\n+        public static MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\n+    }\n+\n+    public static class CXIdxImportedASTFileInfo {\n+\n+        static final MemoryLayout CXIdxImportedASTFileInfo$struct$LAYOUT = MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"file\"),\n+            C_POINTER.withName(\"module\"),\n+            MemoryLayout.ofStruct(\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+                C_INT.withName(\"int_data\"),\n+                MemoryLayout.ofPaddingBits(32)\n+            ).withName(\"loc\"),\n+            C_INT.withName(\"isImplicit\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        );\n+        public static MemoryLayout $LAYOUT() {\n+            return CXIdxImportedASTFileInfo.CXIdxImportedASTFileInfo$struct$LAYOUT;\n+        }\n+        static final VarHandle file$VH = MemoryHandles.asAddressVarHandle(CXIdxImportedASTFileInfo$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"file\")));\n+        public static VarHandle file$VH() {\n+            return CXIdxImportedASTFileInfo.file$VH;\n+        }\n+        public static MemoryAddress file$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxImportedASTFileInfo.file$VH.get(seg);\n+        }\n+        public static void file$set( MemorySegment seg, MemoryAddress x) {\n+            CXIdxImportedASTFileInfo.file$VH.set(seg, x);\n+        }\n+        public static MemoryAddress file$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxImportedASTFileInfo.file$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void file$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXIdxImportedASTFileInfo.file$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle module$VH = MemoryHandles.asAddressVarHandle(CXIdxImportedASTFileInfo$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"module\")));\n+        public static VarHandle module$VH() {\n+            return CXIdxImportedASTFileInfo.module$VH;\n+        }\n+        public static MemoryAddress module$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxImportedASTFileInfo.module$VH.get(seg);\n+        }\n+        public static void module$set( MemorySegment seg, MemoryAddress x) {\n+            CXIdxImportedASTFileInfo.module$VH.set(seg, x);\n+        }\n+        public static MemoryAddress module$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxImportedASTFileInfo.module$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void module$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXIdxImportedASTFileInfo.module$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public static MemorySegment loc$slice(MemorySegment seg) {\n+            return RuntimeHelper.nonCloseableNonTransferableSegment(seg.asSlice(16, 24));\n+        }\n+        static final VarHandle isImplicit$VH = CXIdxImportedASTFileInfo$struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"isImplicit\"));\n+        public static VarHandle isImplicit$VH() {\n+            return CXIdxImportedASTFileInfo.isImplicit$VH;\n+        }\n+        public static int isImplicit$get(MemorySegment seg) {\n+            return (int)CXIdxImportedASTFileInfo.isImplicit$VH.get(seg);\n+        }\n+        public static void isImplicit$set( MemorySegment seg, int x) {\n+            CXIdxImportedASTFileInfo.isImplicit$VH.set(seg, x);\n+        }\n+        public static int isImplicit$get(MemorySegment seg, long index) {\n+            return (int)CXIdxImportedASTFileInfo.isImplicit$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void isImplicit$set(MemorySegment seg, long index, int x) {\n+            CXIdxImportedASTFileInfo.isImplicit$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public static long sizeof() { return $LAYOUT().byteSize(); }\n+        public static MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\n+        public static MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n+        public static MemorySegment allocateArray(int len) {\n+            return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }        public static MemorySegment allocateArray(int len, NativeScope scope) {\n+            return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }\n+        public static MemorySegment allocatePointer() {\n+            return MemorySegment.allocateNative(C_POINTER);\n+        }\n+        public static MemorySegment allocatePointer(NativeScope scope) {\n+            return scope.allocate(C_POINTER);\n+        }\n+        public static MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\n+    }\n+\n+    public static int CXIdxEntity_Unexposed() {\n+        return (int)0L;\n+    }\n+    public static int CXIdxEntity_Typedef() {\n+        return (int)1L;\n+    }\n+    public static int CXIdxEntity_Function() {\n+        return (int)2L;\n+    }\n+    public static int CXIdxEntity_Variable() {\n+        return (int)3L;\n+    }\n+    public static int CXIdxEntity_Field() {\n+        return (int)4L;\n+    }\n+    public static int CXIdxEntity_EnumConstant() {\n+        return (int)5L;\n+    }\n+    public static int CXIdxEntity_ObjCClass() {\n+        return (int)6L;\n+    }\n+    public static int CXIdxEntity_ObjCProtocol() {\n+        return (int)7L;\n+    }\n+    public static int CXIdxEntity_ObjCCategory() {\n+        return (int)8L;\n+    }\n+    public static int CXIdxEntity_ObjCInstanceMethod() {\n+        return (int)9L;\n+    }\n+    public static int CXIdxEntity_ObjCClassMethod() {\n+        return (int)10L;\n+    }\n+    public static int CXIdxEntity_ObjCProperty() {\n+        return (int)11L;\n+    }\n+    public static int CXIdxEntity_ObjCIvar() {\n+        return (int)12L;\n+    }\n+    public static int CXIdxEntity_Enum() {\n+        return (int)13L;\n+    }\n+    public static int CXIdxEntity_Struct() {\n+        return (int)14L;\n+    }\n+    public static int CXIdxEntity_Union() {\n+        return (int)15L;\n+    }\n+    public static int CXIdxEntity_CXXClass() {\n+        return (int)16L;\n+    }\n+    public static int CXIdxEntity_CXXNamespace() {\n+        return (int)17L;\n+    }\n+    public static int CXIdxEntity_CXXNamespaceAlias() {\n+        return (int)18L;\n+    }\n+    public static int CXIdxEntity_CXXStaticVariable() {\n+        return (int)19L;\n+    }\n+    public static int CXIdxEntity_CXXStaticMethod() {\n+        return (int)20L;\n+    }\n+    public static int CXIdxEntity_CXXInstanceMethod() {\n+        return (int)21L;\n+    }\n+    public static int CXIdxEntity_CXXConstructor() {\n+        return (int)22L;\n+    }\n+    public static int CXIdxEntity_CXXDestructor() {\n+        return (int)23L;\n+    }\n+    public static int CXIdxEntity_CXXConversionFunction() {\n+        return (int)24L;\n+    }\n+    public static int CXIdxEntity_CXXTypeAlias() {\n+        return (int)25L;\n+    }\n+    public static int CXIdxEntity_CXXInterface() {\n+        return (int)26L;\n+    }\n+    public static int CXIdxEntityLang_None() {\n+        return (int)0L;\n+    }\n+    public static int CXIdxEntityLang_C() {\n+        return (int)1L;\n+    }\n+    public static int CXIdxEntityLang_ObjC() {\n+        return (int)2L;\n+    }\n+    public static int CXIdxEntityLang_CXX() {\n+        return (int)3L;\n+    }\n+    public static int CXIdxEntityLang_Swift() {\n+        return (int)4L;\n+    }\n+    public static int CXIdxEntity_NonTemplate() {\n+        return (int)0L;\n+    }\n+    public static int CXIdxEntity_Template() {\n+        return (int)1L;\n+    }\n+    public static int CXIdxEntity_TemplatePartialSpecialization() {\n+        return (int)2L;\n+    }\n+    public static class CXIdxAttrInfo {\n+\n+        static final MemoryLayout CXIdxAttrInfo$struct$LAYOUT = MemoryLayout.ofStruct(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.ofPaddingBits(32),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            ).withName(\"cursor\"),\n+            MemoryLayout.ofStruct(\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+                C_INT.withName(\"int_data\"),\n+                MemoryLayout.ofPaddingBits(32)\n+            ).withName(\"loc\")\n+        );\n+        public static MemoryLayout $LAYOUT() {\n+            return CXIdxAttrInfo.CXIdxAttrInfo$struct$LAYOUT;\n+        }\n+        static final VarHandle kind$VH = CXIdxAttrInfo$struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"kind\"));\n+        public static VarHandle kind$VH() {\n+            return CXIdxAttrInfo.kind$VH;\n+        }\n+        public static int kind$get(MemorySegment seg) {\n+            return (int)CXIdxAttrInfo.kind$VH.get(seg);\n+        }\n+        public static void kind$set( MemorySegment seg, int x) {\n+            CXIdxAttrInfo.kind$VH.set(seg, x);\n+        }\n+        public static int kind$get(MemorySegment seg, long index) {\n+            return (int)CXIdxAttrInfo.kind$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void kind$set(MemorySegment seg, long index, int x) {\n+            CXIdxAttrInfo.kind$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public static MemorySegment cursor$slice(MemorySegment seg) {\n+            return RuntimeHelper.nonCloseableNonTransferableSegment(seg.asSlice(8, 32));\n+        }\n+        public static MemorySegment loc$slice(MemorySegment seg) {\n+            return RuntimeHelper.nonCloseableNonTransferableSegment(seg.asSlice(40, 24));\n+        }\n+        public static long sizeof() { return $LAYOUT().byteSize(); }\n+        public static MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\n+        public static MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n+        public static MemorySegment allocateArray(int len) {\n+            return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }        public static MemorySegment allocateArray(int len, NativeScope scope) {\n+            return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }\n+        public static MemorySegment allocatePointer() {\n+            return MemorySegment.allocateNative(C_POINTER);\n+        }\n+        public static MemorySegment allocatePointer(NativeScope scope) {\n+            return scope.allocate(C_POINTER);\n+        }\n+        public static MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\n+    }\n+\n+    public static class CXIdxEntityInfo {\n+\n+        static final MemoryLayout CXIdxEntityInfo$struct$LAYOUT = MemoryLayout.ofStruct(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"templateKind\"),\n+            C_INT.withName(\"lang\"),\n+            MemoryLayout.ofPaddingBits(32),\n+            C_POINTER.withName(\"name\"),\n+            C_POINTER.withName(\"USR\"),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            ).withName(\"cursor\"),\n+            C_POINTER.withName(\"attributes\"),\n+            C_INT.withName(\"numAttributes\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        );\n+        public static MemoryLayout $LAYOUT() {\n+            return CXIdxEntityInfo.CXIdxEntityInfo$struct$LAYOUT;\n+        }\n+        static final VarHandle kind$VH = CXIdxEntityInfo$struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"kind\"));\n+        public static VarHandle kind$VH() {\n+            return CXIdxEntityInfo.kind$VH;\n+        }\n+        public static int kind$get(MemorySegment seg) {\n+            return (int)CXIdxEntityInfo.kind$VH.get(seg);\n+        }\n+        public static void kind$set( MemorySegment seg, int x) {\n+            CXIdxEntityInfo.kind$VH.set(seg, x);\n+        }\n+        public static int kind$get(MemorySegment seg, long index) {\n+            return (int)CXIdxEntityInfo.kind$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void kind$set(MemorySegment seg, long index, int x) {\n+            CXIdxEntityInfo.kind$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle templateKind$VH = CXIdxEntityInfo$struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"templateKind\"));\n+        public static VarHandle templateKind$VH() {\n+            return CXIdxEntityInfo.templateKind$VH;\n+        }\n+        public static int templateKind$get(MemorySegment seg) {\n+            return (int)CXIdxEntityInfo.templateKind$VH.get(seg);\n+        }\n+        public static void templateKind$set( MemorySegment seg, int x) {\n+            CXIdxEntityInfo.templateKind$VH.set(seg, x);\n+        }\n+        public static int templateKind$get(MemorySegment seg, long index) {\n+            return (int)CXIdxEntityInfo.templateKind$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void templateKind$set(MemorySegment seg, long index, int x) {\n+            CXIdxEntityInfo.templateKind$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle lang$VH = CXIdxEntityInfo$struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"lang\"));\n+        public static VarHandle lang$VH() {\n+            return CXIdxEntityInfo.lang$VH;\n+        }\n+        public static int lang$get(MemorySegment seg) {\n+            return (int)CXIdxEntityInfo.lang$VH.get(seg);\n+        }\n+        public static void lang$set( MemorySegment seg, int x) {\n+            CXIdxEntityInfo.lang$VH.set(seg, x);\n+        }\n+        public static int lang$get(MemorySegment seg, long index) {\n+            return (int)CXIdxEntityInfo.lang$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void lang$set(MemorySegment seg, long index, int x) {\n+            CXIdxEntityInfo.lang$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle name$VH = MemoryHandles.asAddressVarHandle(CXIdxEntityInfo$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"name\")));\n+        public static VarHandle name$VH() {\n+            return CXIdxEntityInfo.name$VH;\n+        }\n+        public static MemoryAddress name$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxEntityInfo.name$VH.get(seg);\n+        }\n+        public static void name$set( MemorySegment seg, MemoryAddress x) {\n+            CXIdxEntityInfo.name$VH.set(seg, x);\n+        }\n+        public static MemoryAddress name$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxEntityInfo.name$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void name$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXIdxEntityInfo.name$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle USR$VH = MemoryHandles.asAddressVarHandle(CXIdxEntityInfo$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"USR\")));\n+        public static VarHandle USR$VH() {\n+            return CXIdxEntityInfo.USR$VH;\n+        }\n+        public static MemoryAddress USR$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxEntityInfo.USR$VH.get(seg);\n+        }\n+        public static void USR$set( MemorySegment seg, MemoryAddress x) {\n+            CXIdxEntityInfo.USR$VH.set(seg, x);\n+        }\n+        public static MemoryAddress USR$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxEntityInfo.USR$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void USR$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXIdxEntityInfo.USR$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public static MemorySegment cursor$slice(MemorySegment seg) {\n+            return RuntimeHelper.nonCloseableNonTransferableSegment(seg.asSlice(32, 32));\n+        }\n+        static final VarHandle attributes$VH = MemoryHandles.asAddressVarHandle(CXIdxEntityInfo$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"attributes\")));\n+        public static VarHandle attributes$VH() {\n+            return CXIdxEntityInfo.attributes$VH;\n+        }\n+        public static MemoryAddress attributes$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxEntityInfo.attributes$VH.get(seg);\n+        }\n+        public static void attributes$set( MemorySegment seg, MemoryAddress x) {\n+            CXIdxEntityInfo.attributes$VH.set(seg, x);\n+        }\n+        public static MemoryAddress attributes$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxEntityInfo.attributes$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void attributes$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXIdxEntityInfo.attributes$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle numAttributes$VH = CXIdxEntityInfo$struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"numAttributes\"));\n+        public static VarHandle numAttributes$VH() {\n+            return CXIdxEntityInfo.numAttributes$VH;\n+        }\n+        public static int numAttributes$get(MemorySegment seg) {\n+            return (int)CXIdxEntityInfo.numAttributes$VH.get(seg);\n+        }\n+        public static void numAttributes$set( MemorySegment seg, int x) {\n+            CXIdxEntityInfo.numAttributes$VH.set(seg, x);\n+        }\n+        public static int numAttributes$get(MemorySegment seg, long index) {\n+            return (int)CXIdxEntityInfo.numAttributes$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void numAttributes$set(MemorySegment seg, long index, int x) {\n+            CXIdxEntityInfo.numAttributes$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public static long sizeof() { return $LAYOUT().byteSize(); }\n+        public static MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\n+        public static MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n+        public static MemorySegment allocateArray(int len) {\n+            return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }        public static MemorySegment allocateArray(int len, NativeScope scope) {\n+            return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }\n+        public static MemorySegment allocatePointer() {\n+            return MemorySegment.allocateNative(C_POINTER);\n+        }\n+        public static MemorySegment allocatePointer(NativeScope scope) {\n+            return scope.allocate(C_POINTER);\n+        }\n+        public static MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\n+    }\n+\n+    public static class CXIdxContainerInfo {\n+\n+        static final MemoryLayout CXIdxContainerInfo$struct$LAYOUT = MemoryLayout.ofStruct(\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            ).withName(\"cursor\")\n+        );\n+        public static MemoryLayout $LAYOUT() {\n+            return CXIdxContainerInfo.CXIdxContainerInfo$struct$LAYOUT;\n+        }\n+        public static MemorySegment cursor$slice(MemorySegment seg) {\n+            return RuntimeHelper.nonCloseableNonTransferableSegment(seg.asSlice(0, 32));\n+        }\n+        public static long sizeof() { return $LAYOUT().byteSize(); }\n+        public static MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\n+        public static MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n+        public static MemorySegment allocateArray(int len) {\n+            return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }        public static MemorySegment allocateArray(int len, NativeScope scope) {\n+            return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }\n+        public static MemorySegment allocatePointer() {\n+            return MemorySegment.allocateNative(C_POINTER);\n+        }\n+        public static MemorySegment allocatePointer(NativeScope scope) {\n+            return scope.allocate(C_POINTER);\n+        }\n+        public static MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\n+    }\n+\n+    public static class CXIdxIBOutletCollectionAttrInfo {\n+\n+        static final MemoryLayout CXIdxIBOutletCollectionAttrInfo$struct$LAYOUT = MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"attrInfo\"),\n+            C_POINTER.withName(\"objcClass\"),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            ).withName(\"classCursor\"),\n+            MemoryLayout.ofStruct(\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+                C_INT.withName(\"int_data\"),\n+                MemoryLayout.ofPaddingBits(32)\n+            ).withName(\"classLoc\")\n+        );\n+        public static MemoryLayout $LAYOUT() {\n+            return CXIdxIBOutletCollectionAttrInfo.CXIdxIBOutletCollectionAttrInfo$struct$LAYOUT;\n+        }\n+        static final VarHandle attrInfo$VH = MemoryHandles.asAddressVarHandle(CXIdxIBOutletCollectionAttrInfo$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"attrInfo\")));\n+        public static VarHandle attrInfo$VH() {\n+            return CXIdxIBOutletCollectionAttrInfo.attrInfo$VH;\n+        }\n+        public static MemoryAddress attrInfo$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxIBOutletCollectionAttrInfo.attrInfo$VH.get(seg);\n+        }\n+        public static void attrInfo$set( MemorySegment seg, MemoryAddress x) {\n+            CXIdxIBOutletCollectionAttrInfo.attrInfo$VH.set(seg, x);\n+        }\n+        public static MemoryAddress attrInfo$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxIBOutletCollectionAttrInfo.attrInfo$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void attrInfo$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXIdxIBOutletCollectionAttrInfo.attrInfo$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle objcClass$VH = MemoryHandles.asAddressVarHandle(CXIdxIBOutletCollectionAttrInfo$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"objcClass\")));\n+        public static VarHandle objcClass$VH() {\n+            return CXIdxIBOutletCollectionAttrInfo.objcClass$VH;\n+        }\n+        public static MemoryAddress objcClass$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxIBOutletCollectionAttrInfo.objcClass$VH.get(seg);\n+        }\n+        public static void objcClass$set( MemorySegment seg, MemoryAddress x) {\n+            CXIdxIBOutletCollectionAttrInfo.objcClass$VH.set(seg, x);\n+        }\n+        public static MemoryAddress objcClass$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxIBOutletCollectionAttrInfo.objcClass$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void objcClass$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXIdxIBOutletCollectionAttrInfo.objcClass$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public static MemorySegment classCursor$slice(MemorySegment seg) {\n+            return RuntimeHelper.nonCloseableNonTransferableSegment(seg.asSlice(16, 32));\n+        }\n+        public static MemorySegment classLoc$slice(MemorySegment seg) {\n+            return RuntimeHelper.nonCloseableNonTransferableSegment(seg.asSlice(48, 24));\n+        }\n+        public static long sizeof() { return $LAYOUT().byteSize(); }\n+        public static MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\n+        public static MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n+        public static MemorySegment allocateArray(int len) {\n+            return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }        public static MemorySegment allocateArray(int len, NativeScope scope) {\n+            return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }\n+        public static MemorySegment allocatePointer() {\n+            return MemorySegment.allocateNative(C_POINTER);\n+        }\n+        public static MemorySegment allocatePointer(NativeScope scope) {\n+            return scope.allocate(C_POINTER);\n+        }\n+        public static MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\n+    }\n+\n+    public static class CXIdxDeclInfo {\n+\n+        static final MemoryLayout CXIdxDeclInfo$struct$LAYOUT = MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"entityInfo\"),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            ).withName(\"cursor\"),\n+            MemoryLayout.ofStruct(\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+                C_INT.withName(\"int_data\"),\n+                MemoryLayout.ofPaddingBits(32)\n+            ).withName(\"loc\"),\n+            C_POINTER.withName(\"semanticContainer\"),\n+            C_POINTER.withName(\"lexicalContainer\"),\n+            C_INT.withName(\"isRedeclaration\"),\n+            C_INT.withName(\"isDefinition\"),\n+            C_INT.withName(\"isContainer\"),\n+            MemoryLayout.ofPaddingBits(32),\n+            C_POINTER.withName(\"declAsContainer\"),\n+            C_INT.withName(\"isImplicit\"),\n+            MemoryLayout.ofPaddingBits(32),\n+            C_POINTER.withName(\"attributes\"),\n+            C_INT.withName(\"numAttributes\"),\n+            C_INT.withName(\"flags\")\n+        );\n+        public static MemoryLayout $LAYOUT() {\n+            return CXIdxDeclInfo.CXIdxDeclInfo$struct$LAYOUT;\n+        }\n+        static final VarHandle entityInfo$VH = MemoryHandles.asAddressVarHandle(CXIdxDeclInfo$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"entityInfo\")));\n+        public static VarHandle entityInfo$VH() {\n+            return CXIdxDeclInfo.entityInfo$VH;\n+        }\n+        public static MemoryAddress entityInfo$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxDeclInfo.entityInfo$VH.get(seg);\n+        }\n+        public static void entityInfo$set( MemorySegment seg, MemoryAddress x) {\n+            CXIdxDeclInfo.entityInfo$VH.set(seg, x);\n+        }\n+        public static MemoryAddress entityInfo$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxDeclInfo.entityInfo$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void entityInfo$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXIdxDeclInfo.entityInfo$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public static MemorySegment cursor$slice(MemorySegment seg) {\n+            return RuntimeHelper.nonCloseableNonTransferableSegment(seg.asSlice(8, 32));\n+        }\n+        public static MemorySegment loc$slice(MemorySegment seg) {\n+            return RuntimeHelper.nonCloseableNonTransferableSegment(seg.asSlice(40, 24));\n+        }\n+        static final VarHandle semanticContainer$VH = MemoryHandles.asAddressVarHandle(CXIdxDeclInfo$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"semanticContainer\")));\n+        public static VarHandle semanticContainer$VH() {\n+            return CXIdxDeclInfo.semanticContainer$VH;\n+        }\n+        public static MemoryAddress semanticContainer$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxDeclInfo.semanticContainer$VH.get(seg);\n+        }\n+        public static void semanticContainer$set( MemorySegment seg, MemoryAddress x) {\n+            CXIdxDeclInfo.semanticContainer$VH.set(seg, x);\n+        }\n+        public static MemoryAddress semanticContainer$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxDeclInfo.semanticContainer$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void semanticContainer$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXIdxDeclInfo.semanticContainer$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle lexicalContainer$VH = MemoryHandles.asAddressVarHandle(CXIdxDeclInfo$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"lexicalContainer\")));\n+        public static VarHandle lexicalContainer$VH() {\n+            return CXIdxDeclInfo.lexicalContainer$VH;\n+        }\n+        public static MemoryAddress lexicalContainer$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxDeclInfo.lexicalContainer$VH.get(seg);\n+        }\n+        public static void lexicalContainer$set( MemorySegment seg, MemoryAddress x) {\n+            CXIdxDeclInfo.lexicalContainer$VH.set(seg, x);\n+        }\n+        public static MemoryAddress lexicalContainer$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxDeclInfo.lexicalContainer$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void lexicalContainer$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXIdxDeclInfo.lexicalContainer$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle isRedeclaration$VH = CXIdxDeclInfo$struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"isRedeclaration\"));\n+        public static VarHandle isRedeclaration$VH() {\n+            return CXIdxDeclInfo.isRedeclaration$VH;\n+        }\n+        public static int isRedeclaration$get(MemorySegment seg) {\n+            return (int)CXIdxDeclInfo.isRedeclaration$VH.get(seg);\n+        }\n+        public static void isRedeclaration$set( MemorySegment seg, int x) {\n+            CXIdxDeclInfo.isRedeclaration$VH.set(seg, x);\n+        }\n+        public static int isRedeclaration$get(MemorySegment seg, long index) {\n+            return (int)CXIdxDeclInfo.isRedeclaration$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void isRedeclaration$set(MemorySegment seg, long index, int x) {\n+            CXIdxDeclInfo.isRedeclaration$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle isDefinition$VH = CXIdxDeclInfo$struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"isDefinition\"));\n+        public static VarHandle isDefinition$VH() {\n+            return CXIdxDeclInfo.isDefinition$VH;\n+        }\n+        public static int isDefinition$get(MemorySegment seg) {\n+            return (int)CXIdxDeclInfo.isDefinition$VH.get(seg);\n+        }\n+        public static void isDefinition$set( MemorySegment seg, int x) {\n+            CXIdxDeclInfo.isDefinition$VH.set(seg, x);\n+        }\n+        public static int isDefinition$get(MemorySegment seg, long index) {\n+            return (int)CXIdxDeclInfo.isDefinition$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void isDefinition$set(MemorySegment seg, long index, int x) {\n+            CXIdxDeclInfo.isDefinition$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle isContainer$VH = CXIdxDeclInfo$struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"isContainer\"));\n+        public static VarHandle isContainer$VH() {\n+            return CXIdxDeclInfo.isContainer$VH;\n+        }\n+        public static int isContainer$get(MemorySegment seg) {\n+            return (int)CXIdxDeclInfo.isContainer$VH.get(seg);\n+        }\n+        public static void isContainer$set( MemorySegment seg, int x) {\n+            CXIdxDeclInfo.isContainer$VH.set(seg, x);\n+        }\n+        public static int isContainer$get(MemorySegment seg, long index) {\n+            return (int)CXIdxDeclInfo.isContainer$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void isContainer$set(MemorySegment seg, long index, int x) {\n+            CXIdxDeclInfo.isContainer$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle declAsContainer$VH = MemoryHandles.asAddressVarHandle(CXIdxDeclInfo$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"declAsContainer\")));\n+        public static VarHandle declAsContainer$VH() {\n+            return CXIdxDeclInfo.declAsContainer$VH;\n+        }\n+        public static MemoryAddress declAsContainer$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxDeclInfo.declAsContainer$VH.get(seg);\n+        }\n+        public static void declAsContainer$set( MemorySegment seg, MemoryAddress x) {\n+            CXIdxDeclInfo.declAsContainer$VH.set(seg, x);\n+        }\n+        public static MemoryAddress declAsContainer$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxDeclInfo.declAsContainer$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void declAsContainer$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXIdxDeclInfo.declAsContainer$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle isImplicit$VH = CXIdxDeclInfo$struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"isImplicit\"));\n+        public static VarHandle isImplicit$VH() {\n+            return CXIdxDeclInfo.isImplicit$VH;\n+        }\n+        public static int isImplicit$get(MemorySegment seg) {\n+            return (int)CXIdxDeclInfo.isImplicit$VH.get(seg);\n+        }\n+        public static void isImplicit$set( MemorySegment seg, int x) {\n+            CXIdxDeclInfo.isImplicit$VH.set(seg, x);\n+        }\n+        public static int isImplicit$get(MemorySegment seg, long index) {\n+            return (int)CXIdxDeclInfo.isImplicit$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void isImplicit$set(MemorySegment seg, long index, int x) {\n+            CXIdxDeclInfo.isImplicit$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle attributes$VH = MemoryHandles.asAddressVarHandle(CXIdxDeclInfo$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"attributes\")));\n+        public static VarHandle attributes$VH() {\n+            return CXIdxDeclInfo.attributes$VH;\n+        }\n+        public static MemoryAddress attributes$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxDeclInfo.attributes$VH.get(seg);\n+        }\n+        public static void attributes$set( MemorySegment seg, MemoryAddress x) {\n+            CXIdxDeclInfo.attributes$VH.set(seg, x);\n+        }\n+        public static MemoryAddress attributes$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxDeclInfo.attributes$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void attributes$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXIdxDeclInfo.attributes$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle numAttributes$VH = CXIdxDeclInfo$struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"numAttributes\"));\n+        public static VarHandle numAttributes$VH() {\n+            return CXIdxDeclInfo.numAttributes$VH;\n+        }\n+        public static int numAttributes$get(MemorySegment seg) {\n+            return (int)CXIdxDeclInfo.numAttributes$VH.get(seg);\n+        }\n+        public static void numAttributes$set( MemorySegment seg, int x) {\n+            CXIdxDeclInfo.numAttributes$VH.set(seg, x);\n+        }\n+        public static int numAttributes$get(MemorySegment seg, long index) {\n+            return (int)CXIdxDeclInfo.numAttributes$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void numAttributes$set(MemorySegment seg, long index, int x) {\n+            CXIdxDeclInfo.numAttributes$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle flags$VH = CXIdxDeclInfo$struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"flags\"));\n+        public static VarHandle flags$VH() {\n+            return CXIdxDeclInfo.flags$VH;\n+        }\n+        public static int flags$get(MemorySegment seg) {\n+            return (int)CXIdxDeclInfo.flags$VH.get(seg);\n+        }\n+        public static void flags$set( MemorySegment seg, int x) {\n+            CXIdxDeclInfo.flags$VH.set(seg, x);\n+        }\n+        public static int flags$get(MemorySegment seg, long index) {\n+            return (int)CXIdxDeclInfo.flags$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void flags$set(MemorySegment seg, long index, int x) {\n+            CXIdxDeclInfo.flags$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public static long sizeof() { return $LAYOUT().byteSize(); }\n+        public static MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\n+        public static MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n+        public static MemorySegment allocateArray(int len) {\n+            return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }        public static MemorySegment allocateArray(int len, NativeScope scope) {\n+            return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }\n+        public static MemorySegment allocatePointer() {\n+            return MemorySegment.allocateNative(C_POINTER);\n+        }\n+        public static MemorySegment allocatePointer(NativeScope scope) {\n+            return scope.allocate(C_POINTER);\n+        }\n+        public static MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\n+    }\n+\n+    public static class CXIdxObjCContainerDeclInfo {\n+\n+        static final MemoryLayout CXIdxObjCContainerDeclInfo$struct$LAYOUT = MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"declInfo\"),\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        );\n+        public static MemoryLayout $LAYOUT() {\n+            return CXIdxObjCContainerDeclInfo.CXIdxObjCContainerDeclInfo$struct$LAYOUT;\n+        }\n+        static final VarHandle declInfo$VH = MemoryHandles.asAddressVarHandle(CXIdxObjCContainerDeclInfo$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"declInfo\")));\n+        public static VarHandle declInfo$VH() {\n+            return CXIdxObjCContainerDeclInfo.declInfo$VH;\n+        }\n+        public static MemoryAddress declInfo$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxObjCContainerDeclInfo.declInfo$VH.get(seg);\n+        }\n+        public static void declInfo$set( MemorySegment seg, MemoryAddress x) {\n+            CXIdxObjCContainerDeclInfo.declInfo$VH.set(seg, x);\n+        }\n+        public static MemoryAddress declInfo$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxObjCContainerDeclInfo.declInfo$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void declInfo$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXIdxObjCContainerDeclInfo.declInfo$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle kind$VH = CXIdxObjCContainerDeclInfo$struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"kind\"));\n+        public static VarHandle kind$VH() {\n+            return CXIdxObjCContainerDeclInfo.kind$VH;\n+        }\n+        public static int kind$get(MemorySegment seg) {\n+            return (int)CXIdxObjCContainerDeclInfo.kind$VH.get(seg);\n+        }\n+        public static void kind$set( MemorySegment seg, int x) {\n+            CXIdxObjCContainerDeclInfo.kind$VH.set(seg, x);\n+        }\n+        public static int kind$get(MemorySegment seg, long index) {\n+            return (int)CXIdxObjCContainerDeclInfo.kind$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void kind$set(MemorySegment seg, long index, int x) {\n+            CXIdxObjCContainerDeclInfo.kind$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public static long sizeof() { return $LAYOUT().byteSize(); }\n+        public static MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\n+        public static MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n+        public static MemorySegment allocateArray(int len) {\n+            return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }        public static MemorySegment allocateArray(int len, NativeScope scope) {\n+            return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }\n+        public static MemorySegment allocatePointer() {\n+            return MemorySegment.allocateNative(C_POINTER);\n+        }\n+        public static MemorySegment allocatePointer(NativeScope scope) {\n+            return scope.allocate(C_POINTER);\n+        }\n+        public static MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\n+    }\n+\n+    public static class CXIdxBaseClassInfo {\n+\n+        static final MemoryLayout CXIdxBaseClassInfo$struct$LAYOUT = MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"base\"),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            ).withName(\"cursor\"),\n+            MemoryLayout.ofStruct(\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+                C_INT.withName(\"int_data\"),\n+                MemoryLayout.ofPaddingBits(32)\n+            ).withName(\"loc\")\n+        );\n+        public static MemoryLayout $LAYOUT() {\n+            return CXIdxBaseClassInfo.CXIdxBaseClassInfo$struct$LAYOUT;\n+        }\n+        static final VarHandle base$VH = MemoryHandles.asAddressVarHandle(CXIdxBaseClassInfo$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"base\")));\n+        public static VarHandle base$VH() {\n+            return CXIdxBaseClassInfo.base$VH;\n+        }\n+        public static MemoryAddress base$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxBaseClassInfo.base$VH.get(seg);\n+        }\n+        public static void base$set( MemorySegment seg, MemoryAddress x) {\n+            CXIdxBaseClassInfo.base$VH.set(seg, x);\n+        }\n+        public static MemoryAddress base$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxBaseClassInfo.base$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void base$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXIdxBaseClassInfo.base$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public static MemorySegment cursor$slice(MemorySegment seg) {\n+            return RuntimeHelper.nonCloseableNonTransferableSegment(seg.asSlice(8, 32));\n+        }\n+        public static MemorySegment loc$slice(MemorySegment seg) {\n+            return RuntimeHelper.nonCloseableNonTransferableSegment(seg.asSlice(40, 24));\n+        }\n+        public static long sizeof() { return $LAYOUT().byteSize(); }\n+        public static MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\n+        public static MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n+        public static MemorySegment allocateArray(int len) {\n+            return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }        public static MemorySegment allocateArray(int len, NativeScope scope) {\n+            return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }\n+        public static MemorySegment allocatePointer() {\n+            return MemorySegment.allocateNative(C_POINTER);\n+        }\n+        public static MemorySegment allocatePointer(NativeScope scope) {\n+            return scope.allocate(C_POINTER);\n+        }\n+        public static MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\n+    }\n+\n+    public static class CXIdxObjCProtocolRefInfo {\n+\n+        static final MemoryLayout CXIdxObjCProtocolRefInfo$struct$LAYOUT = MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"protocol\"),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            ).withName(\"cursor\"),\n+            MemoryLayout.ofStruct(\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+                C_INT.withName(\"int_data\"),\n+                MemoryLayout.ofPaddingBits(32)\n+            ).withName(\"loc\")\n+        );\n+        public static MemoryLayout $LAYOUT() {\n+            return CXIdxObjCProtocolRefInfo.CXIdxObjCProtocolRefInfo$struct$LAYOUT;\n+        }\n+        static final VarHandle protocol$VH = MemoryHandles.asAddressVarHandle(CXIdxObjCProtocolRefInfo$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"protocol\")));\n+        public static VarHandle protocol$VH() {\n+            return CXIdxObjCProtocolRefInfo.protocol$VH;\n+        }\n+        public static MemoryAddress protocol$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxObjCProtocolRefInfo.protocol$VH.get(seg);\n+        }\n+        public static void protocol$set( MemorySegment seg, MemoryAddress x) {\n+            CXIdxObjCProtocolRefInfo.protocol$VH.set(seg, x);\n+        }\n+        public static MemoryAddress protocol$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxObjCProtocolRefInfo.protocol$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void protocol$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXIdxObjCProtocolRefInfo.protocol$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public static MemorySegment cursor$slice(MemorySegment seg) {\n+            return RuntimeHelper.nonCloseableNonTransferableSegment(seg.asSlice(8, 32));\n+        }\n+        public static MemorySegment loc$slice(MemorySegment seg) {\n+            return RuntimeHelper.nonCloseableNonTransferableSegment(seg.asSlice(40, 24));\n+        }\n+        public static long sizeof() { return $LAYOUT().byteSize(); }\n+        public static MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\n+        public static MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n+        public static MemorySegment allocateArray(int len) {\n+            return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }        public static MemorySegment allocateArray(int len, NativeScope scope) {\n+            return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }\n+        public static MemorySegment allocatePointer() {\n+            return MemorySegment.allocateNative(C_POINTER);\n+        }\n+        public static MemorySegment allocatePointer(NativeScope scope) {\n+            return scope.allocate(C_POINTER);\n+        }\n+        public static MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\n+    }\n+\n+    public static class CXIdxObjCProtocolRefListInfo {\n+\n+        static final MemoryLayout CXIdxObjCProtocolRefListInfo$struct$LAYOUT = MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"protocols\"),\n+            C_INT.withName(\"numProtocols\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        );\n+        public static MemoryLayout $LAYOUT() {\n+            return CXIdxObjCProtocolRefListInfo.CXIdxObjCProtocolRefListInfo$struct$LAYOUT;\n+        }\n+        static final VarHandle protocols$VH = MemoryHandles.asAddressVarHandle(CXIdxObjCProtocolRefListInfo$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"protocols\")));\n+        public static VarHandle protocols$VH() {\n+            return CXIdxObjCProtocolRefListInfo.protocols$VH;\n+        }\n+        public static MemoryAddress protocols$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxObjCProtocolRefListInfo.protocols$VH.get(seg);\n+        }\n+        public static void protocols$set( MemorySegment seg, MemoryAddress x) {\n+            CXIdxObjCProtocolRefListInfo.protocols$VH.set(seg, x);\n+        }\n+        public static MemoryAddress protocols$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxObjCProtocolRefListInfo.protocols$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void protocols$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXIdxObjCProtocolRefListInfo.protocols$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle numProtocols$VH = CXIdxObjCProtocolRefListInfo$struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"numProtocols\"));\n+        public static VarHandle numProtocols$VH() {\n+            return CXIdxObjCProtocolRefListInfo.numProtocols$VH;\n+        }\n+        public static int numProtocols$get(MemorySegment seg) {\n+            return (int)CXIdxObjCProtocolRefListInfo.numProtocols$VH.get(seg);\n+        }\n+        public static void numProtocols$set( MemorySegment seg, int x) {\n+            CXIdxObjCProtocolRefListInfo.numProtocols$VH.set(seg, x);\n+        }\n+        public static int numProtocols$get(MemorySegment seg, long index) {\n+            return (int)CXIdxObjCProtocolRefListInfo.numProtocols$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void numProtocols$set(MemorySegment seg, long index, int x) {\n+            CXIdxObjCProtocolRefListInfo.numProtocols$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public static long sizeof() { return $LAYOUT().byteSize(); }\n+        public static MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\n+        public static MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n+        public static MemorySegment allocateArray(int len) {\n+            return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }        public static MemorySegment allocateArray(int len, NativeScope scope) {\n+            return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }\n+        public static MemorySegment allocatePointer() {\n+            return MemorySegment.allocateNative(C_POINTER);\n+        }\n+        public static MemorySegment allocatePointer(NativeScope scope) {\n+            return scope.allocate(C_POINTER);\n+        }\n+        public static MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\n+    }\n+\n+    public static class CXIdxObjCInterfaceDeclInfo {\n+\n+        static final MemoryLayout CXIdxObjCInterfaceDeclInfo$struct$LAYOUT = MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"containerInfo\"),\n+            C_POINTER.withName(\"superInfo\"),\n+            C_POINTER.withName(\"protocols\")\n+        );\n+        public static MemoryLayout $LAYOUT() {\n+            return CXIdxObjCInterfaceDeclInfo.CXIdxObjCInterfaceDeclInfo$struct$LAYOUT;\n+        }\n+        static final VarHandle containerInfo$VH = MemoryHandles.asAddressVarHandle(CXIdxObjCInterfaceDeclInfo$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"containerInfo\")));\n+        public static VarHandle containerInfo$VH() {\n+            return CXIdxObjCInterfaceDeclInfo.containerInfo$VH;\n+        }\n+        public static MemoryAddress containerInfo$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxObjCInterfaceDeclInfo.containerInfo$VH.get(seg);\n+        }\n+        public static void containerInfo$set( MemorySegment seg, MemoryAddress x) {\n+            CXIdxObjCInterfaceDeclInfo.containerInfo$VH.set(seg, x);\n+        }\n+        public static MemoryAddress containerInfo$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxObjCInterfaceDeclInfo.containerInfo$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void containerInfo$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXIdxObjCInterfaceDeclInfo.containerInfo$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle superInfo$VH = MemoryHandles.asAddressVarHandle(CXIdxObjCInterfaceDeclInfo$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"superInfo\")));\n+        public static VarHandle superInfo$VH() {\n+            return CXIdxObjCInterfaceDeclInfo.superInfo$VH;\n+        }\n+        public static MemoryAddress superInfo$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxObjCInterfaceDeclInfo.superInfo$VH.get(seg);\n+        }\n+        public static void superInfo$set( MemorySegment seg, MemoryAddress x) {\n+            CXIdxObjCInterfaceDeclInfo.superInfo$VH.set(seg, x);\n+        }\n+        public static MemoryAddress superInfo$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxObjCInterfaceDeclInfo.superInfo$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void superInfo$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXIdxObjCInterfaceDeclInfo.superInfo$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle protocols$VH = MemoryHandles.asAddressVarHandle(CXIdxObjCInterfaceDeclInfo$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"protocols\")));\n+        public static VarHandle protocols$VH() {\n+            return CXIdxObjCInterfaceDeclInfo.protocols$VH;\n+        }\n+        public static MemoryAddress protocols$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxObjCInterfaceDeclInfo.protocols$VH.get(seg);\n+        }\n+        public static void protocols$set( MemorySegment seg, MemoryAddress x) {\n+            CXIdxObjCInterfaceDeclInfo.protocols$VH.set(seg, x);\n+        }\n+        public static MemoryAddress protocols$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxObjCInterfaceDeclInfo.protocols$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void protocols$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXIdxObjCInterfaceDeclInfo.protocols$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public static long sizeof() { return $LAYOUT().byteSize(); }\n+        public static MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\n+        public static MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n+        public static MemorySegment allocateArray(int len) {\n+            return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }        public static MemorySegment allocateArray(int len, NativeScope scope) {\n+            return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }\n+        public static MemorySegment allocatePointer() {\n+            return MemorySegment.allocateNative(C_POINTER);\n+        }\n+        public static MemorySegment allocatePointer(NativeScope scope) {\n+            return scope.allocate(C_POINTER);\n+        }\n+        public static MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\n+    }\n+\n+    public static class CXIdxObjCCategoryDeclInfo {\n+\n+        static final MemoryLayout CXIdxObjCCategoryDeclInfo$struct$LAYOUT = MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"containerInfo\"),\n+            C_POINTER.withName(\"objcClass\"),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            ).withName(\"classCursor\"),\n+            MemoryLayout.ofStruct(\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+                C_INT.withName(\"int_data\"),\n+                MemoryLayout.ofPaddingBits(32)\n+            ).withName(\"classLoc\"),\n+            C_POINTER.withName(\"protocols\")\n+        );\n+        public static MemoryLayout $LAYOUT() {\n+            return CXIdxObjCCategoryDeclInfo.CXIdxObjCCategoryDeclInfo$struct$LAYOUT;\n+        }\n+        static final VarHandle containerInfo$VH = MemoryHandles.asAddressVarHandle(CXIdxObjCCategoryDeclInfo$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"containerInfo\")));\n+        public static VarHandle containerInfo$VH() {\n+            return CXIdxObjCCategoryDeclInfo.containerInfo$VH;\n+        }\n+        public static MemoryAddress containerInfo$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxObjCCategoryDeclInfo.containerInfo$VH.get(seg);\n+        }\n+        public static void containerInfo$set( MemorySegment seg, MemoryAddress x) {\n+            CXIdxObjCCategoryDeclInfo.containerInfo$VH.set(seg, x);\n+        }\n+        public static MemoryAddress containerInfo$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxObjCCategoryDeclInfo.containerInfo$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void containerInfo$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXIdxObjCCategoryDeclInfo.containerInfo$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle objcClass$VH = MemoryHandles.asAddressVarHandle(CXIdxObjCCategoryDeclInfo$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"objcClass\")));\n+        public static VarHandle objcClass$VH() {\n+            return CXIdxObjCCategoryDeclInfo.objcClass$VH;\n+        }\n+        public static MemoryAddress objcClass$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxObjCCategoryDeclInfo.objcClass$VH.get(seg);\n+        }\n+        public static void objcClass$set( MemorySegment seg, MemoryAddress x) {\n+            CXIdxObjCCategoryDeclInfo.objcClass$VH.set(seg, x);\n+        }\n+        public static MemoryAddress objcClass$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxObjCCategoryDeclInfo.objcClass$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void objcClass$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXIdxObjCCategoryDeclInfo.objcClass$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public static MemorySegment classCursor$slice(MemorySegment seg) {\n+            return RuntimeHelper.nonCloseableNonTransferableSegment(seg.asSlice(16, 32));\n+        }\n+        public static MemorySegment classLoc$slice(MemorySegment seg) {\n+            return RuntimeHelper.nonCloseableNonTransferableSegment(seg.asSlice(48, 24));\n+        }\n+        static final VarHandle protocols$VH = MemoryHandles.asAddressVarHandle(CXIdxObjCCategoryDeclInfo$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"protocols\")));\n+        public static VarHandle protocols$VH() {\n+            return CXIdxObjCCategoryDeclInfo.protocols$VH;\n+        }\n+        public static MemoryAddress protocols$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxObjCCategoryDeclInfo.protocols$VH.get(seg);\n+        }\n+        public static void protocols$set( MemorySegment seg, MemoryAddress x) {\n+            CXIdxObjCCategoryDeclInfo.protocols$VH.set(seg, x);\n+        }\n+        public static MemoryAddress protocols$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxObjCCategoryDeclInfo.protocols$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void protocols$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXIdxObjCCategoryDeclInfo.protocols$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public static long sizeof() { return $LAYOUT().byteSize(); }\n+        public static MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\n+        public static MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n+        public static MemorySegment allocateArray(int len) {\n+            return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }        public static MemorySegment allocateArray(int len, NativeScope scope) {\n+            return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }\n+        public static MemorySegment allocatePointer() {\n+            return MemorySegment.allocateNative(C_POINTER);\n+        }\n+        public static MemorySegment allocatePointer(NativeScope scope) {\n+            return scope.allocate(C_POINTER);\n+        }\n+        public static MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\n+    }\n+\n+    public static class CXIdxObjCPropertyDeclInfo {\n+\n+        static final MemoryLayout CXIdxObjCPropertyDeclInfo$struct$LAYOUT = MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"declInfo\"),\n+            C_POINTER.withName(\"getter\"),\n+            C_POINTER.withName(\"setter\")\n+        );\n+        public static MemoryLayout $LAYOUT() {\n+            return CXIdxObjCPropertyDeclInfo.CXIdxObjCPropertyDeclInfo$struct$LAYOUT;\n+        }\n+        static final VarHandle declInfo$VH = MemoryHandles.asAddressVarHandle(CXIdxObjCPropertyDeclInfo$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"declInfo\")));\n+        public static VarHandle declInfo$VH() {\n+            return CXIdxObjCPropertyDeclInfo.declInfo$VH;\n+        }\n+        public static MemoryAddress declInfo$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxObjCPropertyDeclInfo.declInfo$VH.get(seg);\n+        }\n+        public static void declInfo$set( MemorySegment seg, MemoryAddress x) {\n+            CXIdxObjCPropertyDeclInfo.declInfo$VH.set(seg, x);\n+        }\n+        public static MemoryAddress declInfo$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxObjCPropertyDeclInfo.declInfo$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void declInfo$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXIdxObjCPropertyDeclInfo.declInfo$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle getter$VH = MemoryHandles.asAddressVarHandle(CXIdxObjCPropertyDeclInfo$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"getter\")));\n+        public static VarHandle getter$VH() {\n+            return CXIdxObjCPropertyDeclInfo.getter$VH;\n+        }\n+        public static MemoryAddress getter$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxObjCPropertyDeclInfo.getter$VH.get(seg);\n+        }\n+        public static void getter$set( MemorySegment seg, MemoryAddress x) {\n+            CXIdxObjCPropertyDeclInfo.getter$VH.set(seg, x);\n+        }\n+        public static MemoryAddress getter$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxObjCPropertyDeclInfo.getter$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void getter$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXIdxObjCPropertyDeclInfo.getter$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle setter$VH = MemoryHandles.asAddressVarHandle(CXIdxObjCPropertyDeclInfo$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"setter\")));\n+        public static VarHandle setter$VH() {\n+            return CXIdxObjCPropertyDeclInfo.setter$VH;\n+        }\n+        public static MemoryAddress setter$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxObjCPropertyDeclInfo.setter$VH.get(seg);\n+        }\n+        public static void setter$set( MemorySegment seg, MemoryAddress x) {\n+            CXIdxObjCPropertyDeclInfo.setter$VH.set(seg, x);\n+        }\n+        public static MemoryAddress setter$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxObjCPropertyDeclInfo.setter$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void setter$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXIdxObjCPropertyDeclInfo.setter$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public static long sizeof() { return $LAYOUT().byteSize(); }\n+        public static MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\n+        public static MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n+        public static MemorySegment allocateArray(int len) {\n+            return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }        public static MemorySegment allocateArray(int len, NativeScope scope) {\n+            return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }\n+        public static MemorySegment allocatePointer() {\n+            return MemorySegment.allocateNative(C_POINTER);\n+        }\n+        public static MemorySegment allocatePointer(NativeScope scope) {\n+            return scope.allocate(C_POINTER);\n+        }\n+        public static MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\n+    }\n+\n+    public static class CXIdxCXXClassDeclInfo {\n+\n+        static final MemoryLayout CXIdxCXXClassDeclInfo$struct$LAYOUT = MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"declInfo\"),\n+            C_POINTER.withName(\"bases\"),\n+            C_INT.withName(\"numBases\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        );\n+        public static MemoryLayout $LAYOUT() {\n+            return CXIdxCXXClassDeclInfo.CXIdxCXXClassDeclInfo$struct$LAYOUT;\n+        }\n+        static final VarHandle declInfo$VH = MemoryHandles.asAddressVarHandle(CXIdxCXXClassDeclInfo$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"declInfo\")));\n+        public static VarHandle declInfo$VH() {\n+            return CXIdxCXXClassDeclInfo.declInfo$VH;\n+        }\n+        public static MemoryAddress declInfo$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxCXXClassDeclInfo.declInfo$VH.get(seg);\n+        }\n+        public static void declInfo$set( MemorySegment seg, MemoryAddress x) {\n+            CXIdxCXXClassDeclInfo.declInfo$VH.set(seg, x);\n+        }\n+        public static MemoryAddress declInfo$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxCXXClassDeclInfo.declInfo$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void declInfo$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXIdxCXXClassDeclInfo.declInfo$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle bases$VH = MemoryHandles.asAddressVarHandle(CXIdxCXXClassDeclInfo$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"bases\")));\n+        public static VarHandle bases$VH() {\n+            return CXIdxCXXClassDeclInfo.bases$VH;\n+        }\n+        public static MemoryAddress bases$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxCXXClassDeclInfo.bases$VH.get(seg);\n+        }\n+        public static void bases$set( MemorySegment seg, MemoryAddress x) {\n+            CXIdxCXXClassDeclInfo.bases$VH.set(seg, x);\n+        }\n+        public static MemoryAddress bases$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxCXXClassDeclInfo.bases$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void bases$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXIdxCXXClassDeclInfo.bases$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle numBases$VH = CXIdxCXXClassDeclInfo$struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"numBases\"));\n+        public static VarHandle numBases$VH() {\n+            return CXIdxCXXClassDeclInfo.numBases$VH;\n+        }\n+        public static int numBases$get(MemorySegment seg) {\n+            return (int)CXIdxCXXClassDeclInfo.numBases$VH.get(seg);\n+        }\n+        public static void numBases$set( MemorySegment seg, int x) {\n+            CXIdxCXXClassDeclInfo.numBases$VH.set(seg, x);\n+        }\n+        public static int numBases$get(MemorySegment seg, long index) {\n+            return (int)CXIdxCXXClassDeclInfo.numBases$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void numBases$set(MemorySegment seg, long index, int x) {\n+            CXIdxCXXClassDeclInfo.numBases$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public static long sizeof() { return $LAYOUT().byteSize(); }\n+        public static MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\n+        public static MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n+        public static MemorySegment allocateArray(int len) {\n+            return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }        public static MemorySegment allocateArray(int len, NativeScope scope) {\n+            return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }\n+        public static MemorySegment allocatePointer() {\n+            return MemorySegment.allocateNative(C_POINTER);\n+        }\n+        public static MemorySegment allocatePointer(NativeScope scope) {\n+            return scope.allocate(C_POINTER);\n+        }\n+        public static MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\n+    }\n+\n+    public static class CXIdxEntityRefInfo {\n+\n+        static final MemoryLayout CXIdxEntityRefInfo$struct$LAYOUT = MemoryLayout.ofStruct(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.ofPaddingBits(32),\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            ).withName(\"cursor\"),\n+            MemoryLayout.ofStruct(\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+                C_INT.withName(\"int_data\"),\n+                MemoryLayout.ofPaddingBits(32)\n+            ).withName(\"loc\"),\n+            C_POINTER.withName(\"referencedEntity\"),\n+            C_POINTER.withName(\"parentEntity\"),\n+            C_POINTER.withName(\"container\"),\n+            C_INT.withName(\"role\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        );\n+        public static MemoryLayout $LAYOUT() {\n+            return CXIdxEntityRefInfo.CXIdxEntityRefInfo$struct$LAYOUT;\n+        }\n+        static final VarHandle kind$VH = CXIdxEntityRefInfo$struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"kind\"));\n+        public static VarHandle kind$VH() {\n+            return CXIdxEntityRefInfo.kind$VH;\n+        }\n+        public static int kind$get(MemorySegment seg) {\n+            return (int)CXIdxEntityRefInfo.kind$VH.get(seg);\n+        }\n+        public static void kind$set( MemorySegment seg, int x) {\n+            CXIdxEntityRefInfo.kind$VH.set(seg, x);\n+        }\n+        public static int kind$get(MemorySegment seg, long index) {\n+            return (int)CXIdxEntityRefInfo.kind$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void kind$set(MemorySegment seg, long index, int x) {\n+            CXIdxEntityRefInfo.kind$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public static MemorySegment cursor$slice(MemorySegment seg) {\n+            return RuntimeHelper.nonCloseableNonTransferableSegment(seg.asSlice(8, 32));\n+        }\n+        public static MemorySegment loc$slice(MemorySegment seg) {\n+            return RuntimeHelper.nonCloseableNonTransferableSegment(seg.asSlice(40, 24));\n+        }\n+        static final VarHandle referencedEntity$VH = MemoryHandles.asAddressVarHandle(CXIdxEntityRefInfo$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"referencedEntity\")));\n+        public static VarHandle referencedEntity$VH() {\n+            return CXIdxEntityRefInfo.referencedEntity$VH;\n+        }\n+        public static MemoryAddress referencedEntity$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxEntityRefInfo.referencedEntity$VH.get(seg);\n+        }\n+        public static void referencedEntity$set( MemorySegment seg, MemoryAddress x) {\n+            CXIdxEntityRefInfo.referencedEntity$VH.set(seg, x);\n+        }\n+        public static MemoryAddress referencedEntity$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxEntityRefInfo.referencedEntity$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void referencedEntity$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXIdxEntityRefInfo.referencedEntity$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle parentEntity$VH = MemoryHandles.asAddressVarHandle(CXIdxEntityRefInfo$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"parentEntity\")));\n+        public static VarHandle parentEntity$VH() {\n+            return CXIdxEntityRefInfo.parentEntity$VH;\n+        }\n+        public static MemoryAddress parentEntity$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxEntityRefInfo.parentEntity$VH.get(seg);\n+        }\n+        public static void parentEntity$set( MemorySegment seg, MemoryAddress x) {\n+            CXIdxEntityRefInfo.parentEntity$VH.set(seg, x);\n+        }\n+        public static MemoryAddress parentEntity$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxEntityRefInfo.parentEntity$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void parentEntity$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXIdxEntityRefInfo.parentEntity$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle container$VH = MemoryHandles.asAddressVarHandle(CXIdxEntityRefInfo$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"container\")));\n+        public static VarHandle container$VH() {\n+            return CXIdxEntityRefInfo.container$VH;\n+        }\n+        public static MemoryAddress container$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxEntityRefInfo.container$VH.get(seg);\n+        }\n+        public static void container$set( MemorySegment seg, MemoryAddress x) {\n+            CXIdxEntityRefInfo.container$VH.set(seg, x);\n+        }\n+        public static MemoryAddress container$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)CXIdxEntityRefInfo.container$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void container$set(MemorySegment seg, long index, MemoryAddress x) {\n+            CXIdxEntityRefInfo.container$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        static final VarHandle role$VH = CXIdxEntityRefInfo$struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"role\"));\n+        public static VarHandle role$VH() {\n+            return CXIdxEntityRefInfo.role$VH;\n+        }\n+        public static int role$get(MemorySegment seg) {\n+            return (int)CXIdxEntityRefInfo.role$VH.get(seg);\n+        }\n+        public static void role$set( MemorySegment seg, int x) {\n+            CXIdxEntityRefInfo.role$VH.set(seg, x);\n+        }\n+        public static int role$get(MemorySegment seg, long index) {\n+            return (int)CXIdxEntityRefInfo.role$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void role$set(MemorySegment seg, long index, int x) {\n+            CXIdxEntityRefInfo.role$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public static long sizeof() { return $LAYOUT().byteSize(); }\n+        public static MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\n+        public static MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n+        public static MemorySegment allocateArray(int len) {\n+            return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }        public static MemorySegment allocateArray(int len, NativeScope scope) {\n+            return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }\n+        public static MemorySegment allocatePointer() {\n+            return MemorySegment.allocateNative(C_POINTER);\n+        }\n+        public static MemorySegment allocatePointer(NativeScope scope) {\n+            return scope.allocate(C_POINTER);\n+        }\n+        public static MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\n+    }\n+\n+    public static class constants$52 {\n+\n+        static final FunctionDescriptor clang_findReferencesInFileWithBlock$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            ),\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_findReferencesInFileWithBlock$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_findReferencesInFileWithBlock\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+            constants$52.clang_findReferencesInFileWithBlock$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_findIncludesInFileWithBlock$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER,\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_findIncludesInFileWithBlock$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_findIncludesInFileWithBlock\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+            constants$52.clang_findIncludesInFileWithBlock$FUNC, false\n+        );\n+        static final FunctionDescriptor abortQuery$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final FunctionDescriptor diagnostic$FUNC = FunctionDescriptor.ofVoid(\n+            C_POINTER,\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final FunctionDescriptor enteredMainFile$FUNC = FunctionDescriptor.of(C_POINTER,\n+            C_POINTER,\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final FunctionDescriptor ppIncludedFile$FUNC = FunctionDescriptor.of(C_POINTER,\n+            C_POINTER,\n+            C_POINTER\n+        );\n+    }\n+\n+    public static class IndexerCallbacks {\n+\n+        static final MemoryLayout IndexerCallbacks$struct$LAYOUT = MemoryLayout.ofStruct(\n+            C_POINTER.withName(\"abortQuery\"),\n+            C_POINTER.withName(\"diagnostic\"),\n+            C_POINTER.withName(\"enteredMainFile\"),\n+            C_POINTER.withName(\"ppIncludedFile\"),\n+            C_POINTER.withName(\"importedASTFile\"),\n+            C_POINTER.withName(\"startedTranslationUnit\"),\n+            C_POINTER.withName(\"indexDeclaration\"),\n+            C_POINTER.withName(\"indexEntityReference\")\n+        );\n+        public static MemoryLayout $LAYOUT() {\n+            return IndexerCallbacks.IndexerCallbacks$struct$LAYOUT;\n+        }\n+        public interface abortQuery {\n+\n+            int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);\n+            static MemorySegment allocate(abortQuery fi) {\n+                return RuntimeHelper.upcallStub(abortQuery.class, fi, constants$52.abortQuery$FUNC, \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)I\");\n+            }\n+            static MemorySegment allocate(abortQuery fi, NativeScope scope) {\n+                return allocate(fi).handoff(scope);\n+            }\n+        }\n+\n+        static final VarHandle abortQuery$VH = MemoryHandles.asAddressVarHandle(IndexerCallbacks$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"abortQuery\")));\n+        public static VarHandle abortQuery$VH() {\n+            return IndexerCallbacks.abortQuery$VH;\n+        }\n+        public static MemoryAddress abortQuery$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)IndexerCallbacks.abortQuery$VH.get(seg);\n+        }\n+        public static void abortQuery$set( MemorySegment seg, MemoryAddress x) {\n+            IndexerCallbacks.abortQuery$VH.set(seg, x);\n+        }\n+        public static MemoryAddress abortQuery$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)IndexerCallbacks.abortQuery$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void abortQuery$set(MemorySegment seg, long index, MemoryAddress x) {\n+            IndexerCallbacks.abortQuery$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public interface diagnostic {\n+\n+            void apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2);\n+            static MemorySegment allocate(diagnostic fi) {\n+                return RuntimeHelper.upcallStub(diagnostic.class, fi, constants$52.diagnostic$FUNC, \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)V\");\n+            }\n+            static MemorySegment allocate(diagnostic fi, NativeScope scope) {\n+                return allocate(fi).handoff(scope);\n+            }\n+        }\n+\n+        static final VarHandle diagnostic$VH = MemoryHandles.asAddressVarHandle(IndexerCallbacks$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"diagnostic\")));\n+        public static VarHandle diagnostic$VH() {\n+            return IndexerCallbacks.diagnostic$VH;\n+        }\n+        public static MemoryAddress diagnostic$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)IndexerCallbacks.diagnostic$VH.get(seg);\n+        }\n+        public static void diagnostic$set( MemorySegment seg, MemoryAddress x) {\n+            IndexerCallbacks.diagnostic$VH.set(seg, x);\n+        }\n+        public static MemoryAddress diagnostic$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)IndexerCallbacks.diagnostic$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void diagnostic$set(MemorySegment seg, long index, MemoryAddress x) {\n+            IndexerCallbacks.diagnostic$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public interface enteredMainFile {\n+\n+            jdk.incubator.foreign.MemoryAddress apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2);\n+            static MemorySegment allocate(enteredMainFile fi) {\n+                return RuntimeHelper.upcallStub(enteredMainFile.class, fi, constants$52.enteredMainFile$FUNC, \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemoryAddress;\");\n+            }\n+            static MemorySegment allocate(enteredMainFile fi, NativeScope scope) {\n+                return allocate(fi).handoff(scope);\n+            }\n+        }\n+\n+        static final VarHandle enteredMainFile$VH = MemoryHandles.asAddressVarHandle(IndexerCallbacks$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"enteredMainFile\")));\n+        public static VarHandle enteredMainFile$VH() {\n+            return IndexerCallbacks.enteredMainFile$VH;\n+        }\n+        public static MemoryAddress enteredMainFile$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)IndexerCallbacks.enteredMainFile$VH.get(seg);\n+        }\n+        public static void enteredMainFile$set( MemorySegment seg, MemoryAddress x) {\n+            IndexerCallbacks.enteredMainFile$VH.set(seg, x);\n+        }\n+        public static MemoryAddress enteredMainFile$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)IndexerCallbacks.enteredMainFile$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void enteredMainFile$set(MemorySegment seg, long index, MemoryAddress x) {\n+            IndexerCallbacks.enteredMainFile$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public interface ppIncludedFile {\n+\n+            jdk.incubator.foreign.MemoryAddress apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);\n+            static MemorySegment allocate(ppIncludedFile fi) {\n+                return RuntimeHelper.upcallStub(ppIncludedFile.class, fi, constants$52.ppIncludedFile$FUNC, \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemoryAddress;\");\n+            }\n+            static MemorySegment allocate(ppIncludedFile fi, NativeScope scope) {\n+                return allocate(fi).handoff(scope);\n+            }\n+        }\n+\n+        static final VarHandle ppIncludedFile$VH = MemoryHandles.asAddressVarHandle(IndexerCallbacks$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"ppIncludedFile\")));\n+        public static VarHandle ppIncludedFile$VH() {\n+            return IndexerCallbacks.ppIncludedFile$VH;\n+        }\n+        public static MemoryAddress ppIncludedFile$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)IndexerCallbacks.ppIncludedFile$VH.get(seg);\n+        }\n+        public static void ppIncludedFile$set( MemorySegment seg, MemoryAddress x) {\n+            IndexerCallbacks.ppIncludedFile$VH.set(seg, x);\n+        }\n+        public static MemoryAddress ppIncludedFile$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)IndexerCallbacks.ppIncludedFile$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void ppIncludedFile$set(MemorySegment seg, long index, MemoryAddress x) {\n+            IndexerCallbacks.ppIncludedFile$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public interface importedASTFile {\n+\n+            jdk.incubator.foreign.MemoryAddress apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);\n+            static MemorySegment allocate(importedASTFile fi) {\n+                return RuntimeHelper.upcallStub(importedASTFile.class, fi, constants$53.importedASTFile$FUNC, \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemoryAddress;\");\n+            }\n+            static MemorySegment allocate(importedASTFile fi, NativeScope scope) {\n+                return allocate(fi).handoff(scope);\n+            }\n+        }\n+\n+        static final VarHandle importedASTFile$VH = MemoryHandles.asAddressVarHandle(IndexerCallbacks$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"importedASTFile\")));\n+        public static VarHandle importedASTFile$VH() {\n+            return IndexerCallbacks.importedASTFile$VH;\n+        }\n+        public static MemoryAddress importedASTFile$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)IndexerCallbacks.importedASTFile$VH.get(seg);\n+        }\n+        public static void importedASTFile$set( MemorySegment seg, MemoryAddress x) {\n+            IndexerCallbacks.importedASTFile$VH.set(seg, x);\n+        }\n+        public static MemoryAddress importedASTFile$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)IndexerCallbacks.importedASTFile$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void importedASTFile$set(MemorySegment seg, long index, MemoryAddress x) {\n+            IndexerCallbacks.importedASTFile$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public interface startedTranslationUnit {\n+\n+            jdk.incubator.foreign.MemoryAddress apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);\n+            static MemorySegment allocate(startedTranslationUnit fi) {\n+                return RuntimeHelper.upcallStub(startedTranslationUnit.class, fi, constants$53.startedTranslationUnit$FUNC, \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemoryAddress;\");\n+            }\n+            static MemorySegment allocate(startedTranslationUnit fi, NativeScope scope) {\n+                return allocate(fi).handoff(scope);\n+            }\n+        }\n+\n+        static final VarHandle startedTranslationUnit$VH = MemoryHandles.asAddressVarHandle(IndexerCallbacks$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"startedTranslationUnit\")));\n+        public static VarHandle startedTranslationUnit$VH() {\n+            return IndexerCallbacks.startedTranslationUnit$VH;\n+        }\n+        public static MemoryAddress startedTranslationUnit$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)IndexerCallbacks.startedTranslationUnit$VH.get(seg);\n+        }\n+        public static void startedTranslationUnit$set( MemorySegment seg, MemoryAddress x) {\n+            IndexerCallbacks.startedTranslationUnit$VH.set(seg, x);\n+        }\n+        public static MemoryAddress startedTranslationUnit$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)IndexerCallbacks.startedTranslationUnit$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void startedTranslationUnit$set(MemorySegment seg, long index, MemoryAddress x) {\n+            IndexerCallbacks.startedTranslationUnit$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public interface indexDeclaration {\n+\n+            void apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);\n+            static MemorySegment allocate(indexDeclaration fi) {\n+                return RuntimeHelper.upcallStub(indexDeclaration.class, fi, constants$53.indexDeclaration$FUNC, \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)V\");\n+            }\n+            static MemorySegment allocate(indexDeclaration fi, NativeScope scope) {\n+                return allocate(fi).handoff(scope);\n+            }\n+        }\n+\n+        static final VarHandle indexDeclaration$VH = MemoryHandles.asAddressVarHandle(IndexerCallbacks$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"indexDeclaration\")));\n+        public static VarHandle indexDeclaration$VH() {\n+            return IndexerCallbacks.indexDeclaration$VH;\n+        }\n+        public static MemoryAddress indexDeclaration$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)IndexerCallbacks.indexDeclaration$VH.get(seg);\n+        }\n+        public static void indexDeclaration$set( MemorySegment seg, MemoryAddress x) {\n+            IndexerCallbacks.indexDeclaration$VH.set(seg, x);\n+        }\n+        public static MemoryAddress indexDeclaration$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)IndexerCallbacks.indexDeclaration$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void indexDeclaration$set(MemorySegment seg, long index, MemoryAddress x) {\n+            IndexerCallbacks.indexDeclaration$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public interface indexEntityReference {\n+\n+            void apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);\n+            static MemorySegment allocate(indexEntityReference fi) {\n+                return RuntimeHelper.upcallStub(indexEntityReference.class, fi, constants$53.indexEntityReference$FUNC, \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)V\");\n+            }\n+            static MemorySegment allocate(indexEntityReference fi, NativeScope scope) {\n+                return allocate(fi).handoff(scope);\n+            }\n+        }\n+\n+        static final VarHandle indexEntityReference$VH = MemoryHandles.asAddressVarHandle(IndexerCallbacks$struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"indexEntityReference\")));\n+        public static VarHandle indexEntityReference$VH() {\n+            return IndexerCallbacks.indexEntityReference$VH;\n+        }\n+        public static MemoryAddress indexEntityReference$get(MemorySegment seg) {\n+            return (jdk.incubator.foreign.MemoryAddress)IndexerCallbacks.indexEntityReference$VH.get(seg);\n+        }\n+        public static void indexEntityReference$set( MemorySegment seg, MemoryAddress x) {\n+            IndexerCallbacks.indexEntityReference$VH.set(seg, x);\n+        }\n+        public static MemoryAddress indexEntityReference$get(MemorySegment seg, long index) {\n+            return (jdk.incubator.foreign.MemoryAddress)IndexerCallbacks.indexEntityReference$VH.get(seg.asSlice(index*sizeof()));\n+        }\n+        public static void indexEntityReference$set(MemorySegment seg, long index, MemoryAddress x) {\n+            IndexerCallbacks.indexEntityReference$VH.set(seg.asSlice(index*sizeof()), x);\n+        }\n+        public static long sizeof() { return $LAYOUT().byteSize(); }\n+        public static MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\n+        public static MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\n+        public static MemorySegment allocateArray(int len) {\n+            return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }        public static MemorySegment allocateArray(int len, NativeScope scope) {\n+            return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\n+        }\n+        public static MemorySegment allocatePointer() {\n+            return MemorySegment.allocateNative(C_POINTER);\n+        }\n+        public static MemorySegment allocatePointer(NativeScope scope) {\n+            return scope.allocate(C_POINTER);\n+        }\n+        public static MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\n+    }\n+\n+    public interface CXFieldVisitor {\n+\n+        int apply(jdk.incubator.foreign.MemorySegment x0, jdk.incubator.foreign.MemoryAddress x1);\n+        static MemorySegment allocate(CXFieldVisitor fi) {\n+            return RuntimeHelper.upcallStub(CXFieldVisitor.class, fi, constants$53.CXFieldVisitor$FUNC, \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemoryAddress;)I\");\n+        }\n+        static MemorySegment allocate(CXFieldVisitor fi, NativeScope scope) {\n+            return allocate(fi).handoff(scope);\n+        }\n+    }\n+\n+    public static class constants$53 {\n+\n+        static final FunctionDescriptor importedASTFile$FUNC = FunctionDescriptor.of(C_POINTER,\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final FunctionDescriptor startedTranslationUnit$FUNC = FunctionDescriptor.of(C_POINTER,\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final FunctionDescriptor indexDeclaration$FUNC = FunctionDescriptor.ofVoid(\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final FunctionDescriptor indexEntityReference$FUNC = FunctionDescriptor.ofVoid(\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final FunctionDescriptor CXFieldVisitor$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                C_INT.withName(\"xdata\"),\n+                MemoryLayout.ofSequence(3, C_POINTER).withName(\"data\")\n+            ),\n+            C_POINTER\n+        );\n+    }\n+\n+}\n+\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/Index_h.java","additions":12328,"deletions":0,"binary":false,"changes":12328,"status":"added"},{"patch":"@@ -0,0 +1,589 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package jdk.internal.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+ class Index_h_1 {\n+\n+    public static int CXIdxEntity_TemplateSpecialization() {\n+        return (int)3L;\n+    }\n+    public static int CXIdxAttr_Unexposed() {\n+        return (int)0L;\n+    }\n+    public static int CXIdxAttr_IBAction() {\n+        return (int)1L;\n+    }\n+    public static int CXIdxAttr_IBOutlet() {\n+        return (int)2L;\n+    }\n+    public static int CXIdxAttr_IBOutletCollection() {\n+        return (int)3L;\n+    }\n+    public static int CXIdxDeclFlag_Skipped() {\n+        return (int)1L;\n+    }\n+    public static int CXIdxObjCContainer_ForwardRef() {\n+        return (int)0L;\n+    }\n+    public static int CXIdxObjCContainer_Interface() {\n+        return (int)1L;\n+    }\n+    public static int CXIdxObjCContainer_Implementation() {\n+        return (int)2L;\n+    }\n+    public static int CXIdxEntityRef_Direct() {\n+        return (int)1L;\n+    }\n+    public static int CXIdxEntityRef_Implicit() {\n+        return (int)2L;\n+    }\n+    public static int CXSymbolRole_None() {\n+        return (int)0L;\n+    }\n+    public static int CXSymbolRole_Declaration() {\n+        return (int)1L;\n+    }\n+    public static int CXSymbolRole_Definition() {\n+        return (int)2L;\n+    }\n+    public static int CXSymbolRole_Reference() {\n+        return (int)4L;\n+    }\n+    public static int CXSymbolRole_Read() {\n+        return (int)8L;\n+    }\n+    public static int CXSymbolRole_Write() {\n+        return (int)16L;\n+    }\n+    public static int CXSymbolRole_Call() {\n+        return (int)32L;\n+    }\n+    public static int CXSymbolRole_Dynamic() {\n+        return (int)64L;\n+    }\n+    public static int CXSymbolRole_AddressOf() {\n+        return (int)128L;\n+    }\n+    public static int CXSymbolRole_Implicit() {\n+        return (int)256L;\n+    }\n+    public static MethodHandle clang_index_isEntityObjCContainerKind$MH() {\n+        return RuntimeHelper.requireNonNull(constants$0.clang_index_isEntityObjCContainerKind$MH,\"clang_index_isEntityObjCContainerKind\");\n+    }\n+    public static int clang_index_isEntityObjCContainerKind ( int x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$0.clang_index_isEntityObjCContainerKind$MH, \"clang_index_isEntityObjCContainerKind\");\n+        try {\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_index_getObjCContainerDeclInfo$MH() {\n+        return RuntimeHelper.requireNonNull(constants$0.clang_index_getObjCContainerDeclInfo$MH,\"clang_index_getObjCContainerDeclInfo\");\n+    }\n+    public static MemoryAddress clang_index_getObjCContainerDeclInfo ( Addressable x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$0.clang_index_getObjCContainerDeclInfo$MH, \"clang_index_getObjCContainerDeclInfo\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(x0.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_index_getObjCInterfaceDeclInfo$MH() {\n+        return RuntimeHelper.requireNonNull(constants$0.clang_index_getObjCInterfaceDeclInfo$MH,\"clang_index_getObjCInterfaceDeclInfo\");\n+    }\n+    public static MemoryAddress clang_index_getObjCInterfaceDeclInfo ( Addressable x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$0.clang_index_getObjCInterfaceDeclInfo$MH, \"clang_index_getObjCInterfaceDeclInfo\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(x0.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_index_getObjCCategoryDeclInfo$MH() {\n+        return RuntimeHelper.requireNonNull(constants$0.clang_index_getObjCCategoryDeclInfo$MH,\"clang_index_getObjCCategoryDeclInfo\");\n+    }\n+    public static MemoryAddress clang_index_getObjCCategoryDeclInfo ( Addressable x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$0.clang_index_getObjCCategoryDeclInfo$MH, \"clang_index_getObjCCategoryDeclInfo\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(x0.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_index_getObjCProtocolRefListInfo$MH() {\n+        return RuntimeHelper.requireNonNull(constants$0.clang_index_getObjCProtocolRefListInfo$MH,\"clang_index_getObjCProtocolRefListInfo\");\n+    }\n+    public static MemoryAddress clang_index_getObjCProtocolRefListInfo ( Addressable x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$0.clang_index_getObjCProtocolRefListInfo$MH, \"clang_index_getObjCProtocolRefListInfo\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(x0.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_index_getObjCPropertyDeclInfo$MH() {\n+        return RuntimeHelper.requireNonNull(constants$0.clang_index_getObjCPropertyDeclInfo$MH,\"clang_index_getObjCPropertyDeclInfo\");\n+    }\n+    public static MemoryAddress clang_index_getObjCPropertyDeclInfo ( Addressable x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$0.clang_index_getObjCPropertyDeclInfo$MH, \"clang_index_getObjCPropertyDeclInfo\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(x0.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$0 {\n+\n+        static final FunctionDescriptor clang_index_isEntityObjCContainerKind$FUNC = FunctionDescriptor.of(C_INT,\n+            C_INT\n+        );\n+        static final MethodHandle clang_index_isEntityObjCContainerKind$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_index_isEntityObjCContainerKind\",\n+            \"(I)I\",\n+            constants$0.clang_index_isEntityObjCContainerKind$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_index_getObjCContainerDeclInfo$FUNC = FunctionDescriptor.of(C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_index_getObjCContainerDeclInfo$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_index_getObjCContainerDeclInfo\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$0.clang_index_getObjCContainerDeclInfo$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_index_getObjCInterfaceDeclInfo$FUNC = FunctionDescriptor.of(C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_index_getObjCInterfaceDeclInfo$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_index_getObjCInterfaceDeclInfo\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$0.clang_index_getObjCInterfaceDeclInfo$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_index_getObjCCategoryDeclInfo$FUNC = FunctionDescriptor.of(C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_index_getObjCCategoryDeclInfo$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_index_getObjCCategoryDeclInfo\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$0.clang_index_getObjCCategoryDeclInfo$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_index_getObjCProtocolRefListInfo$FUNC = FunctionDescriptor.of(C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_index_getObjCProtocolRefListInfo$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_index_getObjCProtocolRefListInfo\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$0.clang_index_getObjCProtocolRefListInfo$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_index_getObjCPropertyDeclInfo$FUNC = FunctionDescriptor.of(C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_index_getObjCPropertyDeclInfo$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_index_getObjCPropertyDeclInfo\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$0.clang_index_getObjCPropertyDeclInfo$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_index_getIBOutletCollectionAttrInfo$MH() {\n+        return RuntimeHelper.requireNonNull(constants$1.clang_index_getIBOutletCollectionAttrInfo$MH,\"clang_index_getIBOutletCollectionAttrInfo\");\n+    }\n+    public static MemoryAddress clang_index_getIBOutletCollectionAttrInfo ( Addressable x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$1.clang_index_getIBOutletCollectionAttrInfo$MH, \"clang_index_getIBOutletCollectionAttrInfo\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(x0.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_index_getCXXClassDeclInfo$MH() {\n+        return RuntimeHelper.requireNonNull(constants$1.clang_index_getCXXClassDeclInfo$MH,\"clang_index_getCXXClassDeclInfo\");\n+    }\n+    public static MemoryAddress clang_index_getCXXClassDeclInfo ( Addressable x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$1.clang_index_getCXXClassDeclInfo$MH, \"clang_index_getCXXClassDeclInfo\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(x0.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_index_getClientContainer$MH() {\n+        return RuntimeHelper.requireNonNull(constants$1.clang_index_getClientContainer$MH,\"clang_index_getClientContainer\");\n+    }\n+    public static MemoryAddress clang_index_getClientContainer ( Addressable x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$1.clang_index_getClientContainer$MH, \"clang_index_getClientContainer\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(x0.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_index_setClientContainer$MH() {\n+        return RuntimeHelper.requireNonNull(constants$1.clang_index_setClientContainer$MH,\"clang_index_setClientContainer\");\n+    }\n+    public static void clang_index_setClientContainer ( Addressable x0,  Addressable x1) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$1.clang_index_setClientContainer$MH, \"clang_index_setClientContainer\");\n+        try {\n+            mh$.invokeExact(x0.address(), x1.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_index_getClientEntity$MH() {\n+        return RuntimeHelper.requireNonNull(constants$1.clang_index_getClientEntity$MH,\"clang_index_getClientEntity\");\n+    }\n+    public static MemoryAddress clang_index_getClientEntity ( Addressable x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$1.clang_index_getClientEntity$MH, \"clang_index_getClientEntity\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(x0.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_index_setClientEntity$MH() {\n+        return RuntimeHelper.requireNonNull(constants$1.clang_index_setClientEntity$MH,\"clang_index_setClientEntity\");\n+    }\n+    public static void clang_index_setClientEntity ( Addressable x0,  Addressable x1) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$1.clang_index_setClientEntity$MH, \"clang_index_setClientEntity\");\n+        try {\n+            mh$.invokeExact(x0.address(), x1.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$1 {\n+\n+        static final FunctionDescriptor clang_index_getIBOutletCollectionAttrInfo$FUNC = FunctionDescriptor.of(C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_index_getIBOutletCollectionAttrInfo$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_index_getIBOutletCollectionAttrInfo\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$1.clang_index_getIBOutletCollectionAttrInfo$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_index_getCXXClassDeclInfo$FUNC = FunctionDescriptor.of(C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_index_getCXXClassDeclInfo$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_index_getCXXClassDeclInfo\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$1.clang_index_getCXXClassDeclInfo$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_index_getClientContainer$FUNC = FunctionDescriptor.of(C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_index_getClientContainer$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_index_getClientContainer\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$1.clang_index_getClientContainer$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_index_setClientContainer$FUNC = FunctionDescriptor.ofVoid(\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_index_setClientContainer$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_index_setClientContainer\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)V\",\n+            constants$1.clang_index_setClientContainer$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_index_getClientEntity$FUNC = FunctionDescriptor.of(C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_index_getClientEntity$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_index_getClientEntity\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$1.clang_index_getClientEntity$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_index_setClientEntity$FUNC = FunctionDescriptor.ofVoid(\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_index_setClientEntity$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_index_setClientEntity\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)V\",\n+            constants$1.clang_index_setClientEntity$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_IndexAction_create$MH() {\n+        return RuntimeHelper.requireNonNull(constants$2.clang_IndexAction_create$MH,\"clang_IndexAction_create\");\n+    }\n+    public static MemoryAddress clang_IndexAction_create ( Addressable CIdx) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$2.clang_IndexAction_create$MH, \"clang_IndexAction_create\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(CIdx.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_IndexAction_dispose$MH() {\n+        return RuntimeHelper.requireNonNull(constants$2.clang_IndexAction_dispose$MH,\"clang_IndexAction_dispose\");\n+    }\n+    public static void clang_IndexAction_dispose ( Addressable x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$2.clang_IndexAction_dispose$MH, \"clang_IndexAction_dispose\");\n+        try {\n+            mh$.invokeExact(x0.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXIndexOpt_None() {\n+        return (int)0L;\n+    }\n+    public static int CXIndexOpt_SuppressRedundantRefs() {\n+        return (int)1L;\n+    }\n+    public static int CXIndexOpt_IndexFunctionLocalSymbols() {\n+        return (int)2L;\n+    }\n+    public static int CXIndexOpt_IndexImplicitTemplateInstantiations() {\n+        return (int)4L;\n+    }\n+    public static int CXIndexOpt_SuppressWarnings() {\n+        return (int)8L;\n+    }\n+    public static int CXIndexOpt_SkipParsedBodiesInSession() {\n+        return (int)16L;\n+    }\n+    public static MethodHandle clang_indexSourceFile$MH() {\n+        return RuntimeHelper.requireNonNull(constants$2.clang_indexSourceFile$MH,\"clang_indexSourceFile\");\n+    }\n+    public static int clang_indexSourceFile ( Addressable x0,  Addressable client_data,  Addressable index_callbacks,  int index_callbacks_size,  int index_options,  Addressable source_filename,  Addressable command_line_args,  int num_command_line_args,  Addressable unsaved_files,  int num_unsaved_files,  Addressable out_TU,  int TU_options) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$2.clang_indexSourceFile$MH, \"clang_indexSourceFile\");\n+        try {\n+            return (int)mh$.invokeExact(x0.address(), client_data.address(), index_callbacks.address(), index_callbacks_size, index_options, source_filename.address(), command_line_args.address(), num_command_line_args, unsaved_files.address(), num_unsaved_files, out_TU.address(), TU_options);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_indexSourceFileFullArgv$MH() {\n+        return RuntimeHelper.requireNonNull(constants$2.clang_indexSourceFileFullArgv$MH,\"clang_indexSourceFileFullArgv\");\n+    }\n+    public static int clang_indexSourceFileFullArgv ( Addressable x0,  Addressable client_data,  Addressable index_callbacks,  int index_callbacks_size,  int index_options,  Addressable source_filename,  Addressable command_line_args,  int num_command_line_args,  Addressable unsaved_files,  int num_unsaved_files,  Addressable out_TU,  int TU_options) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$2.clang_indexSourceFileFullArgv$MH, \"clang_indexSourceFileFullArgv\");\n+        try {\n+            return (int)mh$.invokeExact(x0.address(), client_data.address(), index_callbacks.address(), index_callbacks_size, index_options, source_filename.address(), command_line_args.address(), num_command_line_args, unsaved_files.address(), num_unsaved_files, out_TU.address(), TU_options);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_indexTranslationUnit$MH() {\n+        return RuntimeHelper.requireNonNull(constants$2.clang_indexTranslationUnit$MH,\"clang_indexTranslationUnit\");\n+    }\n+    public static int clang_indexTranslationUnit ( Addressable x0,  Addressable client_data,  Addressable index_callbacks,  int index_callbacks_size,  int index_options,  Addressable x5) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$2.clang_indexTranslationUnit$MH, \"clang_indexTranslationUnit\");\n+        try {\n+            return (int)mh$.invokeExact(x0.address(), client_data.address(), index_callbacks.address(), index_callbacks_size, index_options, x5.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_indexLoc_getFileLocation$MH() {\n+        return RuntimeHelper.requireNonNull(constants$2.clang_indexLoc_getFileLocation$MH,\"clang_indexLoc_getFileLocation\");\n+    }\n+    public static void clang_indexLoc_getFileLocation ( MemorySegment loc,  Addressable indexFile,  Addressable file,  Addressable line,  Addressable column,  Addressable offset) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$2.clang_indexLoc_getFileLocation$MH, \"clang_indexLoc_getFileLocation\");\n+        try {\n+            mh$.invokeExact(loc, indexFile.address(), file.address(), line.address(), column.address(), offset.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static class constants$2 {\n+\n+        static final FunctionDescriptor clang_IndexAction_create$FUNC = FunctionDescriptor.of(C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_IndexAction_create$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_IndexAction_create\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+            constants$2.clang_IndexAction_create$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_IndexAction_dispose$FUNC = FunctionDescriptor.ofVoid(\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_IndexAction_dispose$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_IndexAction_dispose\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;)V\",\n+            constants$2.clang_IndexAction_dispose$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_indexSourceFile$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER,\n+            C_POINTER,\n+            C_POINTER,\n+            C_INT,\n+            C_INT,\n+            C_POINTER,\n+            C_POINTER,\n+            C_INT,\n+            C_POINTER,\n+            C_INT,\n+            C_POINTER,\n+            C_INT\n+        );\n+        static final MethodHandle clang_indexSourceFile$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_indexSourceFile\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;IILjdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;ILjdk\/incubator\/foreign\/MemoryAddress;ILjdk\/incubator\/foreign\/MemoryAddress;I)I\",\n+            constants$2.clang_indexSourceFile$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_indexSourceFileFullArgv$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER,\n+            C_POINTER,\n+            C_POINTER,\n+            C_INT,\n+            C_INT,\n+            C_POINTER,\n+            C_POINTER,\n+            C_INT,\n+            C_POINTER,\n+            C_INT,\n+            C_POINTER,\n+            C_INT\n+        );\n+        static final MethodHandle clang_indexSourceFileFullArgv$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_indexSourceFileFullArgv\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;IILjdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;ILjdk\/incubator\/foreign\/MemoryAddress;ILjdk\/incubator\/foreign\/MemoryAddress;I)I\",\n+            constants$2.clang_indexSourceFileFullArgv$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_indexTranslationUnit$FUNC = FunctionDescriptor.of(C_INT,\n+            C_POINTER,\n+            C_POINTER,\n+            C_POINTER,\n+            C_INT,\n+            C_INT,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_indexTranslationUnit$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_indexTranslationUnit\",\n+            \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;IILjdk\/incubator\/foreign\/MemoryAddress;)I\",\n+            constants$2.clang_indexTranslationUnit$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_indexLoc_getFileLocation$FUNC = FunctionDescriptor.ofVoid(\n+            MemoryLayout.ofStruct(\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+                C_INT.withName(\"int_data\"),\n+                MemoryLayout.ofPaddingBits(32)\n+            ),\n+            C_POINTER,\n+            C_POINTER,\n+            C_POINTER,\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_indexLoc_getFileLocation$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_indexLoc_getFileLocation\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)V\",\n+            constants$2.clang_indexLoc_getFileLocation$FUNC, false\n+        );\n+    }\n+\n+    public static MethodHandle clang_indexLoc_getCXSourceLocation$MH() {\n+        return RuntimeHelper.requireNonNull(constants$3.clang_indexLoc_getCXSourceLocation$MH,\"clang_indexLoc_getCXSourceLocation\");\n+    }\n+    public static MemorySegment clang_indexLoc_getCXSourceLocation ( MemorySegment loc) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$3.clang_indexLoc_getCXSourceLocation$MH, \"clang_indexLoc_getCXSourceLocation\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(loc);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Type_visitFields$MH() {\n+        return RuntimeHelper.requireNonNull(constants$3.clang_Type_visitFields$MH,\"clang_Type_visitFields\");\n+    }\n+    public static int clang_Type_visitFields ( MemorySegment T,  Addressable visitor,  Addressable client_data) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$3.clang_Type_visitFields$MH, \"clang_Type_visitFields\");\n+        try {\n+            return (int)mh$.invokeExact(T, visitor.address(), client_data.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CINDEX_VERSION() {\n+        return (int)59L;\n+    }\n+    public static MemorySegment CINDEX_VERSION_STRING() {\n+        return constants$3.CINDEX_VERSION_STRING$SEGMENT;\n+    }\n+\n+    \/\/ Manual change to handle platform specific library name difference\n+    private static String libName() {\n+        if (System.getProperty(\"os.name\").startsWith(\"Windows\")) {\n+            return \"libclang\";\n+        }\n+        return \"clang\";\n+    }\n+\n+    static final LibraryLookup[] LIBRARIES = RuntimeHelper.libraries(new String[] {\n+        libName()\n+    });\n+\n+    public static class constants$3 {\n+\n+        static final FunctionDescriptor clang_indexLoc_getCXSourceLocation$FUNC = FunctionDescriptor.of(MemoryLayout.ofStruct(\n+            MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+            C_INT.withName(\"int_data\"),\n+            MemoryLayout.ofPaddingBits(32)\n+        ),\n+            MemoryLayout.ofStruct(\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"ptr_data\"),\n+                C_INT.withName(\"int_data\"),\n+                MemoryLayout.ofPaddingBits(32)\n+            )\n+        );\n+        static final MethodHandle clang_indexLoc_getCXSourceLocation$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_indexLoc_getCXSourceLocation\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+            constants$3.clang_indexLoc_getCXSourceLocation$FUNC, false\n+        );\n+        static final FunctionDescriptor clang_Type_visitFields$FUNC = FunctionDescriptor.of(C_INT,\n+            MemoryLayout.ofStruct(\n+                C_INT.withName(\"kind\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(2, C_POINTER).withName(\"data\")\n+            ),\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        static final MethodHandle clang_Type_visitFields$MH = RuntimeHelper.downcallHandle(\n+            LIBRARIES, \"clang_Type_visitFields\",\n+            \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+            constants$3.clang_Type_visitFields$FUNC, false\n+        );\n+        static final MemorySegment CINDEX_VERSION_STRING$SEGMENT = CLinker.toCString(\"0.59\");\n+    }\n+\n+}\n+\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/Index_h_1.java","additions":589,"deletions":0,"binary":false,"changes":589,"status":"added"},{"patch":"@@ -0,0 +1,249 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.clang.libclang;\n+\/\/ Generated by jextract\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.LibraryLookup;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import static jdk.incubator.foreign.CLinker.*;\n+\n+final class RuntimeHelper {\n+    private RuntimeHelper() {}\n+    private final static CLinker LINKER = CLinker.getInstance();\n+    private final static ClassLoader LOADER = RuntimeHelper.class.getClassLoader();\n+    private final static MethodHandles.Lookup MH_LOOKUP = MethodHandles.lookup();\n+\n+    static <T> T requireNonNull(T obj, String symbolName) {\n+        if (obj == null) {\n+            throw new UnsatisfiedLinkError(\"unresolved symbol: \" + symbolName);\n+        }\n+        return obj;\n+    }\n+\n+    static final LibraryLookup[] libraries(String... libNames) {\n+        if (libNames.length == 0) {\n+            return new LibraryLookup[] { LibraryLookup.ofDefault() };\n+        } else {\n+            return Arrays.stream(libNames)\n+                 .map(libName -> {\n+                      if (libName.indexOf(File.separatorChar) != -1) {\n+                          return LibraryLookup.ofPath(Path.of(libName));\n+                      } else {\n+                          return LibraryLookup.ofLibrary(libName);\n+                      }\n+                 })\n+                .toArray(LibraryLookup[]::new);\n+        }\n+    }\n+\n+    static final MemorySegment lookupGlobalVariable(LibraryLookup[] LIBRARIES, String name, MemoryLayout layout) {\n+        return lookup(LIBRARIES, name).map(s ->\n+            nonCloseableNonTransferableSegment(s.address().asSegmentRestricted(layout.byteSize())\n+                    .share())).orElse(null);\n+    }\n+\n+    static final MethodHandle downcallHandle(LibraryLookup[] LIBRARIES, String name, String desc, FunctionDescriptor fdesc, boolean variadic) {\n+        return lookup(LIBRARIES, name).map(\n+                addr -> {\n+                    MethodType mt = MethodType.fromMethodDescriptorString(desc, LOADER);\n+                    return variadic ?\n+                        VarargsInvoker.make(addr, mt, fdesc) :\n+                        LINKER.downcallHandle(addr, mt, fdesc);\n+                }).orElse(null);\n+    }\n+\n+    static final <Z> MemorySegment upcallStub(Class<Z> fi, Z z, FunctionDescriptor fdesc, String mtypeDesc) {\n+        try {\n+            MethodHandle handle = MH_LOOKUP.findVirtual(fi, \"apply\",\n+                    MethodType.fromMethodDescriptorString(mtypeDesc, LOADER));\n+            handle = handle.bindTo(z);\n+            return LINKER.upcallStub(handle, fdesc);\n+        } catch (Throwable ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+\n+    static final MemorySegment nonCloseableNonTransferableSegment(MemorySegment seg) {\n+        return seg.withAccessModes(seg.accessModes() &  ~MemorySegment.CLOSE & ~MemorySegment.HANDOFF);\n+    }\n+\n+    static MemorySegment asArrayRestricted(MemoryAddress addr, MemoryLayout layout, int numElements) {\n+        return nonCloseableSegment(addr.asSegmentRestricted(numElements * layout.byteSize()));\n+    }\n+\n+    \/\/ Internals only below this point\n+    private static final MemorySegment nonCloseableSegment(MemorySegment seg) {\n+        return seg.withAccessModes(seg.accessModes() &  ~MemorySegment.CLOSE);\n+    }\n+\n+    private static final Optional<LibraryLookup.Symbol> lookup(LibraryLookup[] LIBRARIES, String sym) {\n+        return Stream.of(LIBRARIES)\n+                .flatMap(l -> l.lookup(sym).stream())\n+                .findFirst();\n+    }\n+\n+    private static class VarargsInvoker {\n+        private static final MethodHandle INVOKE_MH;\n+        private final Addressable symbol;\n+        private final MethodType varargs;\n+        private final FunctionDescriptor function;\n+\n+        private VarargsInvoker(Addressable symbol, MethodType type, FunctionDescriptor function) {\n+            this.symbol = symbol;\n+            this.varargs = type;\n+            this.function = function;\n+        }\n+\n+        static {\n+            try {\n+                INVOKE_MH = MethodHandles.lookup().findVirtual(VarargsInvoker.class, \"invoke\", MethodType.methodType(Object.class, Object[].class));\n+            } catch (ReflectiveOperationException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        static MethodHandle make(Addressable symbol, MethodType type, FunctionDescriptor function) {\n+            VarargsInvoker invoker = new VarargsInvoker(symbol, type, function);\n+            return INVOKE_MH.bindTo(invoker).asCollector(Object[].class, type.parameterCount())\n+                    .asType(type);\n+        }\n+\n+        private Object invoke(Object[] args) throws Throwable {\n+            \/\/ one trailing Object[]\n+            int nNamedArgs = function.argumentLayouts().size();\n+            assert(args.length == nNamedArgs + 1);\n+            \/\/ The last argument is the array of vararg collector\n+            Object[] unnamedArgs = (Object[]) args[args.length - 1];\n+\n+            int argsCount = nNamedArgs + unnamedArgs.length;\n+            Class<?>[] argTypes = new Class<?>[argsCount];\n+            MemoryLayout[] argLayouts = new MemoryLayout[nNamedArgs + unnamedArgs.length];\n+\n+            int pos = 0;\n+            for (pos = 0; pos < nNamedArgs; pos++) {\n+                argTypes[pos] = varargs.parameterType(pos);\n+                argLayouts[pos] = function.argumentLayouts().get(pos);\n+            }\n+\n+            assert pos == nNamedArgs;\n+            for (Object o: unnamedArgs) {\n+                argTypes[pos] = normalize(o.getClass());\n+                argLayouts[pos] = variadicLayout(argTypes[pos]);\n+                pos++;\n+            }\n+            assert pos == argsCount;\n+\n+            MethodType mt = MethodType.methodType(varargs.returnType(), argTypes);\n+            FunctionDescriptor f = (function.returnLayout().isEmpty()) ?\n+                    FunctionDescriptor.ofVoid(argLayouts) :\n+                    FunctionDescriptor.of(function.returnLayout().get(), argLayouts);\n+            MethodHandle mh = LINKER.downcallHandle(symbol, mt, f);\n+            \/\/ flatten argument list so that it can be passed to an asSpreader MH\n+            Object[] allArgs = new Object[nNamedArgs + unnamedArgs.length];\n+            System.arraycopy(args, 0, allArgs, 0, nNamedArgs);\n+            System.arraycopy(unnamedArgs, 0, allArgs, nNamedArgs, unnamedArgs.length);\n+\n+            return mh.asSpreader(Object[].class, argsCount).invoke(allArgs);\n+        }\n+\n+        private static Class<?> unboxIfNeeded(Class<?> clazz) {\n+            if (clazz == Boolean.class) {\n+                return boolean.class;\n+            } else if (clazz == Void.class) {\n+                return void.class;\n+            } else if (clazz == Byte.class) {\n+                return byte.class;\n+            } else if (clazz == Character.class) {\n+                return char.class;\n+            } else if (clazz == Short.class) {\n+                return short.class;\n+            } else if (clazz == Integer.class) {\n+                return int.class;\n+            } else if (clazz == Long.class) {\n+                return long.class;\n+            } else if (clazz == Float.class) {\n+                return float.class;\n+            } else if (clazz == Double.class) {\n+                return double.class;\n+            } else {\n+                return clazz;\n+            }\n+        }\n+\n+        private Class<?> promote(Class<?> c) {\n+            if (c == byte.class || c == char.class || c == short.class || c == int.class) {\n+                return long.class;\n+            } else if (c == float.class) {\n+                return double.class;\n+            } else {\n+                return c;\n+            }\n+        }\n+\n+        private Class<?> normalize(Class<?> c) {\n+            c = unboxIfNeeded(c);\n+            if (c.isPrimitive()) {\n+                return promote(c);\n+            }\n+            if (MemoryAddress.class.isAssignableFrom(c)) {\n+                return MemoryAddress.class;\n+            }\n+            if (MemorySegment.class.isAssignableFrom(c)) {\n+                return MemorySegment.class;\n+            }\n+            throw new IllegalArgumentException(\"Invalid type for ABI: \" + c.getTypeName());\n+        }\n+\n+        private MemoryLayout variadicLayout(Class<?> c) {\n+            if (c == long.class) {\n+                return C_LONG_LONG;\n+            } else if (c == double.class) {\n+                return C_DOUBLE;\n+            } else if (MemoryAddress.class.isAssignableFrom(c)) {\n+                return C_POINTER;\n+            } else {\n+                throw new IllegalArgumentException(\"Unhandled variadic argument class: \" + c);\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/RuntimeHelper.java","additions":249,"deletions":0,"binary":false,"changes":249,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.jextract.impl;\n+\n+public class ClangException extends RuntimeException {\n+    private static final long serialVersionUID = 0L;\n+\n+    public ClangException(String message) {\n+        super(message);\n+    }\n+\n+    public ClangException(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n+\n+    public ClangException(Throwable cause) {\n+        super(cause);\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/ClangException.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.jextract.impl;\n+\n+public class CompilationFailedException extends RuntimeException {\n+    private static final long serialVersionUID = 1L;\n+\n+    public CompilationFailedException(String msg) {\n+        super(msg);\n+    }\n+\n+    public CompilationFailedException(String msg, Throwable cause) {\n+        super(msg, cause);\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/CompilationFailedException.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,403 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.SequenceLayout;\n+import jdk.incubator.foreign.ValueLayout;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+public class ConstantBuilder extends NestedClassBuilder {\n+\n+    \/\/ set of names generates already\n+    private final Map<String, Constant> namesGenerated = new HashMap<>();\n+\n+    public ConstantBuilder(JavaSourceBuilder enclosing, Kind kind, String className) {\n+        super(enclosing, kind, className);\n+    }\n+\n+    String memberMods() {\n+        return kind == JavaSourceBuilder.Kind.CLASS ?\n+                \"static final \" : \"\";\n+    }\n+\n+    \/\/ public API\n+\n+    public Constant addLayout(String javaName, MemoryLayout layout) {\n+        return emitIfAbsent(javaName, Constant.Kind.LAYOUT,\n+                () -> emitLayoutField(javaName, layout));\n+    }\n+\n+    public Constant addFieldVarHandle(String javaName, String nativeName, VarInfo varInfo,\n+                                      String rootJavaName, List<String> prefixElementNames) {\n+        return addVarHandle(javaName, nativeName, varInfo, rootJavaName, prefixElementNames);\n+    }\n+\n+    public Constant addGlobalVarHandle(String javaName, String nativeName, VarInfo varInfo) {\n+        return addVarHandle(javaName, nativeName, varInfo, null, List.of());\n+    }\n+\n+    private Constant addVarHandle(String javaName, String nativeName, VarInfo varInfo,\n+                                String rootLayoutName, List<String> prefixElementNames) {\n+        return emitIfAbsent(javaName, Constant.Kind.VAR_HANDLE,\n+                () -> emitVarHandleField(javaName, nativeName, varInfo, rootLayoutName, prefixElementNames));\n+    }\n+\n+    public Constant addMethodHandle(String javaName, String nativeName, FunctionInfo functionInfo, boolean virtual) {\n+        return emitIfAbsent(javaName, Constant.Kind.METHOD_HANDLE,\n+                () -> emitMethodHandleField(javaName, nativeName, functionInfo, virtual));\n+    }\n+\n+    public Constant addSegment(String javaName, String nativeName, MemoryLayout layout) {\n+        return emitIfAbsent(javaName, Constant.Kind.SEGMENT,\n+                () -> emitSegmentField(javaName, nativeName, layout));\n+    }\n+\n+    public Constant addFunctionDesc(String javaName, FunctionDescriptor desc) {\n+        return emitIfAbsent(javaName, Constant.Kind.FUNCTION_DESCRIPTOR,\n+                () -> emitFunctionDescField(javaName, desc));\n+    }\n+\n+    public Constant addConstantDesc(String javaName, Class<?> type, Object value) {\n+        if (type == MemorySegment.class) {\n+            return emitIfAbsent(javaName, Constant.Kind.SEGMENT,\n+                    () -> emitConstantSegment(javaName, value));\n+        } else if (type == MemoryAddress.class) {\n+            return emitIfAbsent(javaName, Constant.Kind.ADDRESS,\n+                    () -> emitConstantAddress(javaName, value));\n+        } else {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    static class Constant {\n+\n+        enum Kind {\n+            LAYOUT(MemoryLayout.class, \"$LAYOUT\"),\n+            METHOD_HANDLE(MethodHandle.class, \"$MH\"),\n+            VAR_HANDLE(VarHandle.class, \"$VH\"),\n+            FUNCTION_DESCRIPTOR(FunctionDescriptor.class, \"$FUNC\"),\n+            ADDRESS(MemoryAddress.class, \"$ADDR\"),\n+            SEGMENT(MemorySegment.class, \"$SEGMENT\");\n+\n+            final Class<?> type;\n+            final String nameSuffix;\n+\n+            Kind(Class<?> type, String nameSuffix) {\n+                this.type = type;\n+                this.nameSuffix = nameSuffix;\n+            }\n+\n+            String fieldName(String javaName) {\n+                return javaName + nameSuffix;\n+            }\n+        }\n+\n+        private final String className;\n+        private final String javaName;\n+        private final Kind kind;\n+\n+        Constant(String className, String javaName, Kind kind) {\n+            this.className = className;\n+            this.javaName = javaName;\n+            this.kind = kind;\n+        }\n+\n+        List<String> getterNameParts() {\n+            return List.of(className, javaName, kind.nameSuffix);\n+        }\n+\n+        String accessExpression() {\n+            return className + \".\" + kind.fieldName(javaName);\n+        }\n+\n+        Constant emitGetter(JavaSourceBuilder builder, String mods, Function<List<String>, String> getterNameFunc) {\n+            builder.emitGetter(mods, kind.type, getterNameFunc.apply(getterNameParts()), accessExpression());\n+            return this;\n+        }\n+\n+        Constant emitGetter(JavaSourceBuilder builder, String mods, Function<List<String>, String> getterNameFunc, String symbolName) {\n+            builder.emitGetter(mods, kind.type, getterNameFunc.apply(getterNameParts()), accessExpression(), true, symbolName);\n+            return this;\n+        }\n+\n+        static final Function<List<String>, String> QUALIFIED_NAME =\n+                l -> l.stream().skip(1).collect(Collectors.joining());\n+\n+        static final Function<List<String>, String> JAVA_NAME =\n+                l -> l.get(1);\n+\n+        static final Function<List<String>, String> SUFFIX_ONLY =\n+                l -> l.get(2);\n+    }\n+\n+    \/\/ private generators\n+\n+    public Constant emitIfAbsent(String name, Constant.Kind kind, Supplier<Constant> constantFactory) {\n+        String lookupName = kind.fieldName(name);\n+        Constant constant = namesGenerated.get(lookupName);\n+        if (constant == null) {\n+            constant = constantFactory.get();\n+            if (constant.kind != kind) {\n+                throw new AssertionError(\"Factory return wrong kind of constant; expected: \"\n+                        + kind + \"; found: \" + constant.kind);\n+            }\n+            namesGenerated.put(lookupName, constant);\n+        }\n+        return constant;\n+    }\n+\n+    private Constant emitMethodHandleField(String javaName, String nativeName, FunctionInfo functionInfo, boolean virtual) {\n+        Constant functionDesc = addFunctionDesc(javaName, functionInfo.descriptor());\n+        incrAlign();\n+        String fieldName = Constant.Kind.METHOD_HANDLE.fieldName(javaName);\n+        indent();\n+        append(memberMods() + \"MethodHandle \");\n+        append(fieldName + \" = RuntimeHelper.downcallHandle(\\n\");\n+        incrAlign();\n+        indent();\n+        if (!virtual) {\n+            append(\"LIBRARIES, \\\"\" + nativeName + \"\\\"\");\n+            append(\",\\n\");\n+            indent();\n+        }\n+        append(\"\\\"\" + functionInfo.methodType().toMethodDescriptorString() + \"\\\",\\n\");\n+        indent();\n+        append(functionDesc.accessExpression());\n+        append(\", \");\n+        \/\/ isVariadic\n+        append(functionInfo.isVarargs());\n+        append(\"\\n\");\n+        decrAlign();\n+        indent();\n+        append(\");\\n\");\n+        decrAlign();\n+        return new Constant(className(), javaName, Constant.Kind.METHOD_HANDLE);\n+    }\n+\n+    private Constant emitVarHandleField(String javaName, String nativeName, VarInfo varInfo,\n+                                      String rootLayoutName, List<String> prefixElementNames) {\n+        String layoutAccess = rootLayoutName != null ?\n+                Constant.Kind.LAYOUT.fieldName(rootLayoutName) :\n+                addLayout(javaName, varInfo.layout()).accessExpression();\n+        incrAlign();\n+        String typeName = varInfo.carrier().getName();\n+        boolean isAddr = typeName.contains(\"MemoryAddress\");\n+        if (isAddr) {\n+            typeName = \"long\";\n+        }\n+        indent();\n+        String fieldName = Constant.Kind.VAR_HANDLE.fieldName(javaName);\n+        append(memberMods() + \"VarHandle \" + fieldName + \" = \");\n+        if (isAddr) {\n+            append(\"MemoryHandles.asAddressVarHandle(\");\n+        }\n+        append(layoutAccess);\n+        append(\".varHandle(\" + typeName + \".class\");\n+        if (rootLayoutName != null) {\n+            for (String prefixElementName : prefixElementNames) {\n+                append(\", MemoryLayout.PathElement.groupElement(\\\"\" + prefixElementName + \"\\\")\");\n+            }\n+            append(\", MemoryLayout.PathElement.groupElement(\\\"\" + nativeName + \"\\\")\");\n+        }\n+        append(\")\");\n+        if (isAddr) {\n+            append(\")\");\n+        }\n+        append(\";\\n\");\n+        decrAlign();\n+        return new Constant(className(), javaName, Constant.Kind.VAR_HANDLE);\n+    }\n+\n+    private Constant emitLayoutField(String javaName, MemoryLayout layout) {\n+        String fieldName = Constant.Kind.LAYOUT.fieldName(javaName);\n+        incrAlign();\n+        indent();\n+        append(memberMods() + \"MemoryLayout \" + fieldName + \" = \");\n+        emitLayoutString(layout, false);\n+        append(\";\\n\");\n+        decrAlign();\n+        return new Constant(className(), javaName, Constant.Kind.LAYOUT);\n+    }\n+\n+    private void emitLayoutString(MemoryLayout l, boolean inBitfield) {\n+        if (l instanceof ValueLayout val) {\n+            append(typeToLayoutName(val, inBitfield));\n+        } else if (l instanceof SequenceLayout seq) {\n+            append(\"MemoryLayout.ofSequence(\");\n+            if (seq.elementCount().isPresent()) {\n+                append(seq.elementCount().getAsLong() + \", \");\n+            }\n+            emitLayoutString(seq.elementLayout(), false);\n+            append(\")\");\n+        } else if (l instanceof GroupLayout group) {\n+            if (group.isStruct()) {\n+                append(\"MemoryLayout.ofStruct(\\n\");\n+            } else {\n+                append(\"MemoryLayout.ofUnion(\\n\");\n+            }\n+            incrAlign();\n+            String delim = \"\";\n+            boolean isBitfield = LayoutUtils.isBitfields(group);\n+            for (MemoryLayout e : group.memberLayouts()) {\n+                append(delim);\n+                indent();\n+                emitLayoutString(e, isBitfield);\n+                delim = \",\\n\";\n+            }\n+            append(\"\\n\");\n+            decrAlign();\n+            indent();\n+            append(\")\");\n+        } else {\n+            \/\/ padding\n+            append(\"MemoryLayout.ofPaddingBits(\" + l.bitSize() + \")\");\n+        }\n+        if (l.name().isPresent()) {\n+            append(\".withName(\\\"\" +  l.name().get() + \"\\\")\");\n+        }\n+    }\n+\n+    private Constant emitFunctionDescField(String javaName, FunctionDescriptor desc) {\n+        incrAlign();\n+        indent();\n+        String fieldName = Constant.Kind.FUNCTION_DESCRIPTOR.fieldName(javaName);\n+        final boolean noArgs = desc.argumentLayouts().isEmpty();\n+        append(memberMods());\n+        append(\"FunctionDescriptor \");\n+        append(fieldName);\n+        append(\" = \");\n+        if (desc.returnLayout().isPresent()) {\n+            append(\"FunctionDescriptor.of(\");\n+            emitLayoutString(desc.returnLayout().get(), false);\n+            if (!noArgs) {\n+                append(\",\");\n+            }\n+        } else {\n+            append(\"FunctionDescriptor.ofVoid(\");\n+        }\n+        if (!noArgs) {\n+            append(\"\\n\");\n+            incrAlign();\n+            String delim = \"\";\n+            for (MemoryLayout e : desc.argumentLayouts()) {\n+                append(delim);\n+                indent();\n+                emitLayoutString(e, false);\n+                delim = \",\\n\";\n+            }\n+            append(\"\\n\");\n+            decrAlign();\n+            indent();\n+        }\n+        append(\");\\n\");\n+        decrAlign();\n+        return new Constant(className(), javaName, Constant.Kind.FUNCTION_DESCRIPTOR);\n+    }\n+\n+    private Constant emitConstantSegment(String javaName, Object value) {\n+        incrAlign();\n+        indent();\n+        String fieldName = Constant.Kind.SEGMENT.fieldName(javaName);\n+        append(memberMods());\n+        append(\"MemorySegment \");\n+        append(fieldName);\n+        append(\" = CLinker.toCString(\\\"\");\n+        append(Utils.quote(Objects.toString(value)));\n+        append(\"\\\");\\n\");\n+        decrAlign();\n+        return new Constant(className(), javaName, Constant.Kind.SEGMENT);\n+    }\n+\n+    private Constant emitConstantAddress(String javaName, Object value) {\n+        incrAlign();\n+        indent();\n+        String fieldName = Constant.Kind.ADDRESS.fieldName(javaName);\n+        append(memberMods());\n+        append(\"MemoryAddress \");\n+        append(fieldName);\n+        append(\" = MemoryAddress.ofLong(\");\n+        append(((Number)value).longValue());\n+        append(\"L);\\n\");\n+        decrAlign();\n+        return new Constant(className(), javaName, Constant.Kind.ADDRESS);\n+    }\n+\n+    private static String typeToLayoutName(ValueLayout vl, boolean inBitfields) {\n+        if (UnsupportedLayouts.isUnsupported(vl)) {\n+            return \"MemoryLayout.ofPaddingBits(\" + vl.bitSize() + \")\";\n+        } else if (inBitfields) {\n+            return \"MemoryLayout.ofValueBits(\" + vl.bitSize() + \", ByteOrder.nativeOrder())\";\n+        } else {\n+            CLinker.TypeKind kind = (CLinker.TypeKind) vl.attribute(CLinker.TypeKind.ATTR_NAME).orElseThrow(\n+                    () -> new IllegalStateException(\"Unexpected value layout: could not determine ABI class\"));\n+            return switch (kind) {\n+                case CHAR -> \"C_CHAR\";\n+                case SHORT -> \"C_SHORT\";\n+                case INT -> \"C_INT\";\n+                case LONG -> \"C_LONG\";\n+                case LONG_LONG -> \"C_LONG_LONG\";\n+                case FLOAT -> \"C_FLOAT\";\n+                case DOUBLE -> \"C_DOUBLE\";\n+                case POINTER -> \"C_POINTER\";\n+            };\n+        }\n+    }\n+\n+    private Constant emitSegmentField(String javaName, String nativeName, MemoryLayout layout) {\n+        Constant layoutConstant = addLayout(javaName, layout);\n+        incrAlign();\n+        indent();\n+        String fieldName = Constant.Kind.SEGMENT.fieldName(javaName);\n+        append(memberMods());\n+        append(\"MemorySegment \");\n+        append(fieldName);\n+        append(\" = \");\n+        append(\"RuntimeHelper.lookupGlobalVariable(\");\n+        append(\"LIBRARIES, \\\"\");\n+        append(nativeName);\n+        append(\"\\\", \");\n+        append(layoutConstant.accessExpression());\n+        append(\");\\n\");\n+        decrAlign();\n+        return new Constant(className(), javaName, Constant.Kind.SEGMENT);\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/ConstantBuilder.java","additions":403,"deletions":0,"binary":false,"changes":403,"status":"added"},{"patch":"@@ -0,0 +1,393 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+import java.lang.constant.Constable;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Position;\n+import jdk.incubator.jextract.Type;\n+\n+public abstract class DeclarationImpl implements Declaration {\n+\n+    private final String name;\n+    private final Position pos;\n+    private final Optional<Map<String, List<Constable>>> attributes;\n+\n+    public DeclarationImpl(String name, Position pos, Map<String, List<Constable>> attrs) {\n+        this.name = name;\n+        this.pos = pos;\n+        this.attributes = Optional.ofNullable(attrs);\n+    }\n+\n+    public String toString() {\n+        return new PrettyPrinter().print(this);\n+    }\n+\n+    public String name() {\n+        return name;\n+    }\n+\n+    @Override\n+    public Position pos() {\n+        return pos;\n+    }\n+\n+    @Override\n+    public Optional<List<Constable>> getAttribute(String name) {\n+        return attributes.map(attrs -> attrs.get(name));\n+    }\n+\n+    @Override\n+    public Set<String> attributeNames() { return Collections.unmodifiableSet(\n+            attributes.map(Map::keySet).orElse(Collections.emptySet()));\n+    }\n+\n+    @Override\n+    public Declaration withAttribute(String name, Constable... values) {\n+        if (values == null || values.length == 0) {\n+            return withAttributes(null);\n+        }\n+        var attrs = attributes.map(HashMap::new).orElseGet(HashMap::new);\n+        attrs.put(name, List.of(values));\n+        return withAttributes(attrs);\n+    }\n+\n+    abstract protected Declaration withAttributes(Map<String, List<Constable>> attrs);\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (!(o instanceof Declaration)) return false;\n+        Declaration decl = (Declaration) o;\n+        return name().equals(decl.name());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(name);\n+    }\n+\n+    public static final class TypedefImpl extends DeclarationImpl implements Declaration.Typedef {\n+        final Type type;\n+\n+        public TypedefImpl(Type type, String name, Position pos, Map<String, List<Constable>> attrs) {\n+            super(name, pos, attrs);\n+            this.type = Objects.requireNonNull(type);\n+        }\n+\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitTypedef(this, data);\n+        }\n+\n+        @Override\n+        public Type type() {\n+            return type;\n+        }\n+\n+        @Override\n+        public Typedef withAttributes(Map<String, List<Constable>> attrs) {\n+            return new TypedefImpl(type, name(), pos(), attrs);\n+        }\n+\n+        @Override\n+        public Typedef stripAttributes() {\n+            return new TypedefImpl(type, name(), pos(), null);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Declaration.Typedef)) return false;\n+\n+            Declaration.Typedef other = (Declaration.Typedef) o;\n+            return name().equals(other.name()) &&\n+                    type.equals(other.type());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(super.hashCode(), type);\n+        }\n+    }\n+\n+    public static final class VariableImpl extends DeclarationImpl implements Declaration.Variable {\n+\n+        final Variable.Kind kind;\n+        final Type type;\n+        final Optional<MemoryLayout> layout;\n+\n+        private VariableImpl(Type type, Optional<MemoryLayout> layout, Variable.Kind kind, String name, Position pos, Map<String, List<Constable>> attrs) {\n+            super(name, pos, attrs);\n+            this.kind = Objects.requireNonNull(kind);\n+            this.type = Objects.requireNonNull(type);\n+            this.layout = Objects.requireNonNull(layout);\n+        }\n+\n+        public VariableImpl(Type type, Variable.Kind kind, String name, Position pos) {\n+            this(type, LayoutUtils.getLayout(type), kind, name, pos, null);\n+        }\n+\n+        public VariableImpl(Type type, MemoryLayout layout, Variable.Kind kind, String name, Position pos) {\n+            this(type, Optional.of(layout), kind, name, pos, null);\n+        }\n+\n+        @Override\n+        public Kind kind() {\n+            return kind;\n+        }\n+\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitVariable(this, data);\n+        }\n+\n+        @Override\n+        public Type type() {\n+            return type;\n+        }\n+\n+        @Override\n+        public Optional<MemoryLayout> layout() {\n+            return layout;\n+        }\n+\n+        @Override\n+        public Variable withAttributes(Map<String, List<Constable>> attrs) {\n+            return new VariableImpl(type, layout, kind, name(), pos(), attrs);\n+        }\n+\n+        @Override\n+        public Variable stripAttributes() {\n+            return new VariableImpl(type, layout, kind, name(), pos(), null);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Declaration.Variable)) return false;\n+\n+            Declaration.Variable variable = (Declaration.Variable) o;\n+            if (!super.equals(o)) return false;\n+            return kind == variable.kind() &&\n+                    type.equals(variable.type());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(super.hashCode(), kind, type);\n+        }\n+    }\n+\n+    public static final class FunctionImpl extends DeclarationImpl implements Declaration.Function {\n+\n+        final List<Variable> params;\n+        final Type.Function type;\n+\n+        public FunctionImpl(Type.Function type, List<Variable> params, String name, Position pos) {\n+            this(type, params, name, pos, null);\n+        }\n+\n+        public FunctionImpl(Type.Function type, List<Variable> params, String name, Position pos, Map<String, List<Constable>> attrs) {\n+            super(name, pos, attrs);\n+            this.params = Objects.requireNonNull(params);\n+            this.type = Objects.requireNonNull(type);\n+        }\n+\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitFunction(this, data);\n+        }\n+\n+        @Override\n+        public List<Variable> parameters() {\n+            return params;\n+        }\n+\n+        @Override\n+        public Type.Function type() {\n+            return type;\n+        }\n+\n+        @Override\n+        public Function withAttributes(Map<String, List<Constable>> attrs) {\n+            return new FunctionImpl(type, params, name(), pos(), attrs);\n+        }\n+\n+        @Override\n+        public Function stripAttributes() {\n+            return new FunctionImpl(type, params, name(), pos(), null);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Declaration.Function)) return false;\n+            if (!super.equals(o)) return false;\n+\n+            Declaration.Function function = (Declaration.Function) o;\n+            return type.equals(function.type());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(super.hashCode(), type);\n+        }\n+    }\n+\n+    public static class ScopedImpl extends DeclarationImpl implements Declaration.Scoped {\n+\n+        private final Scoped.Kind kind;\n+        private final List<Declaration> declarations;\n+        private final Optional<MemoryLayout> optLayout;\n+\n+        public ScopedImpl(Kind kind, MemoryLayout layout, List<Declaration> declarations, String name, Position pos) {\n+            this(kind, Optional.of(layout), declarations, name, pos, null);\n+        }\n+\n+        public ScopedImpl(Kind kind, List<Declaration> declarations, String name, Position pos) {\n+            this(kind, Optional.empty(), declarations, name, pos, null);\n+        }\n+\n+        ScopedImpl(Kind kind, Optional<MemoryLayout> optLayout, List<Declaration> declarations,\n+                String name, Position pos, Map<String, List<Constable>> attrs) {\n+            super(name, pos, attrs);\n+            this.kind = Objects.requireNonNull(kind);\n+            this.declarations = Objects.requireNonNull(declarations);\n+            this.optLayout = Objects.requireNonNull(optLayout);\n+        }\n+\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitScoped(this, data);\n+        }\n+\n+        @Override\n+        public List<Declaration> members() {\n+            return declarations;\n+        }\n+\n+        @Override\n+        public Optional<MemoryLayout> layout() {\n+            return optLayout;\n+        }\n+\n+        @Override\n+        public Kind kind() {\n+            return kind;\n+        }\n+\n+        @Override\n+        public Scoped withAttributes(Map<String, List<Constable>> attrs) {\n+            return new ScopedImpl(kind, optLayout, declarations, name(), pos(), attrs);\n+        }\n+\n+        @Override\n+        public Scoped stripAttributes() {\n+            return new ScopedImpl(kind, optLayout, declarations, name(), pos(), null);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Declaration.Scoped)) return false;\n+            if (!super.equals(o)) return false;\n+            Declaration.Scoped scoped = (Declaration.Scoped) o;\n+            return kind == scoped.kind() &&\n+                    declarations.equals(scoped.members());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(super.hashCode(), kind, declarations);\n+        }\n+    }\n+\n+    public static final class ConstantImpl extends DeclarationImpl implements Declaration.Constant {\n+\n+        final Object value;\n+        final Type type;\n+\n+        public ConstantImpl(Type type, Object value, String name, Position pos) {\n+            this(type, value, name, pos, null);\n+        }\n+\n+        public ConstantImpl(Type type, Object value, String name, Position pos, Map<String, List<Constable>> attrs) {\n+            super(name, pos, attrs);\n+            this.value = Objects.requireNonNull(value);\n+            this.type = Objects.requireNonNull(type);\n+        }\n+\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitConstant(this, data);\n+        }\n+\n+        @Override\n+        public Object value() {\n+            return value;\n+        }\n+\n+        @Override\n+        public Type type() {\n+            return type;\n+        }\n+\n+        @Override\n+        public Constant withAttributes(Map<String, List<Constable>> attrs) {\n+            return new ConstantImpl(type, value, name(), pos(), attrs);\n+        }\n+\n+        @Override\n+        public Constant stripAttributes() {\n+            return new ConstantImpl(type, value, name(), pos(), null);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Declaration.Constant)) return false;\n+            if (!super.equals(o)) return false;\n+            Declaration.Constant constant = (Declaration.Constant) o;\n+            return value.equals(constant.value()) &&\n+                    type.equals(constant.type());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(super.hashCode(), value, type);\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/DeclarationImpl.java","additions":393,"deletions":0,"binary":false,"changes":393,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Position;\n+\n+public final class Filter {\n+    private Filter() {}\n+\n+    public static Declaration.Scoped filter(Declaration.Scoped decl, String... validNames) {\n+        Declaration[] newMembers = decl.members().stream()\n+                .filter(d -> filterDecl(d, validNames))\n+                .toArray(Declaration[]::new);\n+        return Declaration.toplevel(decl.pos(), newMembers);\n+    }\n+\n+    private static boolean filterDecl(Declaration d, String... validNames) {\n+        if (d.pos() == Position.NO_POSITION) {\n+            return false;\n+        } else {\n+            for (String s : validNames) {\n+                String pathName = d.pos().path().toString();\n+                if (pathName.contains(s)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/Filter.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.foreign.*;\n+\n+import jdk.internal.jextract.impl.ConstantBuilder.Constant;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class FunctionalInterfaceBuilder extends NestedClassBuilder {\n+\n+    private static final String MEMBER_MODS = \"static\";\n+\n+    private final MethodType fiType;\n+    private final FunctionDescriptor fiDesc;\n+\n+    FunctionalInterfaceBuilder(JavaSourceBuilder enclosing, String className, MethodType fiType,\n+                               FunctionDescriptor fiDesc) {\n+        super(enclosing, Kind.INTERFACE, className);\n+        this.fiType = fiType;\n+        this.fiDesc = fiDesc;\n+    }\n+\n+    @Override\n+    JavaSourceBuilder classEnd() {\n+        emitFunctionalInterfaceMethod();\n+        emitFunctionalFactories();\n+        emitFunctionalRestrictedFactory();\n+        return super.classEnd();\n+    }\n+\n+    \/\/ private generation\n+\n+    private void emitFunctionalInterfaceMethod() {\n+        incrAlign();\n+        indent();\n+        append(fiType.returnType().getName() + \" apply(\");\n+        String delim = \"\";\n+        for (int i = 0 ; i < fiType.parameterCount(); i++) {\n+            append(delim + fiType.parameterType(i).getName() + \" x\" + i);\n+            delim = \", \";\n+        }\n+        append(\");\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitFunctionalFactories() {\n+        emitWithConstantClass(className(), constantBuilder -> {\n+            Constant functionDesc = constantBuilder.addFunctionDesc(className(), fiDesc);\n+            incrAlign();\n+            indent();\n+            append(MEMBER_MODS + \" MemorySegment allocate(\" + className() + \" fi) {\\n\");\n+            incrAlign();\n+            indent();\n+            append(\"return RuntimeHelper.upcallStub(\" + className() + \".class, fi, \" + functionDesc.accessExpression() + \", \" +\n+                    \"\\\"\" + fiType.toMethodDescriptorString() + \"\\\");\\n\");\n+            decrAlign();\n+            indent();\n+            append(\"}\\n\");\n+            indent();\n+            append(MEMBER_MODS + \" MemorySegment allocate(\" + className() + \" fi, NativeScope scope) {\\n\");\n+            incrAlign();\n+            indent();\n+            append(\"return allocate(fi).handoff(scope);\\n\");\n+            decrAlign();\n+            indent();\n+            append(\"}\\n\");\n+            decrAlign();\n+        });\n+    }\n+\n+    private void emitFunctionalRestrictedFactory() {\n+        emitWithConstantClass(className(), constantBuilder -> {\n+            Constant mhConstant = constantBuilder.addMethodHandle(className(), className(), FunctionInfo.ofFunctionPointer(fiType, fiDesc), true);\n+            incrAlign();\n+            indent();\n+            append(MEMBER_MODS + \" \" + className() + \" ofAddressRestricted(MemoryAddress addr) {\\n\");\n+            incrAlign();\n+            indent();\n+            append(\"return new \" + className() + \"() {\\n\");\n+            incrAlign();\n+            indent();\n+            append(\"public \" + fiType.returnType().getName() + \" apply(\");\n+            String delim = \"\";\n+            for (int i = 0 ; i < fiType.parameterCount(); i++) {\n+                append(delim + fiType.parameterType(i).getName() + \" x\" + i);\n+                delim = \", \";\n+            }\n+            append(\") {\\n\");\n+            incrAlign();\n+            indent();\n+            append(\"try {\\n\");\n+            incrAlign();\n+            indent();\n+            if (!fiType.returnType().equals(void.class)) {\n+                append(\"return (\" + fiType.returnType().getName() + \")\");\n+            }\n+            append(mhConstant.accessExpression() + \".invokeExact((Addressable)addr\");\n+            if (fiType.parameterCount() > 0) {\n+                String params = IntStream.range(0, fiType.parameterCount())\n+                        .mapToObj(i -> \"x\" + i)\n+                        .collect(Collectors.joining(\", \"));\n+                append(\", \" + params);\n+            }\n+            append(\");\\n\");\n+            decrAlign();\n+            indent();\n+            append(\"} catch (Throwable ex$) {\\n\");\n+            incrAlign();\n+            indent();\n+            append(\"throw new AssertionError(\\\"should not reach here\\\", ex$);\\n\");\n+            decrAlign();\n+            indent();\n+            append(\"}\\n\");\n+            decrAlign();\n+            indent();\n+            append(\"}\\n\");\n+            decrAlign();\n+            indent();\n+            append(\"};\\n\");\n+            decrAlign();\n+            indent();\n+            append(\"}\\n\");\n+            decrAlign();\n+        });\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/FunctionalInterfaceBuilder.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Type;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+\n+class FunctionalInterfaceScanner implements Declaration.Visitor<Void, Set<FunctionDescriptor>> {\n+\n+    private final Set<FunctionDescriptor> descriptors;\n+\n+    FunctionalInterfaceScanner(Set<FunctionDescriptor> descriptors) {\n+        this.descriptors = descriptors;\n+    }\n+\n+    Declaration.Scoped scan(Declaration.Scoped decl) {\n+        decl.accept(this, descriptors);\n+        return decl;\n+    }\n+\n+    void scanType(Type t, Set<FunctionDescriptor> functionDescriptors) {\n+        t.accept(new TypeScanner(), functionDescriptors);\n+    }\n+\n+    @Override\n+    public Void visitScoped(Declaration.Scoped d, Set<FunctionDescriptor> functionDescriptors) {\n+        d.members().forEach(m -> m.accept(this, functionDescriptors));\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitFunction(Declaration.Function d, Set<FunctionDescriptor> functionDescriptors) {\n+        scanType(d.type().returnType(), functionDescriptors);\n+        d.parameters().forEach(p -> p.accept(this, functionDescriptors));\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitVariable(Declaration.Variable d, Set<FunctionDescriptor> functionDescriptors) {\n+        scanType(d.type(), functionDescriptors);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitConstant(Declaration.Constant d, Set<FunctionDescriptor> functionDescriptors) {\n+        scanType(d.type(), functionDescriptors);\n+        return null;\n+    }\n+\n+    static class TypeScanner implements Type.Visitor<Void, Set<FunctionDescriptor>> {\n+\n+        @Override\n+        public Void visitPrimitive(Type.Primitive t, Set<FunctionDescriptor> functionDescriptors) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitDelegated(Type.Delegated t, Set<FunctionDescriptor> functionDescriptors) {\n+            return t.type().accept(this, functionDescriptors);\n+        }\n+\n+        @Override\n+        public Void visitFunction(Type.Function t, Set<FunctionDescriptor> functionDescriptors) {\n+            t.returnType().accept(this, functionDescriptors);\n+            t.argumentTypes().forEach(a -> a.accept(this, functionDescriptors));\n+            Optional<FunctionDescriptor> descriptor = Type.descriptorFor(t);\n+            if (descriptor.isPresent()) {\n+                functionDescriptors.add(descriptor.get());\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitDeclared(Type.Declared t, Set<FunctionDescriptor> functionDescriptors) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitArray(Type.Array t, Set<FunctionDescriptor> functionDescriptors) {\n+            return t.elementType().accept(this, functionDescriptors);\n+        }\n+\n+        @Override\n+        public Void visitType(Type t, Set<FunctionDescriptor> functionDescriptors) {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/FunctionalInterfaceScanner.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,290 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.jextract.Type;\n+\n+import jdk.internal.jextract.impl.ConstantBuilder.Constant;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * A helper class to generate header interface class in source form.\n+ * After aggregating various constituents of a .java source, build\n+ * method is called to get overall generated source string.\n+ *\/\n+abstract class HeaderFileBuilder extends JavaSourceBuilder {\n+\n+    private static final String MEMBER_MODS = \"public static\";\n+\n+    private final String superclass;\n+\n+    HeaderFileBuilder(ClassDesc desc, String superclass) {\n+        super(Kind.CLASS, desc);\n+        this.superclass = superclass;\n+    }\n+\n+    @Override\n+    String superClass() {\n+        return superclass;\n+    }\n+\n+    @Override\n+    public void addVar(String javaName, String nativeName, VarInfo varInfo) {\n+        if (varInfo.carrier().equals(MemorySegment.class)) {\n+            emitWithConstantClass(javaName, constantBuilder -> {\n+                constantBuilder.addSegment(javaName, nativeName, varInfo.layout())\n+                        .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME, nativeName);\n+            });\n+        } else {\n+            emitWithConstantClass(javaName, constantBuilder -> {\n+                constantBuilder.addLayout(javaName, varInfo.layout())\n+                        .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME);\n+                Constant vhConstant = constantBuilder.addGlobalVarHandle(javaName, nativeName, varInfo)\n+                        .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME);\n+                Constant segmentConstant = constantBuilder.addSegment(javaName, nativeName, varInfo.layout())\n+                        .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME, nativeName);\n+                emitGlobalGetter(segmentConstant, vhConstant, javaName, nativeName, varInfo.carrier());\n+                emitGlobalSetter(segmentConstant, vhConstant, javaName, nativeName, varInfo.carrier());\n+                if (varInfo.fiName().isPresent()) {\n+                    emitFunctionalInterfaceGetter(varInfo.fiName().get(), javaName);\n+                }\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void addFunction(String javaName, String nativeName, FunctionInfo functionInfo) {\n+        emitWithConstantClass(javaName, constantBuilder -> {\n+            Constant mhConstant = constantBuilder.addMethodHandle(javaName, nativeName, functionInfo, false)\n+                    .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME, nativeName);\n+            emitFunctionWrapper(mhConstant, javaName, nativeName, functionInfo);\n+        });\n+    }\n+\n+    @Override\n+    public void addConstant(String javaName, Class<?> type, Object value) {\n+        if (type.equals(MemorySegment.class) || type.equals(MemoryAddress.class)) {\n+            emitWithConstantClass(javaName, constantBuilder -> {\n+                constantBuilder.addConstantDesc(javaName, type, value)\n+                        .emitGetter(this, MEMBER_MODS, Constant.JAVA_NAME);\n+            });\n+        } else {\n+            emitGetter(MEMBER_MODS, type, javaName, getConstantString(type, value));\n+        }\n+    }\n+\n+    @Override\n+    public void addTypedef(String name, String superClass, Type type) {\n+        if (type instanceof Type.Primitive) {\n+            \/\/ primitive\n+            emitPrimitiveTypedef((Type.Primitive)type, name);\n+        } else {\n+            TypedefBuilder builder = new TypedefBuilder(this, name, superClass);\n+            builder.classBegin();\n+            builder.classEnd();\n+        }\n+    }\n+\n+    \/\/ private generation\n+\n+    private void emitFunctionWrapper(Constant mhConstant, String javaName, String nativeName, FunctionInfo functionInfo) {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS + \" \");\n+        append(functionInfo.methodType().returnType().getSimpleName() + \" \" + javaName + \" (\");\n+        String delim = \"\";\n+        List<String> pExprs = new ArrayList<>();\n+        List<String> paramNames = functionInfo.parameterNames().get();\n+        final int numParams = paramNames.size();\n+        for (int i = 0 ; i < numParams; i++) {\n+            String pName = paramNames.get(i);\n+            if (pName.isEmpty()) {\n+                pName = \"x\" + i;\n+            }\n+            if (functionInfo.methodType().parameterType(i).equals(MemoryAddress.class)) {\n+                pExprs.add(pName + \".address()\");\n+            } else {\n+                pExprs.add(pName);\n+            }\n+            Class<?> pType = functionInfo.methodType().parameterType(i);\n+            if (pType.equals(MemoryAddress.class)) {\n+                pType = Addressable.class;\n+            }\n+            append(delim + \" \" + pType.getSimpleName() + \" \" + pName);\n+            delim = \", \";\n+        }\n+        if (functionInfo.isVarargs()) {\n+            String lastArg = \"x\" + numParams;\n+            if (numParams > 0) {\n+                append(\", \");\n+            }\n+            append(\"Object... \" + lastArg);\n+            pExprs.add(lastArg);\n+        }\n+        append(\") {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"var mh$ = RuntimeHelper.requireNonNull(\");\n+        append(mhConstant.accessExpression());\n+        append(\", \\\"\");\n+        append(nativeName);\n+        append(\"\\\");\\n\");\n+        indent();\n+        append(\"try {\\n\");\n+        incrAlign();\n+        indent();\n+        if (!functionInfo.methodType().returnType().equals(void.class)) {\n+            append(\"return (\" + functionInfo.methodType().returnType().getName() + \")\");\n+        }\n+        append(\"mh$.invokeExact(\" + String.join(\", \", pExprs) + \");\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"} catch (Throwable ex$) {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"throw new AssertionError(\\\"should not reach here\\\", ex$);\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitFunctionalInterfaceGetter(String fiName, String javaName) {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS + \" \");\n+        append(fiName + \" \" + javaName + \" () {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return \" + fiName + \".ofAddressRestricted(\" + javaName + \"$get());\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitPrimitiveTypedef(Type.Primitive primType, String name) {\n+        Type.Primitive.Kind kind = primType.kind();\n+        if (primitiveKindSupported(kind) && !kind.layout().isEmpty()) {\n+            incrAlign();\n+            indent();\n+            append(MEMBER_MODS);\n+            append(\" ValueLayout \");\n+            append(uniqueNestedClassName(name));\n+            append(\" = \");\n+            append(TypeTranslator.typeToLayoutName(kind));\n+            append(\";\\n\");\n+            decrAlign();\n+        }\n+    }\n+\n+    private boolean primitiveKindSupported(Type.Primitive.Kind kind) {\n+        return switch(kind) {\n+            case Short, Int, Long, LongLong, Float, Double, Char -> true;\n+            default -> false;\n+        };\n+    }\n+\n+    private String getConstantString(Class<?> type, Object value) {\n+        StringBuilder buf = new StringBuilder();\n+        if (type == float.class) {\n+            float f = ((Number)value).floatValue();\n+            if (Float.isFinite(f)) {\n+                buf.append(value);\n+                buf.append(\"f\");\n+            } else {\n+                buf.append(\"Float.valueOf(\\\"\");\n+                buf.append(value.toString());\n+                buf.append(\"\\\")\");\n+            }\n+        } else if (type == long.class) {\n+            buf.append(value);\n+            buf.append(\"L\");\n+        } else if (type == double.class) {\n+            double d = ((Number)value).doubleValue();\n+            if (Double.isFinite(d)) {\n+                buf.append(value);\n+                buf.append(\"d\");\n+            } else {\n+                buf.append(\"Double.valueOf(\\\"\");\n+                buf.append(value.toString());\n+                buf.append(\"\\\")\");\n+            }\n+        } else {\n+            buf.append(\"(\" + type.getName() + \")\");\n+            buf.append(value + \"L\");\n+        }\n+        return buf.toString();\n+    }\n+\n+    private void emitGlobalGetter(Constant segmentConstant, Constant vhConstant, String javaName, String nativeName, Class<?> type) {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS + \" \" + type.getSimpleName() + \" \" + javaName + \"$get() {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return (\" + type.getName() + \") \");\n+        append(vhConstant.accessExpression());\n+        append(\".get(RuntimeHelper.requireNonNull(\");\n+        append(segmentConstant.accessExpression());\n+        append(\", \\\"\");\n+        append(nativeName);\n+        append(\"\\\"));\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitGlobalSetter(Constant segmentConstant, Constant vhConstant, String javaName, String nativeName, Class<?> type) {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS + \" void \" + javaName + \"$set(\" + \" \" + type.getSimpleName() + \" x) {\\n\");\n+        incrAlign();\n+        indent();\n+        append(vhConstant.accessExpression());\n+        append(\".set(RuntimeHelper.requireNonNull(\");\n+        append(segmentConstant.accessExpression());\n+        append(\", \\\"\");\n+        append(nativeName);\n+        append(\"\\\"), x);\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/HeaderFileBuilder.java","additions":290,"deletions":0,"binary":false,"changes":290,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.jextract.impl;\n+\n+import javax.tools.FileObject;\n+import javax.tools.ForwardingJavaFileManager;\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileManager;\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n+import javax.tools.ToolProvider;\n+import java.io.*;\n+import java.io.Writer;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+final class InMemoryJavaCompiler {\n+    private InMemoryJavaCompiler() {}\n+\n+    static List<JavaFileObject> compile(List<JavaFileObject> files,\n+                                        String... options) {\n+        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n+        FileManager fileManager = new FileManager(compiler.getStandardFileManager(null, null, null));\n+\n+        Writer writer = new StringWriter();\n+        Boolean exitCode = compiler.getTask(writer, fileManager, null, Arrays.asList(options), null, files).call();\n+        if (!exitCode) {\n+            throw new CompilationFailedException(\"In memory compilation failed: \" + writer.toString());\n+        }\n+        return fileManager.getCompiledFiles();\n+    }\n+\n+    static JavaFileObject jfoFromByteArray(URI uri, byte[] bytes) {\n+        return new SimpleJavaFileObject(uri, JavaFileObject.Kind.CLASS) {\n+            @Override\n+            public InputStream openInputStream() {\n+                return new ByteArrayInputStream(bytes);\n+            }\n+        };\n+    }\n+\n+    static JavaFileObject jfoFromString(URI uri, String contents) {\n+        return new SimpleJavaFileObject(uri, JavaFileObject.Kind.SOURCE) {\n+            @Override\n+            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n+                return contents;\n+            }\n+        };\n+    }\n+\n+    \/\/ Wraper for class byte array\n+    private static class ClassFile extends SimpleJavaFileObject {\n+        private final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+\n+        protected ClassFile(String name) {\n+            super(URI.create(name.replace('.', '\/') + Kind.CLASS.extension), Kind.CLASS);\n+        }\n+\n+        @Override\n+        public ByteArrayOutputStream openOutputStream() {\n+            return this.baos;\n+        }\n+\n+        @Override\n+        public InputStream openInputStream() {\n+            return new ByteArrayInputStream(baos.toByteArray());\n+        }\n+    }\n+\n+    \/\/ File manager which spawns ClassFile instances on demand\n+    private static class FileManager extends ForwardingJavaFileManager<JavaFileManager> {\n+        private final List<JavaFileObject> compiled = new ArrayList<>();\n+\n+        protected FileManager(JavaFileManager fileManager) {\n+            super(fileManager);\n+        }\n+\n+        @Override\n+        public JavaFileObject getJavaFileForOutput(Location location, String name, JavaFileObject.Kind kind, FileObject source) throws IOException {\n+            JavaFileObject out = new ClassFile(name);\n+            compiled.add(out);\n+            return out;\n+        }\n+\n+        public List<JavaFileObject> getCompiledFiles() {\n+            return compiled;\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/InMemoryJavaCompiler.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,315 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Type;\n+\n+import javax.tools.JavaFileObject;\n+import java.lang.constant.ClassDesc;\n+import java.lang.invoke.MethodType;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+\n+\/**\n+ * Superclass for .java source generator classes.\n+ *\/\n+abstract class JavaSourceBuilder {\n+\n+    enum Kind {\n+        CLASS(\"class\"),\n+        INTERFACE(\"interface\");\n+\n+        final String kindName;\n+\n+        Kind(String kindName) {\n+            this.kindName = kindName;\n+        }\n+    }\n+\n+    final Kind kind;\n+    final ClassDesc desc;\n+\n+    Set<String> nestedClassNames = new HashSet<>();\n+    int nestedClassNameCount = 0;\n+\n+    \/\/ code buffer\n+    private StringBuilder sb = new StringBuilder();\n+    \/\/ current line alignment (number of 4-spaces)\n+    private int align;\n+\n+    JavaSourceBuilder(int align, Kind kind, ClassDesc desc) {\n+        this.align = align;\n+        this.kind = kind;\n+        this.desc = desc;\n+    }\n+\n+    JavaSourceBuilder(Kind kind, ClassDesc desc) {\n+        this(0, kind, desc);\n+    }\n+\n+    String className() {\n+        return desc.displayName();\n+    }\n+\n+    String fullName() {\n+        return className();\n+    }\n+\n+    final String packageName() {\n+        return desc.packageName();\n+    }\n+\n+    String superClass() {\n+        return null;\n+    }\n+\n+    String mods() {\n+        return \"public \";\n+    }\n+\n+    void classBegin() {\n+        emitPackagePrefix();\n+        emitImportSection();\n+\n+        indent();\n+        append(mods());\n+        append(kind.kindName + \" \" + className());\n+        if (superClass() != null) {\n+            append(\" extends \");\n+            append(superClass());\n+        }\n+        append(\" {\\n\\n\");\n+    }\n+\n+    JavaSourceBuilder classEnd() {\n+        if (constantBuilder != null) {\n+            constantBuilder.classEnd();\n+        }\n+        indent();\n+        append(\"}\\n\\n\");\n+        return this;\n+    }\n+\n+    \/\/ public API (used by OutputFactory)\n+\n+    public static record FunctionInfo(\n+            MethodType methodType,\n+            FunctionDescriptor descriptor,\n+            boolean isVarargs,\n+            Optional<List<String>> parameterNames) {\n+\n+        static FunctionInfo ofFunction(MethodType methodType, FunctionDescriptor functionDescriptor, boolean isVarargs, List<String> parameterNames) {\n+            return new FunctionInfo(methodType, functionDescriptor, isVarargs, Optional.of(parameterNames));\n+        }\n+\n+        static FunctionInfo ofFunctionPointer(MethodType methodType, FunctionDescriptor functionDescriptor) {\n+            return new FunctionInfo(methodType, functionDescriptor, false, Optional.empty());\n+        }\n+    }\n+\n+    public static record VarInfo(\n+            Class<?> carrier,\n+            MemoryLayout layout,\n+            Optional<String> fiName) {\n+\n+        static VarInfo ofVar(Class<?> carrier, MemoryLayout layout) {\n+            return new VarInfo(carrier, layout, Optional.empty());\n+        }\n+\n+        static VarInfo ofFunctionalPointerVar(Class<?> carrier, MemoryLayout layout, String fiName) {\n+            return new VarInfo(carrier, layout, Optional.ofNullable(fiName));\n+        }\n+    }\n+\n+    public void addVar(String javaName, String nativeName, VarInfo varInfo) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public void addFunction(String javaName, String nativeName, FunctionInfo functionInfo) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public void addConstant(String javaName, Class<?> type, Object value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public void addTypedef(String name, String superClass, Type type) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public StructBuilder addStruct(String name, Declaration parent, GroupLayout layout, Type type) {\n+        return new StructBuilder(this, name.isEmpty() ? parent.name() : name, layout, type);\n+    }\n+\n+    public String addFunctionalInterface(String name, FunctionInfo functionInfo) {\n+        FunctionalInterfaceBuilder builder = new FunctionalInterfaceBuilder(this, name,\n+                functionInfo.methodType(), functionInfo.descriptor());\n+        builder.classBegin();\n+        builder.classEnd();\n+        return builder.fullName();\n+    }\n+\n+    public List<JavaFileObject> toFiles() {\n+        classEnd();\n+        String res = build();\n+        return List.of(Utils.fileFromString(packageName(), className(), res));\n+    }\n+\n+    \/\/ Internal generation helpers (used by other builders)\n+\n+    int align() {\n+        return align;\n+    }\n+\n+    void append(String s) {\n+        sb.append(s);\n+    }\n+\n+    void append(char c) {\n+        sb.append(c);\n+    }\n+\n+    void append(boolean b) {\n+        sb.append(b);\n+    }\n+\n+    void append(long l) {\n+        sb.append(l);\n+    }\n+\n+    void indent() {\n+        for (int i = 0; i < align; i++) {\n+            append(\"    \");\n+        }\n+    }\n+\n+    void incrAlign() {\n+        align++;\n+    }\n+\n+    void decrAlign() {\n+        align--;\n+    }\n+\n+    String build() {\n+        String s = sb.toString();\n+        sb = null;\n+        return s;\n+    }\n+\n+    \/*\n+     * We may have case-insensitive name collision! A C program may have\n+     * defined structs\/unions\/typedefs with the names FooS, fooS, FoOs, fOOs.\n+     * Because we map structs\/unions\/typedefs to nested classes of header classes,\n+     * such a case-insensitive name collision is problematic. This is because in\n+     * a case-insensitive file system javac will overwrite classes for\n+     * Header$CFooS, Header$CfooS, Header$CFoOs and so on! We solve this by\n+     * generating unique case-insensitive names for nested classes.\n+     *\/\n+    final String uniqueNestedClassName(String name) {\n+        name = Utils.javaSafeIdentifier(name);\n+        var notSeen = nestedClassNames.add(name.toLowerCase());\n+        var notEnclosed = !isEnclosedBySameName(name.toLowerCase());\n+        return notSeen && notEnclosed? name : (name + \"$\" + nestedClassNameCount++);\n+    }\n+\n+    \/\/ is the name enclosed enclosed by a class of the same name?\n+    boolean isEnclosedBySameName(String name) {\n+        return className().equals(name);\n+    }\n+\n+    protected void emitPackagePrefix() {\n+        assert packageName().indexOf('\/') == -1 : \"package name invalid: \" + packageName();\n+        append(\"\/\/ Generated by jextract\\n\\n\");\n+        if (!packageName().isEmpty()) {\n+            append(\"package \");\n+            append(packageName());\n+            append(\";\\n\\n\");\n+        }\n+    }\n+\n+    protected void emitImportSection() {\n+        append(\"import java.lang.invoke.MethodHandle;\\n\");\n+        append(\"import java.lang.invoke.VarHandle;\\n\");\n+        append(\"import java.nio.ByteOrder;\\n\");\n+        append(\"import jdk.incubator.foreign.*;\\n\");\n+        append(\"import static \");\n+        append(OutputFactory.C_LANG_CONSTANTS_HOLDER);\n+        append(\".*;\\n\");\n+    }\n+\n+    protected void emitGetter(String mods, Class<?> type, String name, String access, boolean nullCheck, String symbolName) {\n+        incrAlign();\n+        indent();\n+        append(mods + \" \" + type.getSimpleName() + \" \" +name + \"() {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return \");\n+        if (nullCheck) {\n+            append(\"RuntimeHelper.requireNonNull(\");\n+        }\n+        append(access);\n+        if (nullCheck) {\n+            append(\",\\\"\");\n+            append(symbolName);\n+            append(\"\\\")\");\n+        }\n+        append(\";\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    protected void emitGetter(String mods, Class<?> type, String name, String access) {\n+        emitGetter(mods, type, name, access, false, null);\n+    }\n+\n+    int constant_counter = 0;\n+    int constant_class_index = 0;\n+\n+    static final int CONSTANTS_PER_CLASS = Integer.getInteger(\"jextract.constants.per.class\", 5);\n+    ConstantBuilder constantBuilder;\n+\n+    protected void emitWithConstantClass(String javaName, Consumer<ConstantBuilder> constantConsumer) {\n+        if (constant_counter > CONSTANTS_PER_CLASS || constantBuilder == null) {\n+            if (constantBuilder != null) {\n+                constantBuilder.classEnd();\n+            }\n+            constant_counter = 0;\n+            constantBuilder = new ConstantBuilder(this, Kind.CLASS, \"constants$\" + constant_class_index++);\n+            constantBuilder.classBegin();\n+        }\n+        constantConsumer.accept(constantBuilder);\n+        constant_counter++;\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/JavaSourceBuilder.java","additions":315,"deletions":0,"binary":false,"changes":315,"status":"added"},{"patch":"@@ -0,0 +1,230 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.jextract.Type.Primitive;\n+import jdk.internal.clang.Cursor;\n+import jdk.internal.clang.Type;\n+\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import static jdk.incubator.foreign.CLinker.C_POINTER;\n+\n+\/**\n+ * General Layout utility functions\n+ *\/\n+public final class LayoutUtils {\n+\n+    public static final String JEXTRACT_ANONYMOUS = \"jextract\/anonymous\";\n+    public static final String JEXTRACT_BITFIELDS = \"jextract\/bitfields\";\n+\n+    private LayoutUtils() {}\n+\n+    public static String getName(Type type) {\n+        Cursor c = type.getDeclarationCursor();\n+        if (c.isInvalid()) {\n+            return type.spelling();\n+        }\n+        return getName(c);\n+    }\n+\n+    public static String getName(Cursor cursor) {\n+        return cursor.spelling();\n+    }\n+\n+    public static MemoryLayout getLayout(Type t) {\n+        Supplier<UnsupportedOperationException> unsupported = () ->\n+                new UnsupportedOperationException(\"unsupported: \" + t.kind());\n+        switch(t.kind()) {\n+            case UChar, Char_U:\n+            case SChar, Char_S:\n+                return Primitive.Kind.Char.layout().orElseThrow(unsupported);\n+            case Short:\n+            case UShort:\n+                return Primitive.Kind.Short.layout().orElseThrow(unsupported);\n+            case Int:\n+            case UInt:\n+                return Primitive.Kind.Int.layout().orElseThrow(unsupported);\n+            case ULong:\n+            case Long:\n+                return Primitive.Kind.Long.layout().orElseThrow(unsupported);\n+            case ULongLong:\n+            case LongLong:\n+                return Primitive.Kind.LongLong.layout().orElseThrow(unsupported);\n+            case UInt128:\n+            case Int128:\n+                return Primitive.Kind.Int128.layout().orElseThrow(unsupported);\n+            case Enum:\n+                return valueLayoutForSize(t.size() * 8).layout().orElseThrow(unsupported);\n+            case Bool:\n+                return Primitive.Kind.Bool.layout().orElseThrow(unsupported);\n+            case Float:\n+                return Primitive.Kind.Float.layout().orElseThrow(unsupported);\n+            case Double:\n+                return Primitive.Kind.Double.layout().orElseThrow(unsupported);\n+            case LongDouble:\n+                return Primitive.Kind.LongDouble.layout().orElseThrow(unsupported);\n+            case Complex:\n+                throw new UnsupportedOperationException(\"unsupported: \" + t.kind());\n+            case Record:\n+                return getRecordLayout(t);\n+            case Vector:\n+                return MemoryLayout.ofSequence(t.getNumberOfElements(), getLayout(t.getElementType()));\n+            case ConstantArray:\n+                return MemoryLayout.ofSequence(t.getNumberOfElements(), getLayout(t.getElementType()));\n+            case IncompleteArray:\n+                return MemoryLayout.ofSequence(getLayout(t.getElementType()));\n+            case Unexposed:\n+                Type canonical = t.canonicalType();\n+                if (canonical.equalType(t)) {\n+                    throw new TypeMaker.TypeException(\"Unknown type with same canonical type: \" + t.spelling());\n+                }\n+                return getLayout(canonical);\n+            case Typedef:\n+            case Elaborated:\n+                return getLayout(t.canonicalType());\n+            case Pointer:\n+            case BlockPointer:\n+                return C_POINTER;\n+            default:\n+                throw new UnsupportedOperationException(\"unsupported: \" + t.kind());\n+        }\n+    }\n+\n+    public static Optional<MemoryLayout> getLayout(jdk.incubator.jextract.Type t) {\n+        try {\n+            return Optional.of(getLayoutInternal(t));\n+        } catch (Throwable ex) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    public static MemoryLayout getLayoutInternal(jdk.incubator.jextract.Type t) {\n+        return t.accept(layoutMaker, null);\n+    }\n+\n+    private static jdk.incubator.jextract.Type.Visitor<MemoryLayout, Void> layoutMaker = new jdk.incubator.jextract.Type.Visitor<>() {\n+        @Override\n+        public MemoryLayout visitPrimitive(jdk.incubator.jextract.Type.Primitive t, Void _ignored) {\n+            return t.kind().layout().orElseThrow(UnsupportedOperationException::new);\n+        }\n+\n+        @Override\n+        public MemoryLayout visitDelegated(jdk.incubator.jextract.Type.Delegated t, Void _ignored) {\n+            if (t.kind() == jdk.incubator.jextract.Type.Delegated.Kind.POINTER) {\n+                return C_POINTER;\n+            } else {\n+                return t.type().accept(this, null);\n+            }\n+        }\n+\n+        @Override\n+        public MemoryLayout visitFunction(jdk.incubator.jextract.Type.Function t, Void _ignored) {\n+            \/*\n+             * \/\/ pointer to function declared as function like this\n+             *\n+             * typedef void CB(int);\n+             * void func(CB cb);\n+             *\/\n+            return C_POINTER;\n+        }\n+\n+        @Override\n+        public MemoryLayout visitDeclared(jdk.incubator.jextract.Type.Declared t, Void _ignored) {\n+            return t.tree().layout().orElseThrow(UnsupportedOperationException::new);\n+        }\n+\n+        @Override\n+        public MemoryLayout visitArray(jdk.incubator.jextract.Type.Array t, Void _ignored) {\n+            MemoryLayout elem = t.elementType().accept(this, null);\n+            if (t.elementCount().isPresent()) {\n+                return MemoryLayout.ofSequence(t.elementCount().getAsLong(), elem);\n+            } else {\n+                return MemoryLayout.ofSequence(elem);\n+            }\n+        }\n+\n+        @Override\n+        public MemoryLayout visitType(jdk.incubator.jextract.Type t, Void _ignored) {\n+            throw new UnsupportedOperationException();\n+        }\n+    };\n+\n+    static MemoryLayout getRecordLayout(Type type) {\n+        return RecordLayoutComputer.compute(0, type, type);\n+    }\n+\n+    private static boolean isVoidType(jdk.incubator.jextract.Type type) {\n+        if (type instanceof jdk.incubator.jextract.Type.Primitive) {\n+            jdk.incubator.jextract.Type.Primitive pt = (jdk.incubator.jextract.Type.Primitive)type;\n+            return pt.kind() == jdk.incubator.jextract.Type.Primitive.Kind.Void;\n+        } else if (type instanceof jdk.incubator.jextract.Type.Delegated) {\n+            jdk.incubator.jextract.Type.Delegated dt = (jdk.incubator.jextract.Type.Delegated)type;\n+            return dt.kind() == jdk.incubator.jextract.Type.Delegated.Kind.TYPEDEF? isVoidType(dt.type()) : false;\n+        }\n+        return false;\n+    }\n+\n+    public static Optional<FunctionDescriptor> getDescriptor(jdk.incubator.jextract.Type.Function t) {\n+        try {\n+            MemoryLayout[] args = t.argumentTypes().stream()\n+                    .map(LayoutUtils::getLayoutInternal)\n+                    .toArray(MemoryLayout[]::new);\n+            jdk.incubator.jextract.Type retType = t.returnType();\n+            if (isVoidType(retType)) {\n+                return Optional.of(FunctionDescriptor.ofVoid(args));\n+            } else {\n+                return Optional.of(FunctionDescriptor.of(getLayoutInternal(retType), args));\n+            }\n+        } catch (Throwable ex) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    public static Primitive.Kind valueLayoutForSize(long size) {\n+        return switch ((int) size) {\n+            case 8 -> Primitive.Kind.Char;\n+            case 16 -> Primitive.Kind.Short;\n+            case 32 -> Primitive.Kind.Int;\n+            case 64 -> Primitive.Kind.LongLong;\n+            default -> throw new IllegalStateException(\"Cannot infer container layout\");\n+        };\n+    }\n+\n+    static boolean isBitfields(GroupLayout layout) {\n+        return layout.attribute(JEXTRACT_BITFIELDS).isPresent();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    static <Z extends MemoryLayout> Z setBitfields(Z layout) {\n+        return (Z) layout.withAttribute(JEXTRACT_BITFIELDS, true);\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/LayoutUtils.java","additions":230,"deletions":0,"binary":false,"changes":230,"status":"added"},{"patch":"@@ -0,0 +1,379 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Position;\n+import jdk.incubator.jextract.Type;\n+import jdk.incubator.jextract.JextractTool;\n+import jdk.internal.clang.Cursor;\n+import jdk.internal.clang.CursorKind;\n+import jdk.internal.clang.Diagnostic;\n+import jdk.internal.clang.EvalResult;\n+import jdk.internal.clang.Index;\n+import jdk.internal.clang.LibClang;\n+import jdk.internal.clang.TranslationUnit;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+class MacroParserImpl {\n+\n+    private final ClangReparser reparser;\n+    private final TreeMaker treeMaker;\n+    final MacroTable macroTable;\n+\n+    private MacroParserImpl(ClangReparser reparser, TreeMaker treeMaker) {\n+        this.reparser = reparser;\n+        this.treeMaker = treeMaker;\n+        this.macroTable = new MacroTable();\n+    }\n+\n+    static MacroParserImpl make(TreeMaker treeMaker, TranslationUnit tu, Collection<String> args) {\n+        ClangReparser reparser;\n+        try {\n+            reparser = new ClangReparser(tu, args);\n+        } catch (IOException | Index.ParsingFailedException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+\n+        return new MacroParserImpl(reparser, treeMaker);\n+    }\n+\n+    \/**\n+     * This method attempts to evaluate the macro. Evaluation occurs in two steps: first, an attempt is made\n+     * to see if the macro corresponds to a simple numeric constant. If so, the constant is parsed in Java directly.\n+     * If that is not possible (e.g. because the macro refers to other macro, or has a more complex grammar), fall\n+     * back to use clang evaluation support.\n+     *\/\n+    Optional<Declaration.Constant> parseConstant(Position pos, String name, String[] tokens) {\n+        if (!(pos instanceof TreeMaker.CursorPosition)) {\n+            return Optional.empty();\n+        } else {\n+            Cursor cursor = ((TreeMaker.CursorPosition)pos).cursor();\n+            if (cursor.isMacroFunctionLike()) {\n+                return Optional.empty();\n+            } else if (tokens.length == 2) {\n+                \/\/check for fast path\n+                Integer num = toNumber(tokens[1]);\n+                if (num != null) {\n+                    return Optional.of(treeMaker.createMacro(cursor, name, Type.primitive(Type.Primitive.Kind.Int), (long)num));\n+                }\n+            }\n+            macroTable.enterMacro(name, tokens, cursor);\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private Integer toNumber(String str) {\n+        try {\n+            \/\/ Integer.decode supports '#' hex literals which is not valid in C.\n+            return str.length() > 0 && str.charAt(0) != '#'? Integer.decode(str) : null;\n+        } catch (NumberFormatException nfe) {\n+            return null;\n+        }\n+    }\n+\n+    \/**\n+     * This class allows client to reparse a snippet of code against a given set of include files.\n+     * For performance reasons, the set of includes (which comes from the jextract parser) is compiled\n+     * into a precompiled header, so as to speed to incremental recompilation of the generated snippets.\n+     *\/\n+    static class ClangReparser {\n+        final Path macro;\n+        final Index macroIndex = LibClang.createIndex(true);\n+        final TranslationUnit macroUnit;\n+\n+        public ClangReparser(TranslationUnit tu, Collection<String> args) throws IOException, Index.ParsingFailedException {\n+            Path precompiled = Files.createTempFile(\"jextract$\", \".pch\");\n+            precompiled.toFile().deleteOnExit();\n+            tu.save(precompiled);\n+            this.macro = Files.createTempFile(\"jextract$\", \".h\");\n+            this.macro.toFile().deleteOnExit();\n+            String[] patchedArgs = Stream.concat(\n+                Stream.of(\n+                    \/\/ Avoid system search path, use bundled instead\n+                    \"-nostdinc\",\n+                    \"-ferror-limit=0\",\n+                    \/\/ precompiled header\n+                    \"-include-pch\", precompiled.toAbsolutePath().toString()),\n+                args.stream()).toArray(String[]::new);\n+            this.macroUnit = macroIndex.parse(macro.toAbsolutePath().toString(),\n+                    this::processDiagnostics,\n+                    false, \/\/add serialization support (needed for macros)\n+                    patchedArgs);\n+        }\n+\n+        void processDiagnostics(Diagnostic diag) {\n+            if (JextractTool.DEBUG) {\n+                System.err.println(\"Error while processing macro: \" + diag.spelling());\n+            }\n+        }\n+\n+        public Stream<Cursor> reparse(String snippet) {\n+            macroUnit.reparse(this::processDiagnostics,\n+                    Index.UnsavedFile.of(macro, snippet));\n+            return macroUnit.getCursor().children();\n+        }\n+    }\n+\n+    \/**\n+     * This abstraction is used to collect all macros which could not be interpreted during {@link #parseConstant(Position, String, String[])}.\n+     * All unparsed macros in the table can have three different states: UNPARSED (which means the macro has not been parsed yet),\n+     * SUCCESS (which means the macro has been parsed and has a type and a value) and FAILURE, which means the macro has been\n+     * parsed with some errors, but for which we were at least able to infer a type.\n+     *\n+     * The reparsing process goes as follows:\n+     * 1. all unparsed macros are added to the table in the UNPARSED state.\n+     * 2. a snippet for all macros in the UNPARSED state is compiled and the table state is updated\n+     * 3. a recovery snippet for all macros in the FAILURE state is compiled and the table state is updated again\n+     * 4. we repeat from (2) until no further progress is made.\n+     * 5. we return a list of macro which are in the SUCCESS state.\n+     *\n+     * State transitions in the table are as follows:\n+     * - an UNPARSED macro can go to either SUCCESS, to FAILURE or be removed (if not even a type can be inferred)\n+     * - a FAILURE macro can go to either SUCCESS (if recovery step succeds) or be removed\n+     * - a SUCCESS macro cannot go in any other state\n+     *\/\n+    class MacroTable {\n+\n+        final Map<String, Entry> macrosByMangledName = new LinkedHashMap<>();\n+\n+        abstract class Entry {\n+            final String name;\n+            final String[] tokens;\n+            final Cursor cursor;\n+\n+            Entry(String name, String[] tokens, Cursor cursor) {\n+                this.name = name;\n+                this.tokens = tokens;\n+                this.cursor = cursor;\n+            }\n+\n+            String mangledName() {\n+                return \"jextract$macro$\" + name;\n+            }\n+\n+            Entry success(Type type, Object value) {\n+                throw new IllegalStateException();\n+            }\n+\n+            Entry failure(Type type) {\n+                throw new IllegalStateException();\n+            }\n+\n+            boolean isSuccess() {\n+                return false;\n+            }\n+            boolean isRecoverableFailure() {\n+                return false;\n+            }\n+            boolean isUnparsed() {\n+                return false;\n+            }\n+\n+            void update() {\n+                macrosByMangledName.put(mangledName(), this);\n+            }\n+        }\n+\n+        class Unparsed extends Entry {\n+            Unparsed(String name, String[] tokens, Cursor cursor) {\n+                super(name, tokens, cursor);\n+            }\n+\n+            @Override\n+            Entry success(Type type, Object value) {\n+                return new Success(name, tokens, cursor, type, value);\n+            }\n+\n+            @Override\n+            Entry failure(Type type) {\n+                return type != null ?\n+                        new RecoverableFailure(name, tokens, cursor, type) :\n+                        new UnparseableMacro(name, tokens, cursor);\n+            }\n+\n+            @Override\n+            boolean isUnparsed() {\n+                return true;\n+            }\n+\n+            @Override\n+            void update() {\n+                throw new IllegalStateException();\n+            }\n+        }\n+\n+        class RecoverableFailure extends Entry {\n+\n+            final Type type;\n+\n+            public RecoverableFailure(String name, String[] tokens, Cursor cursor, Type type) {\n+                super(name, tokens, cursor);\n+                this.type = type;\n+            }\n+\n+            @Override\n+            Entry success(Type type, Object value) {\n+                return new Success(name, tokens, cursor, this.type, value);\n+            }\n+\n+            @Override\n+            Entry failure(Type type) {\n+                return new UnparseableMacro(name, tokens, cursor);\n+            }\n+\n+            @Override\n+            boolean isRecoverableFailure() {\n+                return true;\n+            }\n+        }\n+\n+        class Success extends Entry {\n+            final Type type;\n+            final Object value;\n+\n+            public Success(String name, String[] tokens, Cursor cursor, Type type, Object value) {\n+                super(name, tokens, cursor);\n+                this.type = type;\n+                this.value = value;\n+            }\n+\n+            @Override\n+            boolean isSuccess() {\n+                return true;\n+            }\n+\n+            public Object value() {\n+                return value;\n+            }\n+        }\n+\n+        class UnparseableMacro extends Entry {\n+\n+            UnparseableMacro(String name, String[] tokens, Cursor cursor) {\n+                super(name, tokens, cursor);\n+            }\n+\n+            @Override\n+            void update() {\n+                macrosByMangledName.remove(mangledName());\n+            }\n+        };\n+\n+        void enterMacro(String name, String[] tokens, Cursor cursor) {\n+            Unparsed unparsed = new Unparsed(name, tokens, cursor);\n+            macrosByMangledName.put(unparsed.mangledName(), unparsed);\n+        }\n+\n+        public List<Declaration.Constant> reparseConstants() {\n+            int last = -1;\n+            while (macrosByMangledName.size() > 0 && last != macrosByMangledName.size()) {\n+                last = macrosByMangledName.size();\n+                \/\/ step 1 - try parsing macros as var declarations\n+                reparseMacros(false);\n+                \/\/ step 2 - retry failed parsed macros as pointers\n+                reparseMacros(true);\n+            }\n+            treeMaker.typeMaker.resolveTypeReferences();\n+            return macrosByMangledName.values().stream()\n+                    .filter(Entry::isSuccess)\n+                    .map(e -> treeMaker.createMacro(e.cursor, e.name, ((Success)e).type, ((Success)e).value))\n+                    .collect(Collectors.toList());\n+        }\n+\n+        void updateTable(TypeMaker typeMaker, Cursor decl) {\n+            String mangledName = decl.spelling();\n+            Entry entry = macrosByMangledName.get(mangledName);\n+            try (EvalResult result = decl.eval()) {\n+                Entry newEntry = switch (result.getKind()) {\n+                    case Integral -> {\n+                        long value = result.getAsInt();\n+                        yield entry.success(typeMaker.makeType(decl.type()), value);\n+                    }\n+                    case FloatingPoint -> {\n+                        double value = result.getAsFloat();\n+                        yield entry.success(typeMaker.makeType(decl.type()), value);\n+                    }\n+                    case StrLiteral -> {\n+                        String value = result.getAsString();\n+                        yield entry.success(typeMaker.makeType(decl.type()), value);\n+                    }\n+                    default -> {\n+                        Type type = decl.type().equals(decl.type().canonicalType()) ?\n+                                null : typeMaker.makeType(decl.type());\n+                        yield entry.failure(type);\n+                    }\n+                };\n+                newEntry.update();\n+            }\n+        }\n+\n+        void reparseMacros(boolean recovery) {\n+            String snippet = macroDecl(recovery);\n+            TreeMaker treeMaker = new TreeMaker();\n+            try {\n+                reparser.reparse(snippet)\n+                        .filter(c -> c.kind() == CursorKind.VarDecl &&\n+                                c.spelling().contains(\"jextract$\"))\n+                        .forEach(c -> updateTable(treeMaker.typeMaker, c));\n+            } finally {\n+                treeMaker.typeMaker.resolveTypeReferences();\n+            }\n+        }\n+\n+        String macroDecl(boolean recovery) {\n+            StringBuilder buf = new StringBuilder();\n+            if (recovery) {\n+                buf.append(\"#include <stdint.h>\\n\");\n+            }\n+            macrosByMangledName.values().stream()\n+                    .filter(e -> !e.isSuccess()) \/\/ skip macros that already have passed\n+                    .filter(recovery ? Entry::isRecoverableFailure : Entry::isUnparsed)\n+                    .forEach(e -> {\n+                        buf.append(\"__auto_type \")\n+                                .append(e.mangledName())\n+                                .append(\" = \");\n+                        if (recovery) {\n+                            buf.append(\"(uintptr_t)\");\n+                        }\n+                        buf.append(e.name)\n+                                .append(\";\\n\");\n+                    });\n+            return buf.toString();\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/MacroParserImpl.java","additions":379,"deletions":0,"binary":false,"changes":379,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+import javax.tools.JavaFileObject;\n+import java.lang.constant.ClassDesc;\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+public class NestedClassBuilder extends JavaSourceBuilder {\n+\n+    protected final JavaSourceBuilder enclosing;\n+\n+    public NestedClassBuilder(JavaSourceBuilder enclosing, Kind kind, String className) {\n+        super(enclosing.align(), kind, ClassDesc.of(enclosing.packageName(), enclosing.uniqueNestedClassName(className)));\n+        this.enclosing = enclosing;\n+    }\n+\n+    @Override\n+    protected String mods() {\n+        return kind == Kind.INTERFACE ?\n+                \"public \" : \"public static \";\n+    }\n+\n+    @Override\n+    boolean isEnclosedBySameName(String name) {\n+        return super.isEnclosedBySameName(name) || enclosing.isEnclosedBySameName(name);\n+    }\n+\n+    @Override\n+    String fullName() {\n+        return enclosing.className() + \".\" + className();\n+    }\n+\n+    @Override\n+    void classBegin() {\n+        incrAlign();\n+        super.classBegin();\n+    }\n+\n+    @Override\n+    JavaSourceBuilder classEnd() {\n+        super.classEnd();\n+        decrAlign();\n+        enclosing.append(build());\n+        return enclosing;\n+    }\n+\n+    @Override\n+    protected void emitPackagePrefix() {\n+        \/\/ nested class. containing class has necessary package declaration\n+    }\n+\n+    @Override\n+    protected void emitImportSection() {\n+        \/\/ nested class. containing class has necessary imports\n+    }\n+\n+    @Override\n+    public List<JavaFileObject> toFiles() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected void emitWithConstantClass(String javaName, Consumer<ConstantBuilder> constantConsumer) {\n+        if (this instanceof ConstantBuilder cb) {\n+            \/\/ use this class to emit constants\n+            constantConsumer.accept(cb);\n+        } else {\n+            enclosing.emitWithConstantClass(javaName, constantConsumer);\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/NestedClassBuilder.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.jextract.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public final class Options {\n+    \/\/ The args for parsing C\n+    public final List<String> clangArgs;\n+    \/\/ The list of library names\n+    public final List<String> libraryNames;\n+    public final List<String> filters;\n+    \/\/ target package\n+    public final String targetPackage;\n+    \/\/ output directory\n+    public final String outputDir;\n+    public final boolean source;\n+\n+    private Options(List<String> clangArgs, List<String> libraryNames,\n+            List<String> filters, String targetPackage,\n+            String outputDir, boolean source) {\n+        this.clangArgs = clangArgs;\n+        this.libraryNames = libraryNames;\n+        this.filters = filters;\n+        this.targetPackage = targetPackage;\n+        this.outputDir = outputDir;\n+        this.source = source;\n+    }\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    public static Options createDefault() {\n+        return builder().build();\n+    }\n+\n+    public static class Builder {\n+        private final List<String> clangArgs;\n+        private final List<String> libraryNames;\n+        private final List<String> filters;\n+        private String targetPackage;\n+        private String outputDir;\n+        private boolean source;\n+\n+        public Builder() {\n+            this.clangArgs = new ArrayList<>();\n+            this.libraryNames = new ArrayList<>();\n+            this.filters = new ArrayList<>();\n+            this.targetPackage = \"\";\n+            this.outputDir = \".\";\n+            this.source = false;\n+        }\n+\n+        public Options build() {\n+            return new Options(\n+                    Collections.unmodifiableList(clangArgs),\n+                    Collections.unmodifiableList(libraryNames),\n+                    Collections.unmodifiableList(filters),\n+                    targetPackage, outputDir, source\n+            );\n+        }\n+\n+        public void addClangArg(String arg) {\n+            clangArgs.add(arg);\n+        }\n+\n+        public void addLibraryName(String name) {\n+            libraryNames.add(name);\n+        }\n+\n+        public void setOutputDir(String outputDir) {\n+            this.outputDir = outputDir;\n+        }\n+\n+        public void setTargetPackage(String pkg) {\n+            this.targetPackage = pkg;\n+        }\n+\n+        public void addFilter(String filter) {\n+            filters.add(filter);\n+        }\n+\n+        public void setGenerateSource() {\n+            source = true;\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/Options.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -0,0 +1,526 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.foreign.*;\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.JextractTool;\n+import jdk.incubator.jextract.Type;\n+\n+import jdk.internal.jextract.impl.JavaSourceBuilder.VarInfo;\n+import jdk.internal.jextract.impl.JavaSourceBuilder.FunctionInfo;\n+\n+import javax.tools.JavaFileObject;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.lang.constant.ClassDesc;\n+import java.lang.invoke.MethodType;\n+import java.net.URI;\n+import java.net.URL;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+\n+\/*\n+ * Scan a header file and generate Java source items for entities defined in that header\n+ * file. Tree visitor visit methods return true\/false depending on whether a\n+ * particular Tree is processed or skipped.\n+ *\/\n+public class OutputFactory implements Declaration.Visitor<Void, Declaration> {\n+    \/\/ internal symbol used by clang for \"va_list\"\n+    private static final String VA_LIST_TAG = \"__va_list_tag\";\n+    private final Set<String> constants = new HashSet<>();\n+    \/\/ To detect duplicate Variable and Function declarations.\n+    private final Set<String> variables = new HashSet<>();\n+    private final Set<Declaration.Function> functions = new HashSet<>();\n+\n+    protected final ToplevelBuilder toplevelBuilder;\n+    protected JavaSourceBuilder currentBuilder;\n+    protected final TypeTranslator typeTranslator = new TypeTranslator();\n+    private final String pkgName;\n+    private final Map<Declaration, String> structClassNames = new HashMap<>();\n+    private final Set<Declaration.Typedef> unresolvedStructTypedefs = new HashSet<>();\n+    private final Map<Type, String> functionTypeDefNames = new HashMap<>();\n+\n+    private void addStructDefinition(Declaration decl, String name) {\n+        structClassNames.put(decl, name);\n+    }\n+\n+    private boolean structDefinitionSeen(Declaration decl) {\n+        return structClassNames.containsKey(decl);\n+    }\n+\n+    private String structDefinitionName(Declaration decl) {\n+        return structClassNames.get(decl);\n+    }\n+\n+    private void addFunctionTypedef(Type.Delegated typedef, String name) {\n+        functionTypeDefNames.put(typedef, name);\n+    }\n+\n+    private boolean functionTypedefSeen(Type.Delegated typedef) {\n+        return functionTypeDefNames.containsKey(typedef);\n+    }\n+\n+    private String functionTypedefName(Type.Delegated decl) {\n+        return functionTypeDefNames.get(decl);\n+    }\n+\n+    \/\/ have we seen this Variable earlier?\n+    protected boolean variableSeen(Declaration.Variable tree) {\n+        return !variables.add(tree.name());\n+    }\n+\n+    \/\/ have we seen this Function earlier?\n+    protected boolean functionSeen(Declaration.Function tree) {\n+        return !functions.add(tree);\n+    }\n+\n+    public static JavaFileObject[] generateWrapped(Declaration.Scoped decl, String headerName,\n+                String pkgName, List<String> libraryNames) {\n+        String clsName = Utils.javaSafeIdentifier(headerName.replace(\".h\", \"_h\"), true);\n+        ToplevelBuilder toplevelBuilder = new ToplevelBuilder(ClassDesc.of(pkgName, clsName), libraryNames.toArray(new String[0]));\n+        return new OutputFactory(pkgName, toplevelBuilder).generate(decl);\n+    }\n+\n+    private OutputFactory(String pkgName, ToplevelBuilder toplevelBuilder) {\n+        this.pkgName = pkgName;\n+        this.toplevelBuilder = toplevelBuilder;\n+        this.currentBuilder = toplevelBuilder;\n+    }\n+\n+    static final String C_LANG_CONSTANTS_HOLDER = \"jdk.incubator.foreign.CLinker\";\n+\n+    JavaFileObject[] generate(Declaration.Scoped decl) {\n+        \/\/generate all decls\n+        decl.members().forEach(this::generateDecl);\n+        \/\/ check if unresolved typedefs can be resolved now!\n+        for (Declaration.Typedef td : unresolvedStructTypedefs) {\n+            Declaration.Scoped structDef = ((Type.Declared) td.type()).tree();\n+            toplevelBuilder.addTypedef(td.name(),\n+                    structDefinitionSeen(structDef) ? structDefinitionName(structDef) : null, td.type());\n+        }\n+        try {\n+            List<JavaFileObject> files = new ArrayList<>(toplevelBuilder.toFiles());\n+            files.add(jfoFromString(pkgName,\"RuntimeHelper\", getRuntimeHelperSource()));\n+            return files.toArray(new JavaFileObject[0]);\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        } catch (URISyntaxException ex2) {\n+            throw new RuntimeException(ex2);\n+        }\n+    }\n+\n+    private String getRuntimeHelperSource() throws URISyntaxException, IOException {\n+        URL runtimeHelper = OutputFactory.class.getResource(\"resources\/RuntimeHelper.java.template\");\n+        return (pkgName.isEmpty()? \"\" : \"package \" + pkgName + \";\\n\") +\n+                        String.join(\"\\n\", Files.readAllLines(Paths.get(runtimeHelper.toURI())))\n+                                .replace(\"${C_LANG}\", C_LANG_CONSTANTS_HOLDER);\n+    }\n+\n+    private void generateDecl(Declaration tree) {\n+        try {\n+            tree.accept(this, null);\n+        } catch (Exception ex) {\n+            ex.printStackTrace();\n+        }\n+    }\n+\n+    private JavaFileObject jfoFromString(String pkgName, String clsName, String contents) {\n+        String pkgPrefix = pkgName.isEmpty() ? \"\" : pkgName.replaceAll(\"\\\\.\", \"\/\") + \"\/\";\n+        return InMemoryJavaCompiler.jfoFromString(URI.create(pkgPrefix + clsName + \".java\"), contents);\n+    }\n+\n+    @Override\n+    public Void visitConstant(Declaration.Constant constant, Declaration parent) {\n+        if (!constants.add(constant.name())) {\n+            \/\/skip\n+            return null;\n+        }\n+\n+        Class<?> clazz = getJavaType(constant.type());\n+        if (clazz == null) {\n+            warn(\"skipping \" + constant.name() + \" because of unsupported type usage\");\n+            return null;\n+        }\n+        toplevelBuilder.addConstant(Utils.javaSafeIdentifier(constant.name()),\n+                constant.value() instanceof String ? MemorySegment.class :\n+                typeTranslator.getJavaType(constant.type()), constant.value());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitScoped(Declaration.Scoped d, Declaration parent) {\n+        if (d.layout().isEmpty()) {\n+            \/\/skip decl-only\n+            return null;\n+        }\n+        boolean isStructKind = switch (d.kind()) {\n+            case STRUCT, UNION -> true;\n+            default -> false;\n+        };\n+        if (isStructKind) {\n+            String className = d.name();\n+            GroupLayout layout = (GroupLayout) layoutFor(d);\n+            currentBuilder = currentBuilder.addStruct(className, parent, layout, Type.declared(d));\n+            currentBuilder.classBegin();\n+            if (!className.isEmpty()) {\n+                addStructDefinition(d, currentBuilder.fullName());\n+            }\n+        }\n+        try {\n+            d.members().forEach(fieldTree -> fieldTree.accept(this, d));\n+        } finally {\n+            if (isStructKind) {\n+                currentBuilder = currentBuilder.classEnd();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static MemoryLayout isUnsupported(MemoryLayout layout) {\n+        if (layout instanceof ValueLayout) {\n+            if (UnsupportedLayouts.isUnsupported(layout)) {\n+                return layout;\n+            }\n+        } else if (layout instanceof GroupLayout) {\n+            GroupLayout gl = (GroupLayout)layout;\n+            for (MemoryLayout ml : gl.memberLayouts()) {\n+                MemoryLayout ul = isUnsupported(ml);\n+                if (ul != null) {\n+                    return ul;\n+                }\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    private static MemoryLayout isUnsupported(FunctionDescriptor desc) {\n+        MemoryLayout resultLayout = desc.returnLayout().orElse(null);\n+        if (resultLayout != null) {\n+            MemoryLayout ul = isUnsupported(resultLayout);\n+            if (ul != null) {\n+                return ul;\n+            }\n+        }\n+\n+        for (MemoryLayout argLayout : desc.argumentLayouts()) {\n+            MemoryLayout ul = isUnsupported(argLayout);\n+            if (ul != null) {\n+                return ul;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    private String generateFunctionalInterface(Type.Function func, String name) {\n+        return functionInfo(func, name, false, FunctionInfo::ofFunctionPointer)\n+                .map(fInfo -> currentBuilder.addFunctionalInterface(Utils.javaSafeIdentifier(name), fInfo))\n+                .orElse(null);\n+    }\n+\n+    @Override\n+    public Void visitFunction(Declaration.Function funcTree, Declaration parent) {\n+        if (functionSeen(funcTree)) {\n+            return null;\n+        }\n+\n+        String mhName = Utils.javaSafeIdentifier(funcTree.name());\n+        \/\/generate static wrapper for function\n+        List<String> paramNames = funcTree.parameters()\n+                                          .stream()\n+                                          .map(Declaration.Variable::name)\n+                                          .map(p -> !p.isEmpty() ? Utils.javaSafeIdentifier(p) : p)\n+                                          .collect(Collectors.toList());\n+\n+        Optional<FunctionInfo> functionInfo = functionInfo(funcTree.type(), funcTree.name(), true,\n+                (mtype, desc) -> FunctionInfo.ofFunction(mtype, desc, funcTree.type().varargs(), paramNames));\n+\n+        if (functionInfo.isPresent()) {\n+            int i = 0;\n+            for (Declaration.Variable param : funcTree.parameters()) {\n+                Type.Function f = getAsFunctionPointer(param.type());\n+                if (f != null) {\n+                    String name = funcTree.name() + \"$\" + (param.name().isEmpty() ? \"x\" + i : param.name());\n+                    if (generateFunctionalInterface(f, name) == null) {\n+                        return null;\n+                    }\n+                    i++;\n+                }\n+            }\n+\n+            toplevelBuilder.addFunction(mhName, funcTree.name(), functionInfo.get());\n+        }\n+\n+        return null;\n+    }\n+\n+    Optional<String> getAsFunctionPointerTypedef(Type type) {\n+        if (type instanceof Type.Delegated delegated &&\n+                delegated.kind() == Type.Delegated.Kind.TYPEDEF &&\n+                functionTypedefSeen(delegated)) {\n+            return Optional.of(functionTypedefName(delegated));\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    Type.Function getAsFunctionPointer(Type type) {\n+        if (type instanceof Type.Delegated) {\n+            Type.Delegated delegated = (Type.Delegated) type;\n+            return (delegated.kind() == Type.Delegated.Kind.POINTER) ?\n+                    getAsFunctionPointer(delegated.type()) : null;\n+        } else if (type instanceof Type.Function) {\n+            \/*\n+             * \/\/ pointer to function declared as function like this\n+             *\n+             * typedef void CB(int);\n+             * void func(CB cb);\n+             *\/\n+            return (Type.Function) type;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public Void visitTypedef(Declaration.Typedef tree, Declaration parent) {\n+        Type type = tree.type();\n+        if (type instanceof Type.Declared) {\n+            Declaration.Scoped s = ((Type.Declared) type).tree();\n+            if (!s.name().equals(tree.name())) {\n+                switch (s.kind()) {\n+                    case STRUCT, UNION -> {\n+                        if (s.name().isEmpty()) {\n+                            visitScoped(s, tree);\n+                        } else {\n+                            \/*\n+                             * If typedef is seen after the struct\/union definition, we can generate subclass\n+                             * right away. If not, we've to save it and revisit after all the declarations are\n+                             * seen. This is to support forward declaration of typedefs.\n+                             *\n+                             * typedef struct Foo Bar;\n+                             *\n+                             * struct Foo {\n+                             *     int x, y;\n+                             * };\n+                             *\/\n+                            if (structDefinitionSeen(s)) {\n+                                toplevelBuilder.addTypedef(tree.name(), structDefinitionName(s), tree.type());\n+                            } else {\n+                                \/*\n+                                 * Definition of typedef'ed struct\/union not seen yet. May be the definition comes later.\n+                                 * Save it to visit at the end of all declarations.\n+                                 *\/\n+                                unresolvedStructTypedefs.add(tree);\n+                            }\n+                        }\n+                    }\n+                    default -> visitScoped(s, tree);\n+                }\n+            }\n+        } else if (type instanceof Type.Primitive) {\n+             toplevelBuilder.addTypedef(tree.name(), null, type);\n+        } else {\n+            Type.Function func = getAsFunctionPointer(type);\n+            if (func != null) {\n+                String funcIntfName = generateFunctionalInterface(func, tree.name());\n+                if (funcIntfName != null) {\n+                    addFunctionTypedef(Type.typedef(tree.name(), tree.type()), funcIntfName);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitVariable(Declaration.Variable tree, Declaration parent) {\n+        if (parent == null && variableSeen(tree)) {\n+            return null;\n+        }\n+\n+        String fieldName = tree.name();\n+        String symbol = tree.name();\n+        assert !symbol.isEmpty();\n+        assert !fieldName.isEmpty();\n+        fieldName = Utils.javaSafeIdentifier(fieldName);\n+\n+        Type type = tree.type();\n+\n+        if (type instanceof Type.Declared && ((Type.Declared) type).tree().name().isEmpty()) {\n+            \/\/ anon type - let's generate something\n+            ((Type.Declared) type).tree().accept(this, tree);\n+        }\n+        MemoryLayout layout = tree.layout().orElse(Type.layoutFor(type).orElse(null));\n+        if (layout == null) {\n+            \/\/no layout - abort\n+            return null;\n+        }\n+\n+        MemoryLayout ul = isUnsupported(layout);\n+        if (ul != null) {\n+            String name = parent != null? parent.name() + \".\" : \"\";\n+            name += fieldName;\n+            warn(\"skipping \" + name + \" because of unsupported type usage: \" +\n+                    UnsupportedLayouts.getUnsupportedTypeName(ul));\n+            return null;\n+        }\n+\n+        Class<?> clazz = getJavaType(type);\n+        if (clazz == null) {\n+            String name = parent != null? parent.name() + \".\" : \"\";\n+            name += fieldName;\n+            warn(\"skipping \" + name + \" because of unsupported type usage\");\n+            return null;\n+        }\n+\n+\n+        VarInfo varInfo = VarInfo.ofVar(clazz, layout);\n+        Type.Function func = getAsFunctionPointer(type);\n+        String fiName;\n+        if (func != null) {\n+            fiName = generateFunctionalInterface(func, fieldName);\n+            if (fiName != null) {\n+                varInfo = VarInfo.ofFunctionalPointerVar(clazz, layout, fiName);\n+            }\n+        } else {\n+            Optional<String> funcTypedef = getAsFunctionPointerTypedef(type);\n+            if (funcTypedef.isPresent()) {\n+                varInfo = VarInfo.ofFunctionalPointerVar(clazz, layout, Utils.javaSafeIdentifier(funcTypedef.get()));\n+            }\n+        }\n+\n+        if (tree.kind() == Declaration.Variable.Kind.BITFIELD ||\n+                (layout instanceof ValueLayout && layout.byteSize() > 8)) {\n+            \/\/skip\n+            return null;\n+        }\n+\n+        boolean sizeAvailable;\n+        try {\n+            layout.byteSize();\n+            sizeAvailable = true;\n+        } catch (Exception ignored) {\n+            sizeAvailable = false;\n+        }\n+        if (sizeAvailable) {\n+            currentBuilder.addVar(fieldName, tree.name(), varInfo);\n+        } else {\n+            warn(\"Layout size not available for \" + fieldName);\n+        }\n+\n+        return null;\n+    }\n+\n+    private Optional<FunctionInfo> functionInfo(Type.Function funcPtr, String nativeName, boolean allowVarargs,\n+                                                BiFunction<MethodType, FunctionDescriptor, FunctionInfo> functionInfoFactory) {\n+        FunctionDescriptor descriptor = Type.descriptorFor(funcPtr).orElse(null);\n+        if (descriptor == null) {\n+            \/\/abort\n+            return Optional.empty();\n+        }\n+\n+        \/\/generate functional interface\n+        if (!allowVarargs && funcPtr.varargs() && !funcPtr.argumentTypes().isEmpty()) {\n+            warn(\"varargs in callbacks is not supported: \" + funcPtr);\n+            return Optional.empty();\n+        }\n+\n+        MemoryLayout unsupportedLayout = isUnsupported(descriptor);\n+        if (unsupportedLayout != null) {\n+            warn(\"skipping \" + nativeName + \" because of unsupported type usage: \" +\n+                    UnsupportedLayouts.getUnsupportedTypeName(unsupportedLayout));\n+            return Optional.empty();\n+        }\n+\n+        MethodType mtype = getMethodType(funcPtr, allowVarargs);\n+        return mtype != null ?\n+                Optional.of(functionInfoFactory.apply(mtype, descriptor)) :\n+                Optional.empty();\n+    }\n+\n+    protected static MemoryLayout layoutFor(Declaration decl) {\n+        if (decl instanceof Declaration.Typedef) {\n+            Declaration.Typedef alias = (Declaration.Typedef) decl;\n+            return Type.layoutFor(alias.type()).orElseThrow();\n+        } else if (decl instanceof Declaration.Scoped) {\n+            return ((Declaration.Scoped) decl).layout().orElseThrow();\n+        } else {\n+            throw new IllegalArgumentException(\"Unexpected parent declaration\");\n+        }\n+        \/\/ case like `typedef struct { ... } Foo`\n+    }\n+\n+    static void warn(String msg) {\n+        System.err.println(\"WARNING: \" + msg);\n+    }\n+\n+    private Class<?> getJavaType(Type type) {\n+        try {\n+            return typeTranslator.getJavaType(type);\n+        } catch (UnsupportedOperationException uoe) {\n+            warn(uoe.toString());\n+            if (JextractTool.DEBUG) {\n+                uoe.printStackTrace();\n+            }\n+            return null;\n+        }\n+    }\n+\n+    private MethodType getMethodType(Type.Function type) {\n+        try {\n+            return typeTranslator.getMethodType(type);\n+        } catch (UnsupportedOperationException uoe) {\n+            warn(uoe.toString());\n+            if (JextractTool.DEBUG) {\n+                uoe.printStackTrace();\n+            }\n+            return null;\n+        }\n+    }\n+\n+    private MethodType getMethodType(Type.Function type, boolean varargsCheck) {\n+        try {\n+            return typeTranslator.getMethodType(type, varargsCheck);\n+        } catch (UnsupportedOperationException uoe) {\n+            warn(uoe.toString());\n+            if (JextractTool.DEBUG) {\n+                uoe.printStackTrace();\n+            }\n+            return null;\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/OutputFactory.java","additions":526,"deletions":0,"binary":false,"changes":526,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.jextract.Declaration;\n+import jdk.internal.clang.Cursor;\n+import jdk.internal.clang.CursorKind;\n+import jdk.internal.clang.Diagnostic;\n+import jdk.internal.clang.Index;\n+import jdk.internal.clang.LibClang;\n+import jdk.internal.clang.SourceLocation;\n+import jdk.internal.clang.SourceRange;\n+import jdk.internal.clang.TranslationUnit;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+\n+public class Parser {\n+    private final TreeMaker treeMaker;\n+\n+    public Parser() {\n+        this.treeMaker = new TreeMaker();\n+    }\n+\n+    public Declaration.Scoped parse(Path path, Collection<String> args) {\n+        final Index index = LibClang.createIndex(false);\n+\n+        TranslationUnit tu = index.parse(path.toString(),\n+            d -> {\n+                if (d.severity() > Diagnostic.CXDiagnostic_Warning) {\n+                    throw new ClangException(d.toString());\n+                }\n+            },\n+            true, args.toArray(new String[0]));\n+\n+        MacroParserImpl macroParser = MacroParserImpl.make(treeMaker, tu, args);\n+\n+        List<Declaration> decls = new ArrayList<>();\n+        Cursor tuCursor = tu.getCursor();\n+        tuCursor.children().\n+            forEach(c -> {\n+                SourceLocation loc = c.getSourceLocation();\n+                if (loc == null) {\n+                    return;\n+                }\n+\n+                SourceLocation.Location src = loc.getFileLocation();\n+                if (src == null) {\n+                    return;\n+                }\n+\n+\n+                if (c.isDeclaration()) {\n+                    if (c.kind() == CursorKind.UnexposedDecl ||\n+                        c.kind() == CursorKind.Namespace) {\n+                        c.children().map(treeMaker::createTree)\n+                                .filter(t -> t != null)\n+                                .forEach(decls::add);\n+                    } else {\n+                        Declaration decl = treeMaker.createTree(c);\n+                        if (decl != null) {\n+                            decls.add(decl);\n+                        }\n+                    }\n+                } else if (isMacro(c) && src.path() != null) {\n+                    SourceRange range = c.getExtent();\n+                    String[] tokens = c.getTranslationUnit().tokens(range);\n+                    Optional<Declaration.Constant> constant = macroParser.parseConstant(treeMaker.toPos(c), c.spelling(), tokens);\n+                    if (constant.isPresent()) {\n+                        decls.add(constant.get());\n+                    }\n+                }\n+            });\n+\n+        decls.addAll(macroParser.macroTable.reparseConstants());\n+        Declaration.Scoped rv = treeMaker.createHeader(tuCursor, decls);\n+        treeMaker.freeze();\n+        index.close();\n+        return rv;\n+    }\n+\n+    private boolean isMacro(Cursor c) {\n+        return c.isPreprocessing() && c.kind() == CursorKind.MacroDefinition;\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/Parser.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+import java.lang.constant.Constable;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Position;\n+import jdk.incubator.jextract.Type;\n+\n+public class PrettyPrinter implements Declaration.Visitor<Void, Void> {\n+\n+    private static String SPACES = \" \".repeat(92);\n+    int align = 0;\n+\n+    void incr() {\n+        align += 4;\n+    }\n+\n+    void decr() {\n+        align -= 4;\n+    }\n+\n+    void indent() {\n+        builder.append(SPACES.substring(0, align));\n+    }\n+\n+    StringBuilder builder = new StringBuilder();\n+\n+    private void getAttributes(Declaration decl) {\n+        Set<String> attrs = decl.attributeNames();\n+        if (attrs.isEmpty()) {\n+            return;\n+        }\n+        incr();\n+        indent();\n+        for (String k: attrs) {\n+            builder.append(\"Attr: \");\n+            builder.append(k);\n+            builder.append(\" -> [\");\n+            builder.append(decl.getAttribute(k).get().stream()\n+                .map(Constable::toString)\n+                .collect(Collectors.joining(\", \")));\n+            builder.append(\"]\\n\");\n+        }\n+        decr();\n+    }\n+\n+    public String print(Declaration decl) {\n+        decl.accept(this, null);\n+        return builder.toString();\n+    }\n+\n+    @Override\n+    public Void visitScoped(Declaration.Scoped d, Void aVoid) {\n+        indent();\n+        builder.append(\"Scoped: \" + d.kind() + \" \" + d.name() + d.layout().map(l -> \" layout = \" + l).orElse(\"\"));\n+        builder.append(\"\\n\");\n+        getAttributes(d);\n+        incr();\n+        d.members().forEach(m -> m.accept(this, null));\n+        decr();\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitFunction(Declaration.Function d, Void aVoid) {\n+        indent();\n+        builder.append(\"Function: \" + d.name() + \" type = \" + d.type().accept(typeVisitor, null));\n+        builder.append(\"\\n\");\n+        getAttributes(d);\n+        incr();\n+        d.parameters().forEach(m -> m.accept(this, null));\n+        decr();\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitVariable(Declaration.Variable d, Void aVoid) {\n+        indent();\n+        builder.append(\"Variable: \" + d.kind() + \" \" + d.name() + \" type = \" + d.type().accept(typeVisitor, null) + \", layout = \" + d.layout());\n+        builder.append(\"\\n\");\n+        getAttributes(d);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitConstant(Declaration.Constant d, Void aVoid) {\n+        indent();\n+        builder.append(\"Constant: \" + d.name() + \" \" + d.value() + \" type = \" + d.type().accept(typeVisitor, null));\n+        builder.append(\"\\n\");\n+        getAttributes(d);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitTypedef(Declaration.Typedef d, Void aVoid) {\n+        indent();\n+        builder.append(\"Typedef: \").append(d.name()).append(\" = \")\n+               .append(d.type().accept(typeVisitor, null)).append(\"\\n\");\n+        getAttributes(d);\n+        return null;\n+    }\n+\n+    private static Type.Visitor<String, Void> typeVisitor = new Type.Visitor<>() {\n+        @Override\n+        public String visitPrimitive(Type.Primitive t, Void aVoid) {\n+            return t.kind().toString() + t.kind().layout().map(l -> \"(layout = \" + l + \")\").orElse(\"\");\n+        }\n+\n+        @Override\n+        public String visitDelegated(Type.Delegated t, Void aVoid) {\n+            switch (t.kind()) {\n+                case TYPEDEF:\n+                    return \"typedef \" + t.name() + \" = \" + t.type().accept(this, null);\n+                case POINTER:\n+                    return \"(\" + t.type().accept(this, null) + \")*\";\n+                default:\n+                    return t.kind() + \" = \" + t.type().accept(this, null);\n+            }\n+        }\n+\n+        @Override\n+        public String visitFunction(Type.Function t, Void aVoid) {\n+            String res = t.returnType().accept(this, null);\n+            String args = t.argumentTypes().stream()\n+                    .map(a -> a.accept(this, null))\n+                    .collect(Collectors.joining(\",\", \"(\", \")\"));\n+            return res + args;\n+        }\n+\n+        @Override\n+        public String visitDeclared(Type.Declared t, Void aVoid) {\n+            return \"Declared(\" + t.tree().layout().map(MemoryLayout::toString).orElse(\"\") + \")\";\n+        }\n+\n+        @Override\n+        public String visitArray(Type.Array t, Void aVoid) {\n+            String brackets = String.format(\"%s[%s]\", t.kind() == Type.Array.Kind.VECTOR ? \"v\" : \"\",\n+                    t.elementCount().isPresent() ? t.elementCount().getAsLong() : \"\");\n+            return t.elementType().accept(this, null) + brackets;\n+        }\n+\n+        @Override\n+        public String visitType(Type t, Void aVoid) {\n+            return \"Unknown type: \" + t.getClass().getName();\n+        }\n+    };\n+\n+    public static String type(Type type) {\n+        return type.accept(typeVisitor, null);\n+    }\n+\n+    public static String position(Position pos) {\n+        return String.format(\"%s:%d:%d\",\n+                pos.path() == null ? \"N\/A\" : pos.path().toString(),\n+                pos.line(), pos.col());\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/PrettyPrinter.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.internal.clang.Cursor;\n+import jdk.internal.clang.CursorKind;\n+import jdk.internal.clang.Type;\n+import jdk.internal.clang.TypeKind;\n+\n+import java.nio.ByteOrder;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static jdk.internal.jextract.impl.LayoutUtils.JEXTRACT_ANONYMOUS;\n+\n+\/**\n+ * Base class for C struct, union MemoryLayout computer helper classes.\n+ *\/\n+abstract class RecordLayoutComputer {\n+    \/\/ enclosing struct type (or this struct type for top level structs)\n+    final Type parent;\n+    \/\/ this struct type\n+    final Type type;\n+    \/\/ cursor of this struct\n+    final Cursor cursor;\n+    final List<MemoryLayout> fieldLayouts;\n+\n+    private int anonCount = 0;\n+\n+    RecordLayoutComputer(Type parent, Type type) {\n+        this.parent = parent;\n+        this.type = type;\n+        this.cursor = type.getDeclarationCursor().getDefinition();\n+        this.fieldLayouts = new ArrayList<>();\n+    }\n+\n+    static MemoryLayout compute(long offsetInParent, Type parent, Type type) {\n+        Cursor cursor = type.getDeclarationCursor().getDefinition();\n+        if (cursor.isInvalid()) {\n+            return MemoryLayout.ofPaddingBits(64);\n+        }\n+\n+        final boolean isUnion = cursor.kind() == CursorKind.UnionDecl;\n+        return isUnion? new UnionLayoutComputer(offsetInParent, parent, type).compute() :\n+                new StructLayoutComputer(offsetInParent, parent, type).compute();\n+    }\n+\n+    final MemoryLayout compute() {\n+        Stream<Cursor> fieldCursors = Utils.flattenableChildren(cursor);\n+        for (Cursor fc : fieldCursors.collect(Collectors.toList())) {\n+            \/*\n+             * Ignore bitfields of zero width.\n+             *\n+             * struct Foo {\n+             *     int i:0;\n+             * }\n+             *\n+             * And bitfields without a name.\n+             * (padding is computed automatically)\n+             *\/\n+            if (fc.isBitField() && (fc.getBitFieldWidth() == 0 || fc.spelling().isEmpty())) {\n+                startBitfield();\n+                continue;\n+            }\n+\n+            processField(fc);\n+        }\n+\n+        return finishLayout();\n+    }\n+\n+    abstract void startBitfield();\n+    abstract void processField(Cursor c);\n+    abstract MemoryLayout finishLayout();\n+\n+    void addFieldLayout(MemoryLayout MemoryLayout) {\n+        fieldLayouts.add(MemoryLayout);\n+    }\n+\n+    void addFieldLayout(long offset, Type parent, Cursor c) {\n+        MemoryLayout memoryLayout = c.isAnonymousStruct()\n+            ? compute(offset, parent, c.type())\n+                .withName(nextAnonymousName())\n+                .withAttribute(JEXTRACT_ANONYMOUS, true)\n+            : fieldLayout(c);\n+        addFieldLayout(memoryLayout);\n+    }\n+\n+    private String nextAnonymousName() {\n+        return \"$anon$\" + anonCount++;\n+    }\n+\n+    MemoryLayout fieldLayout(Cursor c) {\n+        MemoryLayout l = LayoutUtils.getLayout(c.type());\n+        String name = LayoutUtils.getName(c);\n+        if (c.isBitField()) {\n+            MemoryLayout sublayout = MemoryLayout.ofValueBits(c.getBitFieldWidth(), ByteOrder.nativeOrder());\n+            return sublayout.withName(name);\n+        } else {\n+            return l.withName(name);\n+        }\n+    }\n+\n+    long fieldSize(Cursor c) {\n+        if (c.type().kind() == TypeKind.IncompleteArray) {\n+            return 0;\n+        }\n+        return c.isBitField() ? c.getBitFieldWidth() : c.type().size() * 8;\n+    }\n+\n+    MemoryLayout bitfield(List<MemoryLayout> sublayouts) {\n+        return LayoutUtils.setBitfields(MemoryLayout.ofStruct(sublayouts.toArray(new MemoryLayout[0])));\n+    }\n+\n+    long offsetOf(Type parent, Cursor c) {\n+        if (c.kind() == CursorKind.FieldDecl) {\n+            return parent.getOffsetOf(c.spelling());\n+        } else {\n+            return Utils.flattenableChildren(c)\n+                    .mapToLong(child -> offsetOf(parent, child))\n+                    .findFirst()\n+                    .orElseThrow(() -> new IllegalStateException(\n+                            \"Can not find offset of: \" + c + \", in: \" + parent));\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/RecordLayoutComputer.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"},{"patch":"@@ -0,0 +1,392 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Type;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+\n+import static jdk.internal.jextract.impl.LayoutUtils.JEXTRACT_ANONYMOUS;\n+\n+\/**\n+ * This class generates static utilities class for C structs, unions.\n+ *\/\n+class StructBuilder extends ConstantBuilder {\n+\n+    private static final String MEMBER_MODS = \"public static\";\n+\n+    private final GroupLayout structLayout;\n+    private final Type structType;\n+    private final Deque<String> prefixElementNames;\n+\n+    StructBuilder(JavaSourceBuilder enclosing, String className, GroupLayout structLayout, Type structType) {\n+        super(enclosing, Kind.CLASS, className);\n+        this.structLayout = structLayout;\n+        this.structType = structType;\n+        prefixElementNames = new ArrayDeque<>();\n+    }\n+\n+    private String safeParameterName(String paramName) {\n+        return isEnclosedBySameName(paramName)? paramName + \"$\" : paramName;\n+    }\n+\n+    void pushPrefixElement(String prefixElementName) {\n+        prefixElementNames.push(prefixElementName);\n+    }\n+\n+    void popPrefixElement() {\n+        prefixElementNames.pop();\n+    }\n+\n+    private List<String> prefixNamesList() {\n+        List<String> prefixes = new ArrayList<>(prefixElementNames);\n+        Collections.reverse(prefixes);\n+        return Collections.unmodifiableList(prefixes);\n+    }\n+\n+    @Override\n+    void classBegin() {\n+        if (!inAnonymousNested()) {\n+            super.classBegin();\n+            addLayout(layoutField(), ((Type.Declared) structType).tree().layout().get())\n+                    .emitGetter(this, MEMBER_MODS, Constant.SUFFIX_ONLY);\n+        }\n+    }\n+\n+    @Override\n+    JavaSourceBuilder classEnd() {\n+        if (!inAnonymousNested()) {\n+            emitSizeof();\n+            emitAllocate();\n+            emitScopeAllocate();\n+            emitAllocateArray();\n+            emitScopeAllocateArray();\n+            emitAllocatePoiner();\n+            emitScopeAllocatePointer();\n+            emitAsRestricted();\n+            return super.classEnd();\n+        } else {\n+            \/\/ we're in an anonymous struct which got merged into this one, return this very builder and keep it open\n+            popPrefixElement();\n+            return this;\n+        }\n+    }\n+\n+    boolean inAnonymousNested() {\n+        return !prefixElementNames.isEmpty();\n+    }\n+\n+    @Override\n+    public StructBuilder addStruct(String name, Declaration parent, GroupLayout layout, Type type) {\n+        if (name.isEmpty() && (parent instanceof Declaration.Scoped)) {\n+            \/\/nested anon struct - merge into this builder!\n+            GroupLayout parentLayout = (GroupLayout)((Declaration.Scoped)parent).layout().get();\n+            String anonName = findAnonymousStructName(parentLayout, layout);\n+            pushPrefixElement(anonName);\n+            return this;\n+        } else {\n+            return super.addStruct(name, parent, layout, type);\n+        }\n+    }\n+\n+    private String findAnonymousStructName(GroupLayout parentLayout, GroupLayout layout) {\n+        \/\/ nested anonymous struct or union\n+        for (MemoryLayout ml : parentLayout.memberLayouts()) {\n+            \/\/ look for anonymous structs\n+            if (ml.attribute(JEXTRACT_ANONYMOUS).isPresent()) {\n+                \/\/ it's enough to just compare the member layouts, since the member names\n+                \/\/ have to be unique within the parent layout (in C)\n+                if (((GroupLayout) ml).memberLayouts().equals(layout.memberLayouts())) {\n+                    return ml.name().orElseThrow();\n+                }\n+            }\n+        }\n+        throw new IllegalStateException(\"Could not find layout in parent\");\n+    }\n+\n+    @Override\n+    public void addVar(String javaName, String nativeName, VarInfo varInfo) {\n+        try {\n+            structLayout.byteOffset(elementPaths(nativeName));\n+        } catch (UnsupportedOperationException uoe) {\n+            \/\/ bad layout - do nothing\n+            OutputFactory.warn(\"skipping '\" + className() + \".\" + nativeName + \"' : \" + uoe.toString());\n+            return;\n+        }\n+        if (varInfo.carrier().equals(MemorySegment.class)) {\n+            emitSegmentGetter(javaName, nativeName, varInfo.layout());\n+        } else {\n+            Constant vhConstant = addFieldVarHandle(javaName, nativeName, varInfo, layoutField(), prefixNamesList())\n+                    .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME);\n+            emitFieldGetter(vhConstant, javaName, varInfo.carrier());\n+            emitFieldSetter(vhConstant, javaName, varInfo.carrier());\n+            emitIndexedFieldGetter(vhConstant, javaName, varInfo.carrier());\n+            emitIndexedFieldSetter(vhConstant, javaName, varInfo.carrier());\n+            if (varInfo.fiName().isPresent()) {\n+                emitFunctionalInterfaceGetter(varInfo.fiName().get(), javaName);\n+            }\n+        }\n+    }\n+\n+    private void emitFunctionalInterfaceGetter(String fiName, String javaName) {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS + \" \");\n+        append(fiName + \" \" + javaName + \" (MemorySegment segment) {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return \" + fiName + \".ofAddressRestricted(\" + javaName + \"$get(segment));\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitFieldGetter(Constant vhConstant, String javaName, Class<?> type) {\n+        incrAlign();\n+        indent();\n+        String seg = safeParameterName(\"seg\");\n+        append(MEMBER_MODS + \" \" + type.getSimpleName() + \" \" + javaName + \"$get(MemorySegment \" + seg + \") {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return (\" + type.getName() + \")\"\n+                + vhConstant.accessExpression() + \".get(\" + seg + \");\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitFieldSetter(Constant vhConstant, String javaName, Class<?> type) {\n+        incrAlign();\n+        indent();\n+        String seg = safeParameterName(\"seg\");\n+        String x = safeParameterName(\"x\");\n+        String param = MemorySegment.class.getSimpleName() + \" \" + seg;\n+        append(MEMBER_MODS + \" void \" + javaName + \"$set( \" + param + \", \" + type.getSimpleName() + \" \" + x + \") {\\n\");\n+        incrAlign();\n+        indent();\n+        append(vhConstant.accessExpression() + \".set(\" + seg + \", \" + x + \");\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private MemoryLayout.PathElement[] elementPaths(String nativeFieldName) {\n+        List<String> prefixElements = prefixNamesList();\n+        MemoryLayout.PathElement[] elems = new MemoryLayout.PathElement[prefixElements.size() + 1];\n+        int i = 0;\n+        for (; i < prefixElements.size(); i++) {\n+            elems[i] = MemoryLayout.PathElement.groupElement(prefixElements.get(i));\n+        }\n+        elems[i] = MemoryLayout.PathElement.groupElement(nativeFieldName);\n+        return elems;\n+    }\n+\n+    private void emitSegmentGetter(String javaName, String nativeName, MemoryLayout layout) {\n+        incrAlign();\n+        indent();\n+        String seg = safeParameterName(\"seg\");\n+        append(MEMBER_MODS + \" MemorySegment \" + javaName + \"$slice(MemorySegment \" + seg + \") {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return RuntimeHelper.nonCloseableNonTransferableSegment(\");\n+        append(seg);\n+        append(\".asSlice(\");\n+        append(structLayout.byteOffset(elementPaths(nativeName)));\n+        append(\", \");\n+        append(layout.byteSize());\n+        append(\"));\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitSizeof() {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS);\n+        append(\" long sizeof() { return $LAYOUT().byteSize(); }\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitAllocate() {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS);\n+        append(\" MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitScopeAllocate() {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS);\n+        append(\" MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitAllocateArray() {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS);\n+        append(\" MemorySegment allocateArray(int len) {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\\n\");\n+        decrAlign();\n+        indent();\n+        append('}');\n+        decrAlign();\n+    }\n+\n+    private void emitScopeAllocateArray() {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS);\n+        append(\" MemorySegment allocateArray(int len, NativeScope scope) {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitAllocatePoiner() {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS);\n+        append(\" MemorySegment allocatePointer() {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return MemorySegment.allocateNative(C_POINTER);\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitScopeAllocatePointer() {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS);\n+        append(\" MemorySegment allocatePointer(NativeScope scope) {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return scope.allocate(C_POINTER);\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitAsRestricted() {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS);\n+        append(\" MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitIndexedFieldGetter(Constant vhConstant, String javaName, Class<?> type) {\n+        incrAlign();\n+        indent();\n+        String index = safeParameterName(\"index\");\n+        String seg = safeParameterName(\"seg\");\n+        String params = MemorySegment.class.getSimpleName() + \" \" + seg + \", long \" + index;\n+        append(MEMBER_MODS + \" \" + type.getSimpleName() + \" \" + javaName + \"$get(\" + params + \") {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return (\" + type.getName() + \")\");\n+        append(vhConstant.accessExpression());\n+        append(\".get(\");\n+        append(seg);\n+        append(\".asSlice(\");\n+        append(index);\n+        append(\"*sizeof()));\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitIndexedFieldSetter(Constant vhConstant, String javaName, Class<?> type) {\n+        incrAlign();\n+        indent();\n+        String index = safeParameterName(\"index\");\n+        String seg = safeParameterName(\"seg\");\n+        String x = safeParameterName(\"x\");\n+        String params = MemorySegment.class.getSimpleName() + \" \" + seg +\n+            \", long \" + index + \", \" + type.getSimpleName() + \" \" + x;\n+        append(MEMBER_MODS + \" void \" + javaName + \"$set(\" + params + \") {\\n\");\n+        incrAlign();\n+        indent();\n+        append(vhConstant.accessExpression());\n+        append(\".set(\");\n+        append(seg);\n+        append(\".asSlice(\");\n+        append(index);\n+        append(\"*sizeof()), \");\n+        append(x);\n+        append(\");\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private String qualifiedName(JavaSourceBuilder builder) {\n+        if (builder instanceof NestedClassBuilder) {\n+            NestedClassBuilder nestedClassBuilder = (NestedClassBuilder)builder;\n+            String prefix = qualifiedName(nestedClassBuilder.enclosing);\n+            return prefix.isEmpty() ?\n+                    nestedClassBuilder.className() :\n+                    prefix + \"$\" + nestedClassBuilder.className();\n+        } else {\n+            return \"\";\n+        }\n+    }\n+\n+    private String layoutField() {\n+        String suffix = structLayout.isUnion() ? \"union\" : \"struct\";\n+        return qualifiedName(this) + \"$\" + suffix;\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/StructBuilder.java","additions":392,"deletions":0,"binary":false,"changes":392,"status":"added"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.ValueLayout;\n+import jdk.internal.clang.Cursor;\n+import jdk.internal.clang.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * MemoryLayout computer for C structs.\n+ *\/\n+final class StructLayoutComputer extends RecordLayoutComputer {\n+    private long offset;\n+    private long actualSize = 0L;\n+    \/\/ List to collect bitfield fields to process later, may be null\n+    private List<MemoryLayout> bitfieldLayouts;\n+\n+    StructLayoutComputer(long offsetInParent, Type parent, Type type) {\n+        super(parent, type);\n+        this.offset = offsetInParent;\n+    }\n+\n+    @Override\n+    void addFieldLayout(MemoryLayout MemoryLayout) {\n+        if (bitfieldLayouts != null) {\n+            bitfieldLayouts.add(MemoryLayout);\n+        } else {\n+            fieldLayouts.add(MemoryLayout);\n+        }\n+    }\n+\n+    @Override\n+    void startBitfield() {\n+        \/*\n+         * In a struct, a bitfield field is seen after a non-bitfield.\n+         * Initialize bitfieldLayouts list to collect this and subsequent\n+         * bitfield layouts.\n+         *\/\n+        if (bitfieldLayouts == null) {\n+            bitfieldLayouts = new ArrayList<>();\n+        }\n+    }\n+\n+    @Override\n+    void processField(Cursor c) {\n+        boolean isBitfield = c.isBitField();\n+        long expectedOffset = offsetOf(parent, c);\n+        if (expectedOffset > offset) {\n+            addFieldLayout(MemoryLayout.ofPaddingBits(expectedOffset - offset));\n+            actualSize += (expectedOffset - offset);\n+            offset = expectedOffset;\n+        }\n+\n+        if (isBitfield) {\n+            startBitfield();\n+        } else { \/\/ !isBitfield\n+            \/*\n+             * We may be crossing from bit fields to non-bitfield field.\n+             *\n+             * struct Foo {\n+             *     int i:12;\n+             *     int j:20;\n+             *     int k; \/\/ <-- processing this\n+             *     int m;\n+             * }\n+             *\/\n+            handleBitfields();\n+        }\n+\n+        addFieldLayout(offset, parent, c);\n+        long size = fieldSize(c);\n+        offset += size;\n+        actualSize += size;\n+    }\n+\n+    @Override\n+    MemoryLayout finishLayout() {\n+        \/\/ pad at the end, if any\n+        long expectedSize = type.size() * 8;\n+        if (actualSize < expectedSize) {\n+            addFieldLayout(MemoryLayout.ofPaddingBits(expectedSize - actualSize));\n+        }\n+\n+        \/*\n+         * Handle bitfields at the end, if any.\n+         *\n+         * struct Foo {\n+         *     int i,j, k;\n+         *     int f:10;\n+         *     int pad:12;\n+         * }\n+         *\/\n+        handleBitfields();\n+\n+        MemoryLayout[] fields = fieldLayouts.toArray(new MemoryLayout[0]);\n+        GroupLayout g = MemoryLayout.ofStruct(fields);\n+        String name = LayoutUtils.getName(cursor);\n+        return name.isEmpty() ?\n+                g : g.withName(name);\n+    }\n+\n+    \/\/ process bitfields if any and clear bitfield layouts\n+    private void handleBitfields() {\n+        if (bitfieldLayouts != null) {\n+            fieldLayouts.add(bitfield(bitfieldLayouts));\n+            bitfieldLayouts = null;\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/StructLayoutComputer.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,197 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Type;\n+\n+import javax.tools.JavaFileObject;\n+import java.lang.constant.ClassDesc;\n+import java.lang.invoke.MethodType;\n+import java.util.*;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * A helper class to generate header interface class in source form.\n+ * After aggregating various constituents of a .java source, build\n+ * method is called to get overall generated source string.\n+ *\/\n+class ToplevelBuilder extends JavaSourceBuilder {\n+\n+    private int declCount;\n+    private final String[] libraryNames;\n+    private final List<SplitHeader> headers = new ArrayList<>();\n+\n+    static final int DECLS_PER_HEADER_CLASS = Integer.getInteger(\"jextract.decls.per.header\", 1000);\n+\n+    ToplevelBuilder(ClassDesc desc, String[] libraryNames) {\n+        super(Kind.CLASS, desc);\n+        this.libraryNames = libraryNames;\n+        SplitHeader first = new FirstHeader(ClassDesc.of(packageName(), className()));\n+        first.classBegin();\n+        headers.add(first);\n+    }\n+\n+    @Override\n+    void classBegin() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    JavaSourceBuilder classEnd() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public List<JavaFileObject> toFiles() {\n+        headers.stream().skip(1).findFirst()\n+                .orElse(lastHeader()).emitLibraries(libraryNames);\n+        List<JavaFileObject> files = new ArrayList<>();\n+        files.addAll(headers.stream()\n+                .flatMap(hf -> hf.toFiles().stream())\n+                .collect(Collectors.toList()));\n+        return files;\n+    }\n+\n+    @Override\n+    public void addVar(String javaName, String nativeName, VarInfo varInfo) {\n+        nextHeader().addVar(javaName, nativeName, varInfo);\n+    }\n+\n+    @Override\n+    public void addFunction(String javaName, String nativeName, FunctionInfo functionInfo) {\n+        nextHeader().addFunction(javaName, nativeName, functionInfo);\n+    }\n+\n+    @Override\n+    public void addConstant(String javaName, Class<?> type, Object value) {\n+        nextHeader().addConstant(javaName, type, value);\n+    }\n+\n+    @Override\n+    public void addTypedef(String name, String superClass, Type type) {\n+        nextHeader().addTypedef(name, superClass, type);\n+    }\n+\n+    @Override\n+    public StructBuilder addStruct(String name, Declaration parent, GroupLayout layout, Type type) {\n+        return nextHeader().addStruct(name, parent, layout, type);\n+    }\n+\n+    @Override\n+    public String addFunctionalInterface(String name, FunctionInfo functionInfo) {\n+        return nextHeader().addFunctionalInterface(name, functionInfo);\n+    }\n+\n+    private SplitHeader lastHeader() {\n+        return headers.get(headers.size() - 1);\n+    }\n+\n+    private SplitHeader nextHeader() {\n+        if (declCount == DECLS_PER_HEADER_CLASS) {\n+            boolean hasSuper = !(lastHeader() instanceof FirstHeader);\n+            SplitHeader headerFileBuilder = new SplitHeader(ClassDesc.of(packageName(), className() + \"_\" + headers.size()),\n+                    hasSuper ? lastHeader().className() : null);\n+            headerFileBuilder.classBegin();\n+            headers.add(headerFileBuilder);\n+            declCount = 1;\n+            return headerFileBuilder;\n+        } else {\n+            declCount++;\n+            return lastHeader();\n+        }\n+    }\n+\n+    static class SplitHeader extends HeaderFileBuilder {\n+        SplitHeader(ClassDesc desc, String superclass) {\n+            super(desc, superclass);\n+        }\n+\n+        @Override\n+        String mods() {\n+            return \" \";\n+        }\n+\n+        private void emitLibraries(String[] libraryNames) {\n+            incrAlign();\n+            indent();\n+            append(\"static final \");\n+            append(\"LibraryLookup[] LIBRARIES = RuntimeHelper.libraries(new String[] {\\n\");\n+            incrAlign();\n+            for (String lib : libraryNames) {\n+                indent();\n+                append('\\\"');\n+                append(quoteLibraryName(lib));\n+                append(\"\\\",\\n\");\n+            }\n+            decrAlign();\n+            indent();\n+            append(\"});\\n\\n\");\n+            decrAlign();\n+        }\n+\n+        private static String quoteLibraryName(String lib) {\n+            return lib.replace(\"\\\\\", \"\\\\\\\\\"); \/\/ double up slashes\n+        }\n+    }\n+\n+    class FirstHeader extends SplitHeader {\n+\n+        FirstHeader(ClassDesc desc) {\n+            super(desc, \"#{SUPER}\");\n+        }\n+\n+        @Override\n+        String mods() {\n+            return \"public \";\n+        }\n+\n+        @Override\n+        void classBegin() {\n+            super.classBegin();\n+            emitConstructor();\n+        }\n+\n+        void emitConstructor() {\n+            incrAlign();\n+            indent();\n+            append(\"\/* package-private *\/ \");\n+            append(className());\n+            append(\"() {}\");\n+            append('\\n');\n+            decrAlign();\n+        }\n+\n+        @Override\n+        String build() {\n+            HeaderFileBuilder last = lastHeader();\n+            return super.build().replace(\"extends #{SUPER}\",\n+                    last != this ? \"extends \" + last.className() : \"\");\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/ToplevelBuilder.java","additions":197,"deletions":0,"binary":false,"changes":197,"status":"added"},{"patch":"@@ -0,0 +1,345 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.jextract.impl;\n+\n+import java.lang.constant.Constable;\n+import java.nio.ByteOrder;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Position;\n+import jdk.incubator.jextract.Type;\n+import jdk.internal.clang.Cursor;\n+import jdk.internal.clang.CursorKind;\n+import jdk.internal.clang.SourceLocation;\n+\n+class TreeMaker {\n+    public TreeMaker() {}\n+\n+    TypeMaker typeMaker = new TypeMaker(this);\n+\n+    public void freeze() {\n+        typeMaker.resolveTypeReferences();\n+    }\n+\n+    interface ScopedFactoryLayout {\n+        Declaration.Scoped make(Position pos, String name, MemoryLayout layout, Declaration... decls);\n+    }\n+\n+    interface ScopedFactoryNoLayout {\n+        Declaration.Scoped make(Position pos, String name, Declaration... decls);\n+    }\n+\n+    interface VarFactoryNoLayout {\n+        Declaration.Variable make(Position pos, String name, Type type);\n+    }\n+\n+    Map<String, List<Constable>> collectAttributes(Cursor c) {\n+        return c.children().filter(Cursor::isAttribute)\n+                .collect(Collectors.groupingBy(\n+                        attr -> attr.kind().name(),\n+                        Collectors.mapping(Cursor::spelling, Collectors.toList())\n+                ));\n+    }\n+\n+    public Declaration createTree(Cursor c) {\n+        Objects.requireNonNull(c);\n+        var rv = (DeclarationImpl) createTreeInternal(c);\n+        return (rv == null) ? null : rv.withAttributes(collectAttributes(c));\n+    }\n+\n+    private Declaration createTreeInternal(Cursor c) {\n+        switch (c.kind()) {\n+            case EnumDecl:\n+                return createScoped(c, Declaration.Scoped.Kind.ENUM, Declaration::enum_, Declaration::enum_);\n+            case EnumConstantDecl:\n+                return createEnumConstant(c);\n+            case FieldDecl:\n+                return createVar(c.isBitField() ?\n+                        Declaration.Variable.Kind.BITFIELD : Declaration.Variable.Kind.FIELD, c, Declaration::field);\n+            case ParmDecl:\n+                return createVar(Declaration.Variable.Kind.PARAMETER, c, Declaration::parameter);\n+            case FunctionDecl:\n+                return createFunction(c);\n+            case StructDecl:\n+                return createScoped(c, Declaration.Scoped.Kind.STRUCT, Declaration::struct, Declaration::struct);\n+            case UnionDecl:\n+                return createScoped(c, Declaration.Scoped.Kind.UNION, Declaration::union, Declaration::union);\n+            case TypedefDecl: {\n+                return createTypedef(c);\n+            }\n+            case VarDecl:\n+                return createVar(Declaration.Variable.Kind.GLOBAL, c, Declaration::globalVariable);\n+            default:\n+                return null;\n+        }\n+    }\n+\n+    Position toPos(Cursor cursor) {\n+        SourceLocation loc = cursor.getSourceLocation();\n+        if (loc == null) {\n+            return Position.NO_POSITION;\n+        }\n+        SourceLocation.Location sloc = loc.getFileLocation();\n+        if (sloc == null) {\n+            return Position.NO_POSITION;\n+        }\n+        return new CursorPosition(cursor);\n+    }\n+\n+    static class CursorPosition implements Position {\n+        private final Cursor cursor;\n+        private final Path path;\n+        private final int line;\n+        private final int column;\n+\n+        CursorPosition(Cursor cursor) {\n+            this.cursor = cursor;\n+            SourceLocation.Location loc = cursor.getSourceLocation().getFileLocation();\n+            this.path = loc.path();\n+            this.line = loc.line();\n+            this.column = loc.column();\n+        }\n+\n+        @Override\n+        public Path path() {\n+            return path;\n+        }\n+\n+        @Override\n+        public int line() {\n+            return line;\n+        }\n+\n+        @Override\n+        public int col() {\n+            return column;\n+        }\n+\n+        public Cursor cursor() {\n+            return cursor;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return PrettyPrinter.position(this);\n+        }\n+    }\n+\n+    public Declaration.Function createFunction(Cursor c) {\n+        checkCursor(c, CursorKind.FunctionDecl);\n+        List<Declaration.Variable> params = new ArrayList<>();\n+        for (int i = 0 ; i < c.numberOfArgs() ; i++) {\n+            params.add((Declaration.Variable)createTree(c.getArgument(i)));\n+        }\n+        Type type = toType(c);\n+        Type funcType = type instanceof Type.Delegated? ((Type.Delegated)type).type() : type;\n+        return Declaration.function(toPos(c), c.spelling(), (Type.Function)funcType,\n+                params.toArray(new Declaration.Variable[0]));\n+    }\n+\n+    public Declaration.Constant createMacro(Cursor c, String name, Type type, Object value) {\n+        checkCursorAny(c, CursorKind.MacroDefinition);\n+        return Declaration.constant(toPos(c), name, value, type);\n+    }\n+\n+    public Declaration.Constant createEnumConstant(Cursor c) {\n+        return Declaration.constant(toPos(c), c.spelling(), c.getEnumConstantValue(), typeMaker.makeType(c.type()));\n+    }\n+\n+    public Declaration.Scoped createHeader(Cursor c, List<Declaration> decls) {\n+        return Declaration.toplevel(toPos(c), filterNestedDeclarations(decls).toArray(new Declaration[0]));\n+    }\n+\n+    public Declaration.Scoped createScoped(Cursor c, Declaration.Scoped.Kind scopeKind, ScopedFactoryLayout factoryLayout, ScopedFactoryNoLayout factoryNoLayout) {\n+        List<Declaration> decls = filterNestedDeclarations(c.children()\n+                .filter(fc -> {\n+                    if (fc.isBitField()) {\n+                        \/\/ only non-empty and named bit fields are generated\n+                        return fc.getBitFieldWidth() != 0 && !fc.spelling().isEmpty();\n+                    }\n+                    return true;\n+                })\n+                .map(this::createTree).collect(Collectors.toList()));\n+        if (c.isDefinition()) {\n+            \/\/just a declaration AND definition, we have a layout\n+            MemoryLayout layout = null;\n+            try {\n+                layout = LayoutUtils.getLayout(c.type());\n+            } catch (TypeMaker.TypeException ex) {\n+                System.err.println(ex);\n+                System.err.println(\"WARNING: generating empty struct: \" + c.spelling());\n+                return factoryNoLayout.make(toPos(c), c.spelling(), decls.toArray(new Declaration[0]));\n+            }\n+            List<Declaration> adaptedDecls = layout instanceof GroupLayout ?\n+                    collectBitfields(layout, decls) :\n+                    decls;\n+            return factoryLayout.make(toPos(c), c.spelling(), layout, adaptedDecls.toArray(new Declaration[0]));\n+        } else {\n+            \/\/just a declaration\n+            if (scopeKind == Declaration.Scoped.Kind.STRUCT ||\n+                    scopeKind == Declaration.Scoped.Kind.UNION ||\n+                    scopeKind == Declaration.Scoped.Kind.ENUM ||\n+                    scopeKind == Declaration.Scoped.Kind.CLASS) {\n+                \/\/if there's a real definition somewhere else, skip this redundant declaration\n+                if (!c.getDefinition().isInvalid()) {\n+                    return null;\n+                }\n+            }\n+            return factoryNoLayout.make(toPos(c), c.spelling(), decls.toArray(new Declaration[0]));\n+        }\n+    }\n+\n+    private static boolean isEnum(Declaration d) {\n+        return d instanceof Declaration.Scoped && ((Declaration.Scoped)d).kind() == Declaration.Scoped.Kind.ENUM;\n+    }\n+\n+    private static boolean isAnonymousStruct(Declaration declaration) {\n+        return ((CursorPosition)declaration.pos()).cursor.isAnonymousStruct();\n+    }\n+\n+    private List<Declaration> filterNestedDeclarations(List<Declaration> declarations) {\n+        return declarations.stream()\n+                .filter(Objects::nonNull)\n+                .filter(d -> isEnum(d) || !d.name().isEmpty() || isAnonymousStruct(d))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private Declaration.Typedef createTypedef(Cursor c) {\n+        Type cursorType = toType(c);\n+        Type canonicalType = cursorType instanceof Type.Function\n+            ? cursorType\n+            : ((Type.Delegated) cursorType).type(); \/\/ normal typedef\n+        if (canonicalType instanceof Type.Declared) {\n+            Declaration.Scoped s = ((Type.Declared) canonicalType).tree();\n+            if (s.name().equals(c.spelling())) {\n+                \/\/ typedef record with the same name, no need to present twice\n+                return null;\n+            }\n+        }\n+        return Declaration.typedef(toPos(c), c.spelling(), canonicalType);\n+    }\n+\n+    private Declaration.Variable createVar(Declaration.Variable.Kind kind, Cursor c, VarFactoryNoLayout varFactory) {\n+        checkCursorAny(c, CursorKind.VarDecl, CursorKind.FieldDecl, CursorKind.ParmDecl);\n+        if (c.isBitField()) {\n+            return Declaration.bitfield(toPos(c), c.spelling(), toType(c),\n+                    MemoryLayout.ofValueBits(c.getBitFieldWidth(), ByteOrder.nativeOrder()));\n+        } else {\n+            Type type = null;\n+            try {\n+                type = toType(c);\n+            } catch (TypeMaker.TypeException ex) {\n+                System.err.println(ex);\n+                System.err.println(\"WARNING: ignoring variable: \" + c.spelling());\n+                return null;\n+            }\n+            return varFactory.make(toPos(c), c.spelling(), type);\n+        }\n+    }\n+\n+    private static void collectNestedBitFields(Set<Declaration> out, Declaration.Scoped anonymousStruct) {\n+        for  (Declaration field : anonymousStruct.members()) {\n+            if (isAnonymousStruct(field)) {\n+                collectNestedBitFields(out, (Declaration.Scoped) field);\n+            } else if (field instanceof Declaration.Scoped\n+                       && ((Declaration.Scoped) field).kind() == Declaration.Scoped.Kind.BITFIELDS) {\n+                out.addAll(((Declaration.Scoped) field).members());\n+            }\n+        }\n+    }\n+\n+    private static Set<Declaration> nestedBitFields(List<Declaration> members) {\n+        Set<Declaration> res = new HashSet<>();\n+        for (Declaration member : members) {\n+            if (isAnonymousStruct(member)) {\n+                collectNestedBitFields(res, (Declaration.Scoped) member);\n+            }\n+        }\n+        return res;\n+    }\n+\n+    private List<Declaration> collectBitfields(MemoryLayout layout, List<Declaration> declarations) {\n+        Set<String> nestedBitfieldNames = nestedBitFields(declarations).stream()\n+                                                                       .map(Declaration::name)\n+                                                                       .collect(Collectors.toSet());\n+        List<Declaration> newDecls = new ArrayList<>();\n+        for (MemoryLayout e : ((GroupLayout)layout).memberLayouts()) {\n+            if (e instanceof GroupLayout contents && LayoutUtils.isBitfields(contents)) {\n+                List<Declaration.Variable> bfDecls = new ArrayList<>();\n+                outer: for (MemoryLayout bitfield : contents.memberLayouts()) {\n+                    if (bitfield.name().isPresent() && !nestedBitfieldNames.contains(bitfield.name().get())) {\n+                        Iterator<Declaration> declIt = declarations.iterator();\n+                        while (declIt.hasNext()) {\n+                            Declaration d = declIt.next();\n+                            if (d.name().equals(bitfield.name().get())) {\n+                                bfDecls.add((Declaration.Variable)d);\n+                                declIt.remove();\n+                                continue outer;\n+                            }\n+                        }\n+                        throw new IllegalStateException(\"No matching declaration found for bitfield: \" + bitfield);\n+                    }\n+                }\n+                if (!bfDecls.isEmpty()) {\n+                    newDecls.add(Declaration.bitfields(bfDecls.get(0).pos(), \"\", contents, bfDecls.toArray(new Declaration.Variable[0])));\n+                }\n+            }\n+        }\n+        newDecls.addAll(declarations);\n+        return newDecls;\n+    }\n+\n+    private Type toType(Cursor c) {\n+        return typeMaker.makeType(c.type());\n+    }\n+\n+    private void checkCursor(Cursor c, CursorKind k) {\n+        if (c.kind() != k) {\n+            throw new IllegalArgumentException(\"Invalid cursor kind\");\n+        }\n+    }\n+\n+    private void checkCursorAny(Cursor c, CursorKind... kinds) {\n+        CursorKind expected = Objects.requireNonNull(c.kind());\n+        for (CursorKind k : kinds) {\n+            if (k == expected) {\n+                return;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Invalid cursor kind\");\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/TreeMaker.java","additions":345,"deletions":0,"binary":false,"changes":345,"status":"added"},{"patch":"@@ -0,0 +1,343 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.OptionalLong;\n+import java.util.function.Supplier;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Type;\n+\n+public abstract class TypeImpl implements Type {\n+\n+    @Override\n+    public boolean isErroneous() {\n+        return false;\n+    }\n+\n+    static boolean equals(Type t1, Type.Delegated t2) {\n+        assert t1 != null;\n+        assert t2 != null;\n+\n+        return (t2.kind() == Delegated.Kind.TYPEDEF) && t1.equals(t2.type());\n+    }\n+\n+    public static final TypeImpl ERROR = new TypeImpl() {\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitType(this, data);\n+        }\n+\n+        @Override\n+        public boolean isErroneous() {\n+            return true;\n+        }\n+    };\n+\n+    public static final class PrimitiveImpl extends TypeImpl implements Type.Primitive {\n+\n+        private final Primitive.Kind kind;\n+\n+        public PrimitiveImpl(Kind kind) {\n+            this.kind = Objects.requireNonNull(kind);\n+        }\n+\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitPrimitive(this, data);\n+        }\n+\n+        @Override\n+        public Kind kind() {\n+            return kind;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Type.Primitive)) {\n+                return (o instanceof Delegated) && equals(this, (Delegated)o);\n+            }\n+            Type.Primitive primitive = (Type.Primitive) o;\n+            return kind == primitive.kind();\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(kind);\n+        }\n+    }\n+\n+    static abstract class DelegatedBase extends TypeImpl implements Type.Delegated {\n+        Delegated.Kind kind;\n+        Optional<String> name;\n+\n+        DelegatedBase(Kind kind, Optional<String> name) {\n+            this.kind = Objects.requireNonNull(kind);\n+            this.name = Objects.requireNonNull(name);\n+        }\n+\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitDelegated(this, data);\n+        }\n+\n+        @Override\n+        public final Delegated.Kind kind() {\n+            return kind;\n+        }\n+\n+        @Override\n+        public final Optional<String> name() {\n+            return name;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Type.Delegated)) {\n+                return (o instanceof Type) && equals((Type)o, this);\n+            }\n+            Type.Delegated that = (Type.Delegated) o;\n+            return kind == that.kind() &&\n+                    name.equals(that.name());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(kind, name);\n+        }\n+    }\n+\n+    public static final class QualifiedImpl extends DelegatedBase {\n+        private final Type type;\n+\n+        public QualifiedImpl(Kind kind, Type type) {\n+            this(kind, Optional.empty(), type);\n+        }\n+\n+        public QualifiedImpl(Kind kind, String name, Type type) {\n+            this(kind, Optional.of(name), type);\n+        }\n+\n+        private QualifiedImpl(Kind kind, Optional<String> name, Type type) {\n+            super(kind, name);\n+            this.type = type;\n+        }\n+\n+        @Override\n+        public Type type() {\n+            return type;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Type.Delegated)) return false;\n+            if (!super.equals(o)) {\n+                return (o instanceof Delegated) && equals(this, (Delegated) o);\n+            }\n+            Type.Delegated qualified = (Type.Delegated) o;\n+            return Objects.equals(type, qualified.type());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return (kind() == Kind.TYPEDEF)? type().hashCode() : Objects.hash(super.hashCode(), type);\n+        }\n+    }\n+\n+    public static final class PointerImpl extends DelegatedBase {\n+        private final Supplier<Type> pointeeFactory;\n+\n+        public PointerImpl(Supplier<Type> pointeeFactory) {\n+            super(Kind.POINTER, Optional.empty());\n+            this.pointeeFactory = Objects.requireNonNull(pointeeFactory);\n+        }\n+\n+        public PointerImpl(Type pointee) {\n+            this(() -> pointee);\n+        }\n+\n+        @Override\n+        public Type type() {\n+            return pointeeFactory.get();\n+        }\n+    }\n+\n+    public static final class DeclaredImpl extends TypeImpl implements Type.Declared {\n+\n+        private final Declaration.Scoped declaration;\n+\n+        public DeclaredImpl(Declaration.Scoped declaration) {\n+            super();\n+            this.declaration = Objects.requireNonNull(declaration);\n+        }\n+\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitDeclared(this, data);\n+        }\n+\n+        @Override\n+        public Declaration.Scoped tree() {\n+            return declaration;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Type.Declared)) {\n+                return (o instanceof Delegated) && equals(this, (Delegated) o);\n+            }\n+            Type.Declared declared = (Type.Declared) o;\n+            return declaration.equals(declared.tree());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(declaration);\n+        }\n+    }\n+\n+    public static final class FunctionImpl extends TypeImpl implements Type.Function {\n+\n+        private final boolean varargs;\n+        private final List<Type> argtypes;\n+        private final Type restype;\n+\n+        public FunctionImpl(boolean varargs, List<Type> argtypes, Type restype) {\n+            super();\n+            this.varargs = varargs;\n+            this.argtypes = Objects.requireNonNull(argtypes);\n+            this.restype = Objects.requireNonNull(restype);\n+        }\n+\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitFunction(this, data);\n+        }\n+\n+        @Override\n+        public boolean varargs() {\n+            return varargs;\n+        }\n+\n+        @Override\n+        public List<Type> argumentTypes() {\n+            return argtypes;\n+        }\n+\n+        @Override\n+        public Type returnType() {\n+            return restype;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Type.Function)) {\n+                return (o instanceof Delegated) && equals(this, (Delegated) o);\n+            }\n+            Type.Function function = (Type.Function) o;\n+            return varargs == function.varargs() &&\n+                    argtypes.equals(function.argumentTypes()) &&\n+                    restype.equals(function.returnType());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(varargs, argtypes, restype);\n+        }\n+    }\n+\n+    public static final class ArrayImpl extends TypeImpl implements Type.Array {\n+\n+        private final Kind kind;\n+        private final OptionalLong elemCount;\n+        private final Type elemType;\n+\n+        public ArrayImpl(Kind kind, long count, Type elemType) {\n+            this(kind, elemType, OptionalLong.of(count));\n+        }\n+\n+        public ArrayImpl(Kind kind, Type elemType) {\n+            this(kind, elemType, OptionalLong.empty());\n+        }\n+\n+        private ArrayImpl(Kind kind, Type elemType, OptionalLong elemCount) {\n+            super();\n+            this.kind = Objects.requireNonNull(kind);\n+            this.elemCount = Objects.requireNonNull(elemCount);\n+            this.elemType = Objects.requireNonNull(elemType);\n+        }\n+\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitArray(this, data);\n+        }\n+\n+        @Override\n+        public OptionalLong elementCount() {\n+            return elemCount;\n+        }\n+\n+        @Override\n+        public Type elementType() {\n+            return elemType;\n+        }\n+\n+        @Override\n+        public Kind kind() {\n+            return kind;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Type.Array)) {\n+                return (o instanceof Delegated) && equals(this, (Delegated) o);\n+            }\n+            Type.Array array = (Type.Array) o;\n+            return kind == array.kind() &&\n+                    elemType.equals(array.elementType());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(kind, elemType);\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return PrettyPrinter.type(this);\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/TypeImpl.java","additions":343,"deletions":0,"binary":false,"changes":343,"status":"added"},{"patch":"@@ -0,0 +1,257 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+\n+import java.util.ArrayList;\n+import java.util.ConcurrentModificationException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Supplier;\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Type;\n+import jdk.incubator.jextract.Type.Delegated;\n+import jdk.incubator.jextract.Type.Primitive;\n+\n+class TypeMaker {\n+\n+    TreeMaker treeMaker;\n+    private final Map<jdk.internal.clang.Type, Type> typeCache = new HashMap<>();\n+    private List<ClangTypeReference> unresolved = new ArrayList<>();\n+\n+    private class ClangTypeReference implements Supplier<Type> {\n+        jdk.internal.clang.Type origin;\n+        Type derived;\n+\n+        private ClangTypeReference(jdk.internal.clang.Type origin) {\n+            this.origin = origin;\n+            derived = typeCache.get(origin);\n+        }\n+\n+        public boolean isUnresolved() {\n+            return null == derived;\n+        }\n+\n+        public void resolve() {\n+            derived = makeType(origin);\n+            Objects.requireNonNull(derived, \"Clang type cannot be resolved: \" + origin.spelling());\n+        }\n+\n+        public Type get() {\n+            Objects.requireNonNull(derived, \"Type is not yet resolved.\");\n+            return derived;\n+        }\n+    }\n+\n+    private ClangTypeReference reference(jdk.internal.clang.Type type) {\n+        ClangTypeReference ref = new ClangTypeReference(type);\n+        if (ref.isUnresolved()) {\n+            unresolved.add(ref);\n+        }\n+        return ref;\n+    }\n+\n+    public TypeMaker(TreeMaker treeMaker) {\n+        this.treeMaker = treeMaker;\n+    }\n+\n+    \/**\n+     * Resolve all type references. This method should be called before discard clang cursors\/types\n+     *\/\n+    void resolveTypeReferences() {\n+        List<ClangTypeReference> resolving = unresolved;\n+        unresolved = new ArrayList<>();\n+        while (! resolving.isEmpty()) {\n+            resolving.forEach(ClangTypeReference::resolve);\n+            resolving = unresolved;\n+            unresolved = new ArrayList<>();\n+        }\n+    }\n+\n+    Type makeType(jdk.internal.clang.Type t) {\n+        Type rv = typeCache.get(t);\n+        if (rv != null) {\n+            return rv;\n+        }\n+        rv = makeTypeInternal(t);\n+        if (null != rv && typeCache.put(t, rv) != null) {\n+            throw new ConcurrentModificationException();\n+        }\n+        return rv;\n+    }\n+\n+    static class TypeException extends RuntimeException {\n+        static final long serialVersionUID = 1L;\n+\n+        TypeException(String msg) {\n+            super(msg);\n+        }\n+    }\n+\n+    Type makeTypeInternal(jdk.internal.clang.Type t) {\n+        switch(t.kind()) {\n+            case Auto:\n+                return makeType(t.canonicalType());\n+            case Void:\n+                return Type.void_();\n+            case Char_S:\n+            case Char_U:\n+                return Type.primitive(Primitive.Kind.Char);\n+            case Short:\n+                return Type.primitive(Primitive.Kind.Short);\n+            case Int:\n+                return Type.primitive(Primitive.Kind.Int);\n+            case Long:\n+                return Type.primitive(Primitive.Kind.Long);\n+            case LongLong:\n+                return Type.primitive(Primitive.Kind.LongLong);\n+            case SChar: {\n+                Type chType = Type.primitive(Primitive.Kind.Char);\n+                return Type.qualified(Delegated.Kind.SIGNED, chType);\n+            }\n+            case UShort: {\n+                Type chType = Type.primitive(Primitive.Kind.Short);\n+                return Type.qualified(Delegated.Kind.UNSIGNED, chType);\n+            }\n+            case UInt: {\n+                Type chType = Type.primitive(Primitive.Kind.Int);\n+                return Type.qualified(Delegated.Kind.UNSIGNED, chType);\n+            }\n+            case ULong: {\n+                Type chType = Type.primitive(Primitive.Kind.Long);\n+                return Type.qualified(Delegated.Kind.UNSIGNED, chType);\n+            }\n+            case ULongLong: {\n+                Type chType = Type.primitive(Primitive.Kind.LongLong);\n+                return Type.qualified(Delegated.Kind.UNSIGNED, chType);\n+            }\n+            case UChar: {\n+                Type chType = Type.primitive(Primitive.Kind.Char);\n+                return Type.qualified(Delegated.Kind.UNSIGNED, chType);\n+            }\n+\n+            case Bool:\n+                return Type.primitive(Primitive.Kind.Bool);\n+            case Double:\n+                return Type.primitive(Primitive.Kind.Double);\n+            case Float:\n+                return Type.primitive(Primitive.Kind.Float);\n+            case Unexposed:\n+            case Elaborated:\n+                jdk.internal.clang.Type canonical = t.canonicalType();\n+                if (canonical.equalType(t)) {\n+                    throw new TypeException(\"Unknown type with same canonical type: \" + t.spelling());\n+                }\n+                return makeType(canonical);\n+            case ConstantArray: {\n+                Type elem = makeType(t.getElementType());\n+                return Type.array(t.getNumberOfElements(), elem);\n+            }\n+            case IncompleteArray: {\n+                Type elem = makeType(t.getElementType());\n+                return Type.array(elem);\n+            }\n+            case FunctionProto:\n+            case FunctionNoProto: {\n+                List<Type> args = new ArrayList<>();\n+                for (int i = 0; i < t.numberOfArgs(); i++) {\n+                    \/\/ argument could be function pointer declared locally\n+                    args.add(lowerFunctionType(t.argType(i)));\n+                }\n+                return Type.function(t.isVariadic(), lowerFunctionType(t.resultType()), args.toArray(new Type[0]));\n+            }\n+            case Enum:\n+            case Record: {\n+                if (treeMaker == null) {\n+                    \/\/ Macro evaluation, type is meaningless as this can only be pointer and we only care value\n+                    return Type.void_();\n+                }\n+                return Type.declared((Declaration.Scoped) treeMaker.createTree(t.getDeclarationCursor()));\n+            }\n+            case BlockPointer:\n+            case Pointer: {\n+                \/\/ TODO: We can always erase type for macro evaluation, should we?\n+                return new TypeImpl.PointerImpl(reference(t.getPointeeType()));\n+            }\n+            case Typedef: {\n+                Type __type = makeType(t.canonicalType());\n+                return Type.typedef(t.spelling(), __type);\n+            }\n+            case Complex: {\n+                Type __type = makeType(t.getElementType());\n+                return Type.qualified(Delegated.Kind.COMPLEX, __type);\n+            }\n+            case Vector: {\n+                Type __type = makeType(t.getElementType());\n+                return Type.vector(t.getNumberOfElements(), __type);\n+            }\n+            case WChar: \/\/unsupported\n+                return Type.primitive(Primitive.Kind.WChar);\n+            case Char16: \/\/unsupported\n+                return Type.primitive(Primitive.Kind.Char16);\n+            case Half: \/\/unsupported\n+                return Type.primitive(Primitive.Kind.HalfFloat);\n+            case Int128: \/\/unsupported\n+                return Type.primitive(Primitive.Kind.Int128);\n+            case LongDouble: \/\/unsupported\n+                return Type.primitive(Primitive.Kind.LongDouble);\n+            case UInt128: { \/\/unsupported\n+                Type iType = Type.primitive(Primitive.Kind.Int128);\n+                return Type.qualified(Delegated.Kind.UNSIGNED, iType);\n+            }\n+            default:\n+                return TypeImpl.ERROR;\n+        }\n+    }\n+\n+    private Type lowerFunctionType(jdk.internal.clang.Type t) {\n+        Type t2 = makeType(t);\n+        return t2.accept(lowerFunctionType, null);\n+    }\n+\n+    private Type.Visitor<Type, Void> lowerFunctionType = new Type.Visitor<>() {\n+        @Override\n+        public Type visitArray(Type.Array t, Void aVoid) {\n+            return Type.pointer(t.elementType());\n+        }\n+\n+        @Override\n+        public Type visitDelegated(Type.Delegated t, Void aVoid) {\n+            if (t.kind() == Delegated.Kind.TYPEDEF && t.type() instanceof Type.Array) {\n+                return visitArray((Type.Array)t.type(), aVoid);\n+            }\n+            return visitType(t, aVoid);\n+        }\n+\n+        @Override\n+        public Type visitType(Type t, Void aVoid) {\n+            return t;\n+        }\n+    };\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/TypeMaker.java","additions":257,"deletions":0,"binary":false,"changes":257,"status":"added"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.jextract.Type.Primitive;\n+import jdk.incubator.jextract.Type;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+\n+import java.lang.invoke.MethodType;\n+\n+public class TypeTranslator implements Type.Visitor<Class<?>, Void> {\n+    @Override\n+    public Class<?> visitPrimitive(Type.Primitive t, Void aVoid) {\n+        if (t.kind().layout().isEmpty()) {\n+            return void.class;\n+        } else {\n+            return layoutToClass(isFloatingPoint(t), t.kind().layout().orElseThrow(UnsupportedOperationException::new));\n+        }\n+    }\n+\n+    private boolean isFloatingPoint(Type.Primitive t) {\n+        switch (t.kind()) {\n+            case Float:\n+            case Float128:\n+            case HalfFloat:\n+            case Double:\n+            case LongDouble:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    static String typeToLayoutName(Primitive.Kind type) {\n+        return switch (type) {\n+            case Bool -> \"C_BOOL\";\n+            case Char -> \"C_CHAR\";\n+            case Short -> \"C_SHORT\";\n+            case Int -> \"C_INT\";\n+            case Long -> \"C_LONG\";\n+            case LongLong -> \"C_LONG_LONG\";\n+            case Float -> \"C_FLOAT\";\n+            case Double -> \"C_DOUBLE\";\n+            default -> throw new RuntimeException(\"should not reach here: \" + type);\n+        };\n+    }\n+\n+    static Class<?> layoutToClass(boolean fp, MemoryLayout layout) {\n+        switch ((int)layout.bitSize()) {\n+            case 8: return byte.class;\n+            case 16: return short.class;\n+            case 32: return !fp ? int.class : float.class;\n+            case 64:\n+            case 128: return !fp ? long.class : double.class;\n+            default:\n+                throw new UnsupportedOperationException(\"size: \" + (int)layout.bitSize());\n+        }\n+    }\n+\n+    @Override\n+    public Class<?> visitDelegated(Type.Delegated t, Void aVoid) {\n+        return t.kind() == Type.Delegated.Kind.POINTER ?\n+                MemoryAddress.class :\n+                t.type().accept(this, null);\n+    }\n+\n+    @Override\n+    public Class<?> visitFunction(Type.Function t, Void aVoid) {\n+        return MemoryAddress.class; \/\/ function pointer\n+    }\n+\n+    @Override\n+    public Class<?> visitDeclared(Type.Declared t, Void aVoid) {\n+        switch (t.tree().kind()) {\n+            case UNION:\n+            case STRUCT:\n+                return MemorySegment.class;\n+            case ENUM:\n+                return layoutToClass(false, t.tree().layout().orElseThrow(UnsupportedOperationException::new));\n+            default:\n+                throw new UnsupportedOperationException(\"declaration kind: \" + t.tree().kind());\n+        }\n+    }\n+\n+    @Override\n+    public Class<?> visitArray(Type.Array t, Void aVoid) {\n+        if (t.kind() == Type.Array.Kind.VECTOR) {\n+            throw new UnsupportedOperationException(\"vector\");\n+        } else {\n+            return MemorySegment.class;\n+        }\n+    }\n+\n+    @Override\n+    public Class<?> visitType(Type t, Void aVoid) {\n+        throw new UnsupportedOperationException(t.getClass().toString());\n+    }\n+\n+    Class<?> getJavaType(Type t) {\n+        return t.accept(this, null);\n+    }\n+\n+    MethodType getMethodType(Type.Function type) {\n+        return getMethodType(type, true);\n+    }\n+\n+    MethodType getMethodType(Type.Function type, boolean varargsCheck) {\n+        MethodType mtype = MethodType.methodType(getJavaType(type.returnType()));\n+        for (Type arg : type.argumentTypes()) {\n+            mtype = mtype.appendParameterTypes(getJavaType(arg));\n+        }\n+        if (varargsCheck && type.varargs()) {\n+            mtype = mtype.appendParameterTypes(Object[].class);\n+        }\n+        return mtype;\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/TypeTranslator.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+public class TypedefBuilder extends NestedClassBuilder {\n+\n+    private static String MEMBER_MODS = \"public static \";\n+\n+    private final String superClass;\n+\n+    public TypedefBuilder(JavaSourceBuilder prev, String className, String superClass) {\n+        super(prev, Kind.CLASS, className);\n+        this.superClass = superClass;\n+    }\n+\n+    @Override\n+    String superClass() {\n+        return superClass;\n+    }\n+\n+    @Override\n+    JavaSourceBuilder classEnd() {\n+        if (superClass == null) {\n+            emitAllocatePointerMethods();\n+        }\n+        return super.classEnd();\n+    }\n+\n+    void emitAllocatePointerMethods() {\n+        \/\/ allocatePointer\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS);\n+        append(\" MemorySegment allocatePointer() {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return MemorySegment.allocateNative(C_POINTER);\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+\n+        \/\/ allocatePointer (scope version)\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS);\n+        append(\" MemorySegment allocatePointer(NativeScope scope) {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return scope.allocate(C_POINTER);\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/TypedefBuilder.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.jextract.Declaration;\n+import jdk.internal.clang.Cursor;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+\/**\n+ * This visitor handles certain typedef declarations.\n+ *\n+ * 1. Remove redundant typedefs.\n+ * 2. Rename typedef'ed anonymous type definitions like\n+ *        typedef struct { int x; int y; } Point;\n+ *\/\n+final class TypedefHandler implements Declaration.Visitor<Void, Void> {\n+\n+    TreeMaker maker;\n+\n+    public TypedefHandler(TreeMaker maker) {\n+        this.maker = maker;\n+    }\n+\n+    \/\/ Potential Tree instances that will go into transformed HeaderTree\n+    \/\/ are collected in this list.\n+    private List<Declaration> decls = new ArrayList<>();\n+\n+    \/\/ Tree instances that are to be replaced from \"decls\" list are\n+    \/\/ saved in the following Map. One or more Trees can replace a Tree.\n+    private final Map<Cursor, List<Declaration>> replacements = new HashMap<>();\n+\n+    public Declaration.Scoped transform(Declaration.Scoped ht) {\n+        \/\/ Process all header declarations are collect potential\n+        \/\/ declarations that will go into transformed HeaderTree\n+        \/\/ into the this.decls field.\n+        ht.accept(this, null);\n+\n+\/\/        \/\/ Replace trees from this.decls with Trees found in this.replacements.\n+\/\/        \/\/ We need this two step process so that named StructTree instances\n+\/\/        \/\/ will replace with original unnamed StructTree instances.\n+\/\/        List<Declaration> newDecls = decls.stream().flatMap(tx -> {\n+\/\/            if (replacements.containsKey(tx.cursor())) {\n+\/\/                return replacements.get(tx.cursor()).stream();\n+\/\/            } else {\n+\/\/                return Stream.of(tx);\n+\/\/            }\n+\/\/        }).collect(Collectors.toList());\n+\/\/\n+\/\/        return treeMaker.createHeader(ht.cursor(), ht.path(), newDecls);\n+        return ht;\n+    }\n+\n+    @Override\n+    public Void visitDeclaration(Declaration d, Void aVoid) {\n+        decls.add(d);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitScoped(Declaration.Scoped ht, Void v) {\n+        ht.members().forEach(decl -> decl.accept(this, null));\n+        return null;\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/TypedefHandler.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.ValueLayout;\n+import jdk.internal.clang.Cursor;\n+import jdk.internal.clang.Type;\n+import jdk.internal.clang.TypeKind;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * MemoryLayout computer for C unions.\n+ *\/\n+final class UnionLayoutComputer extends RecordLayoutComputer {\n+    private final long offset;\n+    private long actualSize = 0L;\n+\n+    UnionLayoutComputer(long offsetInParent, Type parent, Type type) {\n+        super(parent, type);\n+        this.offset = offsetInParent;\n+    }\n+\n+    @Override\n+    void processField(Cursor c) {\n+        long expectedOffset = offsetOf(parent, c);\n+        if (expectedOffset > offset) {\n+            throw new IllegalStateException(\"No padding in union elements!\");\n+        }\n+\n+        addFieldLayout(offset, parent, c);\n+        actualSize = Math.max(actualSize, fieldSize(c));\n+    }\n+\n+    @Override\n+    void startBitfield() {\n+        \/\/ do nothing\n+    }\n+\n+    @Override\n+    MemoryLayout fieldLayout(Cursor c) {\n+        if (c.isBitField()) {\n+            return bitfield(List.of(super.fieldLayout(c)));\n+        } else {\n+            return super.fieldLayout(c);\n+        }\n+    }\n+\n+    @Override\n+    long fieldSize(Cursor c) {\n+        if (c.type().kind() == TypeKind.IncompleteArray) {\n+            return 0;\n+        } else if (c.isBitField()) {\n+            return c.getBitFieldWidth();\n+        } else {\n+            return c.type().size() * 8;\n+        }\n+    }\n+\n+    @Override\n+    MemoryLayout finishLayout() {\n+        \/\/ size mismatch indicates use of bitfields in union\n+        long expectedSize = type.size() * 8;\n+        if (actualSize < expectedSize) {\n+            \/\/ emit an extra padding of expected size to make sure union layout size is computed correctly\n+            addFieldLayout(MemoryLayout.ofPaddingBits(expectedSize));\n+        } else if (actualSize > expectedSize) {\n+            throw new AssertionError(\"Invalid union size - expected: \" + expectedSize + \"; found: \" + actualSize);\n+        }\n+\n+        MemoryLayout[] fields = fieldLayouts.toArray(new MemoryLayout[0]);\n+        GroupLayout g = MemoryLayout.ofUnion(fields);\n+        String name = LayoutUtils.getName(cursor);\n+        return name.isEmpty() ?\n+                g : g.withName(name);\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/UnionLayoutComputer.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.ValueLayout;\n+import java.nio.ByteOrder;\n+\n+\/*\n+ * Layouts for the primitive types not supported by ABI implementations.\n+ *\/\n+public final class UnsupportedLayouts {\n+    private UnsupportedLayouts() {}\n+\n+    private static final String ATTR_LAYOUT_KIND = \"jextract.abi.unsupported.layout.kind\";\n+\n+    public static final ValueLayout __INT128 = MemoryLayout.ofValueBits(128, ByteOrder.nativeOrder()).\n+            withAttribute(ATTR_LAYOUT_KIND, \"__int128\");\n+\n+    public static final ValueLayout LONG_DOUBLE = MemoryLayout.ofValueBits(128, ByteOrder.nativeOrder()).\n+            withAttribute(ATTR_LAYOUT_KIND, \"long double\");\n+\n+    public static final ValueLayout _FLOAT128 = MemoryLayout.ofValueBits(128, ByteOrder.nativeOrder()).\n+            withAttribute(ATTR_LAYOUT_KIND, \"_float128\");\n+\n+    public static final ValueLayout __FP16 = MemoryLayout.ofValueBits(16, ByteOrder.nativeOrder()).\n+            withAttribute(ATTR_LAYOUT_KIND, \"__fp16\");\n+\n+    public static final ValueLayout CHAR16 = MemoryLayout.ofValueBits(16, ByteOrder.nativeOrder()).\n+            withAttribute(ATTR_LAYOUT_KIND, \"char16\");\n+\n+    public static final ValueLayout WCHAR_T = MemoryLayout.ofValueBits(16, ByteOrder.nativeOrder()).\n+            withAttribute(ATTR_LAYOUT_KIND, \"wchar_t\");\n+\n+    static boolean isUnsupported(MemoryLayout vl) {\n+        return vl.attribute(ATTR_LAYOUT_KIND).isPresent();\n+    }\n+\n+    static String getUnsupportedTypeName(MemoryLayout vl) {\n+        return (String)\n+                vl.attribute(ATTR_LAYOUT_KIND).orElseThrow(IllegalArgumentException::new);\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/UnsupportedLayouts.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,332 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+import jdk.internal.clang.Cursor;\n+import jdk.internal.clang.CursorKind;\n+import jdk.internal.clang.SourceLocation;\n+import jdk.internal.clang.Type;\n+\n+import javax.lang.model.SourceVersion;\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * General utility functions\n+ *\/\n+class Utils {\n+    public static String qualifiedClassName(String packageName, String simpleName) {\n+        return (packageName.isEmpty() ? \"\" : packageName + \".\") + simpleName;\n+    }\n+\n+    private static URI fileName(String pkgName, String clsName, String extension) {\n+        String pkgPrefix = pkgName.isEmpty() ? \"\" : pkgName.replaceAll(\"\\\\.\", \"\/\") + \"\/\";\n+        return URI.create(pkgPrefix + clsName + extension);\n+    }\n+\n+    static JavaFileObject fileFromString(String pkgName, String clsName, String contents) {\n+        return new SimpleJavaFileObject(fileName(pkgName, clsName, \".java\"), JavaFileObject.Kind.SOURCE) {\n+            @Override\n+            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n+                return contents;\n+            }\n+        };\n+    }\n+\n+    static String javaSafeIdentifier(String name) {\n+        return javaSafeIdentifier(name, false);\n+    }\n+\n+    static String javaSafeIdentifier(String name, boolean checkAllChars) {\n+        if (checkAllChars) {\n+            StringBuilder buf = new StringBuilder();\n+            char[] chars = name.toCharArray();\n+            if (Character.isJavaIdentifierStart(chars[0])) {\n+                buf.append(chars[0]);\n+            } else {\n+                buf.append('_');\n+            }\n+            if (chars.length > 1) {\n+                for (int i = 1; i < chars.length; i++) {\n+                    char ch = chars[i];\n+                    if (Character.isJavaIdentifierPart(ch)) {\n+                        buf.append(ch);\n+                    } else {\n+                        buf.append('_');\n+                    }\n+                }\n+            }\n+            return buf.toString();\n+        } else {\n+            \/\/ We never get the problem of Java non-identifiers (like 123, ab-xy) as\n+            \/\/ C identifiers. But we may have a java keyword used as a C identifier.\n+            assert SourceVersion.isIdentifier(name);\n+\n+            return SourceVersion.isKeyword(name) || isRestrictedTypeName(name) || isJavaTypeName(name)? (name + \"_\") : name;\n+        }\n+    }\n+\n+    private static boolean isRestrictedTypeName(String name) {\n+        return switch (name) {\n+            case \"var\", \"yield\", \"record\",\n+                \"sealed\", \"permits\" -> true;\n+            default -> false;\n+        };\n+    }\n+\n+    private static boolean isJavaTypeName(String name) {\n+        \/\/ Java types that are used unqualified in the generated code\n+        return switch (name) {\n+            case \"String\", \"MethodHandle\",\n+                \"VarHandle\", \"ByteOrder\",\n+                \"FunctionDescriptor\", \"LibraryLookup\",\n+                \"MemoryAddress\", \"MemoryLayout\",\n+                \"MemorySegment\", \"ValueLayout\",\n+                \"RuntimeHelper\" -> true;\n+            default -> false;\n+        };\n+    }\n+\n+    static void validSimpleIdentifier(String name) {\n+        int length = name.length();\n+        if (length == 0) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        int ch = name.codePointAt(0);\n+        if (length == 1 && ch == '_') {\n+            throw new IllegalArgumentException(\"'_' is no longer valid identifier.\");\n+        }\n+\n+        if (!Character.isJavaIdentifierStart(ch)) {\n+            throw new IllegalArgumentException(\"Invalid start character for an identifier: \" + ch);\n+        }\n+\n+        for (int i = 1; i < length; i++) {\n+            ch = name.codePointAt(i);\n+            if (!Character.isJavaIdentifierPart(ch)) {\n+                throw new IllegalArgumentException(\"Invalid character for an identifier: \" + ch);\n+            }\n+        }\n+    }\n+\n+    static void validPackageName(String name) {\n+        if (name.isEmpty()) {\n+            throw new IllegalArgumentException();\n+        }\n+        int idx = name.lastIndexOf('.');\n+        if (idx == -1) {\n+           validSimpleIdentifier(name);\n+        } else {\n+            validSimpleIdentifier(name.substring(idx + 1));\n+            validPackageName(name.substring(0, idx));\n+        }\n+    }\n+\n+    static String toJavaIdentifier(String str) {\n+        final int size = str.length();\n+        StringBuilder sb = new StringBuilder(size);\n+        if (! Character.isJavaIdentifierStart(str.charAt(0))) {\n+            sb.append('_');\n+        }\n+        for (int i = 0; i < size; i++) {\n+            char ch = str.charAt(i);\n+            if (Character.isJavaIdentifierPart(ch)) {\n+                sb.append(ch);\n+            } else {\n+                sb.append('_');\n+            }\n+        }\n+        return sb.toString();\n+    }\n+\n+    static String toSafeName(String name) {\n+        StringBuilder sb = new StringBuilder(name.length());\n+        name = toJavaIdentifier(name);\n+        sb.append(name);\n+        if (SourceVersion.isKeyword(name)) {\n+            sb.append(\"$\");\n+        }\n+        return sb.toString();\n+    }\n+\n+    static String toClassName(String cname) {\n+        return toSafeName(cname);\n+    }\n+\n+    static String toMacroName(String mname) {\n+        return toSafeName(mname);\n+    }\n+\n+    static String toInternalName(String pkg, String name, String... nested) {\n+        if ((pkg == null || pkg.isEmpty()) && nested == null) {\n+            return name;\n+        }\n+\n+        StringBuilder sb = new StringBuilder();\n+        if (pkg != null && ! pkg.isEmpty()) {\n+            sb.append(pkg.replace('.', '\/'));\n+            if (sb.charAt(sb.length() - 1) != '\/') {\n+                sb.append('\/');\n+            }\n+        }\n+        sb.append(name);\n+        for (String n: nested) {\n+            sb.append('$');\n+            sb.append(n);\n+        }\n+        return sb.toString();\n+    }\n+\n+    static String getName(Type type) {\n+        return LayoutUtils.getName(type);\n+    }\n+\n+    static Stream<Cursor> flattenableChildren(Cursor c) {\n+        return c.children()\n+                .filter(cx -> cx.isAnonymousStruct() || cx.kind() == CursorKind.FieldDecl);\n+    }\n+\n+    \/\/ return builtin Record types accessible from the given Type\n+    static Stream<Cursor> getBuiltinRecordTypes(Type type) {\n+        List<Cursor> recordTypes = new ArrayList<>();\n+        fillBuiltinRecordTypes(type, recordTypes);\n+        return recordTypes.stream().distinct();\n+    }\n+\n+    private static void fillBuiltinRecordTypes(Type type, List<Cursor> recordTypes) {\n+        Type canonicalType = type.canonicalType();\n+        switch (canonicalType.kind()) {\n+            case ConstantArray:\n+            case IncompleteArray:\n+                fillBuiltinRecordTypes(canonicalType.getElementType(), recordTypes);\n+                break;\n+\n+            case FunctionProto:\n+            case FunctionNoProto: {\n+                final int numArgs = canonicalType.numberOfArgs();\n+                for (int i = 0; i < numArgs; i++) {\n+                    fillBuiltinRecordTypes(canonicalType.argType(i), recordTypes);\n+                }\n+                fillBuiltinRecordTypes(canonicalType.resultType(), recordTypes);\n+            }\n+            break;\n+\n+            case Record: {\n+                Cursor c = canonicalType.getDeclarationCursor();\n+                if (c.isDefinition()) {\n+                    SourceLocation sloc = c.getSourceLocation();\n+                    if (sloc != null && sloc.getFileLocation().path() == null) {\n+                        recordTypes.add(c);\n+                    }\n+                }\n+            }\n+            break;\n+\n+            case BlockPointer:\n+            case Pointer:\n+                fillBuiltinRecordTypes(canonicalType.getPointeeType(), recordTypes);\n+                break;\n+\n+            case Unexposed:\n+                if (! canonicalType.equalType(type)) {\n+                    fillBuiltinRecordTypes(canonicalType, recordTypes);\n+                }\n+                break;\n+\n+            case Elaborated:\n+            case Typedef:\n+                fillBuiltinRecordTypes(canonicalType, recordTypes);\n+                break;\n+\n+            default: \/\/ nothing to do\n+        }\n+    }\n+\n+    \/\/ return the absolute path of the library of given name by searching\n+    \/\/ in the given array of paths.\n+    static Optional<Path> findLibraryPath(Path[] paths, String libName) {\n+        return Arrays.stream(paths).\n+                map(p -> p.resolve(System.mapLibraryName(libName))).\n+                filter(Files::isRegularFile).map(Path::toAbsolutePath).findFirst();\n+    }\n+\n+    \/*\n+     * FIXME: when we add jdk.compiler dependency from jdk.jextract module, revisit\n+     * the following. The following methods 'quote', 'quote' and 'isPrintableAscii'\n+     * are from javac source. See also com.sun.tools.javac.util.Convert.java.\n+     *\/\n+\n+    \/**\n+     * Escapes each character in a string that has an escape sequence or\n+     * is non-printable ASCII.  Leaves non-ASCII characters alone.\n+     *\/\n+    static String quote(String s) {\n+        StringBuilder buf = new StringBuilder();\n+        for (int i = 0; i < s.length(); i++) {\n+            buf.append(quote(s.charAt(i)));\n+        }\n+        return buf.toString();\n+    }\n+\n+    \/**\n+     * Escapes a character if it has an escape sequence or is\n+     * non-printable ASCII.  Leaves non-ASCII characters alone.\n+     *\/\n+    static String quote(char ch) {\n+        switch (ch) {\n+        case '\\b':  return \"\\\\b\";\n+        case '\\f':  return \"\\\\f\";\n+        case '\\n':  return \"\\\\n\";\n+        case '\\r':  return \"\\\\r\";\n+        case '\\t':  return \"\\\\t\";\n+        case '\\'':  return \"\\\\'\";\n+        case '\\\"':  return \"\\\\\\\"\";\n+        case '\\\\':  return \"\\\\\\\\\";\n+        default:\n+            return (isPrintableAscii(ch))\n+                ? String.valueOf(ch)\n+                : String.format(\"\\\\u%04x\", (int) ch);\n+        }\n+    }\n+\n+    \/**\n+     * Is a character printable ASCII?\n+     *\/\n+    private static boolean isPrintableAscii(char ch) {\n+        return ch >= ' ' && ch <= '~';\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/Utils.java","additions":332,"deletions":0,"binary":false,"changes":332,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+import javax.tools.JavaFileObject;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public final class Writer {\n+    private final List<? extends JavaFileObject> files;\n+    private final Path dest;\n+\n+    public Writer(Path dest, List<? extends JavaFileObject> files) {\n+        this.files = files;\n+        this.dest = dest;\n+    }\n+\n+    private List<JavaFileObject> ensureSourcesCompiled() {\n+        List<JavaFileObject> sources = sources();\n+        if (sources.isEmpty()) {\n+            return List.of();\n+        } else {\n+            return InMemoryJavaCompiler.compile(sources,\n+                \"--add-modules\", \"jdk.incubator.foreign\",\n+                \"--release\", \"17\",\n+                \"-d\", dest.toAbsolutePath().toString(),\n+                \"-cp\", dest.toAbsolutePath().toString());\n+        }\n+    }\n+\n+    public void writeAll(boolean compileSources) throws IOException {\n+        writeClassFiles(resources());\n+        writeClassFiles(classes());\n+        if (compileSources) {\n+            writeClassFiles(ensureSourcesCompiled());\n+        } else {\n+            writeSourceFiles();\n+        }\n+    }\n+\n+    void writeClassFiles(List<JavaFileObject> files) throws IOException {\n+        Path destDir = createOutputDir();\n+        for (var entry : files) {\n+            String path = entry.getName();\n+            Path fullPath = destDir.resolve(path).normalize();\n+            Files.createDirectories(fullPath.getParent());\n+            try (InputStream is = entry.openInputStream()) {\n+                Files.write(fullPath, is.readAllBytes());\n+            }\n+        }\n+    }\n+\n+    void writeSourceFiles() throws IOException {\n+        Path destDir = createOutputDir();\n+        for (var entry : sources()) {\n+            String srcPath = entry.getName();\n+            Path fullPath = destDir.resolve(srcPath).normalize();\n+            Path dir = fullPath.getParent();\n+            \/\/ In case the folder exist and is a link to a folder, this should be OK\n+            \/\/ Case in point, \/tmp on MacOS link to \/private\/tmp\n+            if (Files.exists(dir)) {\n+                if (!Files.isDirectory(dir)) {\n+                    throw new FileAlreadyExistsException(dir.toAbsolutePath().toString());\n+                }\n+            } else {\n+                Files.createDirectories(fullPath.getParent());\n+            }\n+            Files.write(fullPath, List.of(entry.getCharContent(false)));\n+        }\n+    }\n+\n+    private List<JavaFileObject> sources() {\n+        return files.stream()\n+                .filter(jfo -> jfo.getKind() == JavaFileObject.Kind.SOURCE)\n+                .collect(Collectors.toList());\n+    }\n+\n+    private List<JavaFileObject> classes() {\n+        return files.stream()\n+                .filter(jfo -> jfo.getKind() == JavaFileObject.Kind.CLASS)\n+                .collect(Collectors.toList());\n+    }\n+\n+    private List<JavaFileObject> resources() {\n+        return files.stream()\n+                .filter(jfo -> (jfo.getKind() == JavaFileObject.Kind.HTML || jfo.getKind() == JavaFileObject.Kind.OTHER))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private Path createOutputDir() throws IOException {\n+        Path absDest = dest.toAbsolutePath();\n+        if (!Files.exists(absDest)) {\n+            Files.createDirectories(absDest);\n+        }\n+        if (!Files.isDirectory(absDest)) {\n+            throw new IOException(\"Not a directory: \" + dest);\n+        }\n+        return absDest;\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/Writer.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+#\n+#  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+#  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+# \n+#  This code is free software; you can redistribute it and\/or modify it\n+#  under the terms of the GNU General Public License version 2 only, as\n+#  published by the Free Software Foundation.\n+# \n+#  This code is distributed in the hope that it will be useful, but WITHOUT\n+#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+#  version 2 for more details (a copy is included in the LICENSE file that\n+#  accompanied this code).\n+# \n+#  You should have received a copy of the GNU General Public License version\n+#  2 along with this work; if not, write to the Free Software Foundation,\n+#  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+# \n+#  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+#  or visit www.oracle.com if you need additional information or have any\n+#  questions.\n+#\n+\n+# error message\n+cannot.read.header.file=cannot read header file: {0}\n+not.a.file=not a file: {0}\n+l.option.value.invalid=option value for -l option should be a name or an absolute path\n+\n+# help messages for options\n+help.C=pass through argument for clang\n+help.I=specify include files path\n+help.d=specify where to place generated files\n+help.filter=header files to filter\n+help.h=print help\n+help.l=specify a library\n+help.source=generate java sources\n+help.t=target package for specified header files\n+help.non.option=header file\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/resources\/Messages.properties","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,230 @@\n+\/\/ Generated by jextract\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.LibraryLookup;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import static jdk.incubator.foreign.CLinker.*;\n+\n+final class RuntimeHelper {\n+    private RuntimeHelper() {}\n+    private final static CLinker LINKER = CLinker.getInstance();\n+    private final static ClassLoader LOADER = RuntimeHelper.class.getClassLoader();\n+    private final static MethodHandles.Lookup MH_LOOKUP = MethodHandles.lookup();\n+\n+    static <T> T requireNonNull(T obj, String symbolName) {\n+        if (obj == null) {\n+            throw new UnsatisfiedLinkError(\"unresolved symbol: \" + symbolName);\n+        }\n+        return obj;\n+    }\n+\n+    static final LibraryLookup[] libraries(String... libNames) {\n+        if (libNames.length == 0) {\n+            return new LibraryLookup[] { LibraryLookup.ofDefault() };\n+        } else {\n+            return Arrays.stream(libNames)\n+                 .map(libName -> {\n+                      if (libName.indexOf(File.separatorChar) != -1) {\n+                          return LibraryLookup.ofPath(Path.of(libName));\n+                      } else {\n+                          return LibraryLookup.ofLibrary(libName);\n+                      }\n+                 })\n+                .toArray(LibraryLookup[]::new);\n+        }\n+    }\n+\n+    static final MemorySegment lookupGlobalVariable(LibraryLookup[] LIBRARIES, String name, MemoryLayout layout) {\n+        return lookup(LIBRARIES, name).map(s ->\n+            nonCloseableNonTransferableSegment(s.address().asSegmentRestricted(layout.byteSize())\n+                    .share())).orElse(null);\n+    }\n+\n+    static final MethodHandle downcallHandle(LibraryLookup[] LIBRARIES, String name, String desc, FunctionDescriptor fdesc, boolean variadic) {\n+        return lookup(LIBRARIES, name).map(\n+                addr -> {\n+                    MethodType mt = MethodType.fromMethodDescriptorString(desc, LOADER);\n+                    return variadic ?\n+                        VarargsInvoker.make(addr, mt, fdesc) :\n+                        LINKER.downcallHandle(addr, mt, fdesc);\n+                }).orElse(null);\n+    }\n+\n+    static final MethodHandle downcallHandle(String desc, FunctionDescriptor fdesc, boolean variadic) {\n+        if (variadic) {\n+            throw new AssertionError(\"Cannot get here!\");\n+        }\n+        MethodType mt = MethodType.fromMethodDescriptorString(desc, LOADER);\n+        return LINKER.downcallHandle(mt, fdesc);\n+    }\n+\n+    static final <Z> MemorySegment upcallStub(Class<Z> fi, Z z, FunctionDescriptor fdesc, String mtypeDesc) {\n+        try {\n+            MethodHandle handle = MH_LOOKUP.findVirtual(fi, \"apply\",\n+                    MethodType.fromMethodDescriptorString(mtypeDesc, LOADER));\n+            handle = handle.bindTo(z);\n+            return LINKER.upcallStub(handle, fdesc);\n+        } catch (Throwable ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+\n+    static final MemorySegment nonCloseableNonTransferableSegment(MemorySegment seg) {\n+        return seg.withAccessModes(seg.accessModes() &  ~MemorySegment.CLOSE & ~MemorySegment.HANDOFF);\n+    }\n+\n+    static MemorySegment asArrayRestricted(MemoryAddress addr, MemoryLayout layout, int numElements) {\n+        return nonCloseableSegment(addr.asSegmentRestricted(numElements * layout.byteSize()));\n+    }\n+\n+    \/\/ Internals only below this point\n+    private static final MemorySegment nonCloseableSegment(MemorySegment seg) {\n+        return seg.withAccessModes(seg.accessModes() &  ~MemorySegment.CLOSE);\n+    }\n+\n+    private static final Optional<LibraryLookup.Symbol> lookup(LibraryLookup[] LIBRARIES, String sym) {\n+        return Stream.of(LIBRARIES)\n+                .flatMap(l -> l.lookup(sym).stream())\n+                .findFirst();\n+    }\n+\n+    private static class VarargsInvoker {\n+        private static final MethodHandle INVOKE_MH;\n+        private final Addressable symbol;\n+        private final MethodType varargs;\n+        private final FunctionDescriptor function;\n+\n+        private VarargsInvoker(Addressable symbol, MethodType type, FunctionDescriptor function) {\n+            this.symbol = symbol;\n+            this.varargs = type;\n+            this.function = function;\n+        }\n+\n+        static {\n+            try {\n+                INVOKE_MH = MethodHandles.lookup().findVirtual(VarargsInvoker.class, \"invoke\", MethodType.methodType(Object.class, Object[].class));\n+            } catch (ReflectiveOperationException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        static MethodHandle make(Addressable symbol, MethodType type, FunctionDescriptor function) {\n+            VarargsInvoker invoker = new VarargsInvoker(symbol, type, function);\n+            return INVOKE_MH.bindTo(invoker).asCollector(Object[].class, type.parameterCount())\n+                    .asType(type);\n+        }\n+\n+        private Object invoke(Object[] args) throws Throwable {\n+            \/\/ one trailing Object[]\n+            int nNamedArgs = function.argumentLayouts().size();\n+            assert(args.length == nNamedArgs + 1);\n+            \/\/ The last argument is the array of vararg collector\n+            Object[] unnamedArgs = (Object[]) args[args.length - 1];\n+\n+            int argsCount = nNamedArgs + unnamedArgs.length;\n+            Class<?>[] argTypes = new Class<?>[argsCount];\n+            MemoryLayout[] argLayouts = new MemoryLayout[nNamedArgs + unnamedArgs.length];\n+\n+            int pos = 0;\n+            for (pos = 0; pos < nNamedArgs; pos++) {\n+                argTypes[pos] = varargs.parameterType(pos);\n+                argLayouts[pos] = function.argumentLayouts().get(pos);\n+            }\n+\n+            assert pos == nNamedArgs;\n+            for (Object o: unnamedArgs) {\n+                argTypes[pos] = normalize(o.getClass());\n+                argLayouts[pos] = variadicLayout(argTypes[pos]);\n+                pos++;\n+            }\n+            assert pos == argsCount;\n+\n+            MethodType mt = MethodType.methodType(varargs.returnType(), argTypes);\n+            FunctionDescriptor f = (function.returnLayout().isEmpty()) ?\n+                    FunctionDescriptor.ofVoid(argLayouts) :\n+                    FunctionDescriptor.of(function.returnLayout().get(), argLayouts);\n+            MethodHandle mh = LINKER.downcallHandle(symbol, mt, f);\n+            \/\/ flatten argument list so that it can be passed to an asSpreader MH\n+            Object[] allArgs = new Object[nNamedArgs + unnamedArgs.length];\n+            System.arraycopy(args, 0, allArgs, 0, nNamedArgs);\n+            System.arraycopy(unnamedArgs, 0, allArgs, nNamedArgs, unnamedArgs.length);\n+\n+            return mh.asSpreader(Object[].class, argsCount).invoke(allArgs);\n+        }\n+\n+        private static Class<?> unboxIfNeeded(Class<?> clazz) {\n+            if (clazz == Boolean.class) {\n+                return boolean.class;\n+            } else if (clazz == Void.class) {\n+                return void.class;\n+            } else if (clazz == Byte.class) {\n+                return byte.class;\n+            } else if (clazz == Character.class) {\n+                return char.class;\n+            } else if (clazz == Short.class) {\n+                return short.class;\n+            } else if (clazz == Integer.class) {\n+                return int.class;\n+            } else if (clazz == Long.class) {\n+                return long.class;\n+            } else if (clazz == Float.class) {\n+                return float.class;\n+            } else if (clazz == Double.class) {\n+                return double.class;\n+            } else {\n+                return clazz;\n+            }\n+        }\n+\n+        private Class<?> promote(Class<?> c) {\n+            if (c == byte.class || c == char.class || c == short.class || c == int.class) {\n+                return long.class;\n+            } else if (c == float.class) {\n+                return double.class;\n+            } else {\n+                return c;\n+            }\n+        }\n+\n+        private Class<?> normalize(Class<?> c) {\n+            c = unboxIfNeeded(c);\n+            if (c.isPrimitive()) {\n+                return promote(c);\n+            }\n+            if (MemoryAddress.class.isAssignableFrom(c)) {\n+                return MemoryAddress.class;\n+            }\n+            if (MemorySegment.class.isAssignableFrom(c)) {\n+                return MemorySegment.class;\n+            }\n+            throw new IllegalArgumentException(\"Invalid type for ABI: \" + c.getTypeName());\n+        }\n+\n+        private MemoryLayout variadicLayout(Class<?> c) {\n+            if (c == long.class) {\n+                return C_LONG_LONG;\n+            } else if (c == double.class) {\n+                return C_DOUBLE;\n+            } else if (MemoryAddress.class.isAssignableFrom(c)) {\n+                return C_POINTER;\n+            } else {\n+                throw new IllegalArgumentException(\"Unhandled variadic argument class: \" + c);\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/resources\/RuntimeHelper.java.template","additions":230,"deletions":0,"binary":false,"changes":230,"status":"added"},{"patch":"@@ -0,0 +1,11 @@\n+import jdk.incubator.jextract.JextractTool;\n+\n+module jdk.incubator.jextract {\n+    requires transitive java.compiler;\n+    requires transitive jdk.incubator.foreign;\n+    requires jdk.internal.opt;\n+    exports jdk.incubator.jextract;\n+\n+    provides java.util.spi.ToolProvider with\n+        JextractTool.JextractToolProvider;\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/module-info.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"},{"patch":"@@ -32,1 +32,7 @@\n-    exports jdk.internal.joptsimple to jdk.jlink, jdk.jshell;\n+    exports jdk.internal.joptsimple to\n+        jdk.incubator.jextract,\n+        jdk.jlink,\n+        jdk.jshell;\n+\n+    exports jdk.internal.joptsimple.util to\n+        jdk.incubator.jextract;\n","filename":"src\/jdk.internal.opt\/share\/classes\/module-info.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+    :jdk_jextract \\\n@@ -346,0 +347,4 @@\n+jdk_jextract = \\\n+    java\/jextract \\\n+    tools\/jextract\n+\n","filename":"test\/jdk\/TEST.groups","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,267 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.JextractTool;\n+import jdk.incubator.jextract.Type;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+\n+public class JextractApiTestBase {\n+    static final boolean isMacOSX =\n+            System.getProperty(\"os.name\", \"unknown\").contains(\"OS X\");\n+    static final boolean isWindows =\n+            System.getProperty(\"os.name\", \"unknown\").startsWith(\"Windows\");\n+\n+    public static  Declaration.Scoped parse(String headerFilename, String... parseOptions) {\n+        Path header = Paths.get(System.getProperty(\"test.src\", \".\"), headerFilename);\n+        return JextractTool.parse(List.of(header), parseOptions);\n+    }\n+\n+    public static void checkNames(List<Declaration> members, String... fields) {\n+        assertEquals(members.size(), fields.length);\n+        for (int i = 0; i < fields.length; i++) {\n+            assertEquals(members.get(i).name(), fields[i]);\n+        }\n+    }\n+\n+    public static Declaration.Scoped checkScoped(Declaration.Scoped toplevel, String name, Declaration.Scoped.Kind kind,  String... fields) {\n+        Declaration.Scoped scoped = findDecl(toplevel, name, Declaration.Scoped.class);\n+        assertTrue(scoped.kind() == kind);\n+        checkNames(scoped.members(), fields);\n+        return scoped;\n+    }\n+\n+    private static List<Declaration> getNamedFields(Declaration.Scoped scoped) {\n+        List<Declaration> fields = new ArrayList<>();\n+        scoped.members().forEach(d -> {\n+            if (d instanceof Declaration.Variable) {\n+                Declaration.Variable v = (Declaration.Variable) d;\n+                if (v.kind() == Declaration.Variable.Kind.FIELD) {\n+                    assert (!v.name().isEmpty());\n+                    fields.add(v);\n+                }\n+            } else if (d instanceof Declaration.Scoped) {\n+                Declaration.Scoped record = (Declaration.Scoped) d;\n+                if (record.name().isEmpty()) {\n+                    fields.addAll(getNamedFields(record));\n+                } else {\n+                    fields.add(record);\n+                }\n+            }\n+        });\n+        return fields;\n+    }\n+\n+    public static Declaration.Scoped checkRecord(Declaration.Scoped scoped, String name, Declaration.Scoped.Kind kind,  String... fields) {\n+        assertTrue(scoped.kind() == kind);\n+        checkNames(getNamedFields(scoped), fields);\n+        return scoped;\n+    }\n+\n+    public static Declaration.Scoped checkStruct(Declaration.Scoped toplevel, String name, String... fields) {\n+        return checkScoped(toplevel, name, Declaration.Scoped.Kind.STRUCT, fields);\n+    }\n+\n+    public static Declaration.Scoped checkBitfields(Declaration.Scoped toplevel, String name, String... fields) {\n+        return checkScoped(toplevel, name, Declaration.Scoped.Kind.BITFIELDS, fields);\n+    }\n+\n+    public static Declaration.Scoped checkUnion(Declaration.Scoped toplevel, String name, String... fields) {\n+        return checkScoped(toplevel, name, Declaration.Scoped.Kind.UNION, fields);\n+    }\n+\n+    public static Declaration.Variable checkVariable(Declaration.Scoped scope, String name, Type type) {\n+        Declaration.Variable var = findDecl(scope, name, Declaration.Variable.class);\n+        assertTypeEquals(type, var.type());\n+        return var;\n+    }\n+\n+    public static Declaration.Variable checkGlobal(Declaration.Scoped toplevel, String name, Type type) {\n+        Declaration.Variable global = checkVariable(toplevel, name, type);\n+        assertEquals(global.kind(), Declaration.Variable.Kind.GLOBAL);\n+        return global;\n+    }\n+\n+    public static Declaration.Variable checkField(Declaration.Scoped record, String name, Type type) {\n+        Declaration.Variable global = checkVariable(record, name, type);\n+        assertEquals(global.kind(), Declaration.Variable.Kind.FIELD);\n+        return global;\n+    }\n+\n+    public static Declaration.Variable checkBitField(Declaration.Scoped record, String name, Type type, int size) {\n+        Declaration.Variable global = checkVariable(record, name, type);\n+        assertEquals(global.kind(), Declaration.Variable.Kind.BITFIELD);\n+        assertEquals(global.layout().get().bitSize(), size);\n+        return global;\n+    }\n+\n+    public static void checkFunction(Declaration.Function function, Type ret, Type... params) {\n+        assertTypeEquals(ret, function.type().returnType());\n+        assertEquals(function.parameters().size(), params.length);\n+        for (int i = 0 ; i < params.length ; i++) {\n+            assertTypeEquals(params[i], function.type().argumentTypes().get(i));\n+            Type paramType = function.parameters().get(i).type();\n+            if (paramType instanceof Type.Array) {\n+                assertTypeEquals(params[i], Type.pointer(((Type.Array) paramType).elementType()));\n+            } else {\n+                assertTypeEquals(params[i], function.parameters().get(i).type());\n+            }\n+        }\n+    }\n+\n+    public static Declaration.Function checkFunction(Declaration.Scoped toplevel,String name , Type ret, Type... params) {\n+        Declaration.Function function = findDecl(toplevel, name, Declaration.Function.class);\n+        checkFunction(function, ret,params);\n+        return function;\n+    }\n+\n+    public static Declaration.Constant checkConstant(Declaration.Scoped toplevel, String name, Type type, Object value) {\n+        Declaration.Constant constant = findDecl(toplevel, name, Declaration.Constant.class);\n+        assertTypeEquals(type, constant.type());\n+        assertEquals(value, constant.value());\n+        return constant;\n+    }\n+\n+    public static Predicate<Declaration> byName(final String name) {\n+        return d -> d.name().equals(name);\n+    }\n+\n+    public static Predicate<Declaration> byNameAndType(final String name, Class<? extends Declaration> declType) {\n+        return d -> declType.isAssignableFrom(d.getClass()) && d.name().equals(name);\n+    }\n+\n+    public static Optional<Declaration> findDecl(Declaration.Scoped toplevel, Predicate<Declaration> filter) {\n+        return toplevel.members().stream().filter(filter).findAny();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <D extends Declaration> D findDecl(Declaration.Scoped toplevel, String name, Class<D> declType) {\n+        Optional<Declaration> d = findDecl(toplevel, byNameAndType(name, declType));\n+        if (d.isEmpty()) {\n+            fail(\"No declaration with name \" + name + \" found in \" + toplevel);\n+            return null;\n+        }\n+        return (D) d.get();\n+    }\n+\n+    public static void assertTypeEquals(Type expected, Type found) {\n+        assertEquals(expected.getClass(), found.getClass());\n+        if (expected instanceof Type.Primitive) {\n+            assertEquals(expected, found);\n+        } else if (expected instanceof Type.Delegated) {\n+            assertEquals(((Type.Delegated)expected).kind(), ((Type.Delegated)found).kind());\n+            assertTypeEquals(((Type.Delegated)expected).type(), ((Type.Delegated)found).type());\n+        } else if (expected instanceof Type.Array) {\n+            assertEquals(((Type.Array)expected).kind(), ((Type.Array)found).kind());\n+            assertEquals(((Type.Array)expected).elementCount(), ((Type.Array)found).elementCount());\n+            assertTypeEquals(((Type.Array)expected).elementType(), ((Type.Array)found).elementType());\n+        } else if (expected instanceof Type.Declared) {\n+            assertEquals(((Type.Declared)expected).tree(), ((Type.Declared)found).tree());\n+        } else if (expected instanceof Type.Function) {\n+            assertTypeEquals(((Type.Function)expected).returnType(), ((Type.Function)found).returnType());\n+            assertEquals(((Type.Function)expected).argumentTypes().size(), ((Type.Function)found).argumentTypes().size());\n+            assertEquals(((Type.Function)expected).varargs(), ((Type.Function)found).varargs());\n+            for (int i = 0 ; i < ((Type.Function)expected).argumentTypes().size() ; i++) {\n+                assertTypeEquals(((Type.Function)expected).argumentTypes().get(i), ((Type.Function)found).argumentTypes().get(i));\n+            }\n+        }\n+    }\n+\n+    public static Type unwrapDelegatedType(Type type, Type.Delegated.Kind kind) {\n+        assertTrue(type instanceof Type.Delegated,\n+                \"Expecting Type.Delegated, got \" + type.getClass());\n+        Type.Delegated delegated = (Type.Delegated) type;\n+        assertEquals(delegated.kind(), kind);\n+        return delegated.type();\n+    }\n+\n+    public static Type unwrapPointerType(Type type) {\n+        return unwrapDelegatedType(type, Type.Delegated.Kind.POINTER);\n+    }\n+\n+    public static Type unwrapTypedefType(Type type) {\n+        return unwrapDelegatedType(type, Type.Delegated.Kind.TYPEDEF);\n+    }\n+\n+    public static Type unwrapArrayType(Type type, long size) {\n+        assertTrue(type instanceof Type.Array,\n+                \"Expecting Type.Array, got \" + type.getClass());\n+        Type.Array arType = (Type.Array) type;\n+        assertEquals(arType.elementCount().getAsLong(), size);\n+        return arType.elementType();\n+    }\n+\n+    public static Type unwrapArrayType(Type type) {\n+        assertTrue(type instanceof Type.Array,\n+                \"Expecting Type.Array, got \" + type.getClass());\n+        Type.Array arType = (Type.Array) type;\n+        assertTrue(arType.elementCount().isEmpty());\n+        return arType.elementType();\n+    }\n+\n+    static class TypeUnwrapper {\n+        private Type type;\n+\n+        private TypeUnwrapper(Type type) {\n+            this.type = type;\n+        }\n+\n+        public static TypeUnwrapper of(Type type) {\n+            return new TypeUnwrapper(type);\n+        }\n+\n+        public TypeUnwrapper unwrapPointer() {\n+            type = unwrapPointerType(type);\n+            return this;\n+        }\n+\n+        public TypeUnwrapper unwrapTypedef() {\n+            type = unwrapTypedefType(type);\n+            return this;\n+        }\n+\n+        public TypeUnwrapper unwrapArray(long size) {\n+            type = unwrapArrayType(type, size);\n+            return this;\n+        }\n+\n+        public TypeUnwrapper unwrapArray() {\n+            type = unwrapArrayType(type);\n+            return this;\n+        }\n+\n+        public Type get() {\n+            return type;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/jextract\/JextractApiTestBase.java","additions":267,"deletions":0,"binary":false,"changes":267,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @build JextractApiTestBase\n+ * @run testng\/othervm -Dforeign.restricted=permit SmokeTest\n+ *\/\n+\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Type;\n+import org.testng.annotations.Test;\n+\n+public class SmokeTest extends JextractApiTestBase {\n+\n+    @Test\n+    public void testParser() {\n+        Declaration.Scoped d = parse(\"smoke.h\");\n+        Declaration.Scoped pointDecl = checkStruct(d, \"Point\", \"x\", \"y\");\n+        Type intType = ((Declaration.Variable)pointDecl.members().get(0)).type();\n+        checkGlobal(d, \"p\", Type.declared(pointDecl));\n+        checkFunction(d, \"distance\", intType, Type.declared(pointDecl), Type.declared(pointDecl));\n+        Declaration.Variable ch_ptr_ptr = findDecl(d, \"ch_ptr_ptr\", Declaration.Variable.class);\n+        checkFunction(d, \"pointers\", ch_ptr_ptr.type(), ch_ptr_ptr.type(), ch_ptr_ptr.type());\n+        checkConstant(d, \"ZERO\", intType, 0L);\n+    }\n+}\n","filename":"test\/jdk\/java\/jextract\/SmokeTest.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+#\n+# Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+modules = jdk.incubator.jextract\n","filename":"test\/jdk\/java\/jextract\/TEST.properties","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ Forward reference of struct to cause ConcurrentModificationException\n+struct foo;\n+\n+\/\/ Declaration above is required, without it, the argument s cause\n+\/\/ a C warning as struct foo only visible to the function.\n+int withRecordTypeArg(int n, struct foo s);\n+struct foo returnRecordType(void);\n+\n+\/\/ Improper header may write such with definition in other file\n+struct bar returnBar(void);\n+void withBar(struct bar s);\n+\n+struct bar *nextBar(struct bar *current);\n+\n+struct foo {\n+    int n;\n+    struct foo *ptr;\n+};\n","filename":"test\/jdk\/java\/jextract\/Test8238712.h","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @build JextractApiTestBase\n+ * @run testng\/othervm -Dforeign.restricted=permit Test8238712\n+ *\/\n+\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Type;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertTrue;\n+\n+public class Test8238712 extends JextractApiTestBase {\n+    @Test\n+    public void test8238712() {\n+        Declaration.Scoped d = parse(\"Test8238712.h\");\n+        Declaration.Scoped structFoo = checkStruct(d, \"foo\", \"n\", \"ptr\");\n+        Type intType = ((Declaration.Variable) structFoo.members().get(0)).type();\n+        Type fooType = Type.declared(structFoo);\n+        checkFunction(d, \"withRecordTypeArg\", intType, intType, fooType);\n+        checkFunction(d, \"returnRecordType\", fooType);\n+        \/\/ Opaque struct, have no field\n+        Declaration.Scoped structBar = checkStruct(d, \"bar\");\n+        assertTrue(structBar.layout().isEmpty());\n+        Type barType = Type.declared(structBar);\n+        \/\/ Function with opaque struct won't work but should have cursor for tool to handle\n+        checkFunction(d, \"returnBar\", barType);\n+        checkFunction(d, \"withBar\", Type.void_(), barType);\n+        \/\/ Function use pointer to opaque struct should be OK\n+        Type barPointer = Type.pointer(barType);\n+        checkFunction(d, \"nextBar\", barPointer, barPointer);\n+    }\n+}\n","filename":"test\/jdk\/java\/jextract\/Test8238712.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct Foo {\n+    unsigned int a:1;\n+    unsigned int b:1;\n+    unsigned int c:30;\n+};\n+\n+struct Bar {\n+    unsigned int x:1;\n+    unsigned int y:31;\n+    struct Foo z[1];\n+};\n+\n+struct Baz {\n+    unsigned long long x:1;\n+    unsigned long long y:63;\n+    struct Bar z[1];\n+};\n","filename":"test\/jdk\/java\/jextract\/Test8239490.h","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @build JextractApiTestBase\n+ * @run testng\/othervm -Dforeign.restricted=permit Test8239490\n+ *\/\n+\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Type;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.*;\n+\n+public class Test8239490 extends JextractApiTestBase {\n+    @Test\n+    public void test8239490() {\n+        Declaration.Scoped d = parse(\"Test8239490.h\");\n+        \/\/ check Foo\n+        String[] fooBitfieldNames = { \"a\", \"b\", \"c\" };\n+        int[] fooBitfieldSizes = { 1, 1, 30 };\n+        Declaration.Scoped structFoo = checkStruct(d, \"Foo\", \"\");\n+        Declaration.Scoped bitfieldsFoo = checkBitfields(structFoo, \"\", \"a\", \"b\", \"c\");\n+        Type intType = ((Declaration.Variable)bitfieldsFoo.members().get(0)).type();\n+        for (int i = 0 ; i < fooBitfieldNames.length ; i++) {\n+            checkBitField(bitfieldsFoo, fooBitfieldNames[i], intType, fooBitfieldSizes[i]);\n+        }\n+        \/\/ check Bar\n+        String[] barBitfieldNames = { \"x\", \"y\" };\n+        int[] barBitfieldSizes = { 1, 31 };\n+        Declaration.Scoped structBar = checkStruct(d, \"Bar\", \"\", \"z\");\n+        Declaration.Scoped bitfieldsBar = checkBitfields(structBar, \"\", \"x\", \"y\");\n+        for (int i = 0 ; i < barBitfieldNames.length ; i++) {\n+            checkBitField(bitfieldsBar, barBitfieldNames[i], intType, barBitfieldSizes[i]);\n+        }\n+        checkField(structBar, \"z\", Type.array(1, Type.declared(structFoo)));\n+\n+        \/\/ check Baz\n+        String[] bazBitfieldNames = { \"x\", \"y\" };\n+        int[] bazBitfieldSizes = { 1, 63 };\n+        Declaration.Scoped structBaz = checkStruct(d, \"Baz\", \"\", \"z\");\n+        Declaration.Scoped bitfieldsBaz = checkBitfields(structBaz, \"\", \"x\", \"y\");\n+        Type longType = ((Declaration.Variable)bitfieldsBaz.members().get(0)).type();\n+        for (int i = 0 ; i < bazBitfieldNames.length ; i++) {\n+            checkBitField(bitfieldsBaz, bazBitfieldNames[i], longType, bazBitfieldSizes[i]);\n+        }\n+        checkField(structBaz, \"z\", Type.array(1, Type.declared(structBar)));\n+    }\n+}\n","filename":"test\/jdk\/java\/jextract\/Test8239490.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,25 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+typedef void CB(int);\n+void func_cb(CB cb);\n","filename":"test\/jdk\/java\/jextract\/Test8240372.h","additions":25,"deletions":0,"binary":false,"changes":25,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @build JextractApiTestBase\n+ * @run testng\/othervm -Dforeign.restricted=permit Test8240372\n+ *\/\n+\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Type;\n+import org.testng.annotations.Test;\n+\n+public class Test8240372 extends JextractApiTestBase {\n+    @Test\n+    public void test8239490() {\n+        Declaration.Scoped d = parse(\"Test8240372.h\");\n+\n+        Type funcType = Type.function(false, Type.void_(), Type.primitive(Type.Primitive.Kind.Int));\n+        Type typedefType = Type.typedef(\"CB\", funcType);\n+        checkFunction(d, \"func_cb\", Type.void_(), typedefType);\n+    }\n+}\n","filename":"test\/jdk\/java\/jextract\/Test8240372.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+union Foo {\n+    int i;\n+    long long l;\n+};\n","filename":"test\/jdk\/java\/jextract\/Test8240853.h","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @build JextractApiTestBase\n+ * @run testng\/othervm -Dforeign.restricted=permit Test8240853\n+ *\/\n+\n+import jdk.incubator.jextract.Declaration;\n+import org.testng.annotations.Test;\n+\n+public class Test8240853 extends JextractApiTestBase {\n+    @Test\n+    public void test8240853() {\n+        Declaration.Scoped d = parse(\"Test8240853.h\");\n+        \/\/ check Foo\n+        checkUnion(d, \"Foo\", \"i\", \"l\");\n+    }\n+}\n","filename":"test\/jdk\/java\/jextract\/Test8240853.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8239808\n+ * @build JextractApiTestBase\n+ * @run testng\/othervm -Dforeign.restricted=permit TestAttributes\n+ *\/\n+\n+import java.lang.constant.Constable;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import jdk.incubator.foreign.MemoryLayouts;\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Type;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestAttributes extends JextractApiTestBase {\n+    private final static Type C_INT = Type.primitive(Type.Primitive.Kind.Int);\n+    private final static String ASMLABEL = \"AsmLabelAttr\";\n+\n+    private void validateAsmLabel(Declaration d, boolean isAdd) {\n+        var attrs = d.getAttribute(ASMLABEL).get();\n+        String value = isMacOSX ? \"_\" : \"\";\n+        value += d.name();\n+        value += isAdd ? \"A\" : \"B\";\n+        assertEquals(attrs.get(0), value);\n+    }\n+\n+    private void validateHeader(Declaration.Scoped top, boolean isAdd) {\n+        if (isWindows) {\n+            \/\/ TODO: add Windows validation\n+            \/\/ Simply dump declaration for now\n+            System.out.println(top);\n+            return;\n+        }\n+        var list = top.members().stream()\n+                .filter(byNameAndType(\"foo\", Declaration.Variable.class))\n+                .map(Declaration.Variable.class::cast)\n+                .collect(Collectors.toList());\n+        assertEquals(list.size(), 3);\n+        int hasAttrs = 0;\n+        for (Declaration.Variable foo: list) {\n+            assertEquals(Declaration.Variable.Kind.GLOBAL, foo.kind());\n+            assertTypeEquals(C_INT, foo.type());\n+            if (foo.getAttribute(ASMLABEL).isPresent()) {\n+                hasAttrs++;\n+                validateAsmLabel(foo, isAdd);\n+            }\n+        }\n+        assertEquals(hasAttrs, 2);\n+        var listFunc = top.members().stream()\n+                .filter(byNameAndType(\"func\", Declaration.Function.class))\n+                .map(Declaration.Function.class::cast)\n+                .collect(Collectors.toList());\n+        assertEquals(listFunc.size(), 3);\n+        hasAttrs = 0;\n+        for (Declaration.Function func: listFunc) {\n+            checkFunction(func, C_INT, C_INT, C_INT);\n+            if (func.getAttribute(ASMLABEL).isPresent()) {\n+                hasAttrs++;\n+                validateAsmLabel(func, isAdd);\n+            }\n+        }\n+        assertEquals(hasAttrs, 2);\n+    }\n+\n+    @Test\n+    public void testA() {\n+        Declaration.Scoped d = parse(\"libAsmSymbol.h\", \"-DADD\");\n+        validateHeader(d, true);\n+    }\n+\n+    @Test\n+    public void testB() {\n+        Declaration.Scoped d = parse(\"libAsmSymbol.h\");\n+        validateHeader(d, false);\n+    }\n+\n+    private static  Constable getSingleValue(Declaration d, String name) {\n+        List<Constable> values = d.getAttribute(name).get();\n+        assertEquals(1, values.size());\n+        return values.get(0);\n+    }\n+\n+    @Test\n+    public void testAddAttribute() {\n+        final String ts = \"timestamp\";\n+        Declaration.Scoped d = parse(\"libAsmSymbol.h\");\n+        String timestamp = LocalDateTime.now().format(DateTimeFormatter.ISO_DATE_TIME);\n+        Declaration withAttrs = d.withAttribute(\"header\", d.name())\n+                .withAttribute(ts, timestamp);\n+\n+        assertEquals(getSingleValue(withAttrs, \"header\"), d.name());\n+        assertEquals(getSingleValue(withAttrs, ts), timestamp);\n+\n+        String timestamp2 = LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);\n+        Declaration withNewAttrs = withAttrs.withAttribute(ts, timestamp2);\n+        assertEquals(getSingleValue(withNewAttrs, ts), timestamp2);\n+\n+        \/\/ Make sure original Declaration is not altered\n+        assertEquals(getSingleValue(withAttrs, ts), timestamp);\n+\n+        \/\/ Add more value to same attribute\n+        withNewAttrs = withAttrs.withAttribute(ts, Stream.concat(\n+                withAttrs.getAttribute(ts).map(List::stream).orElse(Stream.empty()),\n+                Stream.of(timestamp2)\n+            ).toArray(Constable[]::new));\n+        assertEquals(withNewAttrs.getAttribute(ts).get(), List.of(timestamp, timestamp2));\n+        assertEquals(getSingleValue(withNewAttrs,\"header\"), d.name());\n+\n+        \/\/ Remove attribute\n+        withAttrs = withNewAttrs.withAttribute(ts);\n+        assertTrue(withAttrs.getAttribute(ts).isEmpty());\n+\n+        \/\/ Strip attribute\n+        withNewAttrs = withNewAttrs.stripAttributes();\n+        assertTrue(withNewAttrs.attributeNames().isEmpty());\n+    }\n+\n+    @Test\n+    public void replaceFunctionSymbol() {\n+        Declaration.Scoped d = parse(\"libAsmSymbol.h\", \"-DADD\");\n+        validateHeader(d, true);\n+\n+        var members = d.members().stream()\n+            .map(m -> m.getAttribute(ASMLABEL)\n+                    .map(attr -> m.withAttribute(ASMLABEL, attr.get(0).toString().replace('A', 'B')))\n+                    .orElse(m))\n+            .toArray(Declaration[]::new);\n+        Declaration.Scoped patched = Declaration.toplevel(d.pos(), members);\n+        validateHeader(patched, false);\n+    }\n+}\n","filename":"test\/jdk\/java\/jextract\/TestAttributes.java","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8239128\n+ * @build JextractApiTestBase\n+ * @run testng\/othervm -Dforeign.restricted=permit TestMacros\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Type;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+public class TestMacros extends JextractApiTestBase {\n+    Declaration.Scoped badMacro;\n+    Declaration.Scoped foo;\n+    Declaration.Scoped bar;\n+    private final static Type C_INT = Type.primitive(Type.Primitive.Kind.Int);\n+\n+    @BeforeClass\n+    public void parse() {\n+        \/\/ We need stdint.h for pointer macro, otherwise evaluation failed and Constant declaration is not created\n+        Path builtinInc = Paths.get(System.getProperty(\"java.home\"), \"conf\", \"jextract\");\n+        badMacro = parse(\"badMacros.h\", \"-I\", builtinInc.toString());\n+\n+        foo = checkStruct(badMacro, \"foo\", \"ptrFoo\", \"ptrBar\");\n+        bar = checkStruct(badMacro, \"bar\", \"ptrFoo\", \"arFooPtr\");\n+    }\n+\n+    @Test\n+    public void testBadMacros() {\n+        checkConstant(badMacro, \"INVALID_INT_CONSUMER\",\n+            Type.pointer(Type.function(false, Type.void_(), C_INT)),\n+            0L);\n+        \/\/ Record type in macro definition are erased to void\n+        checkConstant(badMacro, \"NO_FOO\", Type.pointer(Type.declared(foo)), 0L);\n+        checkConstant(badMacro, \"INVALID_INT_ARRAY_PTR\", Type.pointer(Type.pointer(C_INT)), 0L);\n+    }\n+\n+    @Test\n+    public void verifyFunctions() {\n+        checkFunction(badMacro, \"func\", Type.void_(),\n+            Type.pointer(Type.declared(bar)), Type.pointer(Type.declared(foo)));\n+        checkFunction(badMacro, \"withArray\", Type.void_(),\n+            Type.pointer(Type.typedef(\"foo_t\", Type.pointer(Type.declared(foo)))));\n+    }\n+\n+    @Test\n+    public void verifyGlobals() {\n+        checkGlobal(badMacro, \"op\", Type.pointer(\n+                Type.function(false, Type.void_(), C_INT, Type.pointer(C_INT))));\n+    }\n+\n+    @Test\n+    public void verifyFields() {\n+        Type foo_t = Type.typedef(\"foo_t\", Type.pointer(Type.declared(foo)));\n+        checkField(foo, \"ptrFoo\", foo_t);\n+        checkField(foo, \"ptrBar\", Type.pointer(Type.declared(bar)));\n+        checkField(bar, \"ptrFoo\", foo_t);\n+        checkField(bar, \"arFooPtr\", Type.pointer(foo_t));\n+    }\n+}\n","filename":"test\/jdk\/java\/jextract\/TestMacros.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,226 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @build JextractApiTestBase\n+ * @run testng\/othervm -ea -Dforeign.restricted=permit TestTypedef\n+ *\/\n+\n+import java.util.Set;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Type;\n+\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotEquals;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+\n+public class TestTypedef extends JextractApiTestBase {\n+    Declaration.Scoped root;\n+\n+    @BeforeClass\n+    public void parse() {\n+        root = parse(\"testTypedef.h\");\n+        System.out.println(root);\n+    }\n+\n+    private Declaration[] findAllWithName(Declaration.Scoped scope, String name) {\n+        return scope.members().stream().filter(byName(name)).toArray(Declaration[]::new);\n+    }\n+\n+    public static Type getTypedefType(Declaration.Scoped scope, String name) {\n+        Declaration.Typedef d = findDecl(scope, name, Declaration.Typedef.class);\n+        Type type = d.type();\n+        \/\/ Typedef declaration should return canonical type\n+        if (type instanceof Type.Delegated) {\n+            assertNotEquals(((Type.Delegated) type).kind(), Type.Delegated.Kind.TYPEDEF);\n+        }\n+        return d.type();\n+    }\n+\n+    private Declaration.Scoped assertDeclaredTypedef(Declaration.Typedef decl) {\n+        Type type = decl.type();\n+        assertTrue(type instanceof Type.Declared, \"Expecting Type.Declared, got \" + type.getClass());\n+        return ((Type.Declared) type).tree();\n+    }\n+\n+    private Declaration.Scoped assertAnonymousRecord(Declaration.Scoped scope, String name) {\n+        Declaration[] ar = findAllWithName(scope, name);\n+        assertEquals(ar.length, 1);\n+        assertTrue(ar[0] instanceof Declaration.Typedef, \"Expectint Declaration.Typedef, but got \" + ar[0].getClass());\n+        Declaration.Scoped record = assertDeclaredTypedef((Declaration.Typedef) ar[0]);\n+        return record;\n+    }\n+\n+    private Declaration.Scoped assertNamedRecord(Declaration.Scoped scope, String name) {\n+        Declaration[] ar = findAllWithName(scope, name);\n+        assertEquals(ar.length, 1);\n+        assertTrue(ar[0] instanceof Declaration.Scoped, \"Expectint Declaration.Scoped, but got \" + ar[0].getClass());\n+        return (Declaration.Scoped) ar[0];\n+    }\n+\n+    @Test\n+    public void NoDuplicateSameNameTypedef() {\n+        \/\/ When typedef a named record with the same name, present the scoped\n+        \/\/ declaration and ignore the typedef\n+        Declaration.Scoped s = assertNamedRecord(root, \"Point3D\");\n+        assertEquals(s.kind(), Declaration.Scoped.Kind.STRUCT);\n+        checkNames(s.members(), \"i\", \"j\", \"k\");\n+\n+        s = assertNamedRecord(root, \"SIZE\");\n+        assertEquals(s.kind(), Declaration.Scoped.Kind.ENUM);\n+        checkNames(s.members(), \"XS\", \"S\", \"M\", \"L\", \"XL\");\n+    }\n+\n+    @Test\n+    public void TypedefReferences() {\n+        \/\/ When reference to a typedef, the Type should be Type.Delegated\n+        \/\/ With the type to be the referenced type\n+        Declaration.Scoped pt3d = checkStruct(root, \"Point3D\", \"i\", \"j\", \"k\");\n+        Declaration.Function drawParamid = findDecl(root, \"drawParamid\", Declaration.Function.class);\n+        Type.Function fnType = drawParamid.type();\n+        \/\/ Array in function argument is lowered to pointer\n+        Type type = TypeUnwrapper.of(fnType.argumentTypes().get(0))\n+                        .unwrapPointer().unwrapTypedef().get();\n+        assertEquals(type, Type.declared(pt3d));\n+\n+        Declaration.Function do_ops = findDecl(root, \"do_ops\", Declaration.Function.class);\n+        fnType = do_ops.type();\n+        type = unwrapTypedefType(fnType.returnType());\n+        assertEquals(type, getTypedefType(root, \"op_sequence\"));\n+        type = fnType.argumentTypes().get(0);\n+        type = unwrapTypedefType(type);\n+        assertEquals(type, getTypedefType(root, \"int_op\"));\n+        type = fnType.argumentTypes().get(1);\n+        type = unwrapTypedefType(type);\n+        assertEquals(type, getTypedefType(root, \"count_t\"));\n+    }\n+\n+    @Test\n+    public void TypedefsToSameType()  {\n+        \/\/ For typedef declaration, the type will be the canonical type\n+        \/\/ Which means, the type will not be another typedef\n+        \/\/ However, it can be other delegated type or an array\n+        Declaration.Scoped pt = checkStruct(root, \"Point\", \"i\", \"j\");\n+        Type.Declared type = Type.declared(pt);\n+        assertEquals(getTypedefType(root, \"POINT\"), type);\n+        assertEquals(getTypedefType(root, \"point_t\"), type);\n+\n+        Type canonical = TypeUnwrapper.of(getTypedefType(root, \"rectangle\"))\n+                .unwrapArray(4)\n+                \/\/ FIXME? If we would like to generate array using typedef type\n+                \/\/ then we need to use typedef as array element type and\n+                \/\/ requires following line to pass the test.\n+                \/\/ .unwrapTypedef()\n+                .get();\n+        assertEquals(canonical, type);\n+\n+        Declaration.Variable canvas = findDecl(root, \"canvas\", Declaration.Variable.class);\n+        assertEquals(canvas.kind(), Declaration.Variable.Kind.GLOBAL);\n+        Type ref = TypeUnwrapper.of(canvas.type())\n+            .unwrapTypedef()\n+            .unwrapArray(4)\n+            .get();\n+        assertEquals(ref, type);\n+\n+        getTypedefType(root, \"count_t\");\n+    }\n+\n+    @Test\n+    public void TypedefsArrays()  {\n+        Type intType = getTypedefType(root, \"cordinate_t\");\n+\n+        \/\/ As noted earlier, we currently have canonical array element type from typedef\n+        Type type = getTypedefType(root, \"location2D\");\n+        Type elementType = unwrapArrayType(type, 2);\n+        assertEquals(elementType, intType);\n+\n+        Type count_t = getTypedefType(root, \"count_t\");\n+        type = getTypedefType(root, \"dimensions\");\n+        elementType = unwrapArrayType(type);\n+        assertEquals(elementType, count_t);\n+        type = getTypedefType(root, \"count_ptr\");\n+        assertEquals(type, Type.pointer(count_t));\n+    }\n+\n+    @Test\n+    public void AnonymousRecordTypedef() {\n+        \/\/ For anonymous typedef, present the typedef declaration and\n+        \/\/ the Scope declaration can be obtained via Variable.type()\n+        Declaration.Scoped record = assertAnonymousRecord(root, \"op_sequence\");\n+        assertEquals(record.kind(), Declaration.Scoped.Kind.STRUCT);\n+        checkNames(record.members(), \"times\", \"op\");\n+\n+        record = assertAnonymousRecord(root, \"IntOrFloat\");\n+        assertEquals(record.kind(), Declaration.Scoped.Kind.UNION);\n+        checkNames(record.members(), \"i\", \"f\");\n+\n+        record = assertAnonymousRecord(root, \"codetype_t\");\n+        assertEquals(record.kind(), Declaration.Scoped.Kind.ENUM);\n+        checkNames(record.members(), \"Java\", \"C\", \"CPP\", \"Python\", \"Ruby\");\n+    }\n+\n+    @Test\n+    public void CheckAnonyousDeclarations() {\n+        \/\/ Should we expunge anonymous declaration?\n+        \/\/ They only needed if referenced as a field or gloabal variable\n+        \/\/ Exception enum, as they can be used as pleased, so we need to\n+        \/\/ elevate them into constants.\n+        \/\/ Anyhow, current implementation pass through enum, not elevate them.\n+        \/\/ So we just check that\n+        Declaration[] ar = findAllWithName(root, \"\");\n+        assertEquals(ar.length, 2);\n+        Declaration.Scoped e = (Declaration.Scoped) ar[0];\n+        assertEquals(e.kind(), Declaration.Scoped.Kind.ENUM);\n+        checkNames(e.members(), \"RED\", \"GREEN\", \"BLUE\");\n+        e = (Declaration.Scoped) ar[1];\n+        assertEquals(e.kind(), Declaration.Scoped.Kind.ENUM);\n+        checkNames(e.members(), \"Java\", \"C\", \"CPP\", \"Python\", \"Ruby\");\n+    }\n+\n+    @Test\n+    public void CheckFunctionPointers() {\n+        Type intType = getTypedefType(root, \"cordinate_t\");\n+        Type intOpType = getTypedefType(root, \"int_op\");\n+        assertEquals(intOpType, Type.pointer(Type.function(false, intType, intType)));\n+        Type intOp2Type = getTypedefType(root, \"int_op2\");\n+        assertEquals(intOp2Type, Type.pointer(Type.function(false, intType, intType, intType)));\n+\n+        checkGlobal(root, \"another_int_op\", intOpType);\n+\n+        Declaration.Function getFn = findDecl(root, \"getFn\", Declaration.Function.class);\n+        assertEquals(getFn.parameters().size(), 0);\n+        Type.Delegated retType = (Type.Delegated) getFn.type().returnType();\n+        assertTrue(retType.kind() == Type.Delegated.Kind.POINTER);\n+        Type.Function fnType = (Type.Function) retType.type();\n+        assertEquals(fnType.returnType(), Type.void_());\n+        assertEquals(fnType.argumentTypes().get(1),\n+                Type.typedef(\"count_t\", getTypedefType(root, \"count_t\")));\n+    }\n+}\n","filename":"test\/jdk\/java\/jextract\/TestTypedef.java","additions":226,"deletions":0,"binary":false,"changes":226,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ Macro of constant function pointer\n+#define INVALID_INT_CONSUMER         (void (*)(int))0\n+\n+struct foo;\n+typedef struct foo *foo_t;\n+struct bar;\n+\n+\/\/ Macro of constant struct pointer\n+#define NO_FOO ((foo_t)0)\n+\n+\/\/ Cases where resolving introduce new type references\n+\/\/ Pointer to pointer in macro\n+#define INVALID_INT_ARRAY_PTR (int**) 0\n+\/\/ Function pointer with pointer type argument\n+void (*op)(int cnt, int* operands);\n+void func(struct bar *pBar, struct foo *pFoo);\n+\n+\/\/ Cyclic struct pointer within struct definitions\n+struct foo {\n+    foo_t ptrFoo;\n+    struct bar *ptrBar;\n+};\n+\n+struct bar {\n+    foo_t ptrFoo;\n+    foo_t *arFooPtr;\n+};\n+\n+\/\/ Function with array to pointer\n+void withArray(foo_t ar[2]);\n","filename":"test\/jdk\/java\/jextract\/badMacros.h","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+  #ifdef IMPL\n+    #define EXPORT __declspec(dllexport)\n+  #else\n+    #define EXPORT __declspec(dllimport)\n+  #endif \/\/ IMPL\n+#else\n+#define EXPORT\n+#endif \/\/_WIN64\n+\n+#ifdef _WIN32\n+\/\/ Windows doesn't really support asm symbol, this is similar approach for C code to\n+\/\/ achieve similar, but this won't work with Panama until we support such Macro\n+#ifdef ADD\n+#define foo fooA\n+#define func funcA\n+#else\n+#define foo fooB\n+#define func funcB\n+#endif \/\/ADD\n+#define ALIAS(sym)\n+\n+#elif __APPLE__\n+#define ALIAS(sym) __asm(\"_\" #sym)\n+#else\n+#define ALIAS(sym) __asm__(#sym)\n+#endif \/\/ _WIN32\n+\n+\/\/ We do 3 declarations to make sure we will pick up alias no matter the sequence of encounter\n+\/\/ Without alias\n+EXPORT extern int foo;\n+EXPORT int func (int x, int y);\n+\n+\/\/ With alias\n+#ifdef ADD\n+\n+EXPORT extern int foo ALIAS(fooA);\n+EXPORT int func (int x, int y) ALIAS(funcA);\n+\n+#else\n+\n+EXPORT extern int foo ALIAS(fooB);\n+EXPORT int func (int x, int y) ALIAS(funcB);\n+\n+#endif \/\/ ADD\n+\n+\/\/ Without alias again\n+EXPORT extern int foo;\n+EXPORT int func (int x, int y);\n+\n","filename":"test\/jdk\/java\/jextract\/libAsmSymbol.h","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.jextract.Declaration;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @library .. \/test\/lib\n+ * @modules jdk.incubator.jextract\n+ * @build JextractApiTestBase\n+ * @bug 8249536\n+ * @summary jextract throw IllegalStateException for bitfields in nested anonymous structs\n+ * @run testng\/othervm -Dforeign.restricted=permit TestNestedBitfields\n+ *\/\n+public class TestNestedBitfields extends JextractApiTestBase {\n+\n+    @Test\n+    public void testNestedBitfields() {\n+        Declaration.Scoped d = parse(\"nestedbitfields.h\");\n+        Declaration.Scoped foo = checkStruct(d, \"Foo\", \"\");\n+        Declaration.Scoped foo$anon = checkStruct(foo, \"\", \"\");\n+        checkBitfields(foo$anon, \"\", \"a\", \"b\");\n+\n+        Declaration.Scoped bar = checkStruct(d, \"Bar\", \"\");\n+        Declaration.Scoped bar$anon = checkStruct(bar, \"\", \"\");\n+        Declaration.Scoped bar$anon$anon = checkStruct(bar$anon, \"\", \"\");\n+        checkBitfields(bar$anon$anon, \"\", \"a\", \"b\");\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/jextract\/nestedBitfields\/TestNestedBitfields.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct Foo {\n+    struct {\n+        int a : 7;\n+        int b : 25;\n+    };\n+};\n+\n+struct Bar {\n+    struct {\n+        struct {\n+            int a : 7;\n+            int b : 25;\n+        };\n+    };\n+};\n+\n","filename":"test\/jdk\/java\/jextract\/nestedBitfields\/nestedbitfields.h","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/simple struct\n+struct Point {\n+    int x;\n+    int y;\n+};\n+\n+\/\/global\n+struct Point p;\n+\n+\/\/function\n+int distance(struct Point p1, struct Point p2);\n+\n+\/\/function with arrays\n+char ** ch_ptr_ptr;\n+char** pointers(char* arr1[], char* arr2[]);\n+\n+\/\/and a constant\n+#define ZERO 0\n","filename":"test\/jdk\/java\/jextract\/smoke.h","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+typedef unsigned long count_t;\n+typedef int (*int_op)(int);\n+typedef int (*int_op2)(int, int);\n+\n+typedef struct {\n+    count_t times;\n+    int_op op;\n+} op_sequence;\n+\n+int_op add;\n+\n+\/\/ Global variable with unnamed function type\n+int (*another_int_op)(int);\n+\n+\/\/ Function prototype\n+op_sequence do_ops(int_op op, count_t times);\n+\n+\/\/ anonymous typedef\n+typedef union {\n+    int i;\n+    float f;\n+} IntOrFloat;\n+\n+\/\/ Completely anonymous enum\n+enum {\n+    RED = 0xff0000,\n+    GREEN = 0x00ff00,\n+    BLUE = 0x0000ff\n+};\n+\n+typedef enum SIZE {\n+    XS,\n+    S,\n+    M,\n+    L,\n+    XL\n+} SIZE;\n+\n+\/\/ Typedef anonymous enum\n+typedef enum {\n+   Java,\n+   C,\n+   CPP,\n+   Python,\n+   Ruby\n+} codetype_t;\n+\n+\/\/ declaration only\n+struct Point;\n+\/\/ definition\n+struct Point {\n+   int i;\n+   int j;\n+};\n+\/\/ different name struct typedef\n+typedef struct Point POINT;\n+\/\/ layered typedef\n+typedef POINT point_t;\n+typedef point_t rectangle[4];\n+\n+rectangle canvas;\n+\n+typedef int cordinate_t;\n+typedef cordinate_t location2D[2];\n+typedef count_t dimensions[];\n+typedef count_t *count_ptr;\n+\n+\/\/ same name struct typedef\n+typedef struct Point3D {\n+    int i;\n+    int j;\n+    int k;\n+} Point3D;\n+\/\/ User of same name typedef\n+void drawParamid(Point3D vertices[4]);\n+\n+\/\/ anonymous types not references\n+struct {\n+    int foo;\n+    int bar;\n+};\n+\n+static union {\n+    int i;\n+    long l;\n+};\n+\n+\/\/ No way to declare anonymous function type\n+\/\/ But here is a function getFn to return a function type\n+void (*getFn(void))(int, count_t, int_op);\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/jextract\/testTypedef.h","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build BadBitfieldTest\n+ * @run testng\/othervm -Dforeign.restricted=permit BadBitfieldTest\n+ *\/\n+\n+\/*\n+ * MSVC: (\/d1reportSingleClassLayoutFoo)\n+ * class Foo    size(24):\n+ *      +---\n+ *  0.    | a (bitstart=0,nbits=45)\n+ *  8.    | b (bitstart=0,nbits=24)\n+ *  8.    | c (bitstart=24,nbits=1)\n+ * 16.    | d (bitstart=0,nbits=58)\n+ *      +---\n+ *\n+ * SysV: (PAHole)\n+ * struct Foo {\n+ *     long long int a:45;                0:19   8\n+ *     long long int b:24;                0:251  8\n+ *     XXX 251 bits hole, try to pack\n+ *     long long int c:1;                 8:58   8\n+ *     long long int d:58;                8: 0   8\n+ *\n+ *     size: 16, cachelines: 1, members: 4\n+ *     bit holes: 1, sum bit holes: 251 bits\n+ *     bit_padding: 5 bits\n+ *     last cacheline: 16 bytes\n+ * };\n+ *\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+public class BadBitfieldTest extends JextractToolRunner {\n+    @Test\n+    public void testBadBitfield() {\n+        run(\"-d\", getOutputFilePath(\"badBitfieldsGen\").toString(),\n+                getInputFilePath(\"badBitfields.h\").toString()).checkSuccess();\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/BadBitfieldTest.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.MemorySegment;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import java.nio.file.Path;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryAddress;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertSame;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build ConstantsTest\n+ * @run testng\/othervm -Dforeign.restricted=permit ConstantsTest\n+ *\/\n+public class ConstantsTest extends JextractToolRunner {\n+    private Class<?> constants;\n+    private Path dirPath;\n+    private Loader loader;\n+\n+    @BeforeTest\n+    public void setup() {\n+        dirPath = getOutputFilePath(\"ConstantsTest_output\");\n+        run( \"-d\", dirPath.toString(), getInputFilePath(\"constants.h\").toString()).checkSuccess();\n+        loader = classLoader(dirPath);\n+        constants = loader.loadClass(\"constants_h\");\n+    }\n+\n+    @AfterTest\n+    public void cleanup() {\n+        constants = null;\n+        loader.close();\n+        deleteDir(dirPath);\n+    }\n+\n+    @Test(dataProvider = \"definedConstants\")\n+    public void checkConstantsTypesAndValues(String name, Class<?> type, Consumer<Object> checker) throws ReflectiveOperationException {\n+        var f = findMethod(constants, name);\n+        assertNotNull(f);\n+        assertSame(f.getReturnType(), type);\n+        f.setAccessible(true);\n+        Object actual = f.invoke(null);\n+        checker.accept(actual);\n+    }\n+\n+    @Test(dataProvider = \"missingConstants\")\n+    public void checkMissingConstants(String name) {\n+        assertTrue(findMethod(constants, name) == null);\n+    }\n+\n+    @DataProvider\n+    public static Object[][] definedConstants() {\n+        return new Object[][] {\n+                { \"SUP\", int.class, equalsTo(5) },\n+                { \"ZERO\", int.class, equalsTo(0) },\n+                { \"ONE\", int.class, equalsTo(1) },\n+                { \"TWO\", int.class, equalsTo(2) },\n+                { \"THREE\", int.class, equalsTo(3) },\n+                { \"FOUR\", long.class, equalsTo(4L) },\n+                { \"FIVE\", long.class, equalsTo(5L) },\n+                { \"SIX\", int.class, equalsTo(6) },\n+                { \"FLOAT_VALUE\", float.class, equalsTo(1.32f) },\n+                { \"DOUBLE_VALUE\", double.class, (Consumer<Double>) (actual -> assertEquals(actual, 1.32, 0.1)) },\n+                { \"CHAR_VALUE\", int.class, equalsTo(104) }, \/\/integer char constants have type int\n+                { \"MULTICHAR_VALUE\", int.class, equalsTo(26728) },  \/\/integer char constants have type int\n+                { \"BOOL_VALUE\", byte.class, equalsTo((byte)1) },\n+                { \"SUB\", int.class, equalsTo( 7 ) },\n+                \/\/ pointer type values\n+                { \"STR\", MemorySegment.class, equalsToJavaStr(\"Hello\") },\n+                { \"QUOTE\", MemorySegment.class, equalsToJavaStr(\"QUOTE\") },\n+                { \"ZERO_PTR\", MemoryAddress.class, equalsPtrContents(0) },\n+                { \"F_PTR\", MemoryAddress.class, equalsPtrContents(0xFFFFFFFFFFFFFFFFL) },\n+        };\n+    }\n+\n+    static Consumer<Object> equalsTo(Object expected) {\n+        return actual -> assertEquals(actual, expected);\n+    }\n+\n+    static Consumer<MemorySegment> equalsToJavaStr(String expected) {\n+        return actual -> assertEquals(CLinker.toJavaString(actual), expected);\n+    }\n+\n+    static Consumer<MemoryAddress> equalsPtrContents(long expected) {\n+        return actual -> assertEquals(actual.toRawLongValue(), expected);\n+    }\n+\n+    @DataProvider\n+    public static Object[][] missingConstants() {\n+        return new Object[][] {\n+                { \"ID\" },\n+                { \"SUM\" },\n+                { \"BLOCK_BEGIN\" },\n+                { \"BLOCK_END\" },\n+                { \"INTEGER_MAX_VALUE\" },\n+                { \"CYCLIC_1\" },\n+                { \"CYCLIC_2\" },\n+                \/\/ array\n+                { \"ARRAY\" }\n+        };\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/ConstantsTest.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+void func(int);\n","filename":"test\/jdk\/tools\/jextract\/JDK-8248474.h","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.MemoryAddress;\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertNull;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8240181\n+ * @run testng\/othervm -Dforeign.restricted=permit -Duser.language=en --add-modules jdk.incubator.jextract JextractToolProviderTest\n+ *\/\n+public class JextractToolProviderTest extends JextractToolRunner {\n+    @Test\n+    public void testHelp() {\n+        run().checkFailure(OPTION_ERROR); \/\/ no options\n+        run(\"--help\").checkSuccess();\n+        run(\"-h\").checkSuccess();\n+        run(\"-?\").checkSuccess();\n+    }\n+\n+    \/\/ error for non-existent header file\n+    @Test\n+    public void testNonExistentHeader() {\n+        run(getInputFilePath(\"non_existent.h\").toString())\n+            .checkFailure(INPUT_ERROR)\n+            .checkContainsOutput(\"cannot read header file\");\n+    }\n+\n+    \/\/ error for header including non_existent.h file\n+    @Test\n+    public void testNonExistentIncluder() {\n+        run(getInputFilePath(\"non_existent_includer.h\").toString())\n+            .checkFailure(CLANG_ERROR)\n+            .checkContainsOutput(\"file not found\");\n+    }\n+\n+    @Test\n+    public void testDirectoryAsHeader() {\n+        run(getInputFilePath(\"directory.h\").toString())\n+            .checkFailure(INPUT_ERROR)\n+            .checkContainsOutput(\"not a file\");\n+    }\n+\n+    \/\/ error for header with parser errors\n+    @Test\n+    public void testHeaderWithDeclarationErrors() {\n+        run(getInputFilePath(\"illegal_decls.h\").toString())\n+            .checkFailure(CLANG_ERROR)\n+            .checkContainsOutput(\"cannot combine with previous 'short' declaration specifier\");\n+    }\n+\n+    @Test\n+    public void testOutputClass() {\n+        Path helloOutput = getOutputFilePath(\"hellogen\");\n+        Path helloH = getInputFilePath(\"hello.h\");\n+        run(\"-d\", helloOutput.toString(), helloH.toString()).checkSuccess();\n+        try(Loader loader = classLoader(helloOutput)) {\n+            Class<?> cls = loader.loadClass(\"hello_h\");\n+            \/\/ check a method for \"void func(int)\"\n+            assertNotNull(findMethod(cls, \"func\", int.class));\n+            \/\/ check a method for \"int printf(MemoryAddress, Object[])\"\n+            assertNotNull(findMethod(cls, \"printf\", Addressable.class, Object[].class));\n+        } finally {\n+            deleteDir(helloOutput);\n+        }\n+    }\n+\n+    private void testTargetPackage(String targetPkgOption) {\n+        Path helloOutput = getOutputFilePath(\"hellogen\");\n+        Path helloH = getInputFilePath(\"hello.h\");\n+        run(targetPkgOption, \"com.acme\", \"-d\",\n+            helloOutput.toString(), helloH.toString()).checkSuccess();\n+        try(Loader loader = classLoader(helloOutput)) {\n+            Class<?> cls = loader.loadClass(\"com.acme.hello_h\");\n+            \/\/ check a method for \"void func(int)\"\n+            assertNotNull(findMethod(cls, \"func\", int.class));\n+            \/\/ check a method for \"int printf(MemoryAddress, Object[])\"\n+            assertNotNull(findMethod(cls, \"printf\", Addressable.class, Object[].class));\n+        } finally {\n+            deleteDir(helloOutput);\n+        }\n+    }\n+\n+    @Test\n+    public void testTargetPackageOption() {\n+        testTargetPackage(\"-t\");\n+    }\n+\n+    @Test\n+    public void testTargetPackageLongOption() {\n+        testTargetPackage(\"--target-package\");\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/JextractToolProviderTest.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -0,0 +1,297 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.spi.ToolProvider;\n+\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemoryLayout.PathElement;\n+import jdk.incubator.jextract.Type;\n+import jdk.test.lib.util.FileUtils;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+\n+public class JextractToolRunner {\n+\n+    \/\/ (private) exit codes from jextract tool. Copied from JextractTool.\n+    static final int SUCCESS       = 0;\n+    static final int OPTION_ERROR  = 1;\n+    static final int INPUT_ERROR   = 2;\n+    static final int CLANG_ERROR   = 3;\n+    static final int RUNTIME_ERROR = 4;\n+    static final int OUTPUT_ERROR  = 5;\n+\n+    private static String safeFileName(String filename) {\n+        int ext = filename.lastIndexOf('.');\n+        return ext != -1 ? filename.substring(0, ext) : filename;\n+    }\n+\n+    private static final ToolProvider JEXTRACT_TOOL = ToolProvider.findFirst(\"jextract\")\n+            .orElseThrow(() ->\n+                    new RuntimeException(\"jextract tool not found\")\n+            );\n+\n+    private final Path inputDir;\n+    private final Path outputDir;\n+\n+    protected JextractToolRunner() {\n+        this(null, null);\n+    }\n+\n+    protected JextractToolRunner(Path input, Path output) {\n+        inputDir = (input != null) ? input :\n+                Paths.get(System.getProperty(\"test.src\", \".\"));\n+        outputDir = (output != null) ? output :\n+                Paths.get(System.getProperty(\"test.classes\", \".\"));\n+    }\n+\n+    protected Path getInputFilePath(String fileName) {\n+        return inputDir.resolve(fileName).toAbsolutePath();\n+    }\n+\n+    protected Path getOutputFilePath(String fileName) {\n+        return outputDir.resolve(fileName).toAbsolutePath();\n+    }\n+\n+    protected static class JextractResult {\n+        private int exitCode;\n+        private String output;\n+\n+        JextractResult(int exitCode, String output) {\n+            this.exitCode = exitCode;\n+            this.output = output;\n+        }\n+\n+        protected JextractResult checkSuccess() {\n+            assertEquals(exitCode, SUCCESS, \"Sucess expected, failed: \" + exitCode);\n+            return this;\n+        }\n+\n+        protected JextractResult checkFailure() {\n+            assertNotEquals(exitCode, SUCCESS, \"Failure expected, succeeded!\");\n+            return this;\n+        }\n+\n+        protected JextractResult checkFailure(int expectedExitCode) {\n+            assertEquals(exitCode, expectedExitCode, \"Expected error code \" + expectedExitCode);\n+            return this;\n+        }\n+\n+        protected JextractResult checkContainsOutput(String expected) {\n+            Objects.requireNonNull(expected);\n+            assertTrue(output.contains(expected), \"Output does not contain string: \" + expected);\n+            return this;\n+        }\n+\n+        protected JextractResult checkMatchesOutput(String regex) {\n+            Objects.requireNonNull(regex);\n+            assertTrue(output.trim().matches(regex), \"Output does not match regex: \" + regex);\n+            return this;\n+        }\n+    }\n+\n+    protected static JextractResult run(Object... options) {\n+        return run(Arrays.stream(options).map(Objects::toString).toArray(String[]::new));\n+    }\n+\n+    protected static JextractResult run(String... options) {\n+        StringWriter writer = new StringWriter();\n+        PrintWriter pw = new PrintWriter(writer);\n+        String[] args = new String[options.length + 1];\n+        int result = JEXTRACT_TOOL.run(pw, pw, options);\n+        String output = writer.toString();\n+        System.err.println(output);\n+        return new JextractResult(result, output);\n+    }\n+\n+    protected static void deleteFile(Path path) {\n+        try {\n+            FileUtils.deleteFileIfExistsWithRetry(path);\n+        } catch (IOException ioExp) {\n+            throw new RuntimeException(ioExp);\n+        }\n+    }\n+\n+    protected static void deleteDir(Path path) {\n+        try {\n+            FileUtils.deleteFileTreeWithRetry(path);\n+        } catch (IOException ioExp) {\n+            throw new RuntimeException(ioExp);\n+        }\n+    }\n+\n+    protected static Loader classLoader(Path... paths) {\n+        try {\n+            URL[] urls = new URL[paths.length];\n+            for (int i = 0; i < paths.length; i++) {\n+                urls[i] = paths[i].toUri().toURL();\n+            }\n+            URLClassLoader ucl = new URLClassLoader(urls,\n+                    JextractToolRunner.class.getClassLoader());\n+            return new Loader(ucl);\n+        } catch (RuntimeException re) {\n+            throw re;\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    protected static Field findField(Class<?> cls, String name) {\n+        try {\n+            return cls.getField(name);\n+        } catch (Exception e) {\n+            System.err.println(e);\n+            return null;\n+        }\n+    }\n+\n+    protected Method checkIntGetter(Class<?> cls, String name, int value) {\n+        Method method = findMethod(cls, name);\n+        assertNotNull(method);\n+        assertEquals(method.getReturnType(), int.class);\n+        try {\n+            assertEquals((int)method.invoke(null), value);\n+        } catch (Exception exp) {\n+            System.err.println(exp);\n+            assertTrue(false, \"should not reach here\");\n+        }\n+        return method;\n+    }\n+\n+    protected static Method findMethod(Class<?> cls, String name, Class<?>... argTypes) {\n+        try {\n+            return cls.getMethod(name, argTypes);\n+        } catch (Exception e) {\n+            System.err.println(e);\n+            return null;\n+        }\n+    }\n+\n+    protected static Method findFirstMethod(Class<?> cls, String name) {\n+        try {\n+            for (Method m : cls.getMethods()) {\n+                if (name.equals(m.getName())) {\n+                    return m;\n+                }\n+            }\n+            return null;\n+        } catch (Exception e) {\n+            System.err.println(e);\n+            return null;\n+        }\n+    }\n+\n+    protected static Class<?> findNestedClass(Class<?> clz, String name) {\n+        return findClass(clz.getClasses(), name);\n+    }\n+\n+    protected static Class<?> findClass(Class<?>[] clz, String name) {\n+        for (Class<?> cls: clz) {\n+            if (cls.getSimpleName().equals(name)) {\n+                return cls;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    protected Method checkMethod(Class<?> cls, String name, MethodType type) {\n+        return checkMethod(cls, name, type.returnType(), type.parameterArray());\n+    }\n+\n+    protected Method checkMethod(Class<?> cls, String name, Class<?> returnType, Class<?>... args) {\n+        Method m = findMethod(cls, name, args);\n+        assertNotNull(m);\n+        assertEquals(m.getReturnType(), returnType);\n+        assertEquals(m.getParameterTypes(), args);\n+        return m;\n+    }\n+\n+    protected static MemoryLayout findLayout(Class<?> cls, String name) {\n+        Method method = findMethod(cls, name + \"$LAYOUT\");\n+        assertNotNull(method);\n+        assertEquals(method.getReturnType(), MemoryLayout.class);\n+        try {\n+            return (MemoryLayout)method.invoke(null);\n+        } catch (Exception exp) {\n+            System.err.println(exp);\n+            assertTrue(false, \"should not reach here\");\n+        }\n+        return null;\n+    }\n+\n+    protected static MemoryLayout findLayout(Class<?> cls) {\n+        return findLayout(cls, \"\");\n+    }\n+\n+    protected static void checkField(MemoryLayout group, String fieldName, MemoryLayout expected) {\n+        assertEquals(group.select(PathElement.groupElement(fieldName)), expected.withName(fieldName));\n+    }\n+\n+    protected static class Loader implements AutoCloseable {\n+\n+        private final URLClassLoader loader;\n+\n+        public Loader(URLClassLoader loader) {\n+            this.loader = loader;\n+        }\n+\n+        public Class<?> loadClass(String className) {\n+            try {\n+                return Class.forName(className, false, loader);\n+            } catch (ClassNotFoundException e) {\n+                \/\/ return null so caller can check if class loading\n+                \/\/ was successful with assertNotNull\/assertNull\n+                return null;\n+            }\n+        }\n+\n+        @Override\n+        public void close() {\n+            try {\n+                loader.close();\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/JextractToolRunner.java","additions":297,"deletions":0,"binary":false,"changes":297,"status":"added"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.File;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class JtregJextract {\n+    private final Path inputDir;\n+    private final Path outputDir;\n+\n+    JtregJextract() {\n+        this(null, null);\n+    }\n+\n+    JtregJextract(Path input, Path output) {\n+        inputDir = (input != null) ? input :\n+                Paths.get(System.getProperty(\"test.src\", \".\"));\n+        outputDir = (output != null) ? output :\n+                Paths.get(System.getProperty(\"test.classes\", \".\"));\n+\n+    }\n+\n+    protected String[] processArgs(String... args) {\n+        Pattern sysPropPattern = Pattern.compile(\"'?\\\\$\\\\((.*)\\\\)'?\");\n+        ArrayList<String> jextrOpts = new ArrayList<>();\n+\n+        jextrOpts.clear();\n+        jextrOpts.add(\"-C-nostdinc\");\n+        jextrOpts.add(\"-I\");\n+        jextrOpts.add(inputDir.toAbsolutePath().toString());\n+        jextrOpts.add(\"-d\");\n+        jextrOpts.add(outputDir.toAbsolutePath().toString());\n+\n+        int i = 0;\n+        while (i < args.length) {\n+            String opt = args[i++];\n+            if (\"--\".equals(opt)) {\n+                break;\n+            }\n+\n+            if (\"-libpath\".equals(opt)) {\n+                String lib = args[i];\n+                jextrOpts.add(\"-l\");\n+                String libpath = System.getProperty(\"test.nativepath\") + File.separator + System.mapLibraryName(lib);\n+                System.err.println(\"jextract driver libpath passed: \" + libpath);\n+                jextrOpts.add(libpath);\n+                i++;\n+                continue;\n+            }\n+\n+            if (\"-d\".equals(opt)) {\n+                i++;\n+                continue;\n+            }\n+            \/\/ Pattern $(system.property.name) is replaced with the\n+            \/\/ value of the System property of that name.\n+            Matcher m = sysPropPattern.matcher(opt);\n+            if (m.matches()) {\n+                jextrOpts.add(System.getProperty(m.group(1)));\n+            } else {\n+                jextrOpts.add(opt);\n+            }\n+        }\n+\n+        while (i < args.length) {\n+            jextrOpts.add(getInputFilePath(args[i++]).toString());\n+        }\n+\n+        return jextrOpts.toArray(String[]::new);\n+    }\n+\n+    protected int jextract(String... options) {\n+        String[] args = processArgs(options);\n+        String[] commands = new String[args.length + 1];\n+        commands[0] = Paths.get(System.getProperty(\"test.jdk\"), \"bin\", \"jextract\").toString();\n+        System.arraycopy(args, 0, commands, 1, args.length);\n+        try {\n+            Process proc = new ProcessBuilder(commands).inheritIO().start();\n+            int result = proc.waitFor();\n+            if (result != 0) {\n+                throw new RuntimeException(\"jextract returns non-zero value\");\n+            }\n+            return result;\n+        } catch (IOException ioExp) {\n+            throw new UncheckedIOException(ioExp);\n+        } catch (InterruptedException intExp) {\n+            throw new RuntimeException(intExp);\n+        }\n+    }\n+\n+    private Path getInputFilePath(String filename) {\n+        return inputDir.resolve(filename).toAbsolutePath();\n+    }\n+\n+    public static int main(String[] args) {\n+        JtregJextract jj =  new JtregJextract();\n+        return jj.jextract(args);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/JtregJextract.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.lang.reflect.Array;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class JtregJextractSources {\n+    private static Path getJextractSourcePath() {\n+        Path testSrc = Path.of(System.getProperty(\"test.file\"));\n+        return Path.of(testSrc.toFile().getName() + \"_sources\");\n+    }\n+\n+    public static int main(String[] args) throws IOException {\n+        System.err.println(\"jextract --source mode\");\n+        Path sourcePath = getJextractSourcePath();\n+        JtregJextract jj =  new JtregJextract(null, sourcePath);\n+        String[] newArgs = new String[args.length + 1];\n+        newArgs[0] = \"--source\";\n+        System.arraycopy(args, 0, newArgs, 1, args.length);\n+        jj.jextract(newArgs);\n+\n+        Path outputDir = Paths.get(System.getProperty(\"test.classes\", \".\"));\n+\n+        List<String> files = Files.find(sourcePath.toAbsolutePath(), 999, (path, ignored) -> path.toString().endsWith(\".java\"))\n+                .map(p -> p.toAbsolutePath().toString())\n+                .collect(Collectors.toList());\n+\n+        System.err.println(\"compiling jextracted sources @ \" + sourcePath.toAbsolutePath());\n+        List<String> commands = new ArrayList<>();\n+        commands.add(Paths.get(System.getProperty(\"test.jdk\"), \"bin\", \"javac\").toString());\n+        commands.add(\"--add-modules\");\n+        commands.add(\"jdk.incubator.foreign\");\n+        commands.add(\"-d\");\n+        commands.add(outputDir.toAbsolutePath().toString());\n+        commands.addAll(files);\n+\n+        try {\n+            Process proc = new ProcessBuilder(commands).inheritIO().start();\n+            int result = proc.waitFor();\n+            if (result != 0) {\n+                throw new RuntimeException(\"javac returns non-zero value: \" + result);\n+            }\n+            return result;\n+        } catch (IOException ioExp) {\n+            throw new UncheckedIOException(ioExp);\n+        } catch (InterruptedException intExp) {\n+            throw new RuntimeException(intExp);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/JtregJextractSources.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import org.testng.annotations.Test;\n+\n+import java.nio.file.Path;\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8240300\n+ * @summary jextract produces non compilable code with repeated declarations\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @run testng\/othervm -Dforeign.restricted=permit RepeatedDeclsTest\n+ *\/\n+public class RepeatedDeclsTest extends JextractToolRunner {\n+    @Test\n+    public void repeatedDecls() throws Throwable {\n+        Path repeatedDeclsOutput = getOutputFilePath(\"repeatedDeclsgen\");\n+        Path repeatedDeclsH = getInputFilePath(\"repeatedDecls.h\");\n+        run(\"-d\", repeatedDeclsOutput.toString(), repeatedDeclsH.toString()).checkSuccess();\n+        try(Loader loader = classLoader(repeatedDeclsOutput)) {\n+            Class<?> cls = loader.loadClass(\"repeatedDecls_h\");\n+            \/\/ check a method for \"void func(int)\"\n+            assertNotNull(findMethod(cls, \"func\", int.class));\n+\n+            \/\/ check a method for \"void func2(int)\"\n+            assertNotNull(findMethod(cls, \"func2\", int.class));\n+\n+            \/\/ check a method for \"void func3(int*)\"\n+            assertNotNull(findMethod(cls, \"func3\", Addressable.class));\n+\n+            \/\/ check a method for \"void func4(int*)\"\n+            assertNotNull(findMethod(cls, \"func4\", Addressable.class));\n+\n+            \/\/ check a method for \"void func5(int)\"\n+            assertNotNull(findMethod(cls, \"func5\", int.class));\n+\n+            \/\/ check a method for \"double distance(struct Point)\"\n+            assertNotNull(findMethod(cls, \"distance\", MemorySegment.class));\n+\n+            \/\/ check a getter method for \"i\"\n+            assertNotNull(findMethod(cls, \"i$get\"));\n+\n+            \/\/ check a setter method for \"i\"\n+            assertNotNull(findMethod(cls, \"i$set\", int.class));\n+\n+            \/\/ make sure that enum constants are generated fine\n+            checkIntGetter(cls, \"R\", 0);\n+            checkIntGetter(cls, \"G\", 1);\n+            checkIntGetter(cls, \"B\", 2);\n+            checkIntGetter(cls, \"C\", 0);\n+            checkIntGetter(cls, \"M\", 1);\n+            checkIntGetter(cls, \"Y\", 2);\n+\n+            \/\/ check Point layout\n+            Class<?> pointCls = loader.loadClass(\"repeatedDecls_h$Point\");\n+            checkPoint(pointCls);\n+            Class<?> point_tCls = loader.loadClass(\"repeatedDecls_h$Point_t\");\n+            checkPoint(point_tCls);\n+            assertTrue(pointCls.isAssignableFrom(point_tCls));\n+            Class<?> point$0Cls = loader.loadClass(\"repeatedDecls_h$POINT$0\");\n+            checkPoint(point$0Cls);\n+            assertTrue(pointCls.isAssignableFrom(point$0Cls));\n+\n+            \/\/ check Point3D layout\n+            Class<?> point3DCls = loader.loadClass(\"repeatedDecls_h$Point3D\");\n+            checkPoint3D(point3DCls);\n+            Class<?> point3D_tCls = loader.loadClass(\"repeatedDecls_h$Point3D_t\");\n+            checkPoint3D(point3D_tCls);\n+            assertTrue(point3DCls.isAssignableFrom(point3D_tCls));\n+        } finally {\n+            deleteDir(repeatedDeclsOutput);\n+        }\n+    }\n+\n+    private void checkPoint(Class<?> pointCls) {\n+        MemoryLayout pointLayout = findLayout(pointCls);\n+        assertNotNull(pointLayout);\n+        assertTrue(((GroupLayout)pointLayout).isStruct());\n+        checkField(pointLayout, \"i\", CLinker.C_INT);\n+        checkField(pointLayout, \"j\", CLinker.C_INT);\n+    }\n+\n+    private void checkPoint3D(Class<?> point3DCls) {\n+        MemoryLayout point3DLayout = findLayout(point3DCls);\n+        assertNotNull(point3DLayout);\n+        assertTrue(((GroupLayout)point3DLayout).isStruct());\n+        checkField(point3DLayout, \"i\", CLinker.C_INT);\n+        checkField(point3DLayout, \"j\", CLinker.C_INT);\n+        checkField(point3DLayout, \"k\", CLinker.C_INT);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/RepeatedDeclsTest.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8240181\n+ * @run testng\/othervm -Dforeign.restricted=permit -Duser.language=en --add-modules jdk.incubator.jextract Test8240181\n+ *\/\n+public class Test8240181 extends JextractToolRunner {\n+    @Test\n+    public void testAnonymousEnum() {\n+        Path anonenumOutput = getOutputFilePath(\"anonenumgen\");\n+        Path anonenumH = getInputFilePath(\"anonenum.h\");\n+        run(\"-d\", anonenumOutput.toString(), anonenumH.toString()).checkSuccess();\n+        try(Loader loader = classLoader(anonenumOutput)) {\n+            Class<?> cls = loader.loadClass(\"anonenum_h\");\n+            checkIntGetter(cls, \"RED\", 0xff0000);\n+            checkIntGetter(cls, \"GREEN\", 0x00ff00);\n+            checkIntGetter(cls, \"BLUE\", 0x0000ff);\n+            checkIntGetter(cls, \"Java\", 0);\n+            checkIntGetter(cls, \"C\", 1);\n+            checkIntGetter(cls, \"CPP\", 2);\n+            checkIntGetter(cls, \"Python\", 3);\n+            checkIntGetter(cls, \"Ruby\", 4);\n+            checkIntGetter(cls, \"ONE\", 1);\n+            checkIntGetter(cls, \"TWO\", 2);\n+        } finally {\n+            deleteDir(anonenumOutput);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8240181.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8240657\n+ * @summary when Java keywords are used as identifiers in C header, jextract generates non-compilable java code\n+ * @run testng\/othervm -Dforeign.restricted=permit Test8240657\n+ *\/\n+public class Test8240657 extends JextractToolRunner {\n+    @Test\n+    public void testKeywordIdentifiers() {\n+        Path exportsOutput = getOutputFilePath(\"exportsgen\");\n+        Path exportsH = getInputFilePath(\"exports.h\");\n+        run(\"-d\", exportsOutput.toString(), exportsH.toString()).checkSuccess();\n+        try(Loader loader = classLoader(exportsOutput)) {\n+            Class<?> cls = loader.loadClass(\"exports_h\");\n+            assertNotNull(cls);\n+        } finally {\n+            deleteDir(exportsOutput);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8240657.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.nio.file.Path;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8240752\n+ * @summary jextract generates non-compilable code for special floating point values\n+ * @run testng\/othervm -Dforeign.restricted=permit Test8240752\n+ *\/\n+public class Test8240752 extends JextractToolRunner {\n+    private float getFloatConstant(Class<?> cls, String name) {\n+        Method method = findMethod(cls, name);\n+        assertNotNull(method);\n+        assertEquals(method.getReturnType(), float.class);\n+        try {\n+            return (float)method.invoke(null);\n+        } catch (Exception exp) {\n+            System.err.println(exp);\n+            assertTrue(false, \"should not reach here\");\n+        }\n+        return 0.0f;\n+    }\n+\n+    private double getDoubleConstant(Class<?> cls, String name) {\n+        Method method = findMethod(cls, name);\n+        assertNotNull(method);\n+        assertEquals(method.getReturnType(), double.class);\n+        try {\n+            return (double)method.invoke(null);\n+        } catch (Exception exp) {\n+            System.err.println(exp);\n+            assertTrue(false, \"should not reach here\");\n+        }\n+        return 0.0d;\n+    }\n+\n+    @Test\n+    public void testConstants() {\n+        Path floatConstsOutput = getOutputFilePath(\"floatconstsgen\");\n+        Path floatConstsH = getInputFilePath(\"float_constants.h\");\n+        run(\"-d\", floatConstsOutput.toString(), floatConstsH.toString()).checkSuccess();\n+        try(Loader loader = classLoader(floatConstsOutput)) {\n+            Class<?> cls = loader.loadClass(\"float_constants_h\");\n+            assertNotNull(cls);\n+\n+            double d = getDoubleConstant(cls, \"NAN\");\n+            assertTrue(Double.isNaN(d));\n+            d = getDoubleConstant(cls, \"PINFINITY\");\n+            assertTrue(Double.isInfinite(d) && d > 0);\n+            d = getDoubleConstant(cls, \"NINFINITY\");\n+            assertTrue(Double.isInfinite(d) && d < 0);\n+\n+            float f = getFloatConstant(cls, \"NANF\");\n+            assertTrue(Float.isNaN(f));\n+            f = getFloatConstant(cls, \"PINFINITYF\");\n+            assertTrue(Float.isInfinite(f) && f > 0);\n+            f = getFloatConstant(cls, \"NINFINITYF\");\n+            assertTrue(Float.isInfinite(f) && f < 0);\n+        } finally {\n+            deleteDir(floatConstsOutput);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8240752.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryLayout;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8240811\n+ * @summary jextract generates non-compilable code for name collision between a struct and a global variable\n+ * @run testng\/othervm -Dforeign.restricted=permit Test8240811\n+ *\/\n+public class Test8240811 extends JextractToolRunner {\n+    @Test\n+    public void testNameCollision() {\n+        Path nameCollisionOutput = getOutputFilePath(\"name_collision_gen\");\n+        Path nameCollisionH = getInputFilePath(\"name_collision.h\");\n+        run(\"-d\", nameCollisionOutput.toString(), nameCollisionH.toString()).checkSuccess();\n+        try(Loader loader = classLoader(nameCollisionOutput)) {\n+            Class<?> cls = loader.loadClass(\"name_collision_h\");\n+            assertNotNull(cls);\n+\n+            \/\/ check foo layout\n+            Class<?> fooCls = loader.loadClass(\"name_collision_h$foo\");\n+            MemoryLayout fooLayout = findLayout(fooCls);\n+            assertNotNull(fooLayout);\n+            assertTrue(((GroupLayout)fooLayout).isStruct());\n+            checkField(fooLayout, \"x\",  CLinker.C_INT);\n+            checkField(fooLayout, \"y\",  CLinker.C_INT);\n+            checkField(fooLayout, \"z\",  CLinker.C_INT);\n+\n+            MemoryLayout fooVarLayout = findLayout(cls, \"foo\");\n+            assertNotNull(fooVarLayout);\n+\n+            \/\/ check foo2 layout\n+            Class<?> foo2Cls = loader.loadClass(\"name_collision_h$foo2\");\n+            MemoryLayout foo2Layout = findLayout(foo2Cls);\n+            assertNotNull(foo2Layout);\n+            assertTrue(((GroupLayout)foo2Layout).isUnion());\n+            checkField(foo2Layout, \"i\",  CLinker.C_INT);\n+            checkField(foo2Layout, \"l\",  CLinker.C_LONG);\n+\n+            MemoryLayout foo2VarLayout = findLayout(cls, \"foo2\");\n+            assertNotNull(foo2VarLayout);\n+\n+            MemoryLayout barVarLayout = findLayout(cls, \"bar\");\n+            assertNotNull(barVarLayout);\n+\n+            \/\/ check bar layout\n+            Class<?> barCls = loader.loadClass(\"name_collision_h$bar\");\n+            MemoryLayout barLayout = findLayout(barCls);\n+            assertNotNull(barLayout);\n+            assertTrue(((GroupLayout)barLayout).isStruct());\n+            checkField(barLayout, \"f1\",  CLinker.C_FLOAT);\n+            checkField(barLayout, \"f2\",  CLinker.C_FLOAT);\n+\n+            MemoryLayout bar2VarLayout = findLayout(cls, \"bar2\");\n+            assertNotNull(bar2VarLayout);\n+\n+            \/\/ check bar layout\n+            Class<?> bar2Cls = loader.loadClass(\"name_collision_h$bar2\");\n+            MemoryLayout bar2Layout = findLayout(bar2Cls);\n+            assertNotNull(bar2Layout);\n+            assertTrue(((GroupLayout)bar2Layout).isUnion());\n+            checkField(bar2Layout, \"f\",  CLinker.C_FLOAT);\n+            checkField(bar2Layout, \"d\",  CLinker.C_DOUBLE);\n+        } finally {\n+            deleteDir(nameCollisionOutput);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8240811.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.jextract.Declaration;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @bug 8241650\n+ * @summary jextract module should be mapped to application class loader\n+ * @run testng Test8241650\n+ *\/\n+public class Test8241650 {\n+    @Test\n+    public void testClassLoader() {\n+        assertTrue(ClassLoader.getSystemClassLoader() == Declaration.class.getClassLoader());\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8241650.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8244412\n+ * @summary jextract should generate static utils class for primitive typedefs\n+ * @run testng\/othervm -Dforeign.restricted=permit Test8244412\n+ *\/\n+public class Test8244412 extends JextractToolRunner {\n+    @Test\n+    public void testPrimitiveTypedefs() {\n+        Path typedefsOutput = getOutputFilePath(\"typedefsgen\");\n+        Path typedefsH = getInputFilePath(\"typedefs.h\");\n+        run(\"-d\", typedefsOutput.toString(), typedefsH.toString()).checkSuccess();\n+        try(Loader loader = classLoader(typedefsOutput)) {\n+            Class<?> headerCls = loader.loadClass(\"typedefs_h\");\n+            assertNotNull(findField(headerCls, \"byte_t\"));\n+            assertNotNull(findField(headerCls, \"mysize_t\"));\n+        } finally {\n+            deleteDir(typedefsOutput);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8244412.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.Method;\n+import java.nio.file.Path;\n+import jdk.incubator.foreign.NativeScope;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertNull;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8245767\n+ * @summary jextract crashes with typedef on a opaque struct or union\n+ * @run testng\/othervm -Dforeign.restricted=permit Test8245767\n+ *\/\n+public class Test8245767 extends JextractToolRunner {\n+    @Test\n+    public void testTypedefs() {\n+        Path test8245767Output = getOutputFilePath(\"test8245767_gen\");\n+        Path test8245767H = getInputFilePath(\"test8245767.h\");\n+        run(\"-d\", test8245767Output.toString(), test8245767H.toString()).checkSuccess();\n+        try(Loader loader = classLoader(test8245767Output)) {\n+            Class<?> cls = loader.loadClass(\"test8245767_h\");\n+            assertNotNull(cls);\n+\n+            \/\/ class should be generated for typedef on opaque struct\n+            Class<?> fooCls = loader.loadClass(\"test8245767_h$Foo\");\n+            assertNotNull(fooCls);\n+            Method alloc = findMethod(fooCls, \"allocatePointer\");\n+            assertNotNull(alloc);\n+            alloc = findMethod(fooCls, \"allocatePointer\", NativeScope.class);\n+            assertNotNull(alloc);\n+\n+            \/\/ check Point_t\n+            Class<?> point_tCls = loader.loadClass(\"test8245767_h$Point_t\");\n+            assertNotNull(point_tCls);\n+\n+            \/\/ check Point\n+            Class<?> pointCls = loader.loadClass(\"test8245767_h$Point\");\n+            assertNotNull(pointCls);\n+            assertTrue(pointCls.isAssignableFrom(point_tCls));\n+        } finally {\n+            deleteDir(test8245767Output);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8245767.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @modules jdk.incubator.jextract\n+ * @build JextractToolRunner\n+ * @bug 8248415\n+ * @summary jextract does not generate getter and setter for pointer typed fields in structs\n+ * @run testng\/othervm -Dforeign.restricted=permit Test8248415\n+ *\/\n+public class Test8248415 extends JextractToolRunner {\n+\n+    @Test\n+    public void testPointerFields() {\n+        Path outputPath = getOutputFilePath(\"output\");\n+        Path headerFile = getInputFilePath(\"test8248415.h\");\n+        run(\"-d\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        try(Loader loader = classLoader(outputPath)) {\n+            Class<?> nodeClass = loader.loadClass(\"test8248415_h$Node\");\n+\n+            \/\/ Check if getters for pointer fields were generated\n+            checkMethod(nodeClass, \"next$get\", MemoryAddress.class, MemorySegment.class);\n+            checkMethod(nodeClass, \"next$get\", MemoryAddress.class, MemorySegment.class, long.class);\n+\n+            \/\/ Check if setters for pointer fields were generated\n+            checkMethod(nodeClass, \"next$set\", void.class, MemorySegment.class, MemoryAddress.class);\n+            checkMethod(nodeClass, \"next$set\", void.class, MemorySegment.class, long.class, MemoryAddress.class);\n+        } finally {\n+            deleteDir(outputPath);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8248415.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8248474\n+ * @summary jextract uses header file name as part of identifier\n+ * @run testng\/othervm -Dforeign.restricted=permit Test8248474\n+ *\/\n+public class Test8248474 extends JextractToolRunner {\n+    @Test\n+    public void testUnsafeHeaderName() {\n+        Path test8248474Output = getOutputFilePath(\"test8248474_gen\");\n+        Path test8248474H = getInputFilePath(\"JDK-8248474.h\");\n+        run(\"-d\", test8248474Output.toString(), test8248474H.toString()).checkSuccess();\n+        try(Loader loader = classLoader(test8248474Output)) {\n+            Class<?> cls = loader.loadClass(\"JDK_8248474_h\");\n+            assertNotNull(cls);\n+        } finally {\n+            deleteDir(test8248474Output);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8248474.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+\n+import jdk.incubator.foreign.Addressable;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @modules jdk.incubator.jextract\n+ * @build JextractToolRunner\n+ * @bug 8249290\n+ * @summary jextract does not handle void typedef in function pointer argument\n+ * @run testng\/othervm -Dforeign.restricted=permit Test8249290\n+ *\/\n+public class Test8249290 extends JextractToolRunner {\n+    @Test\n+    public void testVoidTypedef() {\n+        Path outputPath = getOutputFilePath(\"output8249290\");\n+        Path headerFile = getInputFilePath(\"test8249290.h\");\n+        run(\"-d\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        try(Loader loader = classLoader(outputPath)) {\n+            Class<?> headerClass = loader.loadClass(\"test8249290_h\");\n+            checkMethod(headerClass, \"func\", void.class, Addressable.class);\n+            Class<?> fiClass = loader.loadClass(\"test8249290_h$func$f\");\n+            checkMethod(fiClass, \"apply\", void.class);\n+        } finally {\n+            deleteDir(outputPath);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8249290.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+\n+import jdk.incubator.foreign.Addressable;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @modules jdk.incubator.jextract\n+ * @build JextractToolRunner\n+ * @bug 8249300\n+ * @summary jextract does not handle empty parameter list of a function pointer parameters\n+ * @run testng\/othervm -Dforeign.restricted=permit Test8249300\n+ *\/\n+public class Test8249300 extends JextractToolRunner {\n+    @Test\n+    public void testVoidTypedef() {\n+        Path outputPath = getOutputFilePath(\"output8249300\");\n+        Path headerFile = getInputFilePath(\"test8249300.h\");\n+        run(\"-d\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        try(Loader loader = classLoader(outputPath)) {\n+            Class<?> headerClass = loader.loadClass(\"test8249300_h\");\n+            checkMethod(headerClass, \"func\", void.class, Addressable.class);\n+            Class<?> fiClass = loader.loadClass(\"test8249300_h$func$f\");\n+            checkMethod(fiClass, \"apply\", void.class);\n+        } finally {\n+            deleteDir(outputPath);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8249300.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertNull;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @modules jdk.incubator.jextract\n+ * @build JextractToolRunner\n+ * @bug 8251943\n+ * @summary jextract should not generate MemorySegment typed fields for variables, struct fields if layout size info is not available\n+ * @run testng\/othervm -Dforeign.restricted=permit Test8251943\n+ *\/\n+public class Test8251943 extends JextractToolRunner {\n+\n+    @Test\n+    public void test() {\n+        Path outputPath = getOutputFilePath(\"output\");\n+        Path headerFile = getInputFilePath(\"test8251943.h\");\n+        run(\"-d\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        try(Loader loader = classLoader(outputPath)) {\n+            Class<?> headerClass = loader.loadClass(\"test8251943_h\");\n+            assertNull(findMethod(headerClass, \"tzname$SEGMENT\"));\n+\n+            Class<?> fooClass = loader.loadClass(\"test8251943_h$Foo\");\n+            assertNotNull(findMethod(fooClass, \"bar$get\", MemorySegment.class));\n+            assertNull(findMethod(fooClass, \"names$get\", MemorySegment.class));\n+        } finally {\n+            deleteDir(outputPath);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8251943.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8258223\n+ * @summary jextract throws exception when unsupport type is used in anonymous struct\n+ * @run testng\/othervm -Dforeign.restricted=permit Test8258223\n+ *\/\n+public class Test8258223 extends JextractToolRunner {\n+    @Test\n+    public void test() {\n+        Path test8258223Output = getOutputFilePath(\"test8258223_gen\");\n+        Path test8258223H = getInputFilePath(\"test8258223.h\");\n+        run(\"-d\", test8258223Output.toString(), test8258223H.toString()).checkSuccess();\n+        try(Loader loader = classLoader(test8258223Output)) {\n+            Class<?> cls = loader.loadClass(\"test8258223_h\");\n+            assertNotNull(cls);\n+        } finally {\n+            deleteDir(test8258223Output);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8258223.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8258405\n+ * @summary functional interfaces are not generated for struct fields\/global variables with function pointers\n+ * @run testng\/othervm -Dforeign.restricted=permit Test8258405\n+ *\/\n+public class Test8258405 extends JextractToolRunner {\n+    @Test\n+    public void test() {\n+        Path test8258405Output = getOutputFilePath(\"test8258405_gen\");\n+        Path test8258405H = getInputFilePath(\"test8258405.h\");\n+        run(\"-d\", test8258405Output.toString(), test8258405H.toString()).checkSuccess();\n+        try(Loader loader = classLoader(test8258405Output)) {\n+            Class<?> cls = loader.loadClass(\"test8258405_h\");\n+            assertNotNull(cls);\n+            \/\/ check global function pointer variable 'func'\n+            cls = loader.loadClass(\"test8258405_h$func\");\n+            assertNotNull(cls);\n+            assertNotNull(findMethod(cls, \"apply\", int.class));\n+            \/\/ check function pointer member 'bar' of struct 'Foo'\n+            cls = loader.loadClass(\"test8258405_h$Foo$bar\");\n+            assertNotNull(cls);\n+            assertNotNull(findMethod(cls, \"apply\", float.class, double.class));\n+        } finally {\n+            deleteDir(test8258405Output);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8258405.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8260344\n+ * @summary jextract crashes with exception for log.h from libdebian-installer4-dev\n+ * @run testng\/othervm -Dforeign.restricted=permit -Duser.language=en --add-modules jdk.incubator.jextract Test8260344\n+ *\/\n+public class Test8260344 extends JextractToolRunner {\n+    @Test\n+    public void test() {\n+        Path test8260344Output = getOutputFilePath(\"test8260344gen\");\n+        try {\n+            Path test8260344H = getInputFilePath(\"test8260344.h\");\n+            run(\"-d\", test8260344Output.toString(), test8260344H.toString()).checkSuccess();\n+        } finally {\n+            deleteDir(test8260344Output);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8260344.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.Method;\n+import java.nio.file.Path;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @modules jdk.incubator.jextract\n+ * @build JextractToolRunner\n+ * @bug 8260705\n+ * @summary jextract crash with libbart's types.h\n+ * @run testng\/othervm -Dforeign.restricted=permit Test8260705\n+ *\/\n+public class Test8260705 extends JextractToolRunner {\n+    @Test\n+    public void test() {\n+        Path outputPath = getOutputFilePath(\"output\");\n+        Path headerFile = getInputFilePath(\"test8260705.h\");\n+        run(\"-d\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        try(Loader loader = classLoader(outputPath)) {\n+            Class<?> FooClass = loader.loadClass(\"test8260705_h$Foo\");\n+            checkMethod(FooClass, \"c$get\", byte.class, MemorySegment.class);\n+            checkMethod(FooClass, \"c$get\", byte.class, MemorySegment.class, long.class);\n+            checkMethod(FooClass, \"c$set\", void.class, MemorySegment.class, byte.class);\n+            checkMethod(FooClass, \"c$set\", void.class, MemorySegment.class, long.class, byte.class);\n+\n+            Class<?> Foo2Class = loader.loadClass(\"test8260705_h$Foo2\");\n+            checkMethod(Foo2Class, \"z$get\", int.class, MemorySegment.class);\n+            checkMethod(Foo2Class, \"z$get\", int.class, MemorySegment.class, long.class);\n+            checkMethod(Foo2Class, \"z$set\", void.class, MemorySegment.class, int.class);\n+            checkMethod(Foo2Class, \"z$set\", void.class, MemorySegment.class, long.class, int.class);\n+            checkMethod(Foo2Class, \"w$get\", int.class, MemorySegment.class);\n+            checkMethod(Foo2Class, \"w$get\", int.class, MemorySegment.class, long.class);\n+            checkMethod(Foo2Class, \"w$set\", void.class, MemorySegment.class, int.class);\n+            checkMethod(Foo2Class, \"w$set\", void.class, MemorySegment.class, long.class, int.class);\n+\n+            assertNotNull(loader.loadClass(\"test8260705_h$Foo3\"));\n+\n+            Class<?> Foo4Class = loader.loadClass(\"test8260705_h$Foo4\");\n+            assertTrue(sizeof(Foo4Class) == 8L);\n+\n+            Class<?> Foo5Class = loader.loadClass(\"test8260705_h$Foo5\");\n+            assertTrue(sizeof(Foo5Class) == 4L);\n+\n+        } finally {\n+            deleteDir(outputPath);\n+        }\n+    }\n+\n+    private long sizeof(Class<?> cls) {\n+        Method m = findMethod(cls, \"sizeof\");\n+        try {\n+            return (long)m.invoke(null);\n+        } catch (Exception ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/tools\/jextract\/Test8260705.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @modules jdk.incubator.jextract\n+ * @build JextractToolRunner\n+ * @bug 8260717\n+ * @summary jextract crashes with 'Crossing storage unit boundaries' for libcoap's block.h\n+ * @run testng\/othervm -Dforeign.restricted=permit Test8260717\n+ *\/\n+public class Test8260717 extends JextractToolRunner {\n+    @Test\n+    public void test() {\n+        Path outputPath = getOutputFilePath(\"output\");\n+        Path headerFile = getInputFilePath(\"test8260717.h\");\n+        run(\"-d\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        try(Loader loader = classLoader(outputPath)) {\n+            Class<?> FooClass = loader.loadClass(\"test8260717_h$foo_t\");\n+            checkMethod(FooClass, \"s$get\", short.class, MemorySegment.class);\n+            checkMethod(FooClass, \"s$get\", short.class, MemorySegment.class, long.class);\n+            checkMethod(FooClass, \"s$set\", void.class, MemorySegment.class, short.class);\n+            checkMethod(FooClass, \"s$set\", void.class, MemorySegment.class, long.class, short.class);\n+\n+            checkMethod(FooClass, \"ptr$get\", MemoryAddress.class, MemorySegment.class);\n+            checkMethod(FooClass, \"ptr$get\", MemoryAddress.class, MemorySegment.class, long.class);\n+            checkMethod(FooClass, \"ptr$set\", void.class, MemorySegment.class, MemoryAddress.class);\n+            checkMethod(FooClass, \"ptr$set\", void.class, MemorySegment.class, long.class, MemoryAddress.class);\n+\n+        } finally {\n+            deleteDir(outputPath);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8260717.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import org.testng.annotations.Test;\n+import jdk.incubator.foreign.MemorySegment;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @modules jdk.incubator.jextract\n+ * @build JextractToolRunner\n+ * @bug 8260929\n+ * @summary jextract crashes with libdnet's rabdef.h\n+ * @run testng\/othervm -Dforeign.restricted=permit Test8260929\n+ *\/\n+public class Test8260929 extends JextractToolRunner {\n+    @Test\n+    public void test() {\n+        Path outputPath = getOutputFilePath(\"output\");\n+        Path headerFile = getInputFilePath(\"test8260929.h\");\n+        run(\"-d\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        try(Loader loader = classLoader(outputPath)) {\n+            assertNotNull(loader.loadClass(\"test8260929_h$rab\"));\n+            Class<?> rab2Class = loader.loadClass(\"test8260929_h$rab2\");\n+            assertNotNull(rab2Class);\n+\n+            checkMethod(rab2Class, \"y$get\", int.class, MemorySegment.class);\n+            checkMethod(rab2Class, \"y$get\", int.class, MemorySegment.class, long.class);\n+            checkMethod(rab2Class, \"y$set\", void.class, MemorySegment.class, int.class);\n+            checkMethod(rab2Class, \"y$set\", void.class, MemorySegment.class, long.class, int.class);\n+\n+            checkMethod(rab2Class, \"x$get\", short.class, MemorySegment.class);\n+            checkMethod(rab2Class, \"x$get\", short.class, MemorySegment.class, long.class);\n+            checkMethod(rab2Class, \"x$set\", void.class, MemorySegment.class, short.class);\n+            checkMethod(rab2Class, \"x$set\", void.class, MemorySegment.class, long.class, short.class);\n+        } finally {\n+            deleteDir(outputPath);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8260929.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8261893\n+ * @summary jextract generates class names that are restricted type names\n+ * @run testng\/othervm -Dforeign.restricted=permit -Duser.language=en --add-modules jdk.incubator.jextract Test8261893\n+ *\/\n+public class Test8261893 extends JextractToolRunner {\n+    @Test\n+    public void test() {\n+        Path test8261893Output = getOutputFilePath(\"test8261893gen\");\n+        Path test8261893H = getInputFilePath(\"test8261893.h\");\n+        run(\"-d\", test8261893Output.toString(), test8261893H.toString()).checkSuccess();\n+        try(Loader loader = classLoader(test8261893Output)) {\n+            assertNotNull(loader.loadClass(\"test8261893_h$permits_\"));\n+            assertNotNull(loader.loadClass(\"test8261893_h$record_\"));\n+            assertNotNull(loader.loadClass(\"test8261893_h$sealed_\"));\n+            assertNotNull(loader.loadClass(\"test8261893_h$var_\"));\n+            assertNotNull(loader.loadClass(\"test8261893_h$yield_\"));\n+        } finally {\n+            deleteDir(test8261893Output);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8261893.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.Method;\n+import java.nio.file.Path;\n+import jdk.incubator.foreign.NativeScope;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertNull;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8262117\n+ * @summary jextract crashes with javac compilation error \"class u is already defined\"\n+ * @run testng\/othervm -Dforeign.restricted=permit Test8262117\n+ *\/\n+public class Test8262117 extends JextractToolRunner {\n+    @Test\n+    public void testNameClash() {\n+        Path test8262117Output = getOutputFilePath(\"test8262117_gen\");\n+        Path test8262117H = getInputFilePath(\"test8262117.h\");\n+        run(\"-d\", test8262117Output.toString(), test8262117H.toString()).checkSuccess();\n+        try(Loader loader = classLoader(test8262117Output)) {\n+            Class<?> cls = loader.loadClass(\"test8262117_h\");\n+            assertNotNull(cls);\n+\n+            assertNotNull(loader.loadClass(\"test8262117_h$u\"));\n+            assertNotNull(loader.loadClass(\"test8262117_h$u$outer$u$0\"));\n+            assertNotNull(loader.loadClass(\"test8262117_h$v\"));\n+            assertNotNull(loader.loadClass(\"test8262117_h$v$v$0\"));\n+        } finally {\n+            deleteDir(test8262117Output);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8262117.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import java.nio.file.Path;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8262733\n+ * @summary jextract generates clashing names which results in compilation error with javac\n+ * @run testng\/othervm -Dforeign.restricted=permit Test8262733\n+ *\/\n+public class Test8262733 extends JextractToolRunner {\n+    @Test\n+    public void test() {\n+        Path output = getOutputFilePath(\"8262733gen\");\n+        Path outputH = getInputFilePath(\"test8262733.h\");\n+        run(\"-d\", output.toString(), outputH.toString()).checkSuccess();\n+        try(Loader loader = classLoader(output)) {\n+            Class<?> cls = loader.loadClass(\"test8262733_h\");\n+            assertNotNull(cls);\n+        } finally {\n+            deleteDir(output);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8262733.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import java.nio.file.Path;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8262825\n+ * @summary jextract crashes when Java type names like String are used as identifiers in C heade\n+ * @run testng\/othervm -Dforeign.restricted=permit Test8262825\n+ *\/\n+public class Test8262825 extends JextractToolRunner {\n+    @Test\n+    public void test() {\n+        Path output = getOutputFilePath(\"8262825gen\");\n+        Path outputH = getInputFilePath(\"test8262825.h\");\n+        run(\"-d\", output.toString(), outputH.toString()).checkSuccess();\n+        try(Loader loader = classLoader(output)) {\n+            Class<?> cls = loader.loadClass(\"test8262825_h\");\n+            assertNotNull(cls);\n+\n+            assertNotNull(findField(cls, \"MemoryLayout_\"));\n+            assertNotNull(findField(cls, \"ValueLayout_\"));\n+\n+            assertNotNull(loader.loadClass(\"test8262825_h$RuntimeHelper_\"));\n+            assertNotNull(loader.loadClass(\"test8262825_h$String_\"));\n+            assertNotNull(loader.loadClass(\"test8262825_h$MemoryAddress_\"));\n+            assertNotNull(loader.loadClass(\"test8262825_h$MemorySegment_\"));\n+        } finally {\n+            deleteDir(output);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8262825.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import java.nio.file.Path;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8262851\n+ * @summary jextract crashes with \"Cannot compute size of a layout which is, or depends on a sequence layout with unspecified size\"\n+ * @run testng\/othervm -Dforeign.restricted=permit Test8262851\n+ *\/\n+public class Test8262851 extends JextractToolRunner {\n+    @Test\n+    public void test() {\n+        Path output = getOutputFilePath(\"8262851gen\");\n+        Path outputH = getInputFilePath(\"test8262851.h\");\n+        run(\"-d\", output.toString(), outputH.toString()).checkSuccess();\n+        try(Loader loader = classLoader(output)) {\n+            assertNotNull(loader.loadClass(\"test8262851_h\"));\n+            assertNotNull(loader.loadClass(\"test8262851_h$Odd\"));\n+            assertNotNull(loader.loadClass(\"test8262851_h$Odd$before\"));\n+            assertNotNull(loader.loadClass(\"test8262851_h$Odd$after\"));\n+        } finally {\n+            deleteDir(output);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8262851.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,183 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.nio.file.Path;\n+import java.util.function.BiConsumer;\n+\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import org.testng.annotations.Test;\n+\n+import static jdk.incubator.foreign.MemoryLayout.PathElement.groupElement;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.fail;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8244512 8252759\n+ * @summary test nested structs and unions\n+ * @run testng\/othervm -Dforeign.restricted=permit TestNested\n+ *\/\n+public class TestNested extends JextractToolRunner {\n+    @Test\n+    public void testNestedStructs() {\n+        Path nestedOutput = getOutputFilePath(\"nestedgen\");\n+        Path nestedH = getInputFilePath(\"nested.h\");\n+        run(\"-d\", nestedOutput.toString(), nestedH.toString()).checkSuccess();\n+        try(Loader loader = classLoader(nestedOutput)) {\n+            checkClass(loader, \"Foo\",\n+                checkField(\"bar\", MemorySegment.class, 0),\n+                checkField(\"color\", int.class, 8)\n+            );\n+            checkClass(loader, \"Foo$Bar\",\n+                checkField(\"x\", int.class, 0),\n+                checkField(\"y\", int.class, 4)\n+            );\n+            checkClass(loader, \"U\",\n+                checkField(\"point\", MemorySegment.class, 0),\n+                checkField(\"rgb\", int.class, 0),\n+                checkField(\"i\", int.class, 0)\n+            );\n+            checkClass(loader, \"U$Point\",\n+                checkField(\"x\", short.class, 0),\n+                checkField(\"y\", short.class, 2)\n+            );\n+            checkClass(loader, \"MyStruct\",\n+                checkField(\"a\", byte.class, 0),\n+\n+                checkField(\"b\", int.class, 4, \"$anon$0\"),\n+                checkField(\"c\", int.class, 8, \"$anon$0\", \"$anon$0\"),\n+\n+                checkField(\"d\", byte.class, 12, \"$anon$0\"),\n+                checkField(\"f\", MemorySegment.class, 13, \"$anon$0\"),\n+\n+                checkField(\"g\", int.class, 16, \"$anon$1\"),\n+                checkField(\"h\", long.class, 16, \"$anon$1\"),\n+\n+                checkField(\"k\", MemorySegment.class, 24)\n+            );\n+            checkClass(loader, \"MyStruct$MyStruct_Z\",\n+                checkField(\"e\", byte.class, 0)\n+            );\n+            checkClass(loader, \"MyStruct$k\",\n+                checkField(\"i\", int.class, 0),\n+                checkField(\"j\", int.class, 4)\n+            );\n+            checkClass(loader, \"MyUnion\",\n+                checkField(\"a\", byte.class, 0),\n+\n+                checkField(\"b\", int.class, 0, \"$anon$0\"),\n+                checkField(\"c\", int.class, 4, \"$anon$0\", \"$anon$0\"),\n+\n+                checkField(\"d\", byte.class, 8, \"$anon$0\"),\n+                checkField(\"f\", MemorySegment.class, 9, \"$anon$0\"),\n+\n+                checkField(\"g\", int.class, 0, \"$anon$1\"),\n+                checkField(\"h\", int.class, 4, \"$anon$1\"),\n+\n+                checkField(\"k\", MemorySegment.class, 0)\n+            );\n+            checkClass(loader, \"MyUnion$MyUnion_Z\",\n+                checkField(\"e\", byte.class, 0)\n+            );\n+            checkClass(loader, \"MyUnion$k\",\n+                checkField(\"i\", int.class, 0),\n+                checkField(\"j\", long.class, 0)\n+            );\n+            checkClass(loader, \"X\",\n+                checkField(\"Z\", MemorySegment.class, 0, \"$anon$0\")\n+            );\n+            checkClass(loader, \"X$Z\",\n+                checkField(\"y\", int.class, 0)\n+            );\n+            checkClass(loader, \"X2\",\n+                checkField(\"y\", int.class, 0, \"$anon$0\", \"$anon$0\")\n+            );\n+            checkClass(loader, \"NestedUnion\",\n+                checkField(\"x\", int.class, 0),\n+                checkField(\"y\", int.class, 4, \"$anon$0\"),\n+                checkField(\"z\", int.class, 4, \"$anon$0\")\n+            );\n+        } finally {\n+            deleteDir(nestedOutput);\n+        }\n+    }\n+\n+    @SafeVarargs\n+    private static void checkClass(Loader loader, String name, BiConsumer<Class<?>, MemoryLayout>... checks) {\n+        Class<?> cls = loader.loadClass(\"nested_h$\" + name);\n+        assertNotNull(cls);\n+        MemoryLayout layout = findLayout(cls);\n+        for (var check : checks) {\n+            check.accept(cls, layout);\n+        }\n+    }\n+\n+    private static BiConsumer<Class<?>, MemoryLayout> checkField(String fieldName, Class<?> fieldType,\n+                                                                 long expectedOffset, String... fieldPath) {\n+        MemoryLayout.PathElement[] path = new MemoryLayout.PathElement[fieldPath.length + 1];\n+        int i = 0;\n+        for (; i < fieldPath.length; i++) {\n+            path[i] = groupElement(fieldPath[i]);\n+        }\n+        path[i] = groupElement(fieldName);\n+        return (cls, layout) -> {\n+            assertEquals(layout.byteOffset(path), expectedOffset);\n+            checkAccessors(cls, layout, fieldName, fieldType, layout.select(path));\n+        };\n+    }\n+\n+    private static void checkAccessors(Class<?> cls, MemoryLayout layout, String fieldName, Class<?> type,\n+                                       MemoryLayout fieldLayout) {\n+        try {\n+            if (type == MemorySegment.class) {\n+                Method slicer = cls.getMethod(fieldName + \"$slice\", MemorySegment.class);\n+                assertEquals(slicer.getReturnType(), MemorySegment.class);\n+                try (MemorySegment struct = MemorySegment.allocateNative(layout)) {\n+                    MemorySegment slice = (MemorySegment) slicer.invoke(null, struct);\n+                    assertEquals(slice.byteSize(), fieldLayout.byteSize());\n+                }\n+            } else {\n+                Method getter = cls.getMethod(fieldName + \"$get\", MemorySegment.class);\n+                assertEquals(getter.getReturnType(), type);\n+                Method setter = cls.getMethod(fieldName + \"$set\", MemorySegment.class, type);\n+                assertEquals(setter.getReturnType(), void.class);\n+\n+                Object zero = MethodHandles.zero(type).invoke();\n+                try (MemorySegment struct = MemorySegment.allocateNative(layout)) {\n+                    setter.invoke(null, struct, zero);\n+                    Object actual = getter.invoke(null, struct);\n+                    assertEquals(actual, zero);\n+                }\n+            }\n+        } catch (Throwable t) {\n+            fail(\"Unexpected exception\", t);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/TestNested.java","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8244512\n+ * @summary jextract throws NPE for a nested struct declaration\n+ * @run testng\/othervm -Djextract.decls.per.header=1 -Dforeign.restricted=permit TestSplit\n+ *\/\n+public class TestSplit extends JextractToolRunner {\n+    @Test\n+    public void testSplit() {\n+        Path splitOutput = getOutputFilePath(\"split\");\n+        Path splitH = getInputFilePath(\"split.h\");\n+        run(\"-d\", splitOutput.toString(), splitH.toString()).checkSuccess();\n+        try(Loader loader = classLoader(splitOutput)) {\n+            checkPresent(loader, \"split_h\");\n+            checkPresent(loader, \"split_h_1\");\n+            checkPresent(loader, \"split_h_2\");\n+            checkPresent(loader, \"split_h_3\");\n+            checkPresent(loader, \"split_h_4\");\n+            checkMissing(loader, \"split_h_5\");\n+        } finally {\n+            deleteDir(splitOutput);\n+        }\n+    }\n+\n+    private static void checkPresent(Loader loader, String name) {\n+        assertNotNull(loader.loadClass(name));\n+    }\n+\n+    private static void checkMissing(Loader loader, String name) {\n+        assertNull(loader.loadClass(name));\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/TestSplit.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import org.testng.annotations.Test;\n+import java.nio.file.Path;\n+import jdk.incubator.foreign.GroupLayout;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @run testng\/othervm -Dforeign.restricted=permit UniondeclTest\n+ *\/\n+public class UniondeclTest extends JextractToolRunner {\n+    @Test\n+    public void unionDecl() {\n+        Path uniondeclOutput = getOutputFilePath(\"uniondecl.h\");\n+        Path uniondeclH = getInputFilePath(\"uniondecl.h\");\n+        run(\"-d\", uniondeclOutput.toString(), uniondeclH.toString()).checkSuccess();\n+        try(Loader loader = classLoader(uniondeclOutput)) {\n+            Class<?> cls = loader.loadClass(\"uniondecl_h\");\n+            \/\/ check a method for \"void func(IntOrFloat*)\"\n+            assertNotNull(findMethod(cls, \"func\", Addressable.class));\n+            \/\/ check IntOrFloat layout\n+            Class<?> intOrFloatCls = loader.loadClass(\"uniondecl_h$IntOrFloat\");\n+            GroupLayout intOrFloatLayout = (GroupLayout)findLayout(intOrFloatCls);\n+            assertNotNull(intOrFloatLayout);\n+            assertTrue(intOrFloatLayout.isUnion());\n+            checkField(intOrFloatLayout, \"i\",  CLinker.C_INT);\n+            checkField(intOrFloatLayout, \"f\", CLinker.C_FLOAT);\n+        } finally {\n+            deleteDir(uniondeclOutput);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/UniondeclTest.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+enum {\n+    RED = 0xff0000,\n+    GREEN = 0x00ff00,\n+    BLUE = 0x0000ff\n+};\n+\n+typedef enum {\n+   Java,\n+   C,\n+   CPP,\n+   Python,\n+   Ruby\n+} codetype_t;\n+\n+enum SIZE {\n+   XS,\n+   S,\n+   M,\n+   L,\n+   XL,\n+   XXL\n+};\n+\n+typedef enum temp {\n+   ONE = 1,\n+   TWO\n+} temp_t;\n","filename":"test\/jdk\/tools\/jextract\/anonenum.h","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#pragma pack(1)\n+struct Foo {\n+    long long a: 45;\n+    long long b: 24;\n+    long long c: 1;\n+    long long d: 58;\n+};\n","filename":"test\/jdk\/tools\/jextract\/badBitfields.h","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"constants_aux.h\"\n+\n+#define ZERO 0\n+#define ONE ZERO + 1 \/\/backward ref\n+#define THREE ONE + TWO \/* forward ref *\/\n+#define TWO ONE + ONE\n+\n+#define FOUR (long long)0x1L + THREE \/\/hack: force long carrier\n+#define FIVE (long long)0x1UL + FOUR \/\/hack: force long carrier\n+\n+#define SIX ONE +\\\n+              TWO +\\\n+              THREE\n+\n+#define STR \"Hello\" \/\/ a string\n+\n+#define ID(x) x \/\/function-like\n+#define SUM(x,y) x + y \/\/function-like\n+\n+#define BLOCK_BEGIN { \/\/not a constant\n+#define BLOCK_END } \/\/not a constant\n+\n+#define INTEGER_MAX_VALUE Integer.MAX_VALUE \/\/constant in Java, not in C\n+#define QUOTE \"QUOTE\" \/\/should be ok\n+\n+#define FLOAT_VALUE 1.32F;\n+#define DOUBLE_VALUE 1.32;\n+\n+#define CYCLIC_1 1 + CYCLIC_1 \/\/cycle\n+\n+#define CYCLIC_2 1 + TEMP \/\/indirect cycle\n+#define TEMP 1 + CYCLIC_2\n+\n+#define CHAR_VALUE 'h'\n+#define MULTICHAR_VALUE 'hh'\n+\n+#define BOOL_VALUE (_Bool)1\n+\/\/we should have tests for char and shorts, but these are likely to be platform dependent\n+\n+#define SUB SUP + 2 \/\/dependency\n+\n+#define ZERO_PTR (void*)0;\n+#define F_PTR (void*) 0xFFFFFFFFFFFFFFFFLL; \/\/ all 1s\n+\n+#define ARRAY { 0, 1, 2, 3, 4, 5 }\n","filename":"test\/jdk\/tools\/jextract\/constants.h","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#define SUP 5 \/\/this is used by the main test header file\n","filename":"test\/jdk\/tools\/jextract\/constants_aux.h","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+dummy file for this directory\n","filename":"test\/jdk\/tools\/jextract\/directory.h\/DUMMY.TXT","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+void foo(int boolean);\n+\n+int finally;\n+\n+struct abstract {\n+    short is;\n+    short throws;\n+} abstract;\n+\n+typedef char Byte;\n+void func(Byte byte, Byte* out);\n+\n+#define byte 1\n+#define content byte + 1\n+\n+typedef struct {\n+    short s1;\n+    short s2;\n+} Long;\n+\n+long twoShorts(Long s, Long* out, long* rv);\n","filename":"test\/jdk\/tools\/jextract\/exports.h","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#define NANF (0.0f\/0.0f)\n+#define PINFINITYF (1.0f\/0.0f)\n+#define NINFINITYF (-1.0f\/0.0f)\n+\n+#define NAN (0.0\/0.0)\n+#define PINFINITY (1.0\/0.0)\n+#define NINFINITY (-1.0\/0.0)\n","filename":"test\/jdk\/tools\/jextract\/float_constants.h","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.NativeScope;\n+import org.testng.annotations.Test;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.testng.Assert.*;\n+import static test.jextract.funcpointers.func_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextract -l Func -t test.jextract.funcpointers -- func.h\n+ * @run testng\/othervm -Dforeign.restricted=permit TestFuncPointerInvokers\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextractSources -l Func -t test.jextract.funcpointers -- func.h\n+ * @run testng\/othervm -Dforeign.restricted=permit TestFuncPointerInvokers\n+ *\/\n+public class TestFuncPointerInvokers {\n+    @Test\n+    public void testStructFieldTypedef() {\n+        try (NativeScope scope = NativeScope.unboundedScope()) {\n+            AtomicInteger val = new AtomicInteger(-1);\n+            MemorySegment bar = Bar.allocate(scope);\n+            Bar.foo$set(bar, Foo.allocate((i) -> val.set(i), scope).address());\n+            Bar.foo(bar).apply(42);\n+            assertEquals(val.get(), 42);\n+        }\n+    }\n+\n+    @Test\n+    public void testStructFieldFITypedef() {\n+        try (NativeScope scope = NativeScope.unboundedScope()) {\n+            AtomicInteger val = new AtomicInteger(-1);\n+            MemorySegment bar = Bar.allocate(scope);\n+            Bar.foo$set(bar, Foo.allocate((i) -> val.set(i), scope).address());\n+            Foo.ofAddressRestricted(Bar.foo$get(bar)).apply(42);\n+            assertEquals(val.get(), 42);\n+        }\n+    }\n+\n+    @Test\n+    public void testGlobalTypedef() {\n+        try (NativeScope scope = NativeScope.unboundedScope()) {\n+            AtomicInteger val = new AtomicInteger(-1);\n+            f$set(Foo.allocate((i) -> val.set(i), scope).address());\n+            f().apply(42);\n+            assertEquals(val.get(), 42);\n+        }\n+    }\n+\n+    @Test\n+    public void testGlobalFITypedef() {\n+        try (NativeScope scope = NativeScope.unboundedScope()) {\n+            AtomicInteger val = new AtomicInteger(-1);\n+            f$set(Foo.allocate((i) -> val.set(i), scope).address());\n+            Foo.ofAddressRestricted(f$get()).apply(42);\n+            assertEquals(val.get(), 42);\n+        }\n+    }\n+\n+    @Test\n+    public void testStructFieldFunctionPointer() {\n+        try (NativeScope scope = NativeScope.unboundedScope()) {\n+            AtomicInteger val = new AtomicInteger(-1);\n+            MemorySegment baz = Baz.allocate(scope);\n+            Baz.fp$set(baz, Baz.fp.allocate((i) -> val.set(i), scope).address());\n+            Baz.fp(baz).apply(42);\n+            assertEquals(val.get(), 42);\n+        }\n+    }\n+\n+    @Test\n+    public void testStructFieldFIFunctionPointer() {\n+        try (NativeScope scope = NativeScope.unboundedScope()) {\n+            AtomicInteger val = new AtomicInteger(-1);\n+            MemorySegment baz = Baz.allocate(scope);\n+            Baz.fp$set(baz, Baz.fp.allocate((i) -> val.set(i), scope).address());\n+            Baz.fp.ofAddressRestricted(Baz.fp$get(baz)).apply(42);\n+            assertEquals(val.get(), 42);\n+        }\n+    }\n+\n+    @Test\n+    public void testGlobalFunctionPointer() {\n+        try (NativeScope scope = NativeScope.unboundedScope()) {\n+            AtomicInteger val = new AtomicInteger(-1);\n+            fp$set(fp.allocate((i) -> val.set(i), scope).address());\n+            fp().apply(42);\n+            assertEquals(val.get(), 42);\n+        }\n+    }\n+\n+    @Test\n+    public void testGlobalFIFunctionPointer() {\n+        try (NativeScope scope = NativeScope.unboundedScope()) {\n+            AtomicInteger val = new AtomicInteger(-1);\n+            fp$set(fp.allocate((i) -> val.set(i), scope).address());\n+            fp.ofAddressRestricted(fp$get()).apply(42);\n+            assertEquals(val.get(), 42);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/funcPointerInvokers\/TestFuncPointerInvokers.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+typedef void (*Foo)(int arg);\n+\n+struct Bar {\n+   Foo foo;\n+};\n+\n+EXPORT Foo f;\n+\n+struct Baz {\n+   void (*fp)(int arg);\n+};\n+\n+EXPORT void (*fp)(int arg);\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/funcPointerInvokers\/func.h","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"func.h\"\n","filename":"test\/jdk\/tools\/jextract\/funcPointerInvokers\/libFunc.c","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* make sure compiler built-in headers can be included *\/\n+#include <stddef.h>\n+\n+void func(int);\n+int printf(char* fmt, ...);\n+void f();\n","filename":"test\/jdk\/tools\/jextract\/hello.h","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+short long x;\n","filename":"test\/jdk\/tools\/jextract\/illegal_decls.h","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library .. \/test\/lib\n+ * @modules jdk.incubator.jextract\n+ *\n+ * @run testng\/othervm -Dforeign.restricted=permit IncompleteArrayTest\n+ *\/\n+\n+import jdk.incubator.foreign.MemoryLayout;\n+import org.testng.annotations.Test;\n+\n+import static jdk.incubator.foreign.CLinker.C_INT;\n+import static jdk.incubator.foreign.CLinker.C_POINTER;\n+import static org.testng.Assert.*;\n+\n+import java.nio.file.Path;\n+\n+public class IncompleteArrayTest extends JextractToolRunner {\n+\n+    @Test\n+    public void testIncompleteArray() {\n+        Path output = getOutputFilePath(\"incompleteArray_out\");\n+        Path input = getInputFilePath(\"incompleteArray.h\");\n+        run(\n+            \"-t\", \"org.jextract\",\n+            \"-d\", output,\n+            \"--\",\n+            input).checkSuccess();\n+        try (Loader loader = classLoader(output)) {\n+            Class<?> cls = loader.loadClass(\"org.jextract.incompleteArray_h$Foo\");\n+            assertNotNull(cls);\n+\n+            MemoryLayout actualLayout = findLayout(cls);\n+            MemoryLayout expectedLayout = MemoryLayout.ofStruct(\n+                C_INT.withName(\"size\"),\n+                MemoryLayout.ofPaddingBits(32),\n+                MemoryLayout.ofSequence(C_POINTER).withName(\"data\")\n+            ).withName(\"Foo\");\n+            assertEquals(actualLayout, expectedLayout);\n+        } finally {\n+            \/\/deleteDir(output);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jextract\/incompleteArray\/IncompleteArrayTest.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct Foo {\n+    int size;\n+    void* data[]; \/\/ incomplete array\n+};\n","filename":"test\/jdk\/tools\/jextract\/incompleteArray\/incompleteArray.h","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct foo {\n+  int x;\n+  int y;\n+  int z;\n+};\n+\n+\/\/ variable name clashing with struct name declared earlier\n+long foo;\n+\n+union foo2 {\n+   int i;\n+   long l;\n+};\n+\n+\/\/ variable name clashing with union name declared earlier\n+char foo2;\n+\n+int bar;\n+\n+\/\/ struct name clashing with variable name declared earlier\n+struct bar {\n+   float f1;\n+   float f2;\n+};\n+\n+int bar2;\n+\n+\/\/ union name clashing with variable name declared earlier\n+union bar2 {\n+   float f;\n+   double d;\n+};\n","filename":"test\/jdk\/tools\/jextract\/name_collision.h","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct Foo {\n+    struct Bar {\n+        int x, y;\n+    } bar;\n+\n+    enum Color {\n+        red, green, blue\n+    } color;\n+};\n+\n+union U {\n+    struct Point {\n+        short x, y;\n+    } point;\n+\n+    enum RGB {\n+        r, g, b\n+    } rgb;\n+\n+    int i;\n+};\n+\n+struct MyStruct {\n+    char a;\n+    struct {\n+        int b;\n+        union {\n+            int c;\n+        };\n+        char d;\n+        struct MyStruct_Z {\n+            char e;\n+        } f;\n+    };\n+    union {\n+        int g;\n+        long long h;\n+    };\n+    enum {\n+        X, Y, Z\n+    };\n+    struct {\n+        int i;\n+        int j;\n+    } k;\n+};\n+\n+union MyUnion {\n+    char a;\n+    struct {\n+        int b;\n+        union {\n+            int c;\n+        };\n+        char d;\n+        struct MyUnion_Z {\n+            char e;\n+        } f;\n+    };\n+    struct {\n+        int g;\n+        int h;\n+    };\n+    enum {\n+        A, B, C\n+    };\n+    union {\n+        int i;\n+        long long j;\n+    } k;\n+};\n+\n+struct X {\n+    struct {\n+        union {\n+            int y;\n+        } Z;\n+    };\n+};\n+\n+struct X2 {\n+    struct {\n+        union {\n+            int y;\n+        }; \/\/ no name this time\n+    };\n+};\n+\n+struct NestedUnion {\n+    int x;\n+    union {\n+        int y;\n+        int z;\n+    };\n+};\n","filename":"test\/jdk\/tools\/jextract\/nested.h","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"non_existent.h\"\n","filename":"test\/jdk\/tools\/jextract\/non_existent_includer.h","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct Point;\n+struct Point;\n+\n+int i;\n+int i;\n+\n+void func(int);\n+void func(int abc);\n+void func(int xyz);\n+void func2(int);\n+void func2(int abc);\n+void func2(int xyz);\n+\n+typedef int INT;\n+void func(INT);\n+void func(INT abc);\n+void func(INT xyz);\n+void func2(INT);\n+void func2(INT abc);\n+void func2(INT xyz);\n+\n+typedef int* INTPTR;\n+void func3(INTPTR x);\n+void func3(int* x);\n+void func4(INTPTR x);\n+void func4(int* x);\n+\n+typedef int Integer;\n+void func(Integer x);\n+void func5(int x);\n+void func5(Integer x);\n+void func5(INT x);\n+\n+struct Point;\n+struct Point {\n+   int i;\n+   int j;\n+};\n+\n+typedef struct Point POINT;\n+typedef struct Point Point_t;\n+\n+double distance(struct Point p);\n+double distance(POINT p);\n+\n+typedef struct Point3D {\n+    int i;\n+    int j;\n+    int k;\n+} Point3D_t;\n+struct Point3D;\n+\n+enum RGBColor;\n+enum RGBColor {\n+   R, G, B\n+};\n+\n+enum CMYColor {\n+  C, M, Y\n+};\n+enum CMYColor;\n","filename":"test\/jdk\/tools\/jextract\/repeatedDecls.h","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,11 @@\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT int a();\n+EXPORT int b();\n+EXPORT int c();\n+EXPORT int d();\n+EXPORT int e();\n","filename":"test\/jdk\/tools\/jextract\/split.h","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+import static test.jextract.test8239918.test8239918_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8239918\n+ * @summary jextract generates uncompilable code for no argument C function\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextract -l Test8239918 -t test.jextract.test8239918 -- test8239918.h\n+ * @run testng\/othervm -Dforeign.restricted=permit LibTest8239918Test\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @bug 8239918\n+ * @summary jextract generates uncompilable code for no argument C function\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextractSources -l Test8239918 -t test.jextract.test8239918 -- test8239918.h\n+ * @run testng\/othervm -Dforeign.restricted=permit LibTest8239918Test\n+ *\/\n+public class LibTest8239918Test {\n+    @Test\n+    public void testRand() {\n+        assertEquals(rand(), 1729);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8239918\/LibTest8239918Test.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"test8239918.h\"\n+\n+EXPORT int rand(void) {\n+    return 1729;\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8239918\/libTest8239918.c","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT int rand(void);\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/test8239918\/test8239918.h","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertTrue;\n+import static test.jextract.test8240373.test8240373_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8240373\n+ * @summary Jextract assigns type \"Void\" to enum macros\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextract -t test.jextract.test8240373 -- test8240373.h\n+ * @run testng\/othervm -Dforeign.restricted=permit Lib8240373Test\n+ *\/\n+\n+\/*\n+ * @test id=sources\n+ * @bug 8240373\n+ * @summary Jextract assigns type \"Void\" to enum macros\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ *\n+ * @run driver JtregJextractSources -t test.jextract.test8240373 -- test8240373.h\n+ * @run testng\/othervm -Dforeign.restricted=permit Lib8240373Test\n+ *\/\n+\n+public class Lib8240373Test {\n+    @Test\n+    public void test() {\n+        assertTrue(A() == 0);\n+        assertTrue(B() == 1);\n+        assertTrue(C() == 2);\n+        assertTrue(E_INVALID() == -1);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8240373\/Lib8240373Test.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+typedef enum E { A, B, C } E;\n+#define E_INVALID ((E)-1)\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/test8240373\/test8240373.h","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.stream.DoubleStream;\n+import java.util.stream.IntStream;\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.NativeScope;\n+import org.testng.annotations.Test;\n+import test.jextract.test8241925.*;\n+import static org.testng.Assert.assertEquals;\n+import static test.jextract.test8241925.test8241925_h.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+\n+\/*\n+ * @test\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @bug 8241925\n+ * @summary jextract should generate simple allocation, access API for C primitive types\n+ * @run driver JtregJextract -l Test8241925 -t test.jextract.test8241925 -- test8241925.h\n+ * @run testng\/othervm -Dforeign.restricted=permit LibTest8241925Test\n+ *\/\n+public class LibTest8241925Test {\n+    @Test\n+    public void test() {\n+        try (var scope = NativeScope.unboundedScope()) {\n+            var addr = scope.allocate(C_INT, 12);\n+            assertEquals(MemoryAccess.getInt(addr), 12);\n+            square(addr);\n+            assertEquals(MemoryAccess.getInt(addr), 144);\n+\n+            addr = scope.allocate(C_DOUBLE, 12.0);\n+            assertEquals(MemoryAccess.getDouble(addr), 12.0, 0.1);\n+            square_fp(addr);\n+            assertEquals(MemoryAccess.getDouble(addr), 144.0, 0.1);\n+\n+            int[] intArray = { 34, 67, 78, 8 };\n+            addr = scope.allocateArray(C_INT, intArray);\n+            int sum = sum(addr, intArray.length);\n+            assertEquals(sum, IntStream.of(intArray).sum());\n+            int[] convertedArray = addr.toIntArray();\n+            assertEquals(convertedArray, intArray);\n+\n+            double[] dblArray = { 34.5, 67.56, 78.2, 8.45 };\n+            addr = scope.allocateArray(C_DOUBLE, dblArray);\n+            double sumd = sum_fp(addr, dblArray.length);\n+            assertEquals(sumd, DoubleStream.of(dblArray).sum(), 0.1);\n+            double[] convertedDblArray = addr.toDoubleArray();\n+            for (int i = 0; i < dblArray.length; i++) {\n+                assertEquals(dblArray[i], convertedDblArray[i], 0.1);\n+            }\n+\n+            assertEquals(toJavaStringRestricted(name()), \"java\");\n+\n+            var dest = scope.allocateArray(C_CHAR, 12);\n+            dest.copyFrom(toCString(\"hello \"));\n+            var src = toCString(\"world\", scope);\n+            assertEquals(toJavaStringRestricted(concatenate(dest, src)), \"hello world\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8241925\/LibTest8241925Test.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"test8241925.h\"\n+#include <string.h>\n+\n+EXPORT void square(int* v) {\n+    *v = (*v) * (*v);\n+}\n+\n+EXPORT int sum(int* arr, int num) {\n+    int res = 0;\n+    int i = 0;\n+    for (; i < num; i++) {\n+        res += arr[i];\n+    }\n+    return res;\n+}\n+\n+EXPORT void square_fp(double* v) {\n+    *v = (*v) * (*v);\n+}\n+\n+EXPORT double sum_fp(double* arr, int num) {\n+    double res = 0;\n+    int i = 0;\n+    for (; i < num; i++) {\n+        res += arr[i];\n+    }\n+    return res;\n+}\n+\n+const char* cptr = \"java\";\n+\n+EXPORT const char* name(void) {\n+    return cptr;\n+}\n+\n+EXPORT char* concatenate(char* dest, char* src) {\n+    return strcat(dest, src);\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8241925\/libTest8241925.c","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT void square(int* v);\n+EXPORT int sum(int* arr, int num);\n+\n+EXPORT void square_fp(double* v);\n+EXPORT double sum_fp(double* arr, int num);\n+\n+EXPORT const char* name(void);\n+\n+EXPORT char* concatenate(char* dest, char* src);\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/test8241925\/test8241925.h","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.NativeScope;\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+import static test.jextract.test8244412.test8244412_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @bug 8244412\n+ * @summary jextract should generate static utils class for primitive typedefs\n+ * @run driver JtregJextract -t test.jextract.test8244412 -- test8244412.h\n+ * @run testng\/othervm -Dforeign.restricted=permit LibTest8244412Test\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @bug 8244412\n+ * @summary jextract should generate static utils class for primitive typedefs\n+ * @run driver JtregJextractSources -t test.jextract.test8244412 -- test8244412.h\n+ * @run testng\/othervm -Dforeign.restricted=permit LibTest8244412Test\n+ *\/\n+public class LibTest8244412Test {\n+    @Test\n+    public void test() {\n+        try (var scope = NativeScope.unboundedScope()) {\n+            var addr = scope.allocate(mysize_t, 0L);\n+            assertEquals(MemoryAccess.getLong(addr), 0L);\n+            MemoryAccess.setLong(addr, 13455566L);\n+            assertEquals(MemoryAccess.getLong(addr), 13455566L);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8244412\/LibTest8244412Test.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,25 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+typedef long long mysize_t;\n+typedef long long MYSIZE_T;\n","filename":"test\/jdk\/tools\/jextract\/test8244412\/test8244412.h","additions":25,"deletions":0,"binary":false,"changes":25,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+import static test.jextract.test8244938.test8244938_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8244938\n+ * @summary Crash in foreign ABI CallArranger class when a test native function returns a nested struct\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextract -l Test8244938 -t test.jextract.test8244938 -- test8244938.h\n+ * @run testng\/othervm -Dforeign.restricted=permit Test8244938\n+ *\/\n+\n+\/*\n+ * @test id=sources\n+ * @bug 8244938\n+ * @summary Crash in foreign ABI CallArranger class when a test native function returns a nested struct\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextractSources -l Test8244938 -t test.jextract.test8244938 -- test8244938.h\n+ * @run testng\/othervm -Dforeign.restricted=permit Test8244938\n+ *\/\n+public class Test8244938 {\n+    @Test\n+    public void testNestedStructReturn() {\n+         var seg = func();\n+         assertEquals(seg.byteSize(), Point.sizeof());\n+         assertEquals(Point.k$get(seg), 44);\n+         var point2dSeg = Point.point2d$slice(seg);\n+         assertEquals(Point2D.i$get(point2dSeg), 567);\n+         assertEquals(Point2D.j$get(point2dSeg), 33);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8244938\/Test8244938.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"test8244938.h\"\n+\n+static struct Point point = { 44, { 567, 33 } };\n+EXPORT struct Point func(void) {\n+    return point;\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8244938\/libTest8244938.c","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+struct Point2D {\n+   int i, j;\n+};\n+\n+struct Point {\n+  int k;\n+  struct Point2D point2d;\n+};\n+\n+EXPORT struct Point func(void);\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/test8244938\/test8244938.h","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import jdk.incubator.foreign.MemorySegment;\n+\n+import static org.testng.Assert.assertEquals;\n+import static test.jextract.printf.printf_h.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8244959\n+ * @summary Jextract's VarargsInvoker fails to link functions when passing integer types other than long\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextract -t test.jextract.printf -l Printf -- printf.h\n+ * @run testng\/othervm -Dforeign.restricted=permit Test8244959\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @bug 8244959\n+ * @summary Jextract's VarargsInvoker fails to link functions when passing integer types other than long\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextractSources -t test.jextract.printf -l Printf -- printf.h\n+ * @run testng\/othervm -Dforeign.restricted=permit Test8244959\n+ *\/\n+public class Test8244959 {\n+    @Test\n+    public void testsPrintf() {\n+        try (MemorySegment s = MemorySegment.allocateNative(1024)) {\n+            my_sprintf(s,\n+                toCString(\"%hhd %c %.2f %.2f %lld %lld %d %hd %d %d %lld %c\"), 12,\n+                (byte) 1, 'b', -1.25f, 5.5d, -200L, Long.MAX_VALUE, (byte) -2, (short) 2, 3, (short) -4, 5L, 'a');\n+            String str = toJavaString(s);\n+            assertEquals(str, \"1 b -1.25 5.50 -200 \" + Long.MAX_VALUE + \" -2 2 3 -4 5 a\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8244959\/Test8244959.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"printf.h\"\n+\n+#include <stdio.h>\n+#include <stdarg.h>\n+\n+EXPORT int my_sprintf(char *buf, const char *fmt, int arg_num, ...) {\n+    va_list list;\n+    va_start(list, arg_num);\n+    int result = vsprintf(buf, fmt, list);\n+    va_end(list);\n+    return result;\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8244959\/libPrintf.c","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT int my_sprintf(char *buf, const char *fmt, int arg_num, ...);\n","filename":"test\/jdk\/tools\/jextract\/test8244959\/printf.h","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import jdk.incubator.foreign.MemorySegment;\n+import test.jextract.test8245003.*;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static test.jextract.test8245003.test8245003_h.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8245003\n+ * @summary jextract does not generate accessor for MemorySegement typed values\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextract -l Test8245003 -t test.jextract.test8245003 -- test8245003.h\n+ * @run testng\/othervm -Dforeign.restricted=permit Test8245003\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @bug 8245003\n+ * @summary jextract does not generate accessor for MemorySegement typed values\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextractSources -l Test8245003 -t test.jextract.test8245003 -- test8245003.h\n+ * @run testng\/othervm -Dforeign.restricted=permit Test8245003\n+ *\/\n+public class Test8245003 {\n+    private void checkAccess(MemorySegment seg) {\n+        assertFalse(seg.hasAccessModes(MemorySegment.CLOSE | MemorySegment.HANDOFF));\n+    }\n+\n+    @Test\n+    public void testStructAccessor() {\n+        var seg = special_pt$SEGMENT();\n+        checkAccess(seg);\n+        assertEquals(seg.byteSize(), Point.sizeof());\n+        assertEquals(Point.x$get(seg), 56);\n+        assertEquals(Point.y$get(seg), 75);\n+\n+        seg = special_pt3d$SEGMENT();\n+        checkAccess(seg);\n+        assertEquals(seg.byteSize(), Point3D.sizeof());\n+        assertEquals(Point3D.z$get(seg), 35);\n+        var pointSeg = Point3D.p$slice(seg);\n+        assertEquals(pointSeg.byteSize(), Point.sizeof());\n+        assertEquals(Point.x$get(pointSeg), 43);\n+        assertEquals(Point.y$get(pointSeg), 45);\n+        checkAccess(pointSeg);\n+    }\n+\n+    @Test\n+    public void testArrayAccessor() {\n+        var seg = iarr$SEGMENT();\n+        assertEquals(seg.byteSize(), C_INT.byteSize()*5);\n+        int[] arr = seg.toIntArray();\n+        assertEquals(arr.length, 5);\n+        assertEquals(arr[0], 2);\n+        assertEquals(arr[1], -2);\n+        assertEquals(arr[2], 42);\n+        assertEquals(arr[3], -42);\n+        assertEquals(arr[4], 345);\n+\n+        seg = foo$SEGMENT();\n+        assertEquals(seg.byteSize(), Foo.sizeof());\n+        assertEquals(Foo.count$get(seg), 37);\n+        var greeting = Foo.greeting$slice(seg);\n+        byte[] barr = greeting.toByteArray();\n+        assertEquals(new String(barr), \"hello\");\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8245003\/Test8245003.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"test8245003.h\"\n+\n+EXPORT Point special_pt = { 56, 75 };\n+\n+EXPORT Point3D special_pt3d = { 35, { 43, 45 } };\n+\n+EXPORT int iarr[5] = { 2, -2, 42, -42, 345 };\n+\n+EXPORT Foo foo = { 37, { 'h', 'e', 'l', 'l', 'o' } };\n","filename":"test\/jdk\/tools\/jextract\/test8245003\/libTest8245003.c","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+typedef struct Point {\n+    int x;\n+    int y;\n+} Point;\n+\n+EXPORT Point special_pt;\n+\n+typedef struct Point3D {\n+    int z;\n+    struct Point p;\n+} Point3D;\n+\n+EXPORT Point3D special_pt3d;\n+\n+EXPORT int iarr[5];\n+\n+typedef struct Foo {\n+    int count;\n+    char greeting[5];\n+} Foo;\n+\n+EXPORT Foo foo;\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/test8245003\/test8245003.h","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+typedef struct _Bar Foo;\n+\n+typedef struct Point Point_t;\n+\n+struct Point {\n+    int x, y;\n+};\n","filename":"test\/jdk\/tools\/jextract\/test8245767.h","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.NativeScope;\n+import org.testng.annotations.Test;\n+import test.jextract.test8246341.*;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+import static test.jextract.test8246341.test8246341_h.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8246341\n+ * @summary jextract should generate Cpointer utilities class\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextract -l Test8246341 -t test.jextract.test8246341 -- test8246341.h\n+ * @run testng\/othervm -Dforeign.restricted=permit LibTest8246341Test\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @bug 8246341\n+ * @summary jextract should generate Cpointer utilities class\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextractSources -l Test8246341 -t test.jextract.test8246341 -- test8246341.h\n+ * @run testng\/othervm -Dforeign.restricted=permit LibTest8246341Test\n+ *\/\n+public class LibTest8246341Test {\n+    @Test\n+    public void testPointerArray() {\n+        boolean[] callbackCalled = new boolean[1];\n+        try (var callback = func$callback.allocate((argc, argv) -> {\n+            callbackCalled[0] = true;\n+            var addr = argv.asSegmentRestricted(C_POINTER.byteSize() * argc);\n+            assertEquals(argc, 4);\n+            assertEquals(toJavaStringRestricted(MemoryAccess.getAddressAtIndex(addr, 0)), \"java\");\n+            assertEquals(toJavaStringRestricted(MemoryAccess.getAddressAtIndex(addr, 1)), \"python\");\n+            assertEquals(toJavaStringRestricted(MemoryAccess.getAddressAtIndex(addr, 2)), \"javascript\");\n+            assertEquals(toJavaStringRestricted(MemoryAccess.getAddressAtIndex(addr, 3)), \"c++\");\n+        })) {\n+            func(callback);\n+        }\n+        assertTrue(callbackCalled[0]);\n+    }\n+\n+    @Test\n+    public void testPointerAllocate() {\n+        try (var scope = NativeScope.boundedScope(C_POINTER.byteSize())) {\n+            var addr = scope.allocate(C_POINTER);\n+            MemoryAccess.setAddress(addr, MemoryAddress.NULL);\n+            fillin(addr);\n+            assertEquals(toJavaStringRestricted(MemoryAccess.getAddress(addr)), \"hello world\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8246341\/LibTest8246341Test.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"test8246341.h\"\n+\n+#define NUM_STRINGS 4\n+\n+static char* table[NUM_STRINGS] = { \"java\", \"python\", \"javascript\", \"c++\" };\n+static char* msg = \"hello world\";\n+\n+EXPORT void func(void (*callback)(int argc, char** argv)) {\n+    callback(NUM_STRINGS, table);\n+}\n+\n+EXPORT void fillin(char** pmsg) {\n+    *pmsg = msg;\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8246341\/libTest8246341.c","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT void func(void (*callback)(int argc, char** argv));\n+EXPORT void fillin(char** pmsg);\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/test8246341\/test8246341.h","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.NativeScope;\n+import org.testng.annotations.Test;\n+import test.jextract.test8246400.*;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+import static test.jextract.test8246400.test8246400_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8246400\n+ * @summary jextract should generate a utility to manage mutliple MemorySegments\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextract -l Test8246400 -t test.jextract.test8246400 -- test8246400.h\n+ * @run testng\/othervm -Dforeign.restricted=permit LibTest8246400Test\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @bug 8246400\n+ * @summary jextract should generate a utility to manage mutliple MemorySegments\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextractSources -l Test8246400 -t test.jextract.test8246400 -- test8246400.h\n+ * @run testng\/othervm -Dforeign.restricted=permit LibTest8246400Test\n+ *\/\n+public class LibTest8246400Test {\n+    @Test\n+    public void testSegmentRegister() {\n+        MemorySegment sum = null;\n+        MemorySegment callback = null;\n+        try (var scope = NativeScope.unboundedScope()) {\n+            var v1 = Vector.allocate(scope);\n+            Vector.x$set(v1, 1.0);\n+            Vector.y$set(v1, 0.0);\n+\n+            var v2 = Vector.allocate(scope);\n+            Vector.x$set(v2, 0.0);\n+            Vector.y$set(v2, 1.0);\n+\n+            sum = add(v1, v2);\n+            sum = sum.handoff(scope);\n+\n+            assertEquals(Vector.x$get(sum), 1.0, 0.1);\n+            assertEquals(Vector.y$get(sum), 1.0, 0.1);\n+\n+            callback = cosine_similarity$dot.allocate((a, b) -> {\n+                return (Vector.x$get(a) * Vector.x$get(b)) +\n+                    (Vector.y$get(a) * Vector.y$get(b));\n+            }, scope);\n+\n+            var value = cosine_similarity(v1, v2, callback);\n+            assertEquals(value, 0.0, 0.1);\n+\n+            value = cosine_similarity(v1, v1, callback);\n+            assertEquals(value, 1.0, 0.1);\n+        }\n+        assertTrue(!sum.isAlive());\n+        assertTrue(!callback.isAlive());\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8246400\/LibTest8246400Test.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"test8246400.h\"\n+#include <math.h>\n+\n+EXPORT Vector add(Vector v1, Vector v2) {\n+    Vector res = { v1.x + v2.x, v1.y + v2. y };\n+    return res;\n+}\n+\n+EXPORT double cosine_similarity(Vector v1, Vector v2,\n+        double (*dot)(Vector, Vector)) {\n+    double normv1 = sqrt(dot(v1, v1));\n+    double normv2 = sqrt(dot(v2, v2));\n+    return dot(v1, v2)\/(normv1 * normv2);\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8246400\/libTest8246400.c","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+typedef struct Vector {\n+    double x;\n+    double y;\n+} Vector;\n+\n+EXPORT Vector add(Vector v1, Vector v2);\n+EXPORT double cosine_similarity(Vector v1, Vector v2, double (*dot)(Vector, Vector));\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/test8246400\/test8246400.h","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct Node {\n+  struct Node *next;\n+};\n","filename":"test\/jdk\/tools\/jextract\/test8248415.h","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+typedef void MyVoid;\n+EXPORT void func(MyVoid (*f)(MyVoid));\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/test8249290.h","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+typedef void MyVoid;\n+EXPORT void func(MyVoid (*f)());\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/test8249300.h","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+import static test.jextract.test8249757.test8249757_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @bug 8249757\n+ * @summary jextract should expose a way to load library from a given absolute path\n+ * @run driver JtregJextract -libpath Test8249757 -t test.jextract.test8249757 -- test8249757.h\n+ * @run testng\/othervm -Dforeign.restricted=permit LibTest8249757Test\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @bug 8249757\n+ * @summary jextract should expose a way to load library from a given absolute path\n+ * @run driver JtregJextractSources -libpath Test8249757 -t test.jextract.test8249757 -- test8249757.h\n+ * @run testng\/othervm -Dforeign.restricted=permit LibTest8249757Test\n+ *\/\n+public class LibTest8249757Test {\n+    @Test\n+    public void testSquare() {\n+        assertEquals(square(5), 25);\n+        assertEquals(square(16), 256);\n+        assertEquals(square(20), 400);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8249757\/LibTest8249757Test.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"test8249757.h\"\n+\n+EXPORT int square(int x) {\n+    return x*x;\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8249757\/libTest8249757.c","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT int square(int);\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/test8249757\/test8249757.h","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+extern char* tzname[];\n+\n+struct Foo {\n+   int bar;\n+   char* names[];\n+};\n","filename":"test\/jdk\/tools\/jextract\/test8251943.h","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import jdk.incubator.foreign.MemorySegment;\n+\n+import static org.testng.Assert.assertEquals;\n+import static test.jextract.vsprintf.vsprintf_h.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8252016\n+ * @summary jextract should handle va_list\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextract -t test.jextract.vsprintf -l VSPrintf -- vsprintf.h\n+ * @run testng\/othervm -Dforeign.restricted=permit Test8252016\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @bug 8252016\n+ * @summary jextract should handle va_list\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextractSources -t test.jextract.vsprintf -l VSPrintf -- vsprintf.h\n+ * @run testng\/othervm -Dforeign.restricted=permit Test8252016\n+ *\/\n+public class Test8252016 {\n+    @Test\n+    public void testsVsprintf() {\n+        try (MemorySegment s = MemorySegment.allocateNative(1024)) {\n+            try (VaList vaList = VaList.make(b -> {\n+                b.vargFromInt(C_INT, 12);\n+                b.vargFromDouble(C_DOUBLE, 5.5d);\n+                b.vargFromLong(C_LONG_LONG, -200L);\n+                b.vargFromLong(C_LONG_LONG, Long.MAX_VALUE);\n+            })) {\n+                my_vsprintf(s, toCString(\"%hhd %.2f %lld %lld\"), vaList);\n+                String str = toJavaString(s);\n+                assertEquals(str, \"12 5.50 -200 \" + Long.MAX_VALUE);\n+            }\n+       }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8252016\/Test8252016.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"vsprintf.h\"\n+\n+#include <stdio.h>\n+#include <stdarg.h>\n+\n+EXPORT int my_vsprintf(char *s, const char* format, va_list arg) {\n+    return vsprintf(s, format, arg);\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8252016\/libVSPrintf.c","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+#include <stdarg.h>\n+\n+EXPORT int my_vsprintf(char *s, const char* format, va_list arg);\n","filename":"test\/jdk\/tools\/jextract\/test8252016\/vsprintf.h","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.util.stream.IntStream;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.NativeScope;\n+import static org.testng.Assert.assertEquals;\n+import static test.jextract.arrayparam.arrayparam_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8252121\n+ * @summary jextract generated code fails with ABI for typedefed array type parameters\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextract -t test.jextract.arrayparam -l Arrayparam -- arrayparam.h\n+ * @run testng\/othervm -Dforeign.restricted=permit Test8252121\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @bug 8252121\n+ * @summary jextract generated code fails with ABI for typedefed array type parameters\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextractSources -t test.jextract.arrayparam -l Arrayparam -- arrayparam.h\n+ * @run testng\/othervm -Dforeign.restricted=permit Test8252121\n+ *\/\n+public class Test8252121 {\n+    @Test\n+    public void test() {\n+        try (NativeScope scope = NativeScope.unboundedScope()) {\n+            int[] array = { 3, 5, 89, 34, -33 };\n+            MemorySegment seg = scope.allocateArray(CLinker.C_INT, array);\n+            assertEquals(IntStream.of(array).sum(), sum(seg));\n+            assertEquals(IntStream.of(array).reduce(1, (a,b) -> a*b), mul(seg));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8252121\/Test8252121.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+#define NUM_ELEMENTS 5\n+typedef int Array[NUM_ELEMENTS];\n+\n+typedef Array MyArray;\n+\n+EXPORT int sum(Array a);\n+EXPORT int mul(MyArray a);\n","filename":"test\/jdk\/tools\/jextract\/test8252121\/arrayparam.h","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"arrayparam.h\"\n+\n+int sum(Array a) {\n+    int res = 0;\n+    for (int i = 0; i < NUM_ELEMENTS; i++) {\n+        res += a[i];\n+    }\n+    return res;\n+}\n+\n+int mul(MyArray a) {\n+    int res = 1;\n+    for (int i = 0; i < NUM_ELEMENTS; i++) {\n+        res *= a[i];\n+    }\n+    return res;\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8252121\/libArrayparam.c","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import jdk.incubator.foreign.NativeScope;\n+import static org.testng.Assert.assertEquals;\n+import static test.jextract.test8252465.test8252465_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8252465\n+ * @summary jextract generates wrong layout and varhandle when different structs have same named field\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextract -t test.jextract.test8252465 -- test8252465.h\n+ * @run testng\/othervm -Dforeign.restricted=permit LibTest8252465Test\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @bug 8252465\n+ * @summary jextract generates wrong layout and varhandle when different structs have same named field\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextractSources -t test.jextract.test8252465 -- test8252465.h\n+ * @run testng\/othervm -Dforeign.restricted=permit LibTest8252465Test\n+ *\/\n+public class LibTest8252465Test {\n+    @Test\n+    public void test() {\n+        try (var scope = NativeScope.unboundedScope()) {\n+            var foo = Foo.allocate(scope);\n+            Foo.x$set(foo, 3.14f);\n+            assertEquals(Foo.x$get(foo), 3.14f, 0.001f);\n+            var bar = Bar.allocate(scope);\n+            Bar.x$set(bar, -42);\n+            assertEquals(Bar.x$get(bar), -42);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8252465\/LibTest8252465Test.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct Foo {\n+    float x;\n+};\n+\n+struct Bar {\n+    int x;\n+};\n","filename":"test\/jdk\/tools\/jextract\/test8252465\/test8252465.h","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+import static test.jextract.test8253102.test8253102_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8253102\n+ * @summary jextract should emit address to segment utility method on struct classes\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextract -l Test8253102 -t test.jextract.test8253102 -- test8253102.h\n+ * @run testng\/othervm -Dforeign.restricted=permit LibTest8253102Test\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @bug 8253102\n+ * @summary jextract should emit address to segment utility method on struct classes\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextractSources -l Test8253102 -t test.jextract.test8253102 -- test8253102.h\n+ * @run testng\/othervm -Dforeign.restricted=permit LibTest8253102Test\n+ *\/\n+public class LibTest8253102Test {\n+    @Test\n+    public void test() {\n+        MemoryAddress addr = make(14, 99);\n+        MemorySegment seg = Point.ofAddressRestricted(addr);\n+        assertEquals(Point.x$get(seg), 14);\n+        assertEquals(Point.y$get(seg), 99);\n+        CLinker.freeMemoryRestricted(addr);\n+        boolean caughtException = false;\n+        try {\n+            seg.close();\n+        } catch (UnsupportedOperationException uoe) {\n+            System.err.println(uoe);\n+            caughtException = true;\n+        }\n+        assertTrue(caughtException);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8253102\/LibTest8253102Test.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"test8253102.h\"\n+#include <stdlib.h>\n+\n+EXPORT Point* make(int x, int y) {\n+    Point* p = (Point*)malloc(sizeof(Point));\n+    p->x = x; p->y = y;\n+    return p;\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8253102\/libTest8253102.c","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+typedef struct Point {\n+    int x;\n+    int y;\n+} Point;\n+\n+EXPORT Point* make(int x, int y);\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/test8253102\/test8253102.h","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+import static jdk.incubator.foreign.CLinker.toJavaString;\n+import static test.jextract.test8253390.test8253390_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @bug 8253390\n+ * @summary jextract should quote string literals\n+ * @run driver JtregJextract -t test.jextract.test8253390 -- test8253390.h\n+ * @run testng\/othervm -Dforeign.restricted=permit LibTest8253390Test\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @bug 8253390\n+ * @summary jextract should quote string literals\n+ * @run driver JtregJextractSources -t test.jextract.test8253390 -- test8253390.h\n+ * @run testng\/othervm -Dforeign.restricted=permit LibTest8253390Test\n+ *\/\n+public class LibTest8253390Test {\n+    @Test\n+    public void testSquare() {\n+        assertEquals(toJavaString(GREETING()), \"hello\\nworld\");\n+        assertEquals(toJavaString(GREETING2()), \"hello\\tworld\");\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8253390\/LibTest8253390Test.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+#define GREETING \"hello\\nworld\"\n+#define GREETING2 \"hello\\tworld\"\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/test8253390\/test8253390.h","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+import static test.jextract.test8254983.test8254983_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @bug 8254983\n+ * @summary jextract fails to hande layout paths nested structs\/union\n+ * @run driver JtregJextract -t test.jextract.test8254983 -- test8254983.h\n+ * @run testng\/othervm -Dforeign.restricted=permit LibTest8254983Test\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @bug 8254983\n+ * @summary jextract fails to hande layout paths nested structs\/union\n+ * @run driver JtregJextractSources -t test.jextract.test8254983 -- test8254983.h\n+ * @run testng\/othervm -Dforeign.restricted=permit LibTest8254983Test\n+ *\/\n+public class LibTest8254983Test {\n+    @Test\n+    public void testOuterStruct() {\n+        assertEquals(((GroupLayout)Foo._struct.$LAYOUT()).memberLayouts().size(), 1);\n+        MemorySegment str = Foo._struct.allocate();\n+        Foo._struct.x$set(str, 42);\n+        assertEquals(Foo._struct.x$get(str), 42);\n+    }\n+\n+    @Test\n+    public void testInnerStruct() {\n+        assertEquals(((GroupLayout)Foo._union._struct.$LAYOUT()).memberLayouts().size(), 2);\n+        MemorySegment str = Foo._union._struct.allocate();\n+        Foo._union._struct.x$set(str, 42);\n+        assertEquals(Foo._union._struct.x$get(str), 42);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8254983\/LibTest8254983Test.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct Foo {\n+   struct {\n+       int x;\n+   } _struct;\n+\n+   union {\n+       struct {\n+           int u;\n+           int x;\n+       } _struct;\n+   } _union;\n+};\n","filename":"test\/jdk\/tools\/jextract\/test8254983\/test8254983.h","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.Method;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemoryLayout.PathElement;\n+import org.testng.annotations.Test;\n+\n+import test.jextract.unsupported.unsupported_h;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNull;\n+import static test.jextract.unsupported.unsupported_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextract -l Unsupported -t test.jextract.unsupported -- unsupported.h\n+ * @run testng\/othervm -Dforeign.restricted=permit LibUnsupportedTest\n+ *\/\n+\n+\/*\n+ * @test id=sources\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ *\n+ * @run driver JtregJextractSources -l Unsupported -t test.jextract.unsupported -- unsupported.h\n+ * @run testng\/othervm -Dforeign.restricted=permit LibUnsupportedTest\n+ *\/\n+\n+public class LibUnsupportedTest {\n+    @Test\n+    public void testAllocateFoo() {\n+        try (var seg = Foo.allocate()) {\n+            Foo.i$set(seg, 32);\n+            Foo.c$set(seg, (byte)'z');\n+            assertEquals(Foo.i$get(seg), 32);\n+            assertEquals(Foo.c$get(seg), (byte)'z');\n+        }\n+    }\n+\n+    @Test\n+    public void testGetFoo() {\n+        var seg = getFoo().asSegmentRestricted(Foo.sizeof());\n+        Foo.i$set(seg, 42);\n+        Foo.c$set(seg, (byte)'j');\n+        assertEquals(Foo.i$get(seg), 42);\n+        assertEquals(Foo.c$get(seg), (byte)'j');\n+    }\n+\n+    private static void checkField(GroupLayout group, String fieldName, MemoryLayout expected) {\n+        assertEquals(group.select(PathElement.groupElement(fieldName)), expected.withName(fieldName));\n+    }\n+\n+    @Test\n+    public void testFieldTypes() {\n+        GroupLayout g = (GroupLayout)Foo.$LAYOUT();\n+        checkField(g, \"i\", CLinker.C_INT);\n+        checkField(g, \"c\", CLinker.C_CHAR);\n+    }\n+\n+    @Test\n+    public void testIgnoredMethods() {\n+        assertNull(findMethod(unsupported_h.class, \"func\"));\n+        assertNull(findMethod(unsupported_h.class, \"func2\"));\n+        assertNull(findMethod(unsupported_h.class, \"func3\"));\n+        assertNull(findMethod(unsupported_h.class, \"func4\"));\n+        assertNull(findMethod(unsupported_h.class, \"makeFoo\"));\n+        assertNull(findMethod(unsupported_h.class, \"copyFoo\"));\n+    }\n+\n+    private Method findMethod(Class<?> cls, String name) {\n+        for (Method m : cls.getMethods()) {\n+            if (m.getName().equals(name)) {\n+                return m;\n+            }\n+        }\n+        return null;\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8257892\/LibUnsupportedTest.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"unsupported.h\"\n+\n+static Foo f = { 42, 343.55, 'j' };\n+\n+EXPORT Foo* getFoo() {\n+    return &f;\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8257892\/libUnsupported.c","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+typedef struct Foo {\n+    int i;\n+    long double ld;\n+    char c;\n+} Foo;\n+\n+EXPORT void func(long double ll);\n+EXPORT void func2(void (*f)(long double l));\n+EXPORT void func3(long double (*f)());\n+EXPORT void func4(void (*f)(Foo f));\n+EXPORT Foo* getFoo();\n+EXPORT Foo makeFoo();\n+EXPORT void copyFoo(Foo f1, Foo f2);\n+\n+long double ld;\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/test8257892\/unsupported.h","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct Foo {\n+  struct {\n+   long double dl;\n+  } x;\n+};\n","filename":"test\/jdk\/tools\/jextract\/test8258223.h","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+struct Foo {\n+  int (*bar)(float, double);\n+};\n+\n+void (*func)(int);\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/test8258405.h","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.NativeScope;\n+import org.testng.annotations.Test;\n+import test.jextract.test8258605.*;\n+import static jdk.incubator.foreign.MemoryAddress.NULL;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+import static test.jextract.test8258605.funcParam_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8258605\n+ * @summary regression: jextract can not handle function prototypes as function arguments\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextract -l FuncParam -t test.jextract.test8258605 -- funcParam.h\n+ * @run testng\/othervm -Dforeign.restricted=permit LibTest8258605Test\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @bug 8258605\n+ * @summary regression: jextract can not handle function prototypes as function arguments\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextractSources -l FuncParam -t test.jextract.test8258605 -- funcParam.h\n+ * @run testng\/othervm -Dforeign.restricted=permit LibTest8258605Test\n+ *\/\n+public class LibTest8258605Test {\n+    @Test\n+    public void testFunctionCallback() {\n+        try (var scope = NativeScope.unboundedScope()) {\n+             boolean[] callbackReached = new boolean[1];\n+             f(CB.allocate(i -> {\n+                 assertTrue(i == 10);\n+                 callbackReached[0] = true;\n+             }, scope));\n+             assertTrue(callbackReached[0]);\n+        }\n+    }\n+\n+    @Test\n+    public void testStructFunctionPointerCallback() {\n+        try (var scope = NativeScope.unboundedScope()) {\n+             boolean[] callbackReached = new boolean[1];\n+\n+             \/\/ get struct Foo instance\n+             var foo = getFoo();\n+             \/\/ make sure that foo.bar is not NULL\n+             assertFalse(Foo.bar$get(foo).equals(NULL));\n+\n+             f2(foo, CB.allocate(i -> {\n+                 assertTrue(i == 42);\n+                 callbackReached[0] = true;\n+             }, scope));\n+             assertTrue(callbackReached[0]);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8258605\/LibTest8258605Test.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+typedef void CB(int);\n+\n+EXPORT void f(CB x);\n+\n+struct Foo {\n+    void (*bar)(CB cb);\n+};\n+\n+\/* get initialised Foo struct instance *\/\n+EXPORT struct Foo getFoo();\n+\n+\/* first param should be initialized struct instance returned by getFoo *\/\n+EXPORT void f2(struct Foo foo, CB cb);\n","filename":"test\/jdk\/tools\/jextract\/test8258605\/funcParam.h","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"funcParam.h\"\n+\n+EXPORT void f(CB x) {\n+    x(10);\n+}\n+\n+static void barFunc(CB cb) {\n+    cb(42);\n+}\n+\n+static struct Foo theFoo;\n+\n+EXPORT struct Foo getFoo() {\n+    theFoo.bar = barFunc;\n+    return theFoo;\n+}\n+\n+EXPORT void f2(struct Foo foo, CB cb) {\n+    foo.bar(cb);\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8258605\/libFuncParam.c","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.NativeScope;\n+import org.testng.annotations.Test;\n+import test.jextract.test8259473.*;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+import static test.jextract.test8259473.test8259473_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8259473\n+ * @summary jextract generated code should throw exception for unfound native symbols from calls, variable access, set immediately\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextract -t test.jextract.test8259473 -- test8259473.h\n+ * @run testng\/othervm -Dforeign.restricted=permit LibTest8259473Test\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @bug 8259473\n+ * @summary jextract generated code should throw exception for unfound native symbols from calls, variable access, set immediately\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextractSources -t test.jextract.test8259473 -- test8259473.h\n+ * @run testng\/othervm -Dforeign.restricted=permit LibTest8259473Test\n+ *\/\n+public class LibTest8259473Test {\n+    @Test\n+    public void nullChecksTest() {\n+        try {\n+            func();\n+            throw new AssertionError(\"should not reach here\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            assertTrue(ule.getMessage().contains(\"unresolved symbol: func\"));\n+        }\n+\n+        try {\n+            func$MH();\n+            throw new AssertionError(\"should not reach here\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            assertTrue(ule.getMessage().contains(\"unresolved symbol: func\"));\n+        }\n+\n+        try {\n+            x$get();\n+            throw new AssertionError(\"should not reach here\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            assertTrue(ule.getMessage().contains(\"unresolved symbol: x\"));\n+        }\n+\n+        try {\n+            x$set(1);\n+            throw new AssertionError(\"should not reach here\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            assertTrue(ule.getMessage().contains(\"unresolved symbol: x\"));\n+        }\n+\n+        try {\n+            x$SEGMENT();\n+            throw new AssertionError(\"should not reach here\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            assertTrue(ule.getMessage().contains(\"unresolved symbol: x\"));\n+        }\n+\n+        try {\n+            y$SEGMENT();\n+            throw new AssertionError(\"should not reach here\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            assertTrue(ule.getMessage().contains(\"unresolved symbol: y\"));\n+        }\n+\n+        try {\n+            pt$SEGMENT();\n+            throw new AssertionError(\"should not reach here\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            assertTrue(ule.getMessage().contains(\"unresolved symbol: pt\"));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8259473\/LibTest8259473Test.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+void func();\n+extern int x;\n+extern int y[10];\n+\n+struct Point {\n+    int x;\n+    int y;\n+};\n+\n+extern struct Point pt;\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/test8259473\/test8259473.h","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+typedef void di_log_handler (const char *message, void *user_data);\n+di_log_handler di_log_handler_default;\n+\n+struct json_object;\n+typedef void (json_object_delete_fn)(struct json_object *jso, void *userdata);\n+json_object_delete_fn json_object_free_userdata;\n+\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/test8260344.h","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct Foo {\n+    int: 0;\n+    char c;\n+};\n+\n+struct Foo2 {\n+    int z;\n+    int: 16;\n+    int y:16;\n+    int w;\n+};\n+\n+struct Foo3 {\n+    int: 0;\n+    int: 32;\n+};\n+\n+struct Foo4 {\n+  int    a:3;\n+  int    b:2;\n+  int     :0; \/\/ Force alignment to next boundary.\n+  int    c:4;\n+  int    d:3;\n+};\n+\n+struct Foo5 {\n+  int    a:3;\n+  int    b:2;\n+  int    c:4;\n+  int    d:3;\n+};\n","filename":"test\/jdk\/tools\/jextract\/test8260705.h","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+typedef struct {\n+  short s;\n+  int i1:1;\n+  int i2:1;\n+  void* ptr;\n+} foo_t;\n","filename":"test\/jdk\/tools\/jextract\/test8260717.h","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct {\n+     unsigned : 6;\n+     unsigned r1 : 8;\n+     unsigned r2 : 1;\n+     unsigned r3 : 1;\n+} rab;\n+\n+struct {\n+   int y;\n+   short x;\n+   int r1 : 23;\n+   int r2 : 5;\n+} rab2;\n","filename":"test\/jdk\/tools\/jextract\/test8260929.h","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import test.jextract.test8261511.*;\n+import static org.testng.Assert.assertEquals;\n+import static test.jextract.test8261511.test8261511_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8261511\n+ * @summary jextract does not generate accessor for MemorySegement typed values\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextract -l Test8261511 -t test.jextract.test8261511 -- test8261511.h\n+ * @run testng\/othervm -Dforeign.restricted=permit Test8261511\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @bug 8261511\n+ * @summary jextract does not generate accessor for MemorySegement typed values\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextractSources -l Test8261511 -t test.jextract.test8261511 -- test8261511.h\n+ * @run testng\/othervm -Dforeign.restricted=permit Test8261511\n+ *\/\n+public class Test8261511 {\n+    @Test\n+    public void test() {\n+        var funcPtr = Foo.sum$get(get_foo());\n+        var sumIface = Foo.sum.ofAddressRestricted(funcPtr);\n+        assertEquals(sumIface.apply(15,20), 35);\n+        assertEquals(sum(1.2, 4.5), 5.7, 0.001);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8261511\/Test8261511.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"test8261511.h\"\n+#include <stdio.h>\n+\n+struct Foo theFoo;\n+\n+int foo_sum(int x, int y) {\n+    printf(\"foo_sum called\\n\");\n+    return x + y;\n+}\n+\n+EXPORT struct Foo get_foo() {\n+    theFoo.sum = foo_sum;\n+    return theFoo;\n+}\n+\n+EXPORT double sum(double x, double y) {\n+    printf(\"sum called\\n\");\n+    return x + y;\n+}\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/test8261511\/libTest8261511.c","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+struct Foo {\n+    int (*sum)(int x, int y);\n+};\n+\n+EXPORT struct Foo get_foo();\n+EXPORT double sum(double x, double y);\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/test8261511\/test8261511.h","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import org.testng.annotations.Test;\n+import jdk.incubator.foreign.MemorySegment;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @library .. \/test\/lib\n+ * @modules jdk.incubator.jextract\n+ * @build JextractToolRunner\n+ * @bug 8260929\n+ * @summary jextract crashes with Crossing storage unit boundaries\n+ * @run testng\/othervm -Dforeign.restricted=permit Test8261578\n+ *\/\n+public class Test8261578 extends JextractToolRunner {\n+    @Test\n+    public void test1() {\n+        Path outputPath = getOutputFilePath(\"output_1\");\n+        Path headerFile = getInputFilePath(\"test8261578_1.h\");\n+        run(\"-d\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        try(Loader loader = classLoader(outputPath)) {\n+            Class<?> ndpi_class = loader.loadClass(\"test8261578_1_h$ndpi_flow_tcp_struct\");\n+            assertNotNull(ndpi_class);\n+\n+            checkMethod(ndpi_class, \"gnutella_msg_id$slice\", MemorySegment.class, MemorySegment.class);\n+        } finally {\n+            deleteDir(outputPath);\n+        }\n+    }\n+\n+    @Test\n+    public void test2() {\n+        Path outputPath = getOutputFilePath(\"output_2\");\n+        Path headerFile = getInputFilePath(\"test8261578_2.h\");\n+        run(\"-d\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        try(Loader loader = classLoader(outputPath)) {\n+            Class<?> foo_class = loader.loadClass(\"test8261578_2_h$foo\");\n+            assertNotNull(foo_class);\n+\n+            checkMethod(foo_class, \"clear_color$slice\", MemorySegment.class, MemorySegment.class);\n+            checkMethod(foo_class, \"clear_z$get\", int.class, MemorySegment.class);\n+            checkMethod(foo_class, \"clear_z$set\", void.class, MemorySegment.class, int.class);\n+            checkMethod(foo_class, \"clear_s$get\", byte.class, MemorySegment.class);\n+            checkMethod(foo_class, \"clear_s$set\", void.class, MemorySegment.class, byte.class);\n+        } finally {\n+            deleteDir(outputPath);\n+        }\n+    }\n+\n+    @Test\n+    public void test3() {\n+        Path outputPath = getOutputFilePath(\"output_3\");\n+        Path headerFile = getInputFilePath(\"test8261578_3.h\");\n+        run(\"-d\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        try(Loader loader = classLoader(outputPath)) {\n+            Class<?> plugin_class = loader.loadClass(\"test8261578_3_h$PluginCodec_H323AudioG7231AnnexC\");\n+            assertNotNull(plugin_class);\n+\n+            checkMethod(plugin_class, \"maxAl_sduAudioFrames$get\", byte.class, MemorySegment.class);\n+            checkMethod(plugin_class, \"maxAl_sduAudioFrames$set\", void.class, MemorySegment.class, byte.class);\n+        } finally {\n+            deleteDir(outputPath);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8261578\/Test8261578.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct ndpi_flow_tcp_struct {\n+  char gnutella_msg_id[3];\n+  int irc_3a_counter:3;\n+  int irc_stage2:5;\n+  int irc_direction:2;\n+  int irc_0x1000_full:1;\n+  int soulseek_stage:2;\n+  int filetopia_stage:2;\n+  int tds_stage:3;\n+};\n","filename":"test\/jdk\/tools\/jextract\/test8261578\/test8261578_1.h","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct foo {\n+   int clear_color[2];\n+   int clear_z;\n+   char clear_s;\n+   int pad:24;\n+};\n","filename":"test\/jdk\/tools\/jextract\/test8261578\/test8261578_2.h","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct PluginCodec_H323AudioG7231AnnexC {\n+  unsigned char maxAl_sduAudioFrames;\n+  int silenceSuppression:1;\n+  int highRateMode0:6; \/\/ INTEGER (27..78), -- units octets\n+  int highRateMode1:6; \/\/ INTEGER (27..78), -- units octets\n+  int lowRateMode0:6; \/\/ INTEGER (23..66), -- units octets\n+  int lowRateMode1:6; \/\/ INTEGER (23..66), -- units octets\n+  int sidMode0:4; \/\/ INTEGER (6..17), -- units octets\n+  int sidMode1:4; \/\/ INTEGER (6..17), -- units octets\n+};\n","filename":"test\/jdk\/tools\/jextract\/test8261578\/test8261578_3.h","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+typedef struct {\n+  int x, y;\n+} permits;\n+\n+struct record {\n+  int foo;\n+};\n+\n+union sealed {\n+  float i;\n+  int j;\n+};\n+\n+struct var {\n+  int x;\n+};\n+\n+typedef struct {\n+  int bar;\n+} yield;\n+\n","filename":"test\/jdk\/tools\/jextract\/test8261893.h","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+union {\n+   struct {\n+      union {\n+         struct { int x; } inner;\n+      } u;\n+   } outer;\n+} u;\n+\n+\n+union {\n+    union {\n+       int x; long y;\n+    } v;\n+} v;\n","filename":"test\/jdk\/tools\/jextract\/test8262117.h","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+struct {\n+   int x, y;\n+} x;\n+\n+struct Foo {\n+   union {\n+       int i;\n+       float f;\n+   } x;\n+};\n+\n+struct seg {\n+  int x;\n+};\n+\n+struct index {\n+  int x;\n+};\n","filename":"test\/jdk\/tools\/jextract\/test8262733.h","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct String {\n+   int x, y;\n+};\n+\n+struct RuntimeHelper {\n+   int x;\n+};\n+\n+union MemorySegment {\n+   int x; float f;\n+};\n+\n+union MemoryAddress {\n+   long l; double d;\n+};\n+\n+typedef long MemoryLayout;\n+typedef double ValueLayout;\n","filename":"test\/jdk\/tools\/jextract\/test8262825.h","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct Odd {\n+   struct {\n+    int size;\n+    char data[];\n+   } before;\n+   struct {\n+     int a; int b;\n+   } after;\n+};\n","filename":"test\/jdk\/tools\/jextract\/test8262851.h","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,242 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ *          jdk.incubator.foreign\/jdk.incubator.foreign.unsafe\n+ *          jdk.incubator.foreign\/jdk.internal.foreign\n+ *          jdk.incubator.foreign\/jdk.internal.foreign.abi\n+ *          java.base\/sun.security.action\n+ * @library .. \/test\/lib\n+ * @build JextractToolRunner\n+ * @run testng\/othervm -Dforeign.restricted=permit -Duser.language=en TestClassGeneration\n+ *\/\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Method;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Path;\n+\n+import static java.lang.invoke.MethodType.methodType;\n+import static jdk.incubator.foreign.MemoryLayout.PathElement.sequenceElement;\n+import static jdk.incubator.foreign.CLinker.C_CHAR;\n+import static jdk.incubator.foreign.CLinker.C_DOUBLE;\n+import static jdk.incubator.foreign.CLinker.C_FLOAT;\n+import static jdk.incubator.foreign.CLinker.C_INT;\n+import static jdk.incubator.foreign.CLinker.C_LONG_LONG;\n+import static jdk.incubator.foreign.CLinker.C_SHORT;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+\n+public class TestClassGeneration extends JextractToolRunner {\n+\n+    private static final VarHandle VH_bytes = MemoryLayout.ofSequence(C_CHAR).varHandle(byte.class, sequenceElement());\n+\n+    private Path outputDir;\n+    private Loader loader;\n+    private Class<?> cls;\n+\n+    @DataProvider\n+    public static Object[][] simpleConstants() {\n+        return new Object[][]{\n+            { \"macro_byte\",         byte.class,   (byte) 1                         },\n+            { \"macro_short\",        short.class, (short) 1                         },\n+            { \"macro_int\",          int.class,           1                         },\n+            { \"macro_long\",         long.class,          1L                        },\n+            { \"macro_float\",        float.class,         1.0F                      },\n+            { \"macro_double\",       double.class,        1.0D                      },\n+            { \"macro_address_NULL\", MemoryAddress.class, MemoryAddress.NULL        },\n+            { \"macro_address_123\",  MemoryAddress.class, MemoryAddress.ofLong(123) },\n+            { \"enum_0\",             int.class,           0                         },\n+            { \"enum_1\",             int.class,           1                         },\n+            { \"enum_2\",             int.class,           2                         },\n+            { \"enum_anon_0\",        int.class,           0                         },\n+            { \"enum_anon_1\",        int.class,           1                         },\n+            { \"enum_anon_2\",        int.class,           2                         },\n+        };\n+    }\n+\n+    @DataProvider\n+    public static Object[][] stringConstants() {\n+        return new Object[][]{\n+            { \"macro_string\",         \"abc\"      },\n+            { \"macro_string_noident\", \"123.asdf\" },\n+        };\n+    }\n+\n+    private static final Object[] NO_ARGS = {};\n+\n+    @DataProvider\n+    public static Object[][] method() {\n+        return new Object[][]{\n+            { \"func_byte\",   methodType(byte.class),   (byte) 1,  NO_ARGS },\n+            { \"func_short\",  methodType(short.class), (short) 2,  NO_ARGS },\n+            { \"func_int\",    methodType(int.class),           3,  NO_ARGS },\n+            { \"func_long\",   methodType(long.class),          4L, NO_ARGS },\n+            { \"func_float\",  methodType(float.class),         5F, NO_ARGS },\n+            { \"func_double\", methodType(double.class),        6D, NO_ARGS },\n+        };\n+    }\n+\n+    @DataProvider\n+    public static Object[][] globals() {\n+        return new Object[][]{\n+            { \"global_byte\",   byte.class,   C_CHAR,   (byte) 1  },\n+            { \"global_short\",  short.class,  C_SHORT, (short) 2  },\n+            { \"global_int\",    int.class,    C_INT,           3  },\n+            { \"global_long\",   long.class,   C_LONG_LONG,      4L },\n+            { \"global_float\",  float.class,  C_FLOAT,         5F },\n+            { \"global_double\", double.class, C_DOUBLE,        6D },\n+        };\n+    }\n+\n+    @DataProvider\n+    public static Object[][] structMembers() {\n+        return new Object[][] {\n+            { \"Foo\", C_CHAR.withName(\"c\"),      byte.class,   (byte) 10  },\n+            { \"Foo\", C_SHORT.withName(\"s\"),     short.class, (short) 10  },\n+            { \"Foo\", C_INT.withName(\"i\"),       int.class,           10  },\n+            { \"Foo\", C_LONG_LONG.withName(\"ll\"), long.class,          10L },\n+            { \"Foo\", C_FLOAT.withName(\"f\"),     float.class,         10F },\n+            { \"Foo\", C_DOUBLE.withName(\"d\"),    double.class,        10D },\n+            { \"Bar\", C_INT.withName(\"a\"),       int.class,           10 },\n+            { \"Bar\", C_INT.withName(\"b\"),       int.class,           10 },\n+        };\n+    }\n+\n+    @DataProvider\n+    public static Object[][] functionalInterfaces() {\n+        return new Object[][]{\n+            { \"CB\", methodType(void.class, int.class) }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"simpleConstants\")\n+    public void testConstant(String name, Class<?> expectedType, Object expectedValue) throws Throwable {\n+        Method getter = checkMethod(cls, name, expectedType);\n+        assertEquals(getter.invoke(null), expectedValue);\n+    }\n+\n+    @Test(dataProvider = \"stringConstants\")\n+    public void testStringConstant(String name, String expectedValue) throws Throwable {\n+        Method getter = checkMethod(cls, name, MemorySegment.class);\n+        MemorySegment actual = (MemorySegment) getter.invoke(null);\n+        byte[] expected = expectedValue.getBytes(StandardCharsets.UTF_8);\n+        assertEquals(actual.byteSize(), expected.length + 1);\n+        for (int i = 0; i < expected.length; i++) {\n+            assertEquals((byte) VH_bytes.get(actual, (long) i), expected[i]);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"method\")\n+    public void testMethod(String name, MethodType expectedType, Object expectedReturn, Object[] args) throws Throwable {\n+        Method mh_getter = checkMethod(cls, name + \"$MH\", MethodHandle.class);\n+        MethodHandle mh = (MethodHandle) mh_getter.invoke(null);\n+        assertEquals(mh.type(), expectedType);\n+\n+        Object actualReturn = mh.invokeWithArguments(args);\n+        assertEquals(actualReturn.getClass(), expectedReturn.getClass());\n+        assertEquals(actualReturn, expectedReturn);\n+\n+        Method func = checkMethod(cls, name, expectedType);\n+        assertEquals(func.invoke(null, args), expectedReturn);\n+    }\n+\n+    @Test(dataProvider = \"globals\")\n+    public void testGlobal(String name, Class<?> expectedType, MemoryLayout expectedLayout, Object expectedValue) throws Throwable {\n+        Method layout_getter = checkMethod(cls, name + \"$LAYOUT\", MemoryLayout.class);\n+        assertEquals(layout_getter.invoke(null), expectedLayout);\n+\n+        Method addr_getter = checkMethod(cls, name + \"$SEGMENT\", MemorySegment.class);\n+        MemorySegment segment = (MemorySegment)addr_getter.invoke(null);\n+\n+        Method vh_getter = checkMethod(cls, name + \"$VH\", VarHandle.class);\n+        VarHandle vh = (VarHandle) vh_getter.invoke(null);\n+        assertEquals(vh.varType(), expectedType);\n+        assertEquals(vh.get(segment), expectedValue);\n+\n+        checkMethod(cls, name + \"$get\", expectedType);\n+        checkMethod(cls, name + \"$set\", void.class, expectedType);\n+    }\n+\n+    @Test(dataProvider = \"structMembers\")\n+    public void testStructMember(String structName, MemoryLayout memberLayout, Class<?> expectedType, Object testValue) throws Throwable {\n+        String memberName = memberLayout.name().orElseThrow();\n+\n+        Class<?> structCls = loader.loadClass(\"com.acme.examples_h$\" + structName);\n+        Method layout_getter = checkMethod(structCls, \"$LAYOUT\", MemoryLayout.class);\n+        MemoryLayout structLayout = (MemoryLayout) layout_getter.invoke(null);\n+        try (MemorySegment struct = MemorySegment.allocateNative(structLayout)) {\n+            Method vh_getter = checkMethod(structCls, memberName + \"$VH\", VarHandle.class);\n+            VarHandle vh = (VarHandle) vh_getter.invoke(null);\n+            assertEquals(vh.varType(), expectedType);\n+\n+            Method getter = checkMethod(structCls, memberName + \"$get\", expectedType, MemorySegment.class);\n+            Method setter = checkMethod(structCls, memberName + \"$set\", void.class, MemorySegment.class, expectedType);\n+            MemorySegment addr = struct;\n+            setter.invoke(null, addr, testValue);\n+            assertEquals(getter.invoke(null, addr), testValue);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"functionalInterfaces\")\n+    public void testFunctionalInterface(String name, MethodType type) {\n+        Class<?> fiClass = findNestedClass(cls, name);\n+        assertNotNull(fiClass);\n+        checkMethod(fiClass, \"apply\", type);\n+        checkMethod(fiClass, \"allocate\", MemorySegment.class, fiClass);\n+    }\n+\n+    @BeforeClass\n+    public void setup() {\n+        outputDir = getOutputFilePath(\"exmples_out\");\n+        Path inputHeader = getInputFilePath(\"examples.h\");\n+        run(\n+            \"-t\", \"com.acme\",\n+            \"-d\", outputDir,\n+            \"-l\", \"Examples\",\n+            \"--\",\n+            inputHeader\n+        ).checkSuccess();\n+        loader = classLoader(outputDir);\n+        cls = loader.loadClass(\"com.acme.examples_h\");\n+    }\n+\n+    @AfterClass\n+    public void tearDown() {\n+        loader.close();\n+        deleteDir(outputDir);\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jextract\/testClassGen\/TestClassGeneration.java","additions":242,"deletions":0,"binary":false,"changes":242,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+#define macro_byte (char) 1\n+#define macro_short (short) 1\n+#define macro_int 1\n+#define macro_long 1LL\n+#define macro_float 1.0F\n+#define macro_double 1.0\n+#define macro_address_NULL (void*) 0\n+#define macro_address_123 (void*) 123\n+#define macro_string \"abc\"\n+#define macro_string_noident \"123.asdf\"\n+\n+EXPORT char func_byte(void);\n+EXPORT short func_short(void);\n+EXPORT int func_int(void);\n+EXPORT long long func_long(void);\n+EXPORT float func_float(void);\n+EXPORT double func_double(void);\n+\n+EXPORT extern char global_byte;\n+EXPORT extern short global_short;\n+EXPORT extern int global_int;\n+EXPORT extern long long global_long;\n+EXPORT extern float global_float;\n+EXPORT extern double global_double;\n+\n+typedef void(*CB)(int);\n+EXPORT void func_cb(CB cb);\n+\n+struct Foo {\n+    char c;\n+    short s;\n+    int i;\n+    long long ll;\n+    float f;\n+    double d;\n+};\n+\n+typedef struct {\n+    int a;\n+    int b;\n+} Bar;\n+\n+enum Enum {\n+    enum_0,\n+    enum_1,\n+    enum_2,\n+};\n+\n+enum {\n+    enum_anon_0,\n+    enum_anon_1,\n+    enum_anon_2,\n+};\n\\ No newline at end of file\n","filename":"test\/jdk\/tools\/jextract\/testClassGen\/examples.h","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"examples.h\"\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT char func_byte(void) { return 1; }\n+EXPORT short func_short(void) { return 2; }\n+EXPORT int func_int(void) { return 3; }\n+EXPORT long long func_long(void) { return 4; }\n+EXPORT float func_float(void) { return 5; }\n+EXPORT double func_double(void) { return 6; }\n+\n+EXPORT char global_byte = 1;\n+EXPORT short global_short = 2;\n+EXPORT int global_int = 3;\n+EXPORT long long global_long = 4;\n+EXPORT float global_float = 5;\n+EXPORT double global_double = 6;\n+\n+EXPORT void func_cb(CB cb) {\n+    cb(1);\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/tools\/jextract\/testClassGen\/libExamples.c","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static test.jextract.fp.funcPtr_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextract -l FuncPtr -t test.jextract.fp -- funcPtr.h\n+ * @run testng\/othervm -Dforeign.restricted=permit LibFuncPtrTest\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextractSources -l FuncPtr -t test.jextract.fp -- funcPtr.h\n+ * @run testng\/othervm -Dforeign.restricted=permit LibFuncPtrTest\n+ *\/\n+public class LibFuncPtrTest {\n+    @Test\n+    public void test() {\n+        try (var handle = func$f.allocate(x -> x*x)) {\n+            assertEquals(func(handle, 35), 35 * 35 + 35);\n+        } \/\/deallocate\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/testFunctionPointer\/LibFuncPtrTest.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT int func(int (*f)(int), int);\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/testFunctionPointer\/funcPtr.h","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"funcPtr.h\"\n+\n+EXPORT int func(int (*f)(int), int x) {\n+    return x + f(x);\n+}\n","filename":"test\/jdk\/tools\/jextract\/testFunctionPointer\/libFuncPtr.c","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import test.jextract.redef.*;\n+\n+import java.lang.reflect.Method;\n+\n+import static org.testng.Assert.assertEquals;\n+import static test.jextract.redef.redef_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextract -t test.jextract.redef -- redef.h\n+ * @run testng\/othervm -Dforeign.restricted=permit TestGlobalRedefinition\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextractSources -t test.jextract.redef -- redef.h\n+ * @run testng\/othervm -Dforeign.restricted=permit TestGlobalRedefinition\n+ *\/\n+public class TestGlobalRedefinition {\n+    @Test\n+    public void test() throws Throwable {\n+        Method mGet = redef_h.class.getMethod(\"x$get\");\n+        assertEquals(mGet.getReturnType(), int.class);\n+\n+        Method mSet = redef_h.class.getMethod(\"x$set\", int.class);\n+        assertEquals(mSet.getParameterTypes()[0], int.class);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/testGlobalRedefinition\/TestGlobalRedefinition.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+typedef int MyInt;\n+\n+extern const int x;\n+extern const MyInt x;\n","filename":"test\/jdk\/tools\/jextract\/testGlobalRedefinition\/redef.h","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemoryLayout.PathElement;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static test.jextract.struct.struct_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextract -l Struct -t test.jextract.struct -- struct.h\n+ * @run testng\/othervm -Dforeign.restricted=permit LibStructTest\n+ *\/\n+\n+\/*\n+ * @test id=sources\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ *\n+ * @run driver JtregJextractSources -l Struct -t test.jextract.struct -- struct.h\n+ * @run testng\/othervm -Dforeign.restricted=permit LibStructTest\n+ *\/\n+\n+public class LibStructTest {\n+    @Test\n+    public void testMakePoint() {\n+        try (var seg = makePoint(42, -39)) {\n+            assertEquals(Point.x$get(seg), 42);\n+            assertEquals(Point.y$get(seg), -39);\n+        }\n+    }\n+\n+    @Test\n+    public void testAllocate() {\n+        try (var seg = Point.allocate()) {\n+            Point.x$set(seg, 56);\n+            Point.y$set(seg, 65);\n+            assertEquals(Point.x$get(seg), 56);\n+            assertEquals(Point.y$get(seg), 65);\n+        }\n+    }\n+\n+    @Test\n+    public void testAllocateArray() {\n+        try (var seg = Point.allocateArray(3)) {\n+            for (int i = 0; i < 3; i++) {\n+                Point.x$set(seg, i, 56 + i);\n+                Point.y$set(seg, i, 65 + i);\n+            }\n+            for (int i = 0; i < 3; i++) {\n+                assertEquals(Point.x$get(seg, i), 56 + i);\n+                assertEquals(Point.y$get(seg, i), 65 + i);\n+            }\n+        }\n+    }\n+\n+    private static void checkField(GroupLayout group, String fieldName, MemoryLayout expected) {\n+        assertEquals(group.select(PathElement.groupElement(fieldName)), expected.withName(fieldName));\n+    }\n+\n+    @Test\n+    public void testFieldTypes() {\n+        GroupLayout g = (GroupLayout)AllTypes.$LAYOUT();\n+        checkField(g, \"sc\", CLinker.C_CHAR);\n+        checkField(g, \"uc\", CLinker.C_CHAR);\n+        checkField(g, \"s\",  CLinker.C_SHORT);\n+        checkField(g, \"us\", CLinker.C_SHORT);\n+        checkField(g, \"i\",  CLinker.C_INT);\n+        checkField(g, \"ui\", CLinker.C_INT);\n+        checkField(g, \"l\",  CLinker.C_LONG);\n+        checkField(g, \"ul\", CLinker.C_LONG);\n+        checkField(g, \"ll\", CLinker.C_LONG_LONG);\n+        checkField(g, \"ull\",CLinker.C_LONG_LONG);\n+        checkField(g, \"f\",  CLinker.C_FLOAT);\n+        checkField(g, \"d\",  CLinker.C_DOUBLE);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/testStruct\/LibStructTest.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"struct.h\"\n+\n+EXPORT Point makePoint(int x, int y) {\n+    Point pt = { x, y };\n+    return pt;\n+}\n","filename":"test\/jdk\/tools\/jextract\/testStruct\/libStruct.c","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+typedef struct Point {\n+    int x;\n+    int y;\n+} Point;\n+\n+EXPORT Point makePoint(int x, int y);\n+\n+struct AllTypes {\n+    signed char sc;\n+    unsigned char uc;\n+    short s;\n+    unsigned short us;\n+    int i;\n+    unsigned int ui;\n+    long l;\n+    unsigned long ul;\n+    long long ll;\n+    unsigned long long ull;\n+    float f;\n+    double d;\n+    long double ld;\n+};\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/testStruct\/struct.h","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.nio.file.Path;\n+\n+\/*\n+ * @test\n+ * @library .. \/test\/lib\n+ * @modules jdk.incubator.jextract\n+ * @build JextractToolRunner\n+ * @bug 8249301\n+ * @summary jextract fails with CCE when encountering a typedefdecl whose type is FunctionProto\n+ * @run testng\/othervm -Dforeign.restricted=permit TestTypedefIsFunctionProto\n+ *\/\n+public class TestTypedefIsFunctionProto extends JextractToolRunner {\n+    @Test\n+    public void testVoidTypedef() {\n+        Path outputPath = getOutputFilePath(\"outputTDIFP\");\n+        Path headerFile = getInputFilePath(\"funcproto.h\");\n+        run(\"-d\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        \/\/ nothing is generated that we can check, so we just check that jextract ran successfully\n+        deleteDir(outputPath);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/testTypedefIsFunctionProto\/TestTypedefIsFunctionProto.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+typedef void __stdcall foo();\n","filename":"test\/jdk\/tools\/jextract\/testTypedefIsFunctionProto\/funcproto.h","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+typedef char byte_t;\n+typedef long mysize_t;\n+typedef long MYSIZE_T;\n","filename":"test\/jdk\/tools\/jextract\/typedefs.h","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+typedef union {\n+    int i;\n+    float f;\n+} IntOrFloat;\n+\n+void func(IntOrFloat* value);\n","filename":"test\/jdk\/tools\/jextract\/uniondecl.h","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -154,0 +154,2 @@\n+        \/\/ Panama\n+        new ToolHelpSpec(\"jextract\"    ,1,   1,   1,   0,         1,    1,   1),       \/\/ -?, -h, --help -help, Documents -help\n","filename":"test\/jdk\/tools\/launcher\/HelpFlagsTest.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -84,0 +84,1 @@\n+        \"jextract\",\n","filename":"test\/jdk\/tools\/launcher\/VersionCheck.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}