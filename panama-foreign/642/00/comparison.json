{"files":[{"patch":"@@ -49,1 +49,1 @@\n-    private final OptionalLong size;\n+    private final long size;\n@@ -55,1 +55,1 @@\n-    public AbstractLayout(OptionalLong size, long alignment, Optional<String> name) {\n+    public AbstractLayout(long size, long alignment, Optional<String> name) {\n@@ -111,5 +111,0 @@\n-    @Override\n-    public boolean hasSize() {\n-        return size.isPresent();\n-    }\n-\n@@ -118,9 +113,1 @@\n-        return size.orElseThrow(AbstractLayout::badSizeException);\n-    }\n-\n-    static OptionalLong optSize(MemoryLayout layout) {\n-        return ((AbstractLayout)layout).size;\n-    }\n-\n-    private static UnsupportedOperationException badSizeException() {\n-        return new UnsupportedOperationException(\"Cannot compute size of a layout which is, or depends on a sequence layout with unspecified size\");\n+        return size;\n@@ -153,1 +140,1 @@\n-        return size.isPresent() && size.getAsLong() == alignment;\n+        return size == alignment;\n@@ -204,3 +191,0 @@\n-    static final MethodHandleDesc MH_UNSIZED_SEQUENCE = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_MEMORY_LAYOUT, \"sequenceLayout\",\n-                MethodTypeDesc.of(CD_SEQUENCE_LAYOUT, CD_MEMORY_LAYOUT));\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/AbstractLayout.java","additions":4,"deletions":20,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-        OptionalLong sizeof(List<MemoryLayout> elems) {\n+        long sizeof(List<MemoryLayout> elems) {\n@@ -91,5 +91,1 @@\n-                if (AbstractLayout.optSize(elem).isPresent()) {\n-                    size = sizeOp.applyAsLong(size, elem.bitSize());\n-                } else {\n-                    return OptionalLong.empty();\n-                }\n+                size = sizeOp.applyAsLong(size, elem.bitSize());\n@@ -97,1 +93,1 @@\n-            return OptionalLong.of(size);\n+            return size;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/GroupLayout.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.util.OptionalLong;\n@@ -94,1 +93,1 @@\n- *     <li>for a <em>finite<\/em> sequence layout <em>S<\/em> whose element layout is <em>E<\/em> and size is L,\n+ *     <li>for a sequence layout <em>S<\/em> whose element layout is <em>E<\/em> and size is L,\n@@ -96,1 +95,0 @@\n- *     <li>the size of an <em>unbounded<\/em> sequence layout is <em>unknown<\/em><\/li>\n@@ -208,11 +206,0 @@\n-    \/**\n-     * Returns {@code true} if this layout has a specified size. A layout does not have a specified size if it is (or contains) a sequence layout whose\n-     * size is unspecified (see {@link SequenceLayout#elementCount()}).\n-     *\n-     * Value layouts (see {@link ValueLayout}) and padding layouts (see {@link MemoryLayout#paddingLayout(long)})\n-     * <em>always<\/em> have a specified size, therefore this method always returns {@code true} in these cases.\n-     *\n-     * @return {@code true}, if this layout has a specified size.\n-     *\/\n-    boolean hasSize();\n-\n@@ -221,1 +208,0 @@\n-     * @throws UnsupportedOperationException if the layout is, or contains, a sequence layout with unspecified size (see {@link SequenceLayout}).\n@@ -227,2 +213,1 @@\n-     * @throws UnsupportedOperationException if the layout is, or contains, a sequence layout with unspecified size (see {@link SequenceLayout}),\n-     * or if {@code bitSize()} is not a multiple of 8.\n+     * @throws UnsupportedOperationException if {@code bitSize()} is not a multiple of 8.\n@@ -305,1 +290,0 @@\n-     * @throws UnsupportedOperationException if one of the layouts traversed by the layout path has unspecified size.\n@@ -340,1 +324,0 @@\n-     * @throws UnsupportedOperationException if one of the layouts traversed by the layout path has unspecified size.\n@@ -356,2 +339,1 @@\n-     * @throws UnsupportedOperationException if one of the layouts traversed by the layout path has unspecified size,\n-     * or if {@code bitOffset(elements)} is not a multiple of 8.\n+     * @throws UnsupportedOperationException if {@code bitOffset(elements)} is not a multiple of 8.\n@@ -395,1 +377,0 @@\n-     * @throws UnsupportedOperationException if one of the layouts traversed by the layout path has unspecified size.\n@@ -423,1 +404,1 @@\n-     * and {@code s_0}, {@code s_1}, ... {@code s_n} are <em>static<\/em> stride constants which are derived from\n+     * and {@code s_1}, {@code s_2}, ... {@code s_n} are <em>static<\/em> stride constants which are derived from\n@@ -432,2 +413,1 @@\n-     * @throws UnsupportedOperationException if the layout path has one or more elements with incompatible alignment constraints,\n-     * or if one of the layouts traversed by the layout path has unspecified size.\n+     * @throws UnsupportedOperationException if the layout path has one or more elements with incompatible alignment constraints.\n@@ -441,0 +421,24 @@\n+    \/**\n+     * Creates a <em>strided<\/em> memory access var handle that can be used to dereference memory at the layout selected by a given layout path,\n+     * where the path is considered rooted in this layout. The returned var handle can effectively dereference multiple memory\n+     * locations, using a <em>dynamic<\/em> index (of type {@code long}), which is multiplied by this layout size and then added\n+     * to the offset of the selected layout. Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * MemoryLayout.sequenceLayout(Long.MAX_VALUE, this)\n+     *             .varHandle(PathElement.sequenceElement());\n+     * }\n+     *\n+     * @param elements the layout path elements.\n+     * @return a var handle which can be used to dereference memory at the (possibly nested) layout selected by the layout path in {@code elements}.\n+     * @throws UnsupportedOperationException if the layout path has one or more elements with incompatible alignment constraints.\n+     * @throws IllegalArgumentException if the layout path in {@code elements} does not select a value layout (see {@link ValueLayout}).\n+     *\/\n+    default VarHandle arrayElementVarHandle(PathElement... elements) {\n+        Objects.requireNonNull(elements);\n+        PathElement[] newElements = new PathElement[elements.length + 1];\n+        newElements[0] = PathElement.sequenceElement();\n+        System.arraycopy(elements, 0, newElements, 1, elements.length);\n+        return computePathOp(LayoutPath.rootPath(MemoryLayout.sequenceLayout(Long.MAX_VALUE, this), MemoryLayout::bitSize),\n+                LayoutPath::dereferenceHandle, Set.of(), newElements);\n+    }\n+\n@@ -461,1 +465,1 @@\n-     * and {@code s_0}, {@code s_1}, ... {@code s_n} are <em>static<\/em> stride constants which are derived from\n+     * and {@code s_1}, {@code s_2}, ... {@code s_n} are <em>static<\/em> stride constants which are derived from\n@@ -484,0 +488,24 @@\n+    \/**\n+     * Creates a <em>strided<\/em> method handle which, given a memory segment, returns a {@linkplain MemorySegment#asSlice(long,long) slice}\n+     * corresponding to the layout selected by a given layout path, where the path is considered rooted in this layout.\n+     * The returned method handle can effectively slice a given memory segment at multiple starting offsets, using a <em>dynamic<\/em> index\n+     * (of type {@code long}), which is multiplied by this layout size and then added to the offset of the selected layout.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * MemoryLayout.sequenceLayout(Long.MAX_VALUE, this)\n+     *             .varHandle(PathElement.sequenceElement());\n+     * }\n+     *\n+     * @param elements the layout path elements.\n+     * @return a method handle which can be used to create a slice of the selected layout element, given a segment.\n+     * @throws UnsupportedOperationException if the size of the selected layout in bits is not a multiple of 8.\n+     *\/\n+    default MethodHandle arrayElementSliceHandle(PathElement... elements) {\n+        Objects.requireNonNull(elements);\n+        PathElement[] newElements = new PathElement[elements.length + 1];\n+        newElements[0] = PathElement.sequenceElement();\n+        System.arraycopy(elements, 0, newElements, 1, elements.length);\n+        return computePathOp(LayoutPath.rootPath(MemoryLayout.sequenceLayout(Long.MAX_VALUE, this), MemoryLayout::bitSize),\n+                LayoutPath::sliceHandle, Set.of(), newElements);\n+    }\n+\n@@ -729,12 +757,1 @@\n-        OptionalLong size = OptionalLong.of(elementCount);\n-        return new SequenceLayout(size, Objects.requireNonNull(elementLayout));\n-    }\n-\n-    \/**\n-     * Create a new sequence layout, with unbounded element count and given element layout.\n-     *\n-     * @param elementLayout the element layout of the sequence layout.\n-     * @return the new sequence layout with given element layout.\n-     *\/\n-    static SequenceLayout sequenceLayout(MemoryLayout elementLayout) {\n-        return new SequenceLayout(OptionalLong.empty(), Objects.requireNonNull(elementLayout));\n+        return new SequenceLayout(elementCount, Objects.requireNonNull(elementLayout));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":55,"deletions":38,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-        super(OptionalLong.of(size), alignment, name);\n+        super(size, alignment, name);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/PaddingLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,3 +37,3 @@\n- * The repetition count, where it exists (e.g. for <em>finite<\/em> sequence layouts) is said to be the sequence layout's <em>element count<\/em>.\n- * A finite sequence layout can be thought of as a group layout where the sequence layout's element layout is repeated a number of times\n- * that is equal to the sequence layout's element count. In other words this layout:\n+ * The repetition count is said to be the sequence layout's <em>element count<\/em>. A finite sequence can be thought of as a\n+ * group layout where the sequence layout's element layout is repeated a number of times that is equal to the sequence\n+ * layout's element count. In other words this layout:\n@@ -73,1 +73,1 @@\n-    private final OptionalLong elemCount;\n+    private final long elemCount;\n@@ -76,1 +76,1 @@\n-    SequenceLayout(OptionalLong elemCount, MemoryLayout elementLayout) {\n+    SequenceLayout(long elemCount, MemoryLayout elementLayout) {\n@@ -80,4 +80,2 @@\n-    SequenceLayout(OptionalLong elemCount, MemoryLayout elementLayout, long alignment, Optional<String> name) {\n-        super(elemCount.isPresent() && AbstractLayout.optSize(elementLayout).isPresent() ?\n-                OptionalLong.of(elemCount.getAsLong() * elementLayout.bitSize()) :\n-                OptionalLong.empty(), alignment, name);\n+    SequenceLayout(long elemCount, MemoryLayout elementLayout, long alignment, Optional<String> name) {\n+        super(elemCount * elementLayout.bitSize(), alignment, name);\n@@ -98,1 +96,1 @@\n-    public OptionalLong elementCount() {\n+    public long elementCount() {\n@@ -111,1 +109,1 @@\n-        return new SequenceLayout(OptionalLong.of(elementCount), elementLayout, alignment, name());\n+        return new SequenceLayout(elementCount, elementLayout, alignment, name());\n@@ -152,3 +150,0 @@\n-        if (elementCount().isEmpty()) {\n-            throw new UnsupportedOperationException(\"Cannot reshape a sequence layout whose element count is unspecified\");\n-        }\n@@ -156,1 +151,1 @@\n-        long expectedCount = flat.elementCount().getAsLong();\n+        long expectedCount = flat.elementCount();\n@@ -211,4 +206,1 @@\n-        if (elementCount().isEmpty()) {\n-            throw badUnboundSequenceLayout();\n-        }\n-        long count = elementCount().getAsLong();\n+        long count = elementCount();\n@@ -217,1 +209,1 @@\n-            count = count * elemSeq.elementCount().orElseThrow(this::badUnboundSequenceLayout);\n+            count = count * elemSeq.elementCount();\n@@ -223,4 +215,0 @@\n-    private UnsupportedOperationException badUnboundSequenceLayout() {\n-        return new UnsupportedOperationException(\"Cannot flatten a sequence layout whose element count is unspecified\");\n-    }\n-\n@@ -230,1 +218,1 @@\n-                elemCount.isPresent() ? elemCount.getAsLong() : \"\", elementLayout));\n+                elemCount, elementLayout));\n@@ -244,1 +232,1 @@\n-        return elemCount.equals(s.elemCount) && elementLayout.equals(s.elementLayout);\n+        return elemCount == s.elemCount && elementLayout.equals(s.elementLayout);\n@@ -264,3 +252,1 @@\n-        return Optional.of(decorateLayoutConstant(elemCount.isPresent() ?\n-                DynamicConstantDesc.ofNamed(ConstantDescs.BSM_INVOKE, \"value\",\n-                        CD_SEQUENCE_LAYOUT, MH_SIZED_SEQUENCE, elemCount.getAsLong(), elementLayout.describeConstable().get()) :\n+        return Optional.of(decorateLayoutConstant(\n@@ -268,1 +254,1 @@\n-                        CD_SEQUENCE_LAYOUT, MH_UNSIZED_SEQUENCE, elementLayout.describeConstable().get())));\n+                        CD_SEQUENCE_LAYOUT, MH_SIZED_SEQUENCE, elemCount, elementLayout.describeConstable().get())));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SequenceLayout.java","additions":16,"deletions":30,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-        super(OptionalLong.of(size), alignment, name);\n+        super(size, alignment, name);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -223,5 +223,1 @@\n-            if (seq.elementCount().isPresent()) {\n-                return enclosing.map(l -> dup(l, MemoryLayout.sequenceLayout(seq.elementCount().getAsLong(), newLayout)));\n-            } else {\n-                return enclosing.map(l -> dup(l, MemoryLayout.sequenceLayout(newLayout)));\n-            }\n+            return enclosing.map(l -> dup(l, MemoryLayout.sequenceLayout(seq.elementCount(), newLayout)));\n@@ -245,1 +241,1 @@\n-            newLayout.withName(oldLayout.name().get());\n+            newLayout = newLayout.withName(oldLayout.name().get());\n@@ -269,2 +265,2 @@\n-        if (seq.elementCount().isPresent() && index >= seq.elementCount().getAsLong()) {\n-            throw badLayoutPath(String.format(\"Sequence index out of bound; found: %d, size: %d\", index, seq.elementCount().getAsLong()));\n+        if (index >= seq.elementCount()) {\n+            throw badLayoutPath(String.format(\"Sequence index out of bound; found: %d, size: %d\", index, seq.elementCount()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -148,1 +148,1 @@\n-        if (ar.elementCount().orElseThrow() == 0) {\n+        if (ar.elementCount() == 0) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -216,1 +216,1 @@\n-            for (long i = 0 ; i < seq.elementCount().getAsLong() ; i++) {\n+            for (long i = 0 ; i < seq.elementCount() ; i++) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/TypeClass.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.lang.foreign.MemoryLayout;\n@@ -88,2 +87,1 @@\n-    static final VarHandle intHandleIndexed = MemoryLayout.sequenceLayout(ValueLayout.JAVA_INT)\n-            .varHandle(MemoryLayout.PathElement.sequenceElement());\n+    static final VarHandle intHandleIndexed = ValueLayout.JAVA_INT.arrayElementVarHandle();\n","filename":"test\/jdk\/java\/foreign\/TestAdaptVarHandles.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.foreign.MemoryLayout;\n@@ -278,4 +277,2 @@\n-        VarHandle indexedHandleNO = MemoryLayout.sequenceLayout(helper.elementLayout.withOrder(NATIVE_ORDER))\n-                                                .varHandle(MemoryLayout.PathElement.sequenceElement());\n-        VarHandle indexedHandleNNO = MemoryLayout.sequenceLayout(helper.elementLayout.withOrder(NON_NATIVE_ORDER))\n-                                                 .varHandle(MemoryLayout.PathElement.sequenceElement());\n+        VarHandle indexedHandleNO = helper.elementLayout.withOrder(NATIVE_ORDER).arrayElementVarHandle();\n+        VarHandle indexedHandleNNO = helper.elementLayout.withOrder(NON_NATIVE_ORDER).arrayElementVarHandle();\n","filename":"test\/jdk\/java\/foreign\/TestArrayCopy.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-        for (long i = 0; i < seq.elementCount().getAsLong() ; i++) {\n+        for (long i = 0; i < seq.elementCount() ; i++) {\n@@ -100,1 +100,1 @@\n-        int nelems = (int)layout.elementCount().getAsLong();\n+        int nelems = (int)layout.elementCount();\n","filename":"test\/jdk\/java\/foreign\/TestArrays.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-        for (long i = 0; i < seq.elementCount().getAsLong() ; i++) {\n+        for (long i = 0; i < seq.elementCount() ; i++) {\n@@ -174,1 +174,1 @@\n-        long nelems = layout.elementCount().getAsLong();\n+        long nelems = layout.elementCount();\n@@ -199,1 +199,1 @@\n-            initTuples(segment, tuples.elementCount().getAsLong());\n+            initTuples(segment, tuples.elementCount());\n@@ -202,1 +202,1 @@\n-            checkTuples(segment, bb, tuples.elementCount().getAsLong());\n+            checkTuples(segment, bb, tuples.elementCount());\n@@ -210,1 +210,1 @@\n-        initTuples(region, tuples.elementCount().getAsLong());\n+        initTuples(region, tuples.elementCount());\n@@ -213,1 +213,1 @@\n-        checkTuples(region, bb, tuples.elementCount().getAsLong());\n+        checkTuples(region, bb, tuples.elementCount());\n@@ -226,1 +226,1 @@\n-                initTuples(segment, tuples.elementCount().getAsLong());\n+                initTuples(segment, tuples.elementCount());\n@@ -235,1 +235,1 @@\n-                checkTuples(segment, mbb, tuples.elementCount().getAsLong());\n+                checkTuples(segment, mbb, tuples.elementCount());\n@@ -262,1 +262,1 @@\n-            initTuples(segment, tuples.elementCount().getAsLong());\n+            initTuples(segment, tuples.elementCount());\n@@ -269,1 +269,1 @@\n-            checkTuples(segment, segment.asByteBuffer(), tuples.elementCount().getAsLong());\n+            checkTuples(segment, segment.asByteBuffer(), tuples.elementCount());\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -86,1 +86,0 @@\n-            testValues.add(MemoryLayout.sequenceLayout(ml));\n","filename":"test\/jdk\/java\/foreign\/TestCondy.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -71,2 +71,2 @@\n-                    FunctionDescriptor.of(MemoryLayout.sequenceLayout(C_INT)),\n-                    \"Unsupported layout: [:i32]\"\n+                    FunctionDescriptor.of(MemoryLayout.sequenceLayout(2, C_INT)),\n+                    \"Unsupported layout: [2:i32]\"\n@@ -75,2 +75,2 @@\n-                    FunctionDescriptor.ofVoid(MemoryLayout.sequenceLayout(C_INT)),\n-                    \"Unsupported layout: [:i32]\"\n+                    FunctionDescriptor.ofVoid(MemoryLayout.sequenceLayout(2, C_INT)),\n+                    \"Unsupported layout: [2:i32]\"\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -71,1 +71,0 @@\n-                { MemoryLayout.sequenceLayout(MemoryLayout.paddingLayout(32)) },\n@@ -102,4 +101,0 @@\n-                { MemoryLayout.sequenceLayout(\n-                        MemoryLayout.structLayout(\n-                                MemoryLayout.paddingLayout(8),\n-                                ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN))) },\n","filename":"test\/jdk\/java\/foreign\/TestLayoutConstants.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(5, JAVA_INT);\n@@ -61,1 +61,1 @@\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(5, JAVA_INT);\n@@ -79,1 +79,1 @@\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(5, JAVA_INT);\n@@ -85,1 +85,1 @@\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(5, JAVA_INT);\n@@ -177,24 +177,0 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testBitOffsetBadUnboundedSequenceTraverse() {\n-        MemoryLayout layout = MemoryLayout.sequenceLayout(MemoryLayout.sequenceLayout(JAVA_INT));\n-        layout.bitOffset(sequenceElement(1), sequenceElement(0));\n-    }\n-\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testByteOffsetBadUnboundedSequenceTraverse() {\n-        MemoryLayout layout = MemoryLayout.sequenceLayout(MemoryLayout.sequenceLayout(JAVA_INT));\n-        layout.byteOffset(sequenceElement(1), sequenceElement(0));\n-    }\n-\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testBitOffsetHandleBadUnboundedSequenceTraverse() {\n-        MemoryLayout layout = MemoryLayout.sequenceLayout(MemoryLayout.sequenceLayout(JAVA_INT));\n-        layout.bitOffsetHandle(sequenceElement(1), sequenceElement(0));\n-    }\n-\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testByteOffsetHandleBadUnboundedSequenceTraverse() {\n-        MemoryLayout layout = MemoryLayout.sequenceLayout(MemoryLayout.sequenceLayout(JAVA_INT));\n-        layout.byteOffsetHandle(sequenceElement(1), sequenceElement(0));\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":4,"deletions":28,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -57,2 +57,1 @@\n-                MemoryLayout.sequenceLayout(ValueLayout.JAVA_DOUBLE).withName(\"arr\"));\n-        assertFalse(layout.hasSize());\n+                MemoryLayout.sequenceLayout(0, ValueLayout.JAVA_DOUBLE).withName(\"arr\"));\n@@ -83,2 +82,1 @@\n-                MemoryLayout.sequenceLayout(1, MemoryLayout.sequenceLayout(ValueLayout.JAVA_DOUBLE)).withName(\"arr\"));\n-        assertFalse(layout.hasSize());\n+                MemoryLayout.sequenceLayout(1, MemoryLayout.sequenceLayout(0, ValueLayout.JAVA_DOUBLE)).withName(\"arr\"));\n@@ -125,26 +123,0 @@\n-    @Test(dataProvider = \"unboundLayouts\", expectedExceptions = UnsupportedOperationException.class)\n-    public void testUnboundSize(MemoryLayout layout, long align) {\n-        layout.bitSize();\n-    }\n-\n-    @Test(dataProvider = \"unboundLayouts\")\n-    public void testUnboundAlignment(MemoryLayout layout, long align) {\n-        assertEquals(align, layout.bitAlignment());\n-    }\n-\n-    @Test(dataProvider = \"unboundLayouts\")\n-    public void testUnboundEquals(MemoryLayout layout, long align) {\n-        assertTrue(layout.equals(layout));\n-    }\n-\n-    @Test(dataProvider = \"unboundLayouts\")\n-    public void testUnboundHash(MemoryLayout layout, long align) {\n-        layout.hashCode();\n-    }\n-\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testBadUnboundSequenceLayoutResize() {\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(ValueLayout.JAVA_INT);\n-        seq.withElementCount(-1);\n-    }\n-\n@@ -228,16 +200,0 @@\n-    @DataProvider(name = \"unboundLayouts\")\n-    public Object[][] unboundLayouts() {\n-        ValueLayout alignedInt = JAVA_INT.withBitAlignment(32);\n-        return new Object[][] {\n-                { MemoryLayout.sequenceLayout(alignedInt), 32 },\n-                { MemoryLayout.sequenceLayout(MemoryLayout.sequenceLayout(alignedInt)), 32 },\n-                { MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(alignedInt)), 32 },\n-                { MemoryLayout.structLayout(MemoryLayout.sequenceLayout(alignedInt)), 32 },\n-                { MemoryLayout.structLayout(MemoryLayout.sequenceLayout(MemoryLayout.sequenceLayout(alignedInt))), 32 },\n-                { MemoryLayout.structLayout(MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(alignedInt))), 32 },\n-                { MemoryLayout.unionLayout(MemoryLayout.sequenceLayout(alignedInt)), 32 },\n-                { MemoryLayout.unionLayout(MemoryLayout.sequenceLayout(MemoryLayout.sequenceLayout(alignedInt))), 32 },\n-                { MemoryLayout.unionLayout(MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(alignedInt))), 32 },\n-        };\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestLayouts.java","additions":2,"deletions":46,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-                for (int i = 0; i < seq.elementCount().getAsLong(); i++) {\n+                for (int i = 0; i < seq.elementCount(); i++) {\n@@ -138,1 +138,1 @@\n-                checker.check(handle, segment, seq.elementCount().getAsLong());\n+                checker.check(handle, segment, seq.elementCount());\n@@ -187,2 +187,2 @@\n-                for (int i = 0; i < seq.elementCount().getAsLong(); i++) {\n-                    for (int j = 0; j < ((SequenceLayout) seq.elementLayout()).elementCount().getAsLong(); j++) {\n+                for (int i = 0; i < seq.elementCount(); i++) {\n+                    for (int j = 0; j < ((SequenceLayout) seq.elementLayout()).elementCount(); j++) {\n@@ -202,2 +202,2 @@\n-                checker.check(handle, segment, seq.elementCount().getAsLong(),\n-                        ((SequenceLayout)seq.elementLayout()).elementCount().getAsLong());\n+                checker.check(handle, segment, seq.elementCount(),\n+                        ((SequenceLayout)seq.elementLayout()).elementCount());\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccess.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-        for (long i = 0; i < seq.elementCount().getAsLong() ; i++) {\n+        for (long i = 0; i < seq.elementCount() ; i++) {\n@@ -109,1 +109,1 @@\n-        long nelems = layout.elementCount().getAsLong();\n+        long nelems = layout.elementCount();\n","filename":"test\/jdk\/java\/foreign\/TestNative.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -177,1 +177,1 @@\n-        addDefaultMapping(SequenceLayout.class, MemoryLayout.sequenceLayout(ValueLayout.JAVA_INT));\n+        addDefaultMapping(SequenceLayout.class, MemoryLayout.sequenceLayout(1, ValueLayout.JAVA_INT));\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -79,18 +79,0 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testReshapeOnUnboundSequence() {\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(ValueLayout.JAVA_INT);\n-        seq.reshape(3, 2);\n-    }\n-\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testFlattenOnUnboundSequence() {\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(ValueLayout.JAVA_INT);\n-        seq.flatten();\n-    }\n-\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testFlattenOnUnboundNestedSequence() {\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(ValueLayout.JAVA_INT));\n-        seq.flatten();\n-    }\n-\n@@ -103,1 +85,1 @@\n-            assertEquals(layout.elementCount().getAsLong(), dims[i]);\n+            assertEquals(layout.elementCount(), dims[i]);\n","filename":"test\/jdk\/java\/foreign\/TestReshape.java","additions":1,"deletions":19,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.foreign.MemoryLayout;\n@@ -68,2 +67,1 @@\n-        VarHandle byteHandle = MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE)\n-                .varHandle(MemoryLayout.PathElement.sequenceElement());\n+        VarHandle byteHandle = ValueLayout.JAVA_BYTE.arrayElementVarHandle();\n@@ -80,2 +78,1 @@\n-        VarHandle byteHandle = MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE)\n-                .varHandle(MemoryLayout.PathElement.sequenceElement());\n+        VarHandle byteHandle = ValueLayout.JAVA_BYTE.arrayElementVarHandle();\n@@ -150,2 +147,1 @@\n-        VarHandle byteHandle = MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE)\n-                .varHandle(MemoryLayout.PathElement.sequenceElement());\n+        VarHandle byteHandle = ValueLayout.JAVA_BYTE.arrayElementVarHandle();\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-            for (int i = 0 ; i < layout.elementCount().getAsLong() ; i++) {\n+            for (int i = 0 ; i < layout.elementCount() ; i++) {\n","filename":"test\/jdk\/java\/foreign\/TestSharedAccess.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,2 +51,1 @@\n-    static final VarHandle INT_HANDLE = MemoryLayout.sequenceLayout(ValueLayout.JAVA_INT)\n-            .varHandle(MemoryLayout.PathElement.sequenceElement());\n+    static final VarHandle INT_HANDLE = ValueLayout.JAVA_INT.arrayElementVarHandle();\n@@ -63,1 +62,1 @@\n-            for (int i = 0; i < layout.elementCount().getAsLong(); i++) {\n+            for (int i = 0; i < layout.elementCount(); i++) {\n@@ -66,1 +65,1 @@\n-            long expected = LongStream.range(0, layout.elementCount().getAsLong()).sum();\n+            long expected = LongStream.range(0, layout.elementCount()).sum();\n@@ -89,1 +88,1 @@\n-        for (int i = 0; i < layout.elementCount().getAsLong(); i++) {\n+        for (int i = 0; i < layout.elementCount(); i++) {\n@@ -92,1 +91,1 @@\n-        long expected = LongStream.range(0, layout.elementCount().getAsLong()).sum();\n+        long expected = LongStream.range(0, layout.elementCount()).sum();\n","filename":"test\/jdk\/java\/foreign\/TestSpliterator.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-    static final VarHandle VH_IntArray = MemoryLayout.sequenceLayout(C_INT).varHandle(sequenceElement());\n+    static final VarHandle VH_IntArray = C_INT.arrayElementVarHandle();\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(sequenceElement());\n+    static final VarHandle VH_int = JAVA_INT.arrayElementVarHandle();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverConstant.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(sequenceElement());\n+    static final VarHandle VH_int = JAVA_INT.arrayElementVarHandle();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNew.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(sequenceElement());\n+    static final VarHandle VH_int = JAVA_INT.arrayElementVarHandle();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNewHeap.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(sequenceElement());\n+    static final VarHandle VH_int = JAVA_INT.arrayElementVarHandle();\n@@ -67,1 +67,1 @@\n-    static final VarHandle VH_int_aligned = MemoryLayout.sequenceLayout(JAVA_INT_ALIGNED).varHandle(sequenceElement());\n+    static final VarHandle VH_int_aligned = JAVA_INT_ALIGNED.arrayElementVarHandle();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstant.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(sequenceElement());\n+    static final VarHandle VH_int = JAVA_INT.arrayElementVarHandle();\n@@ -72,1 +72,1 @@\n-    static final VarHandle VH_int_aligned = MemoryLayout.sequenceLayout(JAVA_INT_ALIGNED).varHandle(sequenceElement());\n+    static final VarHandle VH_int_aligned = JAVA_INT_ALIGNED.arrayElementVarHandle();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantHeap.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(sequenceElement());\n+    static final VarHandle VH_int = JAVA_INT.arrayElementVarHandle();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantMapped.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(sequenceElement());\n+    static final VarHandle VH_int = JAVA_INT.arrayElementVarHandle();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantShared.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-    static final VarHandle intHandle = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(MemoryLayout.PathElement.sequenceElement());\n+    static final VarHandle intHandle = JAVA_INT.arrayElementVarHandle();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverPollutedSegments.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(sequenceElement());\n+    static final VarHandle VH_int = JAVA_INT.arrayElementVarHandle();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ParallelSum.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,2 +87,1 @@\n-    static final VarHandle VH_addr_int = MemoryLayout.sequenceLayout(ValueLayout.JAVA_INT)\n-            .varHandle(MemoryLayout.PathElement.sequenceElement());\n+    static final VarHandle VH_addr_int = ValueLayout.JAVA_INT.arrayElementVarHandle();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/TestAdaptVarHandles.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}