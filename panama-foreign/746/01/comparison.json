{"files":[{"patch":"@@ -112,1 +112,2 @@\n-    case StorageType::FRAME_DATA:\n+    case StorageType::FRAME_DATA: {\n+      Address dest(sp, to_reg.offset() + out_bias);\n@@ -114,4 +115,4 @@\n-        \/\/ FIXME use correctly sized stores\n-        case 8: case 4: case 2: case 1:\n-          masm->str(from_reg, Address(sp, to_reg.offset() + out_stk_bias));\n-        break;\n+        case 8: masm->str (from_reg, dest); break;\n+        case 4: masm->strw(from_reg, dest); break;\n+        case 2: masm->strh(from_reg, dest); break;\n+        case 1: masm->strb(from_reg, dest); break;\n@@ -120,1 +121,1 @@\n-      break;\n+    } break;\n@@ -133,4 +134,4 @@\n-        \/\/ FIXME use correctly sized loads\n-        case 8: case 4: case 2: case 1:\n-          masm->ldr(as_Register(to_reg), from_addr);\n-        break;\n+        case 8: masm->ldr (as_Register(to_reg), from_addr); break;\n+        case 4: masm->ldrw(as_Register(to_reg), from_addr); break;\n+        case 2: masm->ldrh(as_Register(to_reg), from_addr); break;\n+        case 1: masm->ldrb(as_Register(to_reg), from_addr); break;\n@@ -154,3 +155,1 @@\n-    case StorageType::FRAME_DATA:\n-      \/\/ We assume 8 bytes stack size when converting from VMReg (Java CC)\n-      \/\/assert(from_reg.stack_size() == to_reg.stack_size(), \"must be same\");\n+    case StorageType::FRAME_DATA: {\n@@ -158,5 +157,4 @@\n-        \/\/ FIXME use correctly sized loads & stores\n-        case 8: case 4: case 2: case 1:\n-          masm->ldr(tmp_reg, from_addr);\n-          masm->str(tmp_reg, Address(sp, to_reg.offset() + out_bias));\n-        break;\n+        case 8: masm->ldr (tmp_reg, from_addr); break;\n+        case 4: masm->ldrw(tmp_reg, from_addr); break;\n+        case 2: masm->ldrh(tmp_reg, from_addr); break;\n+        case 1: masm->ldrb(tmp_reg, from_addr); break;\n@@ -165,1 +163,9 @@\n-      break;\n+      Address dest(sp, to_reg.offset() + out_bias);\n+      switch (to_reg.stack_size()) {\n+        case 8: masm->str (tmp_reg, dest); break;\n+        case 4: masm->strw(tmp_reg, dest); break;\n+        case 2: masm->strh(tmp_reg, dest); break;\n+        case 1: masm->strb(tmp_reg, dest); break;\n+        default: ShouldNotReachHere();\n+      }\n+    } break;\n@@ -177,8 +183,5 @@\n-    case StorageType::STACK:\n-      switch(to_reg.stack_size()) {\n-        case 8:\n-          masm->strd(from_reg, Address(sp, to_reg.offset() + out_stk_bias));\n-        break;\n-        case 4:\n-          masm->strs(from_reg, Address(sp, to_reg.offset() + out_stk_bias));\n-        break;\n+    case StorageType::STACK: {\n+      Address dest(sp, to_reg.offset() + out_stk_bias);\n+      switch (to_reg.stack_size()) {\n+        case 8: masm->strd(from_reg, dest); break;\n+        case 4: masm->strs(from_reg, dest); break;\n@@ -187,1 +190,1 @@\n-      break;\n+    } break;\n","filename":"src\/hotspot\/cpu\/aarch64\/foreignGlobals_aarch64.cpp","additions":31,"deletions":28,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2019, 2021, Arm Limited. All rights reserved.\n+ * Copyright (c) 2019, 2022, Arm Limited. All rights reserved.\n@@ -189,1 +189,5 @@\n-        VMStorage stackAlloc(long size, long alignment) {\n+        void alignStack(long alignment) {\n+            stackOffset = Utils.alignUp(stackOffset, alignment);\n+        }\n+\n+        VMStorage stackAlloc(long size, long alignment, boolean subSlotPacking) {\n@@ -191,5 +195,3 @@\n-            \/\/ Implementation limit: each arg must take up at least an 8 byte stack slot (on the Java side)\n-            \/\/ There is currently no way to address stack offsets that are not multiples of 8 bytes\n-            \/\/ The VM can only address multiple-of-4-bytes offsets, which is also not good enough for some ABIs\n-            \/\/ see JDK-8283462 and related issues\n-            long stackSlotAlignment = Math.max(alignment, STACK_SLOT_SIZE);\n+            long stackSlotAlignment = subSlotPacking && !forVarArgs\n+                    ? alignment\n+                    : Math.max(alignment, STACK_SLOT_SIZE);\n@@ -197,7 +199,0 @@\n-            \/\/ macos-aarch64 ABI potentially requires addressing stack offsets that are not multiples of 8 bytes\n-            \/\/ Reject such call types here, to prevent undefined behavior down the line\n-            \/\/ Reject if the above stack-slot-aligned offset does not match the offset the ABI really wants\n-            \/\/ Except for variadic arguments, which _are_ passed at 8-byte-aligned offsets\n-            if (requiresSubSlotStackPacking() && alignedStackOffset != Utils.alignUp(stackOffset, alignment)\n-                    && !forVarArgs) \/\/ varargs are given a pass on all aarch64 ABIs\n-                throw new UnsupportedOperationException(\"Call type not supported on this platform\");\n@@ -215,1 +210,1 @@\n-            return stackAlloc(layout.byteSize(), layout.byteAlignment());\n+            return stackAlloc(layout.byteSize(), layout.byteAlignment(), requiresSubSlotStackPacking());\n@@ -248,0 +243,21 @@\n+        VMStorage[] nextStorageForHFA(GroupLayout group) {\n+            final int nFields = group.memberLayouts().size();\n+            VMStorage[] regs = regAlloc(StorageType.VECTOR, nFields);\n+            if (regs == null && requiresSubSlotStackPacking() && !forVarArgs) {\n+                \/\/ For the ABI variants that pack arguments spilled to the\n+                \/\/ stack, HFA arguments are spilled as if their individual\n+                \/\/ fields had been allocated separately rather than as if the\n+                \/\/ struct had been spilled as a whole.\n+\n+                VMStorage[] slots = new VMStorage[nFields];\n+                for (int i = 0; i < nFields; i++) {\n+                    MemoryLayout member = group.memberLayouts().get(i);\n+                    slots[i] = stackAlloc(member.byteSize(), member.byteAlignment(), true);\n+                }\n+\n+                return slots;\n+            } else {\n+                return regs;\n+            }\n+        }\n+\n@@ -274,1 +290,1 @@\n-                    storageCalculator.stackAlloc(copy, STACK_SLOT_SIZE);\n+                    storageCalculator.stackAlloc(copy, layout.byteAlignment(), false);\n@@ -283,0 +299,6 @@\n+\n+            if (requiresSubSlotStackPacking()) {\n+                \/\/ Pad to the next stack slot boundary instead of packing\n+                \/\/ additional arguments into the unused space.\n+                storageCalculator.alignStack(STACK_SLOT_SIZE);\n+            }\n@@ -295,1 +317,1 @@\n-                    storageCalculator.stackAlloc(copy, STACK_SLOT_SIZE);\n+                    storageCalculator.stackAlloc(copy, layout.byteAlignment(), false);\n@@ -302,0 +324,6 @@\n+\n+            if (requiresSubSlotStackPacking()) {\n+                \/\/ Pad to the next stack slot boundary instead of packing\n+                \/\/ additional arguments into the unused space.\n+                storageCalculator.alignStack(STACK_SLOT_SIZE);\n+            }\n@@ -363,2 +391,1 @@\n-                    VMStorage[] regs = storageCalculator.regAlloc(\n-                        StorageType.VECTOR, group.memberLayouts().size());\n+                    VMStorage[] regs = storageCalculator.nextStorageForHFA(group);\n@@ -461,2 +488,1 @@\n-                    VMStorage[] regs = storageCalculator.regAlloc(\n-                            StorageType.VECTOR, group.memberLayouts().size());\n+                    VMStorage[] regs = storageCalculator.nextStorageForHFA(group);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":47,"deletions":21,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -482,7 +482,0 @@\n-# jdk_foreign\n-\n-java\/foreign\/TestUpcallStack.java 8275584 macosx-aarch64\n-java\/foreign\/TestDowncallStack.java 8275584 macosx-aarch64\n-\n-############################################################################\n-\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -35,1 +35,2 @@\n-        assertEquals(callingSequence.argumentBindingsCount(), argumentBindings.length);\n+        assertEquals(callingSequence.argumentBindingsCount(), argumentBindings.length,\n+          callingSequence.asString() + \" != \" + Arrays.deepToString(argumentBindings));\n@@ -40,1 +41,1 @@\n-            assertEquals(actual, Arrays.asList(expected));\n+            assertEquals(actual, Arrays.asList(expected), \"bindings at: \" + i + \": \" + actual + \" != \" + Arrays.toString(expected));\n@@ -45,1 +46,1 @@\n-        assertEquals(callingSequence.returnBindings(), Arrays.asList(returnBindings));\n+        assertEquals(callingSequence.returnBindings(), Arrays.asList(returnBindings), callingSequence.returnBindings() + \" != \" + Arrays.toString(returnBindings));\n","filename":"test\/jdk\/java\/foreign\/callarranger\/CallArrangerTestBase.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.lang.foreign.StructLayout;\n@@ -449,0 +450,197 @@\n+\n+    @Test\n+    public void testMacArgsOnStack() {\n+        MethodType mt = MethodType.methodType(void.class,\n+                int.class, int.class, int.class, int.class,\n+                int.class, int.class, int.class, int.class,\n+                int.class, int.class, short.class, byte.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n+                C_INT, C_INT, C_INT, C_INT,\n+                C_INT, C_INT, C_INT, C_INT,\n+                C_INT, C_INT, C_SHORT, C_CHAR);\n+        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(r0, int.class) },\n+            { vmStore(r1, int.class) },\n+            { vmStore(r2, int.class) },\n+            { vmStore(r3, int.class) },\n+            { vmStore(r4, int.class) },\n+            { vmStore(r5, int.class) },\n+            { vmStore(r6, int.class) },\n+            { vmStore(r7, int.class) },\n+            { vmStore(stackStorage((short) 4, 0), int.class) },\n+            { vmStore(stackStorage((short) 4, 4), int.class) },\n+            { cast(short.class, int.class), vmStore(stackStorage((short) 2, 8), int.class) },\n+            { cast(byte.class, int.class), vmStore(stackStorage((short) 1, 10), int.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testMacArgsOnStack2() {\n+        StructLayout struct = MemoryLayout.structLayout(\n+            C_FLOAT,\n+            C_FLOAT\n+        );\n+        MethodType mt = MethodType.methodType(void.class,\n+                long.class, long.class, long.class, long.class,\n+                long.class, long.class, long.class, long.class,\n+                double.class, double.class, double.class, double.class,\n+                double.class, double.class, double.class, double.class,\n+                int.class, MemorySegment.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n+                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n+                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n+                C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,\n+                C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,\n+                C_INT, struct);\n+        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(r0, long.class) },\n+            { vmStore(r1, long.class) },\n+            { vmStore(r2, long.class) },\n+            { vmStore(r3, long.class) },\n+            { vmStore(r4, long.class) },\n+            { vmStore(r5, long.class) },\n+            { vmStore(r6, long.class) },\n+            { vmStore(r7, long.class) },\n+            { vmStore(v0, double.class) },\n+            { vmStore(v1, double.class) },\n+            { vmStore(v2, double.class) },\n+            { vmStore(v3, double.class) },\n+            { vmStore(v4, double.class) },\n+            { vmStore(v5, double.class) },\n+            { vmStore(v6, double.class) },\n+            { vmStore(v7, double.class) },\n+            { vmStore(stackStorage((short) 4, 0), int.class) },\n+            {\n+                dup(),\n+                bufferLoad(0, int.class),\n+                vmStore(stackStorage((short) 4, 4), int.class),\n+                bufferLoad(4, int.class),\n+                vmStore(stackStorage((short) 4, 8), int.class),\n+            }\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testMacArgsOnStack3() {\n+        StructLayout struct = MemoryLayout.structLayout(\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        MethodType mt = MethodType.methodType(void.class,\n+                long.class, long.class, long.class, long.class,\n+                long.class, long.class, long.class, long.class,\n+                double.class, double.class, double.class, double.class,\n+                double.class, double.class, double.class, double.class,\n+                MemorySegment.class, float.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n+                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n+                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n+                C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,\n+                C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,\n+                struct, C_FLOAT);\n+        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(r0, long.class) },\n+            { vmStore(r1, long.class) },\n+            { vmStore(r2, long.class) },\n+            { vmStore(r3, long.class) },\n+            { vmStore(r4, long.class) },\n+            { vmStore(r5, long.class) },\n+            { vmStore(r6, long.class) },\n+            { vmStore(r7, long.class) },\n+            { vmStore(v0, double.class) },\n+            { vmStore(v1, double.class) },\n+            { vmStore(v2, double.class) },\n+            { vmStore(v3, double.class) },\n+            { vmStore(v4, double.class) },\n+            { vmStore(v5, double.class) },\n+            { vmStore(v6, double.class) },\n+            { vmStore(v7, double.class) },\n+            { dup(),\n+                bufferLoad(0, long.class), vmStore(stackStorage((short) 8, 0), long.class),\n+                bufferLoad(8, long.class), vmStore(stackStorage((short) 8, 8), long.class) },\n+            { vmStore(stackStorage((short) 4, 16), float.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testMacArgsOnStack4() {\n+        StructLayout struct = MemoryLayout.structLayout(\n+            C_INT,\n+            C_INT,\n+            C_POINTER\n+        );\n+        MethodType mt = MethodType.methodType(void.class,\n+                long.class, long.class, long.class, long.class,\n+                long.class, long.class, long.class, long.class,\n+                double.class, double.class, double.class, double.class,\n+                double.class, double.class, double.class, double.class,\n+                float.class, MemorySegment.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n+                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n+                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n+                C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,\n+                C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,\n+                C_FLOAT, struct);\n+        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(r0, long.class) },\n+            { vmStore(r1, long.class) },\n+            { vmStore(r2, long.class) },\n+            { vmStore(r3, long.class) },\n+            { vmStore(r4, long.class) },\n+            { vmStore(r5, long.class) },\n+            { vmStore(r6, long.class) },\n+            { vmStore(r7, long.class) },\n+            { vmStore(v0, double.class) },\n+            { vmStore(v1, double.class) },\n+            { vmStore(v2, double.class) },\n+            { vmStore(v3, double.class) },\n+            { vmStore(v4, double.class) },\n+            { vmStore(v5, double.class) },\n+            { vmStore(v6, double.class) },\n+            { vmStore(v7, double.class) },\n+            { vmStore(stackStorage((short) 4, 0), float.class) },\n+            { dup(),\n+                bufferLoad(0, long.class), vmStore(stackStorage((short) 8, 8), long.class),\n+                bufferLoad(8, long.class), vmStore(stackStorage((short) 8, 16), long.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestAarch64CallArranger.java","additions":198,"deletions":0,"binary":false,"changes":198,"status":"modified"}]}