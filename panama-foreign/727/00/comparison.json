{"files":[{"patch":"@@ -221,1 +221,2 @@\n-        return downcallHandle(function).bindTo(symbol);\n+        return downcallHandle(function)\n+                .bindTo(symbol);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -310,1 +310,1 @@\n-        return Utils.bitsToBytesOrThrow(bitOffset(elements), Utils.bitsToBytesThrowOffset);\n+        return Utils.bitsToBytesOrThrow(bitOffset(elements), Utils.BITS_TO_BYTES_THROW_OFFSET);\n@@ -346,1 +346,1 @@\n-        mh = MethodHandles.filterReturnValue(mh, Utils.MH_bitsToBytesOrThrowForOffset);\n+        mh = MethodHandles.filterReturnValue(mh, Utils.MH_BITS_TO_BYTES_OR_THROW_FOR_OFFSET);\n@@ -594,11 +594,0 @@\n-    \/**\n-     * {@return the hash code value for this layout}\n-     *\/\n-    int hashCode();\n-\n-    \/**\n-     * {@return the string representation of this layout}\n-     *\/\n-    @Override\n-    String toString();\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.reflect.Array;\n@@ -49,2 +48,0 @@\n-import jdk.internal.misc.ScopedMemoryAccess;\n-import jdk.internal.misc.Unsafe;\n@@ -55,2 +52,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n-\n@@ -1123,2 +1118,3 @@\n-    static void copy(MemorySegment srcSegment, ValueLayout srcElementLayout, long srcOffset, MemorySegment dstSegment,\n-                     ValueLayout dstElementLayout, long dstOffset, long elementCount) {\n+    static void copy(MemorySegment srcSegment, ValueLayout srcElementLayout, long srcOffset,\n+                     MemorySegment dstSegment, ValueLayout dstElementLayout, long dstOffset,\n+                     long elementCount) {\n@@ -1129,25 +1125,4 @@\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        AbstractMemorySegmentImpl dstImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        if (srcElementLayout.byteSize() != dstElementLayout.byteSize()) {\n-            throw new IllegalArgumentException(\"Source and destination layouts must have same size\");\n-        }\n-        Utils.checkElementAlignment(srcElementLayout, \"Source layout alignment greater than its size\");\n-        Utils.checkElementAlignment(dstElementLayout, \"Destination layout alignment greater than its size\");\n-        if (!srcImpl.isAlignedForElement(srcOffset, srcElementLayout)) {\n-            throw new IllegalArgumentException(\"Source segment incompatible with alignment constraints\");\n-        }\n-        if (!dstImpl.isAlignedForElement(dstOffset, dstElementLayout)) {\n-            throw new IllegalArgumentException(\"Destination segment incompatible with alignment constraints\");\n-        }\n-        long size = elementCount * srcElementLayout.byteSize();\n-        srcImpl.checkAccess(srcOffset, size, true);\n-        dstImpl.checkAccess(dstOffset, size, false);\n-        if (srcElementLayout.byteSize() == 1 || srcElementLayout.order() == dstElementLayout.order()) {\n-            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size);\n-        } else {\n-            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size, srcElementLayout.byteSize());\n-        }\n+\n+        AbstractMemorySegmentImpl.copy(srcSegment, srcElementLayout, srcOffset,\n+                                       dstSegment, dstElementLayout, dstOffset,\n+                                       elementCount);\n@@ -1946,3 +1921,3 @@\n-    static void copy(\n-            MemorySegment srcSegment, ValueLayout srcLayout, long srcOffset,\n-            Object dstArray, int dstIndex, int elementCount) {\n+    static void copy(MemorySegment srcSegment, ValueLayout srcLayout, long srcOffset,\n+                     Object dstArray, int dstIndex,\n+                     int elementCount) {\n@@ -1952,22 +1927,4 @@\n-        long baseAndScale = getBaseAndScale(dstArray.getClass());\n-        if (dstArray.getClass().componentType() != srcLayout.carrier()) {\n-            throw new IllegalArgumentException(\"Incompatible value layout: \" + srcLayout);\n-        }\n-        int dstBase = (int)baseAndScale;\n-        long dstWidth = (int)(baseAndScale >> 32); \/\/ Use long arithmetics below\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        Utils.checkElementAlignment(srcLayout, \"Source layout alignment greater than its size\");\n-        if (!srcImpl.isAlignedForElement(srcOffset, srcLayout)) {\n-            throw new IllegalArgumentException(\"Source segment incompatible with alignment constraints\");\n-        }\n-        srcImpl.checkAccess(srcOffset, elementCount * dstWidth, true);\n-        Objects.checkFromIndexSize(dstIndex, elementCount, Array.getLength(dstArray));\n-        if (dstWidth == 1 || srcLayout.order() == ByteOrder.nativeOrder()) {\n-            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.sessionImpl(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth);\n-        } else {\n-            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.sessionImpl(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth, dstWidth);\n-        }\n+\n+        AbstractMemorySegmentImpl.copy(srcSegment, srcLayout, srcOffset,\n+                dstArray, dstIndex,\n+                elementCount);\n@@ -1998,3 +1955,3 @@\n-    static void copy(\n-            Object srcArray, int srcIndex,\n-            MemorySegment dstSegment, ValueLayout dstLayout, long dstOffset, int elementCount) {\n+    static void copy(Object srcArray, int srcIndex,\n+                     MemorySegment dstSegment, ValueLayout dstLayout, long dstOffset,\n+                     int elementCount) {\n@@ -2004,23 +1961,0 @@\n-        long baseAndScale = getBaseAndScale(srcArray.getClass());\n-        if (srcArray.getClass().componentType() != dstLayout.carrier()) {\n-            throw new IllegalArgumentException(\"Incompatible value layout: \" + dstLayout);\n-        }\n-        int srcBase = (int)baseAndScale;\n-        long srcWidth = (int)(baseAndScale >> 32); \/\/ Use long arithmetics below\n-        Objects.checkFromIndexSize(srcIndex, elementCount, Array.getLength(srcArray));\n-        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        Utils.checkElementAlignment(dstLayout, \"Destination layout alignment greater than its size\");\n-        if (!destImpl.isAlignedForElement(dstOffset, dstLayout)) {\n-            throw new IllegalArgumentException(\"Destination segment incompatible with alignment constraints\");\n-        }\n-        destImpl.checkAccess(dstOffset, elementCount * srcWidth, false);\n-        if (srcWidth == 1 || dstLayout.order() == ByteOrder.nativeOrder()) {\n-            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(null, destImpl.sessionImpl(),\n-                    srcArray, srcBase + (srcIndex * srcWidth),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth);\n-        } else {\n-            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(null, destImpl.sessionImpl(),\n-                    srcArray, srcBase + (srcIndex * srcWidth),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth, srcWidth);\n-        }\n-    }\n@@ -2028,18 +1962,3 @@\n-    private static long getBaseAndScale(Class<?> arrayType) {\n-        if (arrayType.equals(byte[].class)) {\n-            return (long)Unsafe.ARRAY_BYTE_BASE_OFFSET | ((long)Unsafe.ARRAY_BYTE_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(char[].class)) {\n-            return (long)Unsafe.ARRAY_CHAR_BASE_OFFSET | ((long)Unsafe.ARRAY_CHAR_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(short[].class)) {\n-            return (long)Unsafe.ARRAY_SHORT_BASE_OFFSET | ((long)Unsafe.ARRAY_SHORT_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(int[].class)) {\n-            return (long)Unsafe.ARRAY_INT_BASE_OFFSET | ((long) Unsafe.ARRAY_INT_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(float[].class)) {\n-            return (long)Unsafe.ARRAY_FLOAT_BASE_OFFSET | ((long)Unsafe.ARRAY_FLOAT_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(long[].class)) {\n-            return (long)Unsafe.ARRAY_LONG_BASE_OFFSET | ((long)Unsafe.ARRAY_LONG_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(double[].class)) {\n-            return (long)Unsafe.ARRAY_DOUBLE_BASE_OFFSET | ((long)Unsafe.ARRAY_DOUBLE_INDEX_SCALE << 32);\n-        } else {\n-            throw new IllegalArgumentException(\"Not a supported array class: \" + arrayType.getSimpleName());\n-        }\n+        AbstractMemorySegmentImpl.copy(srcArray, srcIndex,\n+                dstSegment, dstLayout, dstOffset,\n+                elementCount);\n@@ -2086,34 +2005,2 @@\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)Objects.requireNonNull(srcSegment);\n-        AbstractMemorySegmentImpl dstImpl = (AbstractMemorySegmentImpl)Objects.requireNonNull(dstSegment);\n-        long srcBytes = srcToOffset - srcFromOffset;\n-        long dstBytes = dstToOffset - dstFromOffset;\n-        srcImpl.checkAccess(srcFromOffset, srcBytes, true);\n-        dstImpl.checkAccess(dstFromOffset, dstBytes, true);\n-        if (dstImpl == srcImpl) {\n-            srcImpl.checkValidState();\n-            return -1;\n-        }\n-\n-        long bytes = Math.min(srcBytes, dstBytes);\n-        long i = 0;\n-        if (bytes > 7) {\n-            if (srcImpl.get(JAVA_BYTE, srcFromOffset) != dstImpl.get(JAVA_BYTE, dstFromOffset)) {\n-                return 0;\n-            }\n-            i = AbstractMemorySegmentImpl.vectorizedMismatchLargeForBytes(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcFromOffset,\n-                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstFromOffset,\n-                    bytes);\n-            if (i >= 0) {\n-                return i;\n-            }\n-            long remaining = ~i;\n-            assert remaining < 8 : \"remaining greater than 7: \" + remaining;\n-            i = bytes - remaining;\n-        }\n-        for (; i < bytes; i++) {\n-            if (srcImpl.get(JAVA_BYTE, srcFromOffset + i) != dstImpl.get(JAVA_BYTE, dstFromOffset + i)) {\n-                return i;\n-            }\n-        }\n-        return srcBytes != dstBytes ? bytes : -1;\n+        return AbstractMemorySegmentImpl.mismatch(srcSegment, srcFromOffset, srcToOffset,\n+                dstSegment, dstFromOffset, dstToOffset);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":22,"deletions":135,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.reflect.Array;\n@@ -53,0 +54,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -57,0 +59,2 @@\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+\n@@ -72,1 +76,1 @@\n-    static final JavaNioAccess nioAccess = SharedSecrets.getJavaNioAccess();\n+    static final JavaNioAccess JAVA_NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n@@ -464,3 +468,3 @@\n-        long bbAddress = nioAccess.getBufferAddress(bb);\n-        Object base = nioAccess.getBufferBase(bb);\n-        UnmapperProxy unmapper = nioAccess.unmapper(bb);\n+        long bbAddress = JAVA_NIO_ACCESS.getBufferAddress(bb);\n+        Object base = JAVA_NIO_ACCESS.getBufferBase(bb);\n+        UnmapperProxy unmapper = JAVA_NIO_ACCESS.unmapper(bb);\n@@ -472,1 +476,1 @@\n-        AbstractMemorySegmentImpl bufferSegment = (AbstractMemorySegmentImpl)nioAccess.bufferSegment(bb);\n+        AbstractMemorySegmentImpl bufferSegment = (AbstractMemorySegmentImpl) JAVA_NIO_ACCESS.bufferSegment(bb);\n@@ -526,0 +530,150 @@\n+\n+    @ForceInline\n+    public static void copy(MemorySegment srcSegment, ValueLayout srcElementLayout, long srcOffset,\n+                     MemorySegment dstSegment, ValueLayout dstElementLayout, long dstOffset,\n+                     long elementCount) {\n+\n+        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n+        AbstractMemorySegmentImpl dstImpl = (AbstractMemorySegmentImpl)dstSegment;\n+        if (srcElementLayout.byteSize() != dstElementLayout.byteSize()) {\n+            throw new IllegalArgumentException(\"Source and destination layouts must have same size\");\n+        }\n+        Utils.checkElementAlignment(srcElementLayout, \"Source layout alignment greater than its size\");\n+        Utils.checkElementAlignment(dstElementLayout, \"Destination layout alignment greater than its size\");\n+        if (!srcImpl.isAlignedForElement(srcOffset, srcElementLayout)) {\n+            throw new IllegalArgumentException(\"Source segment incompatible with alignment constraints\");\n+        }\n+        if (!dstImpl.isAlignedForElement(dstOffset, dstElementLayout)) {\n+            throw new IllegalArgumentException(\"Destination segment incompatible with alignment constraints\");\n+        }\n+        long size = elementCount * srcElementLayout.byteSize();\n+        srcImpl.checkAccess(srcOffset, size, true);\n+        dstImpl.checkAccess(dstOffset, size, false);\n+        if (srcElementLayout.byteSize() == 1 || srcElementLayout.order() == dstElementLayout.order()) {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size);\n+        } else {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size, srcElementLayout.byteSize());\n+        }\n+    }\n+\n+    @ForceInline\n+    public static void copy(MemorySegment srcSegment, ValueLayout srcLayout, long srcOffset,\n+                            Object dstArray, int dstIndex,\n+                            int elementCount) {\n+\n+        long baseAndScale = getBaseAndScale(dstArray.getClass());\n+        if (dstArray.getClass().componentType() != srcLayout.carrier()) {\n+            throw new IllegalArgumentException(\"Incompatible value layout: \" + srcLayout);\n+        }\n+        int dstBase = (int)baseAndScale;\n+        long dstWidth = (int)(baseAndScale >> 32); \/\/ Use long arithmetics below\n+        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n+        Utils.checkElementAlignment(srcLayout, \"Source layout alignment greater than its size\");\n+        if (!srcImpl.isAlignedForElement(srcOffset, srcLayout)) {\n+            throw new IllegalArgumentException(\"Source segment incompatible with alignment constraints\");\n+        }\n+        srcImpl.checkAccess(srcOffset, elementCount * dstWidth, true);\n+        Objects.checkFromIndexSize(dstIndex, elementCount, Array.getLength(dstArray));\n+        if (dstWidth == 1 || srcLayout.order() == ByteOrder.nativeOrder()) {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.sessionImpl(), null,\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth);\n+        } else {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.sessionImpl(), null,\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth, dstWidth);\n+        }\n+    }\n+\n+    @ForceInline\n+    public static void copy(Object srcArray, int srcIndex,\n+                     MemorySegment dstSegment, ValueLayout dstLayout, long dstOffset,\n+                     int elementCount) {\n+\n+        long baseAndScale = getBaseAndScale(srcArray.getClass());\n+        if (srcArray.getClass().componentType() != dstLayout.carrier()) {\n+            throw new IllegalArgumentException(\"Incompatible value layout: \" + dstLayout);\n+        }\n+        int srcBase = (int)baseAndScale;\n+        long srcWidth = (int)(baseAndScale >> 32); \/\/ Use long arithmetics below\n+        Objects.checkFromIndexSize(srcIndex, elementCount, Array.getLength(srcArray));\n+        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n+        Utils.checkElementAlignment(dstLayout, \"Destination layout alignment greater than its size\");\n+        if (!destImpl.isAlignedForElement(dstOffset, dstLayout)) {\n+            throw new IllegalArgumentException(\"Destination segment incompatible with alignment constraints\");\n+        }\n+        destImpl.checkAccess(dstOffset, elementCount * srcWidth, false);\n+        if (srcWidth == 1 || dstLayout.order() == ByteOrder.nativeOrder()) {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(null, destImpl.sessionImpl(),\n+                    srcArray, srcBase + (srcIndex * srcWidth),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth);\n+        } else {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(null, destImpl.sessionImpl(),\n+                    srcArray, srcBase + (srcIndex * srcWidth),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth, srcWidth);\n+        }\n+    }\n+\n+    public static long mismatch(MemorySegment srcSegment, long srcFromOffset, long srcToOffset,\n+                                MemorySegment dstSegment, long dstFromOffset, long dstToOffset) {\n+        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)Objects.requireNonNull(srcSegment);\n+        AbstractMemorySegmentImpl dstImpl = (AbstractMemorySegmentImpl)Objects.requireNonNull(dstSegment);\n+        long srcBytes = srcToOffset - srcFromOffset;\n+        long dstBytes = dstToOffset - dstFromOffset;\n+        srcImpl.checkAccess(srcFromOffset, srcBytes, true);\n+        dstImpl.checkAccess(dstFromOffset, dstBytes, true);\n+        if (dstImpl == srcImpl) {\n+            srcImpl.checkValidState();\n+            return -1;\n+        }\n+\n+        long bytes = Math.min(srcBytes, dstBytes);\n+        long i = 0;\n+        if (bytes > 7) {\n+            if (srcImpl.get(JAVA_BYTE, srcFromOffset) != dstImpl.get(JAVA_BYTE, dstFromOffset)) {\n+                return 0;\n+            }\n+            i = AbstractMemorySegmentImpl.vectorizedMismatchLargeForBytes(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcFromOffset,\n+                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstFromOffset,\n+                    bytes);\n+            if (i >= 0) {\n+                return i;\n+            }\n+            long remaining = ~i;\n+            assert remaining < 8 : \"remaining greater than 7: \" + remaining;\n+            i = bytes - remaining;\n+        }\n+        for (; i < bytes; i++) {\n+            if (srcImpl.get(JAVA_BYTE, srcFromOffset + i) != dstImpl.get(JAVA_BYTE, dstFromOffset + i)) {\n+                return i;\n+            }\n+        }\n+        return srcBytes != dstBytes ? bytes : -1;\n+    }\n+\n+    private static long getBaseAndScale(Class<?> arrayType) {\n+        if (arrayType.equals(byte[].class)) {\n+            return (long) Unsafe.ARRAY_BYTE_BASE_OFFSET | ((long)Unsafe.ARRAY_BYTE_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(char[].class)) {\n+            return (long)Unsafe.ARRAY_CHAR_BASE_OFFSET | ((long)Unsafe.ARRAY_CHAR_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(short[].class)) {\n+            return (long)Unsafe.ARRAY_SHORT_BASE_OFFSET | ((long)Unsafe.ARRAY_SHORT_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(int[].class)) {\n+            return (long)Unsafe.ARRAY_INT_BASE_OFFSET | ((long) Unsafe.ARRAY_INT_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(float[].class)) {\n+            return (long)Unsafe.ARRAY_FLOAT_BASE_OFFSET | ((long)Unsafe.ARRAY_FLOAT_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(long[].class)) {\n+            return (long)Unsafe.ARRAY_LONG_BASE_OFFSET | ((long)Unsafe.ARRAY_LONG_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(double[].class)) {\n+            return (long)Unsafe.ARRAY_DOUBLE_BASE_OFFSET | ((long)Unsafe.ARRAY_DOUBLE_INDEX_SCALE << 32);\n+        } else {\n+            throw new IllegalArgumentException(\"Not a supported array class: \" + arrayType.getSimpleName());\n+        }\n+    }\n+\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":159,"deletions":5,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -184,1 +184,1 @@\n-            Utils.bitsToBytesOrThrow(offset, Utils.bitsToBytesThrowOffset);\n+            Utils.bitsToBytesOrThrow(offset, Utils.BITS_TO_BYTES_THROW_OFFSET);\n@@ -188,1 +188,1 @@\n-        offsetHandle = MethodHandles.filterReturnValue(offsetHandle, Utils.MH_bitsToBytesOrThrowForOffset); \/\/ byte offset\n+        offsetHandle = MethodHandles.filterReturnValue(offsetHandle, Utils.MH_BITS_TO_BYTES_OR_THROW_FOR_OFFSET); \/\/ byte offset\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-        return nioAccess.newMappedByteBuffer(unmapper, min, (int)length, null,\n+        return JAVA_NIO_ACCESS.newMappedByteBuffer(unmapper, min, (int)length, null,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-        return nioAccess.newDirectByteBuffer(min, (int) this.length, null,\n+        return JAVA_NIO_ACCESS.newDirectByteBuffer(min, (int) this.length, null,\n@@ -109,1 +109,1 @@\n-            alignmentBytes = Math.max(alignmentBytes, nioAccess.pageSize());\n+            alignmentBytes = Math.max(alignmentBytes, JAVA_NIO_ACCESS.pageSize());\n@@ -115,1 +115,1 @@\n-        nioAccess.reserveMemory(alignedSize, bytesSize);\n+        JAVA_NIO_ACCESS.reserveMemory(alignedSize, bytesSize);\n@@ -128,1 +128,1 @@\n-                nioAccess.unreserveMemory(alignedSize, bytesSize);\n+                JAVA_NIO_ACCESS.unreserveMemory(alignedSize, bytesSize);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-    public static final MethodHandle MH_bitsToBytesOrThrowForOffset;\n+    public static final MethodHandle MH_BITS_TO_BYTES_OR_THROW_FOR_OFFSET;\n@@ -54,1 +54,1 @@\n-    public static final Supplier<RuntimeException> bitsToBytesThrowOffset\n+    public static final Supplier<RuntimeException> BITS_TO_BYTES_THROW_OFFSET\n@@ -70,1 +70,1 @@\n-            MH_bitsToBytesOrThrowForOffset = MethodHandles.insertArguments(\n+            MH_BITS_TO_BYTES_OR_THROW_FOR_OFFSET = MethodHandles.insertArguments(\n@@ -74,1 +74,1 @@\n-                    bitsToBytesThrowOffset);\n+                    BITS_TO_BYTES_THROW_OFFSET);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}