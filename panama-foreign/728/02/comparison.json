{"files":[{"patch":"@@ -32,0 +32,1 @@\n+import jdk.internal.foreign.layout.AbstractLayout;\n@@ -33,0 +34,2 @@\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n@@ -37,0 +40,3 @@\n+import java.lang.foreign.PaddingLayout;\n+import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -49,0 +55,1 @@\n+        checkHasNaturalAlignment(function);\n@@ -64,0 +71,1 @@\n+        checkHasNaturalAlignment(function);\n@@ -80,0 +88,25 @@\n+\n+    \/\/ Current limitation of the implementation:\n+    \/\/ We don't support packed structs on some platforms,\n+    \/\/ so reject them here explicitly\n+    private static void checkHasNaturalAlignment(FunctionDescriptor descriptor) {\n+        descriptor.returnLayout().ifPresent(AbstractLinker::checkHasNaturalAlignmentRecursive);\n+        descriptor.argumentLayouts().forEach(AbstractLinker::checkHasNaturalAlignmentRecursive);\n+    }\n+\n+    private static void checkHasNaturalAlignmentRecursive(MemoryLayout layout) {\n+        checkHasNaturalAlignment(layout);\n+        if (layout instanceof GroupLayout gl) {\n+            for (MemoryLayout member : gl.memberLayouts()) {\n+                checkHasNaturalAlignmentRecursive(member);\n+            }\n+        } else if (layout instanceof SequenceLayout sl) {\n+            checkHasNaturalAlignmentRecursive(sl.elementLayout());\n+        }\n+    }\n+\n+    private static void checkHasNaturalAlignment(MemoryLayout layout) {\n+        if (!((AbstractLayout<?>) layout).hasNaturalAlignment()) {\n+            throw new IllegalArgumentException(\"Layout bit alignment must be natural alignment: \" + layout);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -97,8 +97,0 @@\n-    \/**\n-     * Align the specified type from a given address\n-     * @return The address the data should be at based on alignment requirement\n-     *\/\n-    public static long align(MemoryLayout t, boolean isVar, long addr) {\n-        return alignUp(addr, alignment(t, isVar));\n-    }\n-\n@@ -109,42 +101,0 @@\n-    \/**\n-     * The alignment requirement for a given type\n-     * @param isVar indicate if the type is a standalone variable. This change how\n-     * array is aligned. for example.\n-     *\/\n-    public static long alignment(MemoryLayout t, boolean isVar) {\n-        if (t instanceof ValueLayout) {\n-            return alignmentOfScalar((ValueLayout) t);\n-        } else if (t instanceof SequenceLayout) {\n-            \/\/ when array is used alone\n-            return alignmentOfArray((SequenceLayout) t, isVar);\n-        } else if (t instanceof GroupLayout) {\n-            return alignmentOfContainer((GroupLayout) t);\n-        } else if (t instanceof PaddingLayout) {\n-            return 1;\n-        } else {\n-            throw new IllegalArgumentException(\"Invalid type: \" + t);\n-        }\n-    }\n-\n-    private static long alignmentOfScalar(ValueLayout st) {\n-        return st.byteSize();\n-    }\n-\n-    private static long alignmentOfArray(SequenceLayout ar, boolean isVar) {\n-        if (ar.elementCount() == 0) {\n-            \/\/ VLA or incomplete\n-            return 16;\n-        } else if ((ar.byteSize()) >= 16 && isVar) {\n-            return 16;\n-        } else {\n-            \/\/ align as element type\n-            MemoryLayout elementType = ar.elementLayout();\n-            return alignment(elementType, false);\n-        }\n-    }\n-\n-    private static long alignmentOfContainer(GroupLayout ct) {\n-        \/\/ Most strict member\n-        return ct.memberLayouts().stream().mapToLong(t -> alignment(t, false)).max().orElse(1);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -218,1 +218,1 @@\n-            return stackAlloc(layout.byteSize(), SharedUtils.alignment(layout, true));\n+            return stackAlloc(layout.byteSize(), layout.byteAlignment());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.foreign.SequenceLayout;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/TypeClass.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -111,2 +111,2 @@\n-    private static ArgumentClassImpl argumentClassFor(MemoryLayout layout) {\n-        Class<?> carrier = ((ValueLayout)layout).carrier();\n+    private static ArgumentClassImpl argumentClassFor(ValueLayout layout) {\n+        Class<?> carrier = layout.carrier();\n@@ -221,1 +221,1 @@\n-        } else if (l instanceof ValueLayout) {\n+        } else if (l instanceof ValueLayout vl) {\n@@ -228,2 +228,2 @@\n-            ArgumentClassImpl argumentClass = (offset % l.byteAlignment()) == 0 ?\n-                    argumentClassFor(l) :\n+            ArgumentClassImpl argumentClass = (offset % vl.byteAlignment()) == 0 ?\n+                    argumentClassFor(vl) :\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/TypeClass.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-        VMStorage nextStorage(int type, MemoryLayout layout) {\n+        VMStorage nextStorage(int type) {\n@@ -167,2 +167,1 @@\n-                long alignment = Math.max(SharedUtils.alignment(layout, true), STACK_SLOT_SIZE);\n-                stackOffset = Utils.alignUp(stackOffset, alignment);\n+                assert stackOffset == Utils.alignUp(stackOffset, STACK_SLOT_SIZE); \/\/ should always be aligned\n@@ -204,1 +203,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER, layout);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);\n@@ -214,1 +213,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER, layout);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);\n@@ -220,1 +219,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER, layout);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);\n@@ -225,1 +224,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER, layout);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);\n@@ -230,1 +229,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.VECTOR, layout);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.VECTOR);\n@@ -235,1 +234,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.VECTOR, layout);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.VECTOR);\n@@ -268,1 +267,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER, layout);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);\n@@ -276,1 +275,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER, layout);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);\n@@ -282,1 +281,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER, layout);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);\n@@ -288,1 +287,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER, layout);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);\n@@ -293,1 +292,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.VECTOR, layout);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.VECTOR);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-abstract sealed class AbstractLayout<L extends AbstractLayout<L> & MemoryLayout>\n+public abstract sealed class AbstractLayout<L extends AbstractLayout<L> & MemoryLayout>\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/AbstractLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import java.nio.ByteOrder;\n+\n@@ -53,1 +55,2 @@\n-            assertTrue(e.getMessage().contains(expectedExceptionMessage));\n+            assertTrue(e.getMessage().contains(expectedExceptionMessage),\n+                    e.getMessage() + \" != \" + expectedExceptionMessage);\n@@ -76,0 +79,36 @@\n+            {\n+                    FunctionDescriptor.ofVoid(C_INT.withBitAlignment(16)),\n+                    \"Layout bit alignment must be natural alignment\"\n+            },\n+            {\n+                    FunctionDescriptor.ofVoid(C_POINTER.withBitAlignment(16)),\n+                    \"Layout bit alignment must be natural alignment\"\n+            },\n+            {\n+                    FunctionDescriptor.ofVoid(MemoryLayout.valueLayout(char.class, ByteOrder.nativeOrder()).withBitAlignment(32)),\n+                    \"Layout bit alignment must be natural alignment\"\n+            },\n+            {\n+                    FunctionDescriptor.ofVoid(MemoryLayout.structLayout(\n+                            C_CHAR.withName(\"x\").withBitAlignment(8),\n+                            C_SHORT.withName(\"y\").withBitAlignment(8),\n+                            C_INT.withName(\"z\").withBitAlignment(8)\n+                            ).withBitAlignment(8)),\n+                    \"Layout bit alignment must be natural alignment\"\n+            },\n+            {\n+                    FunctionDescriptor.ofVoid(MemoryLayout.structLayout(\n+                            MemoryLayout.structLayout(\n+                                C_CHAR.withName(\"x\").withBitAlignment(8),\n+                                C_SHORT.withName(\"y\").withBitAlignment(8),\n+                                C_INT.withName(\"z\").withBitAlignment(8)\n+                            ))),\n+                    \"Layout bit alignment must be natural alignment\"\n+            },\n+            {\n+                    FunctionDescriptor.ofVoid(MemoryLayout.structLayout(\n+                            MemoryLayout.sequenceLayout(\n+                                C_INT.withBitAlignment(8)\n+                            ))),\n+                    \"Layout bit alignment must be natural alignment\"\n+            },\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":40,"deletions":1,"binary":false,"changes":41,"status":"modified"}]}