{"files":[{"patch":"@@ -32,0 +32,1 @@\n+import jdk.internal.foreign.layout.AbstractLayout;\n@@ -33,0 +34,2 @@\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n@@ -37,0 +40,3 @@\n+import java.lang.foreign.PaddingLayout;\n+import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -49,0 +55,1 @@\n+        checkHasNaturalAlignment(function);\n@@ -64,0 +71,1 @@\n+        checkHasNaturalAlignment(function);\n@@ -80,0 +88,25 @@\n+\n+    \/\/ Current limitation of the implementation:\n+    \/\/ We don't support packed structs on some platforms,\n+    \/\/ so reject them here explicitly\n+    private static void checkHasNaturalAlignment(FunctionDescriptor descriptor) {\n+        descriptor.returnLayout().ifPresent(AbstractLinker::checkHasNaturalAlignmentRecursive);\n+        descriptor.argumentLayouts().forEach(AbstractLinker::checkHasNaturalAlignmentRecursive);\n+    }\n+\n+    private static void checkHasNaturalAlignmentRecursive(MemoryLayout layout) {\n+        checkHasNaturalAlignment(layout);\n+        if (layout instanceof GroupLayout gl) {\n+            for (MemoryLayout member : gl.memberLayouts()) {\n+                checkHasNaturalAlignment(member);\n+            }\n+        } else if (layout instanceof SequenceLayout sl) {\n+            checkHasNaturalAlignment(sl.elementLayout());\n+        }\n+    }\n+\n+    private static void checkHasNaturalAlignment(MemoryLayout layout) {\n+        if (!((AbstractLayout<?>) layout).hasNaturalAlignment()) {\n+            throw new IllegalArgumentException(\"Layout bit alignment must be natural alignment: \" + layout);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -101,42 +101,0 @@\n-    \/**\n-     * The alignment requirement for a given type\n-     * @param isVar indicate if the type is a standalone variable. This change how\n-     * array is aligned. for example.\n-     *\/\n-    public static long alignment(MemoryLayout t, boolean isVar) {\n-        if (t instanceof ValueLayout) {\n-            return alignmentOfScalar((ValueLayout) t);\n-        } else if (t instanceof SequenceLayout) {\n-            \/\/ when array is used alone\n-            return alignmentOfArray((SequenceLayout) t, isVar);\n-        } else if (t instanceof GroupLayout) {\n-            return alignmentOfContainer((GroupLayout) t);\n-        } else if (t instanceof PaddingLayout) {\n-            return 1;\n-        } else {\n-            throw new IllegalArgumentException(\"Invalid type: \" + t);\n-        }\n-    }\n-\n-    private static long alignmentOfScalar(ValueLayout st) {\n-        return st.byteSize();\n-    }\n-\n-    private static long alignmentOfArray(SequenceLayout ar, boolean isVar) {\n-        if (ar.elementCount() == 0) {\n-            \/\/ VLA or incomplete\n-            return 16;\n-        } else if ((ar.byteSize()) >= 16 && isVar) {\n-            return 16;\n-        } else {\n-            \/\/ align as element type\n-            MemoryLayout elementType = ar.elementLayout();\n-            return alignment(elementType, false);\n-        }\n-    }\n-\n-    private static long alignmentOfContainer(GroupLayout ct) {\n-        \/\/ Most strict member\n-        return ct.memberLayouts().stream().mapToLong(t -> alignment(t, false)).max().orElse(1);\n-    }\n-\n@@ -370,15 +328,0 @@\n-    \/\/ Current limitation of the implementation:\n-    \/\/ We don't support packed structs on some platforms,\n-    \/\/ so reject them here explicitly\n-    public static void checkHasNaturalAlignment(MemoryLayout layout) {\n-        long naturalByteAlignmnet = naturalByteAlignment(layout);\n-        if (naturalByteAlignmnet != layout.byteAlignment()) {\n-            throw new IllegalArgumentException(\"Layout bit alignment must be natural alignment: \"\n-                    + layout.byteAlignment() + \" != \" + naturalByteAlignmnet);\n-        }\n-    }\n-\n-    private static long naturalByteAlignment(MemoryLayout layout) {\n-        return alignment(layout, true);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":0,"deletions":57,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -198,1 +198,1 @@\n-            long stackSlotAlignment = Utils.alignUp(alignment, STACK_SLOT_SIZE);\n+            long stackSlotAlignment = Math.max(alignment, STACK_SLOT_SIZE);\n@@ -211,1 +211,2 @@\n-            VMStorage storage = AArch64Architecture.stackStorage(encodedSize, (int)alignedStackOffset);\n+            VMStorage storage =\n+                AArch64Architecture.stackStorage(encodedSize, (int)alignedStackOffset);\n@@ -266,2 +267,0 @@\n-        private static final int COPY_CHUNK_SIZE = 8;\n-\n@@ -275,1 +274,0 @@\n-            long align = layout.byteAlignment();\n@@ -277,4 +275,4 @@\n-                long copy = Math.min(layout.byteSize() - offset, COPY_CHUNK_SIZE);\n-                VMStorage storage = storageCalculator.stackAlloc(copy, align);\n-                align = 1; \/\/ only first copy needs aligning\n-                if (offset + COPY_CHUNK_SIZE < layout.byteSize()) {\n+                long copy = Math.min(layout.byteSize() - offset, STACK_SLOT_SIZE);\n+                VMStorage storage =\n+                    storageCalculator.stackAlloc(copy, STACK_SLOT_SIZE);\n+                if (offset + STACK_SLOT_SIZE < layout.byteSize()) {\n@@ -286,1 +284,1 @@\n-                offset += COPY_CHUNK_SIZE;\n+                offset += STACK_SLOT_SIZE;\n@@ -297,1 +295,0 @@\n-            long align = layout.byteAlignment();\n@@ -299,3 +296,3 @@\n-                long copy = Math.min(layout.byteSize() - offset, COPY_CHUNK_SIZE);\n-                VMStorage storage = storageCalculator.stackAlloc(copy, align);\n-                align = 1; \/\/ only first copy needs aligning\n+                long copy = Math.min(layout.byteSize() - offset, STACK_SLOT_SIZE);\n+                VMStorage storage =\n+                    storageCalculator.stackAlloc(copy, STACK_SLOT_SIZE);\n@@ -306,1 +303,1 @@\n-                offset += COPY_CHUNK_SIZE;\n+                offset += STACK_SLOT_SIZE;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":12,"deletions":15,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.internal.foreign.abi.SharedUtils;\n-\n@@ -105,1 +103,0 @@\n-        SharedUtils.checkHasNaturalAlignment(type);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/TypeClass.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-\n@@ -36,1 +35,0 @@\n-import jdk.internal.foreign.abi.SharedUtils;\n@@ -179,1 +177,0 @@\n-        SharedUtils.checkHasNaturalAlignment(type);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/TypeClass.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import jdk.internal.foreign.abi.SharedUtils;\n-\n@@ -85,1 +83,0 @@\n-        SharedUtils.checkHasNaturalAlignment(type);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/TypeClass.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-abstract sealed class AbstractLayout<L extends AbstractLayout<L> & MemoryLayout>\n+public abstract sealed class AbstractLayout<L extends AbstractLayout<L> & MemoryLayout>\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/AbstractLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}