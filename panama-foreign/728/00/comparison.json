{"files":[{"patch":"@@ -97,8 +97,0 @@\n-    \/**\n-     * Align the specified type from a given address\n-     * @return The address the data should be at based on alignment requirement\n-     *\/\n-    public static long align(MemoryLayout t, boolean isVar, long addr) {\n-        return alignUp(addr, alignment(t, isVar));\n-    }\n-\n@@ -378,0 +370,15 @@\n+    \/\/ Current limitation of the implementation:\n+    \/\/ We don't support packed structs on some platforms,\n+    \/\/ so reject them here explicitly\n+    public static void checkHasNaturalAlignment(MemoryLayout layout) {\n+        long naturalByteAlignmnet = naturalByteAlignment(layout);\n+        if (naturalByteAlignmnet != layout.byteAlignment()) {\n+            throw new IllegalArgumentException(\"Layout bit alignment must be natural alignment: \"\n+                    + layout.byteAlignment() + \" != \" + naturalByteAlignmnet);\n+        }\n+    }\n+\n+    private static long naturalByteAlignment(MemoryLayout layout) {\n+        return alignment(layout, true);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -198,1 +198,1 @@\n-            long stackSlotAlignment = Math.max(alignment, STACK_SLOT_SIZE);\n+            long stackSlotAlignment = Utils.alignUp(alignment, STACK_SLOT_SIZE);\n@@ -211,2 +211,1 @@\n-            VMStorage storage =\n-                AArch64Architecture.stackStorage(encodedSize, (int)alignedStackOffset);\n+            VMStorage storage = AArch64Architecture.stackStorage(encodedSize, (int)alignedStackOffset);\n@@ -218,1 +217,1 @@\n-            return stackAlloc(layout.byteSize(), SharedUtils.alignment(layout, true));\n+            return stackAlloc(layout.byteSize(), layout.byteAlignment());\n@@ -267,0 +266,2 @@\n+        private static final int COPY_CHUNK_SIZE = 8;\n+\n@@ -274,0 +275,1 @@\n+            long align = layout.byteAlignment();\n@@ -275,4 +277,4 @@\n-                long copy = Math.min(layout.byteSize() - offset, STACK_SLOT_SIZE);\n-                VMStorage storage =\n-                    storageCalculator.stackAlloc(copy, STACK_SLOT_SIZE);\n-                if (offset + STACK_SLOT_SIZE < layout.byteSize()) {\n+                long copy = Math.min(layout.byteSize() - offset, COPY_CHUNK_SIZE);\n+                VMStorage storage = storageCalculator.stackAlloc(copy, align);\n+                align = 1; \/\/ only first copy needs aligning\n+                if (offset + COPY_CHUNK_SIZE < layout.byteSize()) {\n@@ -284,1 +286,1 @@\n-                offset += STACK_SLOT_SIZE;\n+                offset += COPY_CHUNK_SIZE;\n@@ -295,0 +297,1 @@\n+            long align = layout.byteAlignment();\n@@ -296,3 +299,3 @@\n-                long copy = Math.min(layout.byteSize() - offset, STACK_SLOT_SIZE);\n-                VMStorage storage =\n-                    storageCalculator.stackAlloc(copy, STACK_SLOT_SIZE);\n+                long copy = Math.min(layout.byteSize() - offset, COPY_CHUNK_SIZE);\n+                VMStorage storage = storageCalculator.stackAlloc(copy, align);\n+                align = 1; \/\/ only first copy needs aligning\n@@ -303,1 +306,1 @@\n-                offset += STACK_SLOT_SIZE;\n+                offset += COPY_CHUNK_SIZE;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n+\n@@ -31,1 +33,0 @@\n-import java.lang.foreign.SequenceLayout;\n@@ -104,0 +105,1 @@\n+        SharedUtils.checkHasNaturalAlignment(type);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/TypeClass.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+\n@@ -35,0 +36,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -111,2 +113,2 @@\n-    private static ArgumentClassImpl argumentClassFor(MemoryLayout layout) {\n-        Class<?> carrier = ((ValueLayout)layout).carrier();\n+    private static ArgumentClassImpl argumentClassFor(ValueLayout layout) {\n+        Class<?> carrier = layout.carrier();\n@@ -177,0 +179,1 @@\n+        SharedUtils.checkHasNaturalAlignment(type);\n@@ -221,1 +224,1 @@\n-        } else if (l instanceof ValueLayout) {\n+        } else if (l instanceof ValueLayout vl) {\n@@ -228,2 +231,2 @@\n-            ArgumentClassImpl argumentClass = (offset % l.byteAlignment()) == 0 ?\n-                    argumentClassFor(l) :\n+            ArgumentClassImpl argumentClass = (offset % vl.byteAlignment()) == 0 ?\n+                    argumentClassFor(vl) :\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/TypeClass.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-        VMStorage nextStorage(int type, MemoryLayout layout) {\n+        VMStorage nextStorage(int type) {\n@@ -167,2 +167,1 @@\n-                long alignment = Math.max(SharedUtils.alignment(layout, true), STACK_SLOT_SIZE);\n-                stackOffset = Utils.alignUp(stackOffset, alignment);\n+                assert stackOffset == Utils.alignUp(stackOffset, STACK_SLOT_SIZE); \/\/ should always be aligned\n@@ -204,1 +203,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER, layout);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);\n@@ -214,1 +213,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER, layout);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);\n@@ -220,1 +219,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER, layout);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);\n@@ -225,1 +224,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER, layout);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);\n@@ -230,1 +229,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.VECTOR, layout);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.VECTOR);\n@@ -235,1 +234,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.VECTOR, layout);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.VECTOR);\n@@ -268,1 +267,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER, layout);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);\n@@ -276,1 +275,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER, layout);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);\n@@ -282,1 +281,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER, layout);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);\n@@ -288,1 +287,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER, layout);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);\n@@ -293,1 +292,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.VECTOR, layout);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.VECTOR);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n+\n@@ -83,0 +85,1 @@\n+        SharedUtils.checkHasNaturalAlignment(type);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/TypeClass.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import java.nio.ByteOrder;\n+\n@@ -53,1 +55,2 @@\n-            assertTrue(e.getMessage().contains(expectedExceptionMessage));\n+            assertTrue(e.getMessage().contains(expectedExceptionMessage),\n+                    e.getMessage() + \" != \" + expectedExceptionMessage);\n@@ -76,0 +79,20 @@\n+            {\n+                    FunctionDescriptor.ofVoid(C_INT.withBitAlignment(16)),\n+                    \"Layout bit alignment must be natural alignment\"\n+            },\n+            {\n+                    FunctionDescriptor.ofVoid(C_POINTER.withBitAlignment(16)),\n+                    \"Layout bit alignment must be natural alignment\"\n+            },\n+            {\n+                    FunctionDescriptor.ofVoid(MemoryLayout.valueLayout(char.class, ByteOrder.nativeOrder()).withBitAlignment(32)),\n+                    \"Layout bit alignment must be natural alignment\"\n+            },\n+            {\n+                    FunctionDescriptor.ofVoid(MemoryLayout.structLayout(\n+                            C_CHAR.withName(\"x\").withBitAlignment(8),\n+                            C_SHORT.withName(\"y\").withBitAlignment(8),\n+                            C_INT.withName(\"z\").withBitAlignment(8)\n+                            ).withBitAlignment(8)),\n+                    \"Layout bit alignment must be natural alignment\"\n+            },\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"}]}