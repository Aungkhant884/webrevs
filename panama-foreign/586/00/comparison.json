{"files":[{"patch":"@@ -33,7 +33,0 @@\n- * An addressable instance is associated with a {@linkplain ResourceScope resource scope}; the resource scope determines the\n- * lifecycle of the addressable instance, as well as whether the instance can be used from multiple threads. Some\n- * addressable instances might not be associated with a lifecycle, in which case {@link #scope()} returns the\n- * {@linkplain ResourceScope#globalScope() global scope}. Attempting to obtain a memory address\n- * from an addressable instance whose backing scope has already been {@linkplain ResourceScope#isAlive() closed} always\n- * results in an exception.\n- * <p>\n@@ -47,1 +40,1 @@\n-public interface Addressable {\n+public sealed interface Addressable permits MemorySegment, MemoryAddress, CLinker.UpcallStub, VaList {\n@@ -52,2 +45,0 @@\n-     * @throws IllegalStateException if the scope associated with this addressable has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n@@ -56,6 +47,0 @@\n-\n-    \/**\n-     * Obtains the resource scope associated with this addressable.\n-     * @return the resource scope associated with this addressable.\n-     *\/\n-    ResourceScope scope();\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/Addressable.java","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -71,3 +71,3 @@\n- * All the arguments of type {@link Addressable} passed to a downcall method handle are {@linkplain ResourceScope#keepAlive(ResourceScope) kept alive}\n- * by the linker implementation. This ensures that the resource scopes associated with a by-reference parameters passed\n- * to a downcall method handle can never be closed, either implicitly or {@linkplain ResourceScope#close() explicitly}\n+ * Arguments of type {@link MemorySegment}, {@link VaList} and {@link UpcallStub} passed by-reference to a downcall method handle\n+ * are {@linkplain ResourceScope#keepAlive(ResourceScope) kept alive} by the linker implementation. That is, the resource\n+ * scope associated with such arguments cannot be closed, either implicitly or {@linkplain ResourceScope#close() explicitly}\n@@ -246,0 +246,15 @@\n+\n+        \/**\n+         * Returns the resource scope associated with this instance.\n+         * @return the resource scope associated with this instance.\n+         *\/\n+        ResourceScope scope();\n+\n+        \/**\n+         * Returns the memory address associated with this upcall stub.\n+         * @throws IllegalStateException if the scope associated with this upcall stub has been closed, or if access occurs from\n+         * a thread other than the thread owning that scope.\n+         * @return The memory address associated with this upcall stub.\n+         *\/\n+        @Override\n+        MemoryAddress address();\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -741,9 +741,0 @@\n-\n-    \/**\n-     * Returns the {@linkplain ResourceScope#globalScope() global scope}.\n-     * @return the {@linkplain ResourceScope#globalScope() global scope}.\n-     *\/\n-    @Override\n-    default ResourceScope scope() {\n-        return ResourceScope.globalScope();\n-    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAddress.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -145,0 +145,9 @@\n+    \/**\n+     * Returns the memory address associated with this va list.\n+     * @throws IllegalStateException if the scope associated with this va list has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @return The memory address associated with this va list.\n+     *\/\n+    @Override\n+    MemoryAddress address();\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/VaList.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -34,2 +34,0 @@\n-import jdk.internal.reflect.CallerSensitive;\n-import jdk.internal.reflect.Reflection;\n@@ -60,1 +58,1 @@\n-public abstract non-sealed class AbstractMemorySegmentImpl extends MemorySegmentProxy implements MemorySegment {\n+public abstract non-sealed class AbstractMemorySegmentImpl extends MemorySegmentProxy implements MemorySegment, Scoped {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -42,1 +43,1 @@\n-public final class MemoryAddressImpl implements MemoryAddress {\n+public final class MemoryAddressImpl implements MemoryAddress, Scoped {\n@@ -97,0 +98,5 @@\n+    @Override\n+    public ResourceScope scope() {\n+        return ResourceScopeImpl.GLOBAL;\n+    }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryAddressImpl.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-package p;\n@@ -27,3 +26,3 @@\n-public class Foo {\n-     protected enum T { ONE }\n-}\n+package jdk.internal.foreign;\n+\n+import jdk.incubator.foreign.ResourceScope;\n@@ -31,0 +30,3 @@\n+public interface Scoped {\n+    ResourceScope scope();\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/Scoped.java","additions":6,"deletions":4,"binary":false,"changes":10,"previous_filename":"test\/jdk\/java\/lang\/invoke\/accessClassAndFindClass\/p\/Foo.java","status":"copied"},{"patch":"@@ -42,0 +42,1 @@\n+import jdk.internal.foreign.Scoped;\n@@ -412,1 +413,1 @@\n-        ((ResourceScopeImpl)addressable.scope()).acquire0();\n+        ((ResourceScopeImpl)((Scoped)addressable).scope()).acquire0();\n@@ -418,1 +419,1 @@\n-        ((ResourceScopeImpl)addressable.scope()).release0();\n+        ((ResourceScopeImpl)((Scoped)addressable).scope()).release0();\n@@ -567,1 +568,1 @@\n-    public static non-sealed class EmptyVaList implements VaList {\n+    public static non-sealed class EmptyVaList implements VaList, Scoped {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.incubator.foreign.Addressable;\n@@ -31,1 +30,0 @@\n-import jdk.incubator.foreign.MemorySegment;\n@@ -33,0 +31,1 @@\n+import jdk.internal.foreign.Scoped;\n@@ -57,1 +56,1 @@\n-    public record UpcallStubImpl(long entry, FunctionDescriptor descriptor, MethodHandle target, ResourceScope scope) implements CLinker.UpcallStub {\n+    public record UpcallStubImpl(long entry, FunctionDescriptor descriptor, MethodHandle target, ResourceScope scope) implements Scoped, CLinker.UpcallStub {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallStubs.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.Scoped;\n@@ -52,1 +53,1 @@\n-public non-sealed class LinuxAArch64VaList implements VaList {\n+public non-sealed class LinuxAArch64VaList implements VaList, Scoped {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64VaList.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.Scoped;\n@@ -48,1 +49,1 @@\n-public non-sealed class MacOsAArch64VaList implements VaList {\n+public non-sealed class MacOsAArch64VaList implements VaList, Scoped {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64VaList.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.Scoped;\n@@ -47,1 +48,1 @@\n-public non-sealed class SysVVaList implements VaList {\n+public non-sealed class SysVVaList implements VaList, Scoped {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.Scoped;\n@@ -58,1 +59,1 @@\n-public non-sealed class WinVaList implements VaList {\n+public non-sealed class WinVaList implements VaList, Scoped {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}