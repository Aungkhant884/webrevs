{"files":[{"patch":"@@ -47,0 +47,1 @@\n+import java.lang.foreign.FunctionDescriptor;\n@@ -124,0 +125,2 @@\n+    private static final SoftReferenceCache<FunctionDescriptor, MethodHandle> UPCALL_WRAPPER_CACHE = new SoftReferenceCache<>();\n+\n@@ -154,0 +157,9 @@\n+        if (callingSequence.forUpcall()) {\n+            MethodHandle wrapper = UPCALL_WRAPPER_CACHE.get(callingSequence.functionDesc(), fd -> doSpecialize(leafHandle, callingSequence, abi));\n+            return MethodHandles.insertArguments(wrapper, 0, leafHandle); \/\/ lazily customized for leaf handle instances\n+        } else {\n+            return doSpecialize(leafHandle, callingSequence, abi);\n+        }\n+    }\n+\n+    static MethodHandle doSpecialize(MethodHandle leafHandle, CallingSequence callingSequence, ABIDescriptor abi) {\n@@ -164,0 +176,2 @@\n+        } else { \/\/ upcall\n+            callerMethodType = callerMethodType.insertParameterTypes(0, MethodHandle.class); \/\/ target\n@@ -193,6 +207,7 @@\n-            \/\/ We must initialize the class since the upcall stubs don't have a clinit barrier, and the slow\n-            \/\/ path in the c2i adapter we end up calling can not handle the particular code shape where the\n-            \/\/ caller is an upcall stub.\n-            boolean initialize = callingSequence.forUpcall();\n-            MethodHandles.Lookup lookup = MethodHandles.lookup().defineHiddenClassWithClassData(bytes, leafHandle, initialize);\n-            return lookup.findStatic(lookup.lookupClass(), METHOD_NAME, callerMethodType);\n+            MethodHandles.Lookup defineClassLookup = callingSequence.forUpcall()\n+                \/\/ For upcalls, we must initialize the class since the upcall stubs don't have a clinit barrier,\n+                \/\/ and the slow path in the c2i adapter we end up calling can not handle the particular code shape\n+                \/\/ where the caller is an upcall stub.\n+                ? MethodHandles.lookup().defineHiddenClass(bytes, true)\n+                : MethodHandles.lookup().defineHiddenClassWithClassData(bytes, leafHandle, false);\n+            return defineClassLookup.findStatic(defineClassLookup.lookupClass(), METHOD_NAME, callerMethodType);\n@@ -312,1 +327,1 @@\n-        paramIndex = callingSequence.forDowncall() ? 1 : 0; \/\/ +1 to skip SegmentAllocator\n+        paramIndex = 1; \/\/ +1 to skip SegmentAllocator or MethodHandle\n@@ -346,1 +361,5 @@\n-        mv.visitLdcInsn(CLASS_DATA_CONDY);\n+        if (callingSequence.forDowncall()) {\n+            mv.visitLdcInsn(CLASS_DATA_CONDY);\n+        } else {\n+            emitLoad(BasicType.L, 0); \/\/ load target arg\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":27,"deletions":8,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -212,0 +212,4 @@\n+        } else {\n+            \/\/ adjust return type so it matches the inferred type of the effective\n+            \/\/ function descriptor\n+            target = target.asType(target.type().changeReturnType(Addressable.class));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.CLinker;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.invoke.MethodHandles.lookup;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n+public class LinkUpcall extends CLayouts {\n+\n+    static final CLinker LINKER = CLinker.systemCLinker();\n+    static final MethodHandle BLANK;\n+    static final FunctionDescriptor BLANK_DESC = FunctionDescriptor.ofVoid();\n+\n+    static {\n+        try {\n+            BLANK = lookup().findStatic(LinkUpcall.class, \"blank\", MethodType.methodType(void.class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new BootstrapMethodError(e);\n+        }\n+    }\n+\n+    @Benchmark\n+    public MemorySegment link_blank() {\n+        return LINKER.upcallStub(BLANK, BLANK_DESC, MemorySession.openImplicit());\n+    }\n+\n+    static void blank() {}\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LinkUpcall.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"}]}