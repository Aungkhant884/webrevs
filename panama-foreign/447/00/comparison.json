{"files":[{"patch":"@@ -1,102 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.jextract.impl;\n-\n-import jdk.incubator.jextract.Type;\n-import java.util.stream.Collectors;\n-\n-public class AnnotationWriter implements Type.Visitor<String, Void> {\n-    @Override\n-    public String visitPrimitive(Type.Primitive t, Void aVoid) {\n-        if (t.kind().layout().isEmpty()) {\n-            return \"void\"; \/\/skip for now\n-        } else {\n-            return t.kind().typeName();\n-        }\n-    }\n-\n-    @Override\n-    public String visitDelegated(Type.Delegated t, Void aVoid) {\n-        if (t.kind() == Type.Delegated.Kind.TYPEDEF) {\n-            return t.name().get();\n-        } else if (t.kind() == Type.Delegated.Kind.POINTER) {\n-            String typeStr = t.type().accept(this, null);\n-            \/\/ FIXME Revisit this logic for pointer to function types\n-            if (t.type() instanceof Type.Function) {\n-                return typeStr.replace(\"(\", \"(*)(\");\n-            } else {\n-                return typeStr + \"*\";\n-            }\n-        } else {\n-            String prefix = switch (t.kind()) {\n-                case ATOMIC -> \"_Atomic\";\n-                case COMPLEX -> \"complex\";\n-                case SIGNED -> \"signed\";\n-                case UNSIGNED -> \"unsigned\";\n-                case VOLATILE -> \"volatile\";\n-                default -> throw new IllegalStateException(\"Invalid input\" + t);\n-            };\n-            return prefix + \" \" + t.type().accept(this, null);\n-        }\n-    }\n-\n-    @Override\n-    public String visitFunction(Type.Function t, Void aVoid) {\n-        String ret = t.returnType().accept(this, null);\n-        String args = t.argumentTypes().stream().map(p -> p.accept(this, null))\n-                .collect(Collectors.joining(\",\", \"(\", \")\"));\n-        return ret + args;\n-    }\n-\n-    @Override\n-    public String visitDeclared(Type.Declared t, Void aVoid) {\n-        String name = t.tree().name();\n-        return switch (t.tree().kind()) {\n-            case STRUCT -> \"struct \" + name;\n-            case UNION -> \"union \" + name;\n-            case ENUM -> \"enum \" + name;\n-            default -> name;\n-        };\n-    }\n-\n-    @Override\n-    public String visitArray(Type.Array t, Void aVoid) {\n-        if (t.kind() == Type.Array.Kind.VECTOR) {\n-            return \"\"; \/\/skip for now\n-        } else {\n-            return t.elementType().accept(this, null) + \"[]\";\n-        }\n-    }\n-\n-    @Override\n-    public String visitType(Type t, Void aVoid) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    String getCAnnotation(Type t) {\n-        return \"@C(\\\"\" + t.accept(this, null) + \"\\\")\";\n-    }\n-}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/AnnotationWriter.java","additions":0,"deletions":102,"binary":false,"changes":102,"status":"deleted"},{"patch":"@@ -34,2 +34,0 @@\n-\n-    private final String fiAnno;\n@@ -44,1 +42,0 @@\n-        this.fiAnno = annotationWriter.getCAnnotation(funcType);\n@@ -70,1 +67,1 @@\n-        builder.append(PUB_MODS + \" \" + fiAnno + \" MemorySegment allocate(\" + className + \" fi) {\\n\");\n+        builder.append(PUB_MODS + \" MemorySegment allocate(\" + className + \" fi) {\\n\");\n@@ -79,1 +76,1 @@\n-        builder.append(PUB_MODS + \" \" + fiAnno + \" MemorySegment allocate(\" + className + \" fi, NativeScope scope) {\\n\");\n+        builder.append(PUB_MODS + \" MemorySegment allocate(\" + className + \" fi, NativeScope scope) {\\n\");\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/FunctionalInterfaceBuilder.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -46,2 +46,2 @@\n-    HeaderFileBuilder(String clsName, String pkgName, String superclass, ConstantHelper constantHelper, AnnotationWriter annotationWriter) {\n-        super(new StringSourceBuilder(), Kind.CLASS, clsName, pkgName, constantHelper, annotationWriter);\n+    HeaderFileBuilder(String clsName, String pkgName, String superclass, ConstantHelper constantHelper) {\n+        super(new StringSourceBuilder(), Kind.CLASS, clsName, pkgName, constantHelper);\n@@ -62,1 +62,1 @@\n-                                  boolean varargs, List<String> paramNames, List<String> annos, String returnAnno) {\n+                                  boolean varargs, List<String> paramNames) {\n@@ -66,4 +66,0 @@\n-        if (mtype.returnType() != void.class) {\n-            builder.append(returnAnno);\n-            builder.append(' ');\n-        }\n@@ -88,1 +84,1 @@\n-            builder.append(delim + annos.get(i) + \" \" + pType.getSimpleName() + \" \" + pName);\n+            builder.append(delim + \" \" + pType.getSimpleName() + \" \" + pName);\n@@ -130,1 +126,1 @@\n-    void emitPrimitiveTypedef(Type.Primitive primType, String name, String anno) {\n+    void emitPrimitiveTypedef(Type.Primitive primType, String name) {\n@@ -136,1 +132,1 @@\n-            builder.append(anno + \" ValueLayout \");\n+            builder.append(\" ValueLayout \");\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/HeaderFileBuilder.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-    protected final AnnotationWriter annotationWriter;\n@@ -66,1 +65,1 @@\n-    JavaSourceBuilder(StringSourceBuilder builder, Kind kind, String className, String pkgName, ConstantHelper constantHelper, AnnotationWriter annotationWriter) {\n+    JavaSourceBuilder(StringSourceBuilder builder, Kind kind, String className, String pkgName, ConstantHelper constantHelper) {\n@@ -72,1 +71,0 @@\n-        this.annotationWriter = annotationWriter;\n@@ -92,3 +90,0 @@\n-        if (type() != null) {\n-            builder.append(annotationWriter.getCAnnotation(type()));\n-        }\n@@ -124,1 +119,1 @@\n-        emitForwardGetter(constantHelper.addLayout(javaName, layout), \"\");\n+        emitForwardGetter(constantHelper.addLayout(javaName, layout));\n@@ -128,1 +123,1 @@\n-        emitForwardGetter(constantHelper.addGlobalVarHandle(javaName, nativeName, layout, type), \"\");\n+        emitForwardGetter(constantHelper.addGlobalVarHandle(javaName, nativeName, layout, type));\n@@ -132,1 +127,1 @@\n-        emitForwardGetter(constantHelper.addMethodHandle(javaName, nativeName, mtype, desc, varargs), \"\",\n+        emitForwardGetter(constantHelper.addMethodHandle(javaName, nativeName, mtype, desc, varargs),\n@@ -137,1 +132,1 @@\n-        emitForwardGetter(constantHelper.addSegment(javaName, nativeName, layout), \"\",\n+        emitForwardGetter(constantHelper.addSegment(javaName, nativeName, layout),\n@@ -141,2 +136,2 @@\n-    void addConstantGetter(String javaName, Class<?> type, Object value, String anno) {\n-        emitForwardGetter(constantHelper.addConstant(javaName, type, value), anno);\n+    void addConstantGetter(String javaName, Class<?> type, Object value) {\n+        emitForwardGetter(constantHelper.addConstant(javaName, type, value));\n@@ -145,1 +140,1 @@\n-    void addGetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, String anno) {\n+    void addGetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n@@ -148,1 +143,1 @@\n-        builder.append(PUB_MODS + anno + \" \" + type.getSimpleName() + \" \" + javaName + \"$get() {\\n\");\n+        builder.append(PUB_MODS + \" \" + type.getSimpleName() + \" \" + javaName + \"$get() {\\n\");\n@@ -165,1 +160,1 @@\n-    void addSetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, String anno) {\n+    void addSetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n@@ -168,1 +163,1 @@\n-        builder.append(PUB_MODS + \"void \" + javaName + \"$set(\" + anno + \" \" + type.getSimpleName() + \" x) {\\n\");\n+        builder.append(PUB_MODS + \"void \" + javaName + \"$set(\" + \" \" + type.getSimpleName() + \" x) {\\n\");\n@@ -207,2 +202,2 @@\n-    protected void emitForwardGetter(DirectMethodHandleDesc desc, String anno) {\n-        emitForwardGetter(desc, anno, false, \"\");\n+    protected void emitForwardGetter(DirectMethodHandleDesc desc) {\n+        emitForwardGetter(desc, false, \"\");\n@@ -211,1 +206,1 @@\n-    protected void emitForwardGetter(DirectMethodHandleDesc desc, String anno, boolean nullCheck, String errMsg) {\n+    protected void emitForwardGetter(DirectMethodHandleDesc desc, boolean nullCheck, String errMsg) {\n@@ -214,1 +209,1 @@\n-        builder.append(PUB_MODS + anno + \" \" + displayName(desc.invocationType().returnType()) + \" \" + desc.methodName() + \"() {\\n\");\n+        builder.append(PUB_MODS + \" \" + displayName(desc.invocationType().returnType()) + \" \" + desc.methodName() + \"() {\\n\");\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/JavaSourceBuilder.java","additions":15,"deletions":20,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-        super(enclosing.builder, kind, enclosing.uniqueNestedClassName(className), enclosing.pkgName, enclosing.constantHelper, enclosing.annotationWriter);\n+        super(enclosing.builder, kind, enclosing.uniqueNestedClassName(className), enclosing.pkgName, enclosing.constantHelper);\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/NestedClassBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,1 +68,0 @@\n-    protected final AnnotationWriter annotationWriter;\n@@ -101,3 +100,2 @@\n-        AnnotationWriter annotationWriter = new AnnotationWriter();\n-        ToplevelBuilder toplevelBuilder = new ToplevelBuilder(clsName, pkgName, constantHelper, annotationWriter);\n-        return new OutputFactory(pkgName, toplevelBuilder, annotationWriter).generate(decl);\n+        ToplevelBuilder toplevelBuilder = new ToplevelBuilder(clsName, pkgName, constantHelper);\n+        return new OutputFactory(pkgName, toplevelBuilder).generate(decl);\n@@ -106,2 +104,1 @@\n-    private OutputFactory(String pkgName, ToplevelBuilder toplevelBuilder,\n-                          AnnotationWriter annotationWriter) {\n+    private OutputFactory(String pkgName, ToplevelBuilder toplevelBuilder) {\n@@ -111,1 +108,0 @@\n-        this.annotationWriter = annotationWriter;\n@@ -181,1 +177,0 @@\n-        String anno = annotationWriter.getCAnnotation(constant.type());\n@@ -184,1 +179,1 @@\n-                typeTranslator.getJavaType(constant.type()), constant.value(), anno);\n+                typeTranslator.getJavaType(constant.type()), constant.value());\n@@ -356,7 +351,0 @@\n-        List<String> annos = funcTree.parameters()\n-                .stream()\n-                .map(Declaration.Variable::type)\n-                .map(annotationWriter::getCAnnotation)\n-                .collect(Collectors.toList());\n-        String returnAnno = annotationWriter.getCAnnotation(funcTree.type().returnType());\n-\n@@ -376,1 +364,1 @@\n-                Type.descriptorFor(funcTree.type()).orElseThrow(), funcTree.type().varargs(), paramNames, annos, returnAnno);\n+                Type.descriptorFor(funcTree.type()).orElseThrow(), funcTree.type().varargs(), paramNames);\n@@ -441,2 +429,1 @@\n-             String anno = annotationWriter.getCAnnotation(type);\n-             header().emitPrimitiveTypedef((Type.Primitive)type, tree.name(), anno);\n+             header().emitPrimitiveTypedef((Type.Primitive)type, tree.name());\n@@ -491,1 +478,0 @@\n-        String anno = annotationWriter.getCAnnotation(type);\n@@ -516,2 +502,2 @@\n-                currentBuilder.addGetter(fieldName, tree.name(), treeLayout, clazz, anno);\n-                currentBuilder.addSetter(fieldName, tree.name(), treeLayout, clazz, anno);\n+                currentBuilder.addGetter(fieldName, tree.name(), treeLayout, clazz);\n+                currentBuilder.addSetter(fieldName, tree.name(), treeLayout, clazz);\n@@ -527,2 +513,2 @@\n-                    header().addGetter(fieldName, tree.name(), treeLayout, clazz, anno);\n-                    header().addSetter(fieldName, tree.name(), treeLayout, clazz, anno);\n+                    header().addGetter(fieldName, tree.name(), treeLayout, clazz);\n+                    header().addSetter(fieldName, tree.name(), treeLayout, clazz);\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/OutputFactory.java","additions":10,"deletions":24,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-        super(new StringSourceBuilder(), Kind.CLASS, className, packageName, null, null);\n+        super(new StringSourceBuilder(), Kind.CLASS, className, packageName, null);\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/SourceConstantHelper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,3 +44,0 @@\n-    private final String structAnno;\n-    private final String structArrayAnno;\n-    private final String structPtrAnno;\n@@ -53,3 +50,0 @@\n-        this.structAnno = annotationWriter.getCAnnotation(structType);\n-        this.structArrayAnno = annotationWriter.getCAnnotation(Type.array(structType));\n-        this.structPtrAnno = annotationWriter.getCAnnotation(Type.pointer(structType));\n@@ -125,1 +119,1 @@\n-    void addGetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, String anno) {\n+    void addGetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n@@ -128,1 +122,1 @@\n-        builder.append(PUB_MODS + \" \" + anno + \" \" + type.getSimpleName() + \" \" + javaName + \"$get(\" + this.structAnno + \" MemorySegment seg) {\\n\");\n+        builder.append(PUB_MODS + \" \" + type.getSimpleName() + \" \" + javaName + \"$get(MemorySegment seg) {\\n\");\n@@ -138,1 +132,1 @@\n-        addIndexGetter(javaName, nativeName, layout, type, anno);\n+        addIndexGetter(javaName, nativeName, layout, type);\n@@ -142,1 +136,1 @@\n-    void addSetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, String anno) {\n+    void addSetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n@@ -146,1 +140,1 @@\n-        builder.append(PUB_MODS + \"void \" + javaName + \"$set(\" + this.structAnno + \" \" + param + \", \" + anno + \" \" + type.getSimpleName() + \" x) {\\n\");\n+        builder.append(PUB_MODS + \"void \" + javaName + \"$set( \" + param + \", \" + type.getSimpleName() + \" x) {\\n\");\n@@ -155,1 +149,1 @@\n-        addIndexSetter(javaName, nativeName, layout, type, anno);\n+        addIndexSetter(javaName, nativeName, layout, type);\n@@ -200,1 +194,1 @@\n-        builder.append(structAnno + \" MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\\n\");\n+        builder.append(\" MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\\n\");\n@@ -208,1 +202,1 @@\n-        builder.append(structAnno + \" MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\\n\");\n+        builder.append(\" MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\\n\");\n@@ -216,1 +210,1 @@\n-        builder.append(structArrayAnno + \" MemorySegment allocateArray(int len) {\\n\");\n+        builder.append(\" MemorySegment allocateArray(int len) {\\n\");\n@@ -230,1 +224,1 @@\n-        builder.append(structArrayAnno + \" MemorySegment allocateArray(int len, NativeScope scope) {\\n\");\n+        builder.append(\" MemorySegment allocateArray(int len, NativeScope scope) {\\n\");\n@@ -244,1 +238,1 @@\n-        builder.append(structPtrAnno + \" MemorySegment allocatePointer() {\\n\");\n+        builder.append(\" MemorySegment allocatePointer() {\\n\");\n@@ -258,1 +252,1 @@\n-        builder.append(structPtrAnno + \" MemorySegment allocatePointer(NativeScope scope) {\\n\");\n+        builder.append(\" MemorySegment allocatePointer(NativeScope scope) {\\n\");\n@@ -272,1 +266,1 @@\n-        builder.append(structAnno + \" MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\\n\");\n+        builder.append(\" MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\\n\");\n@@ -276,1 +270,1 @@\n-    private void addIndexGetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, String anno) {\n+    private void addIndexGetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n@@ -279,2 +273,2 @@\n-        String params = this.structAnno + \" \" + MemorySegment.class.getSimpleName() + \" seg, long index\";\n-        builder.append(PUB_MODS + \" \" + anno + \" \" + type.getSimpleName() + \" \" + javaName + \"$get(\" + params + \") {\\n\");\n+        String params = MemorySegment.class.getSimpleName() + \" seg, long index\";\n+        builder.append(PUB_MODS + \" \" + type.getSimpleName() + \" \" + javaName + \"$get(\" + params + \") {\\n\");\n@@ -292,1 +286,1 @@\n-    private void addIndexSetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, String anno) {\n+    private void addIndexSetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n@@ -295,1 +289,1 @@\n-        String params = this.structAnno + \" \" + MemorySegment.class.getSimpleName() + \" seg, long index, \" + anno + \" \" + type.getSimpleName() + \" x\";\n+        String params = MemorySegment.class.getSimpleName() + \" seg, long index, \" + type.getSimpleName() + \" x\";\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/StructBuilder.java","additions":18,"deletions":24,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -46,2 +46,2 @@\n-    ToplevelBuilder(String headerFileName, String pkgName, ConstantHelper constantHelper, AnnotationWriter annotationWriter) {\n-        super(headerFileName, pkgName, null, constantHelper, annotationWriter);\n+    ToplevelBuilder(String headerFileName, String pkgName, ConstantHelper constantHelper) {\n+        super(headerFileName, pkgName, null, constantHelper);\n@@ -96,1 +96,1 @@\n-                    constantHelper, annotationWriter);\n+                    constantHelper);\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/ToplevelBuilder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-        String anno = annotationWriter.getCAnnotation(Type.pointer(type));\n@@ -65,1 +64,1 @@\n-        builder.append(anno + \" MemorySegment allocatePointer() {\\n\");\n+        builder.append(\" MemorySegment allocatePointer() {\\n\");\n@@ -78,1 +77,1 @@\n-        builder.append(anno + \" MemorySegment allocatePointer(NativeScope scope) {\\n\");\n+        builder.append(\" MemorySegment allocatePointer(NativeScope scope) {\\n\");\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/TypedefBuilder.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,148 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.lang.annotation.Annotation;\n-import java.lang.reflect.AnnotatedElement;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Parameter;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.NativeScope;\n-import java.nio.file.Path;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.assertEquals;\n-\n-\/*\n- * @test\n- * @bug 8252634\n- * @summary jextract should generate type annotations for C types\n- * @library \/test\/lib\n- * @modules jdk.incubator.jextract\n- * @build JextractToolRunner\n- * @run testng\/othervm -Dforeign.restricted=permit Test8252634\n- *\/\n-public class Test8252634 extends JextractToolRunner {\n-    private Class<? extends Annotation> cAnnoClass;\n-    private Method cValueMethod;\n-\n-    @Test\n-    public void test() throws Throwable {\n-        Path outputPath = getOutputFilePath(\"output8252634\");\n-        Path headerFile = getInputFilePath(\"test8252634.h\");\n-        run(\"-d\", outputPath.toString(), headerFile.toString()).checkSuccess();\n-        try(Loader loader = classLoader(outputPath)) {\n-            this.cAnnoClass = (Class<? extends Annotation>)loader.loadClass(\"C\");\n-            this.cValueMethod = findMethod(cAnnoClass, \"value\");\n-\n-            Class<?> headerClass = loader.loadClass(\"test8252634_h\");\n-            checkGlobalFunctions(headerClass);\n-            checkGlobalVariables(headerClass);\n-\n-            Class<?> fooTypedefClass = loader.loadClass(\"test8252634_h$Foo\");\n-            checkAnnotation(fooTypedefClass, \"struct foo\");\n-            checkFooAllocatePointer(fooTypedefClass);\n-\n-            Class<?> pointClass = loader.loadClass(\"test8252634_h$Point\");\n-            checkPointGetters(pointClass);\n-            checkPointSetters(pointClass);\n-            checkPointAllocate(pointClass);\n-        } finally {\n-            deleteDir(outputPath);\n-        }\n-    }\n-\n-    private void checkGlobalFunctions(Class<?> headerClass) throws Throwable {\n-        Method make = findMethod(headerClass, \"make\", int.class, int.class);\n-        Parameter[] params = make.getParameters();\n-        checkAnnotation(params[0].getAnnotatedType(), \"int\");\n-        checkAnnotation(params[1].getAnnotatedType(), \"int\");\n-        checkAnnotation(make.getAnnotatedReturnType(), \"struct Point*\");\n-        Method func = findFirstMethod(headerClass, \"func\");\n-        params = func.getParameters();\n-        checkAnnotation(params[0].getAnnotatedType(), \"int(*)(int)\");\n-    }\n-\n-    private void checkGlobalVariables(Class<?> headerClass) throws Throwable {\n-        Method pGetter = findMethod(headerClass, \"p$get\");\n-        checkAnnotation(pGetter.getAnnotatedReturnType(), \"int_ptr\");\n-        Method pSetter = findMethod(headerClass, \"p$set\", MemoryAddress.class);\n-        checkAnnotation(pSetter.getParameters()[0].getAnnotatedType(), \"int_ptr\");\n-    }\n-\n-    private void checkPointGetters(Class<?> pointClass) throws Throwable {\n-        Method xGetter = findMethod(pointClass, \"x$get\", MemorySegment.class);\n-        checkAnnotation(xGetter.getParameters()[0].getAnnotatedType(), \"struct Point\");\n-        checkAnnotation(xGetter.getAnnotatedReturnType(), \"int\");\n-        Method yGetter = findMethod(pointClass, \"y$get\", MemorySegment.class);\n-        checkAnnotation(yGetter.getParameters()[0].getAnnotatedType(), \"struct Point\");\n-        checkAnnotation(yGetter.getAnnotatedReturnType(), \"int\");\n-        Method xIndexedGetter = findMethod(pointClass, \"x$get\", MemorySegment.class, long.class);\n-        checkAnnotation(xIndexedGetter.getParameters()[0].getAnnotatedType(), \"struct Point\");\n-        checkAnnotation(xIndexedGetter.getAnnotatedReturnType(), \"int\");\n-        Method yIndexedGetter = findMethod(pointClass, \"y$get\", MemorySegment.class, long.class);\n-        checkAnnotation(yIndexedGetter.getParameters()[0].getAnnotatedType(), \"struct Point\");\n-        checkAnnotation(yIndexedGetter.getAnnotatedReturnType(), \"int\");\n-    }\n-\n-    private void checkPointSetters(Class<?> pointClass) throws Throwable {\n-        Method xSetter = findMethod(pointClass, \"x$set\", MemorySegment.class, int.class);\n-        checkAnnotation(xSetter.getParameters()[0].getAnnotatedType(), \"struct Point\");\n-        checkAnnotation(xSetter.getParameters()[1].getAnnotatedType(), \"int\");\n-        Method ySetter = findMethod(pointClass, \"y$set\", MemorySegment.class, int.class);\n-        checkAnnotation(ySetter.getParameters()[0].getAnnotatedType(), \"struct Point\");\n-        checkAnnotation(ySetter.getParameters()[1].getAnnotatedType(), \"int\");\n-        Method xIndexedSetter = findMethod(pointClass, \"x$set\", MemorySegment.class, long.class, int.class);\n-        checkAnnotation(xIndexedSetter.getParameters()[0].getAnnotatedType(), \"struct Point\");\n-        checkAnnotation(xIndexedSetter.getParameters()[2].getAnnotatedType(), \"int\");\n-        Method yIndexedSetter = findMethod(pointClass, \"y$set\", MemorySegment.class, long.class, int.class);\n-        checkAnnotation(yIndexedSetter.getParameters()[0].getAnnotatedType(), \"struct Point\");\n-        checkAnnotation(yIndexedSetter.getParameters()[2].getAnnotatedType(), \"int\");\n-    }\n-\n-    private void checkPointAllocate(Class<?> pointClass) throws Throwable {\n-        Method allocate = findMethod(pointClass, \"allocate\");\n-        checkAnnotation(allocate.getAnnotatedReturnType(), \"struct Point\");\n-        allocate = findMethod(pointClass, \"allocate\", NativeScope.class);\n-        checkAnnotation(allocate.getAnnotatedReturnType(), \"struct Point\");\n-        Method allocateArray = findMethod(pointClass, \"allocateArray\", int.class);\n-        checkAnnotation(allocateArray.getAnnotatedReturnType(), \"struct Point[]\");\n-        allocateArray = findMethod(pointClass, \"allocateArray\", int.class, NativeScope.class);\n-        checkAnnotation(allocateArray.getAnnotatedReturnType(), \"struct Point[]\");\n-        Method allocatePointer = findMethod(pointClass, \"allocatePointer\");\n-        checkAnnotation(allocatePointer.getAnnotatedReturnType(), \"struct Point*\");\n-        allocatePointer = findMethod(pointClass, \"allocatePointer\", NativeScope.class);\n-        checkAnnotation(allocatePointer.getAnnotatedReturnType(), \"struct Point*\");\n-    }\n-\n-    private void checkFooAllocatePointer(Class<?> fooClass) throws Throwable {\n-        Method allocatePointer = findMethod(fooClass, \"allocatePointer\");\n-        checkAnnotation(allocatePointer.getAnnotatedReturnType(), \"struct foo*\");\n-        allocatePointer = findMethod(fooClass, \"allocatePointer\", NativeScope.class);\n-        checkAnnotation(allocatePointer.getAnnotatedReturnType(), \"struct foo*\");\n-    }\n-\n-    private void checkAnnotation(AnnotatedElement ae, String expected) throws Throwable {\n-        Object anno = ae.getAnnotation(cAnnoClass);\n-        assertEquals(cValueMethod.invoke(anno).toString(), expected);\n-    }\n-}\n","filename":"test\/jdk\/tools\/jextract\/Test8252634.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"deleted"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif \/\/ __cplusplus\n-\n-struct Point {\n-    int x; int y;\n-};\n-\n-struct Point* make(int x, int y);\n-\n-void func(int (*callback)(int));\n-\n-typedef int* int_ptr;\n-int_ptr p;\n-\n-typedef struct foo Foo;\n-\n-#ifdef __cplusplus\n-}\n-#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/test8252634.h","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -50,2 +50,1 @@\n-        C c1 = mGet.getAnnotatedReturnType().getAnnotation(C.class);\n-        assertEquals(c1.value(), \"int\");\n+        assertEquals(mGet.getReturnType(), int.class);\n@@ -54,2 +53,1 @@\n-        C c2 = mSet.getAnnotatedParameterTypes()[0].getAnnotation(C.class);\n-        assertEquals(c2.value(), \"int\");\n+        assertEquals(mSet.getParameterTypes()[0], int.class);\n","filename":"test\/jdk\/tools\/jextract\/testGlobalRedefinition\/TestGlobalRedefinition.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"}]}