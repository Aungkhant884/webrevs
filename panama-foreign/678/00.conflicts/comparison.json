{"files":[{"patch":"@@ -94,1 +94,1 @@\n-    DISABLED_WARNINGS := processing rawtypes cast serial, \\\n+    DISABLED_WARNINGS := processing rawtypes cast serial preview, \\\n@@ -97,0 +97,1 @@\n+<<<<<<< HEAD\n@@ -99,0 +100,3 @@\n+=======\n+    JAVAC_FLAGS := --add-exports java.base\/sun.security.util=ALL-UNNAMED --enable-preview, \\\n+>>>>>>> 1c3421e54c127b7e2af984c5b705407355759e47\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -71,0 +71,21 @@\n+\/*\n+ * To store problematic threads during an handshake, we need an atomic data structure.\n+ * This is because the handshake closure can run concurrently either on the thread that\n+ * is the target of the handshake operation, or on the thread that is performing the\n+ * handshake (e.g. if the target thread is blocked, or in native state).\n+ *\/\n+class LockFreeStackThreadsElement : public CHeapObj<mtInternal> {\n+  typedef LockFreeStackThreadsElement Element;\n+\n+  Element* volatile _next;\n+  static Element* volatile* next_ptr(Element& e) { return &e._next; }\n+\n+public:\n+  JavaThread* _thread;\n+  LockFreeStackThreadsElement(JavaThread* thread) : _next(nullptr), _thread(thread) {}\n+  typedef LockFreeStack<Element, &next_ptr> ThreadStack;\n+};\n+\n+typedef LockFreeStackThreadsElement::ThreadStack ThreadStack;\n+typedef LockFreeStackThreadsElement ThreadStackElement;\n+\n@@ -73,1 +94,1 @@\n-  jobject _exception;\n+  ThreadStack *_threads;\n@@ -76,3 +97,1 @@\n-  jboolean _found;\n-\n-  CloseScopedMemoryClosure(jobject deopt, jobject exception)\n+  CloseScopedMemoryClosure(jobject deopt, ThreadStack *threads)\n@@ -81,2 +100,1 @@\n-    , _exception(exception)\n-    , _found(false) {}\n+    , _threads(threads) {}\n@@ -125,1 +143,2 @@\n-              _found = true;\n+              ThreadStackElement *element = new ThreadStackElement(jt);\n+              _threads->push(*element);\n@@ -143,0 +162,1 @@\n+<<<<<<< HEAD\n@@ -149,0 +169,13 @@\n+=======\n+ * This function performs a thread-local handshake against all threads running at the time\n+ * the given scope (deopt) was closed. If the hanshake for a given thread is processed while\n+ * the thread is inside a scoped method (that is, a method inside the ScopedMemoryAccess\n+ * class annotated with the '@Scoped' annotation), whose local variables mention the scope being\n+ * closed (deopt), the thread is added to a problematic list. After the handshake, each thread in\n+ * the problematic list is handshaked again, individually, to check that it has exited\n+ * the scoped method. This should happen quickly, because once we find a problematic\n+ * thread, we also deoptimize it, meaning that when the thread resumes execution, the thread\n+ * should also see the updated scope state (and fail on access). This function returns when\n+ * the list of problematic threads is empty. To prevent premature thread termination we take\n+ * a snapshot of the live threads in the system using a ThreadsListHandle.\n+>>>>>>> 1c3421e54c127b7e2af984c5b705407355759e47\n@@ -150,2 +183,4 @@\n-JVM_ENTRY(jboolean, ScopedMemoryAccess_closeScope(JNIEnv *env, jobject receiver, jobject deopt, jobject exception))\n-  CloseScopedMemoryClosure cl(deopt, exception);\n+JVM_ENTRY(void, ScopedMemoryAccess_closeScope(JNIEnv *env, jobject receiver, jobject deopt))\n+  ThreadStack threads;\n+  CloseScopedMemoryClosure cl(deopt, &threads);\n+  \/\/ do a first handshake and collect all problematic threads\n@@ -153,1 +188,20 @@\n-  return !cl._found;\n+  if (threads.empty()) {\n+    \/\/ fast-path: return if no problematic thread is found\n+    return;\n+  }\n+  \/\/ Now iterate over all problematic threads, until we converge. Note: from this point on,\n+  \/\/ we only need to focus on the problematic threads found in the previous step, as\n+  \/\/ any new thread created after the initial handshake will see the scope as CLOSED,\n+  \/\/ and will fail to access memory anyway.\n+  ThreadsListHandle tlh;\n+  ThreadStackElement *element = threads.pop();\n+  while (element != NULL) {\n+    JavaThread* thread = element->_thread;\n+    \/\/ If the thread is not in the list handle, it means that the thread has died,\n+    \/\/ so that we can safely skip further handshakes.\n+    if (tlh.list()->includes(thread)) {\n+      Handshake::execute(&cl, thread);\n+    }\n+    delete element;\n+    element = threads.pop();\n+  }\n@@ -158,1 +212,2 @@\n-#define PKG \"Ljdk\/internal\/misc\/\"\n+#define PKG_MISC \"Ljdk\/internal\/misc\/\"\n+#define PKG_FOREIGN \"Ljdk\/internal\/foreign\/\"\n@@ -161,2 +216,1 @@\n-#define SCOPE PKG MEMACCESS \"$Scope;\"\n-#define SCOPED_ERR PKG MEMACCESS \"$Scope$ScopedAccessError;\"\n+#define SCOPE PKG_FOREIGN \"MemorySessionImpl;\"\n@@ -168,1 +222,1 @@\n-    {CC \"closeScope0\",   CC \"(\" SCOPE SCOPED_ERR \")Z\",           FN_PTR(ScopedMemoryAccess_closeScope)},\n+    {CC \"closeScope0\",   CC \"(\" SCOPE \")V\",           FN_PTR(ScopedMemoryAccess_closeScope)},\n@@ -174,1 +228,2 @@\n-#undef PKG\n+#undef PKG_MISC\n+#undef PKG_FOREIGN\n@@ -177,1 +232,0 @@\n-#undef SCOPED_EXC\n","filename":"src\/hotspot\/share\/prims\/scopedMemoryAccess.cpp","additions":70,"deletions":16,"binary":false,"changes":86,"status":"modified"}]}