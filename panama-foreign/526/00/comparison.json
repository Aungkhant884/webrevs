{"files":[{"patch":"@@ -2429,1 +2429,1 @@\n-    private static long findNative(ClassLoader loader, String entryName) {\n+    static long findNative(ClassLoader loader, String entryName) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassLoader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2347,0 +2347,5 @@\n+\n+            @Override\n+            public long findNative(ClassLoader loader, String entry) {\n+                return ClassLoader.findNative(loader, entry);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -385,0 +385,2 @@\n+\n+    long findNative(ClassLoader loader, String entry);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -387,14 +387,0 @@\n-    public static final NativeLibrary defaultLibrary = new NativeLibraryImpl(Object.class, \"<default>\", true, true) {\n-\n-        @Override\n-        boolean open() {\n-            throw new UnsupportedOperationException(\"Cannot load default library\");\n-        }\n-\n-        @Override\n-        public long find(String name) {\n-            return NativeLibraries.findEntryInProcess(name);\n-        }\n-\n-    };\n-\n@@ -481,1 +467,0 @@\n-    private static native long findEntryInProcess(String name);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/NativeLibraries.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -249,23 +249,0 @@\n-\/*\n- * Class:     jdk_internal_loader_NativeLibraries\n- * Method:    findEntryInProcess\n- * Signature: (Ljava\/lang\/String;)J\n- *\/\n-JNIEXPORT jlong JNICALL\n-Java_jdk_internal_loader_NativeLibraries_findEntryInProcess\n-  (JNIEnv *env, jclass cls, jstring name)\n-{\n-    const char *cname;\n-    jlong res;\n-\n-    if (!initIDs(env))\n-        return jlong_zero;\n-\n-    cname = (*env)->GetStringUTFChars(env, name, 0);\n-    if (cname == 0)\n-        return jlong_zero;\n-    res = ptr_to_jlong(findEntryInProcess(cname));\n-    (*env)->ReleaseStringUTFChars(env, name, cname);\n-    return res;\n-}\n-\n","filename":"src\/java.base\/share\/native\/libjava\/NativeLibraries.c","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -336,2 +336,0 @@\n-void* findEntryInProcess(const char* name);\n-\n","filename":"src\/java.base\/share\/native\/libjava\/jni_util.h","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,4 +54,0 @@\n-void* findEntryInProcess(const char* name) {\n-    return JVM_FindLibraryEntry(RTLD_DEFAULT, name);\n-}\n-\n","filename":"src\/java.base\/unix\/native\/libjava\/jni_util_md.c","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,25 +39,0 @@\n-\/*\n- * Windows doesn't have an RTLD_DEFAULT equivalent, so in stead we have to\n- * iterate over all the modules loaded by the process to implement the\n- * default library behaviour.\n- *\/\n-void* findEntryInProcess(const char* name) {\n-    HANDLE hProcess = GetCurrentProcess();\n-\n-    HMODULE hMods[1024];\n-    DWORD cbNeeded; \/\/ array size in bytes\n-\n-    \/\/ first come, first served\n-    if (EnumProcessModules(hProcess, hMods, sizeof(hMods), &cbNeeded)) {\n-        for (size_t i = 0; i < (cbNeeded \/ sizeof(HMODULE)); i++) {\n-            HMODULE mod = hMods[i];\n-            FARPROC proc = GetProcAddress(mod, name);\n-            if(proc != NULL) {\n-                return proc;\n-            }\n-        }\n-    }\n-\n-    return NULL;\n-}\n-\n","filename":"src\/java.base\/windows\/native\/libjava\/jni_util_md.c","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -39,0 +41,1 @@\n+import java.util.Optional;\n@@ -129,0 +132,14 @@\n+    @CallerSensitive\n+    public static Optional<MemoryAddress> findNative(String name) {\n+         Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+         ClassLoader loader = Reflection.getCallerClass().getClassLoader();\n+         SecurityManager security = System.getSecurityManager();\n+         if (security != null) {\n+             security.checkPermission(new RuntimePermission(\"java.foreign.findNative\"));\n+         }\n+         Objects.requireNonNull(name);\n+         JavaLangAccess javaLangAccess = SharedSecrets.getJavaLangAccess();\n+         MemoryAddress addr = MemoryAddress.ofLong(javaLangAccess.findNative(loader, name));\n+         return addr == MemoryAddress.NULL? Optional.empty() : Optional.of(addr);\n+    }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1,168 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-package jdk.incubator.foreign;\n-\n-import jdk.internal.foreign.LibrariesHelper;\n-import jdk.internal.reflect.CallerSensitive;\n-import jdk.internal.reflect.Reflection;\n-\n-import java.io.File;\n-import java.lang.invoke.MethodType;\n-import java.nio.file.Path;\n-import java.util.Objects;\n-import java.util.Optional;\n-\n-\/**\n- * A native library lookup. Exposes a lookup operation for searching symbols, see {@link LibraryLookup#lookup(String)}.\n- * A given native library remains loaded as long as there is at least one <em>live<\/em> library lookup instance referring\n- * to it.\n- * All instances generated by a given library lookup object contain a strong reference to said lookup object,\n- * therefore preventing library unloading. For {@link #lookup(String, MemoryLayout) memory segments} obtained from a library lookup object,\n- * this means that clients can safely dereference memory associated with lookup symbols, as follows:\n- * <pre>{@code\n- * LibraryLookup defaultLookup = LibraryLookup.ofDefault();\n- * MemorySegment errnoSegment = defaultLookup.lookup(\"errno\", MemoryLayouts.JAVA_INT).get();\n- * int errno = MemoryAccess.getInt(errnoSegment);\n- * }<\/pre>\n- * <p>\n- * For {@link #lookup(String) memory addresses} obtained from a library lookup object,\n- * since {@link CLinker#downcallHandle(Addressable, MethodType, FunctionDescriptor) native method handles}\n- * also maintain a strong reference to the addressable parameter used for their construction, there is\n- * always a strong reachability chain from a native method handle to a lookup object (the one that was used to lookup\n- * the native library symbol the method handle refers to). This is useful to prevent situations where a native library\n- * is unloaded in the middle of a native call.\n- * <p>\n- * To allow for a library to be unloaded, a client will have to discard any strong references it\n- * maintains, directly, or indirectly to a lookup object associated with given library.\n- *\n- * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n- * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n- *\/\n-public interface LibraryLookup {\n-\n-    \/**\n-     * Looks up a symbol with given name in this library. The returned memory address maintains a strong reference to this lookup object.\n-     *\n-     * @param name the symbol name.\n-     * @return the memory address associated with the library symbol (if any).\n-     *\/\n-    Optional<MemoryAddress> lookup(String name);\n-\n-    \/**\n-     * Looks up a symbol with given name in this library. The returned memory segment has a size that matches that of\n-     * the specified layout, and maintains a strong reference to this lookup object. This method can be useful\n-     * to lookup global variable symbols in a foreign library.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted method are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param name the symbol name.\n-     * @param layout the layout to be associated with the library symbol.\n-     * @return the memory segment associated with the library symbol (if any).\n-     * @throws IllegalArgumentException if the address associated with the lookup symbol do not match the\n-     * {@link MemoryLayout#byteAlignment() alignment constraints} in {@code layout}.\n-     *\/\n-    Optional<MemorySegment> lookup(String name, MemoryLayout layout);\n-\n-    \/**\n-     * Obtain a default library lookup object.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted method are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @return the default library lookup object.\n-     *\/\n-    @CallerSensitive\n-    static LibraryLookup ofDefault() {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkPermission(new RuntimePermission(\"java.foreign.getDefaultLibrary\"));\n-        }\n-        return LibrariesHelper.getDefaultLibrary();\n-    }\n-\n-    \/**\n-     * Obtain a library lookup object corresponding to a library identified by given path.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted method are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param path the library absolute path.\n-     * @return a library lookup object for given path.\n-     * @throws IllegalArgumentException if the specified path does not correspond to an absolute path,\n-     * e.g. if {@code !path.isAbsolute()}.\n-     *\/\n-    @CallerSensitive\n-    static LibraryLookup ofPath(Path path) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n-        Objects.requireNonNull(path);\n-        if (!path.isAbsolute()) {\n-            throw new IllegalArgumentException(\"Not an absolute path: \" + path.toString());\n-        }\n-        String absolutePath = path.toString();\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkLink(absolutePath);\n-        }\n-        return LibrariesHelper.load(absolutePath);\n-    }\n-\n-    \/**\n-     * Obtain a library lookup object corresponding to a library identified by given library name. The library name\n-     * is decorated according to the platform conventions (e.g. on Linux, the {@code lib} prefix is added,\n-     * as well as the {@code .so} extension); the resulting name is then looked up in the standard native\n-     * library path (which can be overriden, by setting the <code>java.library.path<\/code> property).\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted method are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param libName the library name.\n-     * @return a library lookup object for given library name.\n-     *\/\n-    @CallerSensitive\n-    static LibraryLookup ofLibrary(String libName) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n-        Objects.requireNonNull(libName);\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkLink(libName);\n-        }\n-        if (libName.indexOf(File.separatorChar) != -1) {\n-            throw new UnsatisfiedLinkError(\n-                    \"Directory separator should not appear in library name: \" + libName);\n-        }\n-        return LibrariesHelper.loadLibrary(libName);\n-    }\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/LibraryLookup.java","additions":0,"deletions":168,"binary":false,"changes":168,"status":"deleted"},{"patch":"@@ -1,152 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-package jdk.internal.foreign;\n-\n-import jdk.incubator.foreign.MemoryAddress;\n-\n-import java.io.File;\n-import jdk.incubator.foreign.LibraryLookup;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.internal.loader.NativeLibraries;\n-import jdk.internal.loader.NativeLibrary;\n-import jdk.internal.reflect.CallerSensitive;\n-import jdk.internal.reflect.Reflection;\n-\n-import java.lang.ref.Reference;\n-import java.lang.ref.WeakReference;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.function.Supplier;\n-\n-public final class LibrariesHelper {\n-    private LibrariesHelper() {}\n-\n-    private static final NativeLibraries nativeLibraries =\n-            NativeLibraries.rawNativeLibraries(LibrariesHelper.class, true);\n-\n-    private static final Map<NativeLibrary, WeakReference<ResourceScope>> loadedLibraries = new ConcurrentHashMap<>();\n-\n-    \/**\n-     * Load the specified shared library.\n-     *\n-     * @param name Name of the shared library to load.\n-     *\/\n-    public static LibraryLookup loadLibrary(String name) {\n-        return lookup(() -> nativeLibraries.loadLibrary(LibrariesHelper.class, name),\n-                \"Library not found: \" + name);\n-    }\n-\n-    \/**\n-     * Load the specified shared library.\n-     *\n-     * @param path Path of the shared library to load.\n-     *\/\n-    public static LibraryLookup load(String path) {\n-        File file = new File(path);\n-        if (!file.isAbsolute()) {\n-            throw new UnsatisfiedLinkError(\n-                    \"Expecting an absolute path of the library: \" + path);\n-        }\n-        return lookup(() -> nativeLibraries.loadLibrary(LibrariesHelper.class, file),\n-                \"Library not found: \" + path);\n-    }\n-\n-    public static LibraryLookup getDefaultLibrary() {\n-        return LibraryLookupImpl.DEFAULT_LOOKUP;\n-    }\n-\n-    static LibraryLookupImpl lookup(Supplier<NativeLibrary> librarySupplier, String notFoundMsg) {\n-        NativeLibrary library = librarySupplier.get();\n-        if (library == null) {\n-            throw new IllegalArgumentException(notFoundMsg);\n-        }\n-        ResourceScope[] holder = new ResourceScope[1];\n-        try {\n-            WeakReference<ResourceScope> scopeRef = loadedLibraries.computeIfAbsent(library, lib -> {\n-                ResourceScopeImpl s = ResourceScopeImpl.createImplicitScope();\n-                holder[0] = s; \/\/ keep the scope alive at least until the outer method returns\n-                s.addOrCleanupIfFail(ResourceScopeImpl.ResourceList.ResourceCleanup.ofRunnable(() -> {\n-                    nativeLibraries.unload(library);\n-                    loadedLibraries.remove(library);\n-                }));\n-                return new WeakReference<>(s);\n-            });\n-            return new LibraryLookupImpl(library, scopeRef.get());\n-        } finally {\n-            Reference.reachabilityFence(holder);\n-        }\n-    }\n-\n-    \/\/Todo: in principle we could expose a scope accessor, so that users could unload libraries at will\n-    static final class LibraryLookupImpl implements LibraryLookup {\n-        final NativeLibrary library;\n-        final MemorySegment librarySegment;\n-\n-        LibraryLookupImpl(NativeLibrary library, ResourceScope scope) {\n-            this.library = library;\n-            this.librarySegment = MemoryAddress.NULL.asSegment(Long.MAX_VALUE, scope);\n-        }\n-\n-        @Override\n-        public final Optional<MemoryAddress> lookup(String name) {\n-            try {\n-                Objects.requireNonNull(name);\n-                MemoryAddress addr = MemoryAddress.ofLong(library.lookup(name));\n-                return Optional.of(librarySegment.asSlice(addr).address());\n-            } catch (NoSuchMethodException ex) {\n-                return Optional.empty();\n-            }\n-        }\n-\n-        @Override\n-        @CallerSensitive\n-        public final Optional<MemorySegment> lookup(String name, MemoryLayout layout) {\n-            Reflection.ensureNativeAccess(Reflection.getCallerClass());\n-            try {\n-                Objects.requireNonNull(name);\n-                Objects.requireNonNull(layout);\n-                MemoryAddress addr = MemoryAddress.ofLong(library.lookup(name));\n-                if (addr.toRawLongValue() % layout.byteAlignment() != 0) {\n-                    throw new IllegalArgumentException(\"Bad layout alignment constraints: \" + layout.byteAlignment());\n-                }\n-                return Optional.of(librarySegment.asSlice(addr, layout.byteSize()));\n-            } catch (NoSuchMethodException ex) {\n-                return Optional.empty();\n-            }\n-        }\n-\n-        static LibraryLookup DEFAULT_LOOKUP = new LibraryLookupImpl(NativeLibraries.defaultLibrary, ResourceScopeImpl.GLOBAL);\n-    }\n-\n-    \/* used for testing *\/\n-    public static int numLoadedLibraries() {\n-        return loadedLibraries.size();\n-    }\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/LibrariesHelper.java","additions":0,"deletions":152,"binary":false,"changes":152,"status":"deleted"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.incubator.foreign.LibraryLookup;\n@@ -418,3 +417,2 @@\n-        static final LibraryLookup LOOKUP = LibraryLookup.ofDefault();\n-\n-        static final MethodHandle MH_MALLOC = getSystemLinker().downcallHandle(LOOKUP.lookup(\"malloc\").get(),\n+        private static final CLinker linker = getSystemLinker();\n+        static final MethodHandle MH_MALLOC = linker.downcallHandle(CLinker.findNative(\"malloc\").get(),\n@@ -424,1 +422,1 @@\n-        static final MethodHandle MH_FREE = getSystemLinker().downcallHandle(LOOKUP.lookup(\"free\").get(),\n+        static final MethodHandle MH_FREE = linker.downcallHandle(CLinker.findNative(\"free\").get(),\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.incubator.foreign.LibraryLookup;\n@@ -45,2 +44,3 @@\n-\n-    LibraryLookup lookup = LibraryLookup.ofLibrary(\"SafeAccess\");\n+    static {\n+        System.loadLibrary(\"SafeAccess\");\n+    }\n@@ -60,1 +60,1 @@\n-                lookup.lookup(\"struct_func\").get(),\n+                CLinker.findNative(\"struct_func\").get(),\n@@ -75,1 +75,1 @@\n-                lookup.lookup(\"addr_func\").get(),\n+                CLinker.findNative(\"addr_func\").get(),\n","filename":"test\/jdk\/java\/foreign\/SafeFunctionAccessTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -156,0 +156,3 @@\n+        static {\n+            System.loadLibrary(\"StdLibTest\");\n+        }\n@@ -157,3 +160,1 @@\n-        static final LibraryLookup lookup = LibraryLookup.ofDefault();\n-\n-        final static MethodHandle strcat = abi.downcallHandle(lookup.lookup(\"strcat\").get(),\n+        final static MethodHandle strcat = abi.downcallHandle(CLinker.findNative(\"libc_strcat\").get(),\n@@ -163,1 +164,1 @@\n-        final static MethodHandle strcmp = abi.downcallHandle(lookup.lookup(\"strcmp\").get(),\n+        final static MethodHandle strcmp = abi.downcallHandle(CLinker.findNative(\"libc_strcmp\").get(),\n@@ -167,1 +168,1 @@\n-        final static MethodHandle puts = abi.downcallHandle(lookup.lookup(\"puts\").get(),\n+        final static MethodHandle puts = abi.downcallHandle(CLinker.findNative(\"libc_puts\").get(),\n@@ -171,1 +172,1 @@\n-        final static MethodHandle strlen = abi.downcallHandle(lookup.lookup(\"strlen\").get(),\n+        final static MethodHandle strlen = abi.downcallHandle(CLinker.findNative(\"libc_strlen\").get(),\n@@ -175,1 +176,1 @@\n-        final static MethodHandle gmtime = abi.downcallHandle(lookup.lookup(\"gmtime\").get(),\n+        final static MethodHandle gmtime = abi.downcallHandle(CLinker.findNative(\"libc_gmtime\").get(),\n@@ -179,1 +180,1 @@\n-        final static MethodHandle qsort = abi.downcallHandle(lookup.lookup(\"qsort\").get(),\n+        final static MethodHandle qsort = abi.downcallHandle(CLinker.findNative(\"libc_qsort\").get(),\n@@ -187,1 +188,1 @@\n-        final static MethodHandle rand = abi.downcallHandle(lookup.lookup(\"rand\").get(),\n+        final static MethodHandle rand = abi.downcallHandle(CLinker.findNative(\"libc_rand\").get(),\n@@ -191,1 +192,1 @@\n-        final static MethodHandle vprintf = abi.downcallHandle(lookup.lookup(\"vprintf\").get(),\n+        final static MethodHandle vprintf = abi.downcallHandle(CLinker.findNative(\"libc_vprintf\").get(),\n@@ -195,1 +196,1 @@\n-        final static MemoryAddress printfAddr = lookup.lookup(\"printf\").get();\n+        final static MemoryAddress printfAddr = CLinker.findNative(\"libc_printf\").get();\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import jdk.incubator.foreign.LibraryLookup;\n@@ -55,1 +54,0 @@\n-    static LibraryLookup lib = LibraryLookup.ofLibrary(\"TestDowncall\");\n@@ -57,0 +55,3 @@\n+    static {\n+        System.loadLibrary(\"TestDowncall\");\n+    }\n@@ -61,1 +62,1 @@\n-        MemoryAddress addr = lib.lookup(fName).get();\n+        MemoryAddress addr = CLinker.findNative(fName).get();\n@@ -88,1 +89,1 @@\n-        MemoryAddress addr = lib.lookup(fName).get();\n+        MemoryAddress addr = CLinker.findNative(fName).get();\n","filename":"test\/jdk\/java\/foreign\/TestDowncall.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import jdk.incubator.foreign.LibraryLookup;\n@@ -56,1 +55,3 @@\n-    static final LibraryLookup lookup = LibraryLookup.ofLibrary(\"Intrinsics\");\n+    static {\n+        System.loadLibrary(\"Intrinsics\");\n+    }\n@@ -87,1 +88,1 @@\n-            MemoryAddress ma = lookup.lookup(name).orElseThrow();\n+            MemoryAddress ma = CLinker.findNative(name).get();\n@@ -97,1 +98,1 @@\n-            MemoryAddress ma = lookup.lookup(\"empty\").orElseThrow();\n+            MemoryAddress ma = CLinker.findNative(\"empty\").get();\n@@ -112,1 +113,1 @@\n-            MemoryAddress ma = lookup.lookup(\"identity_va\").orElseThrow();\n+            MemoryAddress ma = CLinker.findNative(\"identity_va\").get();\n@@ -127,1 +128,1 @@\n-                MemoryAddress ma = lookup.lookup(\"invoke_high_arity\" + i).orElseThrow();\n+                MemoryAddress ma = CLinker.findNative(\"invoke_high_arity\" + i).get();\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import jdk.incubator.foreign.LibraryLookup;\n+import jdk.incubator.foreign.CLinker;\n@@ -37,1 +37,1 @@\n-import jdk.internal.foreign.LibrariesHelper;\n+import jdk.incubator.foreign.ResourceScope;\n@@ -40,7 +40,0 @@\n-import java.lang.reflect.Field;\n-import java.net.URL;\n-import java.net.URLClassLoader;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n@@ -55,14 +48,2 @@\n-\n-    @Test(expectedExceptions = IllegalArgumentException.class, expectedExceptionsMessageRegExp = \"Library not found.*\")\n-    public void testInvalidLookupName() {\n-        LibraryLookup.ofLibrary(\"NonExistent\");\n-    }\n-\n-    @Test(expectedExceptions = IllegalArgumentException.class, expectedExceptionsMessageRegExp = \"Not an absolute path.*\")\n-    public void testNoAbsoluteLookupPath() {\n-        LibraryLookup.ofPath(Path.of(\"NonExistent\"));\n-    }\n-\n-    @Test(expectedExceptions = IllegalArgumentException.class, expectedExceptionsMessageRegExp = \"Library not found.*\")\n-    public void testInvalidLookupPath() {\n-        LibraryLookup.ofPath(Path.of(\"NonExistent\").toAbsolutePath());\n+    static {\n+        System.loadLibrary(\"LookupTest\");\n@@ -72,8 +53,2 @@\n-    public void testSimpleLookup() throws Throwable {\n-        MemoryAddress symbol = null;\n-        LibraryLookup lookup = LibraryLookup.ofLibrary(\"LookupTest\");\n-        symbol = lookup.lookup(\"f\").get();\n-        assertEquals(LibrariesHelper.numLoadedLibraries(), 1);\n-        lookup = null;\n-        symbol = null;\n-        waitUnload();\n+    public void testSimpleLookup() {\n+        assertFalse(CLinker.findNative(\"f\").isEmpty());\n@@ -83,8 +58,2 @@\n-    public void testInvalidSymbolLookup() throws Throwable {\n-        MemoryAddress symbol = null;\n-        LibraryLookup lookup = LibraryLookup.ofLibrary(\"LookupTest\");\n-        assertTrue(lookup.lookup(\"nonExistent\").isEmpty());\n-        assertEquals(LibrariesHelper.numLoadedLibraries(), 1);\n-        lookup = null;\n-        symbol = null;\n-        waitUnload();\n+    public void testInvalidSymbolLookup() {\n+        assertTrue(CLinker.findNative(\"nonExistent\").isEmpty());\n@@ -95,2 +64,1 @@\n-        LibraryLookup lookup = LibraryLookup.ofLibrary(\"LookupTest\");\n-        MemorySegment segment = lookup.lookup(\"c\", MemoryLayouts.JAVA_INT).get();\n+        MemorySegment segment = CLinker.findNative(\"c\").get().asSegment(MemoryLayouts.JAVA_INT.byteSize(), ResourceScope.globalScope());\n@@ -98,103 +66,0 @@\n-        lookup = null;\n-        segment = null;\n-        waitUnload();\n-    }\n-\n-    @Test\n-    public void testBadVariableSymbolLookup() {\n-        LibraryLookup lookup = LibraryLookup.ofLibrary(\"LookupTest\");\n-        try {\n-            MemoryLayout layout = MemoryLayouts.JAVA_INT.withBitAlignment(1 << 16);\n-            MemorySegment segment = lookup.lookup(\"c\", layout).get();\n-            \/\/ no exception, check that address is aligned\n-            if ((segment.address().toRawLongValue() % layout.byteAlignment()) != 0) {\n-                fail(\"Unaligned address\");\n-            }\n-        } catch (IllegalArgumentException ex) {\n-            \/\/ ok, means address was not aligned\n-        }\n-\n-    }\n-\n-    @Test\n-    public void testMultiLookupSameLoader() throws Throwable {\n-        List<MemoryAddress> symbols = new ArrayList<>();\n-        List<LibraryLookup> lookups = new ArrayList<>();\n-        for (int i = 0 ; i < 5 ; i++) {\n-            LibraryLookup lookup = LibraryLookup.ofLibrary(\"LookupTest\");\n-            MemoryAddress symbol = lookup.lookup(\"f\").get();\n-            lookups.add(lookup);\n-            symbols.add(symbol);\n-            assertEquals(LibrariesHelper.numLoadedLibraries(), 1);\n-        }\n-        lookups = null;\n-        symbols = null;\n-        waitUnload();\n-    }\n-\n-    @Test\n-    public void testMultiLookupDifferentLoaders() throws Throwable {\n-        List<URLClassLoader> loaders = new ArrayList<>();\n-        for (int i = 0 ; i < 5 ; i++) {\n-            URLClassLoader loader = new LocalLoader();\n-            Class<?> clazz = loader.loadClass(\"TestLibraryLookup$Holder\");\n-            Field field = clazz.getField(\"lookup\");\n-            field.setAccessible(true);\n-            field.get(null); \/\/make sure <clinit> is run\n-            loaders.add(loader);\n-        }\n-        loaders.forEach(loader -> {\n-            try {\n-                loader.close();\n-            } catch (Throwable ex) {\n-                throw new AssertionError(ex);\n-            }\n-        });\n-        loaders = null;\n-        waitUnload();\n-    }\n-\n-    static class LocalLoader extends URLClassLoader {\n-        public LocalLoader() throws Exception {\n-            super(new URL[] { Path.of(System.getProperty(\"test.classes\")).toUri().toURL() });\n-        }\n-\n-        @Override\n-        public Class<?> loadClass(String name) throws ClassNotFoundException {\n-            Class clazz = findLoadedClass(name);\n-            if (clazz == null) {\n-                \/\/try local first\n-                try {\n-                    clazz = findClass(name);\n-                } catch (ClassNotFoundException e) {\n-                    \/\/ Swallow exception - does not exist locally\n-                }\n-                \/\/then try parent loader\n-                if (clazz == null) {\n-                    clazz = super.loadClass(name);\n-                }\n-            }\n-            return clazz;\n-        }\n-    }\n-\n-    static class Holder {\n-        public static LibraryLookup lookup;\n-        public static MemoryAddress symbol;\n-\n-        static {\n-            try {\n-                lookup = LibraryLookup.ofLibrary(\"LookupTest\");\n-                symbol = lookup.lookup(\"f\").get();\n-            } catch (Throwable ex) {\n-                throw new ExceptionInInitializerError();\n-            }\n-        }\n-    }\n-\n-    private static void waitUnload() throws InterruptedException {\n-        while (LibrariesHelper.numLoadedLibraries() != 0) {\n-            System.gc();\n-            Object o = new Object[1000];\n-            Thread.sleep(1);\n-        }\n","filename":"test\/jdk\/java\/foreign\/TestLibraryLookup.java","additions":9,"deletions":144,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -94,1 +94,0 @@\n-            LibraryLookup.class,\n@@ -159,1 +158,0 @@\n-        addDefaultMapping(LibraryLookup.class, LibraryLookup.ofDefault());\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import jdk.incubator.foreign.LibraryLookup;\n@@ -64,1 +63,3 @@\n-    static LibraryLookup lib = LibraryLookup.ofLibrary(\"TestUpcall\");\n+    static {\n+        System.loadLibrary(\"TestUpcall\");\n+    }\n@@ -91,1 +92,1 @@\n-        MemoryAddress addr = lib.lookup(fName).get();\n+        MemoryAddress addr = CLinker.findNative(fName).get();\n@@ -109,1 +110,1 @@\n-        MemoryAddress addr = lib.lookup(fName).get();\n+        MemoryAddress addr = CLinker.findNative(fName).get();\n","filename":"test\/jdk\/java\/foreign\/TestUpcall.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import jdk.incubator.foreign.LibraryLookup;\n@@ -69,1 +68,1 @@\n-            LibraryLookup lookup = LibraryLookup.ofLibrary(\"TestUpcallHighArity\");\n+            System.loadLibrary(\"TestUpcallHighArity\");\n@@ -71,1 +70,1 @@\n-                lookup.lookup(\"do_upcall\").get(),\n+                CLinker.findNative(\"do_upcall\").get(),\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import jdk.incubator.foreign.LibraryLookup;\n@@ -72,1 +71,1 @@\n-        LibraryLookup lookup = LibraryLookup.ofLibrary(\"TestUpcallStructScope\");\n+        System.loadLibrary(\"TestUpcallStructScope\");\n@@ -74,1 +73,1 @@\n-            lookup.lookup(\"do_upcall\").orElseThrow(),\n+            CLinker.findNative(\"do_upcall\").get(),\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import jdk.incubator.foreign.LibraryLookup;\n@@ -64,2 +63,4 @@\n-    static final MemoryAddress varargsAddr = LibraryLookup.ofLibrary(\"VarArgs\")\n-            .lookup(\"varargs\").get();\n+    static {\n+        System.loadLibrary(\"VarArgs\");\n+    }\n+    static final MemoryAddress varargsAddr = CLinker.findNative(\"varargs\").get();\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"libStdLibTest.h\"\n+\n+EXPORT char *libc_strcat(char *str1, const char *str2) {\n+    return strcat(str1, str2);\n+}\n+\n+EXPORT int libc_strcmp(const char *str1, const char *str2) {\n+    return strcmp(str1, str2);\n+}\n+\n+EXPORT size_t libc_strlen(const char *str) {\n+    return strlen(str);\n+}\n+\n+EXPORT int libc_puts(const char *str) {\n+    return puts(str);\n+}\n+\n+EXPORT struct tm *libc_gmtime(const time_t* timer) {\n+    return gmtime(timer);\n+}\n+\n+EXPORT void libc_qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*)) {\n+    qsort(base, nitems, size, compar);\n+}\n+\n+EXPORT int libc_rand(void) {\n+    return rand();\n+}\n+\n+EXPORT int libc_vprintf(const char *format, va_list arg) {\n+    return vprintf(format, arg);\n+}\n+\n+EXPORT int libc_printf(const char *format, ...) {\n+   va_list arg;\n+   int done;\n+\n+   va_start(arg, format);\n+   done = vprintf(format, arg);\n+   va_end(arg);\n+\n+   return done;\n+}\n","filename":"test\/jdk\/java\/foreign\/libStdLibTest.c","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <time.h>\n+\n+EXPORT char *libc_strcat(char *str1, const char *str2);\n+EXPORT int libc_strcmp(const char *str1, const char *str2);\n+EXPORT size_t libc_strlen(const char *str);\n+EXPORT int libc_puts(const char *str);\n+EXPORT struct tm *libc_gmtime(const time_t *timer);\n+EXPORT void libc_qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*));\n+EXPORT int libc_rand(void);\n+EXPORT int vprintf(const char *format, va_list arg);\n+EXPORT int libc_printf(const char *format, ...);\n","filename":"test\/jdk\/java\/foreign\/libStdLibTest.h","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -52,1 +52,0 @@\n-import jdk.incubator.foreign.LibraryLookup;\n@@ -76,1 +75,1 @@\n-            LibraryLookup lookup = LibraryLookup.ofLibrary(\"StackWalk\");\n+            System.loadLibrary(\"StackWalk\");\n@@ -78,1 +77,1 @@\n-                    lookup.lookup(\"foo\").get(),\n+                    CLinker.findNative(\"foo\").get(),\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestStackWalk.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -70,1 +70,3 @@\n-    private static final LibraryLookup lookup = LibraryLookup.ofLibrary(\"VaList\");\n+    static {\n+        System.loadLibrary(\"VaList\");\n+    }\n@@ -98,1 +100,1 @@\n-        return abi.downcallHandle(lookup.lookup(symbol).get(), mt, fd);\n+        return abi.downcallHandle(CLinker.findNative(symbol).get(), mt, fd);\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.incubator.foreign.LibraryLookup;\n@@ -49,1 +48,0 @@\n-    static final LibraryLookup lookup = LibraryLookup.ofLibrary(\"Virtual\");\n@@ -61,3 +59,4 @@\n-        funcA = lookup.lookup(\"funcA\").orElseThrow();\n-        funcB = lookup.lookup(\"funcB\").orElseThrow();\n-        funcC = lookup.lookup(\"funcC\").orElseThrow();\n+        System.loadLibrary(\"Virtual\");\n+        funcA = CLinker.findNative(\"funcA\").get();\n+        funcB = CLinker.findNative(\"funcB\").get();\n+        funcC = CLinker.findNative(\"funcC\").get();\n","filename":"test\/jdk\/java\/foreign\/virtual\/TestVirtualCalls.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"}]}