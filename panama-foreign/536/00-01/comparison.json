{"files":[{"patch":"@@ -42,0 +42,1 @@\n+import java.util.Optional;\n@@ -52,0 +53,1 @@\n+import org.testng.SkipException;\n@@ -125,0 +127,30 @@\n+    @Test(dataProvider = \"printfArgs\")\n+    void test_printf(List<PrintfArg> args) throws Throwable {\n+        String formatArgs = args.stream()\n+                .map(a -> a.format)\n+                .collect(Collectors.joining(\",\"));\n+\n+        String formatString = \"hello(\" + formatArgs + \")\\n\";\n+\n+        String expected = String.format(formatString, args.stream()\n+                .map(a -> a.javaValue).toArray());\n+\n+        int found = stdLibHelper.printf(formatString, args);\n+        assertEquals(found, expected.length());\n+    }\n+\n+    @Test(dataProvider = \"printfArgs\")\n+    void test_vprintf(List<PrintfArg> args) throws Throwable {\n+        String formatArgs = args.stream()\n+                .map(a -> a.format)\n+                .collect(Collectors.joining(\",\"));\n+\n+        String formatString = \"hello(\" + formatArgs + \")\\n\";\n+\n+        String expected = String.format(formatString, args.stream()\n+                .map(a -> a.javaValue).toArray());\n+\n+        int found = stdLibHelper.vprintf(formatString, args);\n+        assertEquals(found, expected.length());\n+    }\n+\n@@ -127,1 +159,32 @@\n-        final static MethodHandle strcat = abi.downcallHandle(CLinker.systemLookup().lookup(\"strcat\").get(),\n+        final static SymbolLookup LOOKUP;\n+\n+        private static final int F_PRINTF = 0;\n+        private static final int F_VPRINTF = 1;\n+        private static final int F_GMTIME = 2;\n+\n+        static {\n+            System.loadLibrary(\"StdLib\");\n+            SymbolLookup stdLibLookup = SymbolLookup.loaderLookup();\n+            MethodHandle MH_get_ptr = abi.downcallHandle(stdLibLookup.lookup(\"get_ptr\").get(),\n+                MethodType.methodType(MemoryAddress.class, int.class),\n+                FunctionDescriptor.of(C_POINTER, C_INT));\n+\n+            SymbolLookup fallbackLookup = name -> {\n+                MemoryAddress ma;\n+                try {\n+                    ma = (MemoryAddress) MH_get_ptr.invokeExact((int) switch (name) {\n+                        case \"printf\" -> F_PRINTF;\n+                        case \"vprintf\" -> F_VPRINTF;\n+                        case \"gmtime\" -> F_GMTIME;\n+                        default -> -1;\n+                    });\n+                } catch (Throwable throwable) {\n+                    throw new RuntimeException(throwable);\n+                }\n+                return ma == MemoryAddress.NULL ? Optional.empty() : Optional.of(ma);\n+            };\n+\n+            LOOKUP = name -> CLinker.systemLookup().lookup(name).or(() -> fallbackLookup.lookup(name));\n+        }\n+\n+        final static MethodHandle strcat = abi.downcallHandle(LOOKUP.lookup(\"strcat\").get(),\n@@ -131,1 +194,1 @@\n-        final static MethodHandle strcmp = abi.downcallHandle(CLinker.systemLookup().lookup(\"strcmp\").get(),\n+        final static MethodHandle strcmp = abi.downcallHandle(LOOKUP.lookup(\"strcmp\").get(),\n@@ -135,1 +198,1 @@\n-        final static MethodHandle puts = abi.downcallHandle(CLinker.systemLookup().lookup(\"puts\").get(),\n+        final static MethodHandle puts = abi.downcallHandle(LOOKUP.lookup(\"puts\").get(),\n@@ -139,1 +202,1 @@\n-        final static MethodHandle strlen = abi.downcallHandle(CLinker.systemLookup().lookup(\"strlen\").get(),\n+        final static MethodHandle strlen = abi.downcallHandle(LOOKUP.lookup(\"strlen\").get(),\n@@ -143,2 +206,1 @@\n-        final static MethodHandle gmtime = abi.downcallHandle(\n-                CLinker.systemLookup().lookup(NativeTestHelper.IS_WINDOWS ? \"_gmtime64\" : \"gmtime\").get(),\n+        final static MethodHandle gmtime = abi.downcallHandle(LOOKUP.lookup(\"gmtime\").get(),\n@@ -148,1 +210,1 @@\n-        final static MethodHandle qsort = abi.downcallHandle(CLinker.systemLookup().lookup(\"qsort\").get(),\n+        final static MethodHandle qsort = abi.downcallHandle(LOOKUP.lookup(\"qsort\").get(),\n@@ -156,1 +218,1 @@\n-        final static MethodHandle rand = abi.downcallHandle(CLinker.systemLookup().lookup(\"rand\").get(),\n+        final static MethodHandle rand = abi.downcallHandle(LOOKUP.lookup(\"rand\").get(),\n@@ -160,0 +222,8 @@\n+        final static MethodHandle vprintf = abi.downcallHandle(LOOKUP.lookup(\"vprintf\").get(),\n+                MethodType.methodType(int.class, MemoryAddress.class, VaList.class),\n+                FunctionDescriptor.of(C_INT, C_POINTER, C_VA_LIST));\n+\n+        final static MemoryAddress printfAddr = LOOKUP.lookup(\"printf\").get();\n+\n+        final static FunctionDescriptor printfBase = FunctionDescriptor.of(C_INT, C_POINTER);\n+\n@@ -278,0 +348,28 @@\n+\n+        int printf(String format, List<PrintfArg> args) throws Throwable {\n+            try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+                MemorySegment formatStr = toCString(format, scope);\n+                return (int)specializedPrintf(args).invokeExact(formatStr.address(),\n+                        args.stream().map(a -> a.nativeValue(scope)).toArray());\n+            }\n+        }\n+\n+        int vprintf(String format, List<PrintfArg> args) throws Throwable {\n+            try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+                MemorySegment formatStr = toCString(format, scope);\n+                VaList vaList = VaList.make(b -> args.forEach(a -> a.accept(b, scope)), scope);\n+                return (int)vprintf.invokeExact(formatStr.address(), vaList);\n+            }\n+        }\n+\n+        private MethodHandle specializedPrintf(List<PrintfArg> args) {\n+            \/\/method type\n+            MethodType mt = MethodType.methodType(int.class, MemoryAddress.class);\n+            FunctionDescriptor fd = printfBase;\n+            for (PrintfArg arg : args) {\n+                mt = mt.appendParameterTypes(arg.carrier);\n+                fd = fd.withAppendedArgumentLayouts(arg.layout);\n+            }\n+            MethodHandle mh = abi.downcallHandle(printfAddr, mt, fd);\n+            return mh.asSpreader(1, Object[].class, args.size());\n+        }\n@@ -321,0 +419,52 @@\n+    @DataProvider\n+    public static Object[][] printfArgs() {\n+        ArrayList<List<PrintfArg>> res = new ArrayList<>();\n+        List<List<PrintfArg>> perms = new ArrayList<>(perms(0, PrintfArg.values()));\n+        for (int i = 0 ; i < 100 ; i++) {\n+            Collections.shuffle(perms);\n+            res.addAll(perms);\n+        }\n+        return res.stream()\n+                .map(l -> new Object[] { l })\n+                .toArray(Object[][]::new);\n+    }\n+\n+    enum PrintfArg implements BiConsumer<VaList.Builder, ResourceScope> {\n+\n+        INTEGRAL(int.class, asVarArg(C_INT), \"%d\", scope -> 42, 42, VaList.Builder::vargFromInt),\n+        STRING(MemoryAddress.class, asVarArg(C_POINTER), \"%s\", scope -> toCString(\"str\", scope).address(), \"str\", VaList.Builder::vargFromAddress),\n+        CHAR(byte.class, asVarArg(C_CHAR), \"%c\", scope -> (byte) 'h', 'h', (builder, layout, value) -> builder.vargFromInt(C_INT, (int)value)),\n+        DOUBLE(double.class, asVarArg(C_DOUBLE), \"%.4f\", scope ->1.2345d, 1.2345d, VaList.Builder::vargFromDouble);\n+\n+        final Class<?> carrier;\n+        final ValueLayout layout;\n+        final String format;\n+        final Function<ResourceScope, ?> nativeValueFactory;\n+        final Object javaValue;\n+        @SuppressWarnings(\"rawtypes\")\n+        final VaListBuilderCall builderCall;\n+\n+        <Z> PrintfArg(Class<?> carrier, ValueLayout layout, String format, Function<ResourceScope, Z> nativeValueFactory, Object javaValue, VaListBuilderCall<Z> builderCall) {\n+            this.carrier = carrier;\n+            this.layout = layout;\n+            this.format = format;\n+            this.nativeValueFactory = nativeValueFactory;\n+            this.javaValue = javaValue;\n+            this.builderCall = builderCall;\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public void accept(VaList.Builder builder, ResourceScope scope) {\n+            builderCall.build(builder, layout, nativeValueFactory.apply(scope));\n+        }\n+\n+        interface VaListBuilderCall<V> {\n+            void build(VaList.Builder builder, ValueLayout layout, V value);\n+        }\n+\n+        public Object nativeValue(ResourceScope scope) {\n+            return nativeValueFactory.apply(scope);\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":158,"deletions":8,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+#include <stdio.h>\n+#include <time.h>\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+enum Func {\n+  F_PRINTF = 0,\n+  F_VPRINTF = 1,\n+  F_GMTIME = 2\n+};\n+\n+EXPORT void* get_ptr(int func) {\n+    switch(func) {\n+        case F_PRINTF:  return &printf;\n+        case F_VPRINTF: return &vprintf;\n+        case F_GMTIME:  return &gmtime;\n+    }\n+    return NULL;\n+}\n","filename":"test\/jdk\/java\/foreign\/libStdLib.c","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"}]}