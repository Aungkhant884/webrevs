{"files":[{"patch":"@@ -57,2 +57,1 @@\n-            MethodHandle mh = SharedUtils.wrapDowncall(handle, fd);\n-            return mh;\n+            return handle;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.Scoped;\n@@ -48,0 +49,1 @@\n+import java.lang.foreign.NativeSymbol;\n@@ -58,0 +60,1 @@\n+import java.util.Arrays;\n@@ -92,0 +95,2 @@\n+    private static final String RELEASE0_DESC = methodType(void.class).descriptorString();\n+    private static final String ACQUIRE0_DESC = methodType(void.class).descriptorString();\n@@ -120,0 +125,2 @@\n+    private int[] scopeSlots;\n+    private int curScopeLocalIdx = -1;\n@@ -244,0 +251,15 @@\n+\n+            \/\/ for downcalls we also acquire\/release scoped parameters before\/after the call\n+            \/\/ create a bunch of locals here to keep track of their scopes (to release later)\n+            scopeSlots = new int[callerMethodType.parameterCount()];\n+            int numScopes = 0;\n+            for (int i = 0; i < callerMethodType.parameterCount(); i++) {\n+                if (shouldAcquire(callerMethodType.parameterType(i))) {\n+                    int scopeLocal = newLocal(BasicType.L);\n+                    scopeSlots[numScopes++] = scopeLocal;\n+                    emitConst(null);\n+                    emitStore(BasicType.L, scopeLocal); \/\/ need to initialize all scope locals here in case an exception occurs\n+                }\n+            }\n+            scopeSlots = Arrays.copyOf(scopeSlots, numScopes); \/\/ fit to size\n+            curScopeLocalIdx = 0; \/\/ used from emitGetInput\n@@ -347,1 +369,1 @@\n-            emitCloseContext();\n+            emitCleanup();\n@@ -363,1 +385,1 @@\n-            emitCloseContext();\n+            emitCleanup();\n@@ -369,1 +391,1 @@\n-        emitCloseContext();\n+        emitCleanup();\n@@ -385,0 +407,11 @@\n+    private static boolean shouldAcquire(Class<?> type) {\n+        return type == Addressable.class || type == NativeSymbol.class;\n+    }\n+\n+    private void emitCleanup() {\n+        emitCloseContext();\n+        if (callingSequence.forDowncall()) {\n+            emitReleaseScopes();\n+        }\n+    }\n+\n@@ -410,0 +443,6 @@\n+\n+        if (shouldAcquire(highLevelType)) {\n+            emitDup(BasicType.L);\n+            emitAcquireScope();\n+        }\n+\n@@ -414,0 +453,45 @@\n+    private void emitAcquireScope() {\n+        emitCheckCast(Scoped.class);\n+        emitInvokeInterface(Scoped.class, \"scope\", SCOPE_DESC);\n+        Label skipAcquire = new Label();\n+        Label end = new Label();\n+\n+        \/\/ start with 1 scope to maybe acquire on the stack\n+        assert curScopeLocalIdx != -1;\n+        boolean hasOtherScopes = curScopeLocalIdx != 0;\n+        for (int i = 0; i < curScopeLocalIdx; i++) {\n+            emitDup(BasicType.L); \/\/ dup for comparison\n+            emitLoad(BasicType.L, scopeSlots[i]);\n+            mv.visitJumpInsn(IF_ACMPEQ, skipAcquire);\n+        }\n+\n+        \/\/ 1 scope to acquire on the stack\n+        emitDup(BasicType.L);\n+        int nextScopeLocal = scopeSlots[curScopeLocalIdx++];\n+        emitStore(BasicType.L, nextScopeLocal); \/\/ store off one to release later\n+        emitCheckCast(ResourceScopeImpl.class);\n+        emitInvokeVirtual(ResourceScopeImpl.class, \"acquire0\", ACQUIRE0_DESC); \/\/ call acquire on the other\n+\n+        if (hasOtherScopes) { \/\/ avoid ASM generating a bunch of nops for the dead code\n+            mv.visitJumpInsn(GOTO, end);\n+\n+            mv.visitLabel(skipAcquire);\n+            mv.visitInsn(POP); \/\/ drop scope\n+        }\n+\n+        mv.visitLabel(end);\n+    }\n+\n+    private void emitReleaseScopes() {\n+        for (int scopeLocal : scopeSlots) {\n+            Label skipRelease = new Label();\n+\n+            emitLoad(BasicType.L, scopeLocal);\n+            mv.visitJumpInsn(IFNULL, skipRelease);\n+            emitLoad(BasicType.L, scopeLocal);\n+            emitCheckCast(ResourceScopeImpl.class);\n+            emitInvokeVirtual(ResourceScopeImpl.class, \"release0\", RELEASE0_DESC);\n+            mv.visitLabel(skipRelease);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":87,"deletions":3,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -27,0 +27,11 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.JavaLangInvokeAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.foreign.CABI;\n+import jdk.internal.foreign.MemoryAddressImpl;\n+import jdk.internal.foreign.Scoped;\n+import jdk.internal.foreign.abi.aarch64.linux.LinuxAArch64Linker;\n+import jdk.internal.foreign.abi.aarch64.macos.MacOsAArch64Linker;\n+import jdk.internal.foreign.abi.x64.sysv.SysVx64Linker;\n+import jdk.internal.foreign.abi.x64.windows.Windowsx64Linker;\n+\n@@ -46,1 +57,0 @@\n-import java.util.ArrayList;\n@@ -48,1 +58,0 @@\n-import java.util.List;\n@@ -52,1 +61,0 @@\n-import java.util.function.UnaryOperator;\n@@ -55,23 +63,1 @@\n-import jdk.internal.access.JavaLangAccess;\n-import jdk.internal.access.JavaLangInvokeAccess;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.foreign.CABI;\n-import jdk.internal.foreign.MemoryAddressImpl;\n-import jdk.internal.foreign.ResourceScopeImpl;\n-import jdk.internal.foreign.Scoped;\n-import jdk.internal.foreign.abi.aarch64.linux.LinuxAArch64Linker;\n-import jdk.internal.foreign.abi.aarch64.macos.MacOsAArch64Linker;\n-import jdk.internal.foreign.abi.x64.sysv.SysVx64Linker;\n-import jdk.internal.foreign.abi.x64.windows.Windowsx64Linker;\n-import jdk.internal.vm.annotation.ForceInline;\n-import static java.lang.invoke.MethodHandles.collectArguments;\n-import static java.lang.invoke.MethodHandles.constant;\n-import static java.lang.invoke.MethodHandles.dropArguments;\n-import static java.lang.invoke.MethodHandles.dropReturn;\n-import static java.lang.invoke.MethodHandles.empty;\n-import static java.lang.invoke.MethodHandles.foldArguments;\n-import static java.lang.invoke.MethodHandles.identity;\n-import static java.lang.invoke.MethodHandles.insertArguments;\n-import static java.lang.invoke.MethodHandles.permuteArguments;\n-import static java.lang.invoke.MethodHandles.tryFinally;\n-import static java.lang.invoke.MethodType.methodType;\n+\n@@ -87,0 +73,6 @@\n+import static java.lang.invoke.MethodHandles.collectArguments;\n+import static java.lang.invoke.MethodHandles.dropReturn;\n+import static java.lang.invoke.MethodHandles.identity;\n+import static java.lang.invoke.MethodHandles.insertArguments;\n+import static java.lang.invoke.MethodHandles.permuteArguments;\n+import static java.lang.invoke.MethodType.methodType;\n@@ -96,3 +88,0 @@\n-    private static final MethodHandle MH_MAKE_CONTEXT_NO_ALLOCATOR;\n-    private static final MethodHandle MH_MAKE_CONTEXT_BOUNDED_ALLOCATOR;\n-    private static final MethodHandle MH_CLOSE_CONTEXT;\n@@ -100,3 +89,0 @@\n-    private static final MethodHandle MH_HANDLE_UNCAUGHT_EXCEPTION;\n-    private static final MethodHandle ACQUIRE_MH;\n-    private static final MethodHandle RELEASE_MH;\n@@ -113,6 +99,0 @@\n-            MH_MAKE_CONTEXT_NO_ALLOCATOR = lookup.findStatic(Binding.Context.class, \"ofScope\",\n-                    methodType(Binding.Context.class));\n-            MH_MAKE_CONTEXT_BOUNDED_ALLOCATOR = lookup.findStatic(Binding.Context.class, \"ofBoundedAllocator\",\n-                    methodType(Binding.Context.class, long.class));\n-            MH_CLOSE_CONTEXT = lookup.findVirtual(Binding.Context.class, \"close\",\n-                    methodType(void.class));\n@@ -121,6 +101,0 @@\n-            MH_HANDLE_UNCAUGHT_EXCEPTION = lookup.findStatic(SharedUtils.class, \"handleUncaughtException\",\n-                    methodType(void.class, Throwable.class));\n-            ACQUIRE_MH = MethodHandles.lookup().findStatic(SharedUtils.class, \"acquire\",\n-                    MethodType.methodType(void.class, Scoped[].class));\n-            RELEASE_MH = MethodHandles.lookup().findStatic(SharedUtils.class, \"release\",\n-                    MethodType.methodType(void.class, Scoped[].class));\n@@ -350,134 +324,0 @@\n-    @ForceInline\n-    @SuppressWarnings(\"fallthrough\")\n-    public static void acquire(Scoped[] args) {\n-        ResourceScope scope4 = null;\n-        ResourceScope scope3 = null;\n-        ResourceScope scope2 = null;\n-        ResourceScope scope1 = null;\n-        ResourceScope scope0 = null;\n-        switch (args.length) {\n-            default:\n-                \/\/ slow path, acquire all remaining addressable parameters in isolation\n-                for (int i = 5 ; i < args.length ; i++) {\n-                    acquire(args[i].scope());\n-                }\n-            \/\/ fast path, acquire only scopes not seen in other parameters\n-            case 5:\n-                scope4 = args[4].scope();\n-                acquire(scope4);\n-            case 4:\n-                scope3 = args[3].scope();\n-                if (scope3 != scope4)\n-                    acquire(scope3);\n-            case 3:\n-                scope2 = args[2].scope();\n-                if (scope2 != scope3 && scope2 != scope4)\n-                    acquire(scope2);\n-            case 2:\n-                scope1 = args[1].scope();\n-                if (scope1 != scope2 && scope1 != scope3 && scope1 != scope4)\n-                    acquire(scope1);\n-            case 1:\n-                scope0 = args[0].scope();\n-                if (scope0 != scope1 && scope0 != scope2 && scope0 != scope3 && scope0 != scope4)\n-                    acquire(scope0);\n-            case 0: break;\n-        }\n-    }\n-\n-    @ForceInline\n-    @SuppressWarnings(\"fallthrough\")\n-    public static void release(Scoped[] args) {\n-        ResourceScope scope4 = null;\n-        ResourceScope scope3 = null;\n-        ResourceScope scope2 = null;\n-        ResourceScope scope1 = null;\n-        ResourceScope scope0 = null;\n-        switch (args.length) {\n-            default:\n-                \/\/ slow path, release all remaining addressable parameters in isolation\n-                for (int i = 5 ; i < args.length ; i++) {\n-                    release(args[i].scope());\n-                }\n-            \/\/ fast path, release only scopes not seen in other parameters\n-            case 5:\n-                scope4 = args[4].scope();\n-                release(scope4);\n-            case 4:\n-                scope3 = args[3].scope();\n-                if (scope3 != scope4)\n-                    release(scope3);\n-            case 3:\n-                scope2 = args[2].scope();\n-                if (scope2 != scope3 && scope2 != scope4)\n-                    release(scope2);\n-            case 2:\n-                scope1 = args[1].scope();\n-                if (scope1 != scope2 && scope1 != scope3 && scope1 != scope4)\n-                    release(scope1);\n-            case 1:\n-                scope0 = args[0].scope();\n-                if (scope0 != scope1 && scope0 != scope2 && scope0 != scope3 && scope0 != scope4)\n-                    release(scope0);\n-            case 0: break;\n-        }\n-    }\n-\n-    @ForceInline\n-    private static void acquire(ResourceScope scope) {\n-        ((ResourceScopeImpl)scope).acquire0();\n-    }\n-\n-    @ForceInline\n-    private static void release(ResourceScope scope) {\n-        ((ResourceScopeImpl)scope).release0();\n-    }\n-\n-    \/*\n-     * This method adds a try\/finally block to a downcall method handle, to make sure that all by-reference\n-     * parameters (including the target address of the native function) are kept alive for the duration of\n-     * the downcall.\n-     *\/\n-    public static MethodHandle wrapDowncall(MethodHandle downcallHandle, FunctionDescriptor descriptor) {\n-        boolean hasReturn = descriptor.returnLayout().isPresent();\n-        MethodHandle tryBlock = downcallHandle;\n-        MethodHandle cleanup = hasReturn ?\n-                MethodHandles.identity(downcallHandle.type().returnType()) :\n-                MethodHandles.empty(MethodType.methodType(void.class));\n-        int addressableCount = 0;\n-        List<UnaryOperator<MethodHandle>> adapters = new ArrayList<>();\n-        for (int i = 0 ; i < downcallHandle.type().parameterCount() ; i++) {\n-            Class<?> ptype = downcallHandle.type().parameterType(i);\n-            if (ptype == Addressable.class || ptype == NativeSymbol.class) {\n-                addressableCount++;\n-            } else {\n-                int pos = i;\n-                adapters.add(mh -> dropArguments(mh, pos, ptype));\n-            }\n-        }\n-\n-        if (addressableCount > 0) {\n-            cleanup = dropArguments(cleanup, 0, Throwable.class);\n-\n-            MethodType adapterType = MethodType.methodType(void.class);\n-            for (int i = 0 ; i < addressableCount ; i++) {\n-                adapterType = adapterType.appendParameterTypes(i == 0 ? NativeSymbol.class : Addressable.class);\n-            }\n-\n-            MethodHandle acquireHandle = ACQUIRE_MH.asCollector(Scoped[].class, addressableCount).asType(adapterType);\n-            MethodHandle releaseHandle = RELEASE_MH.asCollector(Scoped[].class, addressableCount).asType(adapterType);\n-\n-            for (UnaryOperator<MethodHandle> adapter : adapters) {\n-                acquireHandle = adapter.apply(acquireHandle);\n-                releaseHandle = adapter.apply(releaseHandle);\n-            }\n-\n-            tryBlock = foldArguments(tryBlock, acquireHandle);\n-            cleanup = collectArguments(cleanup, hasReturn ? 2 : 1, releaseHandle);\n-\n-            return tryFinally(tryBlock, cleanup);\n-        } else {\n-            return downcallHandle;\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":18,"deletions":178,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import java.lang.foreign.Addressable;\n+import java.lang.foreign.CLinker;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n+public class PointerInvoke extends CLayouts {\n+\n+    ResourceScope scope = ResourceScope.newConfinedScope();\n+    MemorySegment segment = MemorySegment.allocateNative(100, scope);\n+\n+    static {\n+        System.loadLibrary(\"Ptr\");\n+    }\n+\n+    static final MethodHandle F_LONG, F_PTR;\n+\n+    static {\n+        CLinker abi = CLinker.systemCLinker();\n+        F_LONG = abi.downcallHandle(PointerInvoke.class.getClassLoader().findNative(\"func_as_long\").get(),\n+                FunctionDescriptor.of(C_INT, C_LONG_LONG));\n+        F_PTR = abi.downcallHandle(PointerInvoke.class.getClassLoader().findNative(\"func_as_ptr\").get(),\n+                FunctionDescriptor.of(C_INT, C_POINTER));\n+    }\n+\n+    @TearDown\n+    public void tearDown() {\n+        scope.close();\n+    }\n+\n+    @Benchmark\n+    public int panama_call_as_long() throws Throwable {\n+        return (int)F_LONG.invokeExact(segment.address().toRawLongValue());\n+    }\n+\n+    @Benchmark\n+    public int panama_call_as_address() throws Throwable {\n+        return (int)F_PTR.invokeExact((Addressable)segment.address());\n+    }\n+\n+    @Benchmark\n+    public int panama_call_as_segment() throws Throwable {\n+        return (int)F_PTR.invokeExact((Addressable)segment);\n+    }\n+\n+    @Benchmark\n+    public int panama_call_as_new_segment() throws Throwable {\n+        MemorySegment newSegment = MemorySegment.ofAddress(segment.address(), 100, scope);\n+        return (int)F_PTR.invokeExact((Addressable)newSegment);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/PointerInvoke.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT int func_as_long(long long value) {\n+  return 0;\n+}\n+\n+EXPORT int func_as_ptr(void* ptr) {\n+  return 0;\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/libPtr.c","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"}]}