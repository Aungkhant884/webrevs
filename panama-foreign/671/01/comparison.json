{"files":[{"patch":"@@ -38,0 +38,1 @@\n+import java.util.stream.IntStream;\n@@ -180,2 +181,3 @@\n-                Stream.of(argLayouts)\n-                        .map(Object::toString)\n+                IntStream.range(0, argLayouts.size())\n+                        .mapToObj(i -> (i == firstVariadicArgumentIndex() ?\n+                                \"...\" : \"\") + argLayouts.get(i))\n@@ -190,2 +192,3 @@\n-     *     <li>the two function descriptors have equals return layouts (see {@link MemoryLayout#equals(Object)}), or both have no return layout<\/li>\n-     *     <li>the two function descriptors have argument layouts that are pair-wise equal (see {@link MemoryLayout#equals(Object)})\n+     *     <li>the two function descriptors have equals return layouts (see {@link MemoryLayout#equals(Object)}), or both have no return layout;<\/li>\n+     *     <li>the two function descriptors have argument layouts that are pair-wise {@linkplain MemoryLayout#equals(Object) equal}; and<\/li>\n+     *     <li>the two function descriptors have the same leading {@linkplain #firstVariadicArgumentIndex() variadic argument index}<\/li>\n@@ -199,7 +202,4 @@\n-        if (this == other) {\n-            return true;\n-        }\n-        if (!(other instanceof FunctionDescriptor f)) {\n-            return false;\n-        }\n-        return Objects.equals(resLayout, f.resLayout) && Objects.equals(argLayouts, f.argLayouts);\n+        return other instanceof FunctionDescriptor f &&\n+                Objects.equals(resLayout, f.resLayout) &&\n+                Objects.equals(argLayouts, f.argLayouts) &&\n+                firstVariadicArgumentIndex() == f.firstVariadicArgumentIndex();\n@@ -213,2 +213,1 @@\n-        int hashCode = Objects.hashCode(argLayouts);\n-        return resLayout == null ? hashCode : resLayout.hashCode() ^ hashCode;\n+        return Objects.hash(argLayouts, resLayout, firstVariadicArgumentIndex());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/FunctionDescriptor.java","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1697,0 +1697,30 @@\n+    \/**\n+     * Compares the specified object with this memory segment for equality. Returns {@code true} if and only if the specified\n+     * object is also a memory segment, and if that segment refers to the same memory region as this segment. More specifically,\n+     * for two segments to be considered equals, all the following must be true:\n+     * <ul>\n+     *     <li>the two segments must be of the same kind; either both are {@linkplain #isNative() native segments},\n+     *     backed by off-heap memory, or both are backed by on-heap memory;\n+     *     <li>if the two segments are {@linkplain #isNative() native segments}, their {@link #address() base address}\n+     *     must be {@linkplain MemoryAddress#equals(Object) equal}. Otherwise, the two segments must wrap the\n+     *     same Java array instance, at the same starting offset;<\/li>\n+     *     <li>the two segments must have the same {@linkplain #byteSize() size}; and<\/li>\n+     *     <li>the two segments must have the {@linkplain MemorySession#equals(Object) same} {@linkplain #session() temporal bounds}.\n+     * <\/ul>\n+     * @apiNote This method does not perform a structural comparison of the contents of the two memory segments. Clients can\n+     * compare memory segments structurally by using the {@link #mismatch(MemorySegment)} method instead.\n+     *\n+     * @param that the object to be compared for equality with this memory segment.\n+     * @return {@code true} if the specified object is equal to this memory segment.\n+     * @see #mismatch(MemorySegment)\n+     * @see #asOverlappingSlice(MemorySegment)\n+     *\/\n+    @Override\n+    boolean equals(Object that);\n+\n+    \/**\n+     * {@return the hash code value for this memory segment}\n+     *\/\n+    @Override\n+    int hashCode();\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -498,0 +498,21 @@\n+    @Override\n+    public boolean equals(Object o) {\n+        return o instanceof AbstractMemorySegmentImpl that &&\n+                isNative() == that.isNative() &&\n+                unsafeGetOffset() == that.unsafeGetOffset() &&\n+                unsafeGetBase() == that.unsafeGetBase() &&\n+                length == that.length &&\n+                session.equals(that.session);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(\n+                isNative(),\n+                unsafeGetOffset(),\n+                unsafeGetBase(),\n+                length,\n+                session\n+        );\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import static org.testng.Assert.assertNotEquals;\n@@ -96,0 +97,10 @@\n+\n+    @Test\n+    public void testEquals() {\n+        FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_INT, C_INT);\n+        FunctionDescriptor fd_va1 = FunctionDescriptor.of(C_INT).asVariadic(C_INT, C_INT);\n+        FunctionDescriptor fd_va2 = FunctionDescriptor.of(C_INT, C_INT).asVariadic(C_INT);\n+        assertEquals(fd, fd);\n+        assertNotEquals(fd, fd_va1);\n+        assertNotEquals(fd, fd_va2);\n+    }\n","filename":"test\/jdk\/java\/foreign\/TestFunctionDescriptor.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -117,0 +117,26 @@\n+    @Test\n+    public void testEqualsOffHeap() {\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(100, session);\n+            assertEquals(segment, segment.asReadOnly());\n+            assertEquals(segment, segment.asSlice(0, 100));\n+            assertNotEquals(segment, segment.asSlice(10, 90));\n+            assertNotEquals(segment, segment.asSlice(0, 90));\n+            assertEquals(segment, MemorySegment.ofAddress(segment.address(), 100, session.asNonCloseable()));\n+            assertNotEquals(segment, MemorySegment.ofAddress(segment.address(), 100, MemorySession.global()));\n+            MemorySegment segment2 = MemorySegment.allocateNative(100, session);\n+            assertNotEquals(segment, segment2);\n+        }\n+    }\n+\n+    @Test\n+    public void testEqualsOnHeap() {\n+        MemorySegment segment = MemorySegment.ofArray(new byte[100]);\n+        assertEquals(segment, segment.asReadOnly());\n+        assertEquals(segment, segment.asSlice(0, 100));\n+        assertNotEquals(segment, segment.asSlice(10, 90));\n+        assertNotEquals(segment, segment.asSlice(0, 90));\n+        MemorySegment segment2 = MemorySegment.ofArray(new byte[100]);\n+        assertNotEquals(segment, segment2);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -402,1 +402,1 @@\n-        FunctionDescriptor fdExpected = FunctionDescriptor.ofVoid(ADDRESS, C_INT).asVariadic(C_INT, C_FLOAT);\n+        FunctionDescriptor fdExpected = FunctionDescriptor.ofVoid(ADDRESS, C_INT, C_INT, C_FLOAT);\n@@ -425,1 +425,1 @@\n-        FunctionDescriptor fdExpected = FunctionDescriptor.ofVoid(ADDRESS, C_INT).asVariadic(C_INT, C_FLOAT);\n+        FunctionDescriptor fdExpected = FunctionDescriptor.ofVoid(ADDRESS, C_INT, C_INT, C_FLOAT);\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestAarch64CallArranger.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -191,1 +191,1 @@\n-                ADDRESS, C_INT, C_DOUBLE).asVariadic(C_INT, C_DOUBLE, C_DOUBLE);\n+                ADDRESS, C_INT, C_DOUBLE, C_INT, C_DOUBLE, C_DOUBLE);\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestWindowsCallArranger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}