{"files":[{"patch":"@@ -1,647 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @enablePreview\n- * @modules java.base\/jdk.internal.foreign\n- *          java.base\/jdk.internal.foreign.abi\n- *          java.base\/jdk.internal.foreign.abi.aarch64\n- * @build CallArrangerTestBase\n- * @run testng TestAarch64CallArranger\n- *\/\n-\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.StructLayout;\n-import java.lang.foreign.MemorySegment;\n-import jdk.internal.foreign.abi.Binding;\n-import jdk.internal.foreign.abi.CallingSequence;\n-import jdk.internal.foreign.abi.LinkerOptions;\n-import jdk.internal.foreign.abi.StubLocations;\n-import jdk.internal.foreign.abi.VMStorage;\n-import jdk.internal.foreign.abi.aarch64.CallArranger;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n-import java.lang.invoke.MethodType;\n-\n-import static java.lang.foreign.Linker.Option.firstVariadicArg;\n-import static java.lang.foreign.ValueLayout.ADDRESS;\n-import static jdk.internal.foreign.PlatformLayouts.AArch64.*;\n-import static jdk.internal.foreign.abi.Binding.*;\n-import static jdk.internal.foreign.abi.aarch64.AArch64Architecture.*;\n-import static jdk.internal.foreign.abi.aarch64.AArch64Architecture.Regs.*;\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertFalse;\n-import static org.testng.Assert.assertTrue;\n-\n-public class TestAarch64CallArranger extends CallArrangerTestBase {\n-\n-    private static final VMStorage TARGET_ADDRESS_STORAGE = StubLocations.TARGET_ADDRESS.storage(StorageType.PLACEHOLDER);\n-    private static final VMStorage RETURN_BUFFER_STORAGE = StubLocations.RETURN_BUFFER.storage(StorageType.PLACEHOLDER);\n-\n-    @Test\n-    public void testEmpty() {\n-        MethodType mt = MethodType.methodType(void.class);\n-        FunctionDescriptor fd = FunctionDescriptor.ofVoid();\n-        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n-\n-        assertFalse(bindings.isInMemoryReturn());\n-        CallingSequence callingSequence = bindings.callingSequence();\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n-        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n-\n-        checkArgumentBindings(callingSequence, new Binding[][]{\n-            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) }\n-        });\n-\n-        checkReturnBindings(callingSequence, new Binding[]{});\n-    }\n-\n-    @Test\n-    public void testInteger() {\n-        MethodType mt = MethodType.methodType(void.class,\n-                int.class, int.class, int.class, int.class,\n-                int.class, int.class, int.class, int.class,\n-                int.class, int.class);\n-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n-                C_INT, C_INT, C_INT, C_INT,\n-                C_INT, C_INT, C_INT, C_INT,\n-                C_INT, C_INT);\n-        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n-\n-        assertFalse(bindings.isInMemoryReturn());\n-        CallingSequence callingSequence = bindings.callingSequence();\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n-        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n-\n-        checkArgumentBindings(callingSequence, new Binding[][]{\n-            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n-            { vmStore(r0, int.class) },\n-            { vmStore(r1, int.class) },\n-            { vmStore(r2, int.class) },\n-            { vmStore(r3, int.class) },\n-            { vmStore(r4, int.class) },\n-            { vmStore(r5, int.class) },\n-            { vmStore(r6, int.class) },\n-            { vmStore(r7, int.class) },\n-            { vmStore(stackStorage((short) 4, 0), int.class) },\n-            { vmStore(stackStorage((short) 4, 8), int.class) },\n-        });\n-\n-        checkReturnBindings(callingSequence, new Binding[]{});\n-    }\n-\n-    @Test\n-    public void testTwoIntTwoFloat() {\n-        MethodType mt = MethodType.methodType(void.class,\n-                int.class, int.class, float.class, float.class);\n-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n-                C_INT, C_INT, C_FLOAT, C_FLOAT);\n-        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n-\n-        assertFalse(bindings.isInMemoryReturn());\n-        CallingSequence callingSequence = bindings.callingSequence();\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n-        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n-\n-        checkArgumentBindings(callingSequence, new Binding[][]{\n-            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n-            { vmStore(r0, int.class) },\n-            { vmStore(r1, int.class) },\n-            { vmStore(v0, float.class) },\n-            { vmStore(v1, float.class) },\n-        });\n-\n-        checkReturnBindings(callingSequence, new Binding[]{});\n-    }\n-\n-    @Test(dataProvider = \"structs\")\n-    public void testStruct(MemoryLayout struct, Binding[] expectedBindings) {\n-        MethodType mt = MethodType.methodType(void.class, MemorySegment.class);\n-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(struct);\n-        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n-\n-        assertFalse(bindings.isInMemoryReturn());\n-        CallingSequence callingSequence = bindings.callingSequence();\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n-        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n-\n-        checkArgumentBindings(callingSequence, new Binding[][]{\n-            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n-            expectedBindings\n-        });\n-\n-        checkReturnBindings(callingSequence, new Binding[]{});\n-    }\n-\n-    @DataProvider\n-    public static Object[][] structs() {\n-        MemoryLayout struct2 = MemoryLayout.structLayout(C_INT, C_INT, C_DOUBLE, C_INT);\n-        return new Object[][]{\n-            \/\/ struct s { int32_t a, b; double c; };\n-            { MemoryLayout.structLayout(C_INT, C_INT, C_DOUBLE), new Binding[] {\n-                dup(),\n-                    \/\/ s.a & s.b\n-                    bufferLoad(0, long.class), vmStore(r0, long.class),\n-                    \/\/ s.c --> note AArch64 passes this in an *integer* register\n-                    bufferLoad(8, long.class), vmStore(r1, long.class),\n-            }},\n-            \/\/ struct s { int32_t a, b; double c; int32_t d };\n-            { struct2, new Binding[] {\n-                copy(struct2),\n-                unboxAddress(),\n-                vmStore(r0, long.class)\n-            }},\n-            \/\/ struct s { int32_t a[2]; float b[2] };\n-            { MemoryLayout.structLayout(C_INT, C_INT, C_FLOAT, C_FLOAT), new Binding[] {\n-                dup(),\n-                    \/\/ s.a[0] & s.a[1]\n-                    bufferLoad(0, long.class), vmStore(r0, long.class),\n-                    \/\/ s.b[0] & s.b[1]\n-                    bufferLoad(8, long.class), vmStore(r1, long.class),\n-            }},\n-            \/\/ struct s { float a; \/* padding *\/ double b };\n-            { MemoryLayout.structLayout(C_FLOAT, MemoryLayout.paddingLayout(32), C_DOUBLE),\n-              new Binding[] {\n-                dup(),\n-                \/\/ s.a\n-                bufferLoad(0, long.class), vmStore(r0, long.class),\n-                \/\/ s.b\n-                bufferLoad(8, long.class), vmStore(r1, long.class),\n-            }},\n-        };\n-    }\n-\n-    @Test\n-    public void testMultipleStructs() {\n-        MemoryLayout struct1 = MemoryLayout.structLayout(C_INT, C_INT, C_DOUBLE, C_INT);\n-        MemoryLayout struct2 = MemoryLayout.structLayout(C_LONG, C_LONG, C_LONG);\n-\n-        MethodType mt = MethodType.methodType(void.class, MemorySegment.class, MemorySegment.class, int.class);\n-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(struct1, struct2, C_INT);\n-        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n-\n-        assertFalse(bindings.isInMemoryReturn());\n-        CallingSequence callingSequence = bindings.callingSequence();\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n-        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n-\n-        checkArgumentBindings(callingSequence, new Binding[][]{\n-            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n-            {\n-                copy(struct1),\n-                unboxAddress(),\n-                vmStore(r0, long.class)\n-            },\n-            {\n-                copy(struct2),\n-                unboxAddress(),\n-                vmStore(r1, long.class)\n-            },\n-            { vmStore(r2, int.class) }\n-        });\n-\n-        checkReturnBindings(callingSequence, new Binding[]{});\n-    }\n-\n-    @Test\n-    public void testReturnStruct1() {\n-        MemoryLayout struct = MemoryLayout.structLayout(C_LONG, C_LONG, C_FLOAT);\n-\n-        MethodType mt = MethodType.methodType(MemorySegment.class);\n-        FunctionDescriptor fd = FunctionDescriptor.of(struct);\n-        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n-\n-        assertTrue(bindings.isInMemoryReturn());\n-        CallingSequence callingSequence = bindings.callingSequence();\n-        assertEquals(callingSequence.callerMethodType(), MethodType.methodType(void.class, MemorySegment.class, MemorySegment.class));\n-        assertEquals(callingSequence.functionDesc(), FunctionDescriptor.ofVoid(ADDRESS, C_POINTER));\n-\n-        checkArgumentBindings(callingSequence, new Binding[][]{\n-            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n-            {\n-                unboxAddress(),\n-                vmStore(r8, long.class)\n-            }\n-        });\n-\n-        checkReturnBindings(callingSequence, new Binding[]{});\n-    }\n-\n-    @Test\n-    public void testReturnStruct2() {\n-        MemoryLayout struct = MemoryLayout.structLayout(C_LONG, C_LONG);\n-\n-        MethodType mt = MethodType.methodType(MemorySegment.class);\n-        FunctionDescriptor fd = FunctionDescriptor.of(struct);\n-        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n-\n-        assertFalse(bindings.isInMemoryReturn());\n-        CallingSequence callingSequence = bindings.callingSequence();\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class, MemorySegment.class));\n-        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS, ADDRESS));\n-\n-        checkArgumentBindings(callingSequence, new Binding[][]{\n-            { unboxAddress(), vmStore(RETURN_BUFFER_STORAGE, long.class) },\n-            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) }\n-        });\n-\n-        checkReturnBindings(callingSequence, new Binding[]{\n-            allocate(struct),\n-            dup(),\n-            vmLoad(r0, long.class),\n-            bufferStore(0, long.class),\n-            dup(),\n-            vmLoad(r1, long.class),\n-            bufferStore(8, long.class),\n-        });\n-    }\n-\n-    @Test\n-    public void testStructHFA1() {\n-        MemoryLayout hfa = MemoryLayout.structLayout(C_FLOAT, C_FLOAT);\n-\n-        MethodType mt = MethodType.methodType(MemorySegment.class, float.class, int.class, MemorySegment.class);\n-        FunctionDescriptor fd = FunctionDescriptor.of(hfa, C_FLOAT, C_INT, hfa);\n-        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n-\n-        assertFalse(bindings.isInMemoryReturn());\n-        CallingSequence callingSequence = bindings.callingSequence();\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class, MemorySegment.class));\n-        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS, ADDRESS));\n-\n-        checkArgumentBindings(callingSequence, new Binding[][]{\n-            { unboxAddress(), vmStore(RETURN_BUFFER_STORAGE, long.class) },\n-            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n-            { vmStore(v0, float.class) },\n-            { vmStore(r0, int.class) },\n-            {\n-                dup(),\n-                bufferLoad(0, float.class),\n-                vmStore(v1, float.class),\n-                bufferLoad(4, float.class),\n-                vmStore(v2, float.class)\n-            }\n-        });\n-\n-        checkReturnBindings(callingSequence, new Binding[]{\n-            allocate(hfa),\n-            dup(),\n-            vmLoad(v0, float.class),\n-            bufferStore(0, float.class),\n-            dup(),\n-            vmLoad(v1, float.class),\n-            bufferStore(4, float.class),\n-        });\n-    }\n-\n-    @Test\n-    public void testStructHFA3() {\n-        MemoryLayout struct = MemoryLayout.structLayout(C_FLOAT, C_FLOAT, C_FLOAT);\n-\n-        MethodType mt = MethodType.methodType(void.class, MemorySegment.class, MemorySegment.class, MemorySegment.class);\n-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(struct, struct, struct);\n-        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n-\n-        assertFalse(bindings.isInMemoryReturn());\n-        CallingSequence callingSequence = bindings.callingSequence();\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n-        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n-\n-        checkArgumentBindings(callingSequence, new Binding[][]{\n-            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n-            {\n-                dup(),\n-                bufferLoad(0, float.class),\n-                vmStore(v0, float.class),\n-                dup(),\n-                bufferLoad(4, float.class),\n-                vmStore(v1, float.class),\n-                bufferLoad(8, float.class),\n-                vmStore(v2, float.class)\n-            },\n-            {\n-                dup(),\n-                bufferLoad(0, float.class),\n-                vmStore(v3, float.class),\n-                dup(),\n-                bufferLoad(4, float.class),\n-                vmStore(v4, float.class),\n-                bufferLoad(8, float.class),\n-                vmStore(v5, float.class)\n-            },\n-            {\n-                dup(),\n-                bufferLoad(0, long.class),\n-                vmStore(stackStorage((short) 8, 0), long.class),\n-                bufferLoad(8, int.class),\n-                vmStore(stackStorage((short) 4, 8), int.class),\n-            }\n-        });\n-\n-        checkReturnBindings(callingSequence, new Binding[]{});\n-    }\n-\n-    @Test\n-    public void testStructStackSpill() {\n-        \/\/ A large (> 16 byte) struct argument that is spilled to the\n-        \/\/ stack should be passed as a pointer to a copy and occupy one\n-        \/\/ stack slot.\n-\n-        MemoryLayout struct = MemoryLayout.structLayout(C_INT, C_INT, C_DOUBLE, C_INT);\n-\n-        MethodType mt = MethodType.methodType(\n-            void.class, MemorySegment.class, MemorySegment.class, int.class, int.class,\n-            int.class, int.class, int.class, int.class, MemorySegment.class, int.class);\n-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n-            struct, struct, C_INT, C_INT, C_INT, C_INT, C_INT, C_INT, struct, C_INT);\n-        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n-\n-        assertFalse(bindings.isInMemoryReturn());\n-        CallingSequence callingSequence = bindings.callingSequence();\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n-        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n-\n-        checkArgumentBindings(callingSequence, new Binding[][]{\n-            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n-            { copy(struct), unboxAddress(), vmStore(r0, long.class) },\n-            { copy(struct), unboxAddress(), vmStore(r1, long.class) },\n-            { vmStore(r2, int.class) },\n-            { vmStore(r3, int.class) },\n-            { vmStore(r4, int.class) },\n-            { vmStore(r5, int.class) },\n-            { vmStore(r6, int.class) },\n-            { vmStore(r7, int.class) },\n-            { copy(struct), unboxAddress(), vmStore(stackStorage((short) 8, 0), long.class) },\n-            { vmStore(stackStorage((short) 4, 8), int.class) },\n-        });\n-\n-        checkReturnBindings(callingSequence, new Binding[]{});\n-    }\n-\n-    @Test\n-    public void testVarArgsInRegs() {\n-        MethodType mt = MethodType.methodType(void.class, int.class, int.class, float.class);\n-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_INT, C_INT, C_FLOAT);\n-        FunctionDescriptor fdExpected = FunctionDescriptor.ofVoid(ADDRESS, C_INT, C_INT, C_FLOAT);\n-        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false, LinkerOptions.forDowncall(fd, firstVariadicArg(1)));\n-\n-        assertFalse(bindings.isInMemoryReturn());\n-        CallingSequence callingSequence = bindings.callingSequence();\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n-        assertEquals(callingSequence.functionDesc(), fdExpected);\n-\n-        \/\/ This is identical to the non-variadic calling sequence\n-        checkArgumentBindings(callingSequence, new Binding[][]{\n-            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n-            { vmStore(r0, int.class) },\n-            { vmStore(r1, int.class) },\n-            { vmStore(v0, float.class) },\n-        });\n-\n-        checkReturnBindings(callingSequence, new Binding[]{});\n-    }\n-\n-    @Test\n-    public void testVarArgsOnStack() {\n-        MethodType mt = MethodType.methodType(void.class, int.class, int.class, float.class);\n-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_INT, C_INT, C_FLOAT);\n-        FunctionDescriptor fdExpected = FunctionDescriptor.ofVoid(ADDRESS, C_INT, C_INT, C_FLOAT);\n-        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false, LinkerOptions.forDowncall(fd, firstVariadicArg(1)));\n-\n-        assertFalse(bindings.isInMemoryReturn());\n-        CallingSequence callingSequence = bindings.callingSequence();\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n-        assertEquals(callingSequence.functionDesc(), fdExpected);\n-\n-        \/\/ The two variadic arguments should be allocated on the stack\n-        checkArgumentBindings(callingSequence, new Binding[][]{\n-            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n-            { vmStore(r0, int.class) },\n-            { vmStore(stackStorage((short) 4, 0), int.class) },\n-            { vmStore(stackStorage((short) 4, 8), float.class) },\n-        });\n-\n-        checkReturnBindings(callingSequence, new Binding[]{});\n-    }\n-\n-    @Test\n-    public void testMacArgsOnStack() {\n-        MethodType mt = MethodType.methodType(void.class,\n-                int.class, int.class, int.class, int.class,\n-                int.class, int.class, int.class, int.class,\n-                int.class, int.class, short.class, byte.class);\n-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n-                C_INT, C_INT, C_INT, C_INT,\n-                C_INT, C_INT, C_INT, C_INT,\n-                C_INT, C_INT, C_SHORT, C_CHAR);\n-        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false);\n-\n-        assertFalse(bindings.isInMemoryReturn());\n-        CallingSequence callingSequence = bindings.callingSequence();\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n-        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n-\n-        checkArgumentBindings(callingSequence, new Binding[][]{\n-            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n-            { vmStore(r0, int.class) },\n-            { vmStore(r1, int.class) },\n-            { vmStore(r2, int.class) },\n-            { vmStore(r3, int.class) },\n-            { vmStore(r4, int.class) },\n-            { vmStore(r5, int.class) },\n-            { vmStore(r6, int.class) },\n-            { vmStore(r7, int.class) },\n-            { vmStore(stackStorage((short) 4, 0), int.class) },\n-            { vmStore(stackStorage((short) 4, 4), int.class) },\n-            { cast(short.class, int.class), vmStore(stackStorage((short) 2, 8), int.class) },\n-            { cast(byte.class, int.class), vmStore(stackStorage((short) 1, 10), int.class) },\n-        });\n-\n-        checkReturnBindings(callingSequence, new Binding[]{});\n-    }\n-\n-    @Test\n-    public void testMacArgsOnStack2() {\n-        StructLayout struct = MemoryLayout.structLayout(\n-            C_FLOAT,\n-            C_FLOAT\n-        );\n-        MethodType mt = MethodType.methodType(void.class,\n-                long.class, long.class, long.class, long.class,\n-                long.class, long.class, long.class, long.class,\n-                double.class, double.class, double.class, double.class,\n-                double.class, double.class, double.class, double.class,\n-                int.class, MemorySegment.class);\n-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n-                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n-                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n-                C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,\n-                C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,\n-                C_INT, struct);\n-        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false);\n-\n-        assertFalse(bindings.isInMemoryReturn());\n-        CallingSequence callingSequence = bindings.callingSequence();\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n-        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n-\n-        checkArgumentBindings(callingSequence, new Binding[][]{\n-            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n-            { vmStore(r0, long.class) },\n-            { vmStore(r1, long.class) },\n-            { vmStore(r2, long.class) },\n-            { vmStore(r3, long.class) },\n-            { vmStore(r4, long.class) },\n-            { vmStore(r5, long.class) },\n-            { vmStore(r6, long.class) },\n-            { vmStore(r7, long.class) },\n-            { vmStore(v0, double.class) },\n-            { vmStore(v1, double.class) },\n-            { vmStore(v2, double.class) },\n-            { vmStore(v3, double.class) },\n-            { vmStore(v4, double.class) },\n-            { vmStore(v5, double.class) },\n-            { vmStore(v6, double.class) },\n-            { vmStore(v7, double.class) },\n-            { vmStore(stackStorage((short) 4, 0), int.class) },\n-            {\n-                dup(),\n-                bufferLoad(0, int.class),\n-                vmStore(stackStorage((short) 4, 4), int.class),\n-                bufferLoad(4, int.class),\n-                vmStore(stackStorage((short) 4, 8), int.class),\n-            }\n-        });\n-\n-        checkReturnBindings(callingSequence, new Binding[]{});\n-    }\n-\n-    @Test\n-    public void testMacArgsOnStack3() {\n-        StructLayout struct = MemoryLayout.structLayout(\n-            C_POINTER,\n-            C_POINTER\n-        );\n-        MethodType mt = MethodType.methodType(void.class,\n-                long.class, long.class, long.class, long.class,\n-                long.class, long.class, long.class, long.class,\n-                double.class, double.class, double.class, double.class,\n-                double.class, double.class, double.class, double.class,\n-                MemorySegment.class, float.class);\n-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n-                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n-                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n-                C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,\n-                C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,\n-                struct, C_FLOAT);\n-        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false);\n-\n-        assertFalse(bindings.isInMemoryReturn());\n-        CallingSequence callingSequence = bindings.callingSequence();\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n-        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n-\n-        checkArgumentBindings(callingSequence, new Binding[][]{\n-            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n-            { vmStore(r0, long.class) },\n-            { vmStore(r1, long.class) },\n-            { vmStore(r2, long.class) },\n-            { vmStore(r3, long.class) },\n-            { vmStore(r4, long.class) },\n-            { vmStore(r5, long.class) },\n-            { vmStore(r6, long.class) },\n-            { vmStore(r7, long.class) },\n-            { vmStore(v0, double.class) },\n-            { vmStore(v1, double.class) },\n-            { vmStore(v2, double.class) },\n-            { vmStore(v3, double.class) },\n-            { vmStore(v4, double.class) },\n-            { vmStore(v5, double.class) },\n-            { vmStore(v6, double.class) },\n-            { vmStore(v7, double.class) },\n-            { dup(),\n-                bufferLoad(0, long.class), vmStore(stackStorage((short) 8, 0), long.class),\n-                bufferLoad(8, long.class), vmStore(stackStorage((short) 8, 8), long.class) },\n-            { vmStore(stackStorage((short) 4, 16), float.class) },\n-        });\n-\n-        checkReturnBindings(callingSequence, new Binding[]{});\n-    }\n-\n-    @Test\n-    public void testMacArgsOnStack4() {\n-        StructLayout struct = MemoryLayout.structLayout(\n-            C_INT,\n-            C_INT,\n-            C_POINTER\n-        );\n-        MethodType mt = MethodType.methodType(void.class,\n-                long.class, long.class, long.class, long.class,\n-                long.class, long.class, long.class, long.class,\n-                double.class, double.class, double.class, double.class,\n-                double.class, double.class, double.class, double.class,\n-                float.class, MemorySegment.class);\n-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n-                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n-                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n-                C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,\n-                C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,\n-                C_FLOAT, struct);\n-        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false);\n-\n-        assertFalse(bindings.isInMemoryReturn());\n-        CallingSequence callingSequence = bindings.callingSequence();\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n-        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n-\n-        checkArgumentBindings(callingSequence, new Binding[][]{\n-            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n-            { vmStore(r0, long.class) },\n-            { vmStore(r1, long.class) },\n-            { vmStore(r2, long.class) },\n-            { vmStore(r3, long.class) },\n-            { vmStore(r4, long.class) },\n-            { vmStore(r5, long.class) },\n-            { vmStore(r6, long.class) },\n-            { vmStore(r7, long.class) },\n-            { vmStore(v0, double.class) },\n-            { vmStore(v1, double.class) },\n-            { vmStore(v2, double.class) },\n-            { vmStore(v3, double.class) },\n-            { vmStore(v4, double.class) },\n-            { vmStore(v5, double.class) },\n-            { vmStore(v6, double.class) },\n-            { vmStore(v7, double.class) },\n-            { vmStore(stackStorage((short) 4, 0), float.class) },\n-            { dup(),\n-                bufferLoad(0, long.class), vmStore(stackStorage((short) 8, 8), long.class),\n-                bufferLoad(8, long.class), vmStore(stackStorage((short) 8, 16), long.class) },\n-        });\n-\n-        checkReturnBindings(callingSequence, new Binding[]{});\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestAarch64CallArranger.java","additions":0,"deletions":647,"binary":false,"changes":647,"status":"deleted"},{"patch":"@@ -0,0 +1,427 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.foreign\n+ *          java.base\/jdk.internal.foreign.abi\n+ *          java.base\/jdk.internal.foreign.abi.aarch64\n+ * @build CallArrangerTestBase\n+ * @run testng TestLinuxAArch64CallArranger\n+ *\/\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.StructLayout;\n+import java.lang.foreign.MemorySegment;\n+import jdk.internal.foreign.abi.Binding;\n+import jdk.internal.foreign.abi.CallingSequence;\n+import jdk.internal.foreign.abi.LinkerOptions;\n+import jdk.internal.foreign.abi.StubLocations;\n+import jdk.internal.foreign.abi.VMStorage;\n+import jdk.internal.foreign.abi.aarch64.CallArranger;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodType;\n+\n+import static java.lang.foreign.Linker.Option.firstVariadicArg;\n+import static java.lang.foreign.ValueLayout.ADDRESS;\n+import static jdk.internal.foreign.PlatformLayouts.AArch64.*;\n+import static jdk.internal.foreign.abi.Binding.*;\n+import static jdk.internal.foreign.abi.aarch64.AArch64Architecture.*;\n+import static jdk.internal.foreign.abi.aarch64.AArch64Architecture.Regs.*;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestLinuxAArch64CallArranger extends CallArrangerTestBase {\n+\n+    private static final VMStorage TARGET_ADDRESS_STORAGE = StubLocations.TARGET_ADDRESS.storage(StorageType.PLACEHOLDER);\n+    private static final VMStorage RETURN_BUFFER_STORAGE = StubLocations.RETURN_BUFFER.storage(StorageType.PLACEHOLDER);\n+\n+    @Test\n+    public void testEmpty() {\n+        MethodType mt = MethodType.methodType(void.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid();\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) }\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testInteger() {\n+        MethodType mt = MethodType.methodType(void.class,\n+                int.class, int.class, int.class, int.class,\n+                int.class, int.class, int.class, int.class,\n+                int.class, int.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n+                C_INT, C_INT, C_INT, C_INT,\n+                C_INT, C_INT, C_INT, C_INT,\n+                C_INT, C_INT);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(r0, int.class) },\n+            { vmStore(r1, int.class) },\n+            { vmStore(r2, int.class) },\n+            { vmStore(r3, int.class) },\n+            { vmStore(r4, int.class) },\n+            { vmStore(r5, int.class) },\n+            { vmStore(r6, int.class) },\n+            { vmStore(r7, int.class) },\n+            { vmStore(stackStorage((short) 4, 0), int.class) },\n+            { vmStore(stackStorage((short) 4, 8), int.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testTwoIntTwoFloat() {\n+        MethodType mt = MethodType.methodType(void.class,\n+                int.class, int.class, float.class, float.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n+                C_INT, C_INT, C_FLOAT, C_FLOAT);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(r0, int.class) },\n+            { vmStore(r1, int.class) },\n+            { vmStore(v0, float.class) },\n+            { vmStore(v1, float.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test(dataProvider = \"structs\")\n+    public void testStruct(MemoryLayout struct, Binding[] expectedBindings) {\n+        MethodType mt = MethodType.methodType(void.class, MemorySegment.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(struct);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            expectedBindings\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @DataProvider\n+    public static Object[][] structs() {\n+        MemoryLayout struct2 = MemoryLayout.structLayout(C_INT, C_INT, C_DOUBLE, C_INT);\n+        return new Object[][]{\n+            \/\/ struct s { int32_t a, b; double c; };\n+            { MemoryLayout.structLayout(C_INT, C_INT, C_DOUBLE), new Binding[] {\n+                dup(),\n+                    \/\/ s.a & s.b\n+                    bufferLoad(0, long.class), vmStore(r0, long.class),\n+                    \/\/ s.c --> note AArch64 passes this in an *integer* register\n+                    bufferLoad(8, long.class), vmStore(r1, long.class),\n+            }},\n+            \/\/ struct s { int32_t a, b; double c; int32_t d };\n+            { struct2, new Binding[] {\n+                copy(struct2),\n+                unboxAddress(),\n+                vmStore(r0, long.class)\n+            }},\n+            \/\/ struct s { int32_t a[2]; float b[2] };\n+            { MemoryLayout.structLayout(C_INT, C_INT, C_FLOAT, C_FLOAT), new Binding[] {\n+                dup(),\n+                    \/\/ s.a[0] & s.a[1]\n+                    bufferLoad(0, long.class), vmStore(r0, long.class),\n+                    \/\/ s.b[0] & s.b[1]\n+                    bufferLoad(8, long.class), vmStore(r1, long.class),\n+            }},\n+            \/\/ struct s { float a; \/* padding *\/ double b };\n+            { MemoryLayout.structLayout(C_FLOAT, MemoryLayout.paddingLayout(32), C_DOUBLE),\n+              new Binding[] {\n+                dup(),\n+                \/\/ s.a\n+                bufferLoad(0, long.class), vmStore(r0, long.class),\n+                \/\/ s.b\n+                bufferLoad(8, long.class), vmStore(r1, long.class),\n+            }},\n+        };\n+    }\n+\n+    @Test\n+    public void testMultipleStructs() {\n+        MemoryLayout struct1 = MemoryLayout.structLayout(C_INT, C_INT, C_DOUBLE, C_INT);\n+        MemoryLayout struct2 = MemoryLayout.structLayout(C_LONG, C_LONG, C_LONG);\n+\n+        MethodType mt = MethodType.methodType(void.class, MemorySegment.class, MemorySegment.class, int.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(struct1, struct2, C_INT);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            {\n+                copy(struct1),\n+                unboxAddress(),\n+                vmStore(r0, long.class)\n+            },\n+            {\n+                copy(struct2),\n+                unboxAddress(),\n+                vmStore(r1, long.class)\n+            },\n+            { vmStore(r2, int.class) }\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testReturnStruct1() {\n+        MemoryLayout struct = MemoryLayout.structLayout(C_LONG, C_LONG, C_FLOAT);\n+\n+        MethodType mt = MethodType.methodType(MemorySegment.class);\n+        FunctionDescriptor fd = FunctionDescriptor.of(struct);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n+\n+        assertTrue(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), MethodType.methodType(void.class, MemorySegment.class, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), FunctionDescriptor.ofVoid(ADDRESS, C_POINTER));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            {\n+                unboxAddress(),\n+                vmStore(r8, long.class)\n+            }\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testReturnStruct2() {\n+        MemoryLayout struct = MemoryLayout.structLayout(C_LONG, C_LONG);\n+\n+        MethodType mt = MethodType.methodType(MemorySegment.class);\n+        FunctionDescriptor fd = FunctionDescriptor.of(struct);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(RETURN_BUFFER_STORAGE, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) }\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{\n+            allocate(struct),\n+            dup(),\n+            vmLoad(r0, long.class),\n+            bufferStore(0, long.class),\n+            dup(),\n+            vmLoad(r1, long.class),\n+            bufferStore(8, long.class),\n+        });\n+    }\n+\n+    @Test\n+    public void testStructHFA1() {\n+        MemoryLayout hfa = MemoryLayout.structLayout(C_FLOAT, C_FLOAT);\n+\n+        MethodType mt = MethodType.methodType(MemorySegment.class, float.class, int.class, MemorySegment.class);\n+        FunctionDescriptor fd = FunctionDescriptor.of(hfa, C_FLOAT, C_INT, hfa);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(RETURN_BUFFER_STORAGE, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(v0, float.class) },\n+            { vmStore(r0, int.class) },\n+            {\n+                dup(),\n+                bufferLoad(0, float.class),\n+                vmStore(v1, float.class),\n+                bufferLoad(4, float.class),\n+                vmStore(v2, float.class)\n+            }\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{\n+            allocate(hfa),\n+            dup(),\n+            vmLoad(v0, float.class),\n+            bufferStore(0, float.class),\n+            dup(),\n+            vmLoad(v1, float.class),\n+            bufferStore(4, float.class),\n+        });\n+    }\n+\n+    @Test\n+    public void testStructHFA3() {\n+        MemoryLayout struct = MemoryLayout.structLayout(C_FLOAT, C_FLOAT, C_FLOAT);\n+\n+        MethodType mt = MethodType.methodType(void.class, MemorySegment.class, MemorySegment.class, MemorySegment.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(struct, struct, struct);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            {\n+                dup(),\n+                bufferLoad(0, float.class),\n+                vmStore(v0, float.class),\n+                dup(),\n+                bufferLoad(4, float.class),\n+                vmStore(v1, float.class),\n+                bufferLoad(8, float.class),\n+                vmStore(v2, float.class)\n+            },\n+            {\n+                dup(),\n+                bufferLoad(0, float.class),\n+                vmStore(v3, float.class),\n+                dup(),\n+                bufferLoad(4, float.class),\n+                vmStore(v4, float.class),\n+                bufferLoad(8, float.class),\n+                vmStore(v5, float.class)\n+            },\n+            {\n+                dup(),\n+                bufferLoad(0, long.class),\n+                vmStore(stackStorage((short) 8, 0), long.class),\n+                bufferLoad(8, int.class),\n+                vmStore(stackStorage((short) 4, 8), int.class),\n+            }\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testStructStackSpill() {\n+        \/\/ A large (> 16 byte) struct argument that is spilled to the\n+        \/\/ stack should be passed as a pointer to a copy and occupy one\n+        \/\/ stack slot.\n+\n+        MemoryLayout struct = MemoryLayout.structLayout(C_INT, C_INT, C_DOUBLE, C_INT);\n+\n+        MethodType mt = MethodType.methodType(\n+            void.class, MemorySegment.class, MemorySegment.class, int.class, int.class,\n+            int.class, int.class, int.class, int.class, MemorySegment.class, int.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n+            struct, struct, C_INT, C_INT, C_INT, C_INT, C_INT, C_INT, struct, C_INT);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { copy(struct), unboxAddress(), vmStore(r0, long.class) },\n+            { copy(struct), unboxAddress(), vmStore(r1, long.class) },\n+            { vmStore(r2, int.class) },\n+            { vmStore(r3, int.class) },\n+            { vmStore(r4, int.class) },\n+            { vmStore(r5, int.class) },\n+            { vmStore(r6, int.class) },\n+            { vmStore(r7, int.class) },\n+            { copy(struct), unboxAddress(), vmStore(stackStorage((short) 8, 0), long.class) },\n+            { vmStore(stackStorage((short) 4, 8), int.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testVarArgsInRegs() {\n+        MethodType mt = MethodType.methodType(void.class, int.class, int.class, float.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_INT, C_INT, C_FLOAT);\n+        FunctionDescriptor fdExpected = FunctionDescriptor.ofVoid(ADDRESS, C_INT, C_INT, C_FLOAT);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false, LinkerOptions.forDowncall(fd, firstVariadicArg(1)));\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fdExpected);\n+\n+        \/\/ This is identical to the non-variadic calling sequence\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(r0, int.class) },\n+            { vmStore(r1, int.class) },\n+            { vmStore(v0, float.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestLinuxAArch64CallArranger.java","additions":427,"deletions":0,"binary":false,"changes":427,"status":"added"},{"patch":"@@ -0,0 +1,283 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.foreign\n+ *          java.base\/jdk.internal.foreign.abi\n+ *          java.base\/jdk.internal.foreign.abi.aarch64\n+ * @build CallArrangerTestBase\n+ * @run testng TestMacOsAArch64CallArranger\n+ *\/\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.StructLayout;\n+import java.lang.foreign.MemorySegment;\n+import jdk.internal.foreign.abi.Binding;\n+import jdk.internal.foreign.abi.CallingSequence;\n+import jdk.internal.foreign.abi.LinkerOptions;\n+import jdk.internal.foreign.abi.StubLocations;\n+import jdk.internal.foreign.abi.VMStorage;\n+import jdk.internal.foreign.abi.aarch64.CallArranger;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodType;\n+\n+import static java.lang.foreign.Linker.Option.firstVariadicArg;\n+import static java.lang.foreign.ValueLayout.ADDRESS;\n+import static jdk.internal.foreign.PlatformLayouts.AArch64.*;\n+import static jdk.internal.foreign.abi.Binding.*;\n+import static jdk.internal.foreign.abi.aarch64.AArch64Architecture.*;\n+import static jdk.internal.foreign.abi.aarch64.AArch64Architecture.Regs.*;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestMacOsAArch64CallArranger extends CallArrangerTestBase {\n+\n+    private static final VMStorage TARGET_ADDRESS_STORAGE = StubLocations.TARGET_ADDRESS.storage(StorageType.PLACEHOLDER);\n+\n+    @Test\n+    public void testVarArgsOnStack() {\n+        MethodType mt = MethodType.methodType(void.class, int.class, int.class, float.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_INT, C_INT, C_FLOAT);\n+        FunctionDescriptor fdExpected = FunctionDescriptor.ofVoid(ADDRESS, C_INT, C_INT, C_FLOAT);\n+        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false, LinkerOptions.forDowncall(fd, firstVariadicArg(1)));\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fdExpected);\n+\n+        \/\/ The two variadic arguments should be allocated on the stack\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(r0, int.class) },\n+            { vmStore(stackStorage((short) 4, 0), int.class) },\n+            { vmStore(stackStorage((short) 4, 8), float.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testMacArgsOnStack() {\n+        MethodType mt = MethodType.methodType(void.class,\n+                int.class, int.class, int.class, int.class,\n+                int.class, int.class, int.class, int.class,\n+                int.class, int.class, short.class, byte.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n+                C_INT, C_INT, C_INT, C_INT,\n+                C_INT, C_INT, C_INT, C_INT,\n+                C_INT, C_INT, C_SHORT, C_CHAR);\n+        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(r0, int.class) },\n+            { vmStore(r1, int.class) },\n+            { vmStore(r2, int.class) },\n+            { vmStore(r3, int.class) },\n+            { vmStore(r4, int.class) },\n+            { vmStore(r5, int.class) },\n+            { vmStore(r6, int.class) },\n+            { vmStore(r7, int.class) },\n+            { vmStore(stackStorage((short) 4, 0), int.class) },\n+            { vmStore(stackStorage((short) 4, 4), int.class) },\n+            { cast(short.class, int.class), vmStore(stackStorage((short) 2, 8), int.class) },\n+            { cast(byte.class, int.class), vmStore(stackStorage((short) 1, 10), int.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testMacArgsOnStack2() {\n+        StructLayout struct = MemoryLayout.structLayout(\n+            C_FLOAT,\n+            C_FLOAT\n+        );\n+        MethodType mt = MethodType.methodType(void.class,\n+                long.class, long.class, long.class, long.class,\n+                long.class, long.class, long.class, long.class,\n+                double.class, double.class, double.class, double.class,\n+                double.class, double.class, double.class, double.class,\n+                int.class, MemorySegment.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n+                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n+                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n+                C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,\n+                C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,\n+                C_INT, struct);\n+        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(r0, long.class) },\n+            { vmStore(r1, long.class) },\n+            { vmStore(r2, long.class) },\n+            { vmStore(r3, long.class) },\n+            { vmStore(r4, long.class) },\n+            { vmStore(r5, long.class) },\n+            { vmStore(r6, long.class) },\n+            { vmStore(r7, long.class) },\n+            { vmStore(v0, double.class) },\n+            { vmStore(v1, double.class) },\n+            { vmStore(v2, double.class) },\n+            { vmStore(v3, double.class) },\n+            { vmStore(v4, double.class) },\n+            { vmStore(v5, double.class) },\n+            { vmStore(v6, double.class) },\n+            { vmStore(v7, double.class) },\n+            { vmStore(stackStorage((short) 4, 0), int.class) },\n+            {\n+                dup(),\n+                bufferLoad(0, int.class),\n+                vmStore(stackStorage((short) 4, 4), int.class),\n+                bufferLoad(4, int.class),\n+                vmStore(stackStorage((short) 4, 8), int.class),\n+            }\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testMacArgsOnStack3() {\n+        StructLayout struct = MemoryLayout.structLayout(\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        MethodType mt = MethodType.methodType(void.class,\n+                long.class, long.class, long.class, long.class,\n+                long.class, long.class, long.class, long.class,\n+                double.class, double.class, double.class, double.class,\n+                double.class, double.class, double.class, double.class,\n+                MemorySegment.class, float.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n+                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n+                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n+                C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,\n+                C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,\n+                struct, C_FLOAT);\n+        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(r0, long.class) },\n+            { vmStore(r1, long.class) },\n+            { vmStore(r2, long.class) },\n+            { vmStore(r3, long.class) },\n+            { vmStore(r4, long.class) },\n+            { vmStore(r5, long.class) },\n+            { vmStore(r6, long.class) },\n+            { vmStore(r7, long.class) },\n+            { vmStore(v0, double.class) },\n+            { vmStore(v1, double.class) },\n+            { vmStore(v2, double.class) },\n+            { vmStore(v3, double.class) },\n+            { vmStore(v4, double.class) },\n+            { vmStore(v5, double.class) },\n+            { vmStore(v6, double.class) },\n+            { vmStore(v7, double.class) },\n+            { dup(),\n+                bufferLoad(0, long.class), vmStore(stackStorage((short) 8, 0), long.class),\n+                bufferLoad(8, long.class), vmStore(stackStorage((short) 8, 8), long.class) },\n+            { vmStore(stackStorage((short) 4, 16), float.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testMacArgsOnStack4() {\n+        StructLayout struct = MemoryLayout.structLayout(\n+            C_INT,\n+            C_INT,\n+            C_POINTER\n+        );\n+        MethodType mt = MethodType.methodType(void.class,\n+                long.class, long.class, long.class, long.class,\n+                long.class, long.class, long.class, long.class,\n+                double.class, double.class, double.class, double.class,\n+                double.class, double.class, double.class, double.class,\n+                float.class, MemorySegment.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n+                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n+                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n+                C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,\n+                C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,\n+                C_FLOAT, struct);\n+        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(r0, long.class) },\n+            { vmStore(r1, long.class) },\n+            { vmStore(r2, long.class) },\n+            { vmStore(r3, long.class) },\n+            { vmStore(r4, long.class) },\n+            { vmStore(r5, long.class) },\n+            { vmStore(r6, long.class) },\n+            { vmStore(r7, long.class) },\n+            { vmStore(v0, double.class) },\n+            { vmStore(v1, double.class) },\n+            { vmStore(v2, double.class) },\n+            { vmStore(v3, double.class) },\n+            { vmStore(v4, double.class) },\n+            { vmStore(v5, double.class) },\n+            { vmStore(v6, double.class) },\n+            { vmStore(v7, double.class) },\n+            { vmStore(stackStorage((short) 4, 0), float.class) },\n+            { dup(),\n+                bufferLoad(0, long.class), vmStore(stackStorage((short) 8, 8), long.class),\n+                bufferLoad(8, long.class), vmStore(stackStorage((short) 8, 16), long.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestMacOsAArch64CallArranger.java","additions":283,"deletions":0,"binary":false,"changes":283,"status":"added"}]}