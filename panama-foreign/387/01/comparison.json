{"files":[{"patch":"@@ -12,1 +12,1 @@\n-        default: \"Linux x64, Windows x64, macOS x64\"\n+        default: \"Linux x64, Linux x86, Windows x64, macOS x64\"\n@@ -21,1 +21,1 @@\n-      platform_linux_x32: ${{ steps.check_platforms.outputs.platform_linux_x32 }}\n+      platform_linux_x86: ${{ steps.check_platforms.outputs.platform_linux_x86 }}\n@@ -36,1 +36,1 @@\n-          echo \"::set-output name=platform_linux_x32::${{ contains(github.event.inputs.platforms, 'linux x32') || (github.event.inputs.platforms == '' && (secrets.JDK_SUBMIT_PLATFORMS == '' || contains(secrets.JDK_SUBMIT_PLATFORMS, 'linux x32'))) }}\"\n+          echo \"::set-output name=platform_linux_x86::${{ contains(github.event.inputs.platforms, 'linux x86') || (github.event.inputs.platforms == '' && (secrets.JDK_SUBMIT_PLATFORMS == '' || contains(secrets.JDK_SUBMIT_PLATFORMS, 'linux x86'))) }}\"\n@@ -42,0 +42,1 @@\n+        id: check_bundle_id\n@@ -353,1 +354,29 @@\n-      - name: Persist test logs\n+      - name: Package test results\n+        if: always()\n+        working-directory: build\/run-test-prebuilt\/test-results\/\n+        run: >\n+          zip -r9\n+          \"$HOME\/linux-x64${{ matrix.artifact }}_testresults_${{ env.logsuffix }}.zip\"\n+          .\n+        continue-on-error: true\n+\n+      - name: Package test support\n+        if: always()\n+        working-directory: build\/run-test-prebuilt\/test-support\/\n+        run: >\n+          zip -r9\n+          \"$HOME\/linux-x64${{ matrix.artifact }}_testsupport_${{ env.logsuffix }}.zip\"\n+          .\n+          -i *.jtr\n+          -i hs_err*\n+          -i replay*\n+        continue-on-error: true\n+\n+      - name: Persist test results\n+        if: always()\n+        uses: actions\/upload-artifact@v2\n+        with:\n+          path: ~\/linux-x64${{ matrix.artifact }}_testresults_${{ env.logsuffix }}.zip\n+        continue-on-error: true\n+\n+      - name: Persist test outputs\n@@ -357,2 +386,1 @@\n-          name: linux-x64${{ matrix.artifact }}_testlogs_${{ env.logsuffix }}\n-          path: build\/*\/test-results\n+          path: ~\/linux-x64${{ matrix.artifact }}_testsupport_${{ env.logsuffix }}.zip\n@@ -361,2 +389,2 @@\n-  linux_x32_build:\n-    name: Linux x32\n+  linux_x86_build:\n+    name: Linux x86\n@@ -365,1 +393,1 @@\n-    if: needs.prerequisites.outputs.should_run != 'false' && needs.prerequisites.outputs.platform_linux_x32 != 'false'\n+    if: needs.prerequisites.outputs.should_run != 'false' && needs.prerequisites.outputs.platform_linux_x86 != 'false'\n@@ -371,0 +399,1 @@\n+          - build release\n@@ -441,1 +470,1 @@\n-          --with-conf-name=linux-x32\n+          --with-conf-name=linux-x86\n@@ -455,1 +484,1 @@\n-        run: make CONF_NAME=linux-x32 ${{ matrix.build-target }}\n+        run: make CONF_NAME=linux-x86 ${{ matrix.build-target }}\n@@ -458,0 +487,189 @@\n+      - name: Persist test bundles\n+        uses: actions\/upload-artifact@v2\n+        with:\n+          name: transient_jdk-linux-x86${{ matrix.artifact }}_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: |\n+            jdk\/build\/linux-x86\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x86_bin${{ matrix.artifact }}.tar.gz\n+            jdk\/build\/linux-x86\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x86_bin-tests${{ matrix.artifact }}.tar.gz\n+        if: matrix.build-target == false\n+\n+  linux_x86_test:\n+    name: Linux x86\n+    runs-on: \"ubuntu-latest\"\n+    needs:\n+      - prerequisites\n+      - linux_x86_build\n+\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        test:\n+          - jdk\/tier1 part 1\n+          - jdk\/tier1 part 2\n+          - jdk\/tier1 part 3\n+          - langtools\/tier1\n+          - hs\/tier1 common\n+          - hs\/tier1 compiler\n+          - hs\/tier1 gc\n+          - hs\/tier1 runtime\n+          - hs\/tier1 serviceability\n+        include:\n+          - test: jdk\/tier1 part 1\n+            suites: test\/jdk\/:tier1_part1\n+          - test: jdk\/tier1 part 2\n+            suites: test\/jdk\/:tier1_part2\n+          - test: jdk\/tier1 part 3\n+            suites: test\/jdk\/:tier1_part3\n+          - test: langtools\/tier1\n+            suites: test\/langtools\/:tier1\n+          - test: hs\/tier1 common\n+            suites: test\/hotspot\/jtreg\/:tier1_common\n+            artifact: -debug\n+          - test: hs\/tier1 compiler\n+            suites: test\/hotspot\/jtreg\/:tier1_compiler\n+            artifact: -debug\n+          - test: hs\/tier1 gc\n+            suites: test\/hotspot\/jtreg\/:tier1_gc\n+            artifact: -debug\n+          - test: hs\/tier1 runtime\n+            suites: test\/hotspot\/jtreg\/:tier1_runtime\n+            artifact: -debug\n+          - test: hs\/tier1 serviceability\n+            suites: test\/hotspot\/jtreg\/:tier1_serviceability\n+            artifact: -debug\n+\n+    # Reduced 32-bit build uses the same boot JDK as 64-bit build\n+    env:\n+      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}\"\n+      BOOT_JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).BOOT_JDK_VERSION }}\"\n+      BOOT_JDK_FILENAME: \"${{ fromJson(needs.prerequisites.outputs.dependencies).LINUX_X64_BOOT_JDK_FILENAME }}\"\n+      BOOT_JDK_URL: \"${{ fromJson(needs.prerequisites.outputs.dependencies).LINUX_X64_BOOT_JDK_URL }}\"\n+      BOOT_JDK_SHA256: \"${{ fromJson(needs.prerequisites.outputs.dependencies).LINUX_X64_BOOT_JDK_SHA256 }}\"\n+\n+    steps:\n+      - name: Checkout the source\n+        uses: actions\/checkout@v2\n+\n+      - name: Restore boot JDK from cache\n+        id: bootjdk\n+        uses: actions\/cache@v2\n+        with:\n+          path: ~\/bootjdk\/${{ env.BOOT_JDK_VERSION }}\n+          key: bootjdk-${{ runner.os }}-${{ env.BOOT_JDK_VERSION }}-${{ env.BOOT_JDK_SHA256 }}-v1\n+\n+      - name: Download boot JDK\n+        run: |\n+          mkdir -p \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\"\n+          wget -O \"${HOME}\/bootjdk\/${BOOT_JDK_FILENAME}\" \"${BOOT_JDK_URL}\"\n+          echo \"${BOOT_JDK_SHA256} ${HOME}\/bootjdk\/${BOOT_JDK_FILENAME}\" | sha256sum -c >\/dev\/null -\n+          tar -xf \"${HOME}\/bootjdk\/${BOOT_JDK_FILENAME}\" -C \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\"\n+          mv \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\/\"*\/* \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\/\"\n+        if: steps.bootjdk.outputs.cache-hit != 'true'\n+\n+      - name: Restore jtreg artifact\n+        id: jtreg_restore\n+        uses: actions\/download-artifact@v2\n+        with:\n+          name: transient_jtreg_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jtreg\/\n+        continue-on-error: true\n+\n+      - name: Restore jtreg artifact (retry)\n+        uses: actions\/download-artifact@v2\n+        with:\n+          name: transient_jtreg_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jtreg\/\n+        if: steps.jtreg_restore.outcome == 'failure'\n+\n+      - name: Restore build artifacts\n+        id: build_restore\n+        uses: actions\/download-artifact@v2\n+        with:\n+          name: transient_jdk-linux-x86${{ matrix.artifact }}_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jdk-linux-x86${{ matrix.artifact }}\n+        continue-on-error: true\n+\n+      - name: Restore build artifacts (retry)\n+        uses: actions\/download-artifact@v2\n+        with:\n+          name: transient_jdk-linux-x86${{ matrix.artifact }}_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jdk-linux-x86${{ matrix.artifact }}\n+        if: steps.build_restore.outcome == 'failure'\n+\n+      - name: Unpack jdk\n+        run: |\n+          mkdir -p \"${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x86_bin${{ matrix.artifact }}\"\n+          tar -xf \"${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x86_bin${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x86_bin${{ matrix.artifact }}\"\n+\n+      - name: Unpack tests\n+        run: |\n+          mkdir -p \"${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x86_bin-tests${{ matrix.artifact }}\"\n+          tar -xf \"${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x86_bin-tests${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x86_bin-tests${{ matrix.artifact }}\"\n+\n+      - name: Find root of jdk image dir\n+        run: |\n+          imageroot=`find ${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x86_bin${{ matrix.artifact }} -name release -type f`\n+          echo \"imageroot=`dirname ${imageroot}`\" >> $GITHUB_ENV\n+\n+      - name: Run tests\n+        run: >\n+          JDK_IMAGE_DIR=${{ env.imageroot }}\n+          TEST_IMAGE_DIR=${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x86_bin-tests${{ matrix.artifact }}\n+          BOOT_JDK=${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\n+          JT_HOME=${HOME}\/jtreg\n+          make test-prebuilt\n+          CONF_NAME=run-test-prebuilt\n+          LOG_CMDLINES=true\n+          JTREG_VERBOSE=fail,error,time\n+          TEST=\"${{ matrix.suites }}\"\n+          TEST_OPTS_JAVA_OPTIONS=\n+          JTREG_KEYWORDS=\"!headful\"\n+          JTREG=\"JAVA_OPTIONS=-XX:-CreateCoredumpOnCrash\"\n+\n+      - name: Check that all tests executed successfully\n+        if: always()\n+        run: >\n+          if ! grep --include=test-summary.txt -lqr build\/*\/test-results -e \"TEST SUCCESS\" ; then\n+            cat build\/*\/test-results\/*\/text\/newfailures.txt ;\n+            exit 1 ;\n+          fi\n+\n+      - name: Create suitable test log artifact name\n+        if: always()\n+        run: echo \"logsuffix=`echo ${{ matrix.test }} | sed -e 's!\/!_!'g -e 's! !_!'g`\" >> $GITHUB_ENV\n+\n+      - name: Package test results\n+        if: always()\n+        working-directory: build\/run-test-prebuilt\/test-results\/\n+        run: >\n+          zip -r9\n+          \"$HOME\/linux-x86${{ matrix.artifact }}_testresults_${{ env.logsuffix }}.zip\"\n+          .\n+        continue-on-error: true\n+\n+      - name: Package test support\n+        if: always()\n+        working-directory: build\/run-test-prebuilt\/test-support\/\n+        run: >\n+          zip -r9\n+          \"$HOME\/linux-x86${{ matrix.artifact }}_testsupport_${{ env.logsuffix }}.zip\"\n+          .\n+          -i *.jtr\n+          -i hs_err*\n+          -i replay*\n+        continue-on-error: true\n+\n+      - name: Persist test results\n+        if: always()\n+        uses: actions\/upload-artifact@v2\n+        with:\n+          path: ~\/linux-x86${{ matrix.artifact }}_testresults_${{ env.logsuffix }}.zip\n+        continue-on-error: true\n+\n+      - name: Persist test outputs\n+        if: always()\n+        uses: actions\/upload-artifact@v2\n+        with:\n+          path: ~\/linux-x86${{ matrix.artifact }}_testsupport_${{ env.logsuffix }}.zip\n+        continue-on-error: true\n+\n@@ -737,1 +955,31 @@\n-      - name: Persist test logs\n+      - name: Package test results\n+        if: always()\n+        working-directory: build\/run-test-prebuilt\/test-results\/\n+        run: >\n+          $env:Path = \"$HOME\\cygwin\\cygwin64\\bin;$env:Path\" ;\n+          zip -r9\n+          \"$HOME\/windows-x64${{ matrix.artifact }}_testresults_${{ env.logsuffix }}.zip\"\n+          .\n+        continue-on-error: true\n+\n+      - name: Package test support\n+        if: always()\n+        working-directory: build\/run-test-prebuilt\/test-support\/\n+        run: >\n+          $env:Path = \"$HOME\\cygwin\\cygwin64\\bin;$env:Path\" ;\n+          zip -r9\n+          \"$HOME\/windows-x64${{ matrix.artifact }}_testsupport_${{ env.logsuffix }}.zip\"\n+          .\n+          -i *.jtr\n+          -i hs_err*\n+          -i replay*\n+        continue-on-error: true\n+\n+      - name: Persist test results\n+        if: always()\n+        uses: actions\/upload-artifact@v2\n+        with:\n+          path: ~\/windows-x64${{ matrix.artifact }}_testresults_${{ env.logsuffix }}.zip\n+        continue-on-error: true\n+\n+      - name: Persist test outputs\n@@ -741,2 +989,1 @@\n-          name: windows-x64${{ matrix.artifact }}_testlogs_${{ env.logsuffix }}\n-          path: build\/*\/test-results\n+          path: ~\/windows-x64${{ matrix.artifact }}_testsupport_${{ env.logsuffix }}.zip\n@@ -992,1 +1239,22 @@\n-      - name: Persist test logs\n+      - name: Package test results\n+        if: always()\n+        working-directory: build\/run-test-prebuilt\/test-results\/\n+        run: >\n+          zip -r9\n+          \"$HOME\/macos-x64${{ matrix.artifact }}_testresults_${{ env.logsuffix }}.zip\"\n+          .\n+        continue-on-error: true\n+\n+      - name: Package test support\n+        if: always()\n+        working-directory: build\/run-test-prebuilt\/test-support\/\n+        run: >\n+          zip -r9\n+          \"$HOME\/macos-x64${{ matrix.artifact }}_testsupport_${{ env.logsuffix }}.zip\"\n+          .\n+          -i *.jtr\n+          -i hs_err*\n+          -i replay*\n+        continue-on-error: true\n+\n+      - name: Persist test results\n@@ -996,2 +1264,8 @@\n-          name: macos-x64${{ matrix.artifact }}_testlogs_${{ env.logsuffix }}\n-          path: build\/*\/test-results\n+          path: ~\/macos-x64${{ matrix.artifact }}_testresults_${{ env.logsuffix }}.zip\n+        continue-on-error: true\n+\n+      - name: Persist test outputs\n+        if: always()\n+        uses: actions\/upload-artifact@v2\n+        with:\n+          path: ~\/macos-x64${{ matrix.artifact }}_testsupport_${{ env.logsuffix }}.zip\n@@ -1006,0 +1280,1 @@\n+      - prerequisites\n@@ -1007,0 +1282,1 @@\n+      - linux_x86_test\n","filename":".github\/workflows\/submit.yml","additions":293,"deletions":17,"binary":false,"changes":310,"status":"modified"},{"patch":"@@ -762,1 +762,0 @@\n-ENABLE_INTREE_EC:=@ENABLE_INTREE_EC@\n","filename":"make\/autoconf\/spec.gmk.in","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -185,4 +185,2 @@\n-$(eval $(call SetupCopyFiles, COPY_NET_PROPERTIES, \\\n-    FILES := $(TOPDIR)\/src\/java.base\/share\/conf\/net.properties, \\\n-    DEST := $(CONF_DST_DIR), \\\n-))\n+NET_PROPERTIES_SRCS := $(TOPDIR)\/src\/java.base\/share\/conf\/net.properties \\\n+\t$(TOPDIR)\/src\/java.base\/$(OPENJDK_TARGET_OS_TYPE)\/conf\/net.properties\n@@ -190,1 +188,7 @@\n-TARGETS += $(COPY_NET_PROPERTIES)\n+NET_PROPERTIES_DST  := $(CONF_DST_DIR)\/net.properties\n+\n+$(NET_PROPERTIES_DST): $(NET_PROPERTIES_SRCS)\n+\t$(call MakeTargetDir)\n+\t$(CAT) $(NET_PROPERTIES_SRCS) > $@\n+\n+TARGETS += $(NET_PROPERTIES_DST)\n","filename":"make\/modules\/java.base\/Copy.gmk","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1,49 +0,0 @@\n-#\n-# Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-include LibCommon.gmk\n-\n-################################################################################\n-\n-ifeq ($(ENABLE_INTREE_EC), true)\n-  $(eval $(call SetupJdkLibrary, BUILD_LIBSUNEC, \\\n-      NAME := sunec, \\\n-      TOOLCHAIN := TOOLCHAIN_LINK_CXX, \\\n-      OPTIMIZATION := LOW, \\\n-      CFLAGS := $(CFLAGS_JDKLIB) \\\n-          -DMP_API_COMPATIBLE -DNSS_ECC_MORE_THAN_SUITE_B, \\\n-      CXXFLAGS := $(CXXFLAGS_JDKLIB), \\\n-      DISABLED_WARNINGS_gcc := sign-compare implicit-fallthrough unused-value, \\\n-      DISABLED_WARNINGS_clang := sign-compare, \\\n-      DISABLED_WARNINGS_microsoft := 4101 4244 4146 4018, \\\n-      LDFLAGS := $(LDFLAGS_JDKLIB) $(LDFLAGS_CXX_JDK), \\\n-      LDFLAGS_macosx := $(call SET_SHARED_LIBRARY_ORIGIN), \\\n-      LIBS := $(LIBCXX), \\\n-  ))\n-\n-  TARGETS += $(BUILD_LIBSUNEC)\n-endif\n-\n-################################################################################\n","filename":"make\/modules\/jdk.crypto.ec\/Lib.gmk","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -93,1 +93,1 @@\n-    DISABLED_WARNINGS := processing rawtypes cast serial preview, \\\n+    DISABLED_WARNINGS := processing rawtypes cast serial, \\\n@@ -97,1 +97,0 @@\n-    JAVAC_FLAGS := --enable-preview, \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1332,1 +1332,1 @@\n-  match(Set dst (RShiftVB src shift));\n+  match(Set dst (RShiftVB src (RShiftCntV shift)));\n@@ -1351,1 +1351,1 @@\n-  match(Set dst (RShiftVS src shift));\n+  match(Set dst (RShiftVS src (RShiftCntV shift)));\n@@ -1370,1 +1370,1 @@\n-  match(Set dst (RShiftVI src shift));\n+  match(Set dst (RShiftVI src (RShiftCntV shift)));\n@@ -1388,1 +1388,1 @@\n-  match(Set dst (RShiftVL src shift));\n+  match(Set dst (RShiftVL src (RShiftCntV shift)));\n@@ -1406,1 +1406,1 @@\n-  match(Set dst (URShiftVB src shift));\n+  match(Set dst (URShiftVB src (RShiftCntV shift)));\n@@ -1429,1 +1429,1 @@\n-  match(Set dst (URShiftVS src shift));\n+  match(Set dst (URShiftVS src (RShiftCntV shift)));\n@@ -1439,1 +1439,1 @@\n-    if (con >= 8) {\n+    if (con >= 16) {\n@@ -1452,1 +1452,1 @@\n-  match(Set dst (URShiftVI src shift));\n+  match(Set dst (URShiftVI src (RShiftCntV shift)));\n@@ -1470,1 +1470,1 @@\n-  match(Set dst (URShiftVL src shift));\n+  match(Set dst (URShiftVL src (RShiftCntV shift)));\n@@ -1488,1 +1488,1 @@\n-  match(Set dst (LShiftVB src shift));\n+  match(Set dst (LShiftVB src (LShiftCntV shift)));\n@@ -1506,1 +1506,1 @@\n-  match(Set dst (LShiftVS src shift));\n+  match(Set dst (LShiftVS src (LShiftCntV shift)));\n@@ -1511,1 +1511,1 @@\n-    if (con >= 8) {\n+    if (con >= 16) {\n@@ -1524,1 +1524,1 @@\n-  match(Set dst (LShiftVI src shift));\n+  match(Set dst (LShiftVI src (LShiftCntV shift)));\n@@ -1537,1 +1537,1 @@\n-  match(Set dst (LShiftVL src shift));\n+  match(Set dst (LShiftVL src (LShiftCntV shift)));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -730,2 +730,2 @@\n-dnl VSHIFT_IMM_UNPREDICATE($1,        $2,      $3,   $4,          $5  )\n-dnl VSHIFT_IMM_UNPREDICATE(insn_name, op_name, size, min_vec_len, insn)\n+dnl VSHIFT_IMM_UNPREDICATE($1,        $2,      $3,       $4,   $5,          $6  )\n+dnl VSHIFT_IMM_UNPREDICATE(insn_name, op_name, op_name2, size, min_vec_len, insn)\n@@ -734,2 +734,2 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= $4);\n-  match(Set dst ($2 src shift));\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= $5);\n+  match(Set dst ($2 src ($3 shift)));\n@@ -737,1 +737,1 @@\n-  format %{ \"$5 $dst, $src, $shift\\t# vector (sve) ($3)\" %}\n+  format %{ \"$6 $dst, $src, $shift\\t# vector (sve) ($4)\" %}\n@@ -746,2 +746,2 @@\n-ifelse(eval(index(`$1', `vasr') == 0), 1, `ifelse(eval(index(`$3', `B') == 0), 1, `\n-    if (con >= 8) con = 7;')ifelse(eval(index(`$3', `H') == 0), 1, `\n+ifelse(eval(index(`$1', `vasr') == 0), 1, `ifelse(eval(index(`$4', `B') == 0), 1, `\n+    if (con >= 8) con = 7;')ifelse(eval(index(`$4', `H') == 0), 1, `\n@@ -749,1 +749,1 @@\n-ifelse(eval((index(`$1', `vlsl') == 0 || index(`$1', `vlsr') == 0) && (index(`$3', `B') == 0 || index(`$3', `H') == 0)), 1, `\n+ifelse(eval(index(`$1', `vlsl') == 0  || index(`$1', `vlsr') == 0), 1, `ifelse(eval(index(`$4', `B') == 0), 1, `\n@@ -754,2 +754,7 @@\n-    }')\n-    __ $5(as_FloatRegister($dst$$reg), __ $3,\n+    }')ifelse(eval(index(`$4', `H') == 0), 1, `\n+    if (con >= 16) {\n+      __ sve_eor(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }')')\n+    __ $6(as_FloatRegister($dst$$reg), __ $4,\n@@ -789,12 +794,12 @@\n-VSHIFT_IMM_UNPREDICATE(vasrB_imm, RShiftVB,  B, 16, sve_asr)\n-VSHIFT_IMM_UNPREDICATE(vasrS_imm, RShiftVS,  H,  8, sve_asr)\n-VSHIFT_IMM_UNPREDICATE(vasrI_imm, RShiftVI,  S,  4, sve_asr)\n-VSHIFT_IMM_UNPREDICATE(vasrL_imm, RShiftVL,  D,  2, sve_asr)\n-VSHIFT_IMM_UNPREDICATE(vlsrB_imm, URShiftVB, B, 16, sve_lsr)\n-VSHIFT_IMM_UNPREDICATE(vlsrS_imm, URShiftVS, H,  8, sve_lsr)\n-VSHIFT_IMM_UNPREDICATE(vlsrI_imm, URShiftVI, S,  4, sve_lsr)\n-VSHIFT_IMM_UNPREDICATE(vlsrL_imm, URShiftVL, D,  2, sve_lsr)\n-VSHIFT_IMM_UNPREDICATE(vlslB_imm, LShiftVB,  B, 16, sve_lsl)\n-VSHIFT_IMM_UNPREDICATE(vlslS_imm, LShiftVS,  H,  8, sve_lsl)\n-VSHIFT_IMM_UNPREDICATE(vlslI_imm, LShiftVI,  S,  4, sve_lsl)\n-VSHIFT_IMM_UNPREDICATE(vlslL_imm, LShiftVL,  D,  2, sve_lsl)\n+VSHIFT_IMM_UNPREDICATE(vasrB_imm, RShiftVB,  RShiftCntV, B, 16, sve_asr)\n+VSHIFT_IMM_UNPREDICATE(vasrS_imm, RShiftVS,  RShiftCntV, H,  8, sve_asr)\n+VSHIFT_IMM_UNPREDICATE(vasrI_imm, RShiftVI,  RShiftCntV, S,  4, sve_asr)\n+VSHIFT_IMM_UNPREDICATE(vasrL_imm, RShiftVL,  RShiftCntV, D,  2, sve_asr)\n+VSHIFT_IMM_UNPREDICATE(vlsrB_imm, URShiftVB, RShiftCntV, B, 16, sve_lsr)\n+VSHIFT_IMM_UNPREDICATE(vlsrS_imm, URShiftVS, RShiftCntV, H,  8, sve_lsr)\n+VSHIFT_IMM_UNPREDICATE(vlsrI_imm, URShiftVI, RShiftCntV, S,  4, sve_lsr)\n+VSHIFT_IMM_UNPREDICATE(vlsrL_imm, URShiftVL, RShiftCntV, D,  2, sve_lsr)\n+VSHIFT_IMM_UNPREDICATE(vlslB_imm, LShiftVB,  LShiftCntV, B, 16, sve_lsl)\n+VSHIFT_IMM_UNPREDICATE(vlslS_imm, LShiftVS,  LShiftCntV, H,  8, sve_lsl)\n+VSHIFT_IMM_UNPREDICATE(vlslI_imm, LShiftVI,  LShiftCntV, S,  4, sve_lsl)\n+VSHIFT_IMM_UNPREDICATE(vlslL_imm, LShiftVL,  LShiftCntV, D,  2, sve_lsl)\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":27,"deletions":22,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -96,0 +96,2 @@\n+  product(bool, UseSIMDForBigIntegerShiftIntrinsics, true,              \\\n+          \"Use SIMD instructions for left\/right shift of BigInteger\")   \\\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -554,1 +554,3 @@\n-  call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind));\n+  set_last_Java_frame(esp, rfp, (address)pc(), rscratch1);\n+  super_call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind), rthread);\n+  reset_last_Java_frame(true);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3971,0 +3971,232 @@\n+  \/\/ Arguments:\n+  \/\/\n+  \/\/ Input:\n+  \/\/   c_rarg0   - newArr address\n+  \/\/   c_rarg1   - oldArr address\n+  \/\/   c_rarg2   - newIdx\n+  \/\/   c_rarg3   - shiftCount\n+  \/\/   c_rarg4   - numIter\n+  \/\/\n+  address generate_bigIntegerRightShift() {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this,  \"StubRoutines\", \"bigIntegerRightShiftWorker\");\n+    address start = __ pc();\n+\n+    Label ShiftSIMDLoop, ShiftTwoLoop, ShiftThree, ShiftTwo, ShiftOne, Exit;\n+\n+    Register newArr        = c_rarg0;\n+    Register oldArr        = c_rarg1;\n+    Register newIdx        = c_rarg2;\n+    Register shiftCount    = c_rarg3;\n+    Register numIter       = c_rarg4;\n+    Register idx           = numIter;\n+\n+    Register newArrCur     = rscratch1;\n+    Register shiftRevCount = rscratch2;\n+    Register oldArrCur     = r13;\n+    Register oldArrNext    = r14;\n+\n+    FloatRegister oldElem0        = v0;\n+    FloatRegister oldElem1        = v1;\n+    FloatRegister newElem         = v2;\n+    FloatRegister shiftVCount     = v3;\n+    FloatRegister shiftVRevCount  = v4;\n+\n+    __ cbz(idx, Exit);\n+\n+    __ add(newArr, newArr, newIdx, Assembler::LSL, 2);\n+\n+    \/\/ left shift count\n+    __ movw(shiftRevCount, 32);\n+    __ subw(shiftRevCount, shiftRevCount, shiftCount);\n+\n+    \/\/ numIter too small to allow a 4-words SIMD loop, rolling back\n+    __ cmp(numIter, (u1)4);\n+    __ br(Assembler::LT, ShiftThree);\n+\n+    __ dup(shiftVCount,    __ T4S, shiftCount);\n+    __ dup(shiftVRevCount, __ T4S, shiftRevCount);\n+    __ negr(shiftVCount,   __ T4S, shiftVCount);\n+\n+    __ BIND(ShiftSIMDLoop);\n+\n+    \/\/ Calculate the load addresses\n+    __ sub(idx, idx, 4);\n+    __ add(oldArrNext, oldArr, idx, Assembler::LSL, 2);\n+    __ add(newArrCur,  newArr, idx, Assembler::LSL, 2);\n+    __ add(oldArrCur,  oldArrNext, 4);\n+\n+    \/\/ Load 4 words and process\n+    __ ld1(oldElem0,  __ T4S,  Address(oldArrCur));\n+    __ ld1(oldElem1,  __ T4S,  Address(oldArrNext));\n+    __ ushl(oldElem0, __ T4S,  oldElem0, shiftVCount);\n+    __ ushl(oldElem1, __ T4S,  oldElem1, shiftVRevCount);\n+    __ orr(newElem,   __ T16B, oldElem0, oldElem1);\n+    __ st1(newElem,   __ T4S,  Address(newArrCur));\n+\n+    __ cmp(idx, (u1)4);\n+    __ br(Assembler::LT, ShiftTwoLoop);\n+    __ b(ShiftSIMDLoop);\n+\n+    __ BIND(ShiftTwoLoop);\n+    __ cbz(idx, Exit);\n+    __ cmp(idx, (u1)1);\n+    __ br(Assembler::EQ, ShiftOne);\n+\n+    \/\/ Calculate the load addresses\n+    __ sub(idx, idx, 2);\n+    __ add(oldArrNext, oldArr, idx, Assembler::LSL, 2);\n+    __ add(newArrCur,  newArr, idx, Assembler::LSL, 2);\n+    __ add(oldArrCur,  oldArrNext, 4);\n+\n+    \/\/ Load 2 words and process\n+    __ ld1(oldElem0,  __ T2S, Address(oldArrCur));\n+    __ ld1(oldElem1,  __ T2S, Address(oldArrNext));\n+    __ ushl(oldElem0, __ T2S, oldElem0, shiftVCount);\n+    __ ushl(oldElem1, __ T2S, oldElem1, shiftVRevCount);\n+    __ orr(newElem,   __ T8B, oldElem0, oldElem1);\n+    __ st1(newElem,   __ T2S, Address(newArrCur));\n+    __ b(ShiftTwoLoop);\n+\n+    __ BIND(ShiftThree);\n+    __ tbz(idx, 1, ShiftOne);\n+    __ tbz(idx, 0, ShiftTwo);\n+    __ ldrw(r10,  Address(oldArr, 12));\n+    __ ldrw(r11,  Address(oldArr, 8));\n+    __ lsrvw(r10, r10, shiftCount);\n+    __ lslvw(r11, r11, shiftRevCount);\n+    __ orrw(r12,  r10, r11);\n+    __ strw(r12,  Address(newArr, 8));\n+\n+    __ BIND(ShiftTwo);\n+    __ ldrw(r10,  Address(oldArr, 8));\n+    __ ldrw(r11,  Address(oldArr, 4));\n+    __ lsrvw(r10, r10, shiftCount);\n+    __ lslvw(r11, r11, shiftRevCount);\n+    __ orrw(r12,  r10, r11);\n+    __ strw(r12,  Address(newArr, 4));\n+\n+    __ BIND(ShiftOne);\n+    __ ldrw(r10,  Address(oldArr, 4));\n+    __ ldrw(r11,  Address(oldArr));\n+    __ lsrvw(r10, r10, shiftCount);\n+    __ lslvw(r11, r11, shiftRevCount);\n+    __ orrw(r12,  r10, r11);\n+    __ strw(r12,  Address(newArr));\n+\n+    __ BIND(Exit);\n+    __ ret(lr);\n+\n+    return start;\n+  }\n+\n+  \/\/ Arguments:\n+  \/\/\n+  \/\/ Input:\n+  \/\/   c_rarg0   - newArr address\n+  \/\/   c_rarg1   - oldArr address\n+  \/\/   c_rarg2   - newIdx\n+  \/\/   c_rarg3   - shiftCount\n+  \/\/   c_rarg4   - numIter\n+  \/\/\n+  address generate_bigIntegerLeftShift() {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this,  \"StubRoutines\", \"bigIntegerLeftShiftWorker\");\n+    address start = __ pc();\n+\n+    Label ShiftSIMDLoop, ShiftTwoLoop, ShiftThree, ShiftTwo, ShiftOne, Exit;\n+\n+    Register newArr        = c_rarg0;\n+    Register oldArr        = c_rarg1;\n+    Register newIdx        = c_rarg2;\n+    Register shiftCount    = c_rarg3;\n+    Register numIter       = c_rarg4;\n+\n+    Register shiftRevCount = rscratch1;\n+    Register oldArrNext    = rscratch2;\n+\n+    FloatRegister oldElem0        = v0;\n+    FloatRegister oldElem1        = v1;\n+    FloatRegister newElem         = v2;\n+    FloatRegister shiftVCount     = v3;\n+    FloatRegister shiftVRevCount  = v4;\n+\n+    __ cbz(numIter, Exit);\n+\n+    __ add(oldArrNext, oldArr, 4);\n+    __ add(newArr, newArr, newIdx, Assembler::LSL, 2);\n+\n+    \/\/ right shift count\n+    __ movw(shiftRevCount, 32);\n+    __ subw(shiftRevCount, shiftRevCount, shiftCount);\n+\n+    \/\/ numIter too small to allow a 4-words SIMD loop, rolling back\n+    __ cmp(numIter, (u1)4);\n+    __ br(Assembler::LT, ShiftThree);\n+\n+    __ dup(shiftVCount,     __ T4S, shiftCount);\n+    __ dup(shiftVRevCount,  __ T4S, shiftRevCount);\n+    __ negr(shiftVRevCount, __ T4S, shiftVRevCount);\n+\n+    __ BIND(ShiftSIMDLoop);\n+\n+    \/\/ load 4 words and process\n+    __ ld1(oldElem0,  __ T4S,  __ post(oldArr, 16));\n+    __ ld1(oldElem1,  __ T4S,  __ post(oldArrNext, 16));\n+    __ ushl(oldElem0, __ T4S,  oldElem0, shiftVCount);\n+    __ ushl(oldElem1, __ T4S,  oldElem1, shiftVRevCount);\n+    __ orr(newElem,   __ T16B, oldElem0, oldElem1);\n+    __ st1(newElem,   __ T4S,  __ post(newArr, 16));\n+    __ sub(numIter,   numIter, 4);\n+\n+    __ cmp(numIter, (u1)4);\n+    __ br(Assembler::LT, ShiftTwoLoop);\n+    __ b(ShiftSIMDLoop);\n+\n+    __ BIND(ShiftTwoLoop);\n+    __ cbz(numIter, Exit);\n+    __ cmp(numIter, (u1)1);\n+    __ br(Assembler::EQ, ShiftOne);\n+\n+    \/\/ load 2 words and process\n+    __ ld1(oldElem0,  __ T2S,  __ post(oldArr, 8));\n+    __ ld1(oldElem1,  __ T2S,  __ post(oldArrNext, 8));\n+    __ ushl(oldElem0, __ T2S,  oldElem0, shiftVCount);\n+    __ ushl(oldElem1, __ T2S,  oldElem1, shiftVRevCount);\n+    __ orr(newElem,   __ T8B,  oldElem0, oldElem1);\n+    __ st1(newElem,   __ T2S,  __ post(newArr, 8));\n+    __ sub(numIter,   numIter, 2);\n+    __ b(ShiftTwoLoop);\n+\n+    __ BIND(ShiftThree);\n+    __ ldrw(r10,  __ post(oldArr, 4));\n+    __ ldrw(r11,  __ post(oldArrNext, 4));\n+    __ lslvw(r10, r10, shiftCount);\n+    __ lsrvw(r11, r11, shiftRevCount);\n+    __ orrw(r12,  r10, r11);\n+    __ strw(r12,  __ post(newArr, 4));\n+    __ tbz(numIter, 1, Exit);\n+    __ tbz(numIter, 0, ShiftOne);\n+\n+    __ BIND(ShiftTwo);\n+    __ ldrw(r10,  __ post(oldArr, 4));\n+    __ ldrw(r11,  __ post(oldArrNext, 4));\n+    __ lslvw(r10, r10, shiftCount);\n+    __ lsrvw(r11, r11, shiftRevCount);\n+    __ orrw(r12,  r10, r11);\n+    __ strw(r12,  __ post(newArr, 4));\n+\n+    __ BIND(ShiftOne);\n+    __ ldrw(r10,  Address(oldArr));\n+    __ ldrw(r11,  Address(oldArrNext));\n+    __ lslvw(r10, r10, shiftCount);\n+    __ lsrvw(r11, r11, shiftRevCount);\n+    __ orrw(r12,  r10, r11);\n+    __ strw(r12,  Address(newArr));\n+\n+    __ BIND(Exit);\n+    __ ret(lr);\n+\n+    return start;\n+  }\n+\n@@ -6227,0 +6459,5 @@\n+    if (UseSIMDForBigIntegerShiftIntrinsics) {\n+      StubRoutines::_bigIntegerRightShiftWorker = generate_bigIntegerRightShift();\n+      StubRoutines::_bigIntegerLeftShiftWorker  = generate_bigIntegerLeftShift();\n+    }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":237,"deletions":0,"binary":false,"changes":237,"status":"modified"},{"patch":"@@ -404,1 +404,1 @@\n-      int new_vl = set_and_get_current_sve_vector_lenght(MaxVectorSize);\n+      int new_vl = set_and_get_current_sve_vector_length(MaxVectorSize);\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-  static int set_and_get_current_sve_vector_lenght(int len);\n+  static int set_and_get_current_sve_vector_length(int len);\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -839,1 +839,1 @@\n-    Disassembler::decode(&cbuf, code, code_end, tty);\n+    Disassembler::decode(code, code_end, tty);\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -9806,1 +9806,1 @@\n-  emit_int16(get_prefixq(dst, src), 0x3B);\n+  emit_int16(get_prefixq(dst, src), 0x39);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -608,0 +608,4 @@\n+void InterpreterMacroAssembler::push_i_or_ptr(Register r) {\n+  push(r);\n+}\n+\n@@ -1002,2 +1006,2 @@\n-  call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind));\n-  pop(state);\n+  set_last_Java_frame(rthread, noreg, rbp, (address)pc());\n+  super_call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind), rthread);\n@@ -1005,0 +1009,2 @@\n+  reset_last_Java_frame(rthread, true);\n+  pop(state);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -142,0 +142,4 @@\n+\n+  \/\/ On x86, pushing a ptr or an int is semantically identical, but we\n+  \/\/ maintain a distinction for clarity and for making it easier to change\n+  \/\/ semantics in the future\n@@ -145,0 +149,5 @@\n+  \/\/ push_i_or_ptr is provided for when explicitly allowing either a ptr or\n+  \/\/ an int might have some advantage, while still documenting the fact that a\n+  \/\/ ptr might be pushed to the stack.\n+  void push_i_or_ptr(Register r = rax);\n+\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2768,1 +2768,1 @@\n-    cmpq(Address(thread_reg, Thread::polling_word_offset()), in_nmethod ? rsp : rbp);\n+    cmpq(in_nmethod ? rsp : rbp, Address(thread_reg, Thread::polling_word_offset()));\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1764,3 +1764,0 @@\n-  aep = __ pc();     \/\/ atos entry point\n-      __ push_ptr();\n-      __ jmp(L);\n@@ -1785,2 +1782,2 @@\n-  bep = cep = sep = iep = __ pc();      \/\/ [bcsi]tos entry point\n-      __ push_i();\n+  aep = bep = cep = sep = iep = __ pc();      \/\/ [abcsi]tos entry point\n+      __ push_i_or_ptr();\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -4428,2 +4428,1 @@\n-  predicate(vector_element_basic_type(n->in(2)) == T_INT &&\n-            vector_length(n->in(2)) <= 16); \/\/ src2\n+  predicate(vector_element_basic_type(n->in(2)) == T_INT); \/\/ src2\n@@ -4450,3 +4449,2 @@\n-instruct reductionL(rRegL dst, rRegL src1, vec src2, vec vtmp1, vec vtmp2) %{\n-  predicate(vector_element_basic_type(n->in(2)) == T_LONG &&\n-            vector_length(n->in(2)) < 8); \/\/ src2\n+instruct reductionL(rRegL dst, rRegL src1, legVec src2, legVec vtmp1, legVec vtmp2) %{\n+  predicate(vector_element_basic_type(n->in(2)) == T_LONG && !VM_Version::supports_avx512dq());\n@@ -4470,3 +4468,2 @@\n-instruct reduction8L(rRegL dst, rRegL src1, legVec src2, legVec vtmp1, legVec vtmp2) %{\n-  predicate(vector_element_basic_type(n->in(2)) == T_LONG &&\n-            vector_length(n->in(2)) == 8); \/\/ src2\n+instruct reductionL_avx512dq(rRegL dst, rRegL src1, vec src2, vec vtmp1, vec vtmp2) %{\n+  predicate(vector_element_basic_type(n->in(2)) == T_LONG && VM_Version::supports_avx512dq());\n@@ -4582,3 +4579,2 @@\n-instruct reductionB(rRegI dst, rRegI src1, vec src2, vec vtmp1, vec vtmp2) %{\n-  predicate(vector_element_basic_type(n->in(2)) == T_BYTE &&\n-            vector_length(n->in(2)) <= 32); \/\/ src2\n+instruct reductionB(rRegI dst, rRegI src1, legVec src2, legVec vtmp1, legVec vtmp2) %{\n+  predicate(vector_element_basic_type(n->in(2)) == T_BYTE && !VM_Version::supports_avx512bw());\n@@ -4601,3 +4597,2 @@\n-instruct reduction64B(rRegI dst, rRegI src1, legVec src2, legVec vtmp1, legVec vtmp2) %{\n-  predicate(vector_element_basic_type(n->in(2)) == T_BYTE &&\n-            vector_length(n->in(2)) == 64); \/\/ src2\n+instruct reductionB_avx512bw(rRegI dst, rRegI src1, vec src2, vec vtmp1, vec vtmp2) %{\n+  predicate(vector_element_basic_type(n->in(2)) == T_BYTE && VM_Version::supports_avx512bw());\n@@ -4624,2 +4619,1 @@\n-  predicate(vector_element_basic_type(n->in(2)) == T_SHORT &&\n-            vector_length(n->in(2)) <= 32); \/\/ src2\n+  predicate(vector_element_basic_type(n->in(2)) == T_SHORT); \/\/ src2\n@@ -5455,1 +5449,1 @@\n-instruct mul2L_reg(vec dst, vec src2, vec tmp) %{\n+instruct mul2L_reg(vec dst, vec src2, legVec tmp) %{\n@@ -5481,1 +5475,1 @@\n-instruct vmul4L_reg_avx(vec dst, vec src1, vec src2, vec tmp, vec tmp1) %{\n+instruct vmul4L_reg_avx(vec dst, vec src1, vec src2, legVec tmp, legVec tmp1) %{\n@@ -6966,0 +6960,1 @@\n+  format %{ \"extractI $dst,$src,$idx\\t!\" %}\n@@ -6984,0 +6979,1 @@\n+  format %{ \"vextractI $dst,$src,$idx\\t! using $vtmp as TEMP\" %}\n@@ -6998,0 +6994,1 @@\n+  format %{ \"extractL $dst,$src,$idx\\t!\" %}\n@@ -7012,0 +7009,1 @@\n+  format %{ \"vextractL $dst,$src,$idx\\t! using $vtmp as TEMP\" %}\n@@ -7026,0 +7024,1 @@\n+  format %{ \"extractF $dst,$src,$idx\\t! using $tmp, $vtmp as TEMP\" %}\n@@ -7039,0 +7038,1 @@\n+  format %{ \"vextractF $dst,$src,$idx\\t! using $tmp, $vtmp as TEMP\" %}\n@@ -7051,0 +7051,1 @@\n+  format %{ \"extractD $dst,$src,$idx\\t!\" %}\n@@ -7064,0 +7065,1 @@\n+  format %{ \"vextractD $dst,$src,$idx\\t! using $vtmp as TEMP\" %}\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":20,"deletions":18,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2239,1 +2239,1 @@\n-char* os::pd_attempt_reserve_memory_at(char* requested_addr, size_t bytes, int file_desc) {\n+char* os::pd_attempt_map_memory_to_file_at(char* requested_addr, size_t bytes, int file_desc) {\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1908,1 +1908,1 @@\n-char* os::pd_attempt_reserve_memory_at(char* requested_addr, size_t bytes, int file_desc) {\n+char* os::pd_attempt_map_memory_to_file_at(char* requested_addr, size_t bytes, int file_desc) {\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4217,1 +4217,1 @@\n-char* os::pd_attempt_reserve_memory_at(char* requested_addr, size_t bytes, int file_desc) {\n+char* os::pd_attempt_map_memory_to_file_at(char* requested_addr, size_t bytes, int file_desc) {\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -300,4 +300,1 @@\n-\/\/ Multiple threads can race in this code, and can remap over each other with MAP_FIXED,\n-\/\/ so on posix, unmap the section at the start and at the end of the chunk that we mapped\n-\/\/ rather than unmapping and remapping the whole chunk to get requested alignment.\n-char* os::reserve_memory_aligned(size_t size, size_t alignment, int file_desc) {\n+static size_t calculate_aligned_extra_size(size_t size, size_t alignment) {\n@@ -310,0 +307,2 @@\n+  return extra_size;\n+}\n@@ -311,20 +310,2 @@\n-  char* extra_base;\n-  if (file_desc != -1) {\n-    \/\/ For file mapping, we do not call os:reserve_memory_with_fd since:\n-    \/\/ - we later chop away parts of the mapping using os::release_memory and that could fail if the\n-    \/\/   original mmap call had been tied to an fd.\n-    \/\/ - The memory API os::reserve_memory uses is an implementation detail. It may (and usually is)\n-    \/\/   mmap but it also may System V shared memory which cannot be uncommitted as a whole, so\n-    \/\/   chopping off and unmapping excess bits back and front (see below) would not work.\n-    extra_base = reserve_mmapped_memory(extra_size, NULL);\n-    if (extra_base != NULL) {\n-      MemTracker::record_virtual_memory_reserve((address)extra_base, extra_size, CALLER_PC);\n-    }\n-  } else {\n-    extra_base = os::reserve_memory(extra_size);\n-  }\n-\n-  if (extra_base == NULL) {\n-    return NULL;\n-  }\n-\n+\/\/ After a bigger chunk was mapped, unmaps start and end parts to get the requested alignment.\n+static char* chop_extra_memory(size_t size, size_t alignment, char* extra_base, size_t extra_size) {\n@@ -352,6 +333,31 @@\n-  if (file_desc != -1) {\n-    \/\/ After we have an aligned address, we can replace anonymous mapping with file mapping\n-    if (replace_existing_mapping_with_file_mapping(aligned_base, size, file_desc) == NULL) {\n-      vm_exit_during_initialization(err_msg(\"Error in mapping Java heap at the given filesystem directory\"));\n-    }\n-    MemTracker::record_virtual_memory_commit((address)aligned_base, size, CALLER_PC);\n+  return aligned_base;\n+}\n+\n+\/\/ Multiple threads can race in this code, and can remap over each other with MAP_FIXED,\n+\/\/ so on posix, unmap the section at the start and at the end of the chunk that we mapped\n+\/\/ rather than unmapping and remapping the whole chunk to get requested alignment.\n+char* os::reserve_memory_aligned(size_t size, size_t alignment) {\n+  size_t extra_size = calculate_aligned_extra_size(size, alignment);\n+  char* extra_base = os::reserve_memory(extra_size);\n+  if (extra_base == NULL) {\n+    return NULL;\n+  }\n+  return chop_extra_memory(size, alignment, extra_base, extra_size);\n+}\n+\n+char* os::map_memory_to_file_aligned(size_t size, size_t alignment, int file_desc) {\n+  size_t extra_size = calculate_aligned_extra_size(size, alignment);\n+  \/\/ For file mapping, we do not call os:map_memory_to_file(size,fd) since:\n+  \/\/ - we later chop away parts of the mapping using os::release_memory and that could fail if the\n+  \/\/   original mmap call had been tied to an fd.\n+  \/\/ - The memory API os::reserve_memory uses is an implementation detail. It may (and usually is)\n+  \/\/   mmap but it also may System V shared memory which cannot be uncommitted as a whole, so\n+  \/\/   chopping off and unmapping excess bits back and front (see below) would not work.\n+  char* extra_base = reserve_mmapped_memory(extra_size, NULL);\n+  if (extra_base == NULL) {\n+    return NULL;\n+  }\n+  char* aligned_base = chop_extra_memory(size, alignment, extra_base, extra_size);\n+  \/\/ After we have an aligned address, we can replace anonymous mapping with file mapping\n+  if (replace_existing_mapping_with_file_mapping(aligned_base, size, file_desc) == NULL) {\n+    vm_exit_during_initialization(err_msg(\"Error in mapping Java heap at the given filesystem directory\"));\n@@ -359,0 +365,1 @@\n+  MemTracker::record_virtual_memory_commit((address)aligned_base, size, CALLER_PC);\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":37,"deletions":30,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -3140,1 +3140,1 @@\n-char* os::reserve_memory_aligned(size_t size, size_t alignment, int file_desc) {\n+static char* map_or_reserve_memory_aligned(size_t size, size_t alignment, int file_desc) {\n@@ -3151,1 +3151,3 @@\n-    char* extra_base = os::reserve_memory_with_fd(extra_size, file_desc);\n+    char* extra_base = file_desc != -1 ?\n+      os::map_memory_to_file(extra_size, file_desc) :\n+      os::reserve_memory(extra_size);\n@@ -3164,1 +3166,3 @@\n-    aligned_base = os::attempt_reserve_memory_at(aligned_base, size, file_desc);\n+    aligned_base = file_desc != -1 ?\n+      os::attempt_map_memory_to_file_at(aligned_base, size, file_desc) :\n+      os::attempt_reserve_memory_at(aligned_base, size);\n@@ -3171,0 +3175,8 @@\n+char* os::reserve_memory_aligned(size_t size, size_t alignment) {\n+  return map_or_reserve_memory_aligned(size, alignment, -1 \/* file_desc *\/);\n+}\n+\n+char* os::map_memory_to_file_aligned(size_t size, size_t alignment, int fd) {\n+  return map_or_reserve_memory_aligned(size, alignment, fd);\n+}\n+\n@@ -3208,1 +3220,1 @@\n-char* os::pd_attempt_reserve_memory_at(char* requested_addr, size_t bytes, int file_desc) {\n+char* os::pd_attempt_map_memory_to_file_at(char* requested_addr, size_t bytes, int file_desc) {\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -187,1 +187,3 @@\n-  return __sync_add_and_fetch(dest, add_value);\n+  D res = __atomic_add_fetch(dest, add_value, __ATOMIC_RELEASE);\n+  FULL_MEM_BARRIER;\n+  return res;\n@@ -199,1 +201,3 @@\n-  return __sync_add_and_fetch(dest, add_value);\n+  D res = __atomic_add_fetch(dest, add_value, __ATOMIC_RELEASE);\n+  FULL_MEM_BARRIER;\n+  return res;\n","filename":"src\/hotspot\/os_cpu\/bsd_zero\/atomic_bsd_zero.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-int VM_Version::set_and_get_current_sve_vector_lenght(int length) {\n+int VM_Version::set_and_get_current_sve_vector_length(int length) {\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/vm_version_linux_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,3 @@\n-  return __sync_add_and_fetch(dest, add_value);\n+  D res = __atomic_add_fetch(dest, add_value, __ATOMIC_RELEASE);\n+  FULL_MEM_BARRIER;\n+  return res;\n@@ -61,1 +63,4 @@\n-  return __sync_add_and_fetch(dest, add_value);\n+\n+  D res = __atomic_add_fetch(dest, add_value, __ATOMIC_RELEASE);\n+  FULL_MEM_BARRIER;\n+  return res;\n","filename":"src\/hotspot\/os_cpu\/linux_zero\/atomic_linux_zero.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-int VM_Version::set_and_get_current_sve_vector_lenght(int length) {\n+int VM_Version::set_and_get_current_sve_vector_length(int length) {\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/vm_version_windows_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -202,13 +202,0 @@\n-#ifdef ASSERT\n-    \/\/ Cross-section branches only work if the\n-    \/\/ intermediate section boundaries are frozen.\n-    if (target_sect != branch_sect) {\n-      for (int n = MIN2(target_sect, branch_sect),\n-               nlimit = (target_sect + branch_sect) - n;\n-           n < nlimit; n++) {\n-        CodeSection* cs = cb->code_section(n);\n-        assert(cs->is_frozen(), \"cross-section branch needs stable offsets\");\n-      }\n-    }\n-#endif \/\/ASSERT\n-\n","filename":"src\/hotspot\/share\/asm\/assembler.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -179,22 +179,0 @@\n-void CodeBuffer::freeze_section(CodeSection* cs) {\n-  CodeSection* next_cs = (cs == consts())? NULL: code_section(cs->index()+1);\n-  csize_t frozen_size = cs->size();\n-  if (next_cs != NULL) {\n-    frozen_size = next_cs->align_at_start(frozen_size);\n-  }\n-  address old_limit = cs->limit();\n-  address new_limit = cs->start() + frozen_size;\n-  relocInfo* old_locs_limit = cs->locs_limit();\n-  relocInfo* new_locs_limit = cs->locs_end();\n-  \/\/ Patch the limits.\n-  cs->_limit = new_limit;\n-  cs->_locs_limit = new_locs_limit;\n-  cs->_frozen = true;\n-  if (next_cs != NULL && !next_cs->is_allocated() && !next_cs->is_frozen()) {\n-    \/\/ Give remaining buffer space to the following section.\n-    next_cs->initialize(new_limit, old_limit - new_limit);\n-    next_cs->initialize_shared_locs(new_locs_limit,\n-                                    old_locs_limit - new_locs_limit);\n-  }\n-}\n-\n@@ -260,5 +238,0 @@\n-address CodeBuffer::locator_address(int locator) const {\n-  if (locator < 0)  return NULL;\n-  address start = code_section(locator_sect(locator))->start();\n-  return start + locator_pos(locator);\n-}\n@@ -509,12 +482,0 @@\n-      #ifdef ASSERT\n-      if (prev_cs != NULL && prev_cs->is_frozen() && n < (SECT_LIMIT - 1)) {\n-        \/\/ Make sure the ends still match up.\n-        \/\/ This is important because a branch in a frozen section\n-        \/\/ might target code in a following section, via a Label,\n-        \/\/ and without a relocation record.  See Label::patch_instructions.\n-        address dest_start = buf+buf_offset;\n-        csize_t start2start = cs->start() - prev_cs->start();\n-        csize_t dest_start2start = dest_start - prev_dest_cs->start();\n-        assert(start2start == dest_start2start, \"cannot stretch frozen sect\");\n-      }\n-      #endif \/\/ASSERT\n@@ -899,3 +860,0 @@\n-    for (int n = 0; n < (int)SECT_LIMIT; n++) {\n-      guarantee(!code_section(n)->is_frozen(), \"resizing not allowed when frozen\");\n-    }\n@@ -1227,3 +1185,2 @@\n-  tty->print_cr(\" %7s.code = \" PTR_FORMAT \" : \" PTR_FORMAT \" : \" PTR_FORMAT \" (%d of %d)%s\",\n-                name, p2i(start()), p2i(end()), p2i(limit()), size(), capacity(),\n-                is_frozen()? \" [frozen]\": \"\");\n+  tty->print_cr(\" %7s.code = \" PTR_FORMAT \" : \" PTR_FORMAT \" : \" PTR_FORMAT \" (%d of %d)\",\n+                name, p2i(start()), p2i(end()), p2i(limit()), size(), capacity());\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.cpp","additions":2,"deletions":45,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -95,1 +95,0 @@\n-  bool        _frozen;          \/\/ no more expansion of this section\n@@ -112,1 +111,0 @@\n-    _frozen        = false;\n@@ -164,1 +162,0 @@\n-  csize_t     locs_remaining()const { return (csize_t)(_locs_limit - _locs_end); }\n@@ -169,1 +166,0 @@\n-  bool        is_frozen() const     { return _frozen; }\n@@ -187,2 +183,0 @@\n-  void    set_mark_off(int offset)  { assert(contains2(offset+_start),\"not in codeBuffer\");\n-                                      _mark = offset + _start; }\n@@ -262,4 +256,0 @@\n-  \/\/ Mark a section frozen.  Assign its remaining space to\n-  \/\/ the following section.  It will never expand after this point.\n-  inline void freeze();         \/\/  { _outer->freeze_section(this); }\n-\n@@ -466,2 +456,0 @@\n-  void freeze_section(CodeSection* cs);\n-\n@@ -559,1 +547,5 @@\n-  address    locator_address(int locator) const;\n+  address    locator_address(int locator) const {\n+    if (locator < 0)  return NULL;\n+    address start = code_section(locator_sect(locator))->start();\n+    return start + locator_pos(locator);\n+  }\n@@ -576,1 +568,0 @@\n-  address       insts_limit() const      { return _insts.limit();      }\n@@ -579,1 +570,0 @@\n-  void    clear_insts_mark()             {        _insts.clear_mark(); }\n@@ -651,6 +641,0 @@\n-\n-  \/\/ Print the comment associated with offset on stream, if there is one.\n-  virtual void print_block_comment(outputStream* stream, address block_begin) {\n-    intptr_t offset = (intptr_t)(block_begin - _total_start);  \/\/ I assume total_start is not correct for all code sections.\n-    _code_strings.print_block_comment(stream, offset);\n-  }\n@@ -682,3 +666,0 @@\n-  \/\/ Transform an address from the code in this code buffer to a specified code buffer\n-  address transform_address(const CodeBuffer &cb, address addr) const;\n-\n@@ -713,5 +694,0 @@\n-\n-inline void CodeSection::freeze() {\n-  _outer->freeze_section(this);\n-}\n-\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":5,"deletions":29,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -328,1 +328,1 @@\n-      intervals->at(i)->print_on(output());\n+      intervals->at(i)->print_on(output(), true);\n","filename":"src\/hotspot\/share\/c1\/c1_CFGPrinter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3215,0 +3215,6 @@\n+  LIR_Opr opr = get_operand(reg_num);\n+  assert(opr->is_valid(), \"unknown register\");\n+  opr->print(out);\n+}\n+\n+LIR_Opr LinearScan::get_operand(int reg_num) {\n@@ -3234,1 +3240,1 @@\n-    assert(false, \"unknown register\");\n+    \/\/ reg_num == -1 or a virtual register, return the illegal operand\n@@ -3236,1 +3242,1 @@\n-  opr->print(out);\n+  return opr;\n@@ -4601,1 +4607,1 @@\n-void Interval::print_on(outputStream* out) const {\n+void Interval::print_on(outputStream* out, bool is_cfg_printer) const {\n@@ -4611,1 +4617,0 @@\n-\n@@ -4613,4 +4618,9 @@\n-  if (reg_num() < LIR_OprDesc::vreg_base) {\n-    LinearScan::print_reg_num(out, assigned_reg());\n-  } else if (assigned_reg() != -1 && (LinearScan::num_physical_regs(type()) == 1 || assigned_regHi() != -1)) {\n-    LinearScan::calc_operand_for_interval(this)->print(out);\n+\n+  if (is_cfg_printer) {\n+    \/\/ Special version for compatibility with C1 Visualizer.\n+    LIR_Opr opr = LinearScan::get_operand(reg_num());\n+    if (opr->is_valid()) {\n+      out->print(\"\\\"\");\n+      opr->print(out);\n+      out->print(\"\\\" \");\n+    }\n@@ -4618,2 +4628,10 @@\n-    \/\/ Virtual register that has no assigned register yet.\n-    out->print(\"[ANY]\");\n+    \/\/ Improved output for normal debugging.\n+    if (reg_num() < LIR_OprDesc::vreg_base) {\n+      LinearScan::print_reg_num(out, assigned_reg());\n+    } else if (assigned_reg() != -1 && (LinearScan::num_physical_regs(type()) == 1 || assigned_regHi() != -1)) {\n+      LinearScan::calc_operand_for_interval(this)->print(out);\n+    } else {\n+      \/\/ Virtual register that has no assigned register yet.\n+      out->print(\"[ANY]\");\n+    }\n+    out->print(\" \");\n@@ -4621,2 +4639,1 @@\n-\n-  out->print(\" %d %d \", split_parent()->reg_num(), (register_hint(false) != NULL ? register_hint(false)->reg_num() : -1));\n+  out->print(\"%d %d \", split_parent()->reg_num(), (register_hint(false) != NULL ? register_hint(false)->reg_num() : -1));\n","filename":"src\/hotspot\/share\/c1\/c1_LinearScan.cpp","additions":29,"deletions":12,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -372,0 +372,1 @@\n+  static LIR_Opr get_operand(int reg_num);\n@@ -636,1 +637,5 @@\n-  void print_on(outputStream* out) const;\n+  void print_on(outputStream* out) const {\n+    print_on(out, false);\n+  }\n+  \/\/ Special version for compatibility with C1 Visualizer.\n+  void print_on(outputStream* out, bool is_cfg_printer) const;\n","filename":"src\/hotspot\/share\/c1\/c1_LinearScan.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -764,3 +764,0 @@\n-  \/\/ Accessibility checks are performed in ciEnv::get_method_by_index_impl.\n-  assert(check_klass_accessibility(accessor, holder->get_Klass()), \"holder not accessible\");\n-\n@@ -769,2 +766,8 @@\n-  Method* dest_method;\n-  LinkInfo link_info(holder_klass, name, sig, accessor_klass, LinkInfo::AccessCheck::required, LinkInfo::LoaderConstraintCheck::required, tag);\n+\n+  \/\/ Accessibility checks are performed in ciEnv::get_method_by_index_impl.\n+  assert(check_klass_accessibility(accessor, holder_klass), \"holder not accessible\");\n+\n+  LinkInfo link_info(holder_klass, name, sig, accessor_klass,\n+                     LinkInfo::AccessCheck::required,\n+                     LinkInfo::LoaderConstraintCheck::required,\n+                     tag);\n@@ -772,20 +775,12 @@\n-  case Bytecodes::_invokestatic:\n-    dest_method =\n-      LinkResolver::resolve_static_call_or_null(link_info);\n-    break;\n-  case Bytecodes::_invokespecial:\n-    dest_method =\n-      LinkResolver::resolve_special_call_or_null(link_info);\n-    break;\n-  case Bytecodes::_invokeinterface:\n-    dest_method =\n-      LinkResolver::linktime_resolve_interface_method_or_null(link_info);\n-    break;\n-  case Bytecodes::_invokevirtual:\n-    dest_method =\n-      LinkResolver::linktime_resolve_virtual_method_or_null(link_info);\n-    break;\n-  default: ShouldNotReachHere();\n-  }\n-\n-  return dest_method;\n+    case Bytecodes::_invokestatic:\n+      return LinkResolver::resolve_static_call_or_null(link_info);\n+    case Bytecodes::_invokespecial:\n+      return LinkResolver::resolve_special_call_or_null(link_info);\n+    case Bytecodes::_invokeinterface:\n+      return LinkResolver::linktime_resolve_interface_method_or_null(link_info);\n+    case Bytecodes::_invokevirtual:\n+      return LinkResolver::linktime_resolve_virtual_method_or_null(link_info);\n+    default:\n+      fatal(\"Unhandled bytecode: %s\", Bytecodes::name(bc));\n+      return NULL; \/\/ silence compiler warnings\n+  }\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":20,"deletions":25,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -37,7 +37,2 @@\n-  \/\/ FIXME: Share code with ciMethodHandle::get_vmtarget\n-  Metadata* vmtarget = java_lang_invoke_MemberName::vmtarget(get_oop());\n-  if (vmtarget->is_method())\n-    return CURRENT_ENV->get_method((Method*) vmtarget);\n-  \/\/ FIXME: What if the vmtarget is a Klass?\n-  assert(false, \"\");\n-  return NULL;\n+  Method* vmtarget = java_lang_invoke_MemberName::vmtarget(get_oop());\n+  return CURRENT_ENV->get_method(vmtarget);\n","filename":"src\/hotspot\/share\/ci\/ciMemberName.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -39,7 +39,2 @@\n-  \/\/ FIXME: Share code with ciMemberName::get_vmtarget\n-  Metadata* vmtarget = java_lang_invoke_MemberName::vmtarget(vmentry_oop);\n-  if (vmtarget->is_method())\n-    return CURRENT_ENV->get_method((Method*) vmtarget);\n-  \/\/ FIXME: What if the vmtarget is a Klass?\n-  assert(false, \"\");\n-  return NULL;\n+  Method* vmtarget = java_lang_invoke_MemberName::vmtarget(vmentry_oop);\n+  return CURRENT_ENV->get_method(vmtarget);\n","filename":"src\/hotspot\/share\/ci\/ciMethodHandle.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3656,6 +3656,0 @@\n-bool ClassFileParser::supports_records() {\n-  return _major_version == JVM_CLASSFILE_MAJOR_VERSION &&\n-         _minor_version == JAVA_PREVIEW_MINOR_VERSION &&\n-         Arguments::enable_preview();\n-}\n-\n@@ -3909,8 +3903,7 @@\n-        } else if (_major_version >= JAVA_14_VERSION) {\n-          if (tag == vmSymbols::tag_record()) {\n-            \/\/ Skip over Record attribute if not supported or if super class is\n-            \/\/ not java.lang.Record.\n-            if (supports_records() &&\n-                cp->klass_name_at(_super_class_index) == vmSymbols::java_lang_Record()) {\n-              if (parsed_record_attribute) {\n-                classfile_parse_error(\"Multiple Record attributes in class file %s\", THREAD);\n+\n+        } else if (_major_version >= JAVA_15_VERSION) {\n+          \/\/ Check for PermittedSubclasses tag\n+          if (tag == vmSymbols::tag_permitted_subclasses()) {\n+            if (supports_sealed_types()) {\n+              if (parsed_permitted_subclasses_attribute) {\n+                classfile_parse_error(\"Multiple PermittedSubclasses attributes in class file %s\", CHECK);\n@@ -3919,3 +3912,15 @@\n-              \/\/ Check that class is final and not abstract.\n-              if (!_access_flags.is_final() || _access_flags.is_abstract()) {\n-                classfile_parse_error(\"Record attribute in non-final or abstract class file %s\", THREAD);\n+              \/\/ Classes marked ACC_FINAL cannot have a PermittedSubclasses attribute.\n+              if (_access_flags.is_final()) {\n+                classfile_parse_error(\"PermittedSubclasses attribute in final class file %s\", CHECK);\n+                return;\n+              }\n+              parsed_permitted_subclasses_attribute = true;\n+              permitted_subclasses_attribute_start = cfs->current();\n+              permitted_subclasses_attribute_length = attribute_length;\n+            }\n+            cfs->skip_u1(attribute_length, CHECK);\n+\n+          } else if (_major_version >= JAVA_16_VERSION) {\n+            if (tag == vmSymbols::tag_record()) {\n+              if (parsed_record_attribute) {\n+                classfile_parse_error(\"Multiple Record attributes in class file %s\", THREAD);\n@@ -3927,14 +3932,0 @@\n-            } else if (log_is_enabled(Info, class, record)) {\n-              \/\/ Log why the Record attribute was ignored.  Note that if the\n-              \/\/ class file version is JVM_CLASSFILE_MAJOR_VERSION.65535 and\n-              \/\/ --enable-preview wasn't specified then a java.lang.UnsupportedClassVersionError\n-              \/\/ exception would have been thrown.\n-              ResourceMark rm(THREAD);\n-              if (supports_records()) {\n-                log_info(class, record)(\n-                  \"Ignoring Record attribute in class %s because super type is not java.lang.Record\",\n-                  _class_name->as_C_string());\n-              } else {\n-                log_info(class, record)(\n-                  \"Ignoring Record attribute in class %s because class file version is not %d.65535\",\n-                   _class_name->as_C_string(), JVM_CLASSFILE_MAJOR_VERSION);\n@@ -3942,1 +3933,0 @@\n-            }\n@@ -3944,22 +3934,0 @@\n-          } else if (_major_version >= JAVA_15_VERSION) {\n-            \/\/ Check for PermittedSubclasses tag\n-            if (tag == vmSymbols::tag_permitted_subclasses()) {\n-              if (supports_sealed_types()) {\n-                if (parsed_permitted_subclasses_attribute) {\n-                  classfile_parse_error(\"Multiple PermittedSubclasses attributes in class file %s\", THREAD);\n-                  return;\n-                }\n-                \/\/ Classes marked ACC_FINAL cannot have a PermittedSubclasses attribute.\n-                if (_access_flags.is_final()) {\n-                  classfile_parse_error(\"PermittedSubclasses attribute in final class file %s\", THREAD);\n-                  return;\n-                }\n-                parsed_permitted_subclasses_attribute = true;\n-                permitted_subclasses_attribute_start = cfs->current();\n-                permitted_subclasses_attribute_length = attribute_length;\n-              }\n-              cfs->skip_u1(attribute_length, CHECK);\n-            } else {\n-              \/\/ Unknown attribute\n-              cfs->skip_u1(attribute_length, CHECK);\n-            }\n@@ -4463,7 +4431,1 @@\n-      ResourceMark rm(THREAD);\n-      Exceptions::fthrow(\n-        THREAD_AND_LOCATION,\n-        vmSymbols::java_lang_VerifyError(),\n-        \"class %s cannot inherit from final class %s\",\n-        this_klass->external_name(),\n-        super_ik->external_name());\n+      classfile_icce_error(\"class %s cannot inherit from final class %s\", super_ik, THREAD);\n@@ -4614,9 +4576,6 @@\n-              Exceptions::fthrow(THREAD_AND_LOCATION,\n-                                 vmSymbols::java_lang_VerifyError(),\n-                                 \"class %s overrides final method %s.%s%s\",\n-                                 this_klass->external_name(),\n-                                 super_m->method_holder()->external_name(),\n-                                 name->as_C_string(),\n-                                 signature->as_C_string()\n-                                 );\n-              return;\n+              THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                        err_msg(\"class %s overrides final method %s.%s%s\",\n+                                this_klass->external_name(),\n+                                super_m->method_holder()->external_name(),\n+                                name->as_C_string(),\n+                                signature->as_C_string()));\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":29,"deletions":70,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -1182,1 +1182,1 @@\n-static ResourceHashtable<\n+class LoadedUnregisteredClassesTable : public ResourceHashtable<\n@@ -1187,1 +1187,3 @@\n-  ResourceObj::C_HEAP> _loaded_unregistered_classes;\n+  ResourceObj::C_HEAP> {};\n+\n+static LoadedUnregisteredClassesTable* _loaded_unregistered_classes = NULL;\n@@ -1193,0 +1195,3 @@\n+  if (_loaded_unregistered_classes == NULL) {\n+    _loaded_unregistered_classes = new (ResourceObj::C_HEAP, mtClass)LoadedUnregisteredClassesTable();\n+  }\n@@ -1194,1 +1199,1 @@\n-  _loaded_unregistered_classes.put_if_absent(name, true, &created);\n+  _loaded_unregistered_classes->put_if_absent(name, true, &created);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -150,0 +150,1 @@\n+  template(java_version_name,                         \"java_version\")                             \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -325,1 +325,0 @@\n-\n@@ -363,0 +362,1 @@\n+    \/\/ ignore flags whose cc_flags are X\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,2 +39,2 @@\n-    cflags(BreakAtExecute,          bool, false, X) \\\n-    cflags(BreakAtCompile,          bool, false, X) \\\n+    cflags(BreakAtExecute,          bool, false, BreakAtExecute) \\\n+    cflags(BreakAtCompile,          bool, false, BreakAtCompile) \\\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -284,12 +284,0 @@\n-uint G1PLABAllocator::calc_survivor_alignment_bytes() {\n-  assert(SurvivorAlignmentInBytes >= ObjectAlignmentInBytes, \"sanity\");\n-  if (SurvivorAlignmentInBytes == ObjectAlignmentInBytes) {\n-    \/\/ No need to align objects in the survivors differently, return 0\n-    \/\/ which means \"survivor alignment is not used\".\n-    return 0;\n-  } else {\n-    assert(SurvivorAlignmentInBytes > 0, \"sanity\");\n-    return SurvivorAlignmentInBytes;\n-  }\n-}\n-\n@@ -298,2 +286,1 @@\n-  _allocator(allocator),\n-  _survivor_alignment_bytes(calc_survivor_alignment_bytes()) {\n+  _allocator(allocator) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.cpp","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -152,7 +152,0 @@\n-  \/\/ The survivor alignment in effect in bytes.\n-  \/\/ == 0 : don't align survivors\n-  \/\/ != 0 : align survivors to that alignment\n-  \/\/ These values were chosen to favor the non-alignment case since some\n-  \/\/ architectures have a special compare against zero instructions.\n-  const uint _survivor_alignment_bytes;\n-\n@@ -171,4 +164,0 @@\n-  \/\/ Calculate the survivor space object alignment in bytes. Returns that or 0 if\n-  \/\/ there are no restrictions on survivor alignment.\n-  static uint calc_survivor_alignment_bytes();\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.hpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -108,5 +108,1 @@\n-  if (_survivor_alignment_bytes == 0 || !dest.is_young()) {\n-    return buffer->allocate(word_sz);\n-  } else {\n-    return buffer->allocate_aligned(word_sz, _survivor_alignment_bytes);\n-  }\n+  return buffer->allocate(word_sz);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.inline.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,12 @@\n+G1BiasedMappedArrayBase::G1BiasedMappedArrayBase() :\n+  _alloc_base(NULL),\n+  _base(NULL),\n+  _length(0),\n+  _biased_base(NULL),\n+  _bias(0),\n+  _shift_by(0) { }\n+\n+G1BiasedMappedArrayBase::~G1BiasedMappedArrayBase() {\n+  FreeHeap(_alloc_base);\n+}\n+\n@@ -33,1 +45,1 @@\n-  return PaddedPrimitiveArray<u_char, mtGC>::create_unfreeable(length * elem_size);\n+  return PaddedPrimitiveArray<u_char, mtGC>::create(length * elem_size, &_alloc_base);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BiasedArray.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"memory\/allocation.hpp\"\n@@ -35,1 +36,1 @@\n-class G1BiasedMappedArrayBase {\n+class G1BiasedMappedArrayBase : public CHeapObj<mtGC> {\n@@ -37,0 +38,3 @@\n+\n+  void* _alloc_base;      \/\/ the address the unpadded array has been allocated to\n+\n@@ -39,0 +43,1 @@\n+\n@@ -47,3 +52,1 @@\n-\n-  G1BiasedMappedArrayBase() : _base(NULL), _length(0), _biased_base(NULL),\n-    _bias(0), _shift_by(0) { }\n+  G1BiasedMappedArrayBase();\n@@ -52,1 +55,1 @@\n-  static address create_new_base_array(size_t length, size_t elem_size);\n+  address create_new_base_array(size_t length, size_t elem_size);\n@@ -93,2 +96,4 @@\n-   \/\/ Return the length of the array in elements.\n-   size_t length() const { return _length; }\n+  virtual ~G1BiasedMappedArrayBase();\n+\n+  \/\/ Return the length of the array in elements.\n+  size_t length() const { return _length; }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BiasedArray.hpp","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-      } else if (ml.wait(sleep_time_ms, Monitor::_no_safepoint_check_flag)) {\n+      } else if (ml.wait(sleep_time_ms)) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -223,1 +223,1 @@\n-  char* ret = os::attempt_reserve_memory_at(rs.base(), rs.size(), _backing_fd);\n+  char* ret = os::attempt_map_memory_to_file_at(rs.base(), rs.size(), _backing_fd);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionToSpaceMapper.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -519,3 +519,0 @@\n-\n-  \/\/ This closure provides its own oop verification code.\n-  debug_only(virtual bool should_verify_oops() { return false; })\n@@ -658,3 +655,0 @@\n-\n-  \/\/ This closure provides its own oop verification code.\n-  debug_only(virtual bool should_verify_oops() { return false; })\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,3 +50,0 @@\n-\n-  \/\/ This closure provides its own oop verification code.\n-  debug_only(virtual bool should_verify_oops()    { return false; })\n@@ -67,3 +64,0 @@\n-\n-  \/\/ This closure provides its own oop verification code.\n-  debug_only(virtual bool should_verify_oops()    { return false; })\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.inline.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -137,2 +137,0 @@\n-  \/\/ This closure provides its own oop verification code.\n-  debug_only(virtual bool should_verify_oops() { return false; })\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.inline.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,5 +35,1 @@\n-  HeapWord* obj = CollectedHeap::align_allocation_or_fail(top(), end(), SurvivorAlignmentInBytes);\n-  if (obj == NULL) {\n-    return NULL;\n-  }\n-\n+  HeapWord* obj = top();\n@@ -44,2 +40,1 @@\n-    assert(is_aligned(obj, SurvivorAlignmentInBytes) && is_object_aligned(new_top),\n-           \"checking alignment\");\n+    assert(is_object_aligned(new_top), \"checking alignment\");\n@@ -48,1 +43,0 @@\n-    set_top(obj);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionLAB.inline.hpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -100,3 +100,0 @@\n-\n-  \/\/ Don't use the oop verification code in the oop_oop_iterate framework.\n-  debug_only(virtual bool should_verify_oops() { return false; })\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -714,1 +714,1 @@\n-    obj = (oop) to()->allocate_aligned(s);\n+    obj = (oop) to()->allocate(s);\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-  Devirtualizer::do_oop_no_verify(_cl, p);\n+  Devirtualizer::do_oop(_cl, p);\n@@ -80,1 +80,1 @@\n-  Devirtualizer::do_oop_no_verify(_cl, p);\n+  Devirtualizer::do_oop(_cl, p);\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -194,3 +194,0 @@\n-\n-  \/\/ This closure provides its own oop verification code.\n-  debug_only(virtual bool should_verify_oops() { return false; })\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -313,6 +313,0 @@\n-  \/\/ Return the address \"addr\" aligned by \"alignment_in_bytes\" if such\n-  \/\/ an address is below \"end\".  Return NULL otherwise.\n-  inline static HeapWord* align_allocation_or_fail(HeapWord* addr,\n-                                                   HeapWord* end,\n-                                                   unsigned short alignment_in_bytes);\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,37 +33,0 @@\n-inline HeapWord* CollectedHeap::align_allocation_or_fail(HeapWord* addr,\n-                                                         HeapWord* end,\n-                                                         unsigned short alignment_in_bytes) {\n-  if (alignment_in_bytes <= ObjectAlignmentInBytes) {\n-    return addr;\n-  }\n-\n-  assert(is_aligned(addr, HeapWordSize),\n-         \"Address \" PTR_FORMAT \" is not properly aligned.\", p2i(addr));\n-  assert(is_aligned(alignment_in_bytes, HeapWordSize),\n-         \"Alignment size %u is incorrect.\", alignment_in_bytes);\n-\n-  HeapWord* new_addr = align_up(addr, alignment_in_bytes);\n-  size_t padding = pointer_delta(new_addr, addr);\n-\n-  if (padding == 0) {\n-    return addr;\n-  }\n-\n-  if (padding < CollectedHeap::min_fill_size()) {\n-    padding += alignment_in_bytes \/ HeapWordSize;\n-    assert(padding >= CollectedHeap::min_fill_size(),\n-           \"alignment_in_bytes %u is expect to be larger \"\n-           \"than the minimum object size\", alignment_in_bytes);\n-    new_addr = addr + padding;\n-  }\n-\n-  assert(new_addr > addr, \"Unexpected arithmetic overflow \"\n-         PTR_FORMAT \" not greater than \" PTR_FORMAT, p2i(new_addr), p2i(addr));\n-  if(new_addr < end) {\n-    CollectedHeap::fill_with_object(addr, padding);\n-    return new_addr;\n-  } else {\n-    return NULL;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.inline.hpp","additions":0,"deletions":37,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -441,19 +441,0 @@\n-JVMFlag::Error SurvivorAlignmentInBytesConstraintFunc(intx value, bool verbose) {\n-  if (value != 0) {\n-    if (!is_power_of_2(value)) {\n-      JVMFlag::printError(verbose,\n-                          \"SurvivorAlignmentInBytes (\" INTX_FORMAT \") must be \"\n-                          \"power of 2\\n\",\n-                          value);\n-      return JVMFlag::VIOLATES_CONSTRAINT;\n-    }\n-    if (value < ObjectAlignmentInBytes) {\n-      JVMFlag::printError(verbose,\n-                          \"SurvivorAlignmentInBytes (\" INTX_FORMAT \") must be \"\n-                          \"greater than or equal to ObjectAlignmentInBytes (\" INTX_FORMAT \")\\n\",\n-                          value, ObjectAlignmentInBytes);\n-      return JVMFlag::VIOLATES_CONSTRAINT;\n-    }\n-  }\n-  return JVMFlag::SUCCESS;\n-}\n","filename":"src\/hotspot\/share\/gc\/shared\/jvmFlagConstraintsGC.cpp","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -70,2 +70,1 @@\n- f(size_t, MaxMetaspaceSizeConstraintFunc)                     \\\n- f(intx,   SurvivorAlignmentInBytesConstraintFunc)\n+ f(size_t, MaxMetaspaceSizeConstraintFunc)\n","filename":"src\/hotspot\/share\/gc\/shared\/jvmFlagConstraintsGC.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,12 +33,0 @@\n-inline HeapWord* PLAB::allocate_aligned(size_t word_sz, unsigned short alignment_in_bytes) {\n-  HeapWord* res = CollectedHeap::align_allocation_or_fail(_top, _end, alignment_in_bytes);\n-  if (res == NULL) {\n-    return NULL;\n-  }\n-\n-  \/\/ Set _top so that allocate(), which expects _top to be correctly set,\n-  \/\/ can be used below.\n-  _top = res;\n-  return allocate(word_sz);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/plab.inline.hpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -31,1 +31,5 @@\n-PretouchTask::PretouchTask(const char* task_name, char* start_address, char* end_address, size_t page_size) :\n+PretouchTask::PretouchTask(const char* task_name,\n+                           char* start_address,\n+                           char* end_address,\n+                           size_t page_size,\n+                           size_t chunk_size) :\n@@ -36,6 +40,6 @@\n-    _page_size(0) {\n-#ifdef LINUX\n-  _page_size = UseTransparentHugePages ? (size_t)os::vm_page_size(): page_size;\n-#else\n-  _page_size = page_size;\n-#endif\n+    _page_size(page_size),\n+    _chunk_size(chunk_size) {\n+\n+  assert(chunk_size >= page_size,\n+         \"Chunk size \" SIZE_FORMAT \" is smaller than page size \" SIZE_FORMAT,\n+         chunk_size, page_size);\n@@ -49,2 +53,0 @@\n-  size_t const actual_chunk_size = MAX2(chunk_size(), _page_size);\n-\n@@ -52,1 +54,1 @@\n-    char* touch_addr = Atomic::fetch_and_add(&_cur_addr, actual_chunk_size);\n+    char* touch_addr = Atomic::fetch_and_add(&_cur_addr, _chunk_size);\n@@ -57,1 +59,1 @@\n-    char* end_addr = touch_addr + MIN2(actual_chunk_size, pointer_delta(_end_addr, touch_addr, sizeof(char)));\n+    char* end_addr = touch_addr + MIN2(_chunk_size, pointer_delta(_end_addr, touch_addr, sizeof(char)));\n@@ -65,1 +67,9 @@\n-  PretouchTask task(task_name, start_address, end_address, page_size);\n+\n+#ifdef LINUX\n+  \/\/ When using THP we need to always pre-touch using small pages as the OS will\n+  \/\/ initially always use small pages.\n+  page_size = UseTransparentHugePages ? (size_t)os::vm_page_size() : page_size;\n+#endif\n+  size_t chunk_size = MAX2(PretouchTask::chunk_size(), page_size);\n+\n+  PretouchTask task(task_name, start_address, end_address, page_size, chunk_size);\n@@ -68,0 +78,4 @@\n+  if (total_bytes == 0) {\n+    return;\n+  }\n+\n@@ -69,1 +83,1 @@\n-    size_t num_chunks = MAX2((size_t)1, total_bytes \/ MAX2(PretouchTask::chunk_size(), page_size));\n+    size_t num_chunks = (total_bytes + chunk_size - 1) \/ chunk_size;\n@@ -71,1 +85,1 @@\n-    uint num_workers = MIN2((uint)num_chunks, pretouch_gang->total_workers());\n+    uint num_workers = (uint)MIN2(num_chunks, (size_t)pretouch_gang->total_workers());\n","filename":"src\/hotspot\/share\/gc\/shared\/pretouchTask.cpp","additions":28,"deletions":14,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+  size_t _chunk_size;\n@@ -37,1 +38,1 @@\n-  PretouchTask(const char* task_name, char* start_address, char* end_address, size_t page_size);\n+  PretouchTask(const char* task_name, char* start_address, char* end_address, size_t page_size, size_t chunk_size);\n","filename":"src\/hotspot\/share\/gc\/shared\/pretouchTask.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -570,21 +570,0 @@\n-HeapWord* ContiguousSpace::allocate_aligned(size_t size) {\n-  assert(Heap_lock->owned_by_self() || (SafepointSynchronize::is_at_safepoint() && Thread::current()->is_VM_thread()), \"not locked\");\n-  HeapWord* end_value = end();\n-\n-  HeapWord* obj = CollectedHeap::align_allocation_or_fail(top(), end_value, SurvivorAlignmentInBytes);\n-  if (obj == NULL) {\n-    return NULL;\n-  }\n-\n-  if (pointer_delta(end_value, obj) >= size) {\n-    HeapWord* new_top = obj + size;\n-    set_top(new_top);\n-    assert(::is_aligned(obj, SurvivorAlignmentInBytes) && is_aligned(new_top),\n-      \"checking alignment\");\n-    return obj;\n-  } else {\n-    set_top(obj);\n-    return NULL;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -563,1 +563,0 @@\n-  HeapWord* allocate_aligned(size_t word_size);\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1062,0 +1062,2 @@\n+\n+    \/\/ If one input is NULL, then step over the barriers (except LRB native) on the other input\n@@ -1063,1 +1065,2 @@\n-        (in1->Opcode() != Op_ShenandoahLoadReferenceBarrier || !((ShenandoahLoadReferenceBarrierNode*)in1)->is_native())) {\n+        !((in2->Opcode() == Op_ShenandoahLoadReferenceBarrier) &&\n+          ((ShenandoahLoadReferenceBarrierNode*)in2)->is_native())) {\n@@ -1067,1 +1070,2 @@\n-        (in2->Opcode() != Op_ShenandoahLoadReferenceBarrier || !((ShenandoahLoadReferenceBarrierNode*)in2)->is_native())) {\n+        !((in1->Opcode() == Op_ShenandoahLoadReferenceBarrier) &&\n+          ((ShenandoahLoadReferenceBarrierNode*)in1)->is_native())) {\n@@ -1070,0 +1074,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -136,1 +136,1 @@\n-    \/\/ Split out tasks, as suggested in ObjArrayChunkedTask docs. Record the last\n+    \/\/ Split out tasks, as suggested in ShenandoahMarkTask docs. Record the last\n@@ -169,1 +169,1 @@\n-  \/\/ Split out tasks, as suggested in ObjArrayChunkedTask docs. Avoid pushing tasks that\n+  \/\/ Split out tasks, as suggested in ShenandoahMarkTask docs. Avoid pushing tasks that\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -187,2 +187,2 @@\n-#if SHENANDOAH_OPTIMIZED_OBJTASK\n-  \/\/ The optimized ObjArrayChunkedTask takes some bits away from the full object bits.\n+#if SHENANDOAH_OPTIMIZED_MARKTASK\n+  \/\/ The optimized ShenandoahMarkTask takes some bits away from the full object bits.\n@@ -190,1 +190,1 @@\n-  if ((uintptr_t)heap_rs.end() >= ObjArrayChunkedTask::max_addressable()) {\n+  if ((uintptr_t)heap_rs.end() >= ShenandoahMarkTask::max_addressable()) {\n@@ -194,1 +194,1 @@\n-                p2i(heap_rs.base()), p2i(heap_rs.end()), ObjArrayChunkedTask::max_addressable());\n+                p2i(heap_rs.base()), p2i(heap_rs.end()), ShenandoahMarkTask::max_addressable());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -44,1 +44,2 @@\n-  _gc_state(ShenandoahHeap::heap()->gc_state()),\n+  _heap(ShenandoahHeap::heap()),\n+  _gc_state(_heap->gc_state()),\n@@ -46,0 +47,2 @@\n+  _heap->_gc_state.clear();\n+  _heap->set_concurrent_weak_root_in_progress(false);\n@@ -49,4 +52,3 @@\n-  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n-  heap->_gc_state.set(_gc_state);\n-  assert(heap->gc_state() == _gc_state, \"Should be restored\");\n-  heap->set_concurrent_weak_root_in_progress(_concurrent_weak_root_in_progress);\n+  _heap->_gc_state.set(_gc_state);\n+  assert(_heap->gc_state() == _gc_state, \"Should be restored\");\n+  _heap->set_concurrent_weak_root_in_progress(_concurrent_weak_root_in_progress);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootVerifier.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+  ShenandoahHeap* const _heap;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootVerifier.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -63,1 +64,1 @@\n-\/\/ ObjArrayChunkedTask\n+\/\/ ShenandoahMarkTask\n@@ -126,1 +127,1 @@\n-#define SHENANDOAH_OPTIMIZED_OBJTASK 1\n+#define SHENANDOAH_OPTIMIZED_MARKTASK 1\n@@ -128,1 +129,1 @@\n-#define SHENANDOAH_OPTIMIZED_OBJTASK 0\n+#define SHENANDOAH_OPTIMIZED_MARKTASK 0\n@@ -131,2 +132,2 @@\n-#if SHENANDOAH_OPTIMIZED_OBJTASK\n-class ObjArrayChunkedTask\n+#if SHENANDOAH_OPTIMIZED_MARKTASK\n+class ShenandoahMarkTask\n@@ -134,11 +135,3 @@\n-public:\n-  enum {\n-    chunk_bits   = 10,\n-    pow_bits     = 5,\n-    oop_bits     = sizeof(uintptr_t)*8 - chunk_bits - pow_bits\n-  };\n-  enum {\n-    oop_shift    = 0,\n-    pow_shift    = oop_shift + oop_bits,\n-    chunk_shift  = pow_shift + pow_bits\n-  };\n+private:\n+  \/\/ Everything is encoded into this field...\n+  uintptr_t _obj;\n@@ -146,11 +139,4 @@\n-public:\n-  ObjArrayChunkedTask(oop o = NULL) {\n-    assert(decode_oop(encode_oop(o)) ==  o, \"oop can be encoded: \" PTR_FORMAT, p2i(o));\n-    _obj = encode_oop(o);\n-  }\n-  ObjArrayChunkedTask(oop o, int chunk, int pow) {\n-    assert(decode_oop(encode_oop(o)) == o, \"oop can be encoded: \" PTR_FORMAT, p2i(o));\n-    assert(decode_chunk(encode_chunk(chunk)) == chunk, \"chunk can be encoded: %d\", chunk);\n-    assert(decode_pow(encode_pow(pow)) == pow, \"pow can be encoded: %d\", pow);\n-    _obj = encode_oop(o) | encode_chunk(chunk) | encode_pow(pow);\n-  }\n+  \/\/ ...with these:\n+  static const uint8_t chunk_bits  = 10;\n+  static const uint8_t pow_bits    = 5;\n+  static const uint8_t oop_bits    = sizeof(uintptr_t)*8 - chunk_bits - pow_bits;\n@@ -158,1 +144,9 @@\n-  \/\/ Trivially copyable.\n+  static const uint8_t oop_shift   = 0;\n+  static const uint8_t pow_shift   = oop_bits;\n+  static const uint8_t chunk_shift = oop_bits + pow_bits;\n+\n+  static const uintptr_t oop_extract_mask       = right_n_bits(oop_bits);\n+  static const uintptr_t chunk_pow_extract_mask = ~right_n_bits(oop_bits);\n+\n+  static const int chunk_range_mask = right_n_bits(chunk_bits);\n+  static const int pow_range_mask   = right_n_bits(pow_bits);\n@@ -161,1 +155,7 @@\n-    return (oop) reinterpret_cast<void*>((val >> oop_shift) & right_n_bits(oop_bits));\n+    STATIC_ASSERT(oop_shift == 0);\n+    return cast_to_oop(val & oop_extract_mask);\n+  }\n+\n+  inline bool decode_not_chunked(uintptr_t val) const {\n+    \/\/ No need to shift for a comparison to zero\n+    return (val & chunk_pow_extract_mask) == 0;\n@@ -165,1 +165,1 @@\n-    return (int) ((val >> chunk_shift) & right_n_bits(chunk_bits));\n+    return (int) ((val >> chunk_shift) & chunk_range_mask);\n@@ -169,1 +169,1 @@\n-    return (int) ((val >> pow_shift) & right_n_bits(pow_bits));\n+    return (int) ((val >> pow_shift) & pow_range_mask);\n@@ -173,1 +173,2 @@\n-    return ((uintptr_t)(void*) obj) << oop_shift;\n+    STATIC_ASSERT(oop_shift == 0);\n+    return cast_from_oop<uintptr_t>(obj);\n@@ -184,4 +185,26 @@\n-  inline oop obj()   const { return decode_oop(_obj);   }\n-  inline int chunk() const { return decode_chunk(_obj); }\n-  inline int pow()   const { return decode_pow(_obj);   }\n-  inline bool is_not_chunked() const { return (_obj & ~right_n_bits(oop_bits + pow_bits)) == 0; }\n+public:\n+  ShenandoahMarkTask(oop o = NULL) {\n+    uintptr_t enc = encode_oop(o);\n+    assert(decode_oop(enc) == o,    \"oop encoding should work: \" PTR_FORMAT, p2i(o));\n+    assert(decode_not_chunked(enc), \"task should not be chunked\");\n+    _obj = enc;\n+  }\n+\n+  ShenandoahMarkTask(oop o, int chunk, int pow) {\n+    uintptr_t enc_oop = encode_oop(o);\n+    uintptr_t enc_chunk = encode_chunk(chunk);\n+    uintptr_t enc_pow = encode_pow(pow);\n+    uintptr_t enc = enc_oop | enc_chunk | enc_pow;\n+    assert(decode_oop(enc) == o,       \"oop encoding should work: \" PTR_FORMAT, p2i(o));\n+    assert(decode_chunk(enc) == chunk, \"chunk encoding should work: %d\", chunk);\n+    assert(decode_pow(enc) == pow,     \"pow encoding should work: %d\", pow);\n+    assert(!decode_not_chunked(enc),   \"task should be chunked\");\n+    _obj = enc;\n+  }\n+\n+  \/\/ Trivially copyable.\n+\n+public:\n+  inline oop  obj()            const { return decode_oop(_obj);   }\n+  inline int  chunk()          const { return decode_chunk(_obj); }\n+  inline int  pow()            const { return decode_pow(_obj);   }\n@@ -189,1 +212,3 @@\n-  DEBUG_ONLY(bool is_valid() const); \/\/ Tasks to be pushed\/popped must be valid.\n+  inline bool is_not_chunked() const { return decode_not_chunked(_obj); }\n+\n+  DEBUG_ONLY(bool is_valid() const;) \/\/ Tasks to be pushed\/popped must be valid.\n@@ -198,3 +223,0 @@\n-\n-private:\n-  uintptr_t _obj;\n@@ -203,1 +225,1 @@\n-class ObjArrayChunkedTask\n+class ShenandoahMarkTask\n@@ -205,1 +227,1 @@\n-public:\n+private:\n@@ -210,0 +232,5 @@\n+\n+  oop _obj;\n+  int _chunk;\n+  int _pow;\n+\n@@ -211,1 +238,2 @@\n-  ObjArrayChunkedTask(oop o = NULL, int chunk = 0, int pow = 0): _obj(o) {\n+  ShenandoahMarkTask(oop o = NULL, int chunk = 0, int pow = 0):\n+    _obj(o), _chunk(chunk), _pow(pow) {\n@@ -214,2 +242,0 @@\n-    _chunk = chunk;\n-    _pow = pow;\n@@ -220,4 +246,3 @@\n-  inline oop obj()   const { return _obj; }\n-  inline int chunk() const { return _chunk; }\n-  inline int pow()  const { return _pow; }\n-\n+  inline oop obj()             const { return _obj; }\n+  inline int chunk()           const { return _chunk; }\n+  inline int pow()             const { return _pow; }\n@@ -226,1 +251,1 @@\n-  DEBUG_ONLY(bool is_valid() const); \/\/ Tasks to be pushed\/popped must be valid.\n+  DEBUG_ONLY(bool is_valid() const;) \/\/ Tasks to be pushed\/popped must be valid.\n@@ -235,5 +260,0 @@\n-\n-private:\n-  oop _obj;\n-  int _chunk;\n-  int _pow;\n@@ -241,1 +261,1 @@\n-#endif \/\/ SHENANDOAH_OPTIMIZED_OBJTASK\n+#endif \/\/ SHENANDOAH_OPTIMIZED_MARKTASK\n@@ -247,1 +267,0 @@\n-typedef ObjArrayChunkedTask ShenandoahMarkTask;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahTaskqueue.hpp","additions":76,"deletions":57,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+  static size_t array_size(size_t length);\n@@ -37,0 +38,3 @@\n+  template <typename Allocator>\n+  static void* alloc(Allocator* allocator, size_t length);\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zAttachedArray.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,4 +37,16 @@\n-inline void* ZAttachedArray<ObjectT, ArrayT>::alloc(size_t length) {\n-  const size_t array_size = sizeof(ArrayT) * length;\n-  char* const addr = AllocateHeap(object_size() + array_size, mtGC);\n-  ::new (addr + object_size()) ArrayT[length];\n+inline size_t ZAttachedArray<ObjectT, ArrayT>::array_size(size_t length) {\n+  return sizeof(ArrayT) * length;\n+}\n+\n+template <typename ObjectT, typename ArrayT>\n+template <typename Allocator>\n+inline void* ZAttachedArray<ObjectT, ArrayT>::alloc(Allocator* allocator, size_t length) {\n+  \/\/ Allocate memory for object and array\n+  const size_t size = object_size() + array_size(length);\n+  void* const addr = allocator->alloc(size);\n+\n+  \/\/ Placement new array\n+  void* const array_addr = reinterpret_cast<char*>(addr) + object_size();\n+  ::new (array_addr) ArrayT[length];\n+\n+  \/\/ Return pointer to object\n@@ -44,0 +56,10 @@\n+template <typename ObjectT, typename ArrayT>\n+inline void* ZAttachedArray<ObjectT, ArrayT>::alloc(size_t length) {\n+  struct Allocator {\n+    void* alloc(size_t size) const {\n+      return AllocateHeap(size, mtGC);\n+    }\n+  } allocator;\n+  return alloc(&allocator, length);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zAttachedArray.inline.hpp","additions":27,"deletions":5,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"gc\/z\/zPage.inline.hpp\"\n@@ -28,23 +27,0 @@\n-#include \"utilities\/powerOfTwo.hpp\"\n-\n-ZForwarding* ZForwarding::create(ZPage* page) {\n-  \/\/ Allocate table for linear probing. The size of the table must be\n-  \/\/ a power of two to allow for quick and inexpensive indexing\/masking.\n-  \/\/ The table is sized to have a load factor of 50%, i.e. sized to have\n-  \/\/ double the number of entries actually inserted.\n-  assert(page->live_objects() > 0, \"Invalid value\");\n-  const size_t nentries = round_up_power_of_2(page->live_objects() * 2);\n-  return ::new (AttachedArray::alloc(nentries)) ZForwarding(page, nentries);\n-}\n-\n-void ZForwarding::destroy(ZForwarding* forwarding) {\n-  AttachedArray::free(forwarding);\n-}\n-\n-ZForwarding::ZForwarding(ZPage* page, size_t nentries) :\n-    _virtual(page->virtual_memory()),\n-    _object_alignment_shift(page->object_alignment_shift()),\n-    _entries(nentries),\n-    _page(page),\n-    _refcount(1),\n-    _pinned(false) {}\n","filename":"src\/hotspot\/share\/gc\/z\/zForwarding.cpp","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+class ZForwardingAllocator;\n@@ -60,2 +61,2 @@\n-  static ZForwarding* create(ZPage* page);\n-  static void destroy(ZForwarding* forwarding);\n+  static uint32_t nentries(const ZPage* page);\n+  static ZForwarding* alloc(ZForwardingAllocator* allocator, ZPage* page);\n","filename":"src\/hotspot\/share\/gc\/z\/zForwarding.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/z\/zForwardingAllocator.inline.hpp\"\n@@ -31,0 +32,1 @@\n+#include \"gc\/z\/zPage.inline.hpp\"\n@@ -34,0 +36,25 @@\n+#include \"utilities\/powerOfTwo.hpp\"\n+\n+inline uint32_t ZForwarding::nentries(const ZPage* page) {\n+  \/\/ The number returned by the function is used to size the hash table of\n+  \/\/ forwarding entries for this page. This hash table uses linear probing.\n+  \/\/ The size of the table must be a power of two to allow for quick and\n+  \/\/ inexpensive indexing\/masking. The table is also sized to have a load\n+  \/\/ factor of 50%, i.e. sized to have double the number of entries actually\n+  \/\/ inserted, to allow for good lookup\/insert performance.\n+  return round_up_power_of_2(page->live_objects() * 2);\n+}\n+\n+inline ZForwarding* ZForwarding::alloc(ZForwardingAllocator* allocator, ZPage* page) {\n+  const size_t nentries = ZForwarding::nentries(page);\n+  void* const addr = AttachedArray::alloc(allocator, nentries);\n+  return ::new (addr) ZForwarding(page, nentries);\n+}\n+\n+inline ZForwarding::ZForwarding(ZPage* page, size_t nentries) :\n+    _virtual(page->virtual_memory()),\n+    _object_alignment_shift(page->object_alignment_shift()),\n+    _entries(nentries),\n+    _page(page),\n+    _refcount(1),\n+    _pinned(false) {}\n","filename":"src\/hotspot\/share\/gc\/z\/zForwarding.inline.hpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/z\/zForwardingAllocator.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+\n+ZForwardingAllocator::ZForwardingAllocator() :\n+    _start(NULL),\n+    _end(NULL),\n+    _top(NULL) {}\n+\n+ZForwardingAllocator::~ZForwardingAllocator() {\n+  FREE_C_HEAP_ARRAY(char, _start);\n+}\n+\n+void ZForwardingAllocator::reset(size_t size) {\n+  _start = _top = REALLOC_C_HEAP_ARRAY(char, _start, size, mtGC);\n+  _end = _start + size;\n+}\n","filename":"src\/hotspot\/share\/gc\/z\/zForwardingAllocator.cpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_GC_Z_ZFORWARDINGALLOCATOR_HPP\n+#define SHARE_GC_Z_ZFORWARDINGALLOCATOR_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class ZForwardingAllocator {\n+private:\n+  char* _start;\n+  char* _end;\n+  char* _top;\n+\n+public:\n+  ZForwardingAllocator();\n+  ~ZForwardingAllocator();\n+\n+  void reset(size_t size);\n+  size_t size() const;\n+  bool is_full() const;\n+\n+  void* alloc(size_t size);\n+};\n+\n+#endif \/\/ SHARE_GC_Z_ZFORWARDINGALLOCATOR_HPP\n","filename":"src\/hotspot\/share\/gc\/z\/zForwardingAllocator.hpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_GC_Z_ZFORWARDINGALLOCATOR_INLINE_HPP\n+#define SHARE_GC_Z_ZFORWARDINGALLOCATOR_INLINE_HPP\n+\n+#include \"gc\/z\/zForwardingAllocator.hpp\"\n+#include \"utilities\/debug.hpp\"\n+\n+inline size_t ZForwardingAllocator::size() const {\n+  return _end - _start;\n+}\n+\n+inline bool ZForwardingAllocator::is_full() const {\n+  return _top == _end;\n+}\n+\n+inline void* ZForwardingAllocator::alloc(size_t size) {\n+  char* const addr = _top;\n+  _top += size;\n+  assert(_top <= _end, \"Allocation should never fail\");\n+  return addr;\n+}\n+\n+#endif \/\/ SHARE_GC_Z_ZFORWARDINGALLOCATOR_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/z\/zForwardingAllocator.inline.hpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -129,0 +129,11 @@\n+\n+  virtual ZNMethodEntry nmethod_entry() const {\n+    if (ClassUnloading) {\n+      \/\/ All encountered nmethods should have been \"entered\" during stack walking\n+      return ZNMethodEntry::VerifyDisarmed;\n+    } else {\n+      \/\/ All nmethods are considered roots and will be visited.\n+      \/\/ Make sure that the unvisited gets fixed and disarmed before proceeding.\n+      return ZNMethodEntry::PreBarrier;\n+    }\n+  }\n@@ -163,6 +174,0 @@\n-\n-#ifdef ASSERT\n-  virtual bool should_verify_oops() {\n-    return false;\n-  }\n-#endif\n","filename":"src\/hotspot\/share\/gc\/z\/zHeapIterator.cpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -585,2 +585,3 @@\n-  virtual bool should_disarm_nmethods() const {\n-    return true;\n+  virtual ZNMethodEntry nmethod_entry() const {\n+    \/\/ Only apply closure to armed nmethods, and then disarm them.\n+    return ZNMethodEntry::Disarm;\n","filename":"src\/hotspot\/share\/gc\/z\/zMark.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -239,2 +239,3 @@\n-  OopClosure* const _cl;\n-  const bool        _should_disarm_nmethods;\n+  OopClosure* const        _cl;\n+  const ZNMethodEntry      _entry;\n+  BarrierSetNMethod* const _bs_nm;\n@@ -243,1 +244,1 @@\n-  ZNMethodToOopsDoClosure(OopClosure* cl, bool should_disarm_nmethods) :\n+  ZNMethodToOopsDoClosure(OopClosure* cl, ZNMethodEntry entry) :\n@@ -245,1 +246,2 @@\n-      _should_disarm_nmethods(should_disarm_nmethods) {}\n+      _entry(entry),\n+      _bs_nm(BarrierSet::barrier_set()->barrier_set_nmethod()) {}\n@@ -248,0 +250,5 @@\n+    if (_entry == ZNMethodEntry::PreBarrier) {\n+      \/\/ Apply entry barrier before proceeding with closure\n+      _bs_nm->nmethod_entry_barrier(nm);\n+    }\n+\n@@ -253,1 +260,2 @@\n-    if (_should_disarm_nmethods) {\n+    if (_entry == ZNMethodEntry::Disarm) {\n+      \/\/ Apply closure and disarm only armed nmethods\n@@ -258,2 +266,1 @@\n-    } else {\n-      ZNMethod::nmethod_oops_do(nm, _cl);\n+      return;\n@@ -261,0 +268,7 @@\n+\n+    if (_entry == ZNMethodEntry::VerifyDisarmed) {\n+      \/\/ Only verify\n+      assert(!ZNMethod::is_armed(nm), \"Must be disarmed\");\n+    }\n+\n+    ZNMethod::nmethod_oops_do(nm, _cl);\n@@ -272,2 +286,2 @@\n-void ZNMethod::oops_do(OopClosure* cl, bool should_disarm_nmethods) {\n-  ZNMethodToOopsDoClosure nmethod_cl(cl, should_disarm_nmethods);\n+void ZNMethod::oops_do(OopClosure* cl, ZNMethodEntry entry) {\n+  ZNMethodToOopsDoClosure nmethod_cl(cl, entry);\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethod.cpp","additions":23,"deletions":9,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -34,0 +34,7 @@\n+enum class ZNMethodEntry {\n+  PreBarrier,\n+  Disarm,\n+  VerifyDisarmed,\n+  None\n+};\n+\n@@ -55,1 +62,1 @@\n-  static void oops_do(OopClosure* cl, bool should_disarm_nmethods);\n+  static void oops_do(OopClosure* cl, ZNMethodEntry entry);\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethod.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -34,6 +34,0 @@\n-\n-#ifdef ASSERT\n-  virtual bool should_verify_oops() {\n-    return false;\n-  }\n-#endif\n@@ -55,6 +49,0 @@\n-\n-#ifdef ASSERT\n-  virtual bool should_verify_oops() {\n-    return false;\n-  }\n-#endif\n@@ -72,0 +60,2 @@\n+\n+  virtual ZNMethodEntry nmethod_entry() const;\n@@ -78,0 +68,2 @@\n+\n+  virtual ZNMethodEntry nmethod_entry() const;\n","filename":"src\/hotspot\/share\/gc\/z\/zOopClosures.hpp","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -83,0 +83,5 @@\n+inline ZNMethodEntry ZPhantomKeepAliveOopClosure::nmethod_entry() const {\n+  ShouldNotReachHere();\n+  return ZNMethodEntry::None;\n+}\n+\n@@ -107,0 +112,5 @@\n+inline ZNMethodEntry ZPhantomCleanOopClosure::nmethod_entry() const {\n+  ShouldNotReachHere();\n+  return ZNMethodEntry::None;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zOopClosures.inline.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,2 @@\n-#include \"gc\/z\/zForwarding.hpp\"\n+#include \"gc\/z\/zForwarding.inline.hpp\"\n+#include \"gc\/z\/zForwardingAllocator.inline.hpp\"\n@@ -27,0 +28,1 @@\n+#include \"gc\/z\/zStat.hpp\"\n@@ -28,0 +30,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -30,0 +33,1 @@\n+    _allocator(),\n@@ -33,4 +37,5 @@\n-void ZRelocationSet::populate(ZPage* const* group0, size_t ngroup0,\n-                              ZPage* const* group1, size_t ngroup1) {\n-  _nforwardings = ngroup0 + ngroup1;\n-  _forwardings = REALLOC_C_HEAP_ARRAY(ZForwarding*, _forwardings, _nforwardings, mtGC);\n+void ZRelocationSet::populate(ZPage* const* small, size_t nsmall,\n+                              ZPage* const* medium, size_t nmedium,\n+                              size_t forwarding_entries) {\n+  \/\/ Set relocation set length\n+  _nforwardings = nsmall + nmedium;\n@@ -38,0 +43,11 @@\n+  \/\/ Initialize forwarding allocator to have room for the\n+  \/\/ relocation set, all forwardings, and all forwarding entries.\n+  const size_t relocation_set_size = _nforwardings * sizeof(ZForwarding*);\n+  const size_t forwardings_size = _nforwardings * sizeof(ZForwarding);\n+  const size_t forwarding_entries_size = forwarding_entries * sizeof(ZForwardingEntry);\n+  _allocator.reset(relocation_set_size + forwardings_size + forwarding_entries_size);\n+\n+  \/\/ Allocate relocation set\n+  _forwardings = new (_allocator.alloc(relocation_set_size)) ZForwarding*[_nforwardings];\n+\n+  \/\/ Populate relocation set array\n@@ -40,3 +56,3 @@\n-  \/\/ Populate group 0\n-  for (size_t i = 0; i < ngroup0; i++) {\n-    _forwardings[j++] = ZForwarding::create(group0[i]);\n+  \/\/ Populate medium pages\n+  for (size_t i = 0; i < nmedium; i++) {\n+    _forwardings[j++] = ZForwarding::alloc(&_allocator, medium[i]);\n@@ -45,3 +61,3 @@\n-  \/\/ Populate group 1\n-  for (size_t i = 0; i < ngroup1; i++) {\n-    _forwardings[j++] = ZForwarding::create(group1[i]);\n+  \/\/ Populate small pages\n+  for (size_t i = 0; i < nsmall; i++) {\n+    _forwardings[j++] = ZForwarding::alloc(&_allocator, small[i]);\n@@ -49,0 +65,5 @@\n+\n+  assert(_allocator.is_full(), \"Should be full\");\n+\n+  \/\/ Update statistics\n+  ZStatRelocation::set_at_populate_relocation_set(_allocator.size());\n@@ -52,4 +73,1 @@\n-  for (size_t i = 0; i < _nforwardings; i++) {\n-    ZForwarding::destroy(_forwardings[i]);\n-    _forwardings[i] = NULL;\n-  }\n+  _nforwardings = 0;\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSet.cpp","additions":34,"deletions":16,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/z\/zForwardingAllocator.hpp\"\n@@ -37,2 +38,3 @@\n-  ZForwarding** _forwardings;\n-  size_t        _nforwardings;\n+  ZForwardingAllocator _allocator;\n+  ZForwarding**        _forwardings;\n+  size_t               _nforwardings;\n@@ -43,2 +45,3 @@\n-  void populate(ZPage* const* group0, size_t ngroup0,\n-                ZPage* const* group1, size_t ngroup1);\n+  void populate(ZPage* const* small, size_t nsmall,\n+                ZPage* const* medium, size_t nmedium,\n+                size_t forwarding_entries);\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSet.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/z\/zForwarding.inline.hpp\"\n@@ -56,0 +57,1 @@\n+    _forwarding_entries(0),\n@@ -146,1 +148,3 @@\n-  size_t from_size = 0;\n+  size_t selected_forwarding_entries = 0;\n+  size_t from_live_bytes = 0;\n+  size_t from_forwarding_entries = 0;\n@@ -152,1 +156,3 @@\n-    from_size += _sorted_pages[from - 1]->live_bytes();\n+    ZPage* const page = _sorted_pages[from - 1];\n+    from_live_bytes += page->live_bytes();\n+    from_forwarding_entries += ZForwarding::nentries(page);\n@@ -158,1 +164,1 @@\n-    const size_t to = ceil((double)(from_size) \/ (double)(_page_size - _object_size_limit));\n+    const size_t to = ceil((double)(from_live_bytes) \/ (double)(_page_size - _object_size_limit));\n@@ -170,0 +176,1 @@\n+      selected_forwarding_entries = from_forwarding_entries;\n@@ -172,3 +179,4 @@\n-    log_trace(gc, reloc)(\"Candidate Relocation Set (%s Pages): \"\n-                         SIZE_FORMAT \"->\" SIZE_FORMAT \", %.1f%% relative defragmentation, %s\",\n-                         _name, from, to, diff_reclaimable, (selected_from == from) ? \"Selected\" : \"Rejected\");\n+    log_trace(gc, reloc)(\"Candidate Relocation Set (%s Pages): \" SIZE_FORMAT \"->\" SIZE_FORMAT \", \"\n+                         \"%.1f%% relative defragmentation, \" SIZE_FORMAT \" forwarding entries, %s\",\n+                         _name, from, to, diff_reclaimable, from_forwarding_entries,\n+                         (selected_from == from) ? \"Selected\" : \"Rejected\");\n@@ -179,0 +187,1 @@\n+  _forwarding_entries = selected_forwarding_entries;\n@@ -184,2 +193,4 @@\n-  log_trace(gc, reloc)(\"Relocation Set (%s Pages): \" SIZE_FORMAT \"->\" SIZE_FORMAT \", \" SIZE_FORMAT \" skipped\",\n-                       _name, selected_from, selected_to, npages - _nselected);\n+  log_trace(gc, reloc)(\"Relocation Set (%s Pages): \" SIZE_FORMAT \"->\" SIZE_FORMAT \", \"\n+                       SIZE_FORMAT \" skipped, \" SIZE_FORMAT \" forwarding entries\",\n+                       _name, selected_from, selected_to, npages - selected_from,\n+                       selected_forwarding_entries);\n@@ -248,2 +259,3 @@\n-  relocation_set->populate(_medium.selected(), _medium.nselected(),\n-                           _small.selected(), _small.nselected());\n+  relocation_set->populate(_small.selected(), _small.nselected(),\n+                           _medium.selected(), _medium.nselected(),\n+                           forwarding_entries());\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSetSelector.cpp","additions":22,"deletions":10,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -78,1 +78,0 @@\n-\n@@ -82,0 +81,1 @@\n+  size_t                           _forwarding_entries;\n@@ -102,0 +102,1 @@\n+  size_t forwarding_entries() const;\n@@ -112,0 +113,1 @@\n+  size_t forwarding_entries() const;\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSetSelector.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -77,0 +77,4 @@\n+inline size_t ZRelocationSetSelectorGroup::forwarding_entries() const {\n+  return _forwarding_entries;\n+}\n+\n@@ -81,0 +85,4 @@\n+inline size_t ZRelocationSetSelector::forwarding_entries() const {\n+  return _small.forwarding_entries() + _medium.forwarding_entries();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSetSelector.inline.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-  ZNMethod::oops_do(cl, cl->should_disarm_nmethods());\n+  ZNMethod::oops_do(cl, cl->nmethod_entry());\n","filename":"src\/hotspot\/share\/gc\/z\/zRootsIterator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/z\/zNMethod.hpp\"\n@@ -64,3 +65,1 @@\n-  virtual bool should_disarm_nmethods() const {\n-    return false;\n-  }\n+  virtual ZNMethodEntry nmethod_entry() const = 0;\n","filename":"src\/hotspot\/share\/gc\/z\/zRootsIterator.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1143,0 +1143,1 @@\n+size_t                      ZStatRelocation::_forwarding_usage;\n@@ -1149,0 +1150,4 @@\n+void ZStatRelocation::set_at_populate_relocation_set(size_t forwarding_usage) {\n+  _forwarding_usage = forwarding_usage;\n+}\n+\n@@ -1172,0 +1177,1 @@\n+  log_info(gc, reloc)(\"Forwarding Usage: \" SIZE_FORMAT \"M\", _forwarding_usage \/ M);\n","filename":"src\/hotspot\/share\/gc\/z\/zStat.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -426,0 +426,1 @@\n+  static size_t                      _forwarding_usage;\n@@ -432,0 +433,1 @@\n+  static void set_at_populate_relocation_set(size_t forwarding_usage);\n","filename":"src\/hotspot\/share\/gc\/z\/zStat.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -97,0 +97,5 @@\n+\n+  virtual ZNMethodEntry nmethod_entry() const {\n+    \/\/ Verification performs its own verification\n+    return ZNMethodEntry::None;\n+  }\n@@ -191,1 +196,1 @@\n-class ZVerifyOopClosure : public ClaimMetadataVisitingOopIterateClosure, public ZRootsIteratorClosure  {\n+class ZVerifyOopClosure : public ClaimMetadataVisitingOopIterateClosure {\n@@ -217,7 +222,0 @@\n-\n-#ifdef ASSERT\n-  \/\/ Verification handled by the closure itself\n-  virtual bool should_verify_oops() {\n-    return false;\n-  }\n-#endif\n","filename":"src\/hotspot\/share\/gc\/z\/zVerify.cpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1175,4 +1175,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::at_unwind(JavaThread* thread))\n-  \/\/ JRT_END does an implicit safepoint check, hence we are guaranteed to block\n-  \/\/ if this is called during a safepoint\n-\n+JRT_LEAF(void, InterpreterRuntime::at_unwind(JavaThread* thread))\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -107,0 +107,13 @@\n+EntryPoint::EntryPoint(address aentry, address ientry, address lentry, address fentry, address dentry, address ventry) {\n+  assert(number_of_states == 10, \"check the code below\");\n+  _entry[btos] = ientry;\n+  _entry[ztos] = ientry;\n+  _entry[ctos] = ientry;\n+  _entry[stos] = ientry;\n+  _entry[atos] = aentry;\n+  _entry[itos] = ientry;\n+  _entry[ltos] = lentry;\n+  _entry[ftos] = fentry;\n+  _entry[dtos] = dentry;\n+  _entry[vtos] = ventry;\n+}\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreter.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -51,1 +51,2 @@\n-\n+  \/\/ Will use the ientry for each of [bzcs]entry\n+  EntryPoint(address aentry, address ientry, address lentry, address fentry, address dentry, address ventry);\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreter.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -71,4 +71,0 @@\n-                 generate_trace_code(btos),\n-                 generate_trace_code(ztos),\n-                 generate_trace_code(ctos),\n-                 generate_trace_code(stos),\n@@ -86,1 +82,0 @@\n-    const int index_size = sizeof(u2);\n@@ -89,1 +84,0 @@\n-      address return_itos = generate_return_entry_for(itos, i, index_size);\n@@ -92,10 +86,6 @@\n-                   return_itos,\n-                   return_itos,\n-                   return_itos,\n-                   return_itos,\n-                   generate_return_entry_for(atos, i, index_size),\n-                   return_itos,\n-                   generate_return_entry_for(ltos, i, index_size),\n-                   generate_return_entry_for(ftos, i, index_size),\n-                   generate_return_entry_for(dtos, i, index_size),\n-                   generate_return_entry_for(vtos, i, index_size)\n+                   generate_return_entry_for(atos, i, sizeof(u2)),\n+                   generate_return_entry_for(itos, i, sizeof(u2)),\n+                   generate_return_entry_for(ltos, i, sizeof(u2)),\n+                   generate_return_entry_for(ftos, i, sizeof(u2)),\n+                   generate_return_entry_for(dtos, i, sizeof(u2)),\n+                   generate_return_entry_for(vtos, i, sizeof(u2))\n@@ -107,3 +97,3 @@\n-    \/\/ These states are in order specified in TosState, except btos\/ztos\/ctos\/stos are\n-    \/\/ really the same as itos since there is no top of stack optimization for these types\n-    const TosState states[] = {itos, itos, itos, itos, itos, ltos, ftos, dtos, atos, vtos, ilgl};\n+    \/\/ These states are in order specified in TosState, except btos\/ztos\/ctos\/stos which\n+    \/\/ are the same as itos since there is no top of stack optimization for these types\n+    const TosState states[] = {ilgl, ilgl, ilgl, ilgl, itos, ltos, ftos, dtos, atos, vtos, ilgl};\n@@ -114,1 +104,4 @@\n-    for (int i = 0; i < Interpreter::number_of_return_addrs; i++) {\n+    assert(invoke_length >= 0 && invoke_length < Interpreter::number_of_return_entries, \"invariant\");\n+    assert(invokeinterface_length >= 0 && invokeinterface_length < Interpreter::number_of_return_entries, \"invariant\");\n+\n+    for (int i = itos; i < Interpreter::number_of_return_addrs; i++) {\n@@ -117,3 +110,13 @@\n-      Interpreter::_invoke_return_entry[i] = generate_return_entry_for(state, invoke_length, sizeof(u2));\n-      Interpreter::_invokeinterface_return_entry[i] = generate_return_entry_for(state, invokeinterface_length, sizeof(u2));\n-      Interpreter::_invokedynamic_return_entry[i] = generate_return_entry_for(state, invokedynamic_length, sizeof(u4));\n+\n+      \/\/ Reuse generated entry points\n+      Interpreter::_invoke_return_entry[i]          = Interpreter::_return_entry[invoke_length].entry(state);\n+      Interpreter::_invokeinterface_return_entry[i] = Interpreter::_return_entry[invokeinterface_length].entry(state);\n+\n+      Interpreter::_invokedynamic_return_entry[i]   = generate_return_entry_for(state, invokedynamic_length, sizeof(u4));\n+    }\n+\n+    \/\/ set itos entry points for btos\/ztos\/ctos\/stos\n+    for (int i = 0; i < itos; i++) {\n+      Interpreter::_invoke_return_entry[i]          = Interpreter::_invoke_return_entry[itos];\n+      Interpreter::_invokeinterface_return_entry[i] = Interpreter::_invokeinterface_return_entry[itos];\n+      Interpreter::_invokedynamic_return_entry[i]   = Interpreter::_invokedynamic_return_entry[itos];\n@@ -124,0 +127,1 @@\n+    address earlyret_entry_itos = generate_earlyret_entry_for(itos);\n@@ -126,4 +130,0 @@\n-                 generate_earlyret_entry_for(btos),\n-                 generate_earlyret_entry_for(ztos),\n-                 generate_earlyret_entry_for(ctos),\n-                 generate_earlyret_entry_for(stos),\n@@ -156,4 +156,0 @@\n-                 generate_safept_entry_for(btos, CAST_FROM_FN_PTR(address, InterpreterRuntime::at_safepoint)),\n-                 generate_safept_entry_for(ztos, CAST_FROM_FN_PTR(address, InterpreterRuntime::at_safepoint)),\n-                 generate_safept_entry_for(ctos, CAST_FROM_FN_PTR(address, InterpreterRuntime::at_safepoint)),\n-                 generate_safept_entry_for(stos, CAST_FROM_FN_PTR(address, InterpreterRuntime::at_safepoint)),\n@@ -245,4 +241,0 @@\n-                   deopt_itos, \/* btos *\/\n-                   deopt_itos, \/* ztos *\/\n-                   deopt_itos, \/* ctos *\/\n-                   deopt_itos, \/* stos *\/\n@@ -250,1 +242,1 @@\n-                   deopt_itos, \/* itos *\/\n+                   generate_deopt_entry_for(itos, i),\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.cpp","additions":28,"deletions":36,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -67,1 +67,0 @@\n-  virtual bool should_verify_oops() { return false; }\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/bfsClosure.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-  virtual bool should_verify_oops() { return false; }\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/dfsClosure.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -288,1 +288,1 @@\n-          event.set_origin(flag->get_origin());                   \\\n+          event.set_origin(static_cast<u8>(flag->get_origin()));  \\\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrPeriodic.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-static const char* flag_value_origin_to_string(JVMFlag::Flags origin) {\n+static const char* flag_value_origin_to_string(JVMFlagOrigin origin) {\n@@ -127,9 +127,9 @@\n-    case JVMFlag::DEFAULT: return \"Default\";\n-    case JVMFlag::COMMAND_LINE: return \"Command line\";\n-    case JVMFlag::ENVIRON_VAR: return \"Environment variable\";\n-    case JVMFlag::CONFIG_FILE: return \"Config file\";\n-    case JVMFlag::MANAGEMENT: return \"Management\";\n-    case JVMFlag::ERGONOMIC: return \"Ergonomic\";\n-    case JVMFlag::ATTACH_ON_DEMAND: return \"Attach on demand\";\n-    case JVMFlag::INTERNAL: return \"Internal\";\n-    case JVMFlag::JIMAGE_RESOURCE: return \"JImage resource\";\n+    case JVMFlagOrigin::DEFAULT: return \"Default\";\n+    case JVMFlagOrigin::COMMAND_LINE: return \"Command line\";\n+    case JVMFlagOrigin::ENVIRON_VAR: return \"Environment variable\";\n+    case JVMFlagOrigin::CONFIG_FILE: return \"Config file\";\n+    case JVMFlagOrigin::MANAGEMENT: return \"Management\";\n+    case JVMFlagOrigin::ERGONOMIC: return \"Ergonomic\";\n+    case JVMFlagOrigin::ATTACH_ON_DEMAND: return \"Attach on demand\";\n+    case JVMFlagOrigin::INTERNAL: return \"Internal\";\n+    case JVMFlagOrigin::JIMAGE_RESOURCE: return \"JImage resource\";\n@@ -141,5 +141,7 @@\n-  static const u4 nof_entries = JVMFlag::LAST_VALUE_ORIGIN + 1;\n-  writer.write_count(nof_entries);\n-  for (u4 i = 0; i < nof_entries; ++i) {\n-    writer.write_key(i);\n-    writer.write(flag_value_origin_to_string((JVMFlag::Flags)i));\n+  constexpr EnumRange<JVMFlagOrigin> range;\n+  writer.write_count(static_cast<u4>(range.size()));\n+\n+  for (EnumIterator<JVMFlagOrigin> it = range.begin(); it != range.end(); ++it) {\n+    JVMFlagOrigin origin = *it;\n+    writer.write_key(static_cast<u4>(origin));\n+    writer.write(flag_value_origin_to_string(origin));\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrType.cpp","additions":17,"deletions":15,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"runtime\/flags\/jvmFlag.hpp\"\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVMInit.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1331,2 +1331,4 @@\n-  Method* dest_method;\n-  LinkInfo link_info(holder, name, sig, accessor, LinkInfo::AccessCheck::required, LinkInfo::LoaderConstraintCheck::required, tag);\n+  LinkInfo link_info(holder, name, sig, accessor,\n+                     LinkInfo::AccessCheck::required,\n+                     LinkInfo::LoaderConstraintCheck::required,\n+                     tag);\n@@ -1334,20 +1336,12 @@\n-  case Bytecodes::_invokestatic:\n-    dest_method =\n-      LinkResolver::resolve_static_call_or_null(link_info);\n-    break;\n-  case Bytecodes::_invokespecial:\n-    dest_method =\n-      LinkResolver::resolve_special_call_or_null(link_info);\n-    break;\n-  case Bytecodes::_invokeinterface:\n-    dest_method =\n-      LinkResolver::linktime_resolve_interface_method_or_null(link_info);\n-    break;\n-  case Bytecodes::_invokevirtual:\n-    dest_method =\n-      LinkResolver::linktime_resolve_virtual_method_or_null(link_info);\n-    break;\n-  default: ShouldNotReachHere();\n-  }\n-\n-  return dest_method;\n+    case Bytecodes::_invokestatic:\n+      return LinkResolver::resolve_static_call_or_null(link_info);\n+    case Bytecodes::_invokespecial:\n+      return LinkResolver::resolve_special_call_or_null(link_info);\n+    case Bytecodes::_invokeinterface:\n+      return LinkResolver::linktime_resolve_interface_method_or_null(link_info);\n+    case Bytecodes::_invokevirtual:\n+      return LinkResolver::linktime_resolve_virtual_method_or_null(link_info);\n+    default:\n+      fatal(\"Unhandled bytecode: %s\", Bytecodes::name(bc));\n+      return NULL; \/\/ silence compiler warnings\n+  }\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":16,"deletions":22,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-bool JVMCIGlobals::enable_jvmci_product_mode(JVMFlag::Flags origin) {\n+bool JVMCIGlobals::enable_jvmci_product_mode(JVMFlagOrigin origin) {\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"runtime\/flags\/jvmFlag.hpp\"\n+#include \"utilities\/vmEnums.hpp\"\n@@ -156,1 +156,1 @@\n-  static bool enable_jvmci_product_mode(JVMFlag::Flags);\n+  static bool enable_jvmci_product_mode(JVMFlagOrigin);\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"runtime\/flags\/jvmFlag.hpp\"\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"runtime\/sharedRuntime.hpp\"\n@@ -48,0 +49,21 @@\n+class AdapterHandlerEntry;\n+\n+class MethodTrampolineInfo {\n+  address _c2i_entry_trampoline;\n+  AdapterHandlerEntry** _adapter_trampoline;\n+public:\n+  address c2i_entry_trampoline() { return _c2i_entry_trampoline; }\n+  AdapterHandlerEntry** adapter_trampoline() { return _adapter_trampoline; }\n+  void set_c2i_entry_trampoline(address addr) { _c2i_entry_trampoline = addr; }\n+  void set_adapter_trampoline(AdapterHandlerEntry** entry) { _adapter_trampoline = entry; }\n+};\n+\n+class AdapterToTrampoline : public ResourceHashtable<\n+  AdapterHandlerEntry*, MethodTrampolineInfo,\n+  primitive_hash<AdapterHandlerEntry*>,\n+  primitive_equals<AdapterHandlerEntry*>,\n+  941, \/\/ prime number\n+  ResourceObj::C_HEAP> {};\n+\n+static AdapterToTrampoline* _adapter_to_trampoline = NULL;\n+\n@@ -262,0 +284,2 @@\n+    allocate_method_trampoline_info();\n+    allocate_method_trampolines();\n@@ -801,0 +825,86 @@\n+\n+void ArchiveBuilder::allocate_method_trampolines_for(InstanceKlass* ik) {\n+  if (ik->methods() != NULL) {\n+    for (int j = 0; j < ik->methods()->length(); j++) {\n+      \/\/ Walk the methods in a deterministic order so that the trampolines are\n+      \/\/ created in a deterministic order.\n+      Method* m = ik->methods()->at(j);\n+      AdapterHandlerEntry* ent = m->adapter(); \/\/ different methods can share the same AdapterHandlerEntry\n+      MethodTrampolineInfo* info = _adapter_to_trampoline->get(ent);\n+      if (info->c2i_entry_trampoline() == NULL) {\n+        info->set_c2i_entry_trampoline(\n+          (address)MetaspaceShared::misc_code_space_alloc(SharedRuntime::trampoline_size()));\n+        info->set_adapter_trampoline(\n+          (AdapterHandlerEntry**)MetaspaceShared::misc_code_space_alloc(sizeof(AdapterHandlerEntry*)));\n+      }\n+    }\n+  }\n+}\n+\n+void ArchiveBuilder::allocate_method_trampolines() {\n+  for (int i = 0; i < _klasses->length(); i++) {\n+    Klass* k = _klasses->at(i);\n+    if (k->is_instance_klass()) {\n+      InstanceKlass* ik = InstanceKlass::cast(k);\n+      allocate_method_trampolines_for(ik);\n+    }\n+  }\n+}\n+\n+\/\/ Allocate MethodTrampolineInfo for all Methods that will be archived. Also\n+\/\/ return the total number of bytes needed by the method trampolines in the MC\n+\/\/ region.\n+size_t ArchiveBuilder::allocate_method_trampoline_info() {\n+  size_t total = 0;\n+  size_t each_method_bytes =\n+    align_up(SharedRuntime::trampoline_size(), BytesPerWord) +\n+    align_up(sizeof(AdapterHandlerEntry*), BytesPerWord);\n+\n+  if (_adapter_to_trampoline == NULL) {\n+    _adapter_to_trampoline = new (ResourceObj::C_HEAP, mtClass)AdapterToTrampoline();\n+  }\n+  int count = 0;\n+  for (int i = 0; i < _klasses->length(); i++) {\n+    Klass* k = _klasses->at(i);\n+    if (k->is_instance_klass()) {\n+      InstanceKlass* ik = InstanceKlass::cast(k);\n+      if (ik->methods() != NULL) {\n+        for (int j = 0; j < ik->methods()->length(); j++) {\n+          Method* m = ik->methods()->at(j);\n+          AdapterHandlerEntry* ent = m->adapter(); \/\/ different methods can share the same AdapterHandlerEntry\n+          bool is_created = false;\n+          MethodTrampolineInfo* info = _adapter_to_trampoline->put_if_absent(ent, &is_created);\n+          if (is_created) {\n+            count++;\n+          }\n+        }\n+      }\n+    }\n+  }\n+  if (count == 0) {\n+    \/\/ We have nothing to archive, but let's avoid having an empty region.\n+    total = SharedRuntime::trampoline_size();\n+  } else {\n+    total = count * each_method_bytes;\n+  }\n+  return align_up(total, SharedSpaceObjectAlignment);\n+}\n+\n+void ArchiveBuilder::update_method_trampolines() {\n+  for (int i = 0; i < klasses()->length(); i++) {\n+    Klass* k = klasses()->at(i);\n+    if (k->is_instance_klass()) {\n+      InstanceKlass* ik = InstanceKlass::cast(k);\n+      Array<Method*>* methods = ik->methods();\n+      for (int j = 0; j < methods->length(); j++) {\n+        Method* m = methods->at(j);\n+        AdapterHandlerEntry* ent = m->adapter();\n+        MethodTrampolineInfo* info = _adapter_to_trampoline->get(ent);\n+        \/\/ m is the \"copy\" of the original Method, but its adapter() field is still valid because\n+        \/\/ we haven't called make_klasses_shareable() yet.\n+        m->set_from_compiled_entry(info->c2i_entry_trampoline());\n+        m->set_adapter_trampoline(info->adapter_trampoline());\n+      }\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/memory\/archiveBuilder.cpp","additions":110,"deletions":0,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -282,0 +282,7 @@\n+\n+  \/\/ Method trampolines related functions\n+  void allocate_method_trampolines();\n+  void allocate_method_trampolines_for(InstanceKlass* ik);\n+  size_t allocate_method_trampoline_info();\n+  void update_method_trampolines();\n+\n","filename":"src\/hotspot\/share\/memory\/archiveBuilder.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -96,1 +96,0 @@\n-  size_t estimate_trampoline_size();\n@@ -101,1 +100,0 @@\n-  void make_trampolines();\n@@ -119,6 +117,0 @@\n-  void reserve_buffers_for_trampolines() {\n-    size_t n = _estimated_trampoline_bytes;\n-    assert(n >= SharedRuntime::trampoline_size(), \"dont want to be empty\");\n-    MetaspaceShared::misc_code_space_alloc(n);\n-  }\n-\n@@ -187,1 +179,1 @@\n-    reserve_buffers_for_trampolines();\n+    allocate_method_trampolines();\n@@ -224,1 +216,1 @@\n-    make_trampolines();\n+    update_method_trampolines();\n@@ -257,1 +249,1 @@\n-  _estimated_trampoline_bytes = estimate_trampoline_size();\n+  _estimated_trampoline_bytes = allocate_method_trampoline_info();\n@@ -340,48 +332,0 @@\n-size_t DynamicArchiveBuilder::estimate_trampoline_size() {\n-  size_t total = 0;\n-  size_t each_method_bytes =\n-    align_up(SharedRuntime::trampoline_size(), BytesPerWord) +\n-    align_up(sizeof(AdapterHandlerEntry*), BytesPerWord);\n-\n-  for (int i = 0; i < klasses()->length(); i++) {\n-    Klass* k = klasses()->at(i);\n-    if (k->is_instance_klass()) {\n-      Array<Method*>* methods = InstanceKlass::cast(k)->methods();\n-      total += each_method_bytes * methods->length();\n-    }\n-  }\n-  if (total == 0) {\n-    \/\/ We have nothing to archive, but let's avoid having an empty region.\n-    total = SharedRuntime::trampoline_size();\n-  }\n-  return align_up(total, SharedSpaceObjectAlignment);\n-}\n-\n-void DynamicArchiveBuilder::make_trampolines() {\n-  DumpRegion* mc_space = MetaspaceShared::misc_code_dump_space();\n-  char* p = mc_space->base();\n-  for (int i = 0; i < klasses()->length(); i++) {\n-    Klass* k = klasses()->at(i);\n-    if (!k->is_instance_klass()) {\n-      continue;\n-    }\n-    InstanceKlass* ik = InstanceKlass::cast(k);\n-    Array<Method*>* methods = ik->methods();\n-    for (int j = 0; j < methods->length(); j++) {\n-      Method* m = methods->at(j);\n-      address c2i_entry_trampoline = (address)p;\n-      p += SharedRuntime::trampoline_size();\n-      assert(p >= mc_space->base() && p <= mc_space->top(), \"must be\");\n-      m->set_from_compiled_entry(to_target(c2i_entry_trampoline));\n-\n-      AdapterHandlerEntry** adapter_trampoline =(AdapterHandlerEntry**)p;\n-      p += sizeof(AdapterHandlerEntry*);\n-      assert(p >= mc_space->base() && p <= mc_space->top(), \"must be\");\n-      *adapter_trampoline = NULL;\n-      m->set_adapter_trampoline(to_target(adapter_trampoline));\n-    }\n-  }\n-\n-  guarantee(p <= mc_space->top(), \"Estimate of trampoline size is insufficient\");\n-}\n-\n","filename":"src\/hotspot\/share\/memory\/dynamicArchive.cpp","additions":3,"deletions":59,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -1740,1 +1740,1 @@\n-    return cast_from_oop<address>(CompressedOops::decode_not_null(n));\n+    return cast_from_oop<address>(CompressedOops::decode_raw_not_null(n));\n","filename":"src\/hotspot\/share\/memory\/filemap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1153,3 +1153,0 @@\n-  virtual bool should_verify_oops(void) {\n-    return false;\n-  }\n","filename":"src\/hotspot\/share\/memory\/heapShared.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -105,8 +105,0 @@\n-\n-#ifdef ASSERT\n-  \/\/ Default verification of each visited oop field.\n-  template <typename T> void verify(T* p);\n-\n-  \/\/ Can be used by subclasses to turn off the default verification of oop fields.\n-  virtual bool should_verify_oops() { return true; }\n-#endif\n@@ -360,1 +352,0 @@\n-  template <typename OopClosureType, typename T> static void do_oop_no_verify(OopClosureType* closure, T* p);\n","filename":"src\/hotspot\/share\/memory\/iterator.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"memory\/universe.hpp\"\n@@ -55,16 +54,0 @@\n-#ifdef ASSERT\n-\/\/ This verification is applied to all visited oops.\n-\/\/ The closures can turn is off by overriding should_verify_oops().\n-template <typename T>\n-void OopIterateClosure::verify(T* p) {\n-  if (should_verify_oops()) {\n-    T heap_oop = RawAccess<>::oop_load(p);\n-    if (!CompressedOops::is_null(heap_oop)) {\n-      oop o = CompressedOops::decode_not_null(heap_oop);\n-      assert(Universe::heap()->is_in(o),\n-             \"should be in closed *p \" PTR_FORMAT \" \" PTR_FORMAT, p2i(p), p2i(o));\n-    }\n-  }\n-}\n-#endif\n-\n@@ -126,5 +109,0 @@\n-template <typename OopClosureType, typename T>\n-inline void Devirtualizer::do_oop_no_verify(OopClosureType* closure, T* p) {\n-  call_do_oop<T>(&OopClosureType::do_oop, &OopClosure::do_oop, closure, p);\n-}\n-\n@@ -133,3 +111,1 @@\n-  debug_only(closure->verify(p));\n-\n-  do_oop_no_verify(closure, p);\n+  call_do_oop<T>(&OopClosureType::do_oop, &OopClosure::do_oop, closure, p);\n","filename":"src\/hotspot\/share\/memory\/iterator.inline.hpp","additions":1,"deletions":25,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -773,0 +773,3 @@\n+  log_info(cds)(\"Update method trampolines\");\n+  builder.update_method_trampolines();\n+\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -119,0 +119,1 @@\n+  static T* create(size_t length, void** alloc_base);\n","filename":"src\/hotspot\/share\/memory\/padded.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -85,0 +85,6 @@\n+  void* temp;\n+  return create(length, &temp);\n+}\n+\n+template <class T, MEMFLAGS flags, size_t alignment>\n+T* PaddedPrimitiveArray<T, flags, alignment>::create(size_t length, void** alloc_base) {\n@@ -90,0 +96,1 @@\n+  *alloc_base = chunk;\n","filename":"src\/hotspot\/share\/memory\/padded.inline.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -83,0 +83,24 @@\n+\/\/ Helper method\n+static char* attempt_map_or_reserve_memory_at(char* base, size_t size, int fd) {\n+  if (fd != -1) {\n+    return os::attempt_map_memory_to_file_at(base, size, fd);\n+  }\n+  return os::attempt_reserve_memory_at(base, size);\n+}\n+\n+\/\/ Helper method\n+static char* map_or_reserve_memory(size_t size, int fd) {\n+  if (fd != -1) {\n+    return os::map_memory_to_file(size, fd);\n+  }\n+  return os::reserve_memory(size);\n+}\n+\n+\/\/ Helper method\n+static char* map_or_reserve_memory_aligned(size_t size, size_t alignment, int fd) {\n+  if (fd != -1) {\n+    return os::map_memory_to_file_aligned(size, alignment, fd);\n+  }\n+  return os::reserve_memory_aligned(size, alignment);\n+}\n+\n@@ -191,1 +215,1 @@\n-      base = os::attempt_reserve_memory_at(requested_address, size, _fd_for_heap);\n+      base = attempt_map_or_reserve_memory_at(requested_address, size, _fd_for_heap);\n@@ -197,1 +221,1 @@\n-      base = os::reserve_memory_with_fd(size, _fd_for_heap);\n+      base = map_or_reserve_memory(size, _fd_for_heap);\n@@ -209,1 +233,1 @@\n-      base = os::reserve_memory_aligned(size, alignment, _fd_for_heap);\n+      base = map_or_reserve_memory_aligned(size, alignment, _fd_for_heap);\n@@ -375,1 +399,1 @@\n-      base = os::attempt_reserve_memory_at(requested_address, size, _fd_for_heap);\n+      base = attempt_map_or_reserve_memory_at(requested_address, size, _fd_for_heap);\n@@ -381,1 +405,1 @@\n-      base = os::reserve_memory_with_fd(size, _fd_for_heap);\n+      base = map_or_reserve_memory(size, _fd_for_heap);\n","filename":"src\/hotspot\/share\/memory\/virtualspace.cpp","additions":29,"deletions":5,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -122,0 +122,1 @@\n+  static inline oop decode_raw_not_null(narrowOop v);\n@@ -129,4 +130,4 @@\n-  static oop decode_not_null(oop v)             { return v; }\n-  static oop decode(oop v)                      { return v; }\n-  static narrowOop encode_not_null(narrowOop v) { return v; }\n-  static narrowOop encode(narrowOop v)          { return v; }\n+  static inline oop decode_not_null(oop v);\n+  static inline oop decode(oop v);\n+  static inline narrowOop encode_not_null(narrowOop v);\n+  static inline narrowOop encode(narrowOop v);\n","filename":"src\/hotspot\/share\/oops\/compressedOops.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -44,0 +44,5 @@\n+inline oop CompressedOops::decode_raw_not_null(narrowOop v) {\n+  assert(!is_null(v), \"narrow oop value can never be zero\");\n+  return decode_raw(v);\n+}\n+\n@@ -52,0 +57,1 @@\n+  assert(Universe::heap()->is_in(result), \"object not in heap \" PTR_FORMAT, p2i((void*) result));\n@@ -66,1 +72,1 @@\n-  assert(decode(result) == v, \"reversibility\");\n+  assert(decode_raw(result) == v, \"reversibility\");\n@@ -74,0 +80,18 @@\n+inline oop CompressedOops::decode_not_null(oop v) {\n+  assert(Universe::heap()->is_in(v), \"object not in heap \" PTR_FORMAT, p2i((void*) v));\n+  return v;\n+}\n+\n+inline oop CompressedOops::decode(oop v) {\n+  assert(Universe::heap()->is_in_or_null(v), \"object not in heap \" PTR_FORMAT, p2i((void*) v));\n+  return v;\n+}\n+\n+inline narrowOop CompressedOops::encode_not_null(narrowOop v) {\n+  return v;\n+}\n+\n+inline narrowOop CompressedOops::encode(narrowOop v) {\n+  return v;\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/compressedOops.inline.hpp","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1110,11 +1110,3 @@\n-  if (DynamicDumpSharedSpaces) {\n-    assert(_from_compiled_entry != NULL, \"sanity\");\n-  } else {\n-    \/\/ TODO: Simplify the adapter trampoline allocation for static archiving.\n-    \/\/       Remove the use of CDSAdapterHandlerEntry.\n-    CDSAdapterHandlerEntry* cds_adapter = (CDSAdapterHandlerEntry*)adapter();\n-    constMethod()->set_adapter_trampoline(cds_adapter->get_adapter_trampoline());\n-    _from_compiled_entry = cds_adapter->get_c2i_entry_trampoline();\n-    assert(*((int*)_from_compiled_entry) == 0,\n-           \"must be NULL during dump time, to be initialized at run time\");\n-  }\n+  assert(_from_compiled_entry != NULL, \"sanity\");\n+  assert(*((int*)_from_compiled_entry) == 0,\n+         \"must be NULL during dump time, to be initialized at run time\");\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -719,2 +719,0 @@\n-    _is_scalar_replaceable = false;\n-    _is_non_escaping = false;\n@@ -728,2 +726,0 @@\n-    _is_scalar_replaceable = false;\n-    _is_non_escaping = false;\n@@ -733,4 +729,0 @@\n-  \/\/ Result of Escape Analysis\n-  bool _is_scalar_replaceable;\n-  bool _is_non_escaping;\n-\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -932,2 +932,0 @@\n-  set_do_count_invocations(false);\n-  set_do_method_data_update(false);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -285,2 +285,0 @@\n-  bool                  _do_count_invocations;  \/\/ True if we generate code to count invocations\n-  bool                  _do_method_data_update; \/\/ True if we generate code to update MethodData*s\n@@ -574,4 +572,0 @@\n-  bool              do_count_invocations() const{ return _do_count_invocations; }\n-  void          set_do_count_invocations(bool z){ _do_count_invocations = z; }\n-  bool              do_method_data_update() const { return _do_method_data_update; }\n-  void          set_do_method_data_update(bool z) { _do_method_data_update = z; }\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -646,4 +646,0 @@\n-  \/\/ Bump method data counters (We profile *before* the call is made\n-  \/\/ because exceptions don't return to the call site.)\n-  profile_call(receiver);\n-\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -249,3 +249,0 @@\n-    if (n->is_CallStaticJava()) {\n-      n->as_CallStaticJava()->_is_non_escaping = noescape;\n-    }\n@@ -3071,5 +3068,0 @@\n-        if (alloc->is_CallStaticJava()) {\n-          \/\/ Set the scalar_replaceable flag for boxing method\n-          \/\/ so it could be eliminated if it has no uses.\n-          alloc->as_CallStaticJava()->_is_scalar_replaceable = true;\n-        }\n@@ -3124,5 +3116,0 @@\n-      if (alloc->is_CallStaticJava()) {\n-        \/\/ Set the scalar_replaceable flag for boxing method\n-        \/\/ so it could be eliminated.\n-        alloc->as_CallStaticJava()->_is_scalar_replaceable = true;\n-      }\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1048,10 +1048,0 @@\n-\/\/------------------------------policy_align-----------------------------------\n-\/\/ Return TRUE or FALSE if the loop should be cache-line aligned.  Gather the\n-\/\/ expression that does the alignment.  Note that only one array base can be\n-\/\/ aligned in a loop (unless the VM guarantees mutual alignment).  Note that\n-\/\/ if we vectorize short memory ops into longer memory ops, we may want to\n-\/\/ increase alignment.\n-bool IdealLoopTree::policy_align(PhaseIdealLoop *phase) const {\n-  return false;\n-}\n-\n@@ -3344,3 +3334,2 @@\n-  \/\/ Counted loops may be peeled, may need some iterations run up\n-  \/\/ front for RCE, and may want to align loop refs to a cache\n-  \/\/ line.  Thus we clone a full loop up front whose trip count is\n+  \/\/ Counted loops may be peeled, or may need some iterations run up\n+  \/\/ front for RCE. Thus we clone a full loop up front whose trip count is\n@@ -3358,2 +3347,0 @@\n-  \/\/ TODO: Remove align -- not used.\n-  bool should_align  = policy_align(phase);\n@@ -3361,2 +3348,2 @@\n-  \/\/ If not RCE'ing  (iteration splitting) or Aligning, then we  do not need a\n-  \/\/ pre-loop.  We may still need to peel an initial iteration but we will not\n+  \/\/ If not RCE'ing (iteration splitting), then we do not need a pre-loop.\n+  \/\/ We may still need to peel an initial iteration but we will not\n@@ -3365,3 +3352,3 @@\n-  \/\/ Basically, if may_rce_align reports FALSE first time through, we will not\n-  \/\/ be able to later do RCE or Aligning on this loop.\n-  bool may_rce_align = !policy_peel_only(phase) || should_rce || should_align;\n+  \/\/ Basically, if peel_only reports TRUE first time through, we will not\n+  \/\/ be able to later do RCE on this loop.\n+  bool peel_only = policy_peel_only(phase) && !should_rce;\n@@ -3369,1 +3356,1 @@\n-  \/\/ If we have any of these conditions (RCE, alignment, unrolling) met, then\n+  \/\/ If we have any of these conditions (RCE, unrolling) met, then\n@@ -3372,1 +3359,1 @@\n-  if (should_rce || should_align || should_unroll) {\n+  if (should_rce || should_unroll) {\n@@ -3378,1 +3365,1 @@\n-      phase->insert_pre_post_loops(this, old_new, !may_rce_align);\n+      phase->insert_pre_post_loops(this, old_new, peel_only);\n@@ -3409,5 +3396,0 @@\n-\n-    \/\/ Adjust the pre-loop limits to align the main body iterations.\n-    if (should_align) {\n-      Unimplemented();\n-    }\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":10,"deletions":28,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -620,7 +620,0 @@\n-  \/\/ Return TRUE or FALSE if the loop should be cache-line aligned.\n-  \/\/ Gather the expression that does the alignment.  Note that only\n-  \/\/ one array base can be aligned in a loop (unless the VM guarantees\n-  \/\/ mutual alignment).  Note that if we vectorize short memory ops\n-  \/\/ into longer memory ops, we may want to increase alignment.\n-  bool policy_align( PhaseIdealLoop *phase ) const;\n-\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1271,0 +1271,53 @@\n+bool LoadNode::has_reinterpret_variant(const Type* rt) {\n+  BasicType bt = rt->basic_type();\n+  switch (Opcode()) {\n+    case Op_LoadI: return (bt == T_FLOAT);\n+    case Op_LoadL: return (bt == T_DOUBLE);\n+    case Op_LoadF: return (bt == T_INT);\n+    case Op_LoadD: return (bt == T_LONG);\n+\n+    default: return false;\n+  }\n+}\n+\n+Node* LoadNode::convert_to_reinterpret_load(PhaseGVN& gvn, const Type* rt) {\n+  BasicType bt = rt->basic_type();\n+  assert(has_reinterpret_variant(rt), \"no reinterpret variant: %s %s\", Name(), type2name(bt));\n+  bool is_mismatched = is_mismatched_access();\n+  const TypeRawPtr* raw_type = gvn.type(in(MemNode::Memory))->isa_rawptr();\n+  if (raw_type == NULL) {\n+    is_mismatched = true; \/\/ conservatively match all non-raw accesses as mismatched\n+  }\n+  return LoadNode::make(gvn, in(MemNode::Control), in(MemNode::Memory), in(MemNode::Address),\n+                        raw_adr_type(), rt, bt, _mo, _control_dependency,\n+                        is_unaligned_access(), is_mismatched);\n+}\n+\n+bool StoreNode::has_reinterpret_variant(const Type* vt) {\n+  BasicType bt = vt->basic_type();\n+  switch (Opcode()) {\n+    case Op_StoreI: return (bt == T_FLOAT);\n+    case Op_StoreL: return (bt == T_DOUBLE);\n+    case Op_StoreF: return (bt == T_INT);\n+    case Op_StoreD: return (bt == T_LONG);\n+\n+    default: return false;\n+  }\n+}\n+\n+Node* StoreNode::convert_to_reinterpret_store(PhaseGVN& gvn, Node* val, const Type* vt) {\n+  BasicType bt = vt->basic_type();\n+  assert(has_reinterpret_variant(vt), \"no reinterpret variant: %s %s\", Name(), type2name(bt));\n+  StoreNode* st = StoreNode::make(gvn, in(MemNode::Control), in(MemNode::Memory), in(MemNode::Address), raw_adr_type(), val, bt, _mo);\n+\n+  bool is_mismatched = is_mismatched_access();\n+  const TypeRawPtr* raw_type = gvn.type(in(MemNode::Memory))->isa_rawptr();\n+  if (raw_type == NULL) {\n+    is_mismatched = true; \/\/ conservatively match all non-raw accesses as mismatched\n+  }\n+  if (is_mismatched) {\n+    st->set_mismatched_access();\n+  }\n+  return st;\n+}\n+\n@@ -2551,0 +2604,1 @@\n+  Node* value   = in(MemNode::ValueIn);\n@@ -2614,0 +2668,13 @@\n+  \/\/ Fold reinterpret cast into memory operation:\n+  \/\/    StoreX mem (MoveY2X v) => StoreY mem v\n+  if (value->is_Move()) {\n+    const Type* vt = value->in(1)->bottom_type();\n+    if (has_reinterpret_variant(vt)) {\n+      if (phase->C->post_loop_opts_phase()) {\n+        return convert_to_reinterpret_store(*phase, value->in(1), vt);\n+      } else {\n+        phase->C->record_for_post_loop_opts_igvn(this); \/\/ attempt the transformation once loop opts are over\n+      }\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":67,"deletions":0,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -285,0 +285,3 @@\n+  bool  has_reinterpret_variant(const Type* rt);\n+  Node* convert_to_reinterpret_load(PhaseGVN& gvn, const Type* rt);\n+\n@@ -637,0 +640,3 @@\n+  bool  has_reinterpret_variant(const Type* vt);\n+  Node* convert_to_reinterpret_store(PhaseGVN& gvn, Node* val, const Type* vt);\n+\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -355,0 +355,30 @@\n+\/\/------------------------------MoveNode------------------------------------------\n+\n+Node* MoveNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  if (can_reshape) {\n+    \/\/ Fold reinterpret cast into memory operation:\n+    \/\/    MoveX2Y (LoadX mem) => LoadY mem\n+    LoadNode* ld = in(1)->isa_Load();\n+    if (ld != NULL && (ld->outcnt() == 1)) { \/\/ replace only\n+      const Type* rt = bottom_type();\n+      if (ld->has_reinterpret_variant(rt)) {\n+        if (phase->C->post_loop_opts_phase()) {\n+          return ld->convert_to_reinterpret_load(*phase, rt);\n+        } else {\n+          phase->C->record_for_post_loop_opts_igvn(this); \/\/ attempt the transformation once loop opts are over\n+        }\n+      }\n+    }\n+  }\n+  return NULL;\n+}\n+\n+Node* MoveNode::Identity(PhaseGVN* phase) {\n+  if (in(1)->is_Move()) {\n+    \/\/ Back-to-back moves: MoveX2Y (MoveY2X v) => v\n+    assert(bottom_type() == in(1)->in(1)->bottom_type(), \"sanity\");\n+    return in(1)->in(1);\n+  }\n+  return this;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/movenode.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -101,1 +101,12 @@\n-class MoveI2FNode : public Node {\n+class MoveNode : public Node {\n+  protected:\n+  MoveNode(Node* value) : Node(NULL, value) {\n+    init_class_id(Class_Move);\n+  }\n+\n+  public:\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual Node* Identity(PhaseGVN* phase);\n+};\n+\n+class MoveI2FNode : public MoveNode {\n@@ -103,1 +114,1 @@\n-  MoveI2FNode( Node *value ) : Node(0,value) {}\n+  MoveI2FNode(Node* value) : MoveNode(value) {}\n@@ -105,1 +116,1 @@\n-  virtual const Type *bottom_type() const { return Type::FLOAT; }\n+  virtual const Type* bottom_type() const { return Type::FLOAT; }\n@@ -111,1 +122,1 @@\n-class MoveL2DNode : public Node {\n+class MoveL2DNode : public MoveNode {\n@@ -113,1 +124,1 @@\n-  MoveL2DNode( Node *value ) : Node(0,value) {}\n+  MoveL2DNode(Node* value) : MoveNode(value) {}\n@@ -115,1 +126,1 @@\n-  virtual const Type *bottom_type() const { return Type::DOUBLE; }\n+  virtual const Type* bottom_type() const { return Type::DOUBLE; }\n@@ -121,1 +132,1 @@\n-class MoveF2INode : public Node {\n+class MoveF2INode : public MoveNode {\n@@ -123,1 +134,1 @@\n-  MoveF2INode( Node *value ) : Node(0,value) {}\n+  MoveF2INode(Node* value) : MoveNode(value) {}\n@@ -125,1 +136,1 @@\n-  virtual const Type *bottom_type() const { return TypeInt::INT; }\n+  virtual const Type* bottom_type() const { return TypeInt::INT; }\n@@ -131,1 +142,1 @@\n-class MoveD2LNode : public Node {\n+class MoveD2LNode : public MoveNode {\n@@ -133,1 +144,1 @@\n-  MoveD2LNode( Node *value ) : Node(0,value) {}\n+  MoveD2LNode(Node* value) : MoveNode(value) {}\n@@ -135,1 +146,1 @@\n-  virtual const Type *bottom_type() const { return TypeLong::LONG; }\n+  virtual const Type* bottom_type() const { return TypeLong::LONG; }\n","filename":"src\/hotspot\/share\/opto\/movenode.hpp","additions":23,"deletions":12,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -115,0 +115,1 @@\n+class MoveNode;\n@@ -724,2 +725,3 @@\n-    DEFINE_CLASS_ID(Halt, Node, 15)\n-    DEFINE_CLASS_ID(Opaque1, Node, 16)\n+    DEFINE_CLASS_ID(Halt,     Node, 15)\n+    DEFINE_CLASS_ID(Opaque1,  Node, 16)\n+    DEFINE_CLASS_ID(Move,     Node, 17)\n@@ -727,1 +729,1 @@\n-    _max_classes  = ClassMask_Opaque1\n+    _max_classes  = ClassMask_Move\n@@ -873,0 +875,1 @@\n+  DEFINE_CLASS_QUERY(Move)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -333,2 +333,0 @@\n-  bool          _count_invocations;  \/\/ update and test invocation counter\n-  bool          _method_data_update; \/\/ update method data oop\n@@ -380,2 +378,0 @@\n-  bool          count_invocations() const  { return _count_invocations; }\n-  bool          method_data_update() const { return _method_data_update; }\n@@ -503,3 +499,0 @@\n-  \/\/ Helper function to setup for type-profile based inlining\n-  bool prepare_type_profile_inline(ciInstanceKlass* prof_klass, ciMethod* prof_method);\n-\n@@ -558,3 +551,3 @@\n-  void    jump_if_true_fork(IfNode *ifNode, int dest_bci_if_true, int prof_table_index, bool unc);\n-  void    jump_if_false_fork(IfNode *ifNode, int dest_bci_if_false, int prof_table_index, bool unc);\n-  void    jump_if_always_fork(int dest_bci_if_true, int prof_table_index, bool unc);\n+  void    jump_if_true_fork(IfNode *ifNode, int dest_bci_if_true, bool unc);\n+  void    jump_if_false_fork(IfNode *ifNode, int dest_bci_if_false, bool unc);\n+  void    jump_if_always_fork(int dest_bci_if_true, bool unc);\n@@ -570,17 +563,0 @@\n-  \/\/ helper functions for methodData style profiling\n-  void test_counter_against_threshold(Node* cnt, int limit);\n-  void increment_and_test_invocation_counter(int limit);\n-  void test_for_osr_md_counter_at(ciMethodData* md, ciProfileData* data, ByteSize offset, int limit);\n-  Node* method_data_addressing(ciMethodData* md, ciProfileData* data, ByteSize offset, Node* idx = NULL, uint stride = 0);\n-  void increment_md_counter_at(ciMethodData* md, ciProfileData* data, ByteSize offset, Node* idx = NULL, uint stride = 0);\n-  void set_md_flag_at(ciMethodData* md, ciProfileData* data, int flag_constant);\n-\n-  void profile_method_entry();\n-  void profile_taken_branch(int target_bci, bool force_update = false);\n-  void profile_not_taken_branch(bool force_update = false);\n-  void profile_call(Node* receiver);\n-  void profile_generic_call();\n-  void profile_receiver_type(Node* receiver);\n-  void profile_ret(int target_bci);\n-  void profile_null_checkcast();\n-  void profile_switch_case(int table_index);\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":3,"deletions":27,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -486,3 +486,0 @@\n-  _count_invocations = C->do_count_invocations();\n-  _method_data_update = C->do_method_data_update();\n-\n@@ -1231,4 +1228,0 @@\n-\n-  if (depth() == 1) {\n-    increment_and_test_invocation_counter(Tier2CompileThreshold);\n-  }\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -235,1 +235,1 @@\n-void Parse::jump_if_true_fork(IfNode *iff, int dest_bci_if_true, int prof_table_index, bool unc) {\n+void Parse::jump_if_true_fork(IfNode *iff, int dest_bci_if_true, bool unc) {\n@@ -248,1 +248,0 @@\n-      profile_switch_case(prof_table_index);\n@@ -258,1 +257,1 @@\n-void Parse::jump_if_false_fork(IfNode *iff, int dest_bci_if_true, int prof_table_index, bool unc) {\n+void Parse::jump_if_false_fork(IfNode *iff, int dest_bci_if_true, bool unc) {\n@@ -271,1 +270,0 @@\n-      profile_switch_case(prof_table_index);\n@@ -281,1 +279,1 @@\n-void Parse::jump_if_always_fork(int dest_bci, int prof_table_index, bool unc) {\n+void Parse::jump_if_always_fork(int dest_bci, bool unc) {\n@@ -291,1 +289,0 @@\n-    profile_switch_case(prof_table_index);\n@@ -306,4 +303,0 @@\n-\/\/ Default value for methodData switch indexing. Must be a negative value to avoid\n-\/\/ conflict with any legal switch index.\n-#define NullTableIndex -1\n-\n@@ -315,1 +308,0 @@\n-  int _table_index;             \/\/ index into method data table\n@@ -322,1 +314,0 @@\n-  int  table_index() const     { return _table_index; }\n@@ -326,1 +317,1 @@\n-  void setRange(jint lo, jint hi, int dest, int table_index, float cnt) {\n+  void setRange(jint lo, jint hi, int dest, float cnt) {\n@@ -328,1 +319,1 @@\n-    _lo = lo, _hi = hi; _dest = dest; _table_index = table_index; _cnt = cnt;\n+    _lo = lo, _hi = hi; _dest = dest; _cnt = cnt;\n@@ -331,1 +322,1 @@\n-  bool adjoinRange(jint lo, jint hi, int dest, int table_index, float cnt, bool trim_ranges) {\n+  bool adjoinRange(jint lo, jint hi, int dest, float cnt, bool trim_ranges) {\n@@ -333,1 +324,1 @@\n-    if (lo == _hi+1 && table_index == _table_index) {\n+    if (lo == _hi+1) {\n@@ -363,2 +354,2 @@\n-  void set (jint value, int dest, int table_index, float cnt) {\n-    setRange(value, value, dest, table_index, cnt);\n+  void set (jint value, int dest, float cnt) {\n+    setRange(value, value, dest, cnt);\n@@ -366,2 +357,2 @@\n-  bool adjoin(jint value, int dest, int table_index, float cnt, bool trim_ranges) {\n-    return adjoinRange(value, value, dest, table_index, cnt, trim_ranges);\n+  bool adjoin(jint value, int dest, float cnt, bool trim_ranges) {\n+    return adjoinRange(value, value, dest, cnt, trim_ranges);\n@@ -370,1 +361,1 @@\n-    return adjoinRange(other._lo, other._hi, other._dest, other._table_index, other._cnt, false);\n+    return adjoinRange(other._lo, other._hi, other._dest, other._cnt, false);\n@@ -421,1 +412,1 @@\n-      r.setRange(r.lo(), r.hi(), never_reached, r.table_index(), r.cnt());\n+      r.setRange(r.lo(), r.hi(), never_reached, r.cnt());\n@@ -450,1 +441,1 @@\n-  bool trim_ranges = !method_data_update() && !C->too_many_traps(method(), bci(), Deoptimization::Reason_unstable_if);\n+  bool trim_ranges = !C->too_many_traps(method(), bci(), Deoptimization::Reason_unstable_if);\n@@ -462,1 +453,1 @@\n-    ranges[++rp].setRange(min_jint, lo_index-1, default_dest, NullTableIndex, cnt);\n+    ranges[++rp].setRange(min_jint, lo_index-1, default_dest, cnt);\n@@ -468,1 +459,0 @@\n-    int  table_index = method_data_update() ? j : NullTableIndex;\n@@ -473,2 +463,2 @@\n-    if (rp < 0 || !ranges[rp].adjoin(match_int, dest, table_index, cnt, trim_ranges)) {\n-      ranges[++rp].set(match_int, dest, table_index, cnt);\n+    if (rp < 0 || !ranges[rp].adjoin(match_int, dest, cnt, trim_ranges)) {\n+      ranges[++rp].set(match_int, dest, cnt);\n@@ -484,2 +474,2 @@\n-    if (!ranges[rp].adjoinRange(highest+1, max_jint, default_dest, NullTableIndex, cnt, trim_ranges)) {\n-      ranges[++rp].setRange(highest+1, max_jint, default_dest, NullTableIndex, cnt);\n+    if (!ranges[rp].adjoinRange(highest+1, max_jint, default_dest, cnt, trim_ranges)) {\n+      ranges[++rp].setRange(highest+1, max_jint, default_dest, cnt);\n@@ -523,1 +513,1 @@\n-  bool trim_ranges = !method_data_update() && !C->too_many_traps(method(), bci(), Deoptimization::Reason_unstable_if);\n+  bool trim_ranges = !C->too_many_traps(method(), bci(), Deoptimization::Reason_unstable_if);\n@@ -563,1 +553,0 @@\n-    int  table_index = method_data_update() ? j : NullTableIndex;\n@@ -566,1 +555,1 @@\n-    if (match_int != next_lo && (rp < 0 || !ranges[rp].adjoinRange(next_lo, match_int-1, default_dest, NullTableIndex, c, trim_ranges))) {\n+    if (match_int != next_lo && (rp < 0 || !ranges[rp].adjoinRange(next_lo, match_int-1, default_dest, c, trim_ranges))) {\n@@ -568,1 +557,1 @@\n-      ranges[++rp].setRange(next_lo, match_int-1, default_dest, NullTableIndex, c);\n+      ranges[++rp].setRange(next_lo, match_int-1, default_dest, c);\n@@ -570,1 +559,1 @@\n-    if (rp < 0 || !ranges[rp].adjoin(match_int, dest, table_index, cnt, trim_ranges)) {\n+    if (rp < 0 || !ranges[rp].adjoin(match_int, dest, cnt, trim_ranges)) {\n@@ -572,1 +561,1 @@\n-      ranges[++rp].set(match_int, dest, table_index, cnt);\n+      ranges[++rp].set(match_int, dest, cnt);\n@@ -578,2 +567,2 @@\n-      !ranges[rp].adjoinRange(highest+1, max_jint, default_dest, NullTableIndex, default_cnt * ((float)max_jint - highest), trim_ranges)) {\n-    ranges[++rp].setRange(highest+1, max_jint, default_dest, NullTableIndex, default_cnt * ((float)max_jint - highest));\n+      !ranges[rp].adjoinRange(highest+1, max_jint, default_dest, default_cnt * ((float)max_jint - highest), trim_ranges)) {\n+    ranges[++rp].setRange(highest+1, max_jint, default_dest, default_cnt * ((float)max_jint - highest));\n@@ -738,1 +727,1 @@\n-          prev.setRange(prev.lo(), sr->hi(), prev.dest(), prev.table_index(), prev.cnt());\n+          prev.setRange(prev.lo(), sr->hi(), prev.dest(), prev.cnt());\n@@ -765,1 +754,1 @@\n-    jump_if_true_fork(iff, most_freq.dest(), most_freq.table_index(), false);\n+    jump_if_true_fork(iff, most_freq.dest(), false);\n@@ -781,3 +770,0 @@\n-  \/\/ Don't make jump table if profiling\n-  if (method_data_update())  return false;\n-\n@@ -861,1 +847,1 @@\n-    jump_if_true_fork(iff, default_dest, NullTableIndex, trim_ranges && trimmed_cnt == 0);\n+    jump_if_true_fork(iff, default_dest, trim_ranges && trimmed_cnt == 0);\n@@ -921,1 +907,1 @@\n-        jump_if_always_fork(r->dest(), r->table_index(), trim_ranges && r->cnt() == 0);\n+        jump_if_always_fork(r->dest(), trim_ranges && r->cnt() == 0);\n@@ -933,1 +919,1 @@\n-  bool trim_ranges = !method_data_update() && !C->too_many_traps(method(), bci(), Deoptimization::Reason_unstable_if);\n+  bool trim_ranges = !C->too_many_traps(method(), bci(), Deoptimization::Reason_unstable_if);\n@@ -974,1 +960,1 @@\n-      lo->setRange(min_val, lo->hi(), lo->dest(), lo->table_index(), lo->cnt());\n+      lo->setRange(min_val, lo->hi(), lo->dest(), lo->cnt());\n@@ -980,1 +966,1 @@\n-      hi->setRange(hi->lo(), max_val, hi->dest(), hi->table_index(), hi->cnt());\n+      hi->setRange(hi->lo(), max_val, hi->dest(), hi->cnt());\n@@ -995,1 +981,1 @@\n-    jump_if_always_fork(lo->dest(), lo->table_index(), trim_ranges && lo->cnt() == 0);\n+    jump_if_always_fork(lo->dest(), trim_ranges && lo->cnt() == 0);\n@@ -1033,1 +1019,1 @@\n-      jump_if_false_fork(iff_ne, mid->dest(), mid->table_index(), trim_ranges && mid->cnt() == 0);\n+      jump_if_false_fork(iff_ne, mid->dest(), trim_ranges && mid->cnt() == 0);\n@@ -1062,1 +1048,1 @@\n-        jump_if_true_fork(iff_ge, mid->dest(), mid->table_index(), trim_ranges && cnt == 0);\n+        jump_if_true_fork(iff_ge, mid->dest(), trim_ranges && cnt == 0);\n@@ -1079,1 +1065,1 @@\n-        jump_if_always_fork(lo->dest(), lo->table_index(), trim_ranges && lo->cnt() == 0);\n+        jump_if_always_fork(lo->dest(), trim_ranges && lo->cnt() == 0);\n@@ -1214,3 +1200,0 @@\n-  \/\/ Update method data\n-  profile_taken_branch(jsr_bci);\n-\n@@ -1238,1 +1221,0 @@\n-  profile_ret(target->flow()->start());\n@@ -1450,5 +1432,0 @@\n-    \/\/ We need to mark this branch as taken so that if we recompile we will\n-    \/\/ see that it is possible. In the tiered system the interpreter doesn't\n-    \/\/ do profiling and by the time we get to the lower tier from the interpreter\n-    \/\/ the path may be cold again. Make sure it doesn't look untaken\n-    profile_taken_branch(target_bci, !ProfileInterpreter);\n@@ -1488,2 +1465,0 @@\n-      \/\/ Update method data\n-      profile_taken_branch(target_bci);\n@@ -1508,2 +1483,0 @@\n-    \/\/ Update method data\n-    profile_not_taken_branch();\n@@ -1531,5 +1504,0 @@\n-    \/\/ We need to mark this branch as taken so that if we recompile we will\n-    \/\/ see that it is possible. In the tiered system the interpreter doesn't\n-    \/\/ do profiling and by the time we get to the lower tier from the interpreter\n-    \/\/ the path may be cold again. Make sure it doesn't look untaken\n-    profile_taken_branch(target_bci, !ProfileInterpreter);\n@@ -1610,2 +1578,0 @@\n-      \/\/ Update method data\n-      profile_taken_branch(target_bci);\n@@ -1629,2 +1595,0 @@\n-    \/\/ Update method data\n-    profile_not_taken_branch();\n@@ -2694,3 +2658,0 @@\n-    \/\/ Update method data\n-    profile_taken_branch(target_bci);\n-\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":37,"deletions":76,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -89,3 +89,0 @@\n-    if (!stopped()) {\n-      profile_null_checkcast();\n-    }\n@@ -302,284 +299,0 @@\n-\n-\/\/=============================================================================\n-\/\/\n-\/\/ parser methods for profiling\n-\n-\n-\/\/----------------------test_counter_against_threshold ------------------------\n-void Parse::test_counter_against_threshold(Node* cnt, int limit) {\n-  \/\/ Test the counter against the limit and uncommon trap if greater.\n-\n-  \/\/ This code is largely copied from the range check code in\n-  \/\/ array_addressing()\n-\n-  \/\/ Test invocation count vs threshold\n-  Node *threshold = makecon(TypeInt::make(limit));\n-  Node *chk   = _gvn.transform( new CmpUNode( cnt, threshold) );\n-  BoolTest::mask btest = BoolTest::lt;\n-  Node *tst   = _gvn.transform( new BoolNode( chk, btest) );\n-  \/\/ Branch to failure if threshold exceeded\n-  { BuildCutout unless(this, tst, PROB_ALWAYS);\n-    uncommon_trap(Deoptimization::Reason_age,\n-                  Deoptimization::Action_maybe_recompile);\n-  }\n-}\n-\n-\/\/----------------------increment_and_test_invocation_counter-------------------\n-void Parse::increment_and_test_invocation_counter(int limit) {\n-  if (!count_invocations()) return;\n-\n-  \/\/ Get the Method* node.\n-  ciMethod* m = method();\n-  MethodCounters* counters_adr = m->ensure_method_counters();\n-  if (counters_adr == NULL) {\n-    C->record_failure(\"method counters allocation failed\");\n-    return;\n-  }\n-\n-  Node* ctrl = control();\n-  const TypePtr* adr_type = TypeRawPtr::make((address) counters_adr);\n-  Node *counters_node = makecon(adr_type);\n-  Node* adr_iic_node = basic_plus_adr(counters_node, counters_node,\n-    MethodCounters::interpreter_invocation_counter_offset_in_bytes());\n-  Node* cnt = make_load(ctrl, adr_iic_node, TypeInt::INT, T_INT, adr_type, MemNode::unordered);\n-\n-  test_counter_against_threshold(cnt, limit);\n-\n-  \/\/ Add one to the counter and store\n-  Node* incr = _gvn.transform(new AddINode(cnt, _gvn.intcon(1)));\n-  store_to_memory(ctrl, adr_iic_node, incr, T_INT, adr_type, MemNode::unordered);\n-}\n-\n-\/\/----------------------------method_data_addressing---------------------------\n-Node* Parse::method_data_addressing(ciMethodData* md, ciProfileData* data, ByteSize counter_offset, Node* idx, uint stride) {\n-  \/\/ Get offset within MethodData* of the data array\n-  ByteSize data_offset = MethodData::data_offset();\n-\n-  \/\/ Get cell offset of the ProfileData within data array\n-  int cell_offset = md->dp_to_di(data->dp());\n-\n-  \/\/ Add in counter_offset, the # of bytes into the ProfileData of counter or flag\n-  int offset = in_bytes(data_offset) + cell_offset + in_bytes(counter_offset);\n-\n-  const TypePtr* adr_type = TypeMetadataPtr::make(md);\n-  Node* mdo = makecon(adr_type);\n-  Node* ptr = basic_plus_adr(mdo, mdo, offset);\n-\n-  if (stride != 0) {\n-    Node* str = _gvn.MakeConX(stride);\n-    Node* scale = _gvn.transform( new MulXNode( idx, str ) );\n-    ptr   = _gvn.transform( new AddPNode( mdo, ptr, scale ) );\n-  }\n-\n-  return ptr;\n-}\n-\n-\/\/--------------------------increment_md_counter_at----------------------------\n-void Parse::increment_md_counter_at(ciMethodData* md, ciProfileData* data, ByteSize counter_offset, Node* idx, uint stride) {\n-  Node* adr_node = method_data_addressing(md, data, counter_offset, idx, stride);\n-\n-  const TypePtr* adr_type = _gvn.type(adr_node)->is_ptr();\n-  Node* cnt  = make_load(NULL, adr_node, TypeInt::INT, T_INT, adr_type, MemNode::unordered);\n-  Node* incr = _gvn.transform(new AddINode(cnt, _gvn.intcon(DataLayout::counter_increment)));\n-  store_to_memory(NULL, adr_node, incr, T_INT, adr_type, MemNode::unordered);\n-}\n-\n-\/\/--------------------------test_for_osr_md_counter_at-------------------------\n-void Parse::test_for_osr_md_counter_at(ciMethodData* md, ciProfileData* data, ByteSize counter_offset, int limit) {\n-  Node* adr_node = method_data_addressing(md, data, counter_offset);\n-\n-  const TypePtr* adr_type = _gvn.type(adr_node)->is_ptr();\n-  Node* cnt  = make_load(NULL, adr_node, TypeInt::INT, T_INT, adr_type, MemNode::unordered);\n-\n-  test_counter_against_threshold(cnt, limit);\n-}\n-\n-\/\/-------------------------------set_md_flag_at--------------------------------\n-void Parse::set_md_flag_at(ciMethodData* md, ciProfileData* data, int flag_constant) {\n-  Node* adr_node = method_data_addressing(md, data, DataLayout::flags_offset());\n-\n-  const TypePtr* adr_type = _gvn.type(adr_node)->is_ptr();\n-  Node* flags = make_load(NULL, adr_node, TypeInt::INT, T_INT, adr_type, MemNode::unordered);\n-  Node* incr = _gvn.transform(new OrINode(flags, _gvn.intcon(flag_constant)));\n-  store_to_memory(NULL, adr_node, incr, T_INT, adr_type, MemNode::unordered);\n-}\n-\n-\/\/----------------------------profile_taken_branch-----------------------------\n-void Parse::profile_taken_branch(int target_bci, bool force_update) {\n-  \/\/ This is a potential osr_site if we have a backedge.\n-  int cur_bci = bci();\n-  bool osr_site =\n-    (target_bci <= cur_bci) && count_invocations() && UseOnStackReplacement;\n-\n-  \/\/ If we are going to OSR, restart at the target bytecode.\n-  set_bci(target_bci);\n-\n-  \/\/ To do: factor out the the limit calculations below. These duplicate\n-  \/\/ the similar limit calculations in the interpreter.\n-\n-  if (method_data_update() || force_update) {\n-    ciMethodData* md = method()->method_data();\n-    assert(md != NULL, \"expected valid ciMethodData\");\n-    ciProfileData* data = md->bci_to_data(cur_bci);\n-    assert(data != NULL && data->is_JumpData(), \"need JumpData for taken branch\");\n-    increment_md_counter_at(md, data, JumpData::taken_offset());\n-  }\n-\n-  \/\/ In the new tiered system this is all we need to do. In the old\n-  \/\/ (c2 based) tiered sytem we must do the code below.\n-#ifndef TIERED\n-  if (method_data_update()) {\n-    ciMethodData* md = method()->method_data();\n-    if (osr_site) {\n-      ciProfileData* data = md->bci_to_data(cur_bci);\n-      assert(data != NULL && data->is_JumpData(), \"need JumpData for taken branch\");\n-      int limit = (int)((int64_t)CompileThreshold\n-                   * (OnStackReplacePercentage - InterpreterProfilePercentage) \/ 100);\n-      test_for_osr_md_counter_at(md, data, JumpData::taken_offset(), limit);\n-    }\n-  } else {\n-    \/\/ With method data update off, use the invocation counter to trigger an\n-    \/\/ OSR compilation, as done in the interpreter.\n-    if (osr_site) {\n-      int limit = (int)((int64_t)CompileThreshold * OnStackReplacePercentage \/ 100);\n-      increment_and_test_invocation_counter(limit);\n-    }\n-  }\n-#endif \/\/ TIERED\n-\n-  \/\/ Restore the original bytecode.\n-  set_bci(cur_bci);\n-}\n-\n-\/\/--------------------------profile_not_taken_branch---------------------------\n-void Parse::profile_not_taken_branch(bool force_update) {\n-\n-  if (method_data_update() || force_update) {\n-    ciMethodData* md = method()->method_data();\n-    assert(md != NULL, \"expected valid ciMethodData\");\n-    ciProfileData* data = md->bci_to_data(bci());\n-    assert(data != NULL && data->is_BranchData(), \"need BranchData for not taken branch\");\n-    increment_md_counter_at(md, data, BranchData::not_taken_offset());\n-  }\n-\n-}\n-\n-\/\/---------------------------------profile_call--------------------------------\n-void Parse::profile_call(Node* receiver) {\n-  if (!method_data_update()) return;\n-\n-  switch (bc()) {\n-  case Bytecodes::_invokevirtual:\n-  case Bytecodes::_invokeinterface:\n-    profile_receiver_type(receiver);\n-    break;\n-  case Bytecodes::_invokestatic:\n-  case Bytecodes::_invokedynamic:\n-  case Bytecodes::_invokespecial:\n-    profile_generic_call();\n-    break;\n-  default: fatal(\"unexpected call bytecode\");\n-  }\n-}\n-\n-\/\/------------------------------profile_generic_call---------------------------\n-void Parse::profile_generic_call() {\n-  assert(method_data_update(), \"must be generating profile code\");\n-\n-  ciMethodData* md = method()->method_data();\n-  assert(md != NULL, \"expected valid ciMethodData\");\n-  ciProfileData* data = md->bci_to_data(bci());\n-  assert(data != NULL && data->is_CounterData(), \"need CounterData for not taken branch\");\n-  increment_md_counter_at(md, data, CounterData::count_offset());\n-}\n-\n-\/\/-----------------------------profile_receiver_type---------------------------\n-void Parse::profile_receiver_type(Node* receiver) {\n-  assert(method_data_update(), \"must be generating profile code\");\n-\n-  ciMethodData* md = method()->method_data();\n-  assert(md != NULL, \"expected valid ciMethodData\");\n-  ciProfileData* data = md->bci_to_data(bci());\n-  assert(data != NULL && data->is_ReceiverTypeData(), \"need ReceiverTypeData here\");\n-\n-  \/\/ Skip if we aren't tracking receivers\n-  if (TypeProfileWidth < 1) {\n-    increment_md_counter_at(md, data, CounterData::count_offset());\n-    return;\n-  }\n-  ciReceiverTypeData* rdata = (ciReceiverTypeData*)data->as_ReceiverTypeData();\n-\n-  Node* method_data = method_data_addressing(md, rdata, in_ByteSize(0));\n-\n-  \/\/ Using an adr_type of TypePtr::BOTTOM to work around anti-dep problems.\n-  \/\/ A better solution might be to use TypeRawPtr::BOTTOM with RC_NARROW_MEM.\n-  make_runtime_call(RC_LEAF, OptoRuntime::profile_receiver_type_Type(),\n-                    CAST_FROM_FN_PTR(address,\n-                                     OptoRuntime::profile_receiver_type_C),\n-                    \"profile_receiver_type_C\",\n-                    TypePtr::BOTTOM,\n-                    method_data, receiver);\n-}\n-\n-\/\/---------------------------------profile_ret---------------------------------\n-void Parse::profile_ret(int target_bci) {\n-  if (!method_data_update()) return;\n-\n-  \/\/ Skip if we aren't tracking ret targets\n-  if (TypeProfileWidth < 1) return;\n-\n-  ciMethodData* md = method()->method_data();\n-  assert(md != NULL, \"expected valid ciMethodData\");\n-  ciProfileData* data = md->bci_to_data(bci());\n-  assert(data != NULL && data->is_RetData(), \"need RetData for ret\");\n-  ciRetData* ret_data = (ciRetData*)data->as_RetData();\n-\n-  \/\/ Look for the target_bci is already in the table\n-  uint row;\n-  bool table_full = true;\n-  for (row = 0; row < ret_data->row_limit(); row++) {\n-    int key = ret_data->bci(row);\n-    table_full &= (key != RetData::no_bci);\n-    if (key == target_bci) break;\n-  }\n-\n-  if (row >= ret_data->row_limit()) {\n-    \/\/ The target_bci was not found in the table.\n-    if (!table_full) {\n-      \/\/ XXX: Make slow call to update RetData\n-    }\n-    return;\n-  }\n-\n-  \/\/ the target_bci is already in the table\n-  increment_md_counter_at(md, data, RetData::bci_count_offset(row));\n-}\n-\n-\/\/--------------------------profile_null_checkcast----------------------------\n-void Parse::profile_null_checkcast() {\n-  \/\/ Set the null-seen flag, done in conjunction with the usual null check. We\n-  \/\/ never unset the flag, so this is a one-way switch.\n-  if (!method_data_update()) return;\n-\n-  ciMethodData* md = method()->method_data();\n-  assert(md != NULL, \"expected valid ciMethodData\");\n-  ciProfileData* data = md->bci_to_data(bci());\n-  assert(data != NULL && data->is_BitData(), \"need BitData for checkcast\");\n-  set_md_flag_at(md, data, BitData::null_seen_byte_constant());\n-}\n-\n-\/\/-----------------------------profile_switch_case-----------------------------\n-void Parse::profile_switch_case(int table_index) {\n-  if (!method_data_update()) return;\n-\n-  ciMethodData* md = method()->method_data();\n-  assert(md != NULL, \"expected valid ciMethodData\");\n-\n-  ciProfileData* data = md->bci_to_data(bci());\n-  assert(data != NULL && data->is_MultiBranchData(), \"need MultiBranchData for switch case\");\n-  if (table_index >= 0) {\n-    increment_md_counter_at(md, data, MultiBranchData::case_count_offset(table_index));\n-  } else {\n-    increment_md_counter_at(md, data, MultiBranchData::default_count_offset());\n-  }\n-}\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":0,"deletions":287,"binary":false,"changes":287,"status":"modified"},{"patch":"@@ -1213,54 +1213,0 @@\n-\/\/-------------- methodData update helpers\n-\n-const TypeFunc* OptoRuntime::profile_receiver_type_Type() {\n-  \/\/ create input type (domain)\n-  const Type **fields = TypeTuple::fields(2);\n-  fields[TypeFunc::Parms+0] = TypeAryPtr::NOTNULL;    \/\/ methodData pointer\n-  fields[TypeFunc::Parms+1] = TypeInstPtr::BOTTOM;    \/\/ receiver oop\n-  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);\n-\n-  \/\/ create result type\n-  fields = TypeTuple::fields(1);\n-  fields[TypeFunc::Parms+0] = NULL; \/\/ void\n-  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms, fields);\n-  return TypeFunc::make(domain,range);\n-}\n-\n-JRT_LEAF(void, OptoRuntime::profile_receiver_type_C(DataLayout* data, oopDesc* receiver))\n-  if (receiver == NULL) return;\n-  Klass* receiver_klass = receiver->klass();\n-\n-  intptr_t* mdp = ((intptr_t*)(data)) + DataLayout::header_size_in_cells();\n-  int empty_row = -1;           \/\/ free row, if any is encountered\n-\n-  \/\/ ReceiverTypeData* vc = new ReceiverTypeData(mdp);\n-  for (uint row = 0; row < ReceiverTypeData::row_limit(); row++) {\n-    \/\/ if (vc->receiver(row) == receiver_klass)\n-    int receiver_off = ReceiverTypeData::receiver_cell_index(row);\n-    intptr_t row_recv = *(mdp + receiver_off);\n-    if (row_recv == (intptr_t) receiver_klass) {\n-      \/\/ vc->set_receiver_count(row, vc->receiver_count(row) + DataLayout::counter_increment);\n-      int count_off = ReceiverTypeData::receiver_count_cell_index(row);\n-      *(mdp + count_off) += DataLayout::counter_increment;\n-      return;\n-    } else if (row_recv == 0) {\n-      \/\/ else if (vc->receiver(row) == NULL)\n-      empty_row = (int) row;\n-    }\n-  }\n-\n-  if (empty_row != -1) {\n-    int receiver_off = ReceiverTypeData::receiver_cell_index(empty_row);\n-    \/\/ vc->set_receiver(empty_row, receiver_klass);\n-    *(mdp + receiver_off) = (intptr_t) receiver_klass;\n-    \/\/ vc->set_receiver_count(empty_row, DataLayout::counter_increment);\n-    int count_off = ReceiverTypeData::receiver_count_cell_index(empty_row);\n-    *(mdp + count_off) = DataLayout::counter_increment;\n-  } else {\n-    \/\/ Receiver did not match any saved receiver and there is no empty row for it.\n-    \/\/ Increment total counter to indicate polymorphic case.\n-    intptr_t* count_p = (intptr_t*)(((uint8_t*)(data)) + in_bytes(CounterData::count_offset()));\n-    *count_p += DataLayout::counter_increment;\n-  }\n-JRT_END\n-\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":0,"deletions":54,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -232,3 +232,0 @@\n-  \/\/ Leaf routines helping with method data update\n-  static void profile_receiver_type_C(DataLayout* data, oopDesc* receiver);\n-\n@@ -307,3 +304,0 @@\n-  \/\/ leaf methodData routine types\n-  static const TypeFunc* profile_receiver_type_Type();\n-\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -94,0 +94,2 @@\n+static const bool _do_vector_loop_experimental = false; \/\/ Experimental vectorization which uses data from loop unrolling.\n+\n@@ -473,1 +475,1 @@\n-    if (_do_vector_loop) {\n+    if (_do_vector_loop_experimental) {\n@@ -511,1 +513,1 @@\n-    if (_do_vector_loop) {\n+    if (_do_vector_loop_experimental) {\n@@ -513,0 +515,1 @@\n+#ifndef PRODUCT\n@@ -516,0 +519,1 @@\n+#endif\n@@ -1726,1 +1730,8 @@\n-      assert(my_pack(s) == NULL, \"only in one pack\");\n+#ifdef ASSERT\n+      if (my_pack(s) != NULL) {\n+        s->dump(1);\n+        tty->print_cr(\"packs[%d]:\", i);\n+        print_pack(p);\n+        assert(false, \"only in one pack\");\n+      }\n+#endif\n@@ -1741,1 +1752,1 @@\n-      if (TraceSuperWord && Verbose) {\n+      if ((TraceSuperWord && Verbose) || _vector_loop_debug) {\n@@ -1765,1 +1776,1 @@\n-        if (TraceSuperWord && Verbose) {\n+        if ((TraceSuperWord && Verbose) || _vector_loop_debug) {\n@@ -3055,1 +3066,2 @@\n-  _ii_order.clear();\n+  \/\/ Build iterations order if needed\n+  bool build_ii_order = _do_vector_loop_experimental && _ii_order.is_empty();\n@@ -3060,1 +3072,1 @@\n-    if (_do_vector_loop && n->is_Load()) {\n+    if (build_ii_order && n->is_Load()) {\n@@ -4703,0 +4715,9 @@\n+  if (_ii_order.is_empty()) {\n+#ifndef PRODUCT\n+    if (_vector_loop_debug) {\n+      tty->print_cr(\"SuperWord::pack_parallel: EMPTY\");\n+    }\n+#endif\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":28,"deletions":7,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -3049,3 +3049,5 @@\n-          assert(o != NULL, \"must be constant\");\n-          ciInstanceKlass* k = o->as_instance()->java_lang_Class_klass()->as_instance_klass();\n-          ciField* field = k->get_field_by_offset(_offset, true);\n+          ciField* field = NULL;\n+          if (const_oop() != NULL) {\n+            ciInstanceKlass* k = const_oop()->as_instance()->java_lang_Class_klass()->as_instance_klass();\n+            field = k->get_field_by_offset(_offset, true);\n+          }\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -103,1 +103,4 @@\n-  assert(vec_klass->const_oop()->as_instance()->java_lang_Class_klass(), \"klass instance expected\");\n+  if (vec_klass->const_oop() == NULL) {\n+    return false; \/\/ uninitialized or some kind of unsafe access\n+  }\n+  assert(vec_klass->const_oop()->as_instance()->java_lang_Class_klass() != NULL, \"klass instance expected\");\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1656,11 +1656,3 @@\n-  if (eb.barrier_active()) {\n-    if (java_thread->frames_to_pop_failed_realloc() > 0) {\n-      \/\/ VM is in the process of popping the top frame because it has scalar replaced objects which\n-      \/\/ could not be reallocated on the heap.\n-      \/\/ Return JVMTI_ERROR_OUT_OF_MEMORY to avoid interfering with the VM.\n-      return JVMTI_ERROR_OUT_OF_MEMORY;\n-    }\n-    if (!eb.deoptimize_objects(1)) {\n-      \/\/ Reallocation of scalar replaced objects failed -> return with error\n-      return JVMTI_ERROR_OUT_OF_MEMORY;\n-    }\n+  if (!eb.deoptimize_objects(1)) {\n+    \/\/ Reallocation of scalar replaced objects failed -> return with error\n+    return JVMTI_ERROR_OUT_OF_MEMORY;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1381,11 +1381,3 @@\n-  if (eb.barrier_active()) {\n-    if (java_thread->frames_to_pop_failed_realloc() > 0) {\n-      \/\/ VM is in the process of popping the top frame because it has scalar replaced objects\n-      \/\/ which could not be reallocated on the heap.\n-      \/\/ Return JVMTI_ERROR_OUT_OF_MEMORY to avoid interfering with the VM.\n-      return JVMTI_ERROR_OUT_OF_MEMORY;\n-    }\n-    if (!eb.deoptimize_objects(0)) {\n-      \/\/ Reallocation of scalar replaced objects failed -> return with error\n-      return JVMTI_ERROR_OUT_OF_MEMORY;\n-    }\n+  if (!eb.deoptimize_objects(0)) {\n+    \/\/ Reallocation of scalar replaced objects failed -> return with error\n+    return JVMTI_ERROR_OUT_OF_MEMORY;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -631,6 +631,3 @@\n-\/\/ Revert optimizations based on escape analysis if this is an access to a local object\n-bool VM_GetOrSetLocal::deoptimize_objects(javaVFrame* jvf) {\n-#if COMPILER2_OR_JVMCI\n-  assert(_type == T_OBJECT, \"EscapeBarrier should not be active if _type != T_OBJECT\");\n-  if (_depth < _thread->frames_to_pop_failed_realloc()) {\n-    \/\/ cannot access frame with failed reallocations\n+bool VM_GetOrSetLocal::doit_prologue() {\n+  if (!_eb.deoptimize_objects(_depth, _depth)) {\n+    \/\/ The target frame is affected by a reallocation failure.\n@@ -640,43 +637,0 @@\n-  if (can_be_deoptimized(jvf)) {\n-    compiledVFrame* cf = compiledVFrame::cast(jvf);\n-    if (cf->has_ea_local_in_scope() && !_eb.deoptimize_objects(cf->fr().id())) {\n-      \/\/ reallocation of scalar replaced objects failed because heap is exhausted\n-      _result = JVMTI_ERROR_OUT_OF_MEMORY;\n-      return false;\n-    }\n-  }\n-\n-  \/\/ With this access the object could escape the thread changing its escape state from ArgEscape,\n-  \/\/ to GlobalEscape so we must deoptimize callers which could have optimized on the escape state.\n-  vframe* vf = jvf;\n-  do {\n-    \/\/ move to next physical frame\n-    while(!vf->is_top()) {\n-      vf = vf->sender();\n-    }\n-    vf = vf->sender();\n-\n-    if (vf != NULL && vf->is_compiled_frame()) {\n-      compiledVFrame* cvf = compiledVFrame::cast(vf);\n-      \/\/ Deoptimize objects if arg escape is being passed down the stack.\n-      \/\/ Note that deoptimizing the frame is not enough because objects need to be relocked\n-      if (cvf->arg_escape() && !_eb.deoptimize_objects(cvf->fr().id())) {\n-        \/\/ reallocation of scalar replaced objects failed because heap is exhausted\n-        _result = JVMTI_ERROR_OUT_OF_MEMORY;\n-        return false;\n-      }\n-    }\n-  } while(vf != NULL && !vf->is_entry_frame());\n-#endif \/\/ COMPILER2_OR_JVMCI\n-  return true;\n-}\n-\n-bool VM_GetOrSetLocal::doit_prologue() {\n-  if (_eb.barrier_active()) {\n-    _jvf = get_java_vframe();\n-    NULL_CHECK(_jvf, false);\n-\n-    if (!deoptimize_objects(_jvf)) {\n-      return false;\n-    }\n-  }\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":3,"deletions":49,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -337,1 +337,0 @@\n-  bool deoptimize_objects(javaVFrame* vf);\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1248,1 +1248,1 @@\n-  JVMFlag::Error result = JVMFlagAccess::set<T, type_enum>(flag, value, JVMFlag::INTERNAL);\n+  JVMFlag::Error result = JVMFlagAccess::set<T, type_enum>(flag, value, JVMFlagOrigin::INTERNAL);\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -880,1 +880,1 @@\n-static bool set_bool_flag(JVMFlag* flag, bool value, JVMFlag::Flags origin) {\n+static bool set_bool_flag(JVMFlag* flag, bool value, JVMFlagOrigin origin) {\n@@ -888,1 +888,1 @@\n-static bool set_fp_numeric_flag(JVMFlag* flag, char* value, JVMFlag::Flags origin) {\n+static bool set_fp_numeric_flag(JVMFlag* flag, char* value, JVMFlagOrigin origin) {\n@@ -902,1 +902,1 @@\n-static bool set_numeric_flag(JVMFlag* flag, char* value, JVMFlag::Flags origin) {\n+static bool set_numeric_flag(JVMFlag* flag, char* value, JVMFlagOrigin origin) {\n@@ -955,1 +955,1 @@\n-static bool set_string_flag(JVMFlag* flag, const char* value, JVMFlag::Flags origin) {\n+static bool set_string_flag(JVMFlag* flag, const char* value, JVMFlagOrigin origin) {\n@@ -962,1 +962,1 @@\n-static bool append_to_string_flag(JVMFlag* flag, const char* new_value, JVMFlag::Flags origin) {\n+static bool append_to_string_flag(JVMFlag* flag, const char* new_value, JVMFlagOrigin origin) {\n@@ -1063,1 +1063,1 @@\n-bool Arguments::parse_argument(const char* arg, JVMFlag::Flags origin) {\n+bool Arguments::parse_argument(const char* arg, JVMFlagOrigin origin) {\n@@ -1278,1 +1278,1 @@\n-                                 JVMFlag::Flags origin) {\n+                                 JVMFlagOrigin origin) {\n@@ -1407,1 +1407,1 @@\n-        result &= process_argument(token, ignore_unrecognized, JVMFlag::CONFIG_FILE);\n+        result &= process_argument(token, ignore_unrecognized, JVMFlagOrigin::CONFIG_FILE);\n@@ -1425,1 +1425,1 @@\n-    result &= process_argument(token, ignore_unrecognized, JVMFlag::CONFIG_FILE);\n+    result &= process_argument(token, ignore_unrecognized, JVMFlagOrigin::CONFIG_FILE);\n@@ -1662,4 +1662,0 @@\n-\n-  if (SurvivorAlignmentInBytes == 0) {\n-    SurvivorAlignmentInBytes = ObjectAlignmentInBytes;\n-  }\n@@ -2295,1 +2291,1 @@\n-  jint result = parse_each_vm_init_arg(vm_options_args, &patch_mod_javabase, JVMFlag::JIMAGE_RESOURCE);\n+  jint result = parse_each_vm_init_arg(vm_options_args, &patch_mod_javabase, JVMFlagOrigin::JIMAGE_RESOURCE);\n@@ -2302,1 +2298,1 @@\n-  result = parse_each_vm_init_arg(java_tool_options_args, &patch_mod_javabase, JVMFlag::ENVIRON_VAR);\n+  result = parse_each_vm_init_arg(java_tool_options_args, &patch_mod_javabase, JVMFlagOrigin::ENVIRON_VAR);\n@@ -2308,1 +2304,1 @@\n-  result = parse_each_vm_init_arg(cmd_line_args, &patch_mod_javabase, JVMFlag::COMMAND_LINE);\n+  result = parse_each_vm_init_arg(cmd_line_args, &patch_mod_javabase, JVMFlagOrigin::COMMAND_LINE);\n@@ -2315,1 +2311,1 @@\n-  result = parse_each_vm_init_arg(java_options_args, &patch_mod_javabase, JVMFlag::ENVIRON_VAR);\n+  result = parse_each_vm_init_arg(java_options_args, &patch_mod_javabase, JVMFlagOrigin::ENVIRON_VAR);\n@@ -2459,1 +2455,1 @@\n-jint Arguments::parse_each_vm_init_arg(const JavaVMInitArgs* args, bool* patch_mod_javabase, JVMFlag::Flags origin) {\n+jint Arguments::parse_each_vm_init_arg(const JavaVMInitArgs* args, bool* patch_mod_javabase, JVMFlagOrigin origin) {\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":14,"deletions":18,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"runtime\/flags\/jvmFlag.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"utilities\/vmEnums.hpp\"\n@@ -411,2 +411,2 @@\n-  static bool parse_argument(const char* arg, JVMFlag::Flags origin);\n-  static bool process_argument(const char* arg, jboolean ignore_unrecognized, JVMFlag::Flags origin);\n+  static bool parse_argument(const char* arg, JVMFlagOrigin origin);\n+  static bool process_argument(const char* arg, jboolean ignore_unrecognized, JVMFlagOrigin origin);\n@@ -439,1 +439,1 @@\n-  static jint parse_each_vm_init_arg(const JavaVMInitArgs* args, bool* patch_mod_javabase, JVMFlag::Flags origin);\n+  static jint parse_each_vm_init_arg(const JavaVMInitArgs* args, bool* patch_mod_javabase, JVMFlagOrigin origin);\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -221,5 +221,0 @@\n-      \/\/ Make sure the deoptee frame gets processed after a potential safepoint during\n-      \/\/ object reallocation. This is necessary because (a) deoptee_thread can be\n-      \/\/ different from the current thread and (b) the deoptee frame does not need to be\n-      \/\/ the top frame.\n-      StackWatermarkSet::finish_processing(deoptee_thread, NULL \/* context *\/, StackWatermarkKind::gc);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"runtime\/keepStackGCProcessed.hpp\"\n@@ -65,11 +66,11 @@\n-\/\/ Object references of frames up to the given depth are about to be\n-\/\/ accessed. Frames with optimizations based on escape state that is potentially\n-\/\/ changed by the accesses need to be deoptimized and the referenced objects\n-\/\/ need to be reallocated and relocked.  Up to depth this is done for frames\n-\/\/ with not escaping objects in scope. For deeper frames it is done only if\n-\/\/ they pass not escaping objects as arguments because they potentially escape\n-\/\/ from callee frames within the given depth.\n-\/\/ The search for deeper frames is ended if an entry frame is found because\n-\/\/ arguments to native methods are considered to escape globally.\n-bool EscapeBarrier::deoptimize_objects(int depth) {\n-  if (barrier_active() && deoptee_thread()->has_last_Java_frame()) {\n+\/\/ Deoptimize objects of frames of the target thread at depth >= d1 and depth <= d2.\n+\/\/ Deoptimize objects of caller frames if they passed references to ArgEscape objects as arguments.\n+\/\/ Return false in the case of a reallocation failure and true otherwise.\n+bool EscapeBarrier::deoptimize_objects(int d1, int d2) {\n+  if (!barrier_active()) return true;\n+  if (d1 < deoptee_thread()->frames_to_pop_failed_realloc()) {\n+    \/\/ The deoptee thread has frames with reallocation failures on top of its stack.\n+    \/\/ These frames are about to be removed. We must not interfere with that and signal failure.\n+    return false;\n+  }\n+  if (deoptee_thread()->has_last_Java_frame()) {\n@@ -77,0 +78,1 @@\n+    KeepStackGCProcessedMark ksgcpm(deoptee_thread());\n@@ -82,1 +84,8 @@\n-    while (vf != NULL && ((cur_depth <= depth) || !vf->is_entry_frame())) {\n+\n+    \/\/ Skip frames at depth < d1\n+    while (vf != NULL && cur_depth < d1) {\n+      cur_depth++;\n+      vf = vf->sender();\n+    }\n+\n+    while (vf != NULL && ((cur_depth <= d2) || !vf->is_entry_frame())) {\n@@ -87,1 +96,1 @@\n-        bool should_deopt = cur_depth <= depth ? cvf->has_ea_local_in_scope() : cvf->arg_escape();\n+        bool should_deopt = cur_depth <= d2 ? cvf->has_ea_local_in_scope() : cvf->arg_escape();\n@@ -112,0 +121,5 @@\n+    if (jt->frames_to_pop_failed_realloc() > 0) {\n+      \/\/ The deoptee thread jt has frames with reallocation failures on top of its stack.\n+      \/\/ These frames are about to be removed. We must not interfere with that and signal failure.\n+      return false;\n+    }\n@@ -113,0 +127,1 @@\n+      KeepStackGCProcessedMark ksgcpm(jt);\n@@ -300,1 +315,1 @@\n-  if (!barrier_active()) return true;\n+  assert(barrier_active(), \"should not call\");\n@@ -310,5 +325,1 @@\n-      if (!self_deopt()) {\n-        \/\/ Process stack of deoptee thread as we will access oops during object deoptimization.\n-        StackWatermarkSet::start_processing(deoptee, StackWatermarkKind::gc);\n-      }\n-      StackFrameStream fst(deoptee, true \/* update *\/, true \/* process_frames *\/);\n+      StackFrameStream fst(deoptee, true \/* update *\/, false \/* process_frames *\/);\n","filename":"src\/hotspot\/share\/runtime\/escapeBarrier.cpp","additions":30,"deletions":19,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -64,0 +64,6 @@\n+  \/\/ Deoptimize objects, i.e. reallocate and relock them. The target frames are deoptimized.\n+  \/\/ The methods return false iff at least one reallocation failed.\n+  bool deoptimize_objects(intptr_t* fr_id) {\n+    return deoptimize_objects_internal(deoptee_thread(), fr_id);\n+  }\n+\n@@ -92,4 +98,5 @@\n-  \/\/ Deoptimize objects, i.e. reallocate and relock them. The target frames are deoptimized.\n-  \/\/ The methods return false iff at least one reallocation failed.\n-  bool deoptimize_objects(intptr_t* fr_id) {\n-    return true COMPILER2_OR_JVMCI_PRESENT(&& deoptimize_objects_internal(deoptee_thread(), fr_id));\n+  \/\/ Deoptimize objects of frames of the target thread up to the given depth.\n+  \/\/ Deoptimize objects of caller frames if they passed references to ArgEscape objects as arguments.\n+  \/\/ Return false in the case of a reallocation failure and true otherwise.\n+  bool deoptimize_objects(int depth) {\n+    return deoptimize_objects(0, depth);\n@@ -98,1 +105,4 @@\n-  bool deoptimize_objects(int depth)                           NOT_COMPILER2_OR_JVMCI_RETURN_(true);\n+  \/\/ Deoptimize objects of frames of the target thread at depth >= d1 and depth <= d2.\n+  \/\/ Deoptimize objects of caller frames if they passed references to ArgEscape objects as arguments.\n+  \/\/ Return false in the case of a reallocation failure and true otherwise.\n+  bool deoptimize_objects(int d1, int d2)                      NOT_COMPILER2_OR_JVMCI_RETURN_(true);\n","filename":"src\/hotspot\/share\/runtime\/escapeBarrier.hpp","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -44,1 +44,3 @@\n-void JVMFlag::set_origin(Flags origin) {\n+void JVMFlag::set_origin(JVMFlagOrigin new_origin) {\n+  int old_flags = _flags;\n+  int origin = static_cast<int>(new_origin);\n@@ -46,2 +48,5 @@\n-  Flags new_origin = Flags((origin == COMMAND_LINE) ? Flags(origin | ORIG_COMMAND_LINE) : origin);\n-  _flags = Flags((_flags & ~VALUE_ORIGIN_MASK) | new_origin);\n+  int was_in_cmdline = (new_origin == JVMFlagOrigin::COMMAND_LINE) ? WAS_SET_ON_COMMAND_LINE : 0;\n+  _flags = Flags((_flags & ~VALUE_ORIGIN_MASK) | origin | was_in_cmdline);\n+  if ((old_flags & WAS_SET_ON_COMMAND_LINE) != 0) {\n+    assert((_flags & WAS_SET_ON_COMMAND_LINE) != 0, \"once initialized, should never change\");\n+  }\n@@ -379,1 +384,0 @@\n-  int origin = _flags & VALUE_ORIGIN_MASK;\n@@ -381,2 +385,2 @@\n-  switch(origin) {\n-    case DEFAULT:\n+  switch(get_origin()) {\n+    case JVMFlagOrigin::DEFAULT:\n@@ -384,1 +388,1 @@\n-    case COMMAND_LINE:\n+    case JVMFlagOrigin::COMMAND_LINE:\n@@ -386,1 +390,1 @@\n-    case ENVIRON_VAR:\n+    case JVMFlagOrigin::ENVIRON_VAR:\n@@ -388,1 +392,1 @@\n-    case CONFIG_FILE:\n+    case JVMFlagOrigin::CONFIG_FILE:\n@@ -390,1 +394,1 @@\n-    case MANAGEMENT:\n+    case JVMFlagOrigin::MANAGEMENT:\n@@ -392,2 +396,2 @@\n-    case ERGONOMIC:\n-      if (_flags & ORIG_COMMAND_LINE) {\n+    case JVMFlagOrigin::ERGONOMIC:\n+      if (_flags & WAS_SET_ON_COMMAND_LINE) {\n@@ -397,1 +401,1 @@\n-    case ATTACH_ON_DEMAND:\n+    case JVMFlagOrigin::ATTACH_ON_DEMAND:\n@@ -399,1 +403,1 @@\n-    case INTERNAL:\n+    case JVMFlagOrigin::INTERNAL:\n@@ -401,1 +405,1 @@\n-    case JIMAGE_RESOURCE:\n+    case JVMFlagOrigin::JIMAGE_RESOURCE:\n@@ -498,1 +502,1 @@\n-  flags = flags | extra_flags | JVMFlag::DEFAULT | flag_group(flag_enum);\n+  flags = flags | extra_flags | static_cast<int>(JVMFlagOrigin::DEFAULT) | flag_group(flag_enum);\n@@ -656,1 +660,1 @@\n-    if (array[i]->get_origin() \/* naked field! *\/) {\n+    if (array[i]->get_origin() != JVMFlagOrigin::DEFAULT) {\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlag.cpp","additions":21,"deletions":17,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"utilities\/enumIterator.hpp\"\n@@ -34,0 +35,17 @@\n+enum class JVMFlagOrigin : int {\n+  \/\/ This is the value returned by JVMFlag::get_origin(). It records who\n+  \/\/ has most recently changed the value of a JVMFlag. DEFAULT means that the\n+  \/\/ flag was never changed, or was most recently changed by FLAG_SET_DEFAULT.\n+  DEFAULT          = 0,\n+  COMMAND_LINE     = 1,\n+  ENVIRON_VAR      = 2,\n+  CONFIG_FILE      = 3,\n+  MANAGEMENT       = 4,\n+  ERGONOMIC        = 5,\n+  ATTACH_ON_DEMAND = 6,\n+  INTERNAL         = 7,\n+  JIMAGE_RESOURCE  = 8,\n+};\n+\n+ENUMERATOR_RANGE(JVMFlagOrigin, JVMFlagOrigin::DEFAULT, JVMFlagOrigin::JIMAGE_RESOURCE)\n+\n@@ -36,0 +54,1 @@\n+\n@@ -38,12 +57,0 @@\n-    \/\/ latest value origin\n-    DEFAULT          = 0,\n-    COMMAND_LINE     = 1,\n-    ENVIRON_VAR      = 2,\n-    CONFIG_FILE      = 3,\n-    MANAGEMENT       = 4,\n-    ERGONOMIC        = 5,\n-    ATTACH_ON_DEMAND = 6,\n-    INTERNAL         = 7,\n-    JIMAGE_RESOURCE  = 8,\n-\n-    LAST_VALUE_ORIGIN = JIMAGE_RESOURCE,\n@@ -67,2 +74,7 @@\n-    \/\/ set this bit if the flag was set on the command line\n-    ORIG_COMMAND_LINE       = 1 << 17,\n+    \/\/ Note the difference:\n+    \/\/ f->get_origin() == COMMAND_LINE\n+    \/\/    f was mostly recently set by the command-line\n+    \/\/ f->_flags & WAS_SET_ON_COMMAND_LINE\n+    \/\/    f was specified on the command-line (but may have since been updated by\n+    \/\/    someone else like FLAG_SET_ERGO)\n+    WAS_SET_ON_COMMAND_LINE = 1 << 17,\n@@ -70,1 +82,1 @@\n-    KIND_MASK = ~(VALUE_ORIGIN_MASK | ORIG_COMMAND_LINE)\n+    KIND_MASK = ~(VALUE_ORIGIN_MASK | WAS_SET_ON_COMMAND_LINE)\n@@ -235,14 +247,14 @@\n-  Flags get_origin() const        {  return Flags(_flags & VALUE_ORIGIN_MASK);   }\n-  void set_origin(Flags origin);\n-\n-  bool is_default() const         { return (get_origin() == DEFAULT);            }\n-  bool is_ergonomic() const       { return (get_origin() == ERGONOMIC);          }\n-  bool is_command_line() const    { return (_flags & ORIG_COMMAND_LINE) != 0;    }\n-  void set_command_line()         {  _flags = Flags(_flags | ORIG_COMMAND_LINE); }\n-  bool is_jimage_resource() const { return (get_origin() == JIMAGE_RESOURCE);    }\n-  bool is_product() const         { return (_flags & KIND_PRODUCT) != 0;         }\n-  bool is_manageable() const      { return (_flags & KIND_MANAGEABLE) != 0;      }\n-  bool is_diagnostic() const      { return (_flags & KIND_DIAGNOSTIC) != 0;      }\n-  bool is_experimental() const    { return (_flags & KIND_EXPERIMENTAL) != 0;    }\n-  bool is_notproduct() const      { return (_flags & KIND_NOT_PRODUCT) != 0;     }\n-  bool is_develop() const         { return (_flags & KIND_DEVELOP) != 0;         }\n+  JVMFlagOrigin get_origin() const {  return JVMFlagOrigin(_flags & VALUE_ORIGIN_MASK);   }\n+  void set_origin(JVMFlagOrigin origin);\n+\n+  bool is_default() const         { return (get_origin() == JVMFlagOrigin::DEFAULT);          }\n+  bool is_ergonomic() const       { return (get_origin() == JVMFlagOrigin::ERGONOMIC);        }\n+  bool is_command_line() const    { return (_flags & WAS_SET_ON_COMMAND_LINE) != 0;           }\n+  void set_command_line()         { _flags = Flags(_flags | WAS_SET_ON_COMMAND_LINE);         }\n+  bool is_jimage_resource() const { return (get_origin() == JVMFlagOrigin::JIMAGE_RESOURCE);  }\n+  bool is_product() const         { return (_flags & KIND_PRODUCT) != 0;                      }\n+  bool is_manageable() const      { return (_flags & KIND_MANAGEABLE) != 0;                   }\n+  bool is_diagnostic() const      { return (_flags & KIND_DIAGNOSTIC) != 0;                   }\n+  bool is_experimental() const    { return (_flags & KIND_EXPERIMENTAL) != 0;                 }\n+  bool is_notproduct() const      { return (_flags & KIND_NOT_PRODUCT) != 0;                  }\n+  bool is_develop() const         { return (_flags & KIND_DEVELOP) != 0;                      }\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlag.hpp","additions":41,"deletions":29,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-static void trace_flag_changed(JVMFlag* flag, const T old_value, const T new_value, const JVMFlag::Flags origin) {\n+static void trace_flag_changed(JVMFlag* flag, const T old_value, const T new_value, const JVMFlagOrigin origin) {\n@@ -41,1 +41,1 @@\n-  e.set_origin(origin);\n+  e.set_origin(static_cast<u8>(origin));\n@@ -47,1 +47,1 @@\n-  JVMFlag::Error set(JVMFlag* flag, void* value, JVMFlag::Flags origin) const {\n+  JVMFlag::Error set(JVMFlag* flag, void* value, JVMFlagOrigin origin) const {\n@@ -51,1 +51,1 @@\n-  virtual JVMFlag::Error set_impl(JVMFlag* flag, void* value, JVMFlag::Flags origin) const = 0;\n+  virtual JVMFlag::Error set_impl(JVMFlag* flag, void* value, JVMFlagOrigin origin) const = 0;\n@@ -62,1 +62,1 @@\n-  JVMFlag::Error check_constraint_and_set(JVMFlag* flag, void* value_addr, JVMFlag::Flags origin, bool verbose) const {\n+  JVMFlag::Error check_constraint_and_set(JVMFlag* flag, void* value_addr, JVMFlagOrigin origin, bool verbose) const {\n@@ -90,1 +90,1 @@\n-  JVMFlag::Error set_impl(JVMFlag* flag, void* value_addr, JVMFlag::Flags origin) const {\n+  JVMFlag::Error set_impl(JVMFlag* flag, void* value_addr, JVMFlagOrigin origin) const {\n@@ -104,1 +104,1 @@\n-  virtual JVMFlag::Error set_impl(JVMFlag* flag, void* value_addr, JVMFlag::Flags origin) const {\n+  virtual JVMFlag::Error set_impl(JVMFlag* flag, void* value_addr, JVMFlagOrigin origin) const {\n@@ -295,1 +295,1 @@\n-JVMFlag::Error JVMFlagAccess::set_impl(JVMFlag* flag, int type_enum, void* value, JVMFlag::Flags origin) {\n+JVMFlag::Error JVMFlagAccess::set_impl(JVMFlag* flag, int type_enum, void* value, JVMFlagOrigin origin) {\n@@ -309,1 +309,1 @@\n-JVMFlag::Error JVMFlagAccess::ccstrAtPut(JVMFlag* flag, ccstr* value, JVMFlag::Flags origin) {\n+JVMFlag::Error JVMFlagAccess::ccstrAtPut(JVMFlag* flag, ccstr* value, JVMFlagOrigin origin) {\n@@ -329,1 +329,1 @@\n-JVMFlag::Error JVMFlagAccess::set_impl(JVMFlagsEnum flag_enum, int type_enum, void* value, JVMFlag::Flags origin) {\n+JVMFlag::Error JVMFlagAccess::set_impl(JVMFlagsEnum flag_enum, int type_enum, void* value, JVMFlagOrigin origin) {\n@@ -340,1 +340,1 @@\n-JVMFlag::Error JVMFlagAccess::ccstrAtPut(JVMFlagsEnum flag, ccstr value, JVMFlag::Flags origin) {\n+JVMFlag::Error JVMFlagAccess::ccstrAtPut(JVMFlagsEnum flag, ccstr value, JVMFlagOrigin origin) {\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagAccess.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -55,3 +55,3 @@\n-  static JVMFlag::Error set_impl(JVMFlagsEnum flag_enum, int type_enum, void* value, JVMFlag::Flags origin);\n-  static JVMFlag::Error set_impl(JVMFlag* flag, int type_enum, void* value, JVMFlag::Flags origin);\n-  static JVMFlag::Error ccstrAtPut(JVMFlagsEnum flag, ccstr value, JVMFlag::Flags origin);\n+  static JVMFlag::Error set_impl(JVMFlagsEnum flag_enum, int type_enum, void* value, JVMFlagOrigin origin);\n+  static JVMFlag::Error set_impl(JVMFlag* flag, int type_enum, void* value, JVMFlagOrigin origin);\n+  static JVMFlag::Error ccstrAtPut(JVMFlagsEnum flag, ccstr value, JVMFlagOrigin origin);\n@@ -88,1 +88,1 @@\n-  static JVMFlag::Error set(JVMFlagsEnum flag_enum, T value, JVMFlag::Flags origin) {\n+  static JVMFlag::Error set(JVMFlagsEnum flag_enum, T value, JVMFlagOrigin origin) {\n@@ -98,1 +98,1 @@\n-  static JVMFlag::Error set(JVMFlag* flag, T* value, JVMFlag::Flags origin) {\n+  static JVMFlag::Error set(JVMFlag* flag, T* value, JVMFlagOrigin origin) {\n@@ -102,8 +102,8 @@\n-  static JVMFlag::Error boolAtPut    (JVMFlag* f, bool*     v, JVMFlag::Flags origin) { return set<JVM_FLAG_TYPE(bool)>    (f, v, origin); }\n-  static JVMFlag::Error intAtPut     (JVMFlag* f, int*      v, JVMFlag::Flags origin) { return set<JVM_FLAG_TYPE(int)>     (f, v, origin); }\n-  static JVMFlag::Error uintAtPut    (JVMFlag* f, uint*     v, JVMFlag::Flags origin) { return set<JVM_FLAG_TYPE(uint)>    (f, v, origin); }\n-  static JVMFlag::Error intxAtPut    (JVMFlag* f, intx*     v, JVMFlag::Flags origin) { return set<JVM_FLAG_TYPE(intx)>    (f, v, origin); }\n-  static JVMFlag::Error uintxAtPut   (JVMFlag* f, uintx*    v, JVMFlag::Flags origin) { return set<JVM_FLAG_TYPE(uintx)>   (f, v, origin); }\n-  static JVMFlag::Error uint64_tAtPut(JVMFlag* f, uint64_t* v, JVMFlag::Flags origin) { return set<JVM_FLAG_TYPE(uint64_t)>(f, v, origin); }\n-  static JVMFlag::Error size_tAtPut  (JVMFlag* f, size_t*   v, JVMFlag::Flags origin) { return set<JVM_FLAG_TYPE(size_t)>  (f, v, origin); }\n-  static JVMFlag::Error doubleAtPut  (JVMFlag* f, double*   v, JVMFlag::Flags origin) { return set<JVM_FLAG_TYPE(double)>  (f, v, origin); }\n+  static JVMFlag::Error boolAtPut    (JVMFlag* f, bool*     v, JVMFlagOrigin origin) { return set<JVM_FLAG_TYPE(bool)>    (f, v, origin); }\n+  static JVMFlag::Error intAtPut     (JVMFlag* f, int*      v, JVMFlagOrigin origin) { return set<JVM_FLAG_TYPE(int)>     (f, v, origin); }\n+  static JVMFlag::Error uintAtPut    (JVMFlag* f, uint*     v, JVMFlagOrigin origin) { return set<JVM_FLAG_TYPE(uint)>    (f, v, origin); }\n+  static JVMFlag::Error intxAtPut    (JVMFlag* f, intx*     v, JVMFlagOrigin origin) { return set<JVM_FLAG_TYPE(intx)>    (f, v, origin); }\n+  static JVMFlag::Error uintxAtPut   (JVMFlag* f, uintx*    v, JVMFlagOrigin origin) { return set<JVM_FLAG_TYPE(uintx)>   (f, v, origin); }\n+  static JVMFlag::Error uint64_tAtPut(JVMFlag* f, uint64_t* v, JVMFlagOrigin origin) { return set<JVM_FLAG_TYPE(uint64_t)>(f, v, origin); }\n+  static JVMFlag::Error size_tAtPut  (JVMFlag* f, size_t*   v, JVMFlagOrigin origin) { return set<JVM_FLAG_TYPE(size_t)>  (f, v, origin); }\n+  static JVMFlag::Error doubleAtPut  (JVMFlag* f, double*   v, JVMFlagOrigin origin) { return set<JVM_FLAG_TYPE(double)>  (f, v, origin); }\n@@ -114,1 +114,1 @@\n-  static JVMFlag::Error ccstrAtPut(JVMFlag* flag, ccstr* value, JVMFlag::Flags origin);\n+  static JVMFlag::Error ccstrAtPut(JVMFlag* flag, ccstr* value, JVMFlagOrigin origin);\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagAccess.hpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2396,5 +2396,0 @@\n-  product(intx, SurvivorAlignmentInBytes, 0, EXPERIMENTAL,                  \\\n-           \"Default survivor space alignment in bytes\")                     \\\n-           range(8, 256)                                                    \\\n-           constraint(SurvivorAlignmentInBytesConstraintFunc,AfterErgo)     \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-  inline JVMFlag::Error FLAG_MEMBER_SETTER(name)(type value, JVMFlag::Flags origin) { \\\n+  inline JVMFlag::Error FLAG_MEMBER_SETTER(name)(type value, JVMFlagOrigin origin) { \\\n@@ -78,3 +78,3 @@\n-                                       FLAG_MEMBER_SETTER(name)((value), JVMFlag::COMMAND_LINE))\n-#define FLAG_SET_ERGO(name, value)    (FLAG_MEMBER_SETTER(name)((value), JVMFlag::ERGONOMIC))\n-#define FLAG_SET_MGMT(name, value)    (FLAG_MEMBER_SETTER(name)((value), JVMFlag::MANAGEMENT))\n+                                       FLAG_MEMBER_SETTER(name)((value), JVMFlagOrigin::COMMAND_LINE))\n+#define FLAG_SET_ERGO(name, value)    (FLAG_MEMBER_SETTER(name)((value), JVMFlagOrigin::ERGONOMIC))\n+#define FLAG_SET_MGMT(name, value)    (FLAG_MEMBER_SETTER(name)((value), JVMFlagOrigin::MANAGEMENT))\n","filename":"src\/hotspot\/share\/runtime\/globals_extension.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -691,0 +691,1 @@\n+const char* JDK_Version::_java_version;\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+  static const char* _java_version;\n@@ -133,0 +134,7 @@\n+  static const char* java_version() {\n+    return _java_version;\n+  }\n+  static void set_java_version(const char* version) {\n+    _java_version = version;\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/java.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/safepoint.hpp\"\n+#include \"runtime\/stackWatermark.inline.hpp\"\n+#include \"runtime\/stackWatermarkSet.inline.hpp\"\n+#include \"runtime\/keepStackGCProcessed.hpp\"\n+\n+KeepStackGCProcessedMark::KeepStackGCProcessedMark(JavaThread* jt) :\n+  _active(true),\n+  _jt(jt) {\n+  finish_processing();\n+  if (!Thread::current()->is_Java_thread()) {\n+    assert(SafepointSynchronize::is_at_safepoint() && Thread::current()->is_VM_thread(),\n+           \"must be either Java thread or VM thread in a safepoint\");\n+    _active = false;\n+    return;\n+  }\n+  StackWatermark* our_watermark = StackWatermarkSet::get(JavaThread::current(), StackWatermarkKind::gc);\n+  if (our_watermark == NULL) {\n+    _active = false;\n+    return;\n+  }\n+  StackWatermark* their_watermark = StackWatermarkSet::get(jt, StackWatermarkKind::gc);\n+  our_watermark->link_watermark(their_watermark);\n+}\n+\n+KeepStackGCProcessedMark::~KeepStackGCProcessedMark() {\n+  if (!_active) {\n+    return;\n+  }\n+  StackWatermark* our_watermark = StackWatermarkSet::get(JavaThread::current(), StackWatermarkKind::gc);\n+  our_watermark->link_watermark(NULL);\n+}\n+\n+void KeepStackGCProcessedMark::finish_processing() {\n+  StackWatermarkSet::finish_processing(_jt, NULL \/* context *\/, StackWatermarkKind::gc);\n+}\n","filename":"src\/hotspot\/share\/runtime\/keepStackGCProcessed.cpp","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_KEEPSTACKGCPROCESSED_HPP\n+#define SHARE_RUNTIME_KEEPSTACKGCPROCESSED_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/stackWatermark.hpp\"\n+#include \"runtime\/stackWatermarkKind.hpp\"\n+#include \"runtime\/stackWatermarkSet.hpp\"\n+\n+\/\/ Use this class to mark a remote thread you are currently interested\n+\/\/ in examining the entire stack, without it slipping into an unprocessed\n+\/\/ state at safepoint polls.\n+class KeepStackGCProcessedMark : public StackObj {\n+  friend class StackWatermark;\n+  bool _active;\n+  JavaThread* _jt;\n+\n+  void finish_processing();\n+\n+public:\n+  KeepStackGCProcessedMark(JavaThread* jt);\n+  ~KeepStackGCProcessedMark();\n+};\n+\n+\n+#endif \/\/ SHARE_RUNTIME_KEEPSTACKGCPROCESSED_HPP\n","filename":"src\/hotspot\/share\/runtime\/keepStackGCProcessed.hpp","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -1661,32 +1661,4 @@\n-char* os::reserve_memory_with_fd(size_t bytes, int file_desc) {\n-  char* result;\n-\n-  if (file_desc != -1) {\n-    \/\/ Could have called pd_reserve_memory() followed by replace_existing_mapping_with_file_mapping(),\n-    \/\/ but AIX may use SHM in which case its more trouble to detach the segment and remap memory to the file.\n-    result = os::map_memory_to_file(NULL \/* addr *\/, bytes, file_desc);\n-    if (result != NULL) {\n-      MemTracker::record_virtual_memory_reserve_and_commit(result, bytes, CALLER_PC);\n-    }\n-  } else {\n-    result = pd_reserve_memory(bytes);\n-    if (result != NULL) {\n-      MemTracker::record_virtual_memory_reserve(result, bytes, CALLER_PC);\n-    }\n-  }\n-\n-  return result;\n-}\n-\n-char* os::attempt_reserve_memory_at(char* addr, size_t bytes, int file_desc) {\n-  char* result = NULL;\n-  if (file_desc != -1) {\n-    result = pd_attempt_reserve_memory_at(addr, bytes, file_desc);\n-    if (result != NULL) {\n-      MemTracker::record_virtual_memory_reserve_and_commit((address)result, bytes, CALLER_PC);\n-    }\n-  } else {\n-    result = pd_attempt_reserve_memory_at(addr, bytes);\n-    if (result != NULL) {\n-      MemTracker::record_virtual_memory_reserve((address)result, bytes, CALLER_PC);\n-    }\n+char* os::attempt_reserve_memory_at(char* addr, size_t bytes) {\n+  char* result = pd_attempt_reserve_memory_at(addr, bytes);\n+  if (result != NULL) {\n+    MemTracker::record_virtual_memory_reserve((address)result, bytes, CALLER_PC);\n@@ -1761,0 +1733,19 @@\n+char* os::map_memory_to_file(size_t bytes, int file_desc) {\n+  \/\/ Could have called pd_reserve_memory() followed by replace_existing_mapping_with_file_mapping(),\n+  \/\/ but AIX may use SHM in which case its more trouble to detach the segment and remap memory to the file.\n+  \/\/ On all current implementations NULL is interpreted as any available address.\n+  char* result = os::map_memory_to_file(NULL \/* addr *\/, bytes, file_desc);\n+  if (result != NULL) {\n+    MemTracker::record_virtual_memory_reserve_and_commit(result, bytes, CALLER_PC);\n+  }\n+  return result;\n+}\n+\n+char* os::attempt_map_memory_to_file_at(char* addr, size_t bytes, int file_desc) {\n+  char* result = pd_attempt_map_memory_to_file_at(addr, bytes, file_desc);\n+  if (result != NULL) {\n+    MemTracker::record_virtual_memory_reserve_and_commit((address)result, bytes, CALLER_PC);\n+  }\n+  return result;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":23,"deletions":32,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -119,1 +119,0 @@\n-  static char*  pd_attempt_reserve_memory_at(char* addr, size_t bytes, int file_desc);\n@@ -134,0 +133,2 @@\n+  static char*  pd_attempt_map_memory_to_file_at(char* addr, size_t bytes, int file_desc);\n+\n@@ -316,1 +317,0 @@\n-  \/\/ alignment_hint - currently only used by AIX\n@@ -319,4 +319,0 @@\n-  \/\/ Reserves virtual memory.\n-  \/\/ if file_desc != -1, also attaches the memory to the file.\n-  static char*  reserve_memory_with_fd(size_t bytes, int file_desc);\n-\n@@ -324,1 +320,1 @@\n-  static char*  reserve_memory_aligned(size_t size, size_t alignment, int file_desc = -1);\n+  static char*  reserve_memory_aligned(size_t size, size_t alignment);\n@@ -328,1 +324,1 @@\n-  static char*  attempt_reserve_memory_at(char* addr, size_t bytes, int file_desc = -1);\n+  static char*  attempt_reserve_memory_at(char* addr, size_t bytes);\n@@ -373,0 +369,2 @@\n+  static char* map_memory_to_file(size_t size, int fd);\n+  static char* map_memory_to_file_aligned(size_t size, size_t alignment, int fd);\n@@ -374,0 +372,1 @@\n+  static char* attempt_map_memory_to_file_at(char* base, size_t size, int fd);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-  \/\/ The call to start_processing fixes the thread's oops and the first few frames.\n+  \/\/ The call to on_safepoint fixes the thread's oops and the first few frames.\n@@ -92,1 +92,1 @@\n-  StackWatermarkSet::start_processing(thread, StackWatermarkKind::gc);\n+  StackWatermarkSet::on_safepoint(thread);\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2457,1 +2457,1 @@\n-    : BasicHashtable<mtCode>(293, (DumpSharedSpaces ? sizeof(CDSAdapterHandlerEntry) : sizeof(AdapterHandlerEntry))) { }\n+    : BasicHashtable<mtCode>(293, (sizeof(AdapterHandlerEntry))) { }\n@@ -2463,3 +2463,0 @@\n-    if (DumpSharedSpaces) {\n-      ((CDSAdapterHandlerEntry*)entry)->init();\n-    }\n@@ -3133,11 +3130,0 @@\n-#if INCLUDE_CDS\n-\n-void CDSAdapterHandlerEntry::init() {\n-  assert(DumpSharedSpaces, \"used during dump time only\");\n-  _c2i_entry_trampoline = (address)MetaspaceShared::misc_code_space_alloc(SharedRuntime::trampoline_size());\n-  _adapter_trampoline = (AdapterHandlerEntry**)MetaspaceShared::misc_code_space_alloc(sizeof(AdapterHandlerEntry*));\n-};\n-\n-#endif \/\/ INCLUDE_CDS\n-\n-\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -682,14 +682,0 @@\n-\/\/ This class is used only with DumpSharedSpaces==true. It holds extra information\n-\/\/ that's used only during CDS dump time.\n-\/\/ For details, see comments around Method::link_method()\n-class CDSAdapterHandlerEntry: public AdapterHandlerEntry {\n-  address               _c2i_entry_trampoline;   \/\/ allocated from shared spaces \"MC\" region\n-  AdapterHandlerEntry** _adapter_trampoline;     \/\/ allocated from shared spaces \"MD\" region\n-\n-public:\n-  address get_c2i_entry_trampoline()             const { return _c2i_entry_trampoline; }\n-  AdapterHandlerEntry** get_adapter_trampoline() const { return _adapter_trampoline; }\n-  void init() NOT_CDS_RETURN;\n-};\n-\n-\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -140,0 +140,2 @@\n+  \/\/ Returns base of red zone (one-beyond the highest red zone address, so\n+  \/\/  itself outside red zone and the highest address of the yellow zone).\n@@ -144,0 +146,1 @@\n+  \/\/ Returns true if address points into the red zone.\n@@ -145,1 +148,1 @@\n-    return a <= stack_red_zone_base() && a >= stack_end();\n+    return a < stack_red_zone_base() && a >= stack_end();\n@@ -158,0 +161,1 @@\n+  \/\/ Returns base of the reserved zone (one-beyond the highest reserved zone address).\n@@ -162,0 +166,2 @@\n+\n+  \/\/ Returns true if address points into the reserved zone.\n@@ -163,1 +169,1 @@\n-    return (a <= stack_reserved_zone_base()) &&\n+    return (a < stack_reserved_zone_base()) &&\n@@ -170,0 +176,2 @@\n+\n+  \/\/ Returns true if a points into either yellow or reserved zone.\n@@ -171,1 +179,1 @@\n-    return (a <= stack_reserved_zone_base()) && (a >= stack_red_zone_base());\n+    return (a < stack_reserved_zone_base()) && (a >= stack_red_zone_base());\n","filename":"src\/hotspot\/share\/runtime\/stackOverflow.hpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -166,1 +166,2 @@\n-    _kind(kind) {\n+    _kind(kind),\n+    _linked_watermark(NULL) {\n@@ -250,0 +251,5 @@\n+void StackWatermark::link_watermark(StackWatermark* watermark) {\n+  assert(watermark == NULL || _linked_watermark == NULL, \"nesting not supported\");\n+  _linked_watermark = watermark;\n+}\n+\n@@ -283,0 +289,8 @@\n+void StackWatermark::on_safepoint() {\n+  start_processing();\n+  StackWatermark* linked_watermark = _linked_watermark;\n+  if (linked_watermark != NULL) {\n+    linked_watermark->finish_processing(NULL \/* context *\/);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/stackWatermark.cpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/mutex.hpp\"\n@@ -95,0 +96,1 @@\n+  StackWatermark* _linked_watermark;\n@@ -130,0 +132,2 @@\n+  void link_watermark(StackWatermark* watermark);\n+\n@@ -142,0 +146,1 @@\n+  void on_safepoint();\n","filename":"src\/hotspot\/share\/runtime\/stackWatermark.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"code\/nmethod.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/stackWatermark.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -112,0 +112,7 @@\n+void StackWatermarkSet::on_safepoint(JavaThread* jt) {\n+  StackWatermark* watermark = get(jt, StackWatermarkKind::gc);\n+  if (watermark != NULL) {\n+    watermark->on_safepoint();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/stackWatermarkSet.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -76,0 +76,3 @@\n+  \/\/ Called to ensure that processing of the thread is started when waking up from safepoint\n+  static void on_safepoint(JavaThread* jt);\n+\n","filename":"src\/hotspot\/share\/runtime\/stackWatermarkSet.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -176,4 +176,2 @@\n- * method to upcall into Java to return the value of the specified\n- * property as a utf8 string, or NULL if does not exist. The caller\n- * is responsible for setting a ResourceMark for proper cleanup of\n- * the utf8 strings.\n+ * Call into java.lang.System.getProperty to check that the value of the\n+ * specified property matches\n@@ -181,1 +179,3 @@\n-const char* StatSampler::get_system_property(const char* name, TRAPS) {\n+void StatSampler::assert_system_property(const char* name, const char* value, TRAPS) {\n+#ifdef ASSERT\n+  ResourceMark rm(THREAD);\n@@ -184,1 +184,1 @@\n-  Handle key_str   = java_lang_String::create_from_str(name, CHECK_NULL);\n+  Handle key_str   = java_lang_String::create_from_str(name, CHECK);\n@@ -195,1 +195,1 @@\n-                         CHECK_NULL);\n+                         CHECK);\n@@ -198,3 +198,1 @@\n-  if (value_oop == NULL) {\n-    return NULL;\n-  }\n+  assert(value_oop != NULL, \"property must have a value\");\n@@ -203,1 +201,1 @@\n-  char* value = java_lang_String::as_utf8_string(value_oop);\n+  char* system_value = java_lang_String::as_utf8_string(value_oop);\n@@ -205,1 +203,2 @@\n-  return value;\n+  assert(strcmp(value, system_value) == 0, \"property value mustn't differ from System.getProperty\");\n+#endif \/\/ ASSERT\n@@ -209,7 +208,2 @@\n- * The list of System Properties that have corresponding PerfData\n- * string instrumentation created by retrieving the named property's\n- * value from System.getProperty() and unconditionally creating a\n- * PerfStringConstant object initialized to the retrieved value. This\n- * is not an exhaustive list of Java properties with corresponding string\n- * instrumentation as the create_system_property_instrumentation() method\n- * creates other property based instrumentation conditionally.\n+ * Adds a constant counter of the given property. Asserts the value does not\n+ * differ from the value retrievable from System.getProperty(name)\n@@ -217,0 +211,9 @@\n+void StatSampler::add_property_constant(CounterNS name_space, const char* name, const char* value, TRAPS) {\n+  \/\/ the property must exist\n+  assert(value != NULL, \"property name should be have a value: %s\", name);\n+  assert_system_property(name, value, CHECK);\n+  if (value != NULL) {\n+    \/\/ create the property counter\n+    PerfDataManager::create_string_constant(name_space, name, value, CHECK);\n+  }\n+}\n@@ -218,40 +221,8 @@\n-\/\/ stable interface, supported counters\n-static const char* property_counters_ss[] = {\n-  \"java.vm.specification.version\",\n-  \"java.vm.specification.name\",\n-  \"java.vm.specification.vendor\",\n-  \"java.vm.version\",\n-  \"java.vm.name\",\n-  \"java.vm.vendor\",\n-  \"java.vm.info\",\n-  \"jdk.debug\",\n-  \"java.library.path\",\n-  \"java.class.path\",\n-  \"java.version\",\n-  \"java.home\",\n-  NULL\n-};\n-\n-\/\/ unstable interface, supported counters\n-static const char* property_counters_us[] = {\n-  NULL\n-};\n-\n-\/\/ unstable interface, unsupported counters\n-static const char* property_counters_uu[] = {\n-  \"sun.boot.library.path\",\n-  NULL\n-};\n-\n-typedef struct {\n-  const char** property_list;\n-  CounterNS name_space;\n-} PropertyCounters;\n-\n-static PropertyCounters property_counters[] = {\n-  { property_counters_ss, JAVA_PROPERTY },\n-  { property_counters_us, COM_PROPERTY },\n-  { property_counters_uu, SUN_PROPERTY },\n-  { NULL, SUN_PROPERTY }\n-};\n-\n+\/*\n+ * Adds a string constant of the given property. Retrieves the value via\n+ * Arguments::get_property() and asserts the value for the does not differ from\n+ * the value retrievable from System.getProperty()\n+ *\/\n+void StatSampler::add_property_constant(CounterNS name_space, const char* name, TRAPS) {\n+  add_property_constant(name_space, name, Arguments::get_property(name), CHECK);\n+}\n@@ -260,3 +231,5 @@\n- * Method to create PerfData string instruments that contain the values\n- * of various system properties. String instruments are created for each\n- * property specified in the property lists provided in property_counters[].\n+ * Method to create PerfStringConstants containing the values of various\n+ * system properties. Constants are created from information known to HotSpot,\n+ * but are initialized as-if getting the values from System.getProperty()\n+ * during bootstrap.\n+ *\n@@ -264,1 +237,1 @@\n- * property name as indicated in property_counters[].\n+ * property name.\n@@ -268,21 +241,21 @@\n-  ResourceMark rm;\n-\n-  for (int i = 0; property_counters[i].property_list != NULL; i++) {\n-\n-    for (int j = 0; property_counters[i].property_list[j] != NULL; j++) {\n-\n-      const char* property_name = property_counters[i].property_list[j];\n-      assert(property_name != NULL, \"property name should not be NULL\");\n-\n-      const char* value = get_system_property(property_name, CHECK);\n-\n-      \/\/ the property must exist\n-      assert(value != NULL, \"property name should be valid\");\n-\n-      if (value != NULL) {\n-        \/\/ create the property counter\n-        PerfDataManager::create_string_constant(property_counters[i].name_space,\n-                                                property_name, value, CHECK);\n-      }\n-    }\n-  }\n+  \/\/ Non-writeable, constant properties\n+  add_property_constant(JAVA_PROPERTY, \"java.vm.specification.name\", \"Java Virtual Machine Specification\", CHECK);\n+  add_property_constant(JAVA_PROPERTY, \"java.version\", JDK_Version::java_version(), CHECK);\n+  add_property_constant(JAVA_PROPERTY, \"java.vm.version\", VM_Version::vm_release(), CHECK);\n+  add_property_constant(JAVA_PROPERTY, \"java.vm.name\", VM_Version::vm_name(), CHECK);\n+  add_property_constant(JAVA_PROPERTY, \"java.vm.vendor\", VM_Version::vm_vendor(), CHECK);\n+  add_property_constant(JAVA_PROPERTY, \"jdk.debug\", VM_Version::jdk_debug_level(), CHECK);\n+\n+  \/\/ Get remaining property constants via Arguments::get_property,\n+  \/\/ which does a linear search over the internal system properties list.\n+\n+  \/\/ SUN_PROPERTY properties\n+  add_property_constant(SUN_PROPERTY, \"sun.boot.library.path\", CHECK);\n+\n+  \/\/ JAVA_PROPERTY properties\n+  add_property_constant(JAVA_PROPERTY, \"java.vm.specification.version\", CHECK);\n+  add_property_constant(JAVA_PROPERTY, \"java.vm.specification.vendor\", CHECK);\n+  add_property_constant(JAVA_PROPERTY, \"java.vm.info\", CHECK);\n+  add_property_constant(JAVA_PROPERTY, \"java.library.path\", CHECK);\n+  add_property_constant(JAVA_PROPERTY, \"java.class.path\", CHECK);\n+  add_property_constant(JAVA_PROPERTY, \"java.home\", CHECK);\n","filename":"src\/hotspot\/share\/runtime\/statSampler.cpp","additions":57,"deletions":84,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -54,1 +54,3 @@\n-    static const char* get_system_property(const char* name, TRAPS);\n+    static void assert_system_property(const char* name, const char* value, TRAPS);\n+    static void add_property_constant(CounterNS name_space, const char* name, TRAPS);\n+    static void add_property_constant(CounterNS name_space, const char* name, const char* value, TRAPS);\n","filename":"src\/hotspot\/share\/runtime\/statSampler.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -897,0 +897,1 @@\n+char java_version[64] = \"\";\n@@ -902,0 +903,22 @@\n+\/\/ extract the JRE version string from java.lang.VersionProps.java_version\n+static const char* get_java_version(TRAPS) {\n+  Klass* k = SystemDictionary::find(vmSymbols::java_lang_VersionProps(),\n+                                    Handle(), Handle(), CHECK_AND_CLEAR_NULL);\n+  fieldDescriptor fd;\n+  bool found = k != NULL &&\n+               InstanceKlass::cast(k)->find_local_field(vmSymbols::java_version_name(),\n+                                                        vmSymbols::string_signature(), &fd);\n+  if (found) {\n+    oop name_oop = k->java_mirror()->obj_field(fd.offset());\n+    if (name_oop == NULL) {\n+      return NULL;\n+    }\n+    const char* name = java_lang_String::as_utf8_string(name_oop,\n+                                                        java_version,\n+                                                        sizeof(java_version));\n+    return name;\n+  } else {\n+    return NULL;\n+  }\n+}\n+\n@@ -3386,0 +3409,1 @@\n+  JDK_Version::set_java_version(get_java_version(THREAD));\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2603,9 +2603,9 @@\n-  declare_constant(JVMFlag::DEFAULT)                                      \\\n-  declare_constant(JVMFlag::COMMAND_LINE)                                 \\\n-  declare_constant(JVMFlag::ENVIRON_VAR)                                  \\\n-  declare_constant(JVMFlag::CONFIG_FILE)                                  \\\n-  declare_constant(JVMFlag::MANAGEMENT)                                   \\\n-  declare_constant(JVMFlag::ERGONOMIC)                                    \\\n-  declare_constant(JVMFlag::ATTACH_ON_DEMAND)                             \\\n-  declare_constant(JVMFlag::INTERNAL)                                     \\\n-  declare_constant(JVMFlag::JIMAGE_RESOURCE)                              \\\n+  declare_constant(JVMFlagOrigin::DEFAULT)                                \\\n+  declare_constant(JVMFlagOrigin::COMMAND_LINE)                           \\\n+  declare_constant(JVMFlagOrigin::ENVIRON_VAR)                            \\\n+  declare_constant(JVMFlagOrigin::CONFIG_FILE)                            \\\n+  declare_constant(JVMFlagOrigin::MANAGEMENT)                             \\\n+  declare_constant(JVMFlagOrigin::ERGONOMIC)                              \\\n+  declare_constant(JVMFlagOrigin::ATTACH_ON_DEMAND)                       \\\n+  declare_constant(JVMFlagOrigin::INTERNAL)                               \\\n+  declare_constant(JVMFlagOrigin::JIMAGE_RESOURCE)                        \\\n@@ -2613,1 +2613,1 @@\n-  declare_constant(JVMFlag::ORIG_COMMAND_LINE)\n+  declare_constant(JVMFlag::WAS_SET_ON_COMMAND_LINE)\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -306,1 +306,1 @@\n-  int ret = WriteableFlags::set_flag(op->arg(0), op->arg(1), JVMFlag::ATTACH_ON_DEMAND, err_msg);\n+  int ret = WriteableFlags::set_flag(op->arg(0), op->arg(1), JVMFlagOrigin::ATTACH_ON_DEMAND, err_msg);\n","filename":"src\/hotspot\/share\/services\/attachListener.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -279,1 +279,1 @@\n-  int ret = WriteableFlags::set_flag(_flag.value(), val, JVMFlag::MANAGEMENT, err_msg);\n+  int ret = WriteableFlags::set_flag(_flag.value(), val, JVMFlagOrigin::MANAGEMENT, err_msg);\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1477,1 +1477,1 @@\n-    case JVMFlag::DEFAULT:\n+    case JVMFlagOrigin::DEFAULT:\n@@ -1480,1 +1480,1 @@\n-    case JVMFlag::COMMAND_LINE:\n+    case JVMFlagOrigin::COMMAND_LINE:\n@@ -1483,1 +1483,1 @@\n-    case JVMFlag::ENVIRON_VAR:\n+    case JVMFlagOrigin::ENVIRON_VAR:\n@@ -1486,1 +1486,1 @@\n-    case JVMFlag::CONFIG_FILE:\n+    case JVMFlagOrigin::CONFIG_FILE:\n@@ -1489,1 +1489,1 @@\n-    case JVMFlag::MANAGEMENT:\n+    case JVMFlagOrigin::MANAGEMENT:\n@@ -1492,1 +1492,1 @@\n-    case JVMFlag::ERGONOMIC:\n+    case JVMFlagOrigin::ERGONOMIC:\n@@ -1495,1 +1495,1 @@\n-    case JVMFlag::ATTACH_ON_DEMAND:\n+    case JVMFlagOrigin::ATTACH_ON_DEMAND:\n@@ -1587,1 +1587,1 @@\n-  int succeed = WriteableFlags::set_flag(name, new_value, JVMFlag::MANAGEMENT, error_msg);\n+  int succeed = WriteableFlags::set_flag(name, new_value, JVMFlagOrigin::MANAGEMENT, error_msg);\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-JVMFlag::Error WriteableFlags::set_bool_flag(const char* name, const char* arg, JVMFlag::Flags origin, FormatBuffer<80>& err_msg) {\n+JVMFlag::Error WriteableFlags::set_bool_flag(const char* name, const char* arg, JVMFlagOrigin origin, FormatBuffer<80>& err_msg) {\n@@ -110,1 +110,1 @@\n-JVMFlag::Error WriteableFlags::set_bool_flag(const char* name, bool value, JVMFlag::Flags origin, FormatBuffer<80>& err_msg) {\n+JVMFlag::Error WriteableFlags::set_bool_flag(const char* name, bool value, JVMFlagOrigin origin, FormatBuffer<80>& err_msg) {\n@@ -118,1 +118,1 @@\n-JVMFlag::Error WriteableFlags::set_int_flag(const char* name, const char* arg, JVMFlag::Flags origin, FormatBuffer<80>& err_msg) {\n+JVMFlag::Error WriteableFlags::set_int_flag(const char* name, const char* arg, JVMFlagOrigin origin, FormatBuffer<80>& err_msg) {\n@@ -128,1 +128,1 @@\n-JVMFlag::Error WriteableFlags::set_int_flag(const char* name, int value, JVMFlag::Flags origin, FormatBuffer<80>& err_msg) {\n+JVMFlag::Error WriteableFlags::set_int_flag(const char* name, int value, JVMFlagOrigin origin, FormatBuffer<80>& err_msg) {\n@@ -136,1 +136,1 @@\n-JVMFlag::Error WriteableFlags::set_uint_flag(const char* name, const char* arg, JVMFlag::Flags origin, FormatBuffer<80>& err_msg) {\n+JVMFlag::Error WriteableFlags::set_uint_flag(const char* name, const char* arg, JVMFlagOrigin origin, FormatBuffer<80>& err_msg) {\n@@ -146,1 +146,1 @@\n-JVMFlag::Error WriteableFlags::set_uint_flag(const char* name, uint value, JVMFlag::Flags origin, FormatBuffer<80>& err_msg) {\n+JVMFlag::Error WriteableFlags::set_uint_flag(const char* name, uint value, JVMFlagOrigin origin, FormatBuffer<80>& err_msg) {\n@@ -154,1 +154,1 @@\n-JVMFlag::Error WriteableFlags::set_intx_flag(const char* name, const char* arg, JVMFlag::Flags origin, FormatBuffer<80>& err_msg) {\n+JVMFlag::Error WriteableFlags::set_intx_flag(const char* name, const char* arg, JVMFlagOrigin origin, FormatBuffer<80>& err_msg) {\n@@ -164,1 +164,1 @@\n-JVMFlag::Error WriteableFlags::set_intx_flag(const char* name, intx value, JVMFlag::Flags origin, FormatBuffer<80>& err_msg) {\n+JVMFlag::Error WriteableFlags::set_intx_flag(const char* name, intx value, JVMFlagOrigin origin, FormatBuffer<80>& err_msg) {\n@@ -172,1 +172,1 @@\n-JVMFlag::Error WriteableFlags::set_uintx_flag(const char* name, const char* arg, JVMFlag::Flags origin, FormatBuffer<80>& err_msg) {\n+JVMFlag::Error WriteableFlags::set_uintx_flag(const char* name, const char* arg, JVMFlagOrigin origin, FormatBuffer<80>& err_msg) {\n@@ -182,1 +182,1 @@\n-JVMFlag::Error WriteableFlags::set_uintx_flag(const char* name, uintx value, JVMFlag::Flags origin, FormatBuffer<80>& err_msg) {\n+JVMFlag::Error WriteableFlags::set_uintx_flag(const char* name, uintx value, JVMFlagOrigin origin, FormatBuffer<80>& err_msg) {\n@@ -190,1 +190,1 @@\n-JVMFlag::Error WriteableFlags::set_uint64_t_flag(const char* name, const char* arg, JVMFlag::Flags origin, FormatBuffer<80>& err_msg) {\n+JVMFlag::Error WriteableFlags::set_uint64_t_flag(const char* name, const char* arg, JVMFlagOrigin origin, FormatBuffer<80>& err_msg) {\n@@ -200,1 +200,1 @@\n-JVMFlag::Error WriteableFlags::set_uint64_t_flag(const char* name, uint64_t value, JVMFlag::Flags origin, FormatBuffer<80>& err_msg) {\n+JVMFlag::Error WriteableFlags::set_uint64_t_flag(const char* name, uint64_t value, JVMFlagOrigin origin, FormatBuffer<80>& err_msg) {\n@@ -208,1 +208,1 @@\n-JVMFlag::Error WriteableFlags::set_size_t_flag(const char* name, const char* arg, JVMFlag::Flags origin, FormatBuffer<80>& err_msg) {\n+JVMFlag::Error WriteableFlags::set_size_t_flag(const char* name, const char* arg, JVMFlagOrigin origin, FormatBuffer<80>& err_msg) {\n@@ -218,1 +218,1 @@\n-JVMFlag::Error WriteableFlags::set_size_t_flag(const char* name, size_t value, JVMFlag::Flags origin, FormatBuffer<80>& err_msg) {\n+JVMFlag::Error WriteableFlags::set_size_t_flag(const char* name, size_t value, JVMFlagOrigin origin, FormatBuffer<80>& err_msg) {\n@@ -226,1 +226,1 @@\n-JVMFlag::Error WriteableFlags::set_double_flag(const char* name, const char* arg, JVMFlag::Flags origin, FormatBuffer<80>& err_msg) {\n+JVMFlag::Error WriteableFlags::set_double_flag(const char* name, const char* arg, JVMFlagOrigin origin, FormatBuffer<80>& err_msg) {\n@@ -236,1 +236,1 @@\n-JVMFlag::Error WriteableFlags::set_double_flag(const char* name, double value, JVMFlag::Flags origin, FormatBuffer<80>& err_msg) {\n+JVMFlag::Error WriteableFlags::set_double_flag(const char* name, double value, JVMFlagOrigin origin, FormatBuffer<80>& err_msg) {\n@@ -244,1 +244,1 @@\n-JVMFlag::Error WriteableFlags::set_ccstr_flag(const char* name, const char* value, JVMFlag::Flags origin, FormatBuffer<80>& err_msg) {\n+JVMFlag::Error WriteableFlags::set_ccstr_flag(const char* name, const char* value, JVMFlagOrigin origin, FormatBuffer<80>& err_msg) {\n@@ -256,1 +256,1 @@\n-JVMFlag::Error WriteableFlags::set_flag(const char* flag_name, const char* flag_value, JVMFlag::Flags origin, FormatBuffer<80>& err_msg) {\n+JVMFlag::Error WriteableFlags::set_flag(const char* flag_name, const char* flag_value, JVMFlagOrigin origin, FormatBuffer<80>& err_msg) {\n@@ -265,1 +265,1 @@\n-JVMFlag::Error WriteableFlags::set_flag(const char* flag_name, jvalue flag_value, JVMFlag::Flags origin, FormatBuffer<80>& err_msg) {\n+JVMFlag::Error WriteableFlags::set_flag(const char* flag_name, jvalue flag_value, JVMFlagOrigin origin, FormatBuffer<80>& err_msg) {\n@@ -270,1 +270,1 @@\n-JVMFlag::Error WriteableFlags::set_flag(const char* name, const void* value, JVMFlag::Error(*setter)(JVMFlag*,const void*,JVMFlag::Flags,FormatBuffer<80>&), JVMFlag::Flags origin, FormatBuffer<80>& err_msg) {\n+JVMFlag::Error WriteableFlags::set_flag(const char* name, const void* value, JVMFlag::Error(*setter)(JVMFlag*,const void*,JVMFlagOrigin,FormatBuffer<80>&), JVMFlagOrigin origin, FormatBuffer<80>& err_msg) {\n@@ -296,1 +296,1 @@\n-JVMFlag::Error WriteableFlags::set_flag_from_char(JVMFlag* f, const void* value, JVMFlag::Flags origin, FormatBuffer<80>& err_msg) {\n+JVMFlag::Error WriteableFlags::set_flag_from_char(JVMFlag* f, const void* value, JVMFlagOrigin origin, FormatBuffer<80>& err_msg) {\n@@ -327,1 +327,1 @@\n-JVMFlag::Error WriteableFlags::set_flag_from_jvalue(JVMFlag* f, const void* value, JVMFlag::Flags origin,\n+JVMFlag::Error WriteableFlags::set_flag_from_jvalue(JVMFlag* f, const void* value, JVMFlagOrigin origin,\n","filename":"src\/hotspot\/share\/services\/writeableFlags.cpp","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-  static JVMFlag::Error set_flag(const char* name, const void* value, JVMFlag::Error(*setter)(JVMFlag*, const void*, JVMFlag::Flags, FormatBuffer<80>&), JVMFlag::Flags origin, FormatBuffer<80>& err_msg);\n+  static JVMFlag::Error set_flag(const char* name, const void* value, JVMFlag::Error(*setter)(JVMFlag*, const void*, JVMFlagOrigin, FormatBuffer<80>&), JVMFlagOrigin origin, FormatBuffer<80>& err_msg);\n@@ -37,1 +37,1 @@\n-  static JVMFlag::Error set_flag_from_char(JVMFlag* f, const void* value, JVMFlag::Flags origin, FormatBuffer<80>& err_msg);\n+  static JVMFlag::Error set_flag_from_char(JVMFlag* f, const void* value, JVMFlagOrigin origin, FormatBuffer<80>& err_msg);\n@@ -39,1 +39,1 @@\n-  static JVMFlag::Error set_flag_from_jvalue(JVMFlag* f, const void* value, JVMFlag::Flags origin, FormatBuffer<80>& err_msg);\n+  static JVMFlag::Error set_flag_from_jvalue(JVMFlag* f, const void* value, JVMFlagOrigin origin, FormatBuffer<80>& err_msg);\n@@ -42,1 +42,1 @@\n-  static JVMFlag::Error set_bool_flag(const char* name, const char* value, JVMFlag::Flags origin, FormatBuffer<80>& err_msg);\n+  static JVMFlag::Error set_bool_flag(const char* name, const char* value, JVMFlagOrigin origin, FormatBuffer<80>& err_msg);\n@@ -44,1 +44,1 @@\n-  static JVMFlag::Error set_int_flag(const char* name, const char* value, JVMFlag::Flags origin, FormatBuffer<80>& err_msg);\n+  static JVMFlag::Error set_int_flag(const char* name, const char* value, JVMFlagOrigin origin, FormatBuffer<80>& err_msg);\n@@ -46,1 +46,1 @@\n-  static JVMFlag::Error set_uint_flag(const char* name, const char* value, JVMFlag::Flags origin, FormatBuffer<80>& err_msg);\n+  static JVMFlag::Error set_uint_flag(const char* name, const char* value, JVMFlagOrigin origin, FormatBuffer<80>& err_msg);\n@@ -48,1 +48,1 @@\n-  static JVMFlag::Error set_intx_flag(const char* name, const char* value, JVMFlag::Flags origin, FormatBuffer<80>& err_msg);\n+  static JVMFlag::Error set_intx_flag(const char* name, const char* value, JVMFlagOrigin origin, FormatBuffer<80>& err_msg);\n@@ -50,1 +50,1 @@\n-  static JVMFlag::Error set_uintx_flag(const char* name, const char* value, JVMFlag::Flags origin, FormatBuffer<80>& err_msg);\n+  static JVMFlag::Error set_uintx_flag(const char* name, const char* value, JVMFlagOrigin origin, FormatBuffer<80>& err_msg);\n@@ -52,1 +52,1 @@\n-  static JVMFlag::Error set_uint64_t_flag(const char* name, const char* value, JVMFlag::Flags origin, FormatBuffer<80>& err_msg);\n+  static JVMFlag::Error set_uint64_t_flag(const char* name, const char* value, JVMFlagOrigin origin, FormatBuffer<80>& err_msg);\n@@ -54,1 +54,1 @@\n-  static JVMFlag::Error set_size_t_flag(const char* name, const char* value, JVMFlag::Flags origin, FormatBuffer<80>& err_msg);\n+  static JVMFlag::Error set_size_t_flag(const char* name, const char* value, JVMFlagOrigin origin, FormatBuffer<80>& err_msg);\n@@ -56,1 +56,1 @@\n-  static JVMFlag::Error set_double_flag(const char* name, const char* value, JVMFlag::Flags origin, FormatBuffer<80>& err_msg);\n+  static JVMFlag::Error set_double_flag(const char* name, const char* value, JVMFlagOrigin origin, FormatBuffer<80>& err_msg);\n@@ -58,1 +58,1 @@\n-  static JVMFlag::Error set_bool_flag(const char* name, bool value, JVMFlag::Flags origin, FormatBuffer<80>& err_msg);\n+  static JVMFlag::Error set_bool_flag(const char* name, bool value, JVMFlagOrigin origin, FormatBuffer<80>& err_msg);\n@@ -60,1 +60,1 @@\n-  static JVMFlag::Error set_int_flag(const char* name, int value, JVMFlag::Flags origin, FormatBuffer<80>& err_msg);\n+  static JVMFlag::Error set_int_flag(const char* name, int value, JVMFlagOrigin origin, FormatBuffer<80>& err_msg);\n@@ -62,1 +62,1 @@\n-  static JVMFlag::Error set_uint_flag(const char* name, uint value, JVMFlag::Flags origin, FormatBuffer<80>& err_msg);\n+  static JVMFlag::Error set_uint_flag(const char* name, uint value, JVMFlagOrigin origin, FormatBuffer<80>& err_msg);\n@@ -64,1 +64,1 @@\n-  static JVMFlag::Error set_intx_flag(const char* name, intx value, JVMFlag::Flags origin, FormatBuffer<80>& err_msg);\n+  static JVMFlag::Error set_intx_flag(const char* name, intx value, JVMFlagOrigin origin, FormatBuffer<80>& err_msg);\n@@ -66,1 +66,1 @@\n-  static JVMFlag::Error set_uintx_flag(const char* name, uintx value, JVMFlag::Flags origin, FormatBuffer<80>& err_msg);\n+  static JVMFlag::Error set_uintx_flag(const char* name, uintx value, JVMFlagOrigin origin, FormatBuffer<80>& err_msg);\n@@ -68,1 +68,1 @@\n-  static JVMFlag::Error set_uint64_t_flag(const char* name, uint64_t value, JVMFlag::Flags origin, FormatBuffer<80>& err_msg);\n+  static JVMFlag::Error set_uint64_t_flag(const char* name, uint64_t value, JVMFlagOrigin origin, FormatBuffer<80>& err_msg);\n@@ -70,1 +70,1 @@\n-  static JVMFlag::Error set_size_t_flag(const char* name, size_t value, JVMFlag::Flags origin, FormatBuffer<80>& err_msg);\n+  static JVMFlag::Error set_size_t_flag(const char* name, size_t value, JVMFlagOrigin origin, FormatBuffer<80>& err_msg);\n@@ -72,1 +72,1 @@\n-  static JVMFlag::Error set_double_flag(const char* name, double value, JVMFlag::Flags origin, FormatBuffer<80>& err_msg);\n+  static JVMFlag::Error set_double_flag(const char* name, double value, JVMFlagOrigin origin, FormatBuffer<80>& err_msg);\n@@ -74,1 +74,1 @@\n-  static JVMFlag::Error set_ccstr_flag(const char* name, const char* value, JVMFlag::Flags origin, FormatBuffer<80>& err_msg);\n+  static JVMFlag::Error set_ccstr_flag(const char* name, const char* value, JVMFlagOrigin origin, FormatBuffer<80>& err_msg);\n@@ -82,1 +82,1 @@\n-  static JVMFlag::Error set_flag(const char* flag_name, const char* flag_value, JVMFlag::Flags origin, FormatBuffer<80>& err_msg);\n+  static JVMFlag::Error set_flag(const char* flag_name, const char* flag_value, JVMFlagOrigin origin, FormatBuffer<80>& err_msg);\n@@ -89,1 +89,1 @@\n-  static JVMFlag::Error set_flag(const char* flag_name, jvalue flag_value, JVMFlag::Flags origin, FormatBuffer<80>& err_msg);\n+  static JVMFlag::Error set_flag(const char* flag_name, jvalue flag_value, JVMFlagOrigin origin, FormatBuffer<80>& err_msg);\n","filename":"src\/hotspot\/share\/services\/writeableFlags.hpp","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -194,7 +194,0 @@\n-  \/\/ Used as default functor when no functor supplied for some methods.\n-  struct NoOp {\n-    void operator()(VALUE*) {}\n-    const VALUE& operator()() {}\n-    void operator()(bool, VALUE*) {}\n-  } noOp;\n-\n@@ -432,1 +425,4 @@\n-    return internal_remove(thread, lookup_f, noOp);\n+    struct {\n+      void operator()(VALUE*) {}\n+    } ignore_del_f;\n+    return internal_remove(thread, lookup_f, ignore_del_f);\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.hpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -213,0 +213,4 @@\n+\n+  constexpr size_t size() const {\n+    return static_cast<size_t>(_end - _start); \/\/ _end is exclusive\n+  }\n","filename":"src\/hotspot\/share\/utilities\/enumIterator.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+enum class JVMFlagOrigin : int;\n","filename":"src\/hotspot\/share\/utilities\/vmEnums.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2341,7 +2341,0 @@\n-     * {@preview Associated with records, a preview feature of the Java language.\n-     *\n-     *           This method is associated with <i>records<\/i>, a preview\n-     *           feature of the Java language. Preview features\n-     *           may be removed in a future release, or upgraded to permanent\n-     *           features of the Java language.}\n-     *\n@@ -2384,1 +2377,1 @@\n-     * @since 14\n+     * @since 16\n@@ -2386,3 +2379,0 @@\n-    @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,\n-                                 essentialAPI=false)\n-    @SuppressWarnings(\"preview\")\n@@ -3685,7 +3675,0 @@\n-     * {@preview Associated with records, a preview feature of the Java language.\n-     *\n-     *           This method is associated with <i>records<\/i>, a preview\n-     *           feature of the Java language. Preview features\n-     *           may be removed in a future release, or upgraded to permanent\n-     *           features of the Java language.}\n-     *\n@@ -3704,1 +3687,1 @@\n-     * @since 14\n+     * @since 16\n@@ -3706,2 +3689,0 @@\n-    @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,\n-                                 essentialAPI=false)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":2,"deletions":21,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -28,8 +28,0 @@\n- * {@preview Associated with records, a preview feature of the Java language.\n- *\n- *           This class is associated with <i>records<\/i>, a preview\n- *           feature of the Java language. Programs can only use this\n- *           class when preview features are enabled. Preview features\n- *           may be removed in a future release, or upgraded to permanent\n- *           features of the Java language.}\n- *\n@@ -89,1 +81,1 @@\n- * @since 14\n+ * @since 16\n@@ -91,2 +83,0 @@\n-@jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,\n-                             essentialAPI=true)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Record.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+    \/\/ This field is read by HotSpot\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VersionProps.java.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -121,8 +121,0 @@\n-     * {@preview Associated with records, a preview feature of the Java language.\n-     *\n-     *           This constant is associated with <i>records<\/i>, a preview\n-     *           feature of the Java language. Programs can only use this\n-     *           constant when preview features are enabled. Preview features\n-     *           may be removed in a future release, or upgraded to permanent\n-     *           features of the Java language.}\n-     *\n@@ -134,1 +126,1 @@\n-     * @since 14\n+     * @since 16\n@@ -136,2 +128,0 @@\n-    @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,\n-                                 essentialAPI=true)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/annotation\/ElementType.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import sun.invoke.util.VerifyAccess;\n@@ -69,1 +70,0 @@\n-    private static final String DESCR_SET_IMPL_METHOD = \"(Ljava\/lang\/invoke\/MethodHandle;)V\";\n@@ -90,1 +90,1 @@\n-    private static final AtomicInteger counter = new AtomicInteger(0);\n+    private static final AtomicInteger counter = new AtomicInteger();\n@@ -172,2 +172,2 @@\n-        useImplMethodHandle = !implClass.getPackageName().equals(implInfo.getDeclaringClass().getPackageName())\n-                                && !Modifier.isPublic(implInfo.getModifiers());\n+        useImplMethodHandle = !Modifier.isPublic(implInfo.getModifiers()) &&\n+                              !VerifyAccess.isSamePackage(implClass, implInfo.getDeclaringClass());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4742,13 +4742,10 @@\n-        if (reorder.length == oldType.parameterCount()) {\n-            int limit = newType.parameterCount();\n-            boolean bad = false;\n-            for (int j = 0; j < reorder.length; j++) {\n-                int i = reorder[j];\n-                if (i < 0 || i >= limit) {\n-                    bad = true; break;\n-                }\n-                Class<?> src = newType.parameterType(i);\n-                Class<?> dst = oldType.parameterType(j);\n-                if (src != dst)\n-                    throw newIllegalArgumentException(\"parameter types do not match after reorder\",\n-                            oldType, newType);\n+        if (reorder.length != oldType.parameterCount())\n+            throw newIllegalArgumentException(\"old type parameter count and reorder array length do not match\",\n+                    oldType, Arrays.toString(reorder));\n+\n+        int limit = newType.parameterCount();\n+        for (int j = 0; j < reorder.length; j++) {\n+            int i = reorder[j];\n+            if (i < 0 || i >= limit) {\n+                throw newIllegalArgumentException(\"index is out of bounds for new type\",\n+                        i, newType);\n@@ -4756,1 +4753,5 @@\n-            if (!bad)  return true;\n+            Class<?> src = newType.parameterType(i);\n+            Class<?> dst = oldType.parameterType(j);\n+            if (src != dst)\n+                throw newIllegalArgumentException(\"parameter types do not match after reorder\",\n+                        oldType, newType);\n@@ -4758,1 +4759,1 @@\n-        throw newIllegalArgumentException(\"bad reorder array: \"+Arrays.toString(reorder));\n+        return true;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":16,"deletions":15,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -41,7 +41,0 @@\n- * {@preview Associated with records, a preview feature of the Java language.\n- *\n- *           This class is associated with <i>records<\/i>, a preview\n- *           feature of the Java language. Preview features\n- *           may be removed in a future release, or upgraded to permanent\n- *           features of the Java language.}\n- *\n@@ -54,1 +47,1 @@\n- * @since 14\n+ * @since 16\n@@ -56,2 +49,0 @@\n-@jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,\n-                             essentialAPI=false)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/RecordComponent.java","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -41,7 +41,0 @@\n- * {@preview Associated with records, a preview feature of the Java language.\n- *\n- *           This class is associated with <i>records<\/i>, a preview\n- *           feature of the Java language. Preview features\n- *           may be removed in a future release, or upgraded to permanent\n- *           features of the Java language.}\n- *\n@@ -54,1 +47,1 @@\n- * @since 14\n+ * @since 16\n@@ -56,2 +49,0 @@\n-@jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,\n-                             essentialAPI=false)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ObjectMethods.java","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -69,0 +69,10 @@\n+ *   <th scope=\"row\">accessUnixDomainSocket<\/th>\n+ *   <td>The ability to accept, bind, connect or get the local address\n+ *   of a <i>Unix Domain<\/i> socket.\n+ *   <\/td>\n+ *   <td>Malicious code could connect to local processes using Unix domain sockets\n+ *    or impersonate local processes, by binding to the same pathnames (assuming they\n+ *    have the required Operating System permissions.<\/td>\n+ * <\/tr>\n+ *\n+ * <tr>\n","filename":"src\/java.base\/share\/classes\/java\/net\/NetPermission.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,7 @@\n-    INET6\n+    INET6,\n+\n+    \/**\n+     * Unix domain (Local) interprocess communication.\n+     * @since 16\n+     *\/\n+    UNIX\n","filename":"src\/java.base\/share\/classes\/java\/net\/StandardProtocolFamily.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,211 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.net;\n+\n+import java.io.ObjectStreamException;\n+import java.io.Serializable;\n+import java.net.SocketAddress;\n+import java.nio.channels.SocketChannel;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.Path;\n+\n+\/**\n+ * A <a href=\"package-summary.html#unixdomain\">Unix domain<\/a> socket address.\n+ * A Unix domain socket address encapsulates a file-system path that Unix domain sockets\n+ * bind or connect to.\n+ *\n+ * <p> An <a id=\"unnamed\"><\/a><i>unnamed<\/i> {@code UnixDomainSocketAddress} has\n+ * an empty path. The local address of a {@link SocketChannel} to a Unix domain socket\n+ * that is <i>automatically<\/i> or <i>implicitly<\/i> bound will be unnamed.\n+ *\n+ * <p> {@link Path} objects used to create instances of this class must be obtained\n+ * from the {@linkplain FileSystems#getDefault system-default} file system.\n+ *\n+ * @see java.nio.channels.SocketChannel\n+ * @see java.nio.channels.ServerSocketChannel\n+ * @since 16\n+ *\/\n+public final class UnixDomainSocketAddress extends SocketAddress {\n+    @java.io.Serial\n+    static final long serialVersionUID = 92902496589351288L;\n+\n+    private final transient Path path;\n+\n+    \/**\n+     * A serial proxy for all {@link UnixDomainSocketAddress} instances.\n+     * It captures the file path name and reconstructs using the public static\n+     * {@link #of(String) factory}.\n+     *\n+     * @serial include\n+     *\/\n+    private static final class Ser implements Serializable {\n+        @java.io.Serial\n+        static final long serialVersionUID = -7955684448513979814L;\n+\n+        \/**\n+         * The path name.\n+         * @serial\n+         *\/\n+        private final String pathname;\n+\n+        Ser(String pathname) {\n+            this.pathname = pathname;\n+        }\n+\n+        \/**\n+         * Creates a {@link UnixDomainSocketAddress} instance, by an invocation\n+         * of the {@link #of(String) factory} method passing the path name.\n+         * @return a UnixDomainSocketAddress\n+         *\/\n+        @java.io.Serial\n+        private Object readResolve() {\n+            return UnixDomainSocketAddress.of(pathname);\n+        }\n+    }\n+\n+    \/**\n+     * Returns a\n+     * <a href=\"{@docRoot}\/serialized-form.html#java.net.UnixDomainSocketAddress.Ser\">\n+     * Ser<\/a> containing the path name of this instance.\n+     *\n+     * @return a {@link Ser}\n+     * representing the path name of this instance\n+     *\/\n+    @java.io.Serial\n+    private Object writeReplace() throws ObjectStreamException {\n+        return new Ser(path.toString());\n+    }\n+\n+    \/**\n+     * Throws InvalidObjectException, always.\n+     * @param s the stream\n+     * @throws java.io.InvalidObjectException always\n+     *\/\n+    @java.io.Serial\n+    private void readObject(java.io.ObjectInputStream s)\n+        throws java.io.InvalidObjectException\n+    {\n+        throw new java.io.InvalidObjectException(\"Proxy required\");\n+    }\n+\n+    \/**\n+     * Throws InvalidObjectException, always.\n+     * @throws java.io.InvalidObjectException always\n+     *\/\n+    @java.io.Serial\n+    private void readObjectNoData()\n+        throws java.io.InvalidObjectException\n+    {\n+        throw new java.io.InvalidObjectException(\"Proxy required\");\n+    }\n+\n+    private UnixDomainSocketAddress(Path path) {\n+        this.path = path;\n+    }\n+\n+    \/**\n+     * Creates a UnixDomainSocketAddress from the given path string.\n+     *\n+     * @param  pathname\n+     *         The path string, which can be empty\n+     *\n+     * @return A UnixDomainSocketAddress\n+     *\n+     * @throws InvalidPathException\n+     *         If the path cannot be converted to a Path\n+     *\n+     * @throws NullPointerException if pathname is {@code null}\n+     *\/\n+    public static UnixDomainSocketAddress of(String pathname) {\n+        return of(Path.of(pathname));\n+    }\n+\n+    \/**\n+     * Creates a UnixDomainSocketAddress for the given path.\n+     *\n+     * @param  path\n+     *         The path to the socket, which can be empty\n+     *\n+     * @return A UnixDomainSocketAddress\n+     *\n+     * @throws IllegalArgumentException\n+     *         If the path is not associated with the default file system\n+     *\n+     * @throws NullPointerException if path is {@code null}\n+     *\/\n+    public static UnixDomainSocketAddress of(Path path) {\n+        FileSystem fs = path.getFileSystem();\n+        if (fs != FileSystems.getDefault()) {\n+            throw new IllegalArgumentException();\n+        }\n+        if (fs.getClass().getModule() != Object.class.getModule()) {\n+            throw new IllegalArgumentException();\n+        }\n+        return new UnixDomainSocketAddress(path);\n+    }\n+\n+    \/**\n+     * Returns this address's path.\n+     *\n+     * @return this address's path\n+     *\/\n+    public Path getPath() {\n+        return path;\n+    }\n+\n+    \/**\n+     * Returns the hash code of this {@code UnixDomainSocketAddress}\n+     *\/\n+    @Override\n+    public int hashCode() {\n+        return path.hashCode();\n+    }\n+\n+    \/**\n+     * Compares this address with another object.\n+     *\n+     * @return true if the path fields are equal\n+     *\/\n+    @Override\n+    public boolean equals(Object o) {\n+        if (!(o instanceof UnixDomainSocketAddress))\n+            return false;\n+        UnixDomainSocketAddress that = (UnixDomainSocketAddress)o;\n+        return this.path.equals(that.path);\n+    }\n+\n+    \/**\n+     * Returns a string representation of this {@code UnixDomainSocketAddress}.\n+     *\n+     * @return this address's path which may be empty for an unnamed address\n+     *\/\n+    @Override\n+    public String toString() {\n+        return path.toString();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/net\/UnixDomainSocketAddress.java","additions":211,"deletions":0,"binary":false,"changes":211,"status":"added"},{"patch":"@@ -153,0 +153,3 @@\n+     *\n+     * @see     <a href=\"..\/..\/net\/doc-files\/net-properties.html#Ipv4IPv6\">\n+     *          java.net.preferIPv4Stack<\/a> system property\n@@ -172,0 +175,3 @@\n+     * @apiNote <a href=\"package-summary.html#unixdomain\">Unix domain<\/a> sockets\n+     * are not supported by DatagramChannel.\n+     *\n@@ -185,0 +191,3 @@\n+     * @see     <a href=\"..\/..\/net\/doc-files\/net-properties.html#Ipv4IPv6\">\n+     *          java.net.preferIPv4Stack<\/a> system property\n+     *\n@@ -632,1 +641,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/DatagramChannel.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.net.NetPermission;\n@@ -33,0 +34,1 @@\n+import java.net.UnixDomainSocketAddress;\n@@ -40,5 +42,8 @@\n- * <p> A server-socket channel is created by invoking the {@link #open() open}\n- * method of this class.  It is not possible to create a channel for an arbitrary,\n- * pre-existing {@link ServerSocket}. A newly-created server-socket channel is\n- * open but not yet bound.  An attempt to invoke the {@link #accept() accept}\n- * method of an unbound server-socket channel will cause a {@link NotYetBoundException}\n+ * <p> A server-socket channel is created by invoking one of the {@code open}\n+ * methods of this class. The no-arg {@link #open() open} method opens a server-socket\n+ * channel for an <i>Internet protocol<\/i> socket. The {@link #open(ProtocolFamily)}\n+ * method is used to open a server-socket channel for a socket of a specified\n+ * protocol family. It is not possible to create a channel for an arbitrary,\n+ * pre-existing socket. A newly-created server-socket channel is open but not yet\n+ * bound. An attempt to invoke the {@link #accept() accept} method of an\n+ * unbound server-socket channel will cause a {@link NotYetBoundException}\n@@ -46,1 +51,1 @@\n- * {@link #bind(java.net.SocketAddress,int) bind} methods defined by this class.\n+ * {@link #bind(java.net.SocketAddress, int) bind} methods defined by this class.\n@@ -49,1 +54,2 @@\n- * setOption} method. Server-socket channels support the following options:\n+ * setOption} method. Server-socket channels for <i>Internet protocol<\/i> sockets\n+ * support the following options:\n@@ -71,1 +77,21 @@\n- * Additional (implementation specific) options may also be supported.\n+ *\n+ * <p> Server-socket channels for <i>Unix domain<\/i> sockets support:\n+ * <blockquote>\n+ * <table class=\"striped\">\n+ * <caption style=\"display:none\">Socket options<\/caption>\n+ * <thead>\n+ *   <tr>\n+ *     <th scope=\"col\">Option Name<\/th>\n+ *     <th scope=\"col\">Description<\/th>\n+ *   <\/tr>\n+ * <\/thead>\n+ * <tbody>\n+ *   <tr>\n+ *     <th scope=\"row\"> {@link java.net.StandardSocketOptions#SO_RCVBUF SO_RCVBUF} <\/th>\n+ *     <td> The size of the socket receive buffer <\/td>\n+ *   <\/tr>\n+ * <\/tbody>\n+ * <\/table>\n+ * <\/blockquote>\n+ *\n+ * <p> Additional (implementation specific) options may also be supported.\n@@ -97,1 +123,1 @@\n-     * Opens a server-socket channel.\n+     * Opens a server-socket channel for an <i>Internet protocol<\/i> socket.\n@@ -113,0 +139,3 @@\n+     *\n+     * @see     <a href=\"..\/..\/net\/doc-files\/net-properties.html#Ipv4IPv6\">\n+     *          java.net.preferIPv4Stack<\/a> system property\n@@ -119,1 +148,1 @@\n-     * Opens a server-socket channel.The {@code family} parameter specifies the\n+     * Opens a server-socket channel. The {@code family} parameter specifies the\n@@ -140,0 +169,3 @@\n+     * @see     <a href=\"..\/..\/net\/doc-files\/net-properties.html#Ipv4IPv6\">\n+     *          java.net.preferIPv4Stack<\/a> system property\n+     *\n@@ -183,2 +215,1 @@\n-     *          If a security manager has been installed and its {@link\n-     *          SecurityManager#checkListen checkListen} method denies the\n+     *          If a security manager has been installed and it denies the\n@@ -200,2 +231,2 @@\n-     * a local address. Once an association is established then the socket remains\n-     * bound until the channel is closed.\n+     * a local address. For <i>Internet protocol<\/i> sockets, once an association\n+     * is established then the socket remains bound until the channel is closed.\n@@ -210,0 +241,16 @@\n+     * @apiNote\n+     * Binding a server socket channel for a <i>Unix Domain<\/i> socket, creates a\n+     * file corresponding to the file path in the {@link UnixDomainSocketAddress}.\n+     * This file persists after the channel is closed, and must be removed before\n+     * another socket can bind to the same name. Binding to a {@code null} address\n+     * causes the socket to be <i>automatically<\/i> bound to some unique file\n+     * in a system temporary location. The associated socket file also persists\n+     * after the channel is closed. Its name can be obtained from the channel's\n+     * local socket address.\n+     *\n+     * @implNote\n+     * Each platform enforces an implementation specific, maximum length for the\n+     * name of a <i>Unix Domain<\/i> socket. This limitation is enforced when a\n+     * channel is bound. The maximum length is typically close to and generally\n+     * not less than 100 bytes.\n+     *\n@@ -211,2 +258,2 @@\n-     *          The address to bind the socket, or {@code null} to bind to an\n-     *          automatically assigned socket address\n+     *          The address to bind the socket, or {@code null} to bind to\n+     *          an automatically assigned socket address\n@@ -228,2 +275,4 @@\n-     *          SecurityManager#checkListen checkListen} method denies the\n-     *          operation\n+     *          SecurityManager#checkListen checkListen} method denies\n+     *          the operation for an <i>Internet protocol<\/i> socket address,\n+     *          or for a <i>Unix domain<\/i> socket address if it denies\n+     *          {@link NetPermission}{@code(\"accessUnixDomainSocket\")}.\n@@ -254,0 +303,3 @@\n+     *\n+     * @throws  UnsupportedOperationException\n+     *          If the channel's socket is not an <i>Internet protocol<\/i> socket\n@@ -268,7 +320,9 @@\n-     * <p> This method performs exactly the same security checks as the {@link\n-     * java.net.ServerSocket#accept accept} method of the {@link\n-     * java.net.ServerSocket} class.  That is, if a security manager has been\n-     * installed then for each new connection this method verifies that the\n-     * address and port number of the connection's remote endpoint are\n-     * permitted by the security manager's {@link\n-     * java.lang.SecurityManager#checkAccept checkAccept} method.  <\/p>\n+     * <p> If bound to an <i>Internet protocol<\/i> socket address, this method\n+     * performs exactly the same security checks as the {@link\n+     * java.net.ServerSocket#accept accept} method of the {@link java.net.ServerSocket}\n+     * class.  That is, if a security manager has been installed then for each\n+     * new connection this method verifies that the address and port number\n+     * of the connection's remote endpoint are permitted by the security\n+     * manager's {@link java.lang.SecurityManager#checkAccept checkAccept}\n+     * method. If bound to a <i>Unix Domain<\/i> socket address, this method checks\n+     * {@link NetPermission}{@code (\"accessUnixDomainSocket\")}.\n@@ -308,1 +362,1 @@\n-     * <p>\n+     *\n@@ -316,0 +370,7 @@\n+     * <p> Where the channel is bound to a <i>Unix Domain<\/i> socket address, the socket\n+     * address is a {@link UnixDomainSocketAddress}. If there is a security manager\n+     * set, its {@link SecurityManager#checkPermission(java.security.Permission)\n+     * checkPermission} method is called with {@link NetPermission}{@code\n+     * (\"accessUnixDomainSocket\")}. If the operation is not allowed an unnamed\n+     * {@link UnixDomainSocketAddress} is returned.\n+     *\n@@ -317,2 +378,2 @@\n-     *          {@code SocketAddress} representing the loopback address if\n-     *          denied by the security manager, or {@code null} if the\n+     *          {@code SocketAddress} representing the loopback address or empty\n+     *          path if denied by the security manager, or {@code null} if the\n@@ -326,1 +387,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/ServerSocketChannel.java","additions":89,"deletions":29,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.net.InetSocketAddress;\n+import java.net.NetPermission;\n@@ -30,0 +32,1 @@\n+import java.net.StandardProtocolFamily;\n@@ -33,0 +36,1 @@\n+import java.net.UnixDomainSocketAddress;\n@@ -41,9 +45,12 @@\n- * <p> A socket channel is created by invoking one of the {@link #open open}\n- * methods of this class.  It is not possible to create a channel for an arbitrary,\n- * pre-existing socket. A newly-created socket channel is open but not yet\n- * connected.  An attempt to invoke an I\/O operation upon an unconnected\n- * channel will cause a {@link NotYetConnectedException} to be thrown.  A\n- * socket channel can be connected by invoking its {@link #connect connect}\n- * method; once connected, a socket channel remains connected until it is\n- * closed.  Whether or not a socket channel is connected may be determined by\n- * invoking its {@link #isConnected isConnected} method.\n+ * <p> A socket channel is created by invoking one of the {@code open} methods of\n+ * this class. The no-arg {@link #open() open} method opens a socket channel\n+ * for an <i>Internet protocol<\/i> socket. The {@link #open(ProtocolFamily)}\n+ * method is used to open a socket channel for a socket of a specified protocol\n+ * family. It is not possible to create a channel for an arbitrary, pre-existing\n+ * socket. A newly-created socket channel is open but not yet connected.  An\n+ * attempt to invoke an I\/O operation upon an unconnected channel will cause a\n+ * {@link NotYetConnectedException} to be thrown.  A socket channel can be\n+ * connected by invoking its {@link #connect connect} method; once connected,\n+ * a socket channel remains connected until it is closed.  Whether or not a\n+ * socket channel is connected may be determined by invoking its {@link #isConnected()\n+ * isConnected} method.\n@@ -58,1 +65,1 @@\n- * <p> Socket channels support <i>asynchronous shutdown,<\/i> which is similar\n+ * <p> Socket channels support <i>asynchronous shutdown<\/i>, which is similar\n@@ -69,1 +76,2 @@\n- * setOption} method. Socket channels support the following options:\n+ * setOption} method. Socket channels for  <i>Internet protocol<\/i> sockets support\n+ * following options:\n@@ -108,1 +116,30 @@\n- * Additional (implementation specific) options may also be supported.\n+ *\n+ * <p> Socket channels for <i>Unix domain<\/i> sockets support:\n+ * <blockquote>\n+ * <table class=\"striped\">\n+ * <caption style=\"display:none\">Socket options<\/caption>\n+ * <thead>\n+ *   <tr>\n+ *     <th scope=\"col\">Option Name<\/th>\n+ *     <th scope=\"col\">Description<\/th>\n+ *   <\/tr>\n+ * <\/thead>\n+ * <tbody>\n+ *   <tr>\n+ *     <th scope=\"row\"> {@link java.net.StandardSocketOptions#SO_SNDBUF SO_SNDBUF} <\/th>\n+ *     <td> The size of the socket send buffer <\/td>\n+ *   <\/tr>\n+ *   <tr>\n+ *     <th scope=\"row\"> {@link java.net.StandardSocketOptions#SO_RCVBUF SO_RCVBUF} <\/th>\n+ *     <td> The size of the socket receive buffer <\/td>\n+ *   <\/tr>\n+ *   <tr>\n+ *     <th scope=\"row\"> {@link java.net.StandardSocketOptions#SO_LINGER SO_LINGER} <\/th>\n+ *     <td> Linger on close if data is present (when configured in blocking mode\n+ *          only) <\/td>\n+ *   <\/tr>\n+ * <\/tbody>\n+ * <\/table>\n+ * <\/blockquote>\n+ *\n+ * <p> Additional (implementation specific) options may also be supported.\n@@ -139,1 +176,1 @@\n-     * Opens a socket channel.\n+     * Opens a socket channel for an <i>Internet protocol<\/i> socket.\n@@ -150,0 +187,3 @@\n+     *\n+     * @see     <a href=\"..\/..\/net\/doc-files\/net-properties.html#Ipv4IPv6\">\n+     *          java.net.preferIPv4Stack<\/a> system property\n@@ -177,0 +217,3 @@\n+     * @see     <a href=\"..\/..\/net\/doc-files\/net-properties.html#Ipv4IPv6\">\n+     *          java.net.preferIPv4Stack<\/a> system property\n+     *\n@@ -186,4 +229,10 @@\n-     * <p> This convenience method works as if by invoking the {@link #open()}\n-     * method, invoking the {@link #connect(SocketAddress) connect} method upon\n-     * the resulting socket channel, passing it {@code remote}, and then\n-     * returning that channel.  <\/p>\n+     * <p> If the remote address is an {@link InetSocketAddress} then this\n+     * method works as if by invoking the {@link #open()} method, invoking the\n+     * {@link #connect(SocketAddress) connect} method upon the resulting socket\n+     * channel, passing it {@code remote}, and then returning that channel.\n+     *\n+     * <p> If the remote address is a {@link UnixDomainSocketAddress} then this\n+     * works by invoking the {@link #open(ProtocolFamily)} method with {@link\n+     * StandardProtocolFamily#UNIX} as parameter, invoking the {@link\n+     * #connect(SocketAddress) connect} method upon the resulting socket channel,\n+     * passing it {@code remote}, then returning that channel.  <\/p>\n@@ -207,1 +256,2 @@\n-     *          If the given remote address is not fully resolved\n+     *          If the given remote address is an InetSocketAddress that is not fully\n+     *          resolved\n@@ -218,0 +268,3 @@\n+     *\n+     * @see     <a href=\"..\/..\/net\/doc-files\/net-properties.html#Ipv4IPv6\">\n+     *          java.net.preferIPv4Stack<\/a> system property\n@@ -222,1 +275,9 @@\n-        SocketChannel sc = open();\n+        SocketChannel sc;\n+        requireNonNull(remote);\n+        if (remote instanceof InetSocketAddress)\n+            sc = open();\n+        else if (remote instanceof UnixDomainSocketAddress)\n+            sc = open(StandardProtocolFamily.UNIX);\n+        else\n+            throw new UnsupportedAddressTypeException();\n+\n@@ -258,0 +319,32 @@\n+     * Binds the channel's socket to a local address.\n+     *\n+     * <p> This method is used to establish an association between the socket\n+     * and a local address. For <i>Internet Protocol<\/i> sockets, once an\n+     * association is established then the socket remains bound until the\n+     * channel is closed. If the {@code local} parameter has the value {@code\n+     * null} then the socket will be bound to an address that is assigned\n+     * automatically.\n+     *\n+     * @apiNote\n+     * Binding a socket channel to a <i>Unix Domain<\/i> socket creates a file\n+     * corresponding to the file path in the {@link UnixDomainSocketAddress}. This\n+     * file persists after the channel is closed, and must be removed before\n+     * another socket can bind to the same name. If a socket channel to a Unix\n+     * Domain socket is <i>implicitly<\/i> bound by connecting it without calling\n+     * bind first, then its socket is\n+     * <a href=\"..\/..\/java\/net\/UnixDomainSocketAddress.html#unnamed\">unnamed<\/a>\n+     * with no corresponding socket file in the file-system. If a socket channel\n+     * to a Unix Domain socket is <i>automatically<\/i> bound by calling {@code\n+     * bind(null)} this results in an unnamed socket also.\n+     *\n+     * @implNote\n+     * Each platform enforces an implementation specific maximum length for the\n+     * name of a <i>Unix Domain<\/i> socket. This limitation is enforced when a\n+     * channel is bound. The maximum length is typically close to and generally\n+     * not less than 100 bytes.\n+     *\n+     * @param   local The address to bind the socket, or {@code null} to bind\n+     *          the socket to an automatically assigned socket address\n+     *\n+     * @return  This channel\n+     *\n@@ -266,3 +359,5 @@\n-     *          If a security manager has been installed and its\n-     *          {@link SecurityManager#checkListen checkListen} method denies\n-     *          the operation\n+     *          If a security manager has been installed and its {@link\n+     *          SecurityManager#checkListen checkListen} method denies\n+     *          the operation for an <i>Internet protocol<\/i> socket address,\n+     *          or for a <i>Unix domain<\/i> socket address if it denies\n+     *          {@link NetPermission}{@code(\"accessUnixDomainSocket\")}.\n@@ -332,3 +427,0 @@\n-     * <p> The returned object will not declare any public methods that are not\n-     * declared in the {@link java.net.Socket} class.  <\/p>\n-     *\n@@ -336,0 +428,3 @@\n+     *\n+     * @throws  UnsupportedOperationException\n+     *          If the channel's socket is not an <i>Internet protocol<\/i> socket\n@@ -371,2 +466,3 @@\n-     * <p> This method performs exactly the same security checks as the {@link\n-     * java.net.Socket} class.  That is, if a security manager has been\n+     * <p> For channels to <i>Internet protocol<\/i> sockets, this method performs\n+     * exactly the same security checks as the {@link java.net.Socket} class.\n+     * That is, if a security manager has been\n@@ -377,0 +473,6 @@\n+     * <p> For channels to <i>Unix Domain<\/i> sockets, this method checks\n+     * {@link java.net.NetPermission NetPermission}{@code\n+     * (\"accessUnixDomainSocket\")} with the security manager's {@link\n+     * SecurityManager#checkPermission(java.security.Permission)\n+     * checkPermission} method.\n+     *\n@@ -412,1 +514,1 @@\n-     *          If the given remote address is not fully resolved\n+     *          If the given remote address is an InetSocketAddress that is not fully resolved\n@@ -480,3 +582,6 @@\n-     * <p> Where the channel is bound and connected to an Internet Protocol\n-     * socket address then the return value from this method is of type {@link\n-     * java.net.InetSocketAddress}.\n+     * <p> Where the channel's socket is bound and connected to an <i>Internet\n+     * Protocol<\/i> socket address then the return value is of type\n+     * {@link java.net.InetSocketAddress}.\n+     *\n+     * <p> Where the channel's socket is bound and connected to a <i>Unix Domain<\/i>\n+     * socket address, the returned address is a {@link UnixDomainSocketAddress}.\n@@ -542,1 +647,1 @@\n-     * <p>\n+     *\n@@ -550,0 +655,7 @@\n+     * <p> Where the channel is bound to a Unix Domain socket address, the socket\n+     * address is a {@link UnixDomainSocketAddress}. If there is a security manager\n+     * set, its {@link SecurityManager#checkPermission(java.security.Permission)\n+     * checkPermission} method is called with {@link NetPermission}{@code\n+     * (\"accessUnixDomainSocket\")}. If the operation is not allowed an unnamed\n+     * {@link UnixDomainSocketAddress} is returned.\n+     *\n@@ -551,2 +663,2 @@\n-     *          {@code SocketAddress} representing the loopback address if\n-     *          denied by the security manager, or {@code null} if the\n+     *          {@code SocketAddress} representing the loopback address or empty\n+     *          path if denied by the security manager, or {@code null} if the\n@@ -560,1 +672,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/SocketChannel.java","additions":146,"deletions":35,"binary":false,"changes":181,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -244,0 +244,22 @@\n+ * <p> {@link java.nio.channels.DatagramChannel},\n+ * {@link java.nio.channels.SocketChannel} and\n+ * {@link java.nio.channels.ServerSocketChannel}s can be created\n+ * with different {@link java.net.ProtocolFamily protocol families}. The standard\n+ * family types are specified in {@link java.net.StandardProtocolFamily}.\n+ *\n+ * <p> Channels for <i>Internet Protocol<\/i> sockets are created using the\n+ * {@link java.net.StandardProtocolFamily#INET INET} or {@link\n+ * java.net.StandardProtocolFamily#INET6 INET6} protocol families. <i>Internet\n+ * Protocol<\/i> sockets support network communication using TCP and UDP and are\n+ * addressed using {@link java.net.InetSocketAddress}es which encapsulate an IP\n+ * address and port number. <i>Internet Protocol<\/i> sockets are also the default\n+ * type created, when a protocol family is not specified in the channel factory\n+ * creation method.\n+ *\n+ * <p> Channels for <a id=\"unixdomain\"><\/a><i>Unix Domain<\/i> sockets are created\n+ * using the {@link java.net.StandardProtocolFamily#UNIX UNIX} protocol family.\n+ * <i>Unix Domain<\/i> sockets support local inter-process\n+ * communication on the same host, and are addressed using {@link\n+ * java.net.UnixDomainSocketAddress}es which encapsulate a filesystem pathname\n+ * on the local system.\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/package-info.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -271,2 +271,2 @@\n-     * <p> In cases where the inherited channel represents a network socket\n-     * then the {@link java.nio.channels.Channel Channel} type returned\n+     * <p> In cases where the inherited channel is for an <i>Internet protocol<\/i>\n+     * socket then the {@link Channel Channel} type returned\n@@ -277,4 +277,4 @@\n-     *  <li><p> If the inherited channel represents a stream-oriented connected\n-     *  socket then a {@link java.nio.channels.SocketChannel SocketChannel} is\n-     *  returned. The socket channel is, at least initially, in blocking\n-     *  mode, bound to a socket address, and connected to a peer.\n+     *  <li><p> If the inherited channel is for a stream-oriented connected\n+     *  socket then a {@link SocketChannel SocketChannel} is returned. The\n+     *  socket channel is, at least initially, in blocking mode, bound\n+     *  to a socket address, and connected to a peer.\n@@ -283,4 +283,4 @@\n-     *  <li><p> If the inherited channel represents a stream-oriented listening\n-     *  socket then a {@link java.nio.channels.ServerSocketChannel\n-     *  ServerSocketChannel} is returned. The server-socket channel is, at\n-     *  least initially, in blocking mode, and bound to a socket address.\n+     *  <li><p> If the inherited channel is for a stream-oriented listening\n+     *  socket then a {@link ServerSocketChannel ServerSocketChannel} is returned.\n+     *  The server-socket channel is, at least initially, in blocking mode,\n+     *  and bound to a socket address.\n@@ -289,4 +289,3 @@\n-     *  <li><p> If the inherited channel is a datagram-oriented socket\n-     *  then a {@link java.nio.channels.DatagramChannel DatagramChannel} is\n-     *  returned. The datagram channel is, at least initially, in blocking\n-     *  mode, and bound to a socket address.\n+     *  <li><p> If the inherited channel is a datagram-oriented socket then a\n+     *  {@link DatagramChannel DatagramChannel} is returned. The datagram channel\n+     *  is, at least initially, in blocking mode, and bound to a socket address.\n@@ -297,2 +296,7 @@\n-     * <p> In addition to the network-oriented channels described, this method\n-     * may return other kinds of channels in the future.\n+     * <p> In cases where the inherited channel is for a <i>Unix domain<\/i>\n+     * socket then the {@link Channel} type returned is the same as for\n+     * <i>Internet protocol<\/i> sockets as described above, except that\n+     * datagram-oriented sockets are not supported.\n+     *\n+     * <p> In addition to the two types of socket just described, this method\n+     * may return other types in the future.\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/spi\/SelectorProvider.java","additions":20,"deletions":16,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,2 +36,1 @@\n-import sun.security.action.GetPropertyAction;\n-\n+import jdk.internal.util.StaticProperty;\n@@ -48,2 +47,1 @@\n-    private static final Path tmpdir =\n-        Path.of(GetPropertyAction.privilegedGetProperty(\"java.io.tmpdir\"));\n+    private static final Path tmpdir = Path.of(StaticProperty.javaIoTmpDir());\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/TempFileHelper.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1559,1 +1559,1 @@\n-     *    uu      2      appendValueReduced(ChronoField.YEAR, 2, 2000)\n+     *    uu      2      appendValueReduced(ChronoField.YEAR, 2, 2, 2000)\n@@ -1563,1 +1563,1 @@\n-     *    yy      2      appendValueReduced(ChronoField.YEAR_OF_ERA, 2, 2000)\n+     *    yy      2      appendValueReduced(ChronoField.YEAR_OF_ERA, 2, 2, 2000)\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatterBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-    private static final AtomicInteger nextSerialNumber = new AtomicInteger(0);\n+    private static final AtomicInteger nextSerialNumber = new AtomicInteger();\n","filename":"src\/java.base\/share\/classes\/java\/util\/Timer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-        sharedResult = new AtomicReference<>(null);\n+        sharedResult = new AtomicReference<>();\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/AbstractShortCircuitTask.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,0 +65,5 @@\n+        \/\/ The RECORDS enum constant is not used in the JDK 16 codebase, but\n+        \/\/ exists to support the bootcycle build of JDK 16. The bootcycle build\n+        \/\/ of JDK 16 is performed with JDK 15 and the PreviewFeature type from\n+        \/\/ JDK 16. Since the JDK 15 codebase uses the enum constant, it is\n+        \/\/ necessary for PreviewFeature in JDK 16 to declare the enum constant.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/PreviewFeature.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -4544,1 +4544,2 @@\n-                      \" is out of range 0 to \" + limit);\n+                      \" is out of range 0 to \" + limit + \", or limit \" + limit +\n+                      \" is beyond the text length \" + text.length);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/icu\/text\/BidiBase.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+    private static final String JAVA_IO_TMPDIR;\n@@ -59,0 +60,1 @@\n+        JAVA_IO_TMPDIR = getProperty(props, \"java.io.tmpdir\");\n@@ -143,0 +145,13 @@\n+    \/**\n+     * Return the {@code java.io.tmpdir} system property.\n+     *\n+     * <strong>{@link SecurityManager#checkPropertyAccess} is NOT checked\n+     * in this method. The caller of this method should take care to ensure\n+     * that the returned property is not made accessible to untrusted code.<\/strong>\n+     *\n+     * @return the {@code java.io.tmpdir} system property\n+     *\/\n+    public static String javaIoTmpDir() {\n+        return JAVA_IO_TMPDIR;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/StaticProperty.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -274,0 +274,2 @@\n+    exports sun.nio.fs to\n+        jdk.net;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-        numSockets = new AtomicInteger(0);\n+        numSockets = new AtomicInteger();\n","filename":"src\/java.base\/share\/classes\/sun\/net\/ResourceManager.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,1 @@\n+    private final Set<SocketOption<?>> unixDomainClientOptions;\n@@ -76,0 +77,13 @@\n+    \/**\n+     * Return the, possibly empty, set of extended socket options available for\n+     * Unix domain client sockets. Note, there are no extended\n+     * Unix domain server options.\n+     *\/\n+    private final Set<SocketOption<?>> unixDomainClientOptions() {\n+        return unixDomainClientOptions;\n+    }\n+\n+    public static Set<SocketOption<?>> unixDomainSocketOptions() {\n+        return getInstance().unixDomainClientOptions();\n+    }\n+\n@@ -85,1 +99,9 @@\n-        return !option.name().startsWith(\"TCP_\");\n+        if (option.name().startsWith(\"TCP_\") || isUnixDomainOption(option)) {\n+            return false;\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    private static boolean isUnixDomainOption(SocketOption<?> option) {\n+        return option.name().equals(\"SO_PEERCRED\");\n@@ -89,1 +111,1 @@\n-        if (server && \"SO_FLOW_SLA\".equals(option.name())) {\n+        if (option.name().startsWith(\"UDP_\") || isUnixDomainOption(option)) {\n@@ -92,1 +114,1 @@\n-            return !option.name().startsWith(\"UDP_\");\n+            return true;\n@@ -125,0 +147,1 @@\n+        var unixDomainClientOptions = new HashSet<SocketOption<?>>();\n@@ -135,0 +158,3 @@\n+            if (isUnixDomainOption(option)) {\n+                unixDomainClientOptions.add(option);\n+            }\n@@ -139,0 +165,1 @@\n+        this.unixDomainClientOptions = Set.copyOf(unixDomainClientOptions);\n","filename":"src\/java.base\/share\/classes\/sun\/net\/ext\/ExtendedSocketOptions.java","additions":31,"deletions":4,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,4 @@\n-import java.text.ParseException;\n-import java.text.SimpleDateFormat;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n@@ -40,1 +42,0 @@\n-import java.util.TimeZone;\n@@ -292,3 +293,0 @@\n-\n-        private SimpleDateFormat df = new SimpleDateFormat(\"yyyyMMddhhmmss\");\n-\n@@ -329,5 +327,1 @@\n-                Date d = null;\n-                try {\n-                    d = df.parse(s);\n-                } catch (ParseException ex) {\n-                }\n+                Date d = parseRfc3659TimeValue(s);\n@@ -340,5 +334,1 @@\n-                Date d = null;\n-                try {\n-                    d = df.parse(s);\n-                } catch (ParseException ex) {\n-                }\n+                Date d = parseRfc3659TimeValue(s);\n@@ -1752,5 +1742,0 @@\n-    private static String[] MDTMformats = {\n-        \"yyyyMMddHHmmss.SSS\",\n-        \"yyyyMMddHHmmss\"\n-    };\n-    private static SimpleDateFormat[] dateFormats = new SimpleDateFormat[MDTMformats.length];\n@@ -1758,6 +1743,2 @@\n-    static {\n-        for (int i = 0; i < MDTMformats.length; i++) {\n-            dateFormats[i] = new SimpleDateFormat(MDTMformats[i]);\n-            dateFormats[i].setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n-        }\n-    }\n+    private static final DateTimeFormatter RFC3659_DATETIME_FORMAT = DateTimeFormatter.ofPattern(\"yyyyMMddHHmmss[.SSS]\")\n+                                                                                      .withZone(ZoneOffset.UTC);\n@@ -1780,11 +1761,2 @@\n-            String s = getResponseString().substring(4);\n-            Date d = null;\n-            for (SimpleDateFormat dateFormat : dateFormats) {\n-                try {\n-                    d = dateFormat.parse(s);\n-                } catch (ParseException ex) {\n-                }\n-                if (d != null) {\n-                    return d;\n-                }\n-            }\n+            String s = getResponseString();\n+            return parseRfc3659TimeValue(s.substring(4, s.length() - 1));\n@@ -1795,0 +1767,10 @@\n+    private static Date parseRfc3659TimeValue(String s) {\n+        Date result = null;\n+        try {\n+            var d = ZonedDateTime.parse(s, RFC3659_DATETIME_FORMAT);\n+            result = Date.from(d.toInstant());\n+        } catch (DateTimeParseException ex) {\n+        }\n+        return result;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/net\/ftp\/impl\/FtpClient.java","additions":21,"deletions":39,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+import java.net.UnixDomainSocketAddress;\n+import java.net.SocketAddress;\n@@ -54,2 +56,2 @@\n-    public static IOException of(IOException e, InetSocketAddress address) {\n-        if (!enhancedExceptionText || address == null)\n+    public static IOException of(IOException e, SocketAddress addr) {\n+        if (!enhancedExceptionText || addr == null) {\n@@ -57,2 +59,13 @@\n-        int port = address.getPort();\n-        String host = address.getHostString();\n+        }\n+        if (addr instanceof UnixDomainSocketAddress) {\n+            return ofUnixDomain(e, (UnixDomainSocketAddress)addr);\n+        } else if (addr instanceof InetSocketAddress) {\n+            return ofInet(e, (InetSocketAddress)addr);\n+        } else {\n+            return e;\n+        }\n+    }\n+\n+    private static IOException ofInet(IOException e, InetSocketAddress addr) {\n+        int port = addr.getPort();\n+        String host = addr.getHostString();\n@@ -69,0 +82,10 @@\n+    private static IOException ofUnixDomain(IOException e, UnixDomainSocketAddress addr) {\n+        String path = addr.getPath().toString();\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(e.getMessage());\n+        sb.append(\": \");\n+        sb.append(path);\n+        String enhancedMsg = sb.toString();\n+        return create(e, enhancedMsg);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/net\/util\/SocketExceptions.java","additions":28,"deletions":5,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -229,1 +229,2 @@\n-    static InetSocketAddress getRevealedLocalAddress(InetSocketAddress addr) {\n+    static InetSocketAddress getRevealedLocalAddress(SocketAddress sa) {\n+        InetSocketAddress isa = (InetSocketAddress) sa;\n@@ -231,9 +232,7 @@\n-        if (addr == null || sm == null)\n-            return addr;\n-\n-        try{\n-            sm.checkConnect(addr.getAddress().getHostAddress(), -1);\n-            \/\/ Security check passed\n-        } catch (SecurityException e) {\n-            \/\/ Return loopback address only if security check fails\n-            addr = getLoopbackAddress(addr.getPort());\n+        if (isa != null && sm != null) {\n+            try {\n+                sm.checkConnect(isa.getAddress().getHostAddress(), -1);\n+            } catch (SecurityException e) {\n+                \/\/ Return loopback address only if security check fails\n+                isa = getLoopbackAddress(isa.getPort());\n+            }\n@@ -241,1 +240,1 @@\n-        return addr;\n+        return isa;\n@@ -244,3 +243,7 @@\n-    static String getRevealedLocalAddressAsString(InetSocketAddress addr) {\n-        return System.getSecurityManager() == null ? addr.toString() :\n-                getLoopbackAddress(addr.getPort()).toString();\n+    static String getRevealedLocalAddressAsString(SocketAddress sa) {\n+        InetSocketAddress isa = (InetSocketAddress) sa;\n+        if (System.getSecurityManager() == null) {\n+            return isa.toString();\n+        } else {\n+            return getLoopbackAddress(isa.getPort()).toString();\n+        }\n@@ -250,2 +253,1 @@\n-        return new InetSocketAddress(InetAddress.getLoopbackAddress(),\n-                                     port);\n+        return new InetSocketAddress(InetAddress.getLoopbackAddress(), port);\n@@ -577,0 +579,7 @@\n+    static int connect(ProtocolFamily family, FileDescriptor fd, SocketAddress remote)\n+        throws IOException\n+    {\n+        InetSocketAddress isa = (InetSocketAddress) remote;\n+        return connect(family, fd, isa.getAddress(), isa.getPort());\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/Net.java","additions":25,"deletions":16,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -1,63 +0,0 @@\n-\/*\n- * Copyright (c) 2010, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.nio.ch;\n-\n-import java.nio.channels.SocketChannel;\n-import java.nio.channels.ServerSocketChannel;\n-import java.nio.channels.spi.SelectorProvider;\n-import java.io.FileDescriptor;\n-import java.io.IOException;\n-\n-\/**\n- * Provides access to implementation private constructors and methods.\n- *\/\n-\n-public final class Secrets {\n-    private Secrets() { }\n-\n-    private static SelectorProvider provider() {\n-        SelectorProvider p = SelectorProvider.provider();\n-        if (!(p instanceof SelectorProviderImpl))\n-            throw new UnsupportedOperationException();\n-        return p;\n-    }\n-\n-    public static SocketChannel newSocketChannel(FileDescriptor fd) {\n-        try {\n-            return new SocketChannelImpl(provider(), fd, false);\n-        } catch (IOException ioe) {\n-            throw new AssertionError(ioe);\n-        }\n-    }\n-\n-    public static ServerSocketChannel newServerSocketChannel(FileDescriptor fd) {\n-        try {\n-            return new ServerSocketChannelImpl(provider(), fd, false);\n-        } catch (IOException ioe) {\n-            throw new AssertionError(ioe);\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/Secrets.java","additions":0,"deletions":63,"binary":false,"changes":63,"status":"deleted"},{"patch":"@@ -36,0 +36,4 @@\n+import java.util.Objects;\n+import static java.net.StandardProtocolFamily.INET;\n+import static java.net.StandardProtocolFamily.INET6;\n+import static java.net.StandardProtocolFamily.UNIX;\n@@ -78,1 +82,10 @@\n-        return new SocketChannelImpl(this, family);\n+        Objects.requireNonNull(family, \"'family' is null\");\n+        if (family == INET6 && !Net.isIPv6Available()) {\n+            throw new UnsupportedOperationException(\"IPv6 not available\");\n+        } else if (family == INET || family == INET6) {\n+            return new SocketChannelImpl(this, family);\n+        } else if (family == UNIX && UnixDomainSockets.isSupported()) {\n+            return new SocketChannelImpl(this, family);\n+        } else {\n+            throw new UnsupportedOperationException(\"Protocol family not supported\");\n+        }\n@@ -82,2 +95,11 @@\n-    public ServerSocketChannel openServerSocketChannel(ProtocolFamily family) {\n-        return new ServerSocketChannelImpl(this, family);\n+    public ServerSocketChannel openServerSocketChannel(ProtocolFamily family) throws IOException {\n+        Objects.requireNonNull(family, \"'family' is null\");\n+        if (family == INET6 && !Net.isIPv6Available()) {\n+            throw new UnsupportedOperationException(\"IPv6 not available\");\n+        } else if (family == INET || family == INET6)  {\n+            return new ServerSocketChannelImpl(this, family);\n+        } else if (family == UNIX && UnixDomainSockets.isSupported()) {\n+            return new ServerSocketChannelImpl(this, family);\n+        } else {\n+            throw new UnsupportedOperationException(\"Protocol family not supported\");\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SelectorProviderImpl.java","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,1 +96,1 @@\n-        InetSocketAddress local = ssc.localAddress();\n+        SocketAddress local = ssc.localAddress();\n@@ -106,1 +106,1 @@\n-        InetSocketAddress local = ssc.localAddress();\n+        InetSocketAddress local = (InetSocketAddress) ssc.localAddress();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ServerSocketAdaptor.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.net.BindException;\n@@ -36,1 +37,0 @@\n-import java.net.StandardProtocolFamily;\n@@ -38,0 +38,1 @@\n+import java.net.UnixDomainSocketAddress;\n@@ -47,0 +48,1 @@\n+import java.nio.file.Path;\n@@ -49,1 +51,0 @@\n-import java.util.Objects;\n@@ -51,0 +52,1 @@\n+import java.util.Objects;\n@@ -52,0 +54,3 @@\n+import static java.net.StandardProtocolFamily.INET;\n+import static java.net.StandardProtocolFamily.INET6;\n+import static java.net.StandardProtocolFamily.UNIX;\n@@ -93,1 +98,1 @@\n-    private InetSocketAddress localAddress; \/\/ null => unbound\n+    private SocketAddress localAddress; \/\/ null => unbound\n@@ -103,4 +108,2 @@\n-    ServerSocketChannelImpl(SelectorProvider sp) {\n-        this(sp, Net.isIPv6Available()\n-                ? StandardProtocolFamily.INET6\n-                : StandardProtocolFamily.INET);\n+    ServerSocketChannelImpl(SelectorProvider sp) throws IOException {\n+        this(sp, Net.isIPv6Available() ? INET6 : INET);\n@@ -109,1 +112,3 @@\n-    ServerSocketChannelImpl(SelectorProvider sp, ProtocolFamily family) {\n+    ServerSocketChannelImpl(SelectorProvider sp, ProtocolFamily family)\n+        throws IOException\n+    {\n@@ -112,3 +117,1 @@\n-\n-        if ((family != StandardProtocolFamily.INET) &&\n-                (family != StandardProtocolFamily.INET6)) {\n+        if ((family != INET) && (family != INET6) && (family != UNIX)) {\n@@ -117,1 +120,1 @@\n-        if (family == StandardProtocolFamily.INET6 && !Net.isIPv6Available()) {\n+        if (family == INET6 && !Net.isIPv6Available()) {\n@@ -122,1 +125,5 @@\n-        this.fd = Net.serverSocket(family, true);\n+        if (family == UNIX) {\n+            this.fd = UnixDomainSockets.socket();\n+        } else {\n+            this.fd = Net.serverSocket(family, true);\n+        }\n@@ -126,1 +133,4 @@\n-    ServerSocketChannelImpl(SelectorProvider sp, FileDescriptor fd, boolean bound)\n+    ServerSocketChannelImpl(SelectorProvider sp,\n+                            ProtocolFamily family,\n+                            FileDescriptor fd,\n+                            boolean bound)\n@@ -131,4 +141,6 @@\n-        this.family = Net.isIPv6Available()\n-                ? StandardProtocolFamily.INET6\n-                : StandardProtocolFamily.INET;\n-        this.fd =  fd;\n+        if (family == UNIX) {\n+            this.family = UNIX;\n+        } else {\n+            this.family = Net.isIPv6Available() ? INET6 : INET;\n+        }\n+        this.fd = fd;\n@@ -139,1 +151,5 @@\n-                localAddress = Net.localAddress(fd);\n+                if (family == UNIX) {\n+                    localAddress = UnixDomainSockets.localAddress(fd);\n+                } else {\n+                    localAddress = Net.localAddress(fd);\n+                }\n@@ -144,0 +160,14 @@\n+    \/**\n+     * Returns true if this channel is to a INET or INET6 socket.\n+     *\/\n+    private boolean isNetSocket() {\n+        return (family == INET) || (family == INET6);\n+    }\n+\n+    \/**\n+     * Returns true if this channel is to a UNIX socket.\n+     *\/\n+    boolean isUnixSocket() {\n+        return (family == UNIX);\n+    }\n+\n@@ -153,2 +183,7 @@\n-            if (socket == null)\n-                socket = ServerSocketAdaptor.create(this);\n+            if (socket == null) {\n+                if (isNetSocket()) {\n+                    socket = ServerSocketAdaptor.create(this);\n+                } else {\n+                    throw new UnsupportedOperationException(\"Not supported\");\n+                }\n+            }\n@@ -163,3 +198,5 @@\n-            return (localAddress == null)\n-                    ? null\n-                    : Net.getRevealedLocalAddress(localAddress);\n+            if (isUnixSocket()) {\n+                return UnixDomainSockets.getRevealedLocalAddress(localAddress);\n+            } else {\n+                return Net.getRevealedLocalAddress(localAddress);\n+            }\n@@ -181,2 +218,3 @@\n-\n-            if (name == StandardSocketOptions.SO_REUSEADDR && Net.useExclusiveBind()) {\n+            if (isNetSocket()\n+                    && name == StandardSocketOptions.SO_REUSEADDR\n+                    && Net.useExclusiveBind()) {\n@@ -184,1 +222,1 @@\n-                isReuseAddress = (Boolean)value;\n+                isReuseAddress = (Boolean) value;\n@@ -204,1 +242,3 @@\n-            if (name == StandardSocketOptions.SO_REUSEADDR && Net.useExclusiveBind()) {\n+            if (isNetSocket()\n+                    && name == StandardSocketOptions.SO_REUSEADDR\n+                    && Net.useExclusiveBind()) {\n@@ -206,1 +246,4 @@\n-                return (T)Boolean.valueOf(isReuseAddress);\n+                return (T) Boolean.valueOf(isReuseAddress);\n+            } else {\n+                \/\/ no options that require special handling\n+                return (T) Net.getSocketOption(fd, Net.UNSPEC, name);\n@@ -208,2 +251,0 @@\n-            \/\/ no options that require special handling\n-            return (T) Net.getSocketOption(fd, Net.UNSPEC, name);\n@@ -214,1 +255,2 @@\n-        static final Set<SocketOption<?>> defaultOptions = defaultOptions();\n+        static final Set<SocketOption<?>> defaultInetOptions = defaultInetOptions();\n+        static final Set<SocketOption<?>> defaultUnixDomainOptions = defaultUnixDomainOptions();\n@@ -216,1 +258,1 @@\n-        private static Set<SocketOption<?>> defaultOptions() {\n+        private static Set<SocketOption<?>> defaultInetOptions() {\n@@ -226,0 +268,6 @@\n+\n+        private static Set<SocketOption<?>> defaultUnixDomainOptions() {\n+            HashSet<SocketOption<?>> set = new HashSet<>();\n+            set.add(StandardSocketOptions.SO_RCVBUF);\n+            return Collections.unmodifiableSet(set);\n+        }\n@@ -230,1 +278,5 @@\n-        return DefaultOptionsHolder.defaultOptions;\n+        if (isUnixSocket()) {\n+            return DefaultOptionsHolder.defaultUnixDomainOptions;\n+        } else {\n+            return DefaultOptionsHolder.defaultInetOptions;\n+        }\n@@ -239,3 +291,2 @@\n-            InetSocketAddress isa;\n-            if (local == null) {\n-                isa = new InetSocketAddress(Net.anyLocalAddress(family), 0);\n+            if (isUnixSocket()) {\n+                localAddress = unixBind(local, backlog);\n@@ -243,1 +294,1 @@\n-                isa = Net.checkAddress(local, family);\n+                localAddress = netBind(local, backlog);\n@@ -245,7 +296,0 @@\n-            SecurityManager sm = System.getSecurityManager();\n-            if (sm != null)\n-                sm.checkListen(isa.getPort());\n-            NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());\n-            Net.bind(family, fd, isa.getAddress(), isa.getPort());\n-            Net.listen(fd, backlog < 1 ? 50 : backlog);\n-            localAddress = Net.localAddress(fd);\n@@ -256,0 +300,41 @@\n+    private SocketAddress unixBind(SocketAddress local, int backlog) throws IOException {\n+        UnixDomainSockets.checkPermission();\n+        if (local == null) {\n+            \/\/ Attempt up to 10 times to find an unused name in temp directory.\n+            \/\/ If local address supplied then bind called only once\n+            boolean bound = false;\n+            int attempts = 0;\n+            while (attempts < 10 && !bound) {\n+                try {\n+                    Path path = UnixDomainSockets.generateTempName().getPath();\n+                    UnixDomainSockets.bind(fd, path);\n+                    bound = true;\n+                } catch (BindException e) { }\n+                attempts++;\n+            }\n+            if (!bound)\n+                throw new BindException(\"Could not bind to temporary name\");\n+        } else {\n+            Path path = UnixDomainSockets.checkAddress(local).getPath();\n+            UnixDomainSockets.bind(fd, path);\n+        }\n+        Net.listen(fd, backlog < 1 ? 50 : backlog);\n+        return UnixDomainSockets.localAddress(fd);\n+    }\n+\n+    private SocketAddress netBind(SocketAddress local, int backlog) throws IOException {\n+        InetSocketAddress isa;\n+        if (local == null) {\n+            isa = new InetSocketAddress(Net.anyLocalAddress(family), 0);\n+        } else {\n+            isa = Net.checkAddress(local, family);\n+        }\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null)\n+            sm.checkListen(isa.getPort());\n+        NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());\n+        Net.bind(family, fd, isa.getAddress(), isa.getPort());\n+        Net.listen(fd, backlog < 1 ? 50 : backlog);\n+        return Net.localAddress(fd);\n+    }\n+\n@@ -298,1 +383,1 @@\n-        InetSocketAddress[] isaa = new InetSocketAddress[1];\n+        SocketAddress[] saa = new SocketAddress[1];\n@@ -305,1 +390,1 @@\n-                n = Net.accept(this.fd, newfd, isaa);\n+                n = implAccept(this.fd, newfd, saa);\n@@ -309,1 +394,1 @@\n-                        n = Net.accept(this.fd, newfd, isaa);\n+                        n = implAccept(this.fd, newfd, saa);\n@@ -321,1 +406,1 @@\n-            return finishAccept(newfd, isaa[0]);\n+            return finishAccept(newfd, saa[0]);\n@@ -327,0 +412,19 @@\n+    private int implAccept(FileDescriptor fd, FileDescriptor newfd, SocketAddress[] saa)\n+        throws IOException\n+    {\n+        if (isUnixSocket()) {\n+            UnixDomainSockets.checkPermission();\n+            String[] pa = new String[1];\n+            int n = UnixDomainSockets.accept(fd, newfd, pa);\n+            if (n > 0)\n+                saa[0] = UnixDomainSocketAddress.of(pa[0]);\n+            return n;\n+        } else {\n+            InetSocketAddress[] issa = new InetSocketAddress[1];\n+            int n = Net.accept(fd, newfd, issa);\n+            if (n > 0)\n+                saa[0] = issa[0];\n+            return n;\n+        }\n+    }\n+\n@@ -340,1 +444,1 @@\n-        InetSocketAddress[] isaa = new InetSocketAddress[1];\n+        SocketAddress[] saa = new SocketAddress[1];\n@@ -354,1 +458,1 @@\n-                    n = Net.accept(fd, newfd, isaa);\n+                    n = implAccept(fd, newfd, saa);\n@@ -361,1 +465,1 @@\n-                        n = Net.accept(fd, newfd, isaa);\n+                        n = implAccept(fd, newfd, saa);\n@@ -375,1 +479,1 @@\n-        return finishAccept(newfd, isaa[0]);\n+        return finishAccept(newfd, saa[0]);\n@@ -378,1 +482,1 @@\n-    private SocketChannel finishAccept(FileDescriptor newfd, InetSocketAddress isa)\n+    private SocketChannel finishAccept(FileDescriptor newfd, SocketAddress sa)\n@@ -386,3 +490,6 @@\n-            SecurityManager sm = System.getSecurityManager();\n-            if (sm != null) {\n-                sm.checkAccept(isa.getAddress().getHostAddress(), isa.getPort());\n+            if (isNetSocket()) {\n+                SecurityManager sm = System.getSecurityManager();\n+                if (sm != null) {\n+                    InetSocketAddress isa = (InetSocketAddress) sa;\n+                    sm.checkAccept(isa.getAddress().getHostAddress(), isa.getPort());\n+                }\n@@ -390,1 +497,1 @@\n-            return new SocketChannelImpl(provider(), family, newfd, isa);\n+            return new SocketChannelImpl(provider(), family, newfd, sa);\n@@ -539,1 +646,1 @@\n-    InetSocketAddress localAddress() {\n+    SocketAddress localAddress() {\n@@ -608,1 +715,1 @@\n-                InetSocketAddress addr = localAddress;\n+                SocketAddress addr = localAddress;\n@@ -611,0 +718,2 @@\n+                } else if (isUnixSocket()) {\n+                    sb.append(UnixDomainSockets.getRevealedLocalAddressAsString(addr));\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ServerSocketChannelImpl.java","additions":170,"deletions":61,"binary":false,"changes":231,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,0 +75,8 @@\n+    private InetSocketAddress localAddress() {\n+        return (InetSocketAddress) sc.localAddress();\n+    }\n+\n+    private InetSocketAddress remoteAddress() {\n+        return (InetSocketAddress) sc.remoteAddress();\n+    }\n+\n@@ -109,1 +117,1 @@\n-        InetSocketAddress remote = sc.remoteAddress();\n+        InetSocketAddress remote = remoteAddress();\n@@ -120,1 +128,1 @@\n-            InetSocketAddress local = sc.localAddress();\n+            InetSocketAddress local = localAddress();\n@@ -130,1 +138,1 @@\n-        InetSocketAddress remote = sc.remoteAddress();\n+        InetSocketAddress remote = remoteAddress();\n@@ -140,1 +148,1 @@\n-        InetSocketAddress local = sc.localAddress();\n+        InetSocketAddress local = localAddress();\n@@ -155,6 +163,1 @@\n-        InetSocketAddress local = sc.localAddress();\n-        if (local != null) {\n-            return Net.getRevealedLocalAddress(local);\n-        } else {\n-            return null;\n-        }\n+        return Net.getRevealedLocalAddress(sc.localAddress());\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketAdaptor.java","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import java.net.StandardProtocolFamily;\n@@ -53,0 +52,1 @@\n+import java.nio.file.Path;\n@@ -55,1 +55,0 @@\n-import java.util.Objects;\n@@ -57,0 +56,1 @@\n+import java.util.Objects;\n@@ -58,0 +58,3 @@\n+import static java.net.StandardProtocolFamily.INET;\n+import static java.net.StandardProtocolFamily.INET6;\n+import static java.net.StandardProtocolFamily.UNIX;\n@@ -117,2 +120,2 @@\n-    private InetSocketAddress localAddress;\n-    private InetSocketAddress remoteAddress;\n+    private SocketAddress localAddress;\n+    private SocketAddress remoteAddress;\n@@ -125,2 +128,0 @@\n-    \/\/ Constructor for normal connecting sockets\n-    \/\/\n@@ -128,3 +129,1 @@\n-        this(sp, Net.isIPv6Available()\n-                ? StandardProtocolFamily.INET6\n-                : StandardProtocolFamily.INET);\n+        this(sp, Net.isIPv6Available() ? INET6 : INET);\n@@ -136,2 +135,1 @@\n-        if ((family != StandardProtocolFamily.INET) &&\n-                (family != StandardProtocolFamily.INET6)) {\n+        if ((family != INET) && (family != INET6) && (family != UNIX)) {\n@@ -140,1 +138,1 @@\n-        if (family == StandardProtocolFamily.INET6 && !Net.isIPv6Available()) {\n+        if (family == INET6 && !Net.isIPv6Available()) {\n@@ -143,4 +141,0 @@\n-        this.family = family;\n-        this.fd = Net.socket(family, true);\n-        this.fdVal = IOUtil.fdVal(fd);\n-    }\n@@ -148,14 +142,5 @@\n-    SocketChannelImpl(SelectorProvider sp, FileDescriptor fd, boolean bound)\n-        throws IOException\n-    {\n-        super(sp);\n-        this.family = Net.isIPv6Available()\n-                ? StandardProtocolFamily.INET6\n-                : StandardProtocolFamily.INET;\n-        this.fd = fd;\n-        this.fdVal = IOUtil.fdVal(fd);\n-\n-        if (bound) {\n-            synchronized (stateLock) {\n-                this.localAddress = Net.localAddress(fd);\n-            }\n+        this.family = family;\n+        if (family == UNIX) {\n+            this.fd = UnixDomainSockets.socket();\n+        } else {\n+            this.fd = Net.socket(family, true);\n@@ -163,0 +148,1 @@\n+        this.fdVal = IOUtil.fdVal(fd);\n@@ -170,1 +156,1 @@\n-                      InetSocketAddress isa)\n+                      SocketAddress remoteAddress)\n@@ -178,2 +164,6 @@\n-            this.localAddress = Net.localAddress(fd);\n-            this.remoteAddress = isa;\n+            if (family == UNIX) {\n+                this.localAddress = UnixDomainSockets.localAddress(fd);\n+            } else {\n+                this.localAddress = Net.localAddress(fd);\n+            }\n+            this.remoteAddress = remoteAddress;\n@@ -184,0 +174,14 @@\n+    \/**\n+     * Returns true if this channel is to a INET or INET6 socket.\n+     *\/\n+    boolean isNetSocket() {\n+        return (family == INET) || (family == INET6);\n+    }\n+\n+    \/**\n+     * Returns true if this channel is to a UNIX socket.\n+     *\/\n+    boolean isUnixSocket() {\n+        return (family == UNIX);\n+    }\n+\n@@ -218,2 +222,7 @@\n-            if (socket == null)\n-                socket = SocketAdaptor.create(this);\n+            if (socket == null) {\n+                if (isNetSocket()) {\n+                    socket = SocketAdaptor.create(this);\n+                } else {\n+                    throw new UnsupportedOperationException(\"Not supported\");\n+                }\n+            }\n@@ -228,1 +237,5 @@\n-            return Net.getRevealedLocalAddress(localAddress);\n+            if (isUnixSocket()) {\n+                return UnixDomainSockets.getRevealedLocalAddress(localAddress);\n+            } else {\n+                return Net.getRevealedLocalAddress(localAddress);\n+            }\n@@ -253,9 +266,11 @@\n-            if (name == StandardSocketOptions.IP_TOS) {\n-                Net.setSocketOption(fd, family, name, value);\n-                return this;\n-            }\n-\n-            if (name == StandardSocketOptions.SO_REUSEADDR && Net.useExclusiveBind()) {\n-                \/\/ SO_REUSEADDR emulated when using exclusive bind\n-                isReuseAddress = (Boolean)value;\n-                return this;\n+            if (isNetSocket()) {\n+                if (name == StandardSocketOptions.IP_TOS) {\n+                    \/\/ special handling for IP_TOS\n+                    Net.setSocketOption(fd, family, name, value);\n+                    return this;\n+                }\n+                if (name == StandardSocketOptions.SO_REUSEADDR && Net.useExclusiveBind()) {\n+                    \/\/ SO_REUSEADDR emulated when using exclusive bind\n+                    isReuseAddress = (Boolean) value;\n+                    return this;\n+                }\n@@ -282,8 +297,9 @@\n-            if (name == StandardSocketOptions.SO_REUSEADDR && Net.useExclusiveBind()) {\n-                \/\/ SO_REUSEADDR emulated when using exclusive bind\n-                return (T)Boolean.valueOf(isReuseAddress);\n-            }\n-\n-            \/\/ special handling for IP_TOS\n-            if (name == StandardSocketOptions.IP_TOS) {\n-                return (T) Net.getSocketOption(fd, family, name);\n+            if (isNetSocket()) {\n+                if (name == StandardSocketOptions.IP_TOS) {\n+                    \/\/ special handling for IP_TOS\n+                    return (T) Net.getSocketOption(fd, family, name);\n+                }\n+                if (name == StandardSocketOptions.SO_REUSEADDR && Net.useExclusiveBind()) {\n+                    \/\/ SO_REUSEADDR emulated when using exclusive bind\n+                    return (T) Boolean.valueOf(isReuseAddress);\n+                }\n@@ -298,1 +314,2 @@\n-        static final Set<SocketOption<?>> defaultOptions = defaultOptions();\n+        static final Set<SocketOption<?>> defaultInetOptions = defaultInetOptions();\n+        static final Set<SocketOption<?>> defaultUnixOptions = defaultUnixOptions();\n@@ -300,1 +317,1 @@\n-        private static Set<SocketOption<?>> defaultOptions() {\n+        private static Set<SocketOption<?>> defaultInetOptions() {\n@@ -317,0 +334,9 @@\n+\n+        private static Set<SocketOption<?>> defaultUnixOptions() {\n+            HashSet<SocketOption<?>> set = new HashSet<>();\n+            set.add(StandardSocketOptions.SO_SNDBUF);\n+            set.add(StandardSocketOptions.SO_RCVBUF);\n+            set.add(StandardSocketOptions.SO_LINGER);\n+            set.addAll(ExtendedSocketOptions.unixDomainSocketOptions());\n+            return Collections.unmodifiableSet(set);\n+        }\n@@ -321,1 +347,5 @@\n-        return DefaultOptionsHolder.defaultOptions;\n+        if (isUnixSocket()) {\n+            return DefaultOptionsHolder.defaultUnixOptions;\n+        } else {\n+            return DefaultOptionsHolder.defaultInetOptions;\n+        }\n@@ -628,1 +658,1 @@\n-    InetSocketAddress localAddress() {\n+    SocketAddress localAddress() {\n@@ -637,1 +667,1 @@\n-    InetSocketAddress remoteAddress() {\n+    SocketAddress remoteAddress() {\n@@ -655,3 +685,2 @@\n-                    InetSocketAddress isa;\n-                    if (local == null) {\n-                        isa = new InetSocketAddress(Net.anyLocalAddress(family), 0);\n+                    if (isUnixSocket()) {\n+                        localAddress = unixBind(local);\n@@ -659,5 +688,1 @@\n-                        isa = Net.checkAddress(local, family);\n-                    }\n-                    SecurityManager sm = System.getSecurityManager();\n-                    if (sm != null) {\n-                        sm.checkListen(isa.getPort());\n+                        localAddress = netBind(local);\n@@ -665,3 +690,0 @@\n-                    NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());\n-                    Net.bind(family, fd, isa.getAddress(), isa.getPort());\n-                    localAddress = Net.localAddress(fd);\n@@ -678,0 +700,32 @@\n+    private SocketAddress unixBind(SocketAddress local) throws IOException {\n+        UnixDomainSockets.checkPermission();\n+        if (local == null) {\n+            return UnixDomainSockets.UNNAMED;\n+        } else {\n+            Path path = UnixDomainSockets.checkAddress(local).getPath();\n+            if (path.toString().isEmpty()) {\n+                return UnixDomainSockets.UNNAMED;\n+            } else {\n+                \/\/ bind to non-empty path\n+                UnixDomainSockets.bind(fd, path);\n+                return UnixDomainSockets.localAddress(fd);\n+            }\n+        }\n+    }\n+\n+    private SocketAddress netBind(SocketAddress local) throws IOException {\n+        InetSocketAddress isa;\n+        if (local == null) {\n+            isa = new InetSocketAddress(Net.anyLocalAddress(family), 0);\n+        } else {\n+            isa = Net.checkAddress(local, family);\n+        }\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null) {\n+            sm.checkListen(isa.getPort());\n+        }\n+        NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());\n+        Net.bind(family, fd, isa.getAddress(), isa.getPort());\n+        return Net.localAddress(fd);\n+    }\n+\n@@ -697,1 +751,1 @@\n-    private void beginConnect(boolean blocking, InetSocketAddress isa)\n+    private void beginConnect(boolean blocking, SocketAddress sa)\n@@ -714,1 +768,2 @@\n-            if (localAddress == null)\n+            if (isNetSocket() && (localAddress == null)) {\n+                InetSocketAddress isa = (InetSocketAddress) sa;\n@@ -716,1 +771,2 @@\n-            remoteAddress = isa;\n+            }\n+            remoteAddress = sa;\n@@ -740,1 +796,5 @@\n-                    localAddress = Net.localAddress(fd);\n+                    if (isUnixSocket()) {\n+                        localAddress = UnixDomainSockets.localAddress(fd);\n+                    } else {\n+                        localAddress = Net.localAddress(fd);\n+                    }\n@@ -750,11 +810,19 @@\n-    private InetSocketAddress checkRemote(SocketAddress sa) {\n-        InetSocketAddress isa = Net.checkAddress(sa, family);\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkConnect(isa.getAddress().getHostAddress(), isa.getPort());\n-        }\n-        InetAddress address = isa.getAddress();\n-        if (address.isAnyLocalAddress()) {\n-            int port = isa.getPort();\n-            if (address instanceof Inet4Address) {\n-                return new InetSocketAddress(Net.inet4LoopbackAddress(), port);\n+    private SocketAddress checkRemote(SocketAddress sa) {\n+        if (isUnixSocket()) {\n+            UnixDomainSockets.checkPermission();\n+            return UnixDomainSockets.checkAddress(sa);\n+        } else {\n+            InetSocketAddress isa = Net.checkAddress(sa, family);\n+            SecurityManager sm = System.getSecurityManager();\n+            if (sm != null) {\n+                sm.checkConnect(isa.getAddress().getHostAddress(), isa.getPort());\n+            }\n+            InetAddress address = isa.getAddress();\n+            if (address.isAnyLocalAddress()) {\n+                int port = isa.getPort();\n+                if (address instanceof Inet4Address) {\n+                    return new InetSocketAddress(Net.inet4LoopbackAddress(), port);\n+                } else {\n+                    assert family == INET6;\n+                    return new InetSocketAddress(Net.inet6LoopbackAddress(), port);\n+                }\n@@ -762,2 +830,1 @@\n-                assert family == StandardProtocolFamily.INET6;\n-                return new InetSocketAddress(Net.inet6LoopbackAddress(), port);\n+                return isa;\n@@ -765,2 +832,0 @@\n-        } else {\n-            return isa;\n@@ -772,1 +837,1 @@\n-        InetSocketAddress isa = checkRemote(remote);\n+        SocketAddress sa = checkRemote(remote);\n@@ -781,5 +846,7 @@\n-                        beginConnect(blocking, isa);\n-                        int n = Net.connect(family,\n-                                            fd,\n-                                            isa.getAddress(),\n-                                            isa.getPort());\n+                        beginConnect(blocking, sa);\n+                        int n;\n+                        if (isUnixSocket()) {\n+                            n = UnixDomainSockets.connect(fd, sa);\n+                        } else {\n+                            n = Net.connect(family, fd, sa);\n+                        }\n@@ -810,1 +877,1 @@\n-            throw SocketExceptions.of(ioe, isa);\n+            throw SocketExceptions.of(ioe, sa);\n@@ -851,1 +918,5 @@\n-                    localAddress = Net.localAddress(fd);\n+                    if (isUnixSocket()) {\n+                        localAddress = UnixDomainSockets.localAddress(fd);\n+                    } else {\n+                        localAddress = Net.localAddress(fd);\n+                    }\n@@ -1090,1 +1161,1 @@\n-        InetSocketAddress isa = checkRemote(remote);\n+        SocketAddress sa = checkRemote(remote);\n@@ -1100,1 +1171,1 @@\n-                        beginConnect(true, isa);\n+                        beginConnect(true, sa);\n@@ -1104,1 +1175,6 @@\n-                            int n = Net.connect(fd, isa.getAddress(), isa.getPort());\n+                            int n;\n+                            if (isUnixSocket()) {\n+                                n = UnixDomainSockets.connect(fd, sa);\n+                            } else {\n+                                n = Net.connect(family, fd, sa);\n+                            }\n@@ -1122,1 +1198,1 @@\n-            throw SocketExceptions.of(ioe, isa);\n+            throw SocketExceptions.of(ioe, sa);\n@@ -1393,1 +1469,1 @@\n-                InetSocketAddress addr = localAddress();\n+                SocketAddress addr = localAddress();\n@@ -1396,1 +1472,5 @@\n-                    sb.append(Net.getRevealedLocalAddressAsString(addr));\n+                    if (isUnixSocket()) {\n+                        sb.append(UnixDomainSockets.getRevealedLocalAddressAsString(addr));\n+                    } else {\n+                        sb.append(Net.getRevealedLocalAddressAsString(addr));\n+                    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketChannelImpl.java","additions":182,"deletions":102,"binary":false,"changes":284,"status":"modified"},{"patch":"@@ -0,0 +1,176 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.ch;\n+\n+import java.io.FileDescriptor;\n+import java.io.IOException;\n+import java.net.BindException;\n+import java.net.NetPermission;\n+import java.net.SocketAddress;\n+import java.net.UnixDomainSocketAddress;\n+import java.nio.channels.UnsupportedAddressTypeException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.Path;\n+import java.nio.file.spi.FileSystemProvider;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.util.Random;\n+import sun.nio.fs.AbstractFileSystemProvider;\n+\n+class UnixDomainSockets {\n+    private UnixDomainSockets() { }\n+\n+    static final UnixDomainSocketAddress UNNAMED = UnixDomainSocketAddress.of(\"\");\n+\n+    private static final boolean supported;\n+\n+    private static final String tempDir = UnixDomainSocketsUtil.getTempDir();\n+\n+    private static final NetPermission accessUnixDomainSocket =\n+            new NetPermission(\"accessUnixDomainSocket\");\n+\n+    static boolean isSupported() {\n+        return supported;\n+    }\n+\n+    static void checkPermission() {\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null)\n+            sm.checkPermission(accessUnixDomainSocket);\n+    }\n+\n+    static UnixDomainSocketAddress getRevealedLocalAddress(SocketAddress sa) {\n+        UnixDomainSocketAddress addr = (UnixDomainSocketAddress) sa;\n+        try {\n+            checkPermission();\n+            \/\/ Security check passed\n+        } catch (SecurityException e) {\n+            \/\/ Return unnamed address only if security check fails\n+            addr = UNNAMED;\n+        }\n+        return addr;\n+    }\n+\n+    static UnixDomainSocketAddress localAddress(FileDescriptor fd) throws IOException {\n+        String path = new String(localAddress0(fd), UnixDomainSocketsUtil.getCharset());\n+        return UnixDomainSocketAddress.of(path);\n+    }\n+\n+    private static native byte[] localAddress0(FileDescriptor fd) throws IOException;\n+\n+    static String getRevealedLocalAddressAsString(SocketAddress sa) {\n+        return (System.getSecurityManager() != null) ? sa.toString() : \"\";\n+    }\n+\n+    static UnixDomainSocketAddress checkAddress(SocketAddress sa) {\n+        if (sa == null)\n+            throw new NullPointerException();\n+        if (!(sa instanceof UnixDomainSocketAddress))\n+            throw new UnsupportedAddressTypeException();\n+        return (UnixDomainSocketAddress) sa;\n+    }\n+\n+    static byte[] getPathBytes(Path path) {\n+        FileSystemProvider provider = FileSystems.getDefault().provider();\n+        return ((AbstractFileSystemProvider) provider).getSunPathForSocketFile(path);\n+    }\n+\n+    static FileDescriptor socket() throws IOException {\n+        return IOUtil.newFD(socket0());\n+    }\n+\n+    static void bind(FileDescriptor fd, Path addr) throws IOException {\n+        byte[] path = getPathBytes(addr);\n+        bind0(fd, path);\n+    }\n+\n+    private static Random getRandom() {\n+        try {\n+            return SecureRandom.getInstance(\"NativePRNGNonBlocking\");\n+        } catch (NoSuchAlgorithmException e) {\n+            return new SecureRandom(); \/\/ This should not fail\n+        }\n+    }\n+\n+    private static final Random random = getRandom();\n+\n+    \/**\n+     * Return a possible temporary name to bind to, which is different for each call\n+     * Name is of the form <temp dir>\/socket_<random>\n+     *\/\n+    static UnixDomainSocketAddress generateTempName() throws IOException {\n+        String dir = UnixDomainSockets.tempDir;\n+        if (dir == null)\n+            throw new BindException(\"Could not locate temporary directory for sockets\");\n+        int rnd = random.nextInt(Integer.MAX_VALUE);\n+        try {\n+            Path path = Path.of(dir, \"socket_\" + rnd);\n+            return UnixDomainSocketAddress.of(path);\n+        } catch (InvalidPathException e) {\n+            throw new BindException(\"Invalid temporary directory\");\n+        }\n+    }\n+\n+    static int connect(FileDescriptor fd, SocketAddress sa) throws IOException {\n+        return UnixDomainSockets.connect(fd, ((UnixDomainSocketAddress) sa).getPath());\n+    }\n+\n+    static int connect(FileDescriptor fd, Path path) throws IOException {\n+        return connect0(fd, getPathBytes(path));\n+    }\n+\n+    static int accept(FileDescriptor fd, FileDescriptor newfd, String[] paths)\n+        throws IOException\n+    {\n+        Object[] array  = new Object[1];\n+        int n = accept0(fd, newfd, array);\n+        if (n > 0) {\n+            byte[] bytes = (byte[]) array[0];\n+            paths[0] = new String(bytes, UnixDomainSocketsUtil.getCharset());\n+        }\n+        return n;\n+    }\n+\n+    private static native boolean socketSupported();\n+\n+    private static native int socket0() throws IOException;\n+\n+    private static native void bind0(FileDescriptor fd, byte[] path)\n+        throws IOException;\n+\n+    private static native int connect0(FileDescriptor fd, byte[] path)\n+        throws IOException;\n+\n+    private static native int accept0(FileDescriptor fd, FileDescriptor newfd, Object[] array)\n+        throws IOException;\n+\n+    static {\n+        \/\/ Load all required native libs\n+        IOUtil.load();\n+        supported = socketSupported();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/UnixDomainSockets.java","additions":176,"deletions":0,"binary":false,"changes":176,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -157,0 +157,6 @@\n+\n+    \/**\n+     * Returns a path name as bytes for a Unix domain socket.\n+     * Different encodings may be used for these names on some platforms.\n+     *\/\n+    public abstract byte[] getSunPathForSocketFile(Path file);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/fs\/AbstractFileSystemProvider.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -95,7 +95,1 @@\n-         * {@preview Associated with records, a preview feature of the Java language.\n-         *\n-         *           This enum constant is associated with <i>records<\/i>, a preview\n-         *           feature of the Java language. Preview features\n-         *           may be removed in a future release, or upgraded to permanent\n-         *           features of the Java language.}\n-         * @since 14\n+         * @since 16\n@@ -103,2 +97,0 @@\n-        @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,\n-                                     essentialAPI=false)\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/annotation\/TypeAnnotation.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -357,1 +357,1 @@\n-    OIW_DES_CBC(\"1.3.14.3.2.7\", \"DES\/CBC\"),\n+    OIW_DES_CBC(\"1.3.14.3.2.7\", \"DES\/CBC\", \"DES\"),\n@@ -374,0 +374,2 @@\n+    DESede(\"1.3.14.3.2.17\", \"DESede\"),\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KnownOIDs.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+import java.net.SocketAddress;\n+import java.net.UnixDomainSocketAddress;\n@@ -39,0 +41,1 @@\n+import static java.net.StandardProtocolFamily.UNIX;\n@@ -48,4 +51,4 @@\n-    private static final int AF_UNKNOWN         = -1;\n-    private static final int AF_INET            = 1;\n-    private static final int AF_INET6           = 2;\n-    private static final int AF_UNIX            = 3;\n+    static final int AF_UNKNOWN         = -1;\n+    static final int AF_INET            = 1;\n+    static final int AF_INET6           = 2;\n+    static final int AF_UNIX            = 3;\n@@ -78,0 +81,18 @@\n+    static ProtocolFamily protocolFamily(SocketAddress sa) {\n+        if (sa instanceof UnixDomainSocketAddress) {\n+            return UNIX;\n+        } else {\n+            InetSocketAddress isa = (InetSocketAddress) sa;\n+            return (isa.getAddress() instanceof Inet6Address) ? INET6 : INET;\n+        }\n+    }\n+\n+    static ProtocolFamily protocolFamily(int family) {\n+        return switch (family) {\n+            case AF_INET -> INET;\n+            case AF_INET6 -> INET6;\n+            case AF_UNIX -> UNIX;\n+            default -> throw new IllegalArgumentException();\n+        };\n+    }\n+\n@@ -85,4 +106,0 @@\n-        static ProtocolFamily family(InetSocketAddress isa) {\n-            return (isa.getAddress() instanceof Inet6Address) ? INET6 : INET;\n-        }\n-\n@@ -91,1 +108,1 @@\n-                                   InetSocketAddress remote)\n+                                   SocketAddress remote)\n@@ -94,1 +111,1 @@\n-            super(sp, family(remote), fd, remote);\n+            super(sp, protocolFamily(remote), fd, remote);\n@@ -103,16 +120,1 @@\n-    public static class InheritedUnixChannelImpl extends UnixDomainSocketChannelImpl {\n-\n-        InheritedUnixChannelImpl(FileDescriptor fd)\n-            throws IOException\n-        {\n-            super(fd);\n-        }\n-\n-        protected void implCloseSelectableChannel() throws IOException {\n-            super.implCloseChannel();\n-            detachIOStreams();\n-        }\n-    }\n-\n-    public static class InheritedServerSocketChannelImpl extends\n-        ServerSocketChannelImpl {\n+    public static class InheritedServerSocketChannelImpl extends ServerSocketChannelImpl {\n@@ -121,0 +123,1 @@\n+                                         ProtocolFamily family,\n@@ -124,1 +127,1 @@\n-            super(sp, fd, true);\n+            super(sp, family, fd, true);\n@@ -127,0 +130,1 @@\n+        @Override\n@@ -131,1 +135,0 @@\n-\n@@ -134,2 +137,1 @@\n-    public static class InheritedDatagramChannelImpl extends\n-        DatagramChannelImpl {\n+    public static class InheritedDatagramChannelImpl extends DatagramChannelImpl {\n@@ -154,1 +156,1 @@\n-    private static void checkAccess(Channel c) {\n+    private static void checkAccess() {\n@@ -157,3 +159,1 @@\n-            sm.checkPermission(\n-                new RuntimePermission(\"inheritedChannel\")\n-            );\n+            sm.checkPermission(new RuntimePermission(\"inheritedChannel\"));\n@@ -163,1 +163,0 @@\n-\n@@ -200,1 +199,1 @@\n-        \/\/ we see if tthere is a peer (ie: connected). If so, then we\n+        \/\/ we see if there is a peer (ie: connected). If so, then we\n@@ -212,0 +211,1 @@\n+            ProtocolFamily pfamily = protocolFamily(family);\n@@ -214,1 +214,2 @@\n-                    return new InheritedUnixChannelImpl(fd);\n+                    var sa = UnixDomainSocketAddress.of(unixPeerAddress(fdVal));\n+                    return new InheritedSocketChannelImpl(provider, fd, sa);\n@@ -216,2 +217,1 @@\n-                    \/\/ listener. unsupported.\n-                    return null;\n+                    return new InheritedServerSocketChannelImpl(provider, pfamily, fd);\n@@ -220,1 +220,1 @@\n-            InetAddress ia = peerAddress0(fdVal);\n+            InetAddress ia = inetPeerAddress0(fdVal);\n@@ -222,1 +222,1 @@\n-               c = new InheritedServerSocketChannelImpl(provider, fd);\n+               c = new InheritedServerSocketChannelImpl(provider, pfamily, fd);\n@@ -225,0 +225,1 @@\n+\n@@ -256,1 +257,1 @@\n-            checkAccess(channel);\n+            checkAccess();\n@@ -261,0 +262,4 @@\n+    private static String unixPeerAddress(int fd) throws IOException {\n+        byte[] bytes = unixPeerAddress0(fd);\n+        return new String(bytes);\n+    }\n@@ -271,1 +276,2 @@\n-    private static native InetAddress peerAddress0(int fd);\n+    private static native InetAddress inetPeerAddress0(int fd);\n+    private static native byte[] unixPeerAddress0(int fd);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/InheritedChannel.java","additions":49,"deletions":43,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -1,266 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.nio.ch;\n-\n-import java.io.FileDescriptor;\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.AsynchronousCloseException;\n-import java.nio.channels.ByteChannel;\n-import java.nio.channels.ClosedChannelException;\n-import java.nio.channels.NotYetConnectedException;\n-import java.nio.channels.spi.AbstractInterruptibleChannel;\n-import java.util.Objects;\n-import java.util.concurrent.locks.ReentrantLock;\n-\n-import static java.util.concurrent.TimeUnit.NANOSECONDS;\n-\n-class UnixDomainSocketChannelImpl\n-    extends AbstractInterruptibleChannel\n-    implements ByteChannel\n-{\n-    \/\/ Used to make native read and write calls\n-    private static final NativeDispatcher nd = new SocketDispatcher();\n-\n-    \/\/ Our file descriptor object\n-    private final FileDescriptor fd;\n-    \/\/ Lock held by current reading or connecting thread\n-    private final ReentrantLock readLock = new ReentrantLock();\n-\n-    \/\/ Lock held by current writing or connecting thread\n-    private final ReentrantLock writeLock = new ReentrantLock();\n-\n-    \/\/ Lock for managing close state\n-    private final Object stateLock = new Object();\n-\n-    \/\/ Channel state\n-    private static final int ST_INUSE = 0;\n-    private static final int ST_CLOSING = 1;\n-    private static final int ST_CLOSED = 2;\n-    private int state;\n-\n-    \/\/ IDs of native threads doing reads and writes, for signalling\n-    private long readerThread;\n-    private long writerThread;\n-\n-    UnixDomainSocketChannelImpl(FileDescriptor fd)\n-        throws IOException\n-    {\n-        this.fd = fd;\n-    }\n-\n-    \/**\n-     * Checks that the channel is open.\n-     *\n-     * @throws ClosedChannelException if channel is closed (or closing)\n-     *\/\n-    private void ensureOpen() throws ClosedChannelException {\n-        if (!isOpen())\n-            throw new ClosedChannelException();\n-    }\n-\n-    \/**\n-     * Closes the socket if there are no I\/O operations in progress\n-     *\/\n-    private boolean tryClose() throws IOException {\n-        assert Thread.holdsLock(stateLock) && state == ST_CLOSING;\n-        if (readerThread == 0 && writerThread == 0) {\n-            state = ST_CLOSED;\n-            nd.close(fd);\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    \/**\n-     * Complete closure of pre-closed socket (release the file descriptor)\n-     *\/\n-    private void tryFinishClose() {\n-        try {\n-            tryClose();\n-        } catch (IOException ignore) { }\n-    }\n-\n-    \/**\n-     * Marks the beginning of a read operation\n-     *\n-     * @throws ClosedChannelException if the channel is closed\n-     * @throws NotYetConnectedException if the channel is not yet connected\n-     *\/\n-    private void beginRead() throws ClosedChannelException {\n-        \/\/ set hook for Thread.interrupt\n-        begin();\n-        synchronized (stateLock) {\n-            ensureOpen();\n-            readerThread = NativeThread.current();\n-        }\n-    }\n-\n-    \/**\n-     * Marks the end of a read operation that may have blocked.\n-     *\n-     * @throws AsynchronousCloseException if the channel was closed due to this\n-     * thread being interrupted on a blocking read operation.\n-     *\/\n-    private void endRead(boolean completed)\n-        throws AsynchronousCloseException\n-    {\n-        synchronized (stateLock) {\n-            readerThread = 0;\n-            if (state == ST_CLOSING) {\n-                tryFinishClose();\n-            }\n-        }\n-        end(completed);\n-    }\n-\n-    @Override\n-    public int read(ByteBuffer buf) throws IOException {\n-        Objects.requireNonNull(buf);\n-\n-        readLock.lock();\n-        try {\n-            int n = 0;\n-            try {\n-                beginRead();\n-                n = IOUtil.read(fd, buf, -1, nd);\n-                while (IOStatus.okayToRetry(n) && isOpen()) {\n-                    park(Net.POLLIN, 0L);\n-                    n = IOUtil.read(fd, buf, -1, nd);\n-                }\n-            } finally {\n-                endRead(n > 0);\n-            }\n-            return n;\n-        } finally {\n-            readLock.unlock();\n-        }\n-    }\n-\n-    \/**\n-     * Marks the beginning of a write operation that might block.\n-     *\n-     * @throws ClosedChannelException if the channel is closed\n-     * @throws NotYetConnectedException if the channel is not yet connected\n-     *\/\n-    private void beginWrite() throws ClosedChannelException {\n-        begin();\n-        synchronized (stateLock) {\n-            \/\/ set hook for Thread.interrupt\n-            ensureOpen();\n-            writerThread = NativeThread.current();\n-        }\n-    }\n-\n-    \/**\n-     * Marks the end of a write operation that may have blocked.\n-     *\n-     * @throws AsynchronousCloseException if the channel was closed due to this\n-     * thread being interrupted on a blocking write operation.\n-     *\/\n-    private void endWrite(boolean completed)\n-        throws AsynchronousCloseException\n-    {\n-        synchronized (stateLock) {\n-            writerThread = 0;\n-            if (state == ST_CLOSING) {\n-                tryFinishClose();\n-            }\n-        }\n-        end(completed);\n-    }\n-\n-    void park(int event, long nanos) throws IOException {\n-        long millis;\n-        if (nanos <= 0) {\n-            millis = -1;\n-        } else {\n-            millis = NANOSECONDS.toMillis(nanos);\n-        }\n-        Net.poll(fd, event, millis);\n-    }\n-\n-    @Override\n-    public int write(ByteBuffer buf) throws IOException {\n-        Objects.requireNonNull(buf);\n-\n-        writeLock.lock();\n-        try {\n-            int n = 0;\n-            try {\n-                beginWrite();\n-                n = IOUtil.write(fd, buf, -1, nd);\n-                while (IOStatus.okayToRetry(n) && isOpen()) {\n-                    park(Net.POLLOUT, 0L);\n-                    n = IOUtil.write(fd, buf, -1, nd);\n-                }\n-            } finally {\n-                endWrite(n > 0);\n-            }\n-            return n;\n-        } finally {\n-            writeLock.unlock();\n-        }\n-    }\n-\n-    \/**\n-     * Closes this channel\n-     *\n-     * If there is an I\/O operation in progress then the socket is pre-closed\n-     * and the I\/O threads signalled, in which case the final close is deferred\n-     * until all I\/O operations complete.\n-     *\/\n-    @Override\n-    protected void implCloseChannel() throws IOException {\n-        synchronized (stateLock) {\n-            assert state == ST_INUSE;\n-            state = ST_CLOSING;\n-            if (!tryClose()) {\n-                long reader = readerThread;\n-                long writer = writerThread;\n-                if (reader != 0 || writer != 0) {\n-                    nd.preClose(fd);\n-                    if (reader != 0)\n-                        NativeThread.signal(reader);\n-                    if (writer != 0)\n-                        NativeThread.signal(writer);\n-                }\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public String toString() {\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(this.getClass().getSuperclass().getName());\n-        sb.append('[');\n-        if (!isOpen())\n-            sb.append(\"closed\");\n-        sb.append(']');\n-        return sb.toString();\n-    }\n-}\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/UnixDomainSocketChannelImpl.java","additions":0,"deletions":266,"binary":false,"changes":266,"status":"deleted"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.ch;\n+\n+import java.nio.charset.Charset;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import sun.net.NetProperties;\n+import jdk.internal.util.StaticProperty;\n+\n+\/**\n+ * Platform specific utility functions\n+ *\/\n+class UnixDomainSocketsUtil {\n+    private UnixDomainSocketsUtil() { }\n+\n+    static Charset getCharset() {\n+        return Charset.defaultCharset();\n+    }\n+\n+    \/**\n+     * Return the temp directory for storing automatically bound\n+     * server sockets.\n+     *\n+     * On UNIX we search the following directories in sequence:\n+     *\n+     * 1. ${jdk.net.unixdomain.tmpdir} if set as system property\n+     * 2. ${jdk.net.unixdomain.tmpdir} if set as net property\n+     * 3. ${java.io.tmpdir} system property\n+     *\/\n+    static String getTempDir() {\n+        PrivilegedAction<String> action = () -> {\n+            String s = NetProperties.get(\"jdk.net.unixdomain.tmpdir\");\n+            if (s != null && s.length() > 0) {\n+                return s;\n+            } else {\n+                return StaticProperty.javaIoTmpDir();\n+            }\n+        };\n+        return AccessController.doPrivileged(action);\n+    }\n+}\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/UnixDomainSocketsUtil.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -560,0 +560,6 @@\n+\n+    @Override\n+    public byte[] getSunPathForSocketFile(Path obj) {\n+        UnixPath file = UnixPath.toUnixPath(obj);\n+        return file.getByteArrayForSysCalls();\n+    }\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystemProvider.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-class UnixUserPrincipals {\n+public class UnixUserPrincipals {\n@@ -111,1 +111,1 @@\n-    static User fromUid(int uid) {\n+    public static User fromUid(int uid) {\n@@ -122,1 +122,1 @@\n-    static Group fromGid(int gid) {\n+    public static Group fromGid(int gid) {\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixUserPrincipals.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,15 @@\n+#\n+# Default directory where automatically bound Unix domain server\n+# sockets are stored. Sockets are automatically bound when bound\n+# with a null address.\n+#\n+# On Unix the search order to determine this directory is:\n+#\n+# 1. System property jdk.net.unixdomain.tmpdir\n+#\n+# 2. Networking property jdk.net.unixdomain.tmpdir specified\n+#    in this file (effective default)\n+#\n+# 3. System property java.io.tmpdir\n+#\n+jdk.net.unixdomain.tmpdir=\/tmp\n","filename":"src\/java.base\/unix\/conf\/net.properties","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -208,1 +208,0 @@\n-    char searchName[IFNAMESIZE];\n@@ -232,6 +231,2 @@\n-    strncpy(searchName, name_utf, IFNAMESIZE);\n-    searchName[IFNAMESIZE - 1] = '\\0';\n-    colonP = strchr(searchName, ':');\n-    if (colonP != NULL) {\n-        *colonP = '\\0';\n-    }\n+    colonP = strchr(name_utf, ':');\n+    size_t limit = colonP != NULL ? (size_t)(colonP - name_utf) : strlen(name_utf);\n@@ -240,1 +235,1 @@\n-        if (strcmp(searchName, curr->name) == 0) {\n+        if (strlen(curr->name) == limit && memcmp(name_utf, curr->name, limit) == 0) {\n","filename":"src\/java.base\/unix\/native\/libnet\/NetworkInterface.c","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+#include \"nio_util.h\"\n@@ -40,1 +41,1 @@\n-static int matchFamily(SOCKETADDRESS *sa) {\n+static int toInetFamily(SOCKETADDRESS *sa) {\n@@ -52,1 +53,1 @@\n-Java_sun_nio_ch_InheritedChannel_peerAddress0(JNIEnv *env, jclass cla, jint fd)\n+Java_sun_nio_ch_InheritedChannel_inetPeerAddress0(JNIEnv *env, jclass cla, jint fd)\n@@ -60,1 +61,1 @@\n-        if (matchFamily(&sa)) {\n+        if (toInetFamily(&sa)) {\n@@ -68,0 +69,15 @@\n+JNIEXPORT jbyteArray JNICALL\n+Java_sun_nio_ch_InheritedChannel_unixPeerAddress0(JNIEnv *env, jclass cla, jint fd)\n+{\n+    struct sockaddr_un sa;\n+    socklen_t len = sizeof(struct sockaddr_un);\n+    jobject remote_sa = NULL;\n+\n+    if (getpeername(fd, (struct sockaddr *)&sa, &len) == 0) {\n+        if (sa.sun_family == AF_UNIX) {\n+            remote_sa = sockaddrToUnixAddressBytes(env, &sa, len);\n+        }\n+    }\n+    return remote_sa;\n+}\n+\n@@ -75,2 +91,2 @@\n-    if (getpeername(fd, &sa.sa, &len) == 0) {\n-        if (matchFamily(&sa)) {\n+    if (getpeername(fd, (struct sockaddr *)&sa.sa, &len) == 0) {\n+        if (toInetFamily(&sa)) {\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/InheritedChannel.c","additions":22,"deletions":6,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <poll.h>\n+#include <sys\/types.h>\n+#include <sys\/socket.h>\n+#include <string.h>\n+#include <stddef.h>\n+#include <netinet\/in.h>\n+#include <netinet\/tcp.h>\n+#include <limits.h>\n+\n+#include \"jni.h\"\n+#include \"java_props.h\"\n+#include \"jni_util.h\"\n+#include \"jvm.h\"\n+#include \"jlong.h\"\n+#include \"sun_nio_ch_Net.h\"\n+#include \"nio_util.h\"\n+#include \"nio.h\"\n+\n+\/* Subtle platform differences in how unnamed sockets (empty path)\n+ * are returned from getsockname()\n+ *\/\n+#ifdef MACOSX\n+  #define ZERO_PATHLEN(len) (JNI_FALSE)\n+#else\n+  #define ZERO_PATHLEN(len) (len == offsetof(struct sockaddr_un, sun_path))\n+#endif\n+\n+jbyteArray sockaddrToUnixAddressBytes(JNIEnv *env, struct sockaddr_un *sa, socklen_t len)\n+{\n+    if (sa->sun_family == AF_UNIX) {\n+        int namelen;\n+        if (ZERO_PATHLEN(len)) {\n+            namelen = 0;\n+        } else {\n+            namelen = strlen(sa->sun_path);\n+        }\n+        jbyteArray name = (*env)->NewByteArray(env, namelen);\n+        if (namelen != 0) {\n+            (*env)->SetByteArrayRegion(env, name, 0, namelen, (jbyte*)sa->sun_path);\n+            if ((*env)->ExceptionOccurred(env)) {\n+                return NULL;\n+            }\n+        }\n+        return name;\n+    }\n+    return NULL;\n+}\n+\n+jint unixSocketAddressToSockaddr(JNIEnv *env, jbyteArray path, struct sockaddr_un *sa, int *len)\n+{\n+    memset(sa, 0, sizeof(struct sockaddr_un));\n+    sa->sun_family = AF_UNIX;\n+    int ret;\n+    const char* pname = (const char *)(*env)->GetByteArrayElements(env, path, NULL);\n+    if (pname == NULL) {\n+        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Unix domain path not present\");\n+        return -1;\n+    }\n+    size_t name_len = (*env)->GetArrayLength(env, path);\n+    if (name_len > MAX_UNIX_DOMAIN_PATH_LEN) {\n+        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Unix domain path too long\");\n+        ret = -1;\n+    } else {\n+        memcpy(sa->sun_path, pname, name_len);\n+        *len = (int)(offsetof(struct sockaddr_un, sun_path) + name_len + 1);\n+        ret = 0;\n+    }\n+    (*env)->ReleaseByteArrayElements(env, path, (jbyte *)pname, 0);\n+    return ret;\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_socketSupported(JNIEnv *env, jclass cl)\n+{\n+    return JNI_TRUE;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_socket0(JNIEnv *env, jclass cl)\n+{\n+    int fd = socket(PF_UNIX, SOCK_STREAM, 0);\n+    if (fd < 0) {\n+        return handleSocketError(env, errno);\n+    }\n+    return fd;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_bind0(JNIEnv *env, jclass clazz, jobject fdo, jbyteArray path)\n+{\n+    struct sockaddr_un sa;\n+    int sa_len = 0;\n+    int rv = 0;\n+\n+    if (unixSocketAddressToSockaddr(env, path, &sa, &sa_len) != 0)\n+        return;\n+\n+    rv = bind(fdval(env, fdo), (struct sockaddr *)&sa, sa_len);\n+    if (rv != 0) {\n+        handleSocketError(env, errno);\n+    }\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_connect0(JNIEnv *env, jclass clazz, jobject fdo, jbyteArray path)\n+{\n+    struct sockaddr_un sa;\n+    int sa_len = 0;\n+    int rv;\n+\n+    if (unixSocketAddressToSockaddr(env, path, &sa, &sa_len) != 0) {\n+        return IOS_THROWN;\n+    }\n+\n+    rv = connect(fdval(env, fdo), (struct sockaddr *)&sa, sa_len);\n+    if (rv != 0) {\n+        if (errno == EINPROGRESS) {\n+            return IOS_UNAVAILABLE;\n+        } else if (errno == EINTR) {\n+            return IOS_INTERRUPTED;\n+        }\n+        return handleSocketError(env, errno);\n+    }\n+    return 1;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_accept0(JNIEnv *env, jclass clazz, jobject fdo, jobject newfdo,\n+                                          jobjectArray array)\n+{\n+    jint fd = fdval(env, fdo);\n+    jint newfd;\n+    struct sockaddr_un sa;\n+    socklen_t sa_len = sizeof(struct sockaddr_un);\n+    jbyteArray address;\n+\n+    newfd = accept(fd, (struct sockaddr *)&sa, &sa_len);\n+    if (newfd < 0) {\n+        if (errno == EAGAIN || errno == EWOULDBLOCK)\n+            return IOS_UNAVAILABLE;\n+        if (errno == EINTR)\n+            return IOS_INTERRUPTED;\n+        JNU_ThrowIOExceptionWithLastError(env, \"Accept failed\");\n+        return IOS_THROWN;\n+    }\n+\n+    setfdval(env, newfdo, newfd);\n+\n+    address = sockaddrToUnixAddressBytes(env, &sa, sa_len);\n+    CHECK_NULL_RETURN(address, IOS_THROWN);\n+\n+    (*env)->SetObjectArrayElement(env, array, 0, address);\n+\n+    return 1;\n+}\n+\n+JNIEXPORT jbyteArray JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_localAddress0(JNIEnv *env, jclass clazz, jobject fdo)\n+{\n+    struct sockaddr_un sa;\n+    socklen_t sa_len = sizeof(struct sockaddr_un);\n+    int port;\n+    if (getsockname(fdval(env, fdo), (struct sockaddr *)&sa, &sa_len) < 0) {\n+        handleSocketError(env, errno);\n+        return NULL;\n+    }\n+    return sockaddrToUnixAddressBytes(env, &sa, sa_len);\n+}\n+\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/UnixDomainSockets.c","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+#include <sys\/un.h>\n@@ -50,0 +51,6 @@\n+\/* 2 bytes to allow for null at end of string and null at start of string\n+ * for abstract name\n+ *\/\n+#define MAX_UNIX_DOMAIN_PATH_LEN \\\n+        (int)(sizeof(((struct sockaddr_un *)0)->sun_path)-2)\n+\n@@ -65,0 +72,12 @@\n+\n+\/* Defined in UnixDomainSockets.c *\/\n+\n+jbyteArray sockaddrToUnixAddressBytes(JNIEnv *env,\n+                                      struct sockaddr_un *sa,\n+                                      socklen_t len);\n+\n+jint unixSocketAddressToSockaddr(JNIEnv *env,\n+                                jbyteArray uaddr,\n+                                struct sockaddr_un *sa,\n+                                int *len);\n+\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/nio_util.h","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,4 @@\n+import java.net.SocketAddress;\n+import java.net.UnixDomainSocketAddress;\n+import java.net.StandardProtocolFamily;\n+import java.net.StandardSocketOptions;\n@@ -36,0 +40,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -58,2 +64,2 @@\n-    private SourceChannel source;\n-    private SinkChannel sink;\n+    private final SourceChannel source;\n+    private final SinkChannel sink;\n@@ -66,2 +72,3 @@\n-\n-        private IOException ioe = null;\n+        private IOException ioe;\n+        SourceChannelImpl source;\n+        SinkChannelImpl sink;\n@@ -106,0 +113,2 @@\n+                \/\/ Loopback address\n+                SocketAddress sa = null;\n@@ -112,4 +121,0 @@\n-                    \/\/ Loopback address\n-                    InetAddress lb = InetAddress.getLoopbackAddress();\n-                    assert(lb.isLoopbackAddress());\n-                    InetSocketAddress sa = null;\n@@ -120,3 +125,2 @@\n-                            ssc = ServerSocketChannel.open();\n-                            ssc.socket().bind(new InetSocketAddress(lb, 0));\n-                            sa = new InetSocketAddress(lb, ssc.socket().getLocalPort());\n+                            ssc = createListener();\n+                            sa = ssc.getLocalAddress();\n@@ -163,0 +167,4 @@\n+                        if (sa instanceof UnixDomainSocketAddress) {\n+                            Path path = ((UnixDomainSocketAddress) sa).getPath();\n+                            Files.deleteIfExists(path);\n+                        }\n@@ -169,1 +177,16 @@\n-    PipeImpl(final SelectorProvider sp) throws IOException {\n+    \/**\n+     * Creates a Pipe implementation that supports buffering.\n+     *\/\n+    PipeImpl(SelectorProvider sp) throws IOException {\n+        this(sp, true);\n+    }\n+\n+    \/**\n+     * Creates Pipe implementation that supports optionally buffering.\n+     *\n+     * @implNote The pipe uses Unix domain sockets where possible. It uses a\n+     * loopback connection on older editions of Windows. When buffering is\n+     * disabled then it sets TCP_NODELAY on the sink channel.\n+     *\/\n+    PipeImpl(SelectorProvider sp, boolean buffering) throws IOException {\n+        Initializer initializer = new Initializer(sp);\n@@ -171,3 +194,7 @@\n-            AccessController.doPrivileged(new Initializer(sp));\n-        } catch (PrivilegedActionException x) {\n-            throw (IOException)x.getCause();\n+            AccessController.doPrivileged(initializer);\n+            SinkChannelImpl sink = initializer.sink;\n+            if (sink.isNetSocket() && !buffering) {\n+                sink.setOption(StandardSocketOptions.TCP_NODELAY, true);\n+            }\n+        } catch (PrivilegedActionException pae) {\n+            throw (IOException) pae.getCause();\n@@ -175,0 +202,2 @@\n+        this.source = initializer.source;\n+        this.sink = initializer.sink;\n@@ -185,0 +214,21 @@\n+    private static volatile boolean noUnixDomainSockets;\n+\n+    private static ServerSocketChannel createListener() throws IOException {\n+        ServerSocketChannel listener = null;\n+        if (!noUnixDomainSockets) {\n+            try {\n+                listener = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+                return listener.bind(null);\n+            } catch (UnsupportedOperationException | IOException e) {\n+                \/\/ IOException is most likely to be caused by the temporary directory\n+                \/\/ name being too long. Possibly should log this.\n+                noUnixDomainSockets = true;\n+                if (listener != null)\n+                    listener.close();\n+            }\n+        }\n+        listener = ServerSocketChannel.open();\n+        InetAddress lb = InetAddress.getLoopbackAddress();\n+        listener.bind(new InetSocketAddress(lb, 0));\n+        return listener;\n+    }\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/PipeImpl.java","additions":66,"deletions":16,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.net.SocketOption;\n@@ -47,1 +48,1 @@\n-    final SocketChannel sc;\n+    private final SocketChannelImpl sc;\n@@ -50,1 +51,1 @@\n-        return ((SocketChannelImpl)sc).getFD();\n+        return sc.getFD();\n@@ -54,1 +55,1 @@\n-        return ((SocketChannelImpl)sc).getFDVal();\n+        return sc.getFDVal();\n@@ -59,1 +60,9 @@\n-        this.sc = sc;\n+        this.sc = (SocketChannelImpl) sc;\n+    }\n+\n+    boolean isNetSocket() {\n+        return sc.isNetSocket();\n+    }\n+\n+    <T> void setOption(SocketOption<T> name, T value) throws IOException {\n+        sc.setOption(name, value);\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/SinkChannelImpl.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.ch;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import sun.net.NetProperties;\n+import jdk.internal.util.StaticProperty;\n+\n+class UnixDomainSocketsUtil {\n+    private UnixDomainSocketsUtil() { }\n+\n+    static Charset getCharset() {\n+        return StandardCharsets.UTF_8;\n+    }\n+\n+    \/**\n+     * Return the temp directory for storing automatically bound\n+     * server sockets.\n+     *\n+     * On Windows we search the following directories in sequence:\n+     *\n+     * 1. ${jdk.net.unixdomain.tmpdir} if set as system property\n+     * 2. ${jdk.net.unixdomain.tmpdir} if set as net property\n+     * 3. %TEMP%\n+     * 4. ${java.io.tmpdir}\n+     *\/\n+    static String getTempDir() {\n+        PrivilegedAction<String> action = () -> {\n+            String s = NetProperties.get(\"jdk.net.unixdomain.tmpdir\");\n+            if (s != null) {\n+                return s;\n+            }\n+            String temp = System.getenv(\"TEMP\");\n+            if (temp != null) {\n+                return temp;\n+            }\n+            return StaticProperty.javaIoTmpDir();\n+        };\n+        return AccessController.doPrivileged(action);\n+    }\n+}\n+\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/UnixDomainSocketsUtil.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.nio.channels.SelectableChannel;\n@@ -142,1 +143,1 @@\n-        wakeupPipe = Pipe.open();\n+        wakeupPipe = new PipeImpl(sp, false);\n@@ -144,6 +145,1 @@\n-\n-        \/\/ Disable the Nagle algorithm so that the wakeup is more immediate\n-        SinkChannelImpl sink = (SinkChannelImpl)wakeupPipe.sink();\n-        (sink.sc).socket().setTcpNoDelay(true);\n-        wakeupSinkFd = ((SelChImpl)sink).getFDVal();\n-\n+        wakeupSinkFd = ((SelChImpl)wakeupPipe.sink()).getFDVal();\n@@ -416,1 +412,1 @@\n-                SelectionKeyImpl sk = me.ski;\n+                SelectionKeyImpl ski = me.ski;\n@@ -421,4 +417,4 @@\n-                if (isExceptFds &&\n-                    (sk.channel() instanceof SocketChannelImpl) &&\n-                    discardUrgentData(desc))\n-                {\n+                SelectableChannel sc = ski.channel();\n+                if (isExceptFds && (sc instanceof SocketChannelImpl)\n+                        && ((SocketChannelImpl) sc).isNetSocket()\n+                        && discardUrgentData(desc)) {\n@@ -428,1 +424,1 @@\n-                int updated = processReadyEvents(rOps, sk, action);\n+                int updated = processReadyEvents(rOps, ski, action);\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/WindowsSelectorImpl.java","additions":10,"deletions":14,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -625,0 +626,8 @@\n+\n+    @Override\n+    public byte[] getSunPathForSocketFile(Path obj) {\n+        WindowsPath file = WindowsPath.toWindowsPath(obj);\n+        String s = file.toString();\n+        return s.getBytes(StandardCharsets.UTF_8);\n+    }\n+\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsFileSystemProvider.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,19 @@\n+#\n+# Default directory where automatically bound Unix domain server\n+# sockets are stored. Sockets are automatically bound when bound\n+# with a null address.\n+#\n+# The search order for the directory on Windows is:\n+#\n+# 1. System property \"jdk.net.unixdomain.tmpdir\"\n+#\n+# 2. Networking property \"jdk.net.unixdomain.tmpdir\" specified\n+#    in this file (not set by default)\n+#\n+# 3. The TEMP environment variable (the effective default)\n+#\n+# 4. The java.io.tmpdir system property\n+#\n+#jdk.net.unixdomain.tmpdir=\n+#\n+\n","filename":"src\/java.base\/windows\/conf\/net.properties","additions":19,"deletions":0,"binary":false,"changes":19,"status":"added"},{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <windows.h>\n+#include <winsock2.h>\n+\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+#include \"jvm.h\"\n+#include \"jlong.h\"\n+#include \"nio.h\"\n+#include \"nio_util.h\"\n+#include \"net_util.h\"\n+\n+#include \"java_net_InetAddress.h\"\n+#include \"sun_nio_ch_Net.h\"\n+#include \"sun_nio_ch_PollArrayWrapper.h\"\n+\n+jbyteArray sockaddrToUnixAddressBytes(JNIEnv *env, struct sockaddr_un *sa, socklen_t len)\n+{\n+    if (sa->sun_family == AF_UNIX) {\n+        int namelen = (int)strlen(sa->sun_path);\n+        jbyteArray name = (*env)->NewByteArray(env, namelen);\n+        if (name != NULL) {\n+            (*env)->SetByteArrayRegion(env, name, 0, namelen, (jbyte*)sa->sun_path);\n+            if ((*env)->ExceptionOccurred(env)) {\n+                return NULL;\n+            }\n+        }\n+        return name;\n+    }\n+    return NULL;\n+}\n+\n+jint unixSocketAddressToSockaddr(JNIEnv *env, jbyteArray addr, struct sockaddr_un *sa, int *len)\n+{\n+    memset(sa, 0, sizeof(struct sockaddr_un));\n+    sa->sun_family = AF_UNIX;\n+    if (addr == 0L) {\n+        \/* Do explicit bind on Windows *\/\n+        *len = (int)(offsetof(struct sockaddr_un, sun_path));\n+        return 0;\n+    }\n+    int ret;\n+    jboolean isCopy;\n+    char *pname = (*env)->GetByteArrayElements(env, addr, &isCopy);\n+    if (pname == NULL) {\n+        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Unix domain path not present\");\n+        return -1;\n+    }\n+\n+    size_t name_len = (size_t)(*env)->GetArrayLength(env, addr);\n+    if (name_len > MAX_UNIX_DOMAIN_PATH_LEN) {\n+        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Unix domain path too long\");\n+        ret = -1;\n+    } else {\n+        strncpy(sa->sun_path, pname, name_len);\n+        *len = (int)(offsetof(struct sockaddr_un, sun_path) + name_len);\n+        ret = 0;\n+    }\n+    (*env)->ReleaseByteArrayElements(env, addr, pname, JNI_ABORT);\n+    return ret;\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_socketSupported(JNIEnv *env, jclass cl)\n+{\n+    SOCKET s = socket(PF_UNIX, SOCK_STREAM, 0);\n+    if (s == INVALID_SOCKET) {\n+        return JNI_FALSE;\n+    }\n+    closesocket(s);\n+    return JNI_TRUE;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_socket0(JNIEnv *env, jclass cl)\n+{\n+    SOCKET s = socket(PF_UNIX, SOCK_STREAM, 0);\n+    if (s == INVALID_SOCKET) {\n+        return handleSocketError(env, WSAGetLastError());\n+    }\n+    SetHandleInformation((HANDLE)s, HANDLE_FLAG_INHERIT, 0);\n+    return (int)s;\n+}\n+\n+\/**\n+ * Windows does not support auto bind. So, the windows version of unixSocketAddressToSockaddr\n+ * looks out for a null 'uaddr' and handles it specially\n+ *\/\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_bind0(JNIEnv *env, jclass clazz, jobject fdo, jbyteArray addr)\n+{\n+    struct sockaddr_un sa;\n+    int sa_len = 0;\n+    int rv = 0;\n+\n+    if (unixSocketAddressToSockaddr(env, addr, &sa, &sa_len) != 0)\n+        return;\n+\n+    rv = bind(fdval(env, fdo), (struct sockaddr *)&sa, sa_len);\n+    if (rv == SOCKET_ERROR) {\n+        int err = WSAGetLastError();\n+        NET_ThrowNew(env, err, \"bind\");\n+    }\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_connect0(JNIEnv *env, jclass clazz, jobject fdo, jbyteArray addr)\n+{\n+    struct sockaddr_un sa;\n+    int sa_len = 0;\n+    int rv;\n+\n+    if (unixSocketAddressToSockaddr(env, addr, &sa, &sa_len) != 0) {\n+        return IOS_THROWN;\n+    }\n+\n+    rv = connect(fdval(env, fdo), (const struct sockaddr *)&sa, sa_len);\n+    if (rv != 0) {\n+        int err = WSAGetLastError();\n+        if (err == WSAEINPROGRESS || err == WSAEWOULDBLOCK) {\n+            return IOS_UNAVAILABLE;\n+        }\n+        NET_ThrowNew(env, err, \"connect\");\n+        return IOS_THROWN;\n+    }\n+    return 1;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_accept0(JNIEnv *env, jclass clazz, jobject fdo, jobject newfdo,\n+                                          jobjectArray array)\n+{\n+    jint fd = fdval(env, fdo);\n+    jint newfd;\n+    struct sockaddr_un sa;\n+    socklen_t sa_len = sizeof(sa);\n+    jbyteArray address;\n+\n+    memset((char *)&sa, 0, sizeof(sa));\n+    newfd = (jint) accept(fd, (struct sockaddr *)&sa, &sa_len);\n+    if (newfd == INVALID_SOCKET) {\n+        int theErr = (jint)WSAGetLastError();\n+        if (theErr == WSAEWOULDBLOCK) {\n+            return IOS_UNAVAILABLE;\n+        }\n+        JNU_ThrowIOExceptionWithLastError(env, \"Accept failed\");\n+        return IOS_THROWN;\n+    }\n+\n+    SetHandleInformation((HANDLE)(UINT_PTR)newfd, HANDLE_FLAG_INHERIT, 0);\n+    setfdval(env, newfdo, newfd);\n+\n+    address = sockaddrToUnixAddressBytes(env, &sa, sa_len);\n+    CHECK_NULL_RETURN(address, IOS_THROWN);\n+    (*env)->SetObjectArrayElement(env, array, 0, address);\n+\n+    return 1;\n+}\n+\n+JNIEXPORT jbyteArray JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_localAddress0(JNIEnv *env, jclass clazz, jobject fdo)\n+{\n+    struct sockaddr_un sa;\n+    int sa_len = sizeof(sa);\n+\n+    if (getsockname(fdval(env, fdo), (struct sockaddr *)&sa, &sa_len) == SOCKET_ERROR) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"getsockname\");\n+        return NULL;\n+    }\n+    return sockaddrToUnixAddressBytes(env, &sa, sa_len);\n+}\n+\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/UnixDomainSockets.c","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+#include <ws2tcpip.h>\n+#include <afunix.h>\n@@ -38,0 +40,3 @@\n+#define MAX_UNIX_DOMAIN_PATH_LEN \\\n+        (int)(sizeof(((struct sockaddr_un *)0)->sun_path)-2)\n+\n@@ -77,0 +82,8 @@\n+\n+\/* Defined in UnixDomainSockets.c *\/\n+\n+jbyteArray sockaddrToUnixAddressBytes(JNIEnv *env, struct sockaddr_un *sa, socklen_t len);\n+\n+jint unixSocketAddressToSockaddr(JNIEnv *env, jbyteArray uaddr,\n+                                struct sockaddr_un *sa, int *len);\n+\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/nio_util.h","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -112,7 +112,0 @@\n-     * {@preview Associated with records, a preview feature of the Java language.\n-     *\n-     *           This enum constant is associated with <i>records<\/i>, a preview\n-     *           feature of the Java language. Preview features\n-     *           may be removed in a future release, or upgraded to permanent\n-     *           features of the Java language.}\n-     *\n@@ -120,1 +113,1 @@\n-     * @since 14\n+     * @since 16\n@@ -122,2 +115,0 @@\n-    @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,\n-                                 essentialAPI=false)\n@@ -127,7 +118,0 @@\n-     * {@preview Associated with records, a preview feature of the Java language.\n-     *\n-     *           This enum constant is associated with <i>records<\/i>, a preview\n-     *           feature of the Java language. Preview features\n-     *           may be removed in a future release, or upgraded to permanent\n-     *           features of the Java language.}\n-     *\n@@ -135,1 +119,1 @@\n-     * @since 14\n+     * @since 16\n@@ -137,2 +121,0 @@\n-    @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,\n-                                 essentialAPI=false)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/ElementKind.java","additions":2,"deletions":20,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -214,7 +214,0 @@\n-     * {@preview Associated with records, a preview feature of the Java language.\n-     *\n-     *           This method is associated with <i>records<\/i>, a preview\n-     *           feature of the Java language. Preview features\n-     *           may be removed in a future release, or upgraded to permanent\n-     *           features of the Java language.}\n-     *\n@@ -229,1 +222,1 @@\n-     * @since 14\n+     * @since 16\n@@ -231,3 +224,0 @@\n-    @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,\n-                                 essentialAPI=false)\n-    @SuppressWarnings(\"preview\")\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/ElementVisitor.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,7 +29,0 @@\n- * {@preview Associated with records, a preview feature of the Java language.\n- *\n- *           This class is associated with <i>records<\/i>, a preview\n- *           feature of the Java language. Preview features\n- *           may be removed in a future release, or upgraded to permanent\n- *           features of the Java language.}\n- *\n@@ -38,1 +31,1 @@\n- * @since 14\n+ * @since 16\n@@ -40,2 +33,0 @@\n-@jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,\n-                             essentialAPI=false)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/RecordComponentElement.java","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -183,7 +183,0 @@\n-     * {@preview Associated with records, a preview feature of the Java language.\n-     *\n-     *           This method is associated with <i>records<\/i>, a preview\n-     *           feature of the Java language. Preview features\n-     *           may be removed in a future release, or upgraded to permanent\n-     *           features of the Java language.}\n-     *\n@@ -199,1 +192,1 @@\n-     * @since 14\n+     * @since 16\n@@ -201,3 +194,0 @@\n-    @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,\n-                                 essentialAPI=false)\n-    @SuppressWarnings(\"preview\")\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/TypeElement.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -34,7 +34,0 @@\n- * {@preview Associated with records, a preview feature of the Java language.\n- *\n- *           This class is associated with <i>records<\/i>, a preview\n- *           feature of the Java language. Preview features\n- *           may be removed in a future release, or upgraded to permanent\n- *           features of the Java language.}\n- *\n@@ -57,1 +50,1 @@\n- * @since 14\n+ * @since 16\n@@ -59,2 +52,0 @@\n-@jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,\n-                             essentialAPI=false)\n@@ -80,1 +71,0 @@\n-    @SuppressWarnings(\"preview\")\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractElementVisitor14.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -115,7 +115,0 @@\n-     * {@preview Associated with records, a preview feature of the Java language.\n-     *\n-     *           This method is associated with <i>records<\/i>, a preview\n-     *           feature of the Java language. Preview features\n-     *           may be removed in a future release, or upgraded to permanent\n-     *           features of the Java language.}\n-     *\n@@ -125,1 +118,1 @@\n-     * @since 14\n+     * @since 16\n@@ -127,3 +120,0 @@\n-    @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,\n-                                 essentialAPI=false)\n-    @SuppressWarnings(\"preview\")\n@@ -136,7 +126,0 @@\n-     * {@preview Associated with records, a preview feature of the Java language.\n-     *\n-     *           This method is associated with <i>records<\/i>, a preview\n-     *           feature of the Java language. Preview features\n-     *           may be removed in a future release, or upgraded to permanent\n-     *           features of the Java language.}\n-     *\n@@ -146,1 +129,1 @@\n-     * @since 14\n+     * @since 16\n@@ -148,3 +131,0 @@\n-    @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,\n-                                 essentialAPI=false)\n-    @SuppressWarnings(\"preview\")\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementFilter.java","additions":2,"deletions":22,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -34,7 +34,0 @@\n- * {@preview Associated with records, a preview feature of the Java language.\n- *\n- *           This class is associated with <i>records<\/i>, a preview\n- *           feature of the Java language. Preview features\n- *           may be removed in a future release, or upgraded to permanent\n- *           features of the Java language.}\n- *\n@@ -69,1 +62,1 @@\n- * @since 14\n+ * @since 16\n@@ -71,2 +64,0 @@\n-@jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,\n-                             essentialAPI=false)\n@@ -102,1 +93,0 @@\n-    @SuppressWarnings(\"preview\")\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementKindVisitor14.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -220,7 +220,0 @@\n-     * {@preview Associated with records, a preview feature of the Java language.\n-     *\n-     *           This method is associated with <i>records<\/i>, a preview\n-     *           feature of the Java language. Preview features\n-     *           may be removed in a future release, or upgraded to permanent\n-     *           features of the Java language.}\n-     *\n@@ -235,1 +228,1 @@\n-     * @since 14\n+     * @since 16\n@@ -237,2 +230,0 @@\n-    @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,\n-                                 essentialAPI=false)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementKindVisitor6.java","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -36,7 +36,0 @@\n- * {@preview Associated with records, a preview feature of the Java language.\n- *\n- *           This class is associated with <i>records<\/i>, a preview\n- *           feature of the Java language. Preview features\n- *           may be removed in a future release, or upgraded to permanent\n- *           features of the Java language.}\n- *\n@@ -84,1 +77,1 @@\n- * @since 14\n+ * @since 16\n@@ -86,2 +79,0 @@\n-@jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,\n-                             essentialAPI=false)\n@@ -159,1 +150,0 @@\n-    @SuppressWarnings(\"preview\")\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementScanner14.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -635,7 +635,0 @@\n-     * {@preview Associated with records, a preview feature of the Java language.\n-     *\n-     *           This method is associated with <i>records<\/i>, a preview\n-     *           feature of the Java language. Preview features\n-     *           may be removed in a future release, or upgraded to permanent\n-     *           features of the Java language.}\n-     *\n@@ -656,1 +649,1 @@\n-     * @since 14\n+     * @since 16\n@@ -658,3 +651,0 @@\n-    @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,\n-                                 essentialAPI=false)\n-    @SuppressWarnings(\"preview\")\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Elements.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -34,7 +34,0 @@\n- * {@preview Associated with records, a preview feature of the Java language.\n- *\n- *           This class is associated with <i>records<\/i>, a preview\n- *           feature of the Java language. Preview features\n- *           may be removed in a future release, or upgraded to permanent\n- *           features of the Java language.}\n- *\n@@ -65,1 +58,1 @@\n- * @since 14\n+ * @since 16\n@@ -67,2 +60,0 @@\n-@jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,\n-                             essentialAPI=false)\n@@ -99,1 +90,0 @@\n-    @SuppressWarnings(\"preview\")\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleElementVisitor14.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-    private static final AtomicInteger threadInitNumber = new AtomicInteger(0);\n+    private static final AtomicInteger threadInitNumber = new AtomicInteger();\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/EventQueue.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-    private int type;\n+    private final int type;\n@@ -110,1 +110,1 @@\n-    private int numComponents;\n+    private final int numComponents;\n@@ -245,0 +245,1 @@\n+\n@@ -278,1 +279,1 @@\n-     * @param  numcomponents the number of components in the color space\n+     * @param  numComponents the number of components in the color space\n@@ -280,1 +281,1 @@\n-    protected ColorSpace(int type, int numcomponents) {\n+    protected ColorSpace(int type, int numComponents) {\n@@ -282,1 +283,1 @@\n-        this.numComponents = numcomponents;\n+        this.numComponents = numComponents;\n@@ -444,2 +445,2 @@\n-     * @param colorvalue a float array with length of at least the number of\n-     *        components in this {@code ColorSpace}\n+     * @param  colorvalue a float array with length of at least the number of\n+     *         components in this {@code ColorSpace}\n@@ -511,5 +512,1 @@\n-        if ((idx < 0) || (idx > numComponents - 1)) {\n-            throw new IllegalArgumentException(\n-                \"Component index out of range: \" + idx);\n-        }\n-\n+        rangeCheck(idx);\n@@ -576,4 +573,1 @@\n-        if ((component < 0) || (component > numComponents - 1)) {\n-            throw new IllegalArgumentException(\n-                \"Component index out of range: \" + component);\n-        }\n+        rangeCheck(component);\n@@ -595,4 +589,1 @@\n-        if ((component < 0) || (component > numComponents - 1)) {\n-            throw new IllegalArgumentException(\n-                \"Component index out of range: \" + component);\n-        }\n+        rangeCheck(component);\n@@ -602,2 +593,6 @@\n-    \/*\n-     * Returns {@code true} if {@code cspace} is the XYZspace.\n+    \/**\n+     * Checks that {@code component} is in range of the number of components.\n+     *\n+     * @param  component the component index\n+     * @throws IllegalArgumentException if component is less than 0 or greater\n+     *         than {@code numComponents - 1}\n@@ -605,2 +600,5 @@\n-    static boolean isCS_CIEXYZ(ColorSpace cspace) {\n-        return (cspace == XYZspace);\n+    final void rangeCheck(int component) {\n+        if (component < 0 || component > getNumComponents() - 1) {\n+            throw new IllegalArgumentException(\n+                    \"Component index out of range: \" + component);\n+        }\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ColorSpace.java","additions":22,"deletions":24,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -572,4 +572,1 @@\n-        if ((component < 0) || (component > this.getNumComponents() - 1)) {\n-            throw new IllegalArgumentException(\n-                \"Component index out of range: \" + component);\n-        }\n+        rangeCheck(component);\n@@ -598,4 +595,1 @@\n-        if ((component < 0) || (component > this.getNumComponents() - 1)) {\n-            throw new IllegalArgumentException(\n-                \"Component index out of range: \" + component);\n-        }\n+        rangeCheck(component);\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ICC_ColorSpace.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -118,4 +118,1 @@\n-    float theGamma;\n-\n-        theGamma = super.getGamma(ICC_Profile.icSigGrayTRCTag);\n-        return theGamma;\n+        return getGamma(ICC_Profile.icSigGrayTRCTag);\n@@ -143,4 +140,1 @@\n-    short[]    theTRC;\n-\n-        theTRC = super.getTRC(ICC_Profile.icSigGrayTRCTag);\n-        return theTRC;\n+        return getTRC(ICC_Profile.icSigGrayTRCTag);\n@@ -148,1 +142,0 @@\n-\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ICC_ProfileGray.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-     * @param p the CMM ID for the profile.\n+     * @param  p the CMM ID for the profile.\n@@ -116,1 +116,1 @@\n-     * @param pdi\n+     * @param  pdi\n@@ -146,16 +146,6 @@\n-        float[][] theMatrix = new float[3][3];\n-        float[] tmpMatrix;\n-\n-        tmpMatrix = getXYZTag(ICC_Profile.icSigRedColorantTag);\n-        theMatrix[0][0] = tmpMatrix[0];\n-        theMatrix[1][0] = tmpMatrix[1];\n-        theMatrix[2][0] = tmpMatrix[2];\n-        tmpMatrix = getXYZTag(ICC_Profile.icSigGreenColorantTag);\n-        theMatrix[0][1] = tmpMatrix[0];\n-        theMatrix[1][1] = tmpMatrix[1];\n-        theMatrix[2][1] = tmpMatrix[2];\n-        tmpMatrix = getXYZTag(ICC_Profile.icSigBlueColorantTag);\n-        theMatrix[0][2] = tmpMatrix[0];\n-        theMatrix[1][2] = tmpMatrix[1];\n-        theMatrix[2][2] = tmpMatrix[2];\n-        return theMatrix;\n+        float[] red = getXYZTag(ICC_Profile.icSigRedColorantTag);\n+        float[] green = getXYZTag(ICC_Profile.icSigGreenColorantTag);\n+        float[] blue = getXYZTag(ICC_Profile.icSigBlueColorantTag);\n+        return new float[][]{{red[0], green[0], blue[0]},\n+                             {red[1], green[1], blue[1]},\n+                             {red[2], green[2], blue[2]}};\n@@ -184,0 +174,3 @@\n+     * @throws IllegalArgumentException if the component is not\n+     *         {@code REDCOMPONENT}, {@code GREENCOMPONENT}, or\n+     *         {@code BLUECOMPONENT}\n@@ -188,23 +181,1 @@\n-    float theGamma;\n-    int theSignature;\n-\n-        switch (component) {\n-        case REDCOMPONENT:\n-            theSignature = ICC_Profile.icSigRedTRCTag;\n-            break;\n-\n-        case GREENCOMPONENT:\n-            theSignature = ICC_Profile.icSigGreenTRCTag;\n-            break;\n-\n-        case BLUECOMPONENT:\n-            theSignature = ICC_Profile.icSigBlueTRCTag;\n-            break;\n-\n-        default:\n-            throw new IllegalArgumentException(\"Must be Red, Green, or Blue\");\n-        }\n-\n-        theGamma = super.getGamma(theSignature);\n-\n-        return theGamma;\n+        return super.getGamma(toTag(component));\n@@ -235,0 +206,3 @@\n+     * @throws IllegalArgumentException if the component is not\n+     *         {@code REDCOMPONENT}, {@code GREENCOMPONENT}, or\n+     *         {@code BLUECOMPONENT}\n@@ -239,23 +213,1 @@\n-    short[] theTRC;\n-    int theSignature;\n-\n-        switch (component) {\n-        case REDCOMPONENT:\n-            theSignature = ICC_Profile.icSigRedTRCTag;\n-            break;\n-\n-        case GREENCOMPONENT:\n-            theSignature = ICC_Profile.icSigGreenTRCTag;\n-            break;\n-\n-        case BLUECOMPONENT:\n-            theSignature = ICC_Profile.icSigBlueTRCTag;\n-            break;\n-\n-        default:\n-            throw new IllegalArgumentException(\"Must be Red, Green, or Blue\");\n-        }\n-\n-        theTRC = super.getTRC(theSignature);\n-\n-        return theTRC;\n+        return super.getTRC(toTag(component));\n@@ -264,0 +216,18 @@\n+    \/**\n+     * Converts the {@code ICC_ProfileRGB} constant to the appropriate tag.\n+     *\n+     * @param  component the {@code ICC_ProfileRGB} constant\n+     * @return the tag signature\n+     * @throws IllegalArgumentException if the component is not\n+     *         {@code REDCOMPONENT}, {@code GREENCOMPONENT}, or\n+     *         {@code BLUECOMPONENT}\n+     *\/\n+    private static int toTag(int component) {\n+        return switch (component) {\n+            case REDCOMPONENT -> ICC_Profile.icSigRedTRCTag;\n+            case GREENCOMPONENT -> ICC_Profile.icSigGreenTRCTag;\n+            case BLUECOMPONENT -> ICC_Profile.icSigBlueTRCTag;\n+            default -> throw new IllegalArgumentException(\n+                    \"Must be Red, Green, or Blue\");\n+        };\n+    }\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ICC_ProfileRGB.java","additions":34,"deletions":64,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -251,1 +251,1 @@\n-        private static final AtomicLong sequencer = new AtomicLong(0);\n+        private static final AtomicLong sequencer = new AtomicLong();\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/TimerQueue.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -211,1 +211,1 @@\n-    private static final AtomicInteger numAppContexts = new AtomicInteger(0);\n+    private static final AtomicInteger numAppContexts = new AtomicInteger();\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/AppContext.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,0 @@\n-volatile BOOL AwtClipboard::skipInitialWmDrawClipboardMsg = TRUE;\n@@ -47,1 +46,0 @@\n-volatile HWND AwtClipboard::hwndNextViewer = NULL;\n@@ -62,16 +60,1 @@\n-void AwtClipboard::WmChangeCbChain(WPARAM wParam, LPARAM lParam) {\n-    if ((HWND)wParam == hwndNextViewer) {\n-        hwndNextViewer = (HWND)lParam;\n-    } else if (hwndNextViewer != NULL) {\n-        ::SendMessage(hwndNextViewer, WM_CHANGECBCHAIN, wParam, lParam);\n-    }\n-}\n-\n-void AwtClipboard::WmDrawClipboard(JNIEnv *env, WPARAM wParam, LPARAM lParam) {\n-    if (skipInitialWmDrawClipboardMsg) {\n-        \/\/ skipping the first contents change notification as it comes\n-        \/\/ immediately after registering the clipboard viewer window\n-        \/\/ and it is not caused by an actual contents change.\n-        skipInitialWmDrawClipboardMsg = FALSE;\n-        return;\n-    }\n+void AwtClipboard::WmClipboardUpdate(JNIEnv *env) {\n@@ -82,1 +65,0 @@\n-    ::SendMessage(hwndNextViewer, WM_DRAWCLIPBOARD, wParam, lParam);\n@@ -99,1 +81,1 @@\n-    hwndNextViewer = ::SetClipboardViewer(AwtToolkit::GetInstance().GetHWnd());\n+    ::AddClipboardFormatListener(AwtToolkit::GetInstance().GetHWnd());\n@@ -107,2 +89,1 @@\n-        ::ChangeClipboardChain(AwtToolkit::GetInstance().GetHWnd(), AwtClipboard::hwndNextViewer);\n-        AwtClipboard::hwndNextViewer = NULL;\n+        ::RemoveClipboardFormatListener(AwtToolkit::GetInstance().GetHWnd());\n@@ -110,1 +91,0 @@\n-        skipInitialWmDrawClipboardMsg = TRUE;\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Clipboard.cpp","additions":4,"deletions":24,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,2 +39,0 @@\n-    \/\/ handle to the next window in the clipboard viewer chain\n-    static volatile HWND hwndNextViewer;\n@@ -42,1 +40,0 @@\n-    static volatile BOOL skipInitialWmDrawClipboardMsg;\n@@ -60,2 +57,1 @@\n-    static void WmChangeCbChain(WPARAM wparam, LPARAM lparam);\n-    static void WmDrawClipboard(JNIEnv *env, WPARAM wparam, LPARAM lparam);\n+    static void WmClipboardUpdate(JNIEnv *env);\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Clipboard.h","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1070,6 +1070,2 @@\n-      case WM_CHANGECBCHAIN: {\n-          AwtClipboard::WmChangeCbChain(wParam, lParam);\n-          return 0;\n-      }\n-      case WM_DRAWCLIPBOARD: {\n-          AwtClipboard::WmDrawClipboard((JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2), wParam, lParam);\n+      case WM_CLIPBOARDUPDATE: {\n+          AwtClipboard::WmClipboardUpdate((JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2));\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Toolkit.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-        = new AtomicLong(0);\n+        = new AtomicLong();\n","filename":"src\/java.logging\/share\/classes\/java\/util\/logging\/LogRecord.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-    final AtomicInteger received = new AtomicInteger(0);\n+    final AtomicInteger received = new AtomicInteger();\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/WindowUpdateSender.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -378,1 +378,1 @@\n-        AtomicInteger count = new AtomicInteger(0);\n+        AtomicInteger count = new AtomicInteger();\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/SSLFlowDelegate.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-    final AtomicLong upstreamWindow = new AtomicLong(0);\n+    final AtomicLong upstreamWindow = new AtomicLong();\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/SubscriberWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-    private static final AtomicLong nextObjNum = new AtomicLong(0);\n+    private static final AtomicLong nextObjNum = new AtomicLong();\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/server\/ObjID.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.util.concurrent.TimeUnit;\n@@ -73,1 +72,1 @@\n-                private final AtomicInteger count = new AtomicInteger(0);\n+                private final AtomicInteger count = new AtomicInteger();\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/runtime\/RuntimeUtil.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -131,2 +131,0 @@\n-    private final AtomicInteger methodCallIDCount = new AtomicInteger(0);\n-\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/server\/UnicastServerRef.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-    private static final AtomicInteger connectionCount = new AtomicInteger(0);\n+    private static final AtomicInteger connectionCount = new AtomicInteger();\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/transport\/tcp\/TCPTransport.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -652,7 +652,0 @@\n-         * {@preview Associated with records, a preview feature of the Java language.\n-         *\n-         *           This enum constant is associated with <i>records<\/i>, a preview\n-         *           feature of the Java language. Preview features\n-         *           may be removed in a future release, or upgraded to permanent\n-         *           features of the Java language.}\n-         *\n@@ -660,2 +653,1 @@\n-         *\n-         * @since 14\n+         * @since 16\n@@ -663,2 +655,0 @@\n-        @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,\n-                                     essentialAPI=false)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/Tree.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -170,1 +170,0 @@\n-            feature == Feature.RECORDS ||\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -162,2 +162,1 @@\n-        allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &&\n-                Feature.RECORDS.allowedInSource(source);\n+        allowRecords = Feature.RECORDS.allowedInSource(source);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -153,2 +153,1 @@\n-        allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &&\n-                Feature.RECORDS.allowedInSource(source);\n+        allowRecords = Feature.RECORDS.allowedInSource(source);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -275,2 +275,1 @@\n-        allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &&\n-                Feature.RECORDS.allowedInSource(source);\n+        allowRecords = Feature.RECORDS.allowedInSource(source);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -187,2 +187,1 @@\n-        this.allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &&\n-                Feature.RECORDS.allowedInSource(source);\n+        this.allowRecords = Feature.RECORDS.allowedInSource(source);\n@@ -3720,1 +3719,1 @@\n-            if (token.kind == IDENTIFIER && token.name() == names.record && preview.isEnabled()) {\n+            if (token.kind == IDENTIFIER && token.name() == names.record) {\n@@ -4217,1 +4216,1 @@\n-             checkSourceLevel(Feature.RECORDS);\n+            checkSourceLevel(Feature.RECORDS);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-  private static int   Flags_ORIG_COMMAND_LINE;\n+  private static int   Flags_WAS_SET_ON_COMMAND_LINE;\n@@ -198,1 +198,1 @@\n-            if ((flags & Flags_ORIG_COMMAND_LINE) == Flags_ORIG_COMMAND_LINE) {\n+            if ((flags & Flags_WAS_SET_ON_COMMAND_LINE) == Flags_WAS_SET_ON_COMMAND_LINE) {\n@@ -493,9 +493,9 @@\n-    Flags_DEFAULT = db.lookupIntConstant(\"JVMFlag::DEFAULT\").intValue();\n-    Flags_COMMAND_LINE = db.lookupIntConstant(\"JVMFlag::COMMAND_LINE\").intValue();\n-    Flags_ENVIRON_VAR = db.lookupIntConstant(\"JVMFlag::ENVIRON_VAR\").intValue();\n-    Flags_CONFIG_FILE = db.lookupIntConstant(\"JVMFlag::CONFIG_FILE\").intValue();\n-    Flags_MANAGEMENT = db.lookupIntConstant(\"JVMFlag::MANAGEMENT\").intValue();\n-    Flags_ERGONOMIC = db.lookupIntConstant(\"JVMFlag::ERGONOMIC\").intValue();\n-    Flags_ATTACH_ON_DEMAND = db.lookupIntConstant(\"JVMFlag::ATTACH_ON_DEMAND\").intValue();\n-    Flags_INTERNAL = db.lookupIntConstant(\"JVMFlag::INTERNAL\").intValue();\n-    Flags_JIMAGE_RESOURCE = db.lookupIntConstant(\"JVMFlag::JIMAGE_RESOURCE\").intValue();\n+    Flags_DEFAULT = db.lookupIntConstant(\"JVMFlagOrigin::DEFAULT\").intValue();\n+    Flags_COMMAND_LINE = db.lookupIntConstant(\"JVMFlagOrigin::COMMAND_LINE\").intValue();\n+    Flags_ENVIRON_VAR = db.lookupIntConstant(\"JVMFlagOrigin::ENVIRON_VAR\").intValue();\n+    Flags_CONFIG_FILE = db.lookupIntConstant(\"JVMFlagOrigin::CONFIG_FILE\").intValue();\n+    Flags_MANAGEMENT = db.lookupIntConstant(\"JVMFlagOrigin::MANAGEMENT\").intValue();\n+    Flags_ERGONOMIC = db.lookupIntConstant(\"JVMFlagOrigin::ERGONOMIC\").intValue();\n+    Flags_ATTACH_ON_DEMAND = db.lookupIntConstant(\"JVMFlagOrigin::ATTACH_ON_DEMAND\").intValue();\n+    Flags_INTERNAL = db.lookupIntConstant(\"JVMFlagOrigin::INTERNAL\").intValue();\n+    Flags_JIMAGE_RESOURCE = db.lookupIntConstant(\"JVMFlagOrigin::JIMAGE_RESOURCE\").intValue();\n@@ -503,1 +503,1 @@\n-    Flags_ORIG_COMMAND_LINE = db.lookupIntConstant(\"JVMFlag::ORIG_COMMAND_LINE\").intValue();\n+    Flags_WAS_SET_ON_COMMAND_LINE = db.lookupIntConstant(\"JVMFlag::WAS_SET_ON_COMMAND_LINE\").intValue();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/VM.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -31,9 +31,12 @@\n- * HttpContext represents a mapping between the root URI path of an application\n- * to a {@link HttpHandler} which is invoked to handle requests destined\n- * for that path on the associated HttpServer or HttpsServer.\n- * <p>\n- * HttpContext instances are created by the create methods in HttpServer\n- * and HttpsServer\n- * <p>\n- * A chain of {@link Filter} objects can be added to a HttpContext. All exchanges processed by the\n- * context can be pre- and post-processed by each Filter in the chain.\n+ * {@code HttpContext} represents a mapping between the root {@link java.net.URI}\n+ * path of an application to a {@link HttpHandler} which is invoked to handle\n+ * requests destined for that path on the associated {@link HttpServer} or\n+ * {@link HttpsServer}.\n+ *\n+ * <p> {@code HttpContext} instances are created by the create methods in\n+ * {@code HttpServer} and {@code HttpsServer}.\n+ *\n+ * <p> A chain of {@link Filter} objects can be added to a {@code HttpContext}.\n+ * All exchanges processed by the context can be pre- and post-processed by each\n+ * {@code Filter} in the chain.\n+ *\n@@ -47,1 +50,1 @@\n-    protected HttpContext () {\n+    protected HttpContext() {\n@@ -51,2 +54,3 @@\n-     * returns the handler for this context\n-     * @return the HttpHandler for this context\n+     * Returns the handler for this context.\n+     *\n+     * @return the {@code HttpHandler} for this context\n@@ -54,1 +58,1 @@\n-    public abstract HttpHandler getHandler () ;\n+    public abstract HttpHandler getHandler();\n@@ -58,3 +62,4 @@\n-     * @param h the handler to set for this context\n-     * @throws IllegalArgumentException if this context's handler is already set.\n-     * @throws NullPointerException if handler is <code>null<\/code>\n+     *\n+     * @param handler the handler to set for this context\n+     * @throws IllegalArgumentException if the context for this handler is already set.\n+     * @throws NullPointerException if handler is {@code null}\n@@ -62,1 +67,1 @@\n-    public abstract void setHandler (HttpHandler h) ;\n+    public abstract void setHandler(HttpHandler handler);\n@@ -65,2 +70,3 @@\n-     * returns the path this context was created with\n-     * @return this context's path\n+     * Returns the path this context was created with.\n+     *\n+     * @return the context of this path\n@@ -68,1 +74,1 @@\n-    public abstract String getPath() ;\n+    public abstract String getPath();\n@@ -71,2 +77,3 @@\n-     * returns the server this context was created with\n-     * @return this context's server\n+     * Returns the server this context was created with.\n+     *\n+     * @return the context of this server\n@@ -74,1 +81,1 @@\n-    public abstract HttpServer getServer () ;\n+    public abstract HttpServer getServer();\n@@ -77,6 +84,6 @@\n-     * returns a mutable Map, which can be used to pass\n-     * configuration and other data to Filter modules\n-     * and to the context's exchange handler.\n-     * <p>\n-     * Every attribute stored in this Map will be visible to\n-     * every HttpExchange processed by this context\n+     * Returns a mutable {@link Map}, which can be used to pass configuration\n+     * and other data to {@link Filter} modules and to the context's exchange\n+     * handler.\n+     *\n+     * <p> Every attribute stored in this {@code Map} will be visible to every\n+     * {@code HttpExchange} processed by this context.\n@@ -84,1 +91,1 @@\n-     * @return a map containing the attributes of this context\n+     * @return a {@code Map} containing the attributes of this context\n@@ -89,4 +96,5 @@\n-     * returns this context's list of Filters. This is the\n-     * actual list used by the server when dispatching requests\n-     * so modifications to this list immediately affect the\n-     * the handling of exchanges.\n+     * Returns this context's {@link List} of {@linkplain Filter filters}. This\n+     * is the actual list used by the server when dispatching requests so\n+     * modifications to this list immediately affect the the handling of exchanges.\n+     *\n+     * @return a {@link List} containing the filters of this context\n@@ -97,9 +105,9 @@\n-     * Sets the Authenticator for this HttpContext. Once an authenticator\n-     * is establised on a context, all client requests must be\n-     * authenticated, and the given object will be invoked to validate each\n-     * request. Each call to this method replaces any previous value set.\n-     * @param auth the authenticator to set. If <code>null<\/code> then any\n-     *         previously set authenticator is removed,\n-     *         and client authentication will no longer be required.\n-     * @return the previous Authenticator, if any set, or <code>null<\/code>\n-     *         otherwise.\n+     * Sets the {@link Authenticator} for this {@code HttpContext}. Once an authenticator\n+     * is establised on a context, all client requests must be authenticated,\n+     * and the given object will be invoked to validate each request. Each call\n+     * to this method replaces any previous value set.\n+     *\n+     * @param auth the {@code Authenticator} to set. If {@code null} then any previously\n+     *             set {@code Authenticator} is removed, and client authentication\n+     *             will no longer be required.\n+     * @return the previous {@code Authenticator}, if any set, or {@code null} otherwise.\n@@ -107,1 +115,1 @@\n-    public abstract Authenticator setAuthenticator (Authenticator auth);\n+    public abstract Authenticator setAuthenticator(Authenticator auth);\n@@ -110,1 +118,1 @@\n-     * Returns the currently set Authenticator for this context\n+     * Returns the currently set {@link Authenticator} for this context\n@@ -112,2 +120,3 @@\n-     * @return this HttpContext's Authenticator, or <code>null<\/code>\n-     *         if none is set.\n+     *\n+     * @return this {@linkplain HttpContext HttpContext's} {@code Authenticator},\n+     * or {@code null} if none is set\n@@ -115,1 +124,1 @@\n-    public abstract Authenticator getAuthenticator ();\n+    public abstract Authenticator getAuthenticator();\n","filename":"src\/jdk.httpserver\/share\/classes\/com\/sun\/net\/httpserver\/HttpContext.java","additions":57,"deletions":48,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ *\n@@ -40,0 +41,1 @@\n+     *\n@@ -41,2 +43,2 @@\n-     *      client and used to send the response\n-     * @throws NullPointerException if exchange is <code>null<\/code>\n+     *                 client and used to send the response\n+     * @throws NullPointerException if exchange is {@code null}\n","filename":"src\/jdk.httpserver\/share\/classes\/com\/sun\/net\/httpserver\/HttpHandler.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,4 +37,6 @@\n-     * creates a HttpPrincipal from the given username and realm\n-     * @param username The name of the user within the realm\n-     * @param realm The realm.\n-     * @throws NullPointerException if either username or realm are null\n+     * Creates a {@code HttpPrincipal} from the given {@code username} and\n+     * {@code realm}.\n+     *\n+     * @param username the name of the user within the realm\n+     * @param realm the realm for this user\n+     * @throws NullPointerException if either username or realm are {@code null}\n@@ -42,1 +44,1 @@\n-    public HttpPrincipal (String username, String realm) {\n+    public HttpPrincipal(String username, String realm) {\n@@ -51,4 +53,8 @@\n-     * Compares two HttpPrincipal. Returns <code>true<\/code>\n-     * if <i>another<\/i> is an instance of HttpPrincipal, and its\n-     * username and realm are equal to this object's username\n-     * and realm. Returns <code>false<\/code> otherwise.\n+     * Compare two instances of {@code HttpPrincipal}. Returns {@code true} if\n+     * <i>another<\/i> is an instance of {@code HttpPrincipal}, and its username\n+     * and realm are equal to this object's username and realm. Returns {@code false}\n+     * otherwise.\n+     *\n+     * @param another the object to compare this instance of {@code HttpPrincipal} against\n+     * @return {@code true} or {@code false} depending on whether objects are\n+     * equal or not\n@@ -56,1 +62,1 @@\n-    public boolean equals (Object another) {\n+    public boolean equals(Object another) {\n@@ -66,2 +72,4 @@\n-     * returns the contents of this principal in the form\n-     * <i>realm:username<\/i>\n+     * Returns the contents of this principal in the form\n+     * <i>realm:username<\/i>.\n+     *\n+     * @return the contents of this principal in the form realm:username\n@@ -74,1 +82,1 @@\n-     * returns the username this object was created with.\n+     * Returns the {@code username} this object was created with.\n@@ -76,1 +84,1 @@\n-     * @return The name of the user assoicated with this object\n+     * @return the name of the user associated with this object\n@@ -83,1 +91,1 @@\n-     * returns the realm this object was created with.\n+     * Returns the {@code realm} this object was created with.\n@@ -85,1 +93,1 @@\n-     * @return The realm associated with this object\n+     * @return the realm associated with this object\n@@ -92,2 +100,4 @@\n-     * returns a hashcode for this HttpPrincipal. This is calculated\n-     * as <code>(getUsername()+getRealm().hashCode()<\/code>\n+     * Returns a hashcode for this {@code HttpPrincipal}. This is calculated\n+     * as {@code (getUsername()+getRealm()).hashCode()}.\n+     *\n+     * @return the hashcode for this object\n@@ -100,1 +110,3 @@\n-     * returns the same string as getName()\n+     * Returns the same string as {@link #getName()}.\n+     *\n+     * @return the name associated with this object\n","filename":"src\/jdk.httpserver\/share\/classes\/com\/sun\/net\/httpserver\/HttpPrincipal.java","additions":31,"deletions":19,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -28,8 +28,2 @@\n-import java.net.*;\n-import java.io.*;\n-import java.nio.*;\n-import java.security.*;\n-import java.nio.channels.*;\n-import java.util.*;\n-import java.util.concurrent.*;\n-import javax.net.ssl.*;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n@@ -40,1 +34,1 @@\n- * https connection on a HttpsServer. Applications need to override\n+ * https connection on a {@link HttpsServer}. Applications need to override\n@@ -43,2 +37,2 @@\n- * <p>\n- * The following <a id=\"example\">example<\/a> shows how this may be done:\n+ *\n+ * <p> The following <a id=\"example\">example<\/a> shows how this may be done:\n@@ -68,0 +62,1 @@\n+ *\n@@ -75,3 +70,4 @@\n-     * Creates an Https configuration, with the given SSLContext.\n-     * @param context the SSLContext to use for this configurator\n-     * @throws NullPointerException if no SSLContext supplied\n+     * Creates a Https configuration, with the given {@link SSLContext}.\n+     *\n+     * @param context the {@code SSLContext} to use for this configurator\n+     * @throws NullPointerException if no {@code SSLContext} supplied\n@@ -79,1 +75,1 @@\n-    public HttpsConfigurator (SSLContext context) {\n+    public HttpsConfigurator(SSLContext context) {\n@@ -87,2 +83,3 @@\n-     * Returns the SSLContext for this HttpsConfigurator.\n-     * @return the SSLContext\n+     * Returns the {@link SSLContext} for this {@code HttpsConfigurator}.\n+     *\n+     * @return the {@code SSLContext}\n@@ -94,1 +91,0 @@\n-\/\/BEGIN_TIGER_EXCLUDE\n@@ -96,13 +92,14 @@\n-    * Called by the HttpsServer to configure the parameters\n-    * for a https connection currently being established.\n-    * The implementation of configure() must call\n-    * {@link HttpsParameters#setSSLParameters(SSLParameters)}\n-    * in order to set the SSL parameters for the connection.\n-    * <p>\n-    * The default implementation of this method uses the\n-    * SSLParameters returned from <p>\n-    * {@code getSSLContext().getDefaultSSLParameters()}\n-    * <p>\n-    * configure() may be overridden in order to modify this behavior.\n-    * See, the example <a href=\"#example\">above<\/a>.\n-    * @param params the HttpsParameters to be configured.\n+    * Called by the {@link HttpsServer} to configure the parameters for a https\n+    * connection currently being established. The implementation of configure()\n+    * must call {@link HttpsParameters#setSSLParameters(SSLParameters)} in order\n+    * to set the SSL parameters for the connection.\n+    *\n+    * <p> The default implementation of this method uses the\n+    * SSLParameters returned from:\n+    *\n+    * <p> {@code getSSLContext().getDefaultSSLParameters()}\n+    *\n+    * <p> configure() may be overridden in order to modify this behavior. See\n+    * example <a href=\"#example\">above<\/a>.\n+    *\n+    * @param params the {@code HttpsParameters} to be configured\n@@ -112,1 +109,1 @@\n-    public void configure (HttpsParameters params) {\n+    public void configure(HttpsParameters params) {\n@@ -115,1 +112,0 @@\n-\/\/END_TIGER_EXCLUDE\n","filename":"src\/jdk.httpserver\/share\/classes\/com\/sun\/net\/httpserver\/HttpsConfigurator.java","additions":29,"deletions":33,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -82,7 +82,17 @@\n-        withFindNeededPackages = LibProvidersLookup.supported();\n-        if (!withFindNeededPackages) {\n-            final String advice;\n-            if (\"deb\".equals(getID())) {\n-                advice = \"message.deb-ldd-not-available.advice\";\n-            } else {\n-                advice = \"message.rpm-ldd-not-available.advice\";\n+        if (!isDefault()) {\n+            withFindNeededPackages = false;\n+            Log.verbose(MessageFormat.format(I18N.getString(\n+                    \"message.not-default-bundler-no-dependencies-lookup\"),\n+                    getName()));\n+        } else {\n+            withFindNeededPackages = LibProvidersLookup.supported();\n+            if (!withFindNeededPackages) {\n+                final String advice;\n+                if (\"deb\".equals(getID())) {\n+                    advice = \"message.deb-ldd-not-available.advice\";\n+                } else {\n+                    advice = \"message.rpm-ldd-not-available.advice\";\n+                }\n+                \/\/ Let user know package dependencies will not be generated.\n+                Log.error(String.format(\"%s\\n%s\", I18N.getString(\n+                        \"message.ldd-not-available\"), I18N.getString(advice)));\n@@ -90,3 +100,0 @@\n-            \/\/ Let user know package dependencies will not be generated.\n-            Log.error(String.format(\"%s\\n%s\", I18N.getString(\n-                    \"message.ldd-not-available\"), I18N.getString(advice)));\n@@ -195,1 +202,0 @@\n-\n","filename":"src\/jdk.incubator.jpackage\/linux\/classes\/jdk\/incubator\/jpackage\/internal\/LinuxPackageBundler.java","additions":17,"deletions":11,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+message.not-default-bundler-no-dependencies-lookup={0} is not the default package type. Package dependencies will not be generated.\n","filename":"src\/jdk.incubator.jpackage\/linux\/classes\/jdk\/incubator\/jpackage\/internal\/resources\/LinuxResources.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,2 +43,0 @@\n-warning.foreign-app-image=Warning: app-image dir not generated by jpackage.\n-\n@@ -66,0 +64,3 @@\n+warning.foreign-app-image=Warning: app-image dir not generated by jpackage.\n+message.not-default-bundler-no-dependencies-lookup={0} is not the default package type. Package dependencies will not be generated.\n+\n","filename":"src\/jdk.incubator.jpackage\/linux\/classes\/jdk\/incubator\/jpackage\/internal\/resources\/LinuxResources_ja.properties","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -43,2 +43,0 @@\n-warning.foreign-app-image=Warning: app-image dir not generated by jpackage.\n-\n@@ -66,0 +64,3 @@\n+warning.foreign-app-image=Warning: app-image dir not generated by jpackage.\n+message.not-default-bundler-no-dependencies-lookup={0} is not the default package type. Package dependencies will not be generated.\n+\n","filename":"src\/jdk.incubator.jpackage\/linux\/classes\/jdk\/incubator\/jpackage\/internal\/resources\/LinuxResources_zh_CN.properties","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -476,9 +476,0 @@\n-            \/\/hdiutil unflatten your_image_file.dmg\n-            pb = new ProcessBuilder(\n-                    hdiutil,\n-                    \"unflatten\",\n-                    finalDMG.toAbsolutePath().toString()\n-            );\n-            IOUtils.exec(pb);\n-\n-            \/\/add license\n@@ -493,9 +484,0 @@\n-\n-            \/\/hdiutil flatten your_image_file.dmg\n-            pb = new ProcessBuilder(\n-                    hdiutil,\n-                    \"flatten\",\n-                    finalDMG.toAbsolutePath().toString()\n-            );\n-            IOUtils.exec(pb);\n-\n","filename":"src\/jdk.incubator.jpackage\/macosx\/classes\/jdk\/incubator\/jpackage\/internal\/MacDmgBundler.java","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -503,1 +503,1 @@\n-        ByteOrder bo = ByteOrder.LITTLE_ENDIAN;\n+        ByteOrder bo = ByteOrder.nativeOrder();\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractVector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    private final static AtomicLong counter = new AtomicLong(0);\n+    private final static AtomicLong counter = new AtomicLong();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/AbstractEventStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import java.net.SocketAddress;\n+import java.net.UnixDomainSocketAddress;\n@@ -31,1 +33,0 @@\n-\n@@ -44,2 +45,0 @@\n-    private InetSocketAddress remoteAddress;\n-\n@@ -61,2 +60,5 @@\n-                String hostString  = remoteAddress.getAddress().toString();\n-                int delimiterIndex = hostString.lastIndexOf('\/');\n+                SocketAddress remoteAddress = getRemoteAddress();\n+                if (remoteAddress instanceof InetSocketAddress) {\n+                    InetSocketAddress isa = (InetSocketAddress) remoteAddress;\n+                    String hostString  = isa.getAddress().toString();\n+                    int delimiterIndex = hostString.lastIndexOf('\/');\n@@ -64,5 +66,8 @@\n-                String host = hostString.substring(0, delimiterIndex);\n-                String address = hostString.substring(delimiterIndex + 1);\n-                int port = remoteAddress.getPort();\n-                if (bytesRead < 0) {\n-                    handler.write(start, duration, host, address, port, 0, 0L, true);\n+                    String host = hostString.substring(0, delimiterIndex);\n+                    String address = hostString.substring(delimiterIndex + 1);\n+                    int port = isa.getPort();\n+                    if (bytesRead < 0) {\n+                        handler.write(start, duration, host, address, port, 0, 0L, true);\n+                    } else {\n+                        handler.write(start, duration, host, address, port, 0, bytesRead, false);\n+                    }\n@@ -70,1 +75,7 @@\n-                    handler.write(start, duration, host, address, port, 0, bytesRead, false);\n+                    UnixDomainSocketAddress udsa = (UnixDomainSocketAddress) remoteAddress;\n+                    String path = \"[\" + udsa.getPath().toString() + \"]\";\n+                    if (bytesRead < 0) {\n+                        handler.write(start, duration, \"Unix domain socket\", path, 0, 0, 0L, true);\n+                    } else {\n+                        handler.write(start, duration, \"Unix domain socket\", path, 0, 0, bytesRead, false);\n+                    }\n@@ -84,1 +95,0 @@\n-\n@@ -93,2 +103,5 @@\n-                String hostString  = remoteAddress.getAddress().toString();\n-                int delimiterIndex = hostString.lastIndexOf('\/');\n+                SocketAddress remoteAddress = getRemoteAddress();\n+                if (remoteAddress instanceof InetSocketAddress) {\n+                    InetSocketAddress isa = (InetSocketAddress) remoteAddress;\n+                    String hostString  = isa.getAddress().toString();\n+                    int delimiterIndex = hostString.lastIndexOf('\/');\n@@ -96,5 +109,8 @@\n-                String host = hostString.substring(0, delimiterIndex);\n-                String address = hostString.substring(delimiterIndex + 1);\n-                int port = remoteAddress.getPort();\n-                if (bytesRead < 0) {\n-                    handler.write(start, duration, host, address, port, 0, 0L, true);\n+                    String host = hostString.substring(0, delimiterIndex);\n+                    String address = hostString.substring(delimiterIndex + 1);\n+                    int port = isa.getPort();\n+                    if (bytesRead < 0) {\n+                        handler.write(start, duration, host, address, port, 0, 0L, true);\n+                    } else {\n+                        handler.write(start, duration, host, address, port, 0, bytesRead, false);\n+                    }\n@@ -102,1 +118,7 @@\n-                    handler.write(start, duration, host, address, port, 0, bytesRead, false);\n+                    UnixDomainSocketAddress udsa = (UnixDomainSocketAddress) remoteAddress;\n+                    String path = \"[\" + udsa.getPath().toString() + \"]\";\n+                    if (bytesRead < 0) {\n+                        handler.write(start, duration, \"Unix domain socket\", path, 0, 0, 0L, true);\n+                    } else {\n+                        handler.write(start, duration, \"Unix domain socket\", path, 0, 0, bytesRead, false);\n+                    }\n@@ -124,6 +146,0 @@\n-                String hostString  = remoteAddress.getAddress().toString();\n-                int delimiterIndex = hostString.lastIndexOf('\/');\n-\n-                String host = hostString.substring(0, delimiterIndex);\n-                String address = hostString.substring(delimiterIndex + 1);\n-                int port = remoteAddress.getPort();\n@@ -131,1 +147,15 @@\n-                handler.write(start, duration, host, address, port, bytes);\n+                SocketAddress remoteAddress = getRemoteAddress();\n+                if (remoteAddress instanceof InetSocketAddress) {\n+                    InetSocketAddress isa = (InetSocketAddress) remoteAddress;\n+                    String hostString  = isa.getAddress().toString();\n+                    int delimiterIndex = hostString.lastIndexOf('\/');\n+\n+                    String host = hostString.substring(0, delimiterIndex);\n+                    String address = hostString.substring(delimiterIndex + 1);\n+                    int port = isa.getPort();\n+                    handler.write(start, duration, host, address, port, bytes);\n+                } else {\n+                    UnixDomainSocketAddress udsa = (UnixDomainSocketAddress) remoteAddress;\n+                    String path = \"[\" + udsa.getPath().toString() + \"]\";\n+                    handler.write(start, duration, \"Unix domain socket\", path, 0, bytes);\n+                }\n@@ -137,0 +167,5 @@\n+    public SocketAddress getRemoteAddress() throws IOException {\n+        \/\/ gets replaced by call to instrumented class\n+        return null;\n+    }\n+\n@@ -152,6 +187,0 @@\n-                String hostString  = remoteAddress.getAddress().toString();\n-                int delimiterIndex = hostString.lastIndexOf('\/');\n-\n-                String host = hostString.substring(0, delimiterIndex);\n-                String address = hostString.substring(delimiterIndex + 1);\n-                int port = remoteAddress.getPort();\n@@ -159,1 +188,15 @@\n-                handler.write(start, duration, host, address, port, bytes);\n+                SocketAddress remoteAddress = getRemoteAddress();\n+                if (remoteAddress instanceof InetSocketAddress) {\n+                    InetSocketAddress isa = (InetSocketAddress) remoteAddress;\n+                    String hostString  = isa.getAddress().toString();\n+                    int delimiterIndex = hostString.lastIndexOf('\/');\n+\n+                    String host = hostString.substring(0, delimiterIndex);\n+                    String address = hostString.substring(delimiterIndex + 1);\n+                    int port = isa.getPort();\n+                    handler.write(start, duration, host, address, port, bytes);\n+                } else {\n+                    UnixDomainSocketAddress udsa = (UnixDomainSocketAddress) remoteAddress;\n+                    String path = \"[\" + udsa.getPath().toString() + \"]\";\n+                    handler.write(start, duration, \"Unix domain socket\", path, 0, bytes);\n+                }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/SocketChannelImplInstrumentor.java","additions":77,"deletions":34,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-    private static final AtomicLong numThrowables = new AtomicLong(0);\n+    private static final AtomicLong numThrowables = new AtomicLong();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/ThrowableTracer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"","filename":"src\/jdk.jfr\/share\/man\/jfr.1","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/java.base\/share\/man\/jfr.1","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.nio.file.attribute.UserPrincipal;\n+import java.nio.file.attribute.GroupPrincipal;\n@@ -31,0 +33,1 @@\n+import sun.nio.fs.UnixUserPrincipals;\n@@ -57,0 +60,4 @@\n+    boolean peerCredentialsSupported() {\n+        return true;\n+    }\n+\n@@ -97,0 +104,10 @@\n+    @Override\n+    UnixDomainPrincipal getSoPeerCred(int fd) throws SocketException {\n+        long l = getSoPeerCred0(fd);\n+        int uid = (int)(l >> 32);\n+        int gid = (int)l;\n+        UserPrincipal user = UnixUserPrincipals.fromUid(uid);\n+        GroupPrincipal group = UnixUserPrincipals.fromGid(gid);\n+        return new UnixDomainPrincipal(user, group);\n+    }\n+\n@@ -105,0 +122,1 @@\n+    private static native long getSoPeerCred0(int fd) throws SocketException;\n","filename":"src\/jdk.net\/linux\/classes\/jdk\/net\/LinuxSocketOptions.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+#include <sys\/un.h>\n+#include <sys\/types.h>\n@@ -112,0 +114,23 @@\n+\/*\n+ * Class:     jdk_net_LinuxSocketOptions\n+ * Method:    getSoPeerCred0\n+ * Signature: (I)L\n+ *\/\n+JNIEXPORT jlong JNICALL Java_jdk_net_LinuxSocketOptions_getSoPeerCred0\n+  (JNIEnv *env, jclass clazz, jint fd) {\n+\n+    int rv;\n+    struct ucred cred;\n+    socklen_t len = sizeof(cred);\n+\n+    if ((rv=getsockopt(fd, SOL_SOCKET, SO_PEERCRED, &cred, &len)) < 0) {\n+        handleError(env, rv, \"get SO_PEERCRED failed\");\n+    } else {\n+        if ((int)cred.uid == -1) {\n+            handleError(env, -1, \"get SO_PEERCRED failed\");\n+            cred.uid = cred.gid = -1;\n+        }\n+    }\n+    return (((jlong)cred.uid) << 32) | (cred.gid & 0xffffffffL);\n+}\n+\n","filename":"src\/jdk.net\/linux\/native\/libextnet\/LinuxSocketOptions.c","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.nio.file.attribute.UserPrincipal;\n+import java.nio.file.attribute.GroupPrincipal;\n@@ -31,0 +33,1 @@\n+import sun.nio.fs.UnixUserPrincipals;\n@@ -52,0 +55,5 @@\n+    @Override\n+    boolean peerCredentialsSupported() {\n+        return true;\n+    }\n+\n@@ -72,0 +80,10 @@\n+    @Override\n+    UnixDomainPrincipal getSoPeerCred(int fd) throws SocketException {\n+        long l = getSoPeerCred0(fd);\n+        int uid = (int)(l >> 32);\n+        int gid = (int)l;\n+        UserPrincipal user = UnixUserPrincipals.fromUid(uid);\n+        GroupPrincipal group = UnixUserPrincipals.fromGid(gid);\n+        return new UnixDomainPrincipal(user, group);\n+    }\n+\n@@ -78,0 +96,1 @@\n+    private static native long getSoPeerCred0(int fd) throws SocketException;\n","filename":"src\/jdk.net\/macosx\/classes\/jdk\/net\/MacOSXSocketOptions.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include <sys\/types.h>\n@@ -126,0 +127,19 @@\n+\/*\n+ * Class:     jdk_net_MacOSXSocketOptions\n+ * Method:    getSoPeerCred0\n+ * Signature: (I)L\n+ *\/\n+JNIEXPORT jlong JNICALL Java_jdk_net_MacOSXSocketOptions_getSoPeerCred0\n+  (JNIEnv *env, jclass clazz, jint fd) {\n+\n+    jint rv;\n+    int uid, gid;\n+    rv = getpeereid(fd, (uid_t *)&uid, (gid_t *)&gid);\n+    handleError(env, rv, \"get peer eid failed\");\n+    if (rv == -1) {\n+        uid = gid = -1;\n+    }\n+    return (((long)uid) << 32) | (gid & 0xffffffffL);\n+}\n+\n+\n","filename":"src\/jdk.net\/macosx\/native\/libextnet\/MacOSXSocketOptions.c","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -183,0 +183,19 @@\n+    \/**\n+     * Unix Domain peer credentials.\n+     *\n+     * <p> The value of this socket option is a {@link UnixDomainPrincipal} that\n+     * represents the credentials of a peer connected to a Unix Domain socket.\n+     * The credentials are those that applied at the time the socket was first\n+     * connected or accepted.\n+     *\n+     * <p> The socket option is read-only and an attempt to set the socket option\n+     * will throw {@code SocketException}. {@code SocketException} is also thrown\n+     * when attempting to get the value of the socket option on an unconnected Unix\n+     * Domain socket.\n+     *\n+     * @since 16\n+     *\/\n+    public static final SocketOption<UnixDomainPrincipal> SO_PEERCRED\n+        = new ExtSocketOption<UnixDomainPrincipal>\n+            (\"SO_PEERCRED\", UnixDomainPrincipal.class);\n+\n@@ -190,0 +209,2 @@\n+    private static final boolean peerCredentialsSupported =\n+            platformSocketOptions.peerCredentialsSupported();\n@@ -205,0 +226,3 @@\n+        if (peerCredentialsSupported) {\n+            options.add(SO_PEERCRED);\n+        }\n@@ -236,0 +260,2 @@\n+                } else if (option == SO_PEERCRED) {\n+                    throw new SocketException(\"SO_PEERCRED cannot be set \");\n@@ -258,0 +284,2 @@\n+                } else if (option == SO_PEERCRED) {\n+                    return getSoPeerCred(fd);\n@@ -275,0 +303,5 @@\n+    private static Object getSoPeerCred(FileDescriptor fd)\n+            throws SocketException {\n+        return platformSocketOptions.getSoPeerCred(fdAccess.get(fd));\n+    }\n+\n@@ -348,0 +381,4 @@\n+        boolean peerCredentialsSupported() {\n+            return false;\n+        }\n+\n@@ -372,0 +409,4 @@\n+        UnixDomainPrincipal getSoPeerCred(int fd) throws SocketException {\n+            throw new UnsupportedOperationException(\"unsupported SO_PEERCRED option\");\n+        }\n+\n","filename":"src\/jdk.net\/share\/classes\/jdk\/net\/ExtendedSocketOptions.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.net;\n+\n+import java.nio.file.attribute.UserPrincipal;\n+import java.nio.file.attribute.GroupPrincipal;\n+import java.util.Objects;\n+\n+\/**\n+ * Represents the credentials of a peer connected to a\n+ * <a href=\"..\/..\/..\/java.base\/java\/nio\/channels\/package-summary.html#unixdomain\">\n+ * Unix domain<\/a> socket.\n+ *\n+ * @since 16\n+ *\/\n+\n+public final class UnixDomainPrincipal {\n+    private final UserPrincipal user;\n+    private final GroupPrincipal group;\n+\n+    \/**\n+     * Creates a UnixDomainPrincipal.\n+     *\n+     * @param user the user identity\n+     *\n+     * @param group the group identity\n+     *\n+     * @throws NullPointerException if {@code user} or {@code group} are {@code null}.\n+     *\/\n+    public UnixDomainPrincipal(UserPrincipal user, GroupPrincipal group) {\n+        this.user = Objects.requireNonNull(user);\n+        this.group = Objects.requireNonNull(group);\n+    }\n+\n+    \/**\n+     * Returns true if {@code obj} is a {@code UnixDomainPrincipal}\n+     * and its user and group are equal to this user and group.\n+     *\n+     * @param obj the object to compare with\n+     * @return true if this equal to obj\n+     *\/\n+    public boolean equals(Object obj) {\n+        if (obj instanceof UnixDomainPrincipal) {\n+            UnixDomainPrincipal that = (UnixDomainPrincipal) obj;\n+            return Objects.equals(this.user, that.user)\n+                    && Objects.equals(this.group, that.group);\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Returns a hashcode calculated from the user and group\n+     *\/\n+    public int hashCode() {\n+        return Objects.hash(user, group);\n+    }\n+\n+    \/**\n+     * Returns this object's {@link UserPrincipal}\n+     *\n+     * @return this object's user\n+     *\/\n+    public UserPrincipal user() {\n+        return user;\n+    }\n+\n+    \/**\n+     * Returns this object's {@link GroupPrincipal}\n+     *\n+     * @return this object's user\n+     *\/\n+    public GroupPrincipal group() {\n+        return group;\n+    }\n+}\n","filename":"src\/jdk.net\/share\/classes\/jdk\/net\/UnixDomainPrincipal.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/z\/zForwardingAllocator.inline.hpp\"\n@@ -160,0 +161,5 @@\n+    \/\/ Setup allocator\n+    ZForwardingAllocator allocator;\n+    const uint32_t nentries = ZForwarding::nentries(&page);\n+    allocator.reset((sizeof(ZForwarding)) + (nentries * sizeof(ZForwardingEntry)));\n+\n@@ -161,1 +167,1 @@\n-    ZForwarding* const forwarding = ZForwarding::create(&page);\n+    ZForwarding* const forwarding = ZForwarding::alloc(&allocator, &page);\n@@ -165,3 +171,0 @@\n-\n-    \/\/ Teardown forwarding\n-    ZForwarding::destroy(forwarding);\n","filename":"test\/hotspot\/gtest\/gc\/z\/test_zForwarding.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/stackOverflow.hpp\"\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"unittest.hpp\"\n+\n+\n+TEST_VM(StackOverflow, basics) {\n+  StackOverflow so;\n+\n+  \/\/ Make up a stack range. No need to allocate anything. Size has to be large enough\n+  \/\/  to fit sum of all zones into them.\n+  address base = (address) 0x40000000;\n+  const size_t size = os::vm_page_size() * 100;\n+  address end = base - size;\n+  so.initialize(base, end);\n+\n+  \/\/ Walking down the \"stack\" check for consistency of the three \"in_stack_xxx\" functions\n+  enum { normal_stack, reserved_or_yellow_zone, red_zone } where = normal_stack;\n+  for (address p = base - 1; p >= end; p -= os::vm_page_size()) {\n+    \/\/ tty->print_cr(PTR_FORMAT \" %d %d %d\", p2i(p),\n+    \/\/     (int)so.in_stack_reserved_zone(p),\n+    \/\/     (int)so.in_stack_yellow_reserved_zone(p),\n+    \/\/     (int)so.in_stack_red_zone(p));\n+    switch (where) {\n+    case normal_stack:\n+      ASSERT_FALSE(so.in_stack_red_zone(p));\n+      if (so.in_stack_yellow_reserved_zone(p)) {\n+        if (StackReservedPages > 0) {\n+          ASSERT_TRUE(so.in_stack_reserved_zone(p));\n+        } else {\n+          ASSERT_FALSE(so.in_stack_reserved_zone(p));\n+        }\n+        where = reserved_or_yellow_zone;\n+      } else {\n+        ASSERT_FALSE(so.in_stack_reserved_zone((p)));\n+      }\n+      break;\n+    case reserved_or_yellow_zone:\n+      if (so.in_stack_red_zone(p)) {\n+        ASSERT_FALSE(so.in_stack_yellow_reserved_zone(p));\n+        where = red_zone;\n+      } else {\n+        ASSERT_TRUE(so.in_stack_yellow_reserved_zone(p));\n+      }\n+      break;\n+    case red_zone:\n+      ASSERT_TRUE(so.in_stack_red_zone(p));\n+      ASSERT_FALSE(so.in_stack_yellow_reserved_zone(p));\n+      ASSERT_FALSE(so.in_stack_reserved_zone((p)));\n+      break;\n+    }\n+  }\n+  ASSERT_EQ(where, red_zone);\n+\n+  \/\/ Check bases.\n+  ASSERT_FALSE(so.in_stack_red_zone(so.stack_red_zone_base()));\n+  ASSERT_TRUE(so.in_stack_red_zone(so.stack_red_zone_base() - 1));\n+  ASSERT_TRUE(so.in_stack_yellow_reserved_zone(so.stack_red_zone_base()));\n+  ASSERT_FALSE(so.in_stack_reserved_zone(so.stack_reserved_zone_base()));\n+  if (so.stack_reserved_zone_size() > 0) {\n+    ASSERT_TRUE(so.in_stack_reserved_zone(so.stack_reserved_zone_base() - 1));\n+  }\n+}\n","filename":"test\/hotspot\/gtest\/runtime\/test_stackoverflow.cpp","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -67,0 +67,2 @@\n+compiler\/loopstripmining\/BackedgeNodeWithOutOfLoopControl.java 8255120 generic-all\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -78,1 +78,2 @@\n-    test.vm.gc.nvdimm\n+    test.vm.gc.nvdimm \\\n+    jdk.containerized\n","filename":"test\/hotspot\/jtreg\/TEST.ROOT","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -205,1 +205,0 @@\n-  -gc\/survivorAlignment\/TestPromotionFromSurvivorToTenuredAfterMinorGC.java \\\n@@ -310,0 +309,1 @@\n+ -runtime\/Thread\/ThreadCountLimit.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2020, Huawei Technologies Co. Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/**\n+ * @test\n+ * @bug 8255287\n+ * @summary aarch64: fix SVE patterns for vector shift count\n+ *\n+ * @requires os.arch == \"aarch64\" & vm.compiler2.enabled\n+ * @run main\/othervm -XX:UseSVE=2 -Xbatch -XX:-TieredCompilation\n+ *      -XX:CompileCommand=compileonly,compiler.c2.aarch64.TestVectorShiftShorts::test_*\n+ *      compiler.c2.aarch64.TestVectorShiftShorts\n+ *\/\n+\n+package compiler.c2.aarch64;\n+\n+public class TestVectorShiftShorts {\n+\n+    private static final int ARRLEN = 1000;\n+    private static final int ITERS  = 20000;\n+\n+    public static void main(String args[]) {\n+        short[] a0 = new short[ARRLEN];\n+        short[] a1 = new short[ARRLEN];\n+\n+        \/\/ Initialize\n+        test_init(a0, a1);\n+\n+        \/\/ Warmup\n+        for (int i = 0; i < ITERS; i++) {\n+            test_lshift(a0, a1);\n+            test_urshift(a0, a1);\n+        }\n+\n+        \/\/ Test and verify results\n+        test_init(a0, a1);\n+        test_lshift(a0, a1);\n+        verify_lshift(a0, a1);\n+\n+        test_init(a0, a1);\n+        test_urshift(a0, a1);\n+        verify_urshift(a0, a1);\n+\n+        \/\/ Finish\n+        System.out.println(\"Test passed\");\n+    }\n+\n+    static void test_init(short[] a0, short[] a1) {\n+        for (int i = 0; i < ARRLEN; i++) {\n+            a0[i] = (short)(i & 3);\n+            a1[i] = (short)i;\n+        }\n+    }\n+\n+    static void test_lshift(short[] a0, short[] a1) {\n+        for (int i = 0; i < ARRLEN; i++) {\n+            a0[i] = (short)(a1[i] << 10);\n+        }\n+    }\n+\n+    static void verify_lshift(short[] a0, short[] a1) {\n+        for (int i = 0; i < ARRLEN; i++) {\n+            if (a0[i] != (short)(a1[i] << 10)) {\n+                throw new RuntimeException(\"LShift test failed.\");\n+            }\n+        }\n+    }\n+\n+    static void test_urshift(short[] a0, short[] a1) {\n+        for (int i = 0; i < ARRLEN; i++) {\n+            a0[i] = (short)(a1[i] >>> 10);\n+        }\n+    }\n+\n+    static void verify_urshift(short[] a0, short[] a1) {\n+        for (int i = 0; i < ARRLEN; i++) {\n+            if (a0[i] != (short)(a1[i] >>> 10)) {\n+                throw new RuntimeException(\"URshift test failed.\");\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/aarch64\/TestVectorShiftShorts.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8255466\n+ * @summary unsafe access to static field causes crash\n+ * @modules java.base\/jdk.internal.misc\n+ *\n+ * @run main\/othervm -Xcomp -XX:CompileCommand=compileonly,TestUnsafeStaticFieldAccess::* TestUnsafeStaticFieldAccess\n+ *\n+ *\/\n+\n+import jdk.internal.misc.Unsafe;\n+import java.lang.reflect.Field;\n+\n+public class TestUnsafeStaticFieldAccess {\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+    private static final long offset;\n+    private static volatile Class<?> clazz;\n+\n+    private static int field;\n+\n+    static {\n+        long o = 0;\n+        for (Field f : TestUnsafeStaticFieldAccess.class.getDeclaredFields()) {\n+            if (f.getName().equals(\"field\")) {\n+                o = UNSAFE.staticFieldOffset(f);\n+                break;\n+            }\n+        }\n+        offset = o;\n+        clazz = TestUnsafeStaticFieldAccess.class;\n+    }\n+\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 12000; i++) {\n+            UNSAFE.getInt(clazz, offset);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/TestUnsafeStaticFieldAccess.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8251994\n+ * @summary Test vectorization of Streams$RangeIntSpliterator::forEachRemaining\n+ * @requires vm.compiler2.enabled & vm.compMode != \"Xint\"\n+ *\n+ * @run main compiler.vectorization.TestForEachRem test1\n+ * @run main compiler.vectorization.TestForEachRem test2\n+ * @run main compiler.vectorization.TestForEachRem test3\n+ * @run main compiler.vectorization.TestForEachRem test4\n+ *\/\n+\n+package compiler.vectorization;\n+\n+import java.util.stream.IntStream;\n+\n+public class TestForEachRem {\n+    static final int RANGE = 512;\n+    static final int ITER  = 100;\n+\n+    static void test1(int[] data) {\n+       IntStream.range(0, RANGE).parallel().forEach(j -> {\n+           data[j] = j + 1;\n+       });\n+    }\n+\n+    static void test2(int[] data) {\n+       IntStream.range(0, RANGE - 1).forEach(j -> {\n+           data[j] = data[j] + data[j + 1];\n+       });\n+    }\n+\n+    static void test3(int[] data, int A, int B) {\n+       IntStream.range(0, RANGE - 1).forEach(j -> {\n+           data[j] = A * data[j] + B * data[j + 1];\n+       });\n+    }\n+\n+    static void test4(int[] data) {\n+       IntStream.range(0, RANGE - 1).forEach(j -> {\n+           data[j + 1] = data[j];\n+       });\n+    }\n+\n+    static void verify(String name, int[] data, int[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + name + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        int[] data = new int[RANGE];\n+        int[] gold = new int[RANGE];\n+\n+        if (args.length == 0) {\n+            throw new RuntimeException(\" Missing test name: test1, test2, test3, test4\");\n+        }\n+\n+        if (args[0].equals(\"test1\")) {\n+            System.out.println(\" Run test1 ...\");\n+            test1(gold);\n+            for (int i = 0; i < ITER; i++) {\n+                test1(data);\n+            }\n+            verify(\"test1\", data, gold);\n+            System.out.println(\" Finished test1.\");\n+        }\n+\n+        if (args[0].equals(\"test2\")) {\n+            System.out.println(\" Run test2 ...\");\n+            test1(gold);\n+            test2(gold);\n+            for (int i = 0; i < ITER; i++) {\n+                test1(data); \/\/ reset\n+                test2(data);\n+            }\n+            verify(\"test2\", data, gold);\n+            System.out.println(\" Finished test2.\");\n+        }\n+\n+        if (args[0].equals(\"test3\")) {\n+            System.out.println(\" Run test3 ...\");\n+            test1(gold);\n+            test3(gold, 2, 3);\n+            for (int i = 0; i < ITER; i++) {\n+                test1(data); \/\/ reset\n+                test3(data, 2, 3);\n+            }\n+            verify(\"test3\", data, gold);\n+            System.out.println(\" Finished test3.\");\n+        }\n+\n+        if (args[0].equals(\"test4\")) {\n+            System.out.println(\" Run test4 ...\");\n+            test1(gold); \/\/ reset\n+            test4(gold);\n+            for (int i = 0; i < ITER; i++) {\n+                test1(data); \/\/ reset\n+                test4(data);\n+            }\n+            verify(\"test4\", data, gold);\n+            System.out.println(\" Finished test4.\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestForEachRem.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8251994\n+ * @summary Test forced vectorization\n+ * @requires vm.compiler2.enabled & vm.compMode != \"Xint\"\n+ *\n+ * @run main\/othervm -XX:CompileCommand=option,*::test,Vectorize compiler.vectorization.TestOptionVectorize\n+ *\/\n+\n+package compiler.vectorization;\n+\n+import java.util.stream.IntStream;\n+\n+public class TestOptionVectorize {\n+    static final int RANGE = 512;\n+    static final int ITER  = 100;\n+\n+    static void init(double[] data) {\n+       IntStream.range(0, RANGE).parallel().forEach(j -> {\n+           data[j] = j + 1;\n+       });\n+    }\n+\n+    static void test(double[] data, double A, double B) {\n+        for (int i = RANGE - 1; i > 0; i--) {\n+            for (int j = 0; j <= i - 1; j++) {\n+                data[j] = A * data[j + 1] + B * data[j];\n+            }\n+        }\n+    }\n+\n+    static void verify(double[] data, double[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        double[] data = new double[RANGE];\n+        double[] gold = new double[RANGE];\n+        System.out.println(\" Run test ...\");\n+        init(gold); \/\/ reset\n+        test(gold, 1.0, 2.0);\n+        for (int i = 0; i < ITER; i++) {\n+            init(data); \/\/ reset\n+            test(data, 1.0, 2.0);\n+        }\n+        verify(data, gold);\n+        System.out.println(\" Finished test.\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestOptionVectorize.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -56,0 +56,3 @@\n+    private Path cgroupv1CgroupsJoinControllers;\n+    private Path cgroupv1SelfCgroupsJoinControllers;\n+    private Path cgroupv1MountInfoJoinControllers;\n@@ -84,0 +87,11 @@\n+    private String procSelfCgroupV1JoinControllers =\n+            \"9:freezer:\/\\n\" +\n+            \"8:rdma:\/\\n\" +\n+            \"7:blkio:\/user.slice\\n\" +\n+            \"6:devices:\/user.slice\\n\" +\n+            \"5:pids:\/user.slice\/user-1000.slice\/session-2.scope\\n\" +\n+            \"4:cpu,cpuacct,memory,net_cls,net_prio,hugetlb:\/user.slice\/user-1000.slice\/session-2.scope\\n\" +\n+            \"3:cpuset:\/\\n\" +\n+            \"2:perf_event:\/\\n\" +\n+            \"1:name=systemd:\/user.slice\/user-1000.slice\/session-2.scope\\n\" +\n+            \"0::\/user.slice\/user-1000.slice\/session-2.scope\\n\";\n@@ -95,0 +109,15 @@\n+    private String cgroupsNonZeroJoinControllers =\n+            \"#subsys_name hierarchy num_cgroups enabled\\n\" +\n+            \"cpuset\\t3\\t1\\t1\\n\" +\n+            \"cpu\\t4\\t153\\t1\\n\" +\n+            \"cpuacct\\t4\\t153\\t1\\n\" +\n+            \"blkio\\t7\\t87\\t1\\n\" +\n+            \"memory\\t4\\t153\\t1\\n\" +\n+            \"devices\\t6\\t87\\t1\\n\" +\n+            \"freezer\\t9\\t1\\t1\\n\" +\n+            \"net_cls\\t4\\t153\\t1\\n\" +\n+            \"perf_event\\t2\\t1\\t1\\n\" +\n+            \"net_prio\\t4\\t153\\t1\\n\" +\n+            \"hugetlb\\t4\\t153\\t1\\n\" +\n+            \"pids\\t5\\t95\\t1\\n\" +\n+            \"rdma\\t8\\t1\\t1\\n\";\n@@ -113,0 +142,12 @@\n+    private String mntInfoCgroupv1JoinControllers =\n+            \"31 22 0:26 \/ \/sys\/fs\/cgroup ro,nosuid,nodev,noexec shared:9 - tmpfs tmpfs ro,mode=755\\n\" +\n+            \"32 31 0:27 \/ \/sys\/fs\/cgroup\/unified rw,nosuid,nodev,noexec,relatime shared:10 - cgroup2 cgroup2 rw,nsdelegate\\n\" +\n+            \"33 31 0:28 \/ \/sys\/fs\/cgroup\/systemd rw,nosuid,nodev,noexec,relatime shared:11 - cgroup cgroup rw,xattr,name=systemd\\n\" +\n+            \"36 31 0:31 \/ \/sys\/fs\/cgroup\/perf_event rw,nosuid,nodev,noexec,relatime shared:15 - cgroup cgroup rw,perf_event\\n\" +\n+            \"37 31 0:32 \/ \/sys\/fs\/cgroup\/cpuset rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,cpuset\\n\" +\n+            \"38 31 0:33 \/ \/sys\/fs\/cgroup\/cpu,cpuacct,net_cls,net_prio,hugetlb,memory rw,nosuid,nodev,noexec,relatime shared:17 - cgroup cgroup rw,cpu,cpuacct,memory,net_cls,net_prio,hugetlb\\n\" +\n+            \"39 31 0:34 \/ \/sys\/fs\/cgroup\/pids rw,nosuid,nodev,noexec,relatime shared:18 - cgroup cgroup rw,pids\\n\" +\n+            \"40 31 0:35 \/ \/sys\/fs\/cgroup\/devices rw,nosuid,nodev,noexec,relatime shared:19 - cgroup cgroup rw,devices\\n\" +\n+            \"41 31 0:36 \/ \/sys\/fs\/cgroup\/blkio rw,nosuid,nodev,noexec,relatime shared:20 - cgroup cgroup rw,blkio\\n\" +\n+            \"42 31 0:37 \/ \/sys\/fs\/cgroup\/rdma rw,nosuid,nodev,noexec,relatime shared:21 - cgroup cgroup rw,rdma\\n\" +\n+            \"43 31 0:38 \/ \/sys\/fs\/cgroup\/freezer rw,nosuid,nodev,noexec,relatime shared:22 - cgroup cgroup rw,freezer\\n\";\n@@ -178,0 +219,9 @@\n+\n+            cgroupv1CgroupsJoinControllers = Paths.get(existingDirectory.toString(), \"cgroups_cgv1_join_controllers\");\n+            Files.writeString(cgroupv1CgroupsJoinControllers, cgroupsNonZeroJoinControllers);\n+\n+            cgroupv1SelfCgroupsJoinControllers = Paths.get(existingDirectory.toString(), \"self_cgroup_cgv1_join_controllers\");\n+            Files.writeString(cgroupv1SelfCgroupsJoinControllers, procSelfCgroupV1JoinControllers);\n+\n+            cgroupv1MountInfoJoinControllers = Paths.get(existingDirectory.toString(), \"mntinfo_cgv1_join_controllers\");\n+            Files.writeString(cgroupv1MountInfoJoinControllers, mntInfoCgroupv1JoinControllers);\n@@ -195,0 +245,10 @@\n+    public void testCgroupv1JoinControllerCombo(WhiteBox wb) {\n+        String procCgroups = cgroupv1CgroupsJoinControllers.toString();\n+        String procSelfCgroup = cgroupv1SelfCgroupsJoinControllers.toString();\n+        String procSelfMountinfo = cgroupv1MountInfoJoinControllers.toString();\n+        int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);\n+        Asserts.assertEQ(CGROUPS_V1, retval, \"Join controllers should be properly detected\");\n+        Asserts.assertTrue(isValidCgroup(retval));\n+        System.out.println(\"testCgroupv1JoinControllerMounts PASSED!\");\n+    }\n+\n@@ -290,0 +350,1 @@\n+            test.testCgroupv1JoinControllerCombo(wb);\n","filename":"test\/hotspot\/jtreg\/containers\/cgroup\/CgroupSubsystemFactory.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -1,142 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.arguments;\n-\n-import jdk.test.lib.Platform;\n-import jdk.test.lib.process.ExitCode;\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-\n-\/**\n- * @test\n- * @bug 8031323\n- * @summary Verify SurvivorAlignmentInBytes option processing.\n- * @library \/test\/lib\n- * @requires vm.opt.SurvivorAlignmentInBytes == null\n- *           & vm.opt.ObjectAlignmentInBytes == null\n- *           & vm.opt.UnlockExperimentalVMOptions == null\n- *           & (vm.opt.IgnoreUnrecognizedVMOptions == null\n- *              | vm.opt.IgnoreUnrecognizedVMOptions == \"false\")\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @run driver gc.arguments.TestSurvivorAlignmentInBytesOption\n- *\/\n-public class TestSurvivorAlignmentInBytesOption {\n-    public static void main(String args[]) throws Throwable {\n-        String optionName = \"SurvivorAlignmentInBytes\";\n-        String unlockExperimentalVMOpts = \"UnlockExperimentalVMOptions\";\n-        String optionIsExperimental\n-                = CommandLineOptionTest.getExperimentalOptionErrorMessage(\n-                optionName);\n-        String valueIsTooSmall= \".*SurvivorAlignmentInBytes.*must be greater\"\n-                + \" than or equal to ObjectAlignmentInBytes.*\";\n-        String mustBePowerOf2 = \".*SurvivorAlignmentInBytes.*must be \"\n-                + \"power of 2.*\";\n-\n-        \/\/ Verify that without -XX:+UnlockExperimentalVMOptions usage of\n-        \/\/ SurvivorAlignmentInBytes option will cause JVM startup failure\n-        \/\/ with the warning message saying that that option is experimental.\n-        String shouldFailMessage = String.format(\"JVM option '%s' is \"\n-                + \"experimental.%nJVM startup should fail without \"\n-                + \"-XX:+UnlockExperimentalVMOptions option\", optionName);\n-        CommandLineOptionTest.verifyJVMStartup(\n-                new String[]{optionIsExperimental}, null,\n-                shouldFailMessage, shouldFailMessage,\n-                ExitCode.FAIL, false,\n-                \"-XX:-UnlockExperimentalVMOptions\",\n-                CommandLineOptionTest.prepareBooleanFlag(\n-                        unlockExperimentalVMOpts, false),\n-                CommandLineOptionTest.prepareNumericFlag(optionName, 64));\n-\n-        \/\/ Verify that with -XX:+UnlockExperimentalVMOptions passed to JVM\n-        \/\/ usage of SurvivorAlignmentInBytes option won't cause JVM startup\n-        \/\/ failure.\n-        String shouldPassMessage = String.format(\"JVM option '%s' is \"\n-                + \"experimental.%nJVM startup should pass with \"\n-                + \"-XX:+UnlockExperimentalVMOptions option\", optionName);\n-        String noWarningMessage = \"There should be no warnings when use \"\n-                + \"with -XX:+UnlockExperimentalVMOptions option\";\n-        CommandLineOptionTest.verifyJVMStartup(\n-                null, new String[]{optionIsExperimental},\n-                shouldPassMessage, noWarningMessage,\n-                ExitCode.OK, false,\n-                CommandLineOptionTest.prepareBooleanFlag(\n-                        unlockExperimentalVMOpts, true),\n-                CommandLineOptionTest.prepareNumericFlag(optionName, 64));\n-\n-        \/\/ Verify that if specified SurvivorAlignmentInBytes is lower than\n-        \/\/ ObjectAlignmentInBytes, then the JVM startup will fail with\n-        \/\/ appropriate error message.\n-        if (Platform.is64bit()) {\n-            shouldFailMessage = String.format(\"JVM startup should fail with \"\n-                    + \"'%s' option value lower than ObjectAlignmentInBytes\", optionName);\n-            CommandLineOptionTest.verifyJVMStartup(\n-                    new String[]{valueIsTooSmall}, null,\n-                    shouldFailMessage, shouldFailMessage,\n-                    ExitCode.FAIL, false,\n-                    CommandLineOptionTest.prepareBooleanFlag(\n-                            unlockExperimentalVMOpts, true),\n-                    CommandLineOptionTest.prepareNumericFlag(optionName, 8),\n-                    CommandLineOptionTest.prepareNumericFlag(\"ObjectAlignmentInBytes\", 16));\n-        }\n-\n-        \/\/ Verify that if specified SurvivorAlignmentInBytes value is not\n-        \/\/ a power of 2 then the JVM startup will fail with appropriate error\n-        \/\/ message.\n-        shouldFailMessage = String.format(\"JVM startup should fail with \"\n-                + \"'%s' option value is not a power of 2\", optionName);\n-        CommandLineOptionTest.verifyJVMStartup(\n-                new String[]{mustBePowerOf2}, null,\n-                shouldFailMessage, shouldFailMessage,\n-                ExitCode.FAIL, false,\n-                CommandLineOptionTest.prepareBooleanFlag(\n-                        unlockExperimentalVMOpts, true),\n-                CommandLineOptionTest.prepareNumericFlag(optionName, 127));\n-\n-        \/\/ Verify that if SurvivorAlignmentInBytes has correct value, then\n-        \/\/ the JVM will be started without errors.\n-        shouldPassMessage = String.format(\"JVM startup should pass with \"\n-                + \"correct '%s' option value\", optionName);\n-        noWarningMessage = String.format(\"There should be no warnings when use \"\n-                + \"correct '%s' option value\", optionName);\n-        CommandLineOptionTest.verifyJVMStartup(\n-                null, new String[]{\".*SurvivorAlignmentInBytes.*\"},\n-                shouldPassMessage, noWarningMessage,\n-                ExitCode.OK, false,\n-                CommandLineOptionTest.prepareBooleanFlag(\n-                        unlockExperimentalVMOpts, true),\n-                CommandLineOptionTest.prepareNumericFlag(optionName, 128));\n-\n-        \/\/ Verify that we can setup different SurvivorAlignmentInBytes values.\n-        for (int alignment = 32; alignment <= 128; alignment *= 2) {\n-            shouldPassMessage = String.format(\"JVM startup should pass with \"\n-                    + \"'%s' = %d\", optionName, alignment);\n-            CommandLineOptionTest.verifyOptionValue(optionName,\n-                    Integer.toString(alignment), shouldPassMessage,\n-                    CommandLineOptionTest.prepareBooleanFlag(\n-                            unlockExperimentalVMOpts, true),\n-                    CommandLineOptionTest.prepareNumericFlag(\n-                            optionName, alignment));\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestSurvivorAlignmentInBytesOption.java","additions":0,"deletions":142,"binary":false,"changes":142,"status":"deleted"},{"patch":"@@ -1,176 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.survivorAlignment;\n-\n-import java.lang.management.MemoryPoolMXBean;\n-import java.util.Optional;\n-\n-import sun.hotspot.WhiteBox;\n-\n-\/**\n- * Helper class aimed to provide information about alignment of objects in\n- * particular heap space, expected memory usage after objects' allocation so on.\n- *\/\n-public class AlignmentHelper {\n-    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n-\n-    private static final long OBJECT_ALIGNMENT_IN_BYTES_FOR_32_VM = 8L;\n-\n-    \/**\n-     * Max relative allowed actual memory usage deviation from expected memory\n-     * usage.\n-     *\/\n-    private static final float MAX_RELATIVE_DEVIATION = 0.05f; \/\/ 5%\n-\n-    public static final long OBJECT_ALIGNMENT_IN_BYTES = Optional.ofNullable(\n-            AlignmentHelper.WHITE_BOX.getIntxVMFlag(\"ObjectAlignmentInBytes\"))\n-            .orElse(AlignmentHelper.OBJECT_ALIGNMENT_IN_BYTES_FOR_32_VM);\n-\n-    public static final long SURVIVOR_ALIGNMENT_IN_BYTES = Optional.ofNullable(\n-            AlignmentHelper.WHITE_BOX.getIntxVMFlag(\"SurvivorAlignmentInBytes\"))\n-            .orElseThrow(() ->new AssertionError(\n-                    \"Unable to get SurvivorAlignmentInBytes value\"));\n-    \/**\n-     * Min amount of memory that will be occupied by an object.\n-     *\/\n-    public static final long MIN_OBJECT_SIZE\n-            = AlignmentHelper.WHITE_BOX.getObjectSize(new Object());\n-    \/**\n-     * Min amount of memory that will be occupied by an empty byte array.\n-     *\/\n-    public static final long MIN_ARRAY_SIZE\n-            = AlignmentHelper.WHITE_BOX.getObjectSize(new byte[0]);\n-\n-    \/**\n-     * Precision at which actual memory usage in a heap space represented by\n-     * this sizing helper could be measured.\n-     *\/\n-    private final long memoryUsageMeasurementPrecision;\n-    \/**\n-     * Min amount of memory that will be occupied by an object allocated in a\n-     * heap space represented by this sizing helper.\n-     *\/\n-    private final long minObjectSizeInThisSpace;\n-    \/**\n-     * Object's alignment in a heap space represented by this sizing helper.\n-     *\/\n-    private final long objectAlignmentInThisRegion;\n-    \/**\n-     * MemoryPoolMXBean associated with a heap space represented by this sizing\n-     * helper.\n-     *\/\n-    private final MemoryPoolMXBean poolMXBean;\n-\n-    private static long alignUp(long value, long alignment) {\n-        return ((value - 1) \/ alignment + 1) * alignment;\n-    }\n-\n-    protected AlignmentHelper(long memoryUsageMeasurementPrecision,\n-            long objectAlignmentInThisRegion, long minObjectSizeInThisSpace,\n-            MemoryPoolMXBean poolMXBean) {\n-        this.memoryUsageMeasurementPrecision = memoryUsageMeasurementPrecision;\n-        this.minObjectSizeInThisSpace = minObjectSizeInThisSpace;\n-        this.objectAlignmentInThisRegion = objectAlignmentInThisRegion;\n-        this.poolMXBean = poolMXBean;\n-    }\n-\n-    \/**\n-     * Returns how many objects have to be allocated to fill\n-     * {@code memoryToFill} bytes in this heap space using objects of size\n-     * {@code objectSize}.\n-     *\/\n-    public int getObjectsCount(long memoryToFill, long objectSize) {\n-        return (int) (memoryToFill \/ getObjectSizeInThisSpace(objectSize));\n-    }\n-\n-    \/**\n-     * Returns amount of memory that {@code objectsCount} of objects with size\n-     * {@code objectSize} will occupy this this space after allocation.\n-     *\/\n-    public long getExpectedMemoryUsage(long objectSize, int objectsCount) {\n-        long correctedObjectSize = getObjectSizeInThisSpace(objectSize);\n-        return AlignmentHelper.alignUp(correctedObjectSize * objectsCount,\n-                memoryUsageMeasurementPrecision);\n-    }\n-\n-    \/**\n-     * Returns current memory usage in this heap space.\n-     *\/\n-    public long getActualMemoryUsage() {\n-        return poolMXBean.getUsage().getUsed();\n-    }\n-\n-    \/**\n-     * Returns maximum memory usage deviation from {@code expectedMemoryUsage}\n-     * given the max allowed relative deviation equal to\n-     * {@code relativeDeviation}.\n-     *\n-     * Note that value returned by this method is aligned according to\n-     * memory measurement precision for this heap space.\n-     *\/\n-    public long getAllowedMemoryUsageDeviation(long expectedMemoryUsage) {\n-        long unalignedDeviation = (long) (expectedMemoryUsage *\n-                AlignmentHelper.MAX_RELATIVE_DEVIATION);\n-        return AlignmentHelper.alignUp(unalignedDeviation,\n-                memoryUsageMeasurementPrecision);\n-    }\n-\n-    \/**\n-     * Returns amount of memory that will be occupied by an object with size\n-     * {@code objectSize} in this heap space.\n-     *\/\n-    public long getObjectSizeInThisSpace(long objectSize) {\n-        objectSize = Math.max(objectSize, minObjectSizeInThisSpace);\n-\n-        long alignedObjectSize = AlignmentHelper.alignUp(objectSize,\n-                objectAlignmentInThisRegion);\n-        long sizeDiff = alignedObjectSize - objectSize;\n-\n-        \/\/ If there is not enough space to fit padding object, then object will\n-        \/\/ be aligned to {@code 2 * objectAlignmentInThisRegion}.\n-        if (sizeDiff >= AlignmentHelper.OBJECT_ALIGNMENT_IN_BYTES\n-                && sizeDiff < AlignmentHelper.MIN_OBJECT_SIZE) {\n-            alignedObjectSize += AlignmentHelper.MIN_OBJECT_SIZE;\n-            alignedObjectSize = AlignmentHelper.alignUp(alignedObjectSize,\n-                    objectAlignmentInThisRegion);\n-        }\n-\n-        return alignedObjectSize;\n-    }\n-    @Override\n-    public String toString() {\n-        StringBuilder builder = new StringBuilder();\n-\n-        builder.append(String.format(\"AlignmentHelper for memory pool '%s':%n\",\n-                poolMXBean.getName()));\n-        builder.append(String.format(\"Memory usage measurement precision: %d%n\",\n-                memoryUsageMeasurementPrecision));\n-        builder.append(String.format(\"Min object size in this space: %d%n\",\n-                minObjectSizeInThisSpace));\n-        builder.append(String.format(\"Object alignment in this space: %d%n\",\n-                objectAlignmentInThisRegion));\n-\n-        return builder.toString();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/survivorAlignment\/AlignmentHelper.java","additions":0,"deletions":176,"binary":false,"changes":176,"status":"deleted"},{"patch":"@@ -1,395 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.survivorAlignment;\n-\n-import java.lang.management.ManagementFactory;\n-import java.lang.management.MemoryPoolMXBean;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-import jdk.test.lib.Asserts;\n-import com.sun.management.ThreadMXBean;\n-import sun.hotspot.WhiteBox;\n-import jdk.internal.misc.Unsafe;\n-\n-\/**\n- * Main class for tests on {@code SurvivorAlignmentInBytes} option.\n- *\n- * Typical usage is to obtain instance using fromArgs method, allocate objects\n- * and verify that actual memory usage in tested heap space is close to\n- * expected.\n- *\/\n-public class SurvivorAlignmentTestMain {\n-    enum HeapSpace {\n-        EDEN,\n-        SURVIVOR,\n-        TENURED\n-    }\n-\n-    public static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n-\n-    public static final long MAX_TENURING_THRESHOLD = Optional.ofNullable(\n-            SurvivorAlignmentTestMain.WHITE_BOX.getIntxVMFlag(\n-                    \"MaxTenuringThreshold\")).orElse(15L);\n-\n-    \/**\n-     * Regexp used to parse memory size params, like 2G, 34m or 15k.\n-     *\/\n-    private static final Pattern SIZE_REGEX\n-            = Pattern.compile(\"(?<size>[0-9]+)(?<multiplier>[GMKgmk])?\");\n-\n-    \/\/ Names of different heap spaces.\n-    private static final String DEF_NEW_EDEN = \"Eden Space\";\n-    private static final String DEF_NEW_SURVIVOR = \"Survivor Space\";\n-    private static final String PAR_NEW_EDEN = \"Par Eden Space\";\n-    private static final String PAR_NEW_SURVIVOR = \"Par Survivor Space\";\n-    private static final String PS_EDEN = \"PS Eden Space\";\n-    private static final String PS_SURVIVOR = \"PS Survivor Space\";\n-    private static final String G1_EDEN = \"G1 Eden Space\";\n-    private static final String G1_SURVIVOR = \"G1 Survivor Space\";\n-    private static final String SERIAL_TENURED = \"Tenured Gen\";\n-    private static final String PS_TENURED = \"PS Old Gen\";\n-    private static final String G1_TENURED = \"G1 Old Gen\";\n-\n-    private static final long G1_HEAP_REGION_SIZE = Optional.ofNullable(\n-            SurvivorAlignmentTestMain.WHITE_BOX.getUintxVMFlag(\n-                    \"G1HeapRegionSize\")).orElse(-1L);\n-\n-    private static final AlignmentHelper EDEN_SPACE_HELPER;\n-    private static final AlignmentHelper SURVIVOR_SPACE_HELPER;\n-    private static final AlignmentHelper TENURED_SPACE_HELPER;\n-    \/**\n-     * Amount of memory that should be filled during a test run.\n-     *\/\n-    private final long memoryToFill;\n-    \/**\n-     * The size of an objects that will be allocated during a test run.\n-     *\/\n-    private final long objectSize;\n-    \/**\n-     * Amount of memory that will be actually occupied by an object in eden\n-     * space.\n-     *\/\n-    private final long actualObjectSize;\n-    \/**\n-     * Storage for allocated objects.\n-     *\/\n-    private final Object[] garbage;\n-    \/**\n-     * Heap space whose memory usage is a subject of assertions during the test\n-     * run.\n-     *\/\n-    private final HeapSpace testedSpace;\n-\n-    private long[] baselinedThreadMemoryUsage = null;\n-    private long[] threadIds = null;\n-\n-    \/**\n-     * Initialize {@code EDEN_SPACE_HELPER}, {@code SURVIVOR_SPACE_HELPER} and\n-     * {@code TENURED_SPACE_HELPER} to represent heap spaces in use.\n-     *\n-     * Note that regardless to GC object's alignment in survivor space is\n-     * expected to be equal to {@code SurvivorAlignmentInBytes} value and\n-     * alignment in other spaces is expected to be equal to\n-     * {@code ObjectAlignmentInBytes} value.\n-     *\n-     * For G1 GC MXBeans could report memory usage only with region size\n-     * precision (if an object allocated in some G1 heap region, then all region\n-     * will claimed as used), so for G1's spaces precision is equal to\n-     * {@code G1HeapRegionSize} value.\n-     *\/\n-    static {\n-        AlignmentHelper edenHelper = null;\n-        AlignmentHelper survivorHelper = null;\n-        AlignmentHelper tenuredHelper = null;\n-        for (MemoryPoolMXBean pool : ManagementFactory.getMemoryPoolMXBeans()) {\n-            switch (pool.getName()) {\n-                case SurvivorAlignmentTestMain.DEF_NEW_EDEN:\n-                case SurvivorAlignmentTestMain.PAR_NEW_EDEN:\n-                case SurvivorAlignmentTestMain.PS_EDEN:\n-                    Asserts.assertNull(edenHelper,\n-                            \"Only one bean for eden space is expected.\");\n-                    edenHelper = new AlignmentHelper(\n-                            AlignmentHelper.OBJECT_ALIGNMENT_IN_BYTES,\n-                            AlignmentHelper.OBJECT_ALIGNMENT_IN_BYTES,\n-                            AlignmentHelper.MIN_OBJECT_SIZE, pool);\n-                    break;\n-                case SurvivorAlignmentTestMain.G1_EDEN:\n-                    Asserts.assertNull(edenHelper,\n-                            \"Only one bean for eden space is expected.\");\n-                    edenHelper = new AlignmentHelper(\n-                            SurvivorAlignmentTestMain.G1_HEAP_REGION_SIZE,\n-                            AlignmentHelper.OBJECT_ALIGNMENT_IN_BYTES,\n-                            AlignmentHelper.MIN_OBJECT_SIZE, pool);\n-                    break;\n-                case SurvivorAlignmentTestMain.DEF_NEW_SURVIVOR:\n-                case SurvivorAlignmentTestMain.PAR_NEW_SURVIVOR:\n-                case SurvivorAlignmentTestMain.PS_SURVIVOR:\n-                    Asserts.assertNull(survivorHelper,\n-                            \"Only one bean for survivor space is expected.\");\n-                    survivorHelper = new AlignmentHelper(\n-                            AlignmentHelper.OBJECT_ALIGNMENT_IN_BYTES,\n-                            AlignmentHelper.SURVIVOR_ALIGNMENT_IN_BYTES,\n-                            AlignmentHelper.MIN_OBJECT_SIZE, pool);\n-                    break;\n-                case SurvivorAlignmentTestMain.G1_SURVIVOR:\n-                    Asserts.assertNull(survivorHelper,\n-                            \"Only one bean for survivor space is expected.\");\n-                    survivorHelper = new AlignmentHelper(\n-                            SurvivorAlignmentTestMain.G1_HEAP_REGION_SIZE,\n-                            AlignmentHelper.SURVIVOR_ALIGNMENT_IN_BYTES,\n-                            AlignmentHelper.MIN_OBJECT_SIZE, pool);\n-                    break;\n-                case SurvivorAlignmentTestMain.SERIAL_TENURED:\n-                case SurvivorAlignmentTestMain.PS_TENURED:\n-                case SurvivorAlignmentTestMain.G1_TENURED:\n-                    Asserts.assertNull(tenuredHelper,\n-                            \"Only one bean for tenured space is expected.\");\n-                    tenuredHelper = new AlignmentHelper(\n-                            AlignmentHelper.OBJECT_ALIGNMENT_IN_BYTES,\n-                            AlignmentHelper.OBJECT_ALIGNMENT_IN_BYTES,\n-                            AlignmentHelper.MIN_OBJECT_SIZE, pool);\n-                    break;\n-            }\n-        }\n-        EDEN_SPACE_HELPER = Objects.requireNonNull(edenHelper,\n-                \"AlignmentHelper for eden space should be initialized.\");\n-        SURVIVOR_SPACE_HELPER = Objects.requireNonNull(survivorHelper,\n-                \"AlignmentHelper for survivor space should be initialized.\");\n-        TENURED_SPACE_HELPER = Objects.requireNonNull(tenuredHelper,\n-                \"AlignmentHelper for tenured space should be initialized.\");\n-    }\n-    \/**\n-     * Returns an SurvivorAlignmentTestMain instance constructed using CLI\n-     * options.\n-     *\n-     * Following options are expected:\n-     * <ul>\n-     *     <li>memoryToFill<\/li>\n-     *     <li>objectSize<\/li>\n-     * <\/ul>\n-     *\n-     * Both argument may contain multiplier suffix k, m or g.\n-     *\/\n-    public static SurvivorAlignmentTestMain fromArgs(String[] args) {\n-        Asserts.assertEQ(args.length, 3, \"Expected three arguments: \"\n-                + \"memory size, object size and tested heap space name.\");\n-\n-        long memoryToFill = parseSize(args[0]);\n-        long objectSize = Math.max(parseSize(args[1]),\n-                AlignmentHelper.MIN_ARRAY_SIZE);\n-        HeapSpace testedSpace = HeapSpace.valueOf(args[2]);\n-\n-        return new SurvivorAlignmentTestMain(memoryToFill, objectSize,\n-                testedSpace);\n-    }\n-\n-    \/**\n-     * Returns a value parsed from a string with format\n-     * &lt;integer&gt;&lt;multiplier&gt;.\n-     *\/\n-    private static long parseSize(String sizeString) {\n-        Matcher matcher = SIZE_REGEX.matcher(sizeString);\n-        Asserts.assertTrue(matcher.matches(),\n-                \"sizeString should have following format \\\"[0-9]+([MBK])?\\\"\");\n-        long size = Long.valueOf(matcher.group(\"size\"));\n-\n-        if (matcher.group(\"multiplier\") != null) {\n-            long K = 1024L;\n-            \/\/ fall through multipliers\n-            switch (matcher.group(\"multiplier\").toLowerCase()) {\n-                case \"g\":\n-                    size *= K;\n-                case \"m\":\n-                    size *= K;\n-                case \"k\":\n-                    size *= K;\n-            }\n-        }\n-        return size;\n-    }\n-\n-    private SurvivorAlignmentTestMain(long memoryToFill, long objectSize,\n-            HeapSpace testedSpace) {\n-        this.objectSize = objectSize;\n-        this.memoryToFill = memoryToFill;\n-        this.testedSpace = testedSpace;\n-\n-        AlignmentHelper helper = SurvivorAlignmentTestMain.EDEN_SPACE_HELPER;\n-\n-        this.actualObjectSize = helper.getObjectSizeInThisSpace(\n-                this.objectSize);\n-        int arrayLength = helper.getObjectsCount(memoryToFill, this.objectSize);\n-        garbage = new Object[arrayLength];\n-    }\n-\n-    \/**\n-     * Allocate byte arrays to fill {@code memoryToFill} memory.\n-     *\/\n-    public void allocate() {\n-        int byteArrayLength = Math.max((int) (objectSize\n-                - Unsafe.ARRAY_BYTE_BASE_OFFSET), 0);\n-\n-        for (int i = 0; i < garbage.length; i++) {\n-            garbage[i] = new byte[byteArrayLength];\n-        }\n-    }\n-\n-    \/**\n-     * Release memory occupied after {@code allocate} call.\n-     *\/\n-    public void release() {\n-        for (int i = 0; i < garbage.length; i++) {\n-            garbage[i] = null;\n-        }\n-    }\n-\n-    \/**\n-     * Returns expected amount of memory occupied in a {@code heapSpace} by\n-     * objects referenced from {@code garbage} array.\n-     *\/\n-    public long getExpectedMemoryUsage() {\n-        AlignmentHelper alignmentHelper = getAlignmentHelper(testedSpace);\n-        return alignmentHelper.getExpectedMemoryUsage(objectSize,\n-                garbage.length);\n-    }\n-\n-    \/**\n-     * Verifies that memory usage in a {@code heapSpace} deviates from\n-     * {@code expectedUsage} for no more than {@code MAX_RELATIVE_DEVIATION}.\n-     *\/\n-    public void verifyMemoryUsage(long expectedUsage) {\n-        AlignmentHelper alignmentHelper = getAlignmentHelper(testedSpace);\n-\n-        long actualMemoryUsage = alignmentHelper.getActualMemoryUsage();\n-        boolean otherThreadsAllocatedMemory = areOtherThreadsAllocatedMemory();\n-\n-        long memoryUsageDiff = Math.abs(actualMemoryUsage - expectedUsage);\n-        long maxAllowedUsageDiff\n-                = alignmentHelper.getAllowedMemoryUsageDeviation(expectedUsage);\n-\n-        System.out.println(\"Verifying memory usage in space: \" + testedSpace);\n-        System.out.println(\"Allocated objects count: \" + garbage.length);\n-        System.out.println(\"Desired object size: \" + objectSize);\n-        System.out.println(\"Actual object size: \" + actualObjectSize);\n-        System.out.println(\"Expected object size in space: \"\n-                + alignmentHelper.getObjectSizeInThisSpace(objectSize));\n-        System.out.println(\"Expected memory usage: \" + expectedUsage);\n-        System.out.println(\"Actual memory usage: \" + actualMemoryUsage);\n-        System.out.println(\"Memory usage diff: \" + memoryUsageDiff);\n-        System.out.println(\"Max allowed usage diff: \" + maxAllowedUsageDiff);\n-\n-        if (memoryUsageDiff > maxAllowedUsageDiff\n-                && otherThreadsAllocatedMemory) {\n-            System.out.println(\"Memory usage diff is incorrect, but it seems \"\n-                    + \"like someone else allocated objects\");\n-            return;\n-        }\n-\n-        Asserts.assertLTE(memoryUsageDiff, maxAllowedUsageDiff,\n-                \"Actual memory usage should not deviate from expected for \" +\n-                        \"more then \" + maxAllowedUsageDiff);\n-    }\n-\n-    \/**\n-     * Baselines amount of memory allocated by each thread.\n-     *\/\n-    public void baselineMemoryAllocation() {\n-        ThreadMXBean bean = (ThreadMXBean) ManagementFactory.getThreadMXBean();\n-        threadIds = bean.getAllThreadIds();\n-        baselinedThreadMemoryUsage = bean.getThreadAllocatedBytes(threadIds);\n-    }\n-\n-    \/**\n-     * Checks if threads other then the current thread were allocating objects\n-     * after baselinedThreadMemoryUsage call.\n-     *\n-     * If baselinedThreadMemoryUsage was not called, then this method will return\n-     * {@code false}.\n-     *\/\n-    public boolean areOtherThreadsAllocatedMemory() {\n-        if (baselinedThreadMemoryUsage == null) {\n-            return false;\n-        }\n-\n-        ThreadMXBean bean = (ThreadMXBean) ManagementFactory.getThreadMXBean();\n-        long currentMemoryAllocation[]\n-                = bean.getThreadAllocatedBytes(threadIds);\n-        boolean otherThreadsAllocatedMemory = false;\n-\n-        System.out.println(\"Verifying amount of memory allocated by threads:\");\n-        for (int i = 0; i < threadIds.length; i++) {\n-            System.out.format(\"Thread %d%nbaseline allocation: %d\"\n-                            + \"%ncurrent allocation:%d%n\", threadIds[i],\n-                    baselinedThreadMemoryUsage[i], currentMemoryAllocation[i]);\n-            System.out.println(bean.getThreadInfo(threadIds[i]));\n-\n-            long bytesAllocated = Math.abs(currentMemoryAllocation[i]\n-                    - baselinedThreadMemoryUsage[i]);\n-            if (bytesAllocated > 0\n-                    && threadIds[i] != Thread.currentThread().getId()) {\n-                otherThreadsAllocatedMemory = true;\n-            }\n-        }\n-\n-        return otherThreadsAllocatedMemory;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        StringBuilder builder = new StringBuilder();\n-\n-        builder.append(String.format(\"SurvivorAlignmentTestMain info:%n\"));\n-        builder.append(String.format(\"Desired object size: %d%n\", objectSize));\n-        builder.append(String.format(\"Memory to fill: %d%n\", memoryToFill));\n-        builder.append(String.format(\"Objects to be allocated: %d%n\",\n-                garbage.length));\n-\n-        builder.append(String.format(\"Alignment helpers to be used: %n\"));\n-        for (HeapSpace heapSpace: HeapSpace.values()) {\n-            builder.append(String.format(\"For space %s:%n%s%n\", heapSpace,\n-                    getAlignmentHelper(heapSpace)));\n-        }\n-\n-        return builder.toString();\n-    }\n-\n-    \/**\n-     * Returns {@code AlignmentHelper} for a space {@code heapSpace}.\n-     *\/\n-    public static AlignmentHelper getAlignmentHelper(HeapSpace heapSpace) {\n-        switch (heapSpace) {\n-            case EDEN:\n-                return SurvivorAlignmentTestMain.EDEN_SPACE_HELPER;\n-            case SURVIVOR:\n-                return SurvivorAlignmentTestMain.SURVIVOR_SPACE_HELPER;\n-            case TENURED:\n-                return SurvivorAlignmentTestMain.TENURED_SPACE_HELPER;\n-            default:\n-                throw new Error(\"Unexpected heap space: \" + heapSpace);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/survivorAlignment\/SurvivorAlignmentTestMain.java","additions":0,"deletions":395,"binary":false,"changes":395,"status":"deleted"},{"patch":"@@ -1,95 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.survivorAlignment;\n-\n-\/**\n- * @test gc.survivorAlignment.TestAllocationInEden\n- * @bug 8031323\n- * @summary Verify that object's alignment in eden space is not affected by\n- *          SurvivorAlignmentInBytes option.\n- * @requires vm.gc != \"Z\" & vm.gc != \"Shenandoah\"\n- * @library \/test\/lib\n- * @library \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @build sun.hotspot.WhiteBox\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=64m -XX:MaxNewSize=64m\n- *                   -XX:SurvivorRatio=1 -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=32 -XX:-UseTLAB -XX:-ResizePLAB\n- *                   -XX:OldSize=128m -XX:MaxHeapSize=192m\n- *                   -XX:-ExplicitGCInvokesConcurrent\n- *                   gc.survivorAlignment.TestAllocationInEden 10m 9 EDEN\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=64m -XX:MaxNewSize=64m\n- *                   -XX:SurvivorRatio=1 -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=32 -XX:-UseTLAB -XX:-ResizePLAB\n- *                   -XX:OldSize=128m -XX:MaxHeapSize=192m\n- *                   -XX:-ExplicitGCInvokesConcurrent\n- *                   gc.survivorAlignment.TestAllocationInEden 10m 47 EDEN\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=64m -XX:MaxNewSize=64m\n- *                   -XX:SurvivorRatio=1 -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=64 -XX:-UseTLAB -XX:-ResizePLAB\n- *                   -XX:OldSize=128m  -XX:MaxHeapSize=192m\n- *                   -XX:-ExplicitGCInvokesConcurrent\n- *                   gc.survivorAlignment.TestAllocationInEden 10m 9 EDEN\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=64m -XX:MaxNewSize=64m\n- *                   -XX:SurvivorRatio=1 -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=64 -XX:-UseTLAB -XX:-ResizePLAB\n- *                   -XX:OldSize=128m  -XX:MaxHeapSize=192m\n- *                   -XX:-ExplicitGCInvokesConcurrent\n- *                   gc.survivorAlignment.TestAllocationInEden 10m 87 EDEN\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=64m -XX:MaxNewSize=64m\n- *                   -XX:SurvivorRatio=1 -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=128 -XX:-UseTLAB -XX:-ResizePLAB\n- *                   -XX:OldSize=128m -XX:MaxHeapSize=192m\n- *                   -XX:-ExplicitGCInvokesConcurrent\n- *                   gc.survivorAlignment.TestAllocationInEden 10m 9 EDEN\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=64m -XX:MaxNewSize=64m\n- *                   -XX:SurvivorRatio=1 -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=128 -XX:-UseTLAB -XX:-ResizePLAB\n- *                   -XX:OldSize=128m -XX:MaxHeapSize=192m\n- *                   -XX:-ExplicitGCInvokesConcurrent\n- *                   gc.survivorAlignment.TestAllocationInEden 10m 147 EDEN\n- *\/\n-public class TestAllocationInEden {\n-    public static void main(String args[]) {\n-        SurvivorAlignmentTestMain test\n-                = SurvivorAlignmentTestMain.fromArgs(args);\n-        System.out.println(test);\n-\n-        long expectedMemoryUsage = test.getExpectedMemoryUsage();\n-        test.baselineMemoryAllocation();\n-        System.gc();\n-\n-        test.allocate();\n-\n-        test.verifyMemoryUsage(expectedMemoryUsage);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/survivorAlignment\/TestAllocationInEden.java","additions":0,"deletions":95,"binary":false,"changes":95,"status":"deleted"},{"patch":"@@ -1,100 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.survivorAlignment;\n-\n-\/**\n- * @test gc.survivorAlignment.TestPromotionFromEdenToTenured\n- * @bug 8031323\n- * @summary Verify that objects promoted from eden space to tenured space during\n- *          full GC are not aligned to SurvivorAlignmentInBytes value.\n- * @requires vm.gc != \"Z\" & vm.gc != \"Shenandoah\"\n- * @library \/test\/lib\n- * @library \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @build sun.hotspot.WhiteBox\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=64m -XX:MaxNewSize=64m\n- *                   -XX:OldSize=32m -XX:MaxHeapSize=96m -XX:SurvivorRatio=1\n- *                   -XX:-ExplicitGCInvokesConcurrent -XX:-ResizePLAB\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=32\n- *                   gc.survivorAlignment.TestPromotionFromEdenToTenured 10m 9 TENURED\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=64m -XX:MaxNewSize=64m\n- *                   -XX:OldSize=32m -XX:MaxHeapSize=96m -XX:SurvivorRatio=1\n- *                   -XX:-ExplicitGCInvokesConcurrent -XX:-ResizePLAB\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=32\n- *                   gc.survivorAlignment.TestPromotionFromEdenToTenured 10m 47 TENURED\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=64m -XX:MaxNewSize=64m\n- *                   -XX:OldSize=32m  -XX:MaxHeapSize=96m\n- *                   -XX:SurvivorRatio=1 -XX:-ExplicitGCInvokesConcurrent -XX:-ResizePLAB\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=64\n- *                   gc.survivorAlignment.TestPromotionFromEdenToTenured 10m 9 TENURED\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=64m -XX:MaxNewSize=64m\n- *                   -XX:OldSize=32m -XX:MaxHeapSize=128m\n- *                   -XX:SurvivorRatio=1 -XX:-ExplicitGCInvokesConcurrent -XX:-ResizePLAB\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=64\n- *                   gc.survivorAlignment.TestPromotionFromEdenToTenured 10m 87 TENURED\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=64m -XX:MaxNewSize=64m\n- *                   -XX:OldSize=32M -XX:MaxHeapSize=96m -XX:SurvivorRatio=1\n- *                   -XX:-ExplicitGCInvokesConcurrent -XX:-ResizePLAB\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=128\n- *                   gc.survivorAlignment.TestPromotionFromEdenToTenured 10m 9 TENURED\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=64m -XX:MaxNewSize=64m\n- *                   -XX:OldSize=32m -XX:MaxHeapSize=96m -XX:SurvivorRatio=1\n- *                   -XX:-ExplicitGCInvokesConcurrent -XX:-ResizePLAB\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=128\n- *                   gc.survivorAlignment.TestPromotionFromEdenToTenured 10m 147 TENURED\n- *\/\n-public class TestPromotionFromEdenToTenured {\n-    public static void main(String args[]) {\n-        SurvivorAlignmentTestMain test\n-                = SurvivorAlignmentTestMain.fromArgs(args);\n-        System.out.println(test);\n-\n-        long expectedMemoryUsage = test.getExpectedMemoryUsage();\n-        test.baselineMemoryAllocation();\n-        System.gc();\n-        \/\/ increase expected usage by current old gen usage\n-        expectedMemoryUsage += SurvivorAlignmentTestMain.getAlignmentHelper(\n-                SurvivorAlignmentTestMain.HeapSpace.TENURED)\n-                .getActualMemoryUsage();\n-\n-        test.allocate();\n-        System.gc();\n-\n-        test.verifyMemoryUsage(expectedMemoryUsage);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/survivorAlignment\/TestPromotionFromEdenToTenured.java","additions":0,"deletions":100,"binary":false,"changes":100,"status":"deleted"},{"patch":"@@ -1,105 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.survivorAlignment;\n-\n-\/**\n- * @test gc.survivorAlignment.TestPromotionFromSurvivorToTenuredAfterFullGC\n- * @bug 8031323\n- * @summary Verify that objects promoted from survivor space to tenured space\n- *          during full GC are not aligned to SurvivorAlignmentInBytes value.\n- * @requires vm.gc != \"Z\" & vm.gc != \"Shenandoah\"\n- * @library \/test\/lib\n- * @library \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @build sun.hotspot.WhiteBox\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=128m -XX:MaxNewSize=128m\n- *                   -XX:OldSize=32m -XX:MaxHeapSize=160m\n- *                   -XX:SurvivorRatio=1 -XX:-ExplicitGCInvokesConcurrent -XX:-ResizePLAB\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=32\n- *                   gc.survivorAlignment.TestPromotionFromSurvivorToTenuredAfterFullGC 10m 9 TENURED\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=128m -XX:MaxNewSize=128m\n- *                   -XX:OldSize=32m -XX:MaxHeapSize=160m -XX:-ResizePLAB\n- *                   -XX:SurvivorRatio=1 -XX:-ExplicitGCInvokesConcurrent\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=32\n- *                   gc.survivorAlignment.TestPromotionFromSurvivorToTenuredAfterFullGC 20m 47\n- *                   TENURED\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=200m -XX:MaxNewSize=200m\n- *                   -XX:OldSize=32m -XX:MaxHeapSize=232m\n- *                   -XX:SurvivorRatio=1 -XX:-ExplicitGCInvokesConcurrent -XX:-ResizePLAB\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=64\n- *                   gc.survivorAlignment.TestPromotionFromSurvivorToTenuredAfterFullGC 10m 9 TENURED\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=128m -XX:MaxNewSize=128m\n- *                   -XX:OldSize=32m -XX:MaxHeapSize=160m\n- *                   -XX:SurvivorRatio=1 -XX:-ExplicitGCInvokesConcurrent -XX:-ResizePLAB\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=64\n- *                   gc.survivorAlignment.TestPromotionFromSurvivorToTenuredAfterFullGC 20m 87\n- *                   TENURED\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=256m -XX:MaxNewSize=256m\n- *                   -XX:OldSize=32M -XX:MaxHeapSize=288m\n- *                   -XX:SurvivorRatio=1 -XX:-ExplicitGCInvokesConcurrent -XX:-ResizePLAB\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=128\n- *                    gc.survivorAlignment.TestPromotionFromSurvivorToTenuredAfterFullGC 10m 9\n- *                    TENURED\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=128m -XX:MaxNewSize=128m\n- *                   -XX:OldSize=32m -XX:MaxHeapSize=160m\n- *                   -XX:SurvivorRatio=1 -XX:-ExplicitGCInvokesConcurrent -XX:-ResizePLAB\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=128\n- *                   gc.survivorAlignment.TestPromotionFromSurvivorToTenuredAfterFullGC 20m 147\n- *                   TENURED\n- *\/\n-public class TestPromotionFromSurvivorToTenuredAfterFullGC {\n-    public static void main(String args[]) {\n-        SurvivorAlignmentTestMain test\n-                = SurvivorAlignmentTestMain.fromArgs(args);\n-        System.out.println(test);\n-\n-        long expectedMemoryUsage = test.getExpectedMemoryUsage();\n-        test.baselineMemoryAllocation();\n-        System.gc();\n-        \/\/ increase expected usage by current old gen usage\n-        expectedMemoryUsage += SurvivorAlignmentTestMain.getAlignmentHelper(\n-                SurvivorAlignmentTestMain.HeapSpace.TENURED)\n-                .getActualMemoryUsage();\n-\n-        test.allocate();\n-        SurvivorAlignmentTestMain.WHITE_BOX.youngGC();\n-        System.gc();\n-\n-        test.verifyMemoryUsage(expectedMemoryUsage);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/survivorAlignment\/TestPromotionFromSurvivorToTenuredAfterFullGC.java","additions":0,"deletions":105,"binary":false,"changes":105,"status":"deleted"},{"patch":"@@ -1,117 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.survivorAlignment;\n-\n-\/**\n- * @test gc.survivorAlignment.TestPromotionFromSurvivorToTenuredAfterMinorGC\n- * @bug 8031323\n- * @summary Verify that objects promoted from survivor space to tenured space\n- *          when their age exceeded tenuring threshold are not aligned to\n- *          SurvivorAlignmentInBytes value.\n- * @requires vm.gc != \"Z\" & vm.gc != \"Shenandoah\"\n- * @library \/test\/lib\n- * @library \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @build sun.hotspot.WhiteBox\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=128m -XX:MaxNewSize=128m\n- *                   -XX:OldSize=32M -XX:MaxHeapSize=160m -XX:SurvivorRatio=1 -XX:-ResizePLAB\n- *                   -XX:-ExplicitGCInvokesConcurrent\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=32\n- *                   gc.survivorAlignment.TestPromotionFromSurvivorToTenuredAfterMinorGC 10m 9\n- *                   TENURED\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=128m -XX:MaxNewSize=128m\n- *                   -XX:OldSize=32M -XX:MaxHeapSize=160m -XX:SurvivorRatio=1 -XX:-ResizePLAB\n- *                   -XX:-ExplicitGCInvokesConcurrent\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=32\n- *                   gc.survivorAlignment.TestPromotionFromSurvivorToTenuredAfterMinorGC 20m 47\n- *                   TENURED\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=200m -XX:MaxNewSize=200m\n- *                   -XX:OldSize=32M -XX:MaxHeapSize=232m -XX:SurvivorRatio=1 -XX:-ResizePLAB\n- *                   -XX:-ExplicitGCInvokesConcurrent\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=64\n- *                   gc.survivorAlignment.TestPromotionFromSurvivorToTenuredAfterMinorGC 10m 9\n- *                   TENURED\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=128m -XX:MaxNewSize=128m\n- *                   -XX:OldSize=32M -XX:MaxHeapSize=160m -XX:SurvivorRatio=1 -XX:-ResizePLAB\n- *                   -XX:-ExplicitGCInvokesConcurrent\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=64\n- *                   gc.survivorAlignment.TestPromotionFromSurvivorToTenuredAfterMinorGC 20m 87\n- *                   TENURED\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=256m -XX:MaxNewSize=256m\n- *                   -XX:OldSize=32M -XX:MaxHeapSize=288m -XX:SurvivorRatio=1 -XX:-ResizePLAB\n- *                   -XX:-ExplicitGCInvokesConcurrent\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=128\n- *                    gc.survivorAlignment.TestPromotionFromSurvivorToTenuredAfterMinorGC 10m 9\n- *                    TENURED\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=128m -XX:MaxNewSize=128m\n- *                   -XX:OldSize=32M -XX:MaxHeapSize=160m -XX:SurvivorRatio=1 -XX:-ResizePLAB\n- *                   -XX:-ExplicitGCInvokesConcurrent\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=128\n- *                   gc.survivorAlignment.TestPromotionFromSurvivorToTenuredAfterMinorGC 20m 147\n- *                   TENURED\n- *\/\n-public class TestPromotionFromSurvivorToTenuredAfterMinorGC {\n-    public static void main(String args[]) throws Exception {\n-        SurvivorAlignmentTestMain test\n-                = SurvivorAlignmentTestMain.fromArgs(args);\n-        System.out.println(test);\n-\n-        long expectedMemoryUsage = test.getExpectedMemoryUsage();\n-        test.baselineMemoryAllocation();\n-        SurvivorAlignmentTestMain.WHITE_BOX.fullGC();\n-        \/\/ increase expected usage by current old gen usage\n-        expectedMemoryUsage += SurvivorAlignmentTestMain.getAlignmentHelper(\n-                SurvivorAlignmentTestMain.HeapSpace.TENURED)\n-                .getActualMemoryUsage();\n-\n-        test.allocate();\n-        for (int i = 0; i <= SurvivorAlignmentTestMain.MAX_TENURING_THRESHOLD; i++) {\n-            SurvivorAlignmentTestMain.WHITE_BOX.youngGC();\n-        }\n-\n-        \/\/ Sometimes we see that data unrelated to the test has been allocated during\n-        \/\/ the loop. This data is included in the expectedMemoryUsage since we look\n-        \/\/ through all threads to see what they allocated. If this data is still in\n-        \/\/ the survivor area however, it should not be included in expectedMemoryUsage\n-        \/\/ since the verification below only look at what's in tenured space.\n-        expectedMemoryUsage -= SurvivorAlignmentTestMain.getAlignmentHelper(\n-                                   SurvivorAlignmentTestMain.HeapSpace.SURVIVOR)\n-                                   .getActualMemoryUsage();\n-        test.verifyMemoryUsage(expectedMemoryUsage);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/survivorAlignment\/TestPromotionFromSurvivorToTenuredAfterMinorGC.java","additions":0,"deletions":117,"binary":false,"changes":117,"status":"deleted"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.survivorAlignment;\n-\n-\/**\n- * @test gc.survivorAlignment.TestPromotionLABLargeSurvivorAlignment\n- * @bug 8060463\n- * @summary Verify that objects promoted from eden space to survivor space\n- *          with large values for SurvivorAlignmentInBytes succeed.\n- * @requires vm.opt.ExplicitGCInvokesConcurrent != true\n- * @run main\/othervm -Xmx128m\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=8 -XX:SurvivorRatio=1\n- *                   -XX:-ExplicitGCInvokesConcurrent -XX:-ResizePLAB\n- *                   gc.survivorAlignment.TestPromotionLABLargeSurvivorAlignment\n- * @run main\/othervm -Xmx128m\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=16 -XX:SurvivorRatio=1\n- *                   -XX:-ExplicitGCInvokesConcurrent -XX:-ResizePLAB\n- *                   gc.survivorAlignment.TestPromotionLABLargeSurvivorAlignment\n- * @run main\/othervm -Xmx128m\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=256 -XX:SurvivorRatio=1\n- *                   -XX:-ExplicitGCInvokesConcurrent -XX:-ResizePLAB\n- *                   gc.survivorAlignment.TestPromotionLABLargeSurvivorAlignment\n- *\/\n-public class TestPromotionLABLargeSurvivorAlignment {\n-    public static void main(String args[]) {\n-        Object garbage[] = new Object[1000000];\n-        for (int i = 0; i < garbage.length; i++) {\n-            garbage[i] = new byte[0];\n-        }\n-        for (int i = 0; i < 2; i++) {\n-            System.gc();\n-        }\n-    }\n-}\n-\n","filename":"test\/hotspot\/jtreg\/gc\/survivorAlignment\/TestPromotionLABLargeSurvivorAlignment.java","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"},{"patch":"@@ -1,90 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.survivorAlignment;\n-\n-\/**\n- * @test gc.survivorAlignment.TestPromotionToSurvivor\n- * @bug 8031323\n- * @summary Verify that objects promoted from eden space to survivor space after\n- *          minor GC are aligned to SurvivorAlignmentInBytes.\n- * @requires vm.gc != \"Z\" & vm.gc != \"Shenandoah\"\n- * @library \/test\/lib\n- * @library \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @build sun.hotspot.WhiteBox\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=128m -XX:MaxNewSize=128m\n- *                   -XX:SurvivorRatio=1 -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=32 -XX:OldSize=128m\n- *                   -XX:MaxHeapSize=256m -XX:-ExplicitGCInvokesConcurrent -XX:-ResizePLAB\n- *                   gc.survivorAlignment.TestPromotionToSurvivor 10m 9 SURVIVOR\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=128m -XX:MaxNewSize=128m\n- *                   -XX:SurvivorRatio=1 -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=32 -XX:OldSize=128m\n- *                   -XX:MaxHeapSize=256m -XX:-ExplicitGCInvokesConcurrent -XX:-ResizePLAB\n- *                   gc.survivorAlignment.TestPromotionToSurvivor 20m 47 SURVIVOR\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=128m -XX:MaxNewSize=128m\n- *                   -XX:SurvivorRatio=1 -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=64 -XX:OldSize=128m\n- *                   -XX:MaxHeapSize=256m -XX:-ExplicitGCInvokesConcurrent -XX:-ResizePLAB\n- *                   gc.survivorAlignment.TestPromotionToSurvivor 8m 9 SURVIVOR\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=128m -XX:MaxNewSize=128m\n- *                   -XX:SurvivorRatio=1 -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=64 -XX:OldSize=128m\n- *                   -XX:MaxHeapSize=256m -XX:-ExplicitGCInvokesConcurrent -XX:-ResizePLAB\n- *                   gc.survivorAlignment.TestPromotionToSurvivor 20m 87 SURVIVOR\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=256m -XX:MaxNewSize=256m\n- *                   -XX:SurvivorRatio=1 -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=128 -XX:OldSize=128m\n- *                   -XX:MaxHeapSize=384m  -XX:-ExplicitGCInvokesConcurrent -XX:-ResizePLAB\n- *                   gc.survivorAlignment.TestPromotionToSurvivor 10m 9 SURVIVOR\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=128m -XX:MaxNewSize=128m\n- *                   -XX:SurvivorRatio=1 -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=128 -XX:OldSize=128m\n- *                   -XX:MaxHeapSize=256m -XX:-ExplicitGCInvokesConcurrent -XX:-ResizePLAB\n- *                   gc.survivorAlignment.TestPromotionToSurvivor 20m 147 SURVIVOR\n- *\/\n-public class TestPromotionToSurvivor {\n-    public static void main(String args[]) {\n-        SurvivorAlignmentTestMain test\n-                = SurvivorAlignmentTestMain.fromArgs(args);\n-        System.out.println(test);\n-\n-        long expectedUsage = test.getExpectedMemoryUsage();\n-        test.baselineMemoryAllocation();\n-        SurvivorAlignmentTestMain.WHITE_BOX.fullGC();\n-\n-        test.allocate();\n-        SurvivorAlignmentTestMain.WHITE_BOX.youngGC();\n-\n-        test.verifyMemoryUsage(expectedUsage);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/survivorAlignment\/TestPromotionToSurvivor.java","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -90,0 +90,1 @@\n+ * @requires vm.bits == 64\n","filename":"test\/hotspot\/jtreg\/gtest\/MetaspaceGtests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @key stress\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/ThreadCountLimit.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8246774\n@@ -32,3 +33,2 @@\n- * @compile --enable-preview -source ${jdk.version} RedefineRecord.java\n- * @run main\/othervm --enable-preview RedefineRecord buildagent\n- * @run main\/othervm\/timeout=6000 --enable-preview RedefineRecord runtest\n+ * @run main RedefineRecord buildagent\n+ * @run main\/othervm\/timeout=6000 RedefineRecord runtest\n@@ -103,1 +103,0 @@\n-                \"--enable-preview\",\n","filename":"test\/hotspot\/jtreg\/runtime\/records\/RedefineRecord.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,2 @@\n-\/\/ This test is a Record marked as abstract.  It should result in a\n-\/\/ ClassFormatError exception.\n+\/\/ This test is a Record marked as abstract.  Loading this class should\n+\/\/ not cause a ClassFormatError exception.\n@@ -31,1 +31,1 @@\n-  65535; \/\/ minor version\n+  0; \/\/ minor version\n","filename":"test\/hotspot\/jtreg\/runtime\/records\/abstractRecord.jcod","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-  65535; \/\/ minor version\n+  0; \/\/ minor version\n","filename":"test\/hotspot\/jtreg\/runtime\/records\/badRecordAttribute.jcod","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary test logging of reasons for ignoring Record attribute\n- * @library \/test\/lib\n- * @compile superNotJLRecord.jcod recordIgnoredVersion.jcod\n- * @run driver ignoreRecordAttribute\n- *\/\n-\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-public class ignoreRecordAttribute {\n-\n-    public static void main(String[] args) throws Exception {\n-        String MAJOR_VERSION = Integer.toString(44 + Runtime.version().feature());\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\"--enable-preview\",\n-            \"-Xlog:class+record\", \"-Xshare:off\", \"superNotJLRecord\");\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-        output.shouldContain(\"Ignoring Record attribute\");\n-        output.shouldContain(\"because super type is not java.lang.Record\");\n-\n-        pb = ProcessTools.createJavaProcessBuilder(\"--enable-preview\",\n-            \"-Xlog:class+record\", \"-Xshare:off\", \"recordIgnoredVersion\");\n-        output = new OutputAnalyzer(pb.start());\n-        output.shouldContain(\"Ignoring Record attribute\");\n-        output.shouldContain(\"because class file version is not \" + MAJOR_VERSION + \".65535\");\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/records\/ignoreRecordAttribute.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -27,2 +27,2 @@\n-\/\/ This test is a Record but not marked final.  It should result in a\n-\/\/ ClassFormatError exception.\n+\/\/ This test is a Record but not marked final.  Loading this class should\n+\/\/ not cause a ClassFormatError exception.\n@@ -31,1 +31,1 @@\n-  65535; \/\/ minor version\n+  0; \/\/ minor version\n","filename":"test\/hotspot\/jtreg\/runtime\/records\/notFinalRecord.jcod","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8246774\n@@ -28,2 +29,1 @@\n- *\n- * @run main\/othervm --enable-preview recordAttributeTest\n+ * @run main recordAttributeTest\n@@ -40,1 +40,1 @@\n-            throw new RuntimeException(\"Expected ClasFormatError exception not thrown\");\n+            throw new RuntimeException(\"Expected ClassFormatError exception not thrown\");\n@@ -57,3 +57,2 @@\n-        \/\/ Test loading a Record type marked abstract. This should throw ClassFormatError.\n-        runTest(\"abstractRecord\",\n-                \"Record attribute in non-final or abstract class\");\n+        \/\/ Test loading a Record type marked abstract. This should not throw ClassFormatError.\n+        Class abstractClass = Class.forName(\"abstractRecord\");\n@@ -61,3 +60,2 @@\n-        \/\/ Test loading a Record type that is not final. This should throw ClassFormatError.\n-        runTest(\"notFinalRecord\",\n-                \"Record attribute in non-final or abstract class\");\n+        \/\/ Test loading a Record type that is not final. This should not throw ClassFormatError.\n+        Class notFinalClass = Class.forName(\"notFinalRecord\");\n@@ -76,3 +74,8 @@\n-        \/\/ Test that loading a class whose super class is not java.lang.Record\n-        \/\/ ignores a badly formed Record attribute. No exception should be thrown.\n-        newClass = Class.forName(\"superNotJLRecord\");\n+        \/\/ Test that loading a class containing an ill-formed Record attribute causes a\n+        \/\/ ClassFormatError exception even though its super class is not java.lang.Record.\n+        runTest(\"superNotJLRecord\", \"Truncated class file\");\n+\n+        \/\/ Test that loading a class that contains a properly formed Record attribute\n+        \/\/ does not cause a ClassFormatError exception even though its super class is not\n+        \/\/ java.lang.Record.\n+        Class superNoJLRClass = Class.forName(\"superNotJLRecordOK\");\n","filename":"test\/hotspot\/jtreg\/runtime\/records\/recordAttributeTest.java","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1,256 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ Record attribute is ignored because class file minor version is 0.\n-class recordIgnoredVersion {\n-  0xCAFEBABE;\n-  0; \/\/ minor version\n-  60; \/\/ version\n-  [52] { \/\/ Constant Pool\n-    ; \/\/ first element is empty\n-    Method #2 #3; \/\/ #1     at 0x0A\n-    class #4; \/\/ #2     at 0x0F\n-    NameAndType #5 #6; \/\/ #3     at 0x12\n-    Utf8 \"java\/lang\/Record\"; \/\/ #4     at 0x17\n-    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n-    Utf8 \"()V\"; \/\/ #6     at 0x33\n-    Field #8 #9; \/\/ #7     at 0x39\n-    class #10; \/\/ #8     at 0x3E\n-    NameAndType #11 #12; \/\/ #9     at 0x41\n-    Utf8 \"recordIgnoredVersion\"; \/\/ #10     at 0x46\n-    Utf8 \"x\"; \/\/ #11     at 0x56\n-    Utf8 \"I\"; \/\/ #12     at 0x5A\n-    Field #8 #9; \/\/ #13     at 0x5E\n-    InvokeDynamic 0s #15; \/\/ #14     at 0x63\n-    NameAndType #16 #17; \/\/ #15     at 0x68\n-    Utf8 \"toString\"; \/\/ #16     at 0x6D\n-    Utf8 \"(LrecordIgnoredVersion;)Ljava\/lang\/String;\"; \/\/ #17     at 0x78\n-    InvokeDynamic 0s #19; \/\/ #18     at 0x9E\n-    NameAndType #20 #21; \/\/ #19     at 0xA3\n-    Utf8 \"hashCode\"; \/\/ #20     at 0xA8\n-    Utf8 \"(LrecordIgnoredVersion;)I\"; \/\/ #21     at 0xB3\n-    InvokeDynamic 0s #23; \/\/ #22     at 0xC8\n-    NameAndType #24 #25; \/\/ #23     at 0xCD\n-    Utf8 \"equals\"; \/\/ #24     at 0xD2\n-    Utf8 \"(LrecordIgnoredVersion;Ljava\/lang\/Object;)Z\"; \/\/ #25     at 0xDB\n-    Utf8 \"(I)V\"; \/\/ #26     at 0x0102\n-    Utf8 \"Code\"; \/\/ #27     at 0x0109\n-    Utf8 \"LineNumberTable\"; \/\/ #28     at 0x0110\n-    Utf8 \"MethodParameters\"; \/\/ #29     at 0x0122\n-    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #30     at 0x0135\n-    Utf8 \"()I\"; \/\/ #31     at 0x014C\n-    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #32     at 0x0152\n-    Utf8 \"SourceFile\"; \/\/ #33     at 0x016A\n-    Utf8 \"recordIgnoredVersion.java\"; \/\/ #34     at 0x0177\n-    Utf8 \"Record\"; \/\/ #35     at 0x018C\n-    Utf8 \"BootstrapMethods\"; \/\/ #36     at 0x0195\n-    MethodHandle 6b #38; \/\/ #37     at 0x01A8\n-    Method #39 #40; \/\/ #38     at 0x01AC\n-    class #41; \/\/ #39     at 0x01B1\n-    NameAndType #42 #43; \/\/ #40     at 0x01B4\n-    Utf8 \"java\/lang\/runtime\/ObjectMethods\"; \/\/ #41     at 0x01B9\n-    Utf8 \"bootstrap\"; \/\/ #42     at 0x01DB\n-    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/TypeDescriptor;Ljava\/lang\/Class;Ljava\/lang\/String;[Ljava\/lang\/invoke\/MethodHandle;)Ljava\/lang\/Object;\"; \/\/ #43     at 0x01E7\n-    String #11; \/\/ #44     at 0x029B\n-    MethodHandle 1b #7; \/\/ #45     at 0x029E\n-    Utf8 \"InnerClasses\"; \/\/ #46     at 0x02A2\n-    class #48; \/\/ #47     at 0x02B1\n-    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #48     at 0x02B4\n-    class #50; \/\/ #49     at 0x02DC\n-    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #50     at 0x02DF\n-    Utf8 \"Lookup\"; \/\/ #51     at 0x0300\n-  } \/\/ Constant Pool\n-\n-  0x0030; \/\/ access [ ACC_SUPER ACC_FINAL ]\n-  #8;\/\/ this_cpx\n-  #2;\/\/ super_cpx\n-\n-  [0] { \/\/ Interfaces\n-  } \/\/ Interfaces\n-\n-  [1] { \/\/ fields\n-    { \/\/ Member at 0x0313\n-      0x8012; \/\/ access\n-      #11; \/\/ name_cpx\n-      #12; \/\/ sig_cpx\n-      [0] { \/\/ Attributes\n-      } \/\/ Attributes\n-    } \/\/ Member\n-  } \/\/ fields\n-\n-  [5] { \/\/ methods\n-    { \/\/ Member at 0x031D\n-      0x0001; \/\/ access\n-      #5; \/\/ name_cpx\n-      #26; \/\/ sig_cpx\n-      [2] { \/\/ Attributes\n-        Attr(#27, 34) { \/\/ Code at 0x0325\n-          2; \/\/ max_stack\n-          2; \/\/ max_locals\n-          Bytes[10]{\n-            0x2AB700012A1BB500;\n-            0x07B1;\n-          }\n-          [0] { \/\/ Traps\n-          } \/\/ end Traps\n-          [1] { \/\/ Attributes\n-            Attr(#28, 6) { \/\/ LineNumberTable at 0x0341\n-              [1] { \/\/ LineNumberTable\n-                0  1; \/\/  at 0x034D\n-              }\n-            } \/\/ end LineNumberTable\n-          } \/\/ Attributes\n-        } \/\/ end Code\n-        ;\n-        Attr(#29, 5) { \/\/ MethodParameters at 0x034D\n-          0x01000B8000;\n-        } \/\/ end MethodParameters\n-      } \/\/ Attributes\n-    } \/\/ Member\n-    ;\n-    { \/\/ Member at 0x0358\n-      0x8001; \/\/ access\n-      #16; \/\/ name_cpx\n-      #30; \/\/ sig_cpx\n-      [1] { \/\/ Attributes\n-        Attr(#27, 31) { \/\/ Code at 0x0360\n-          1; \/\/ max_stack\n-          1; \/\/ max_locals\n-          Bytes[7]{\n-            0x2ABA000E0000B0;\n-          }\n-          [0] { \/\/ Traps\n-          } \/\/ end Traps\n-          [1] { \/\/ Attributes\n-            Attr(#28, 6) { \/\/ LineNumberTable at 0x0379\n-              [1] { \/\/ LineNumberTable\n-                0  1; \/\/  at 0x0385\n-              }\n-            } \/\/ end LineNumberTable\n-          } \/\/ Attributes\n-        } \/\/ end Code\n-      } \/\/ Attributes\n-    } \/\/ Member\n-    ;\n-    { \/\/ Member at 0x0385\n-      0x8011; \/\/ access\n-      #20; \/\/ name_cpx\n-      #31; \/\/ sig_cpx\n-      [1] { \/\/ Attributes\n-        Attr(#27, 31) { \/\/ Code at 0x038D\n-          1; \/\/ max_stack\n-          1; \/\/ max_locals\n-          Bytes[7]{\n-            0x2ABA00120000AC;\n-          }\n-          [0] { \/\/ Traps\n-          } \/\/ end Traps\n-          [1] { \/\/ Attributes\n-            Attr(#28, 6) { \/\/ LineNumberTable at 0x03A6\n-              [1] { \/\/ LineNumberTable\n-                0  1; \/\/  at 0x03B2\n-              }\n-            } \/\/ end LineNumberTable\n-          } \/\/ Attributes\n-        } \/\/ end Code\n-      } \/\/ Attributes\n-    } \/\/ Member\n-    ;\n-    { \/\/ Member at 0x03B2\n-      0x8011; \/\/ access\n-      #24; \/\/ name_cpx\n-      #32; \/\/ sig_cpx\n-      [1] { \/\/ Attributes\n-        Attr(#27, 32) { \/\/ Code at 0x03BA\n-          2; \/\/ max_stack\n-          2; \/\/ max_locals\n-          Bytes[8]{\n-            0x2A2BBA00160000AC;\n-          }\n-          [0] { \/\/ Traps\n-          } \/\/ end Traps\n-          [1] { \/\/ Attributes\n-            Attr(#28, 6) { \/\/ LineNumberTable at 0x03D4\n-              [1] { \/\/ LineNumberTable\n-                0  1; \/\/  at 0x03E0\n-              }\n-            } \/\/ end LineNumberTable\n-          } \/\/ Attributes\n-        } \/\/ end Code\n-      } \/\/ Attributes\n-    } \/\/ Member\n-    ;\n-    { \/\/ Member at 0x03E0\n-      0x8001; \/\/ access\n-      #11; \/\/ name_cpx\n-      #31; \/\/ sig_cpx\n-      [1] { \/\/ Attributes\n-        Attr(#27, 29) { \/\/ Code at 0x03E8\n-          1; \/\/ max_stack\n-          1; \/\/ max_locals\n-          Bytes[5]{\n-            0x2AB4000DAC;\n-          }\n-          [0] { \/\/ Traps\n-          } \/\/ end Traps\n-          [1] { \/\/ Attributes\n-            Attr(#28, 6) { \/\/ LineNumberTable at 0x03FF\n-              [1] { \/\/ LineNumberTable\n-                0  1; \/\/  at 0x040B\n-              }\n-            } \/\/ end LineNumberTable\n-          } \/\/ Attributes\n-        } \/\/ end Code\n-      } \/\/ Attributes\n-    } \/\/ Member\n-  } \/\/ methods\n-\n-  [4] { \/\/ Attributes\n-    Attr(#33, 2) { \/\/ SourceFile at 0x040D\n-      #34;\n-    } \/\/ end SourceFile\n-    ;\n-    Attr(#35, 8) { \/\/ Record at 0x0415\n-      0x0001000B000C0000;\n-    } \/\/ end Record\n-    ;\n-    Attr(#36, 12) { \/\/ BootstrapMethods at 0x0423\n-      [1] { \/\/ bootstrap_methods\n-        {  \/\/  bootstrap_method\n-          #37; \/\/ bootstrap_method_ref\n-          [3] { \/\/ bootstrap_arguments\n-            #8; \/\/  at 0x0431\n-            #44; \/\/  at 0x0433\n-            #45; \/\/  at 0x0435\n-          }  \/\/  bootstrap_arguments\n-        }  \/\/  bootstrap_method\n-      }\n-    } \/\/ end BootstrapMethods\n-    ;\n-    Attr(#46, 10) { \/\/ InnerClasses at 0x0435\n-      [1] { \/\/ InnerClasses\n-        #47 #49 #51 25; \/\/  at 0x0445\n-      }\n-    } \/\/ end InnerClasses\n-  } \/\/ Attributes\n-} \/\/ end class recordIgnoredVersion\n","filename":"test\/hotspot\/jtreg\/runtime\/records\/recordIgnoredVersion.jcod","additions":0,"deletions":256,"binary":false,"changes":256,"status":"deleted"},{"patch":"@@ -26,2 +26,2 @@\n- * @compile --enable-preview --source ${jdk.version} recordReflectionTest.java\n- * @run main\/othervm --enable-preview recordReflectionTest\n+ * @bug 8246774\n+ * @summary testing reflection APIs for record classes\n","filename":"test\/hotspot\/jtreg\/runtime\/records\/recordReflectionTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-  65535; \/\/ minor version\n+  0; \/\/ minor version\n","filename":"test\/hotspot\/jtreg\/runtime\/records\/shortRecordAttribute.jcod","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,2 +27,3 @@\n-\/\/ This test has a Record attribute that is too short but its super class is\n-\/\/ not java.lang.Record.  So, the bogus Record attribute should be ignored.\n+\/\/ This test has a Record attribute that is too short and its super class is\n+\/\/ not java.lang.Record.  The bad Record attribute should still be detected\n+\/\/ causing a ClassFormatError exception.\n@@ -31,1 +32,1 @@\n-  65535; \/\/ minor version\n+  0; \/\/ minor version\n@@ -346,0 +347,326 @@\n+\n+\n+\n+\/\/ This test was generated from this source and then modified:\n+\/\/    record recordNames(int x, String y) {}\n+\/\/\n+\/\/ This class has a valid Record attribute but its super class is\n+\/\/ not java.lang.Record.  Loading this class should not cause a\n+\/\/ ClassFormatError exception.\n+class superNotJLRecordOK {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  60; \/\/ version\n+  [69] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #6; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    Field #8 #9; \/\/ #7     at 0x39\n+    class #10; \/\/ #8     at 0x3E\n+    NameAndType #11 #12; \/\/ #9     at 0x41\n+    Utf8 \"superNotJLRecordOK\"; \/\/ #10     at 0x46\n+    Utf8 \"x\"; \/\/ #11     at 0x56\n+    Utf8 \"I\"; \/\/ #12     at 0x5A\n+    Field #8 #14; \/\/ #13     at 0x5E\n+    NameAndType #15 #16; \/\/ #14     at 0x63\n+    Utf8 \"y\"; \/\/ #15     at 0x68\n+    Utf8 \"Ljava\/lang\/String;\"; \/\/ #16     at 0x6C\n+    InvokeDynamic 0s #18; \/\/ #17     at 0x81\n+    NameAndType #19 #20; \/\/ #18     at 0x86\n+    Utf8 \"toString\"; \/\/ #19     at 0x8B\n+    Utf8 \"(LsuperNotJLRecordOK;)Ljava\/lang\/String;\"; \/\/ #20     at 0x96\n+    InvokeDynamic 0s #22; \/\/ #21     at 0xBC\n+    NameAndType #23 #24; \/\/ #22     at 0xC1\n+    Utf8 \"hashCode\"; \/\/ #23     at 0xC6\n+    Utf8 \"(LsuperNotJLRecordOK;)I\"; \/\/ #24     at 0xD1\n+    InvokeDynamic 0s #26; \/\/ #25     at 0xE6\n+    NameAndType #27 #28; \/\/ #26     at 0xEB\n+    Utf8 \"equals\"; \/\/ #27     at 0xF0\n+    Utf8 \"(LsuperNotJLRecordOK;Ljava\/lang\/Object;)Z\"; \/\/ #28     at 0xF9\n+    Dynamic 1s #30; \/\/ #29     at 0x0120\n+    NameAndType #31 #32; \/\/ #30     at 0x0125\n+    Utf8 \"\\\\%pattern\\\\%recordExample\\\\%(ILjava\\\\|lang\\\\|String\\\\?)\"; \/\/ #31     at 0x012A\n+    Utf8 \"Ljava\/lang\/runtime\/PatternHandle;\"; \/\/ #32     at 0x015F\n+    Utf8 \"(ILjava\/lang\/String;)V\"; \/\/ #33     at 0x0183\n+    Utf8 \"Code\"; \/\/ #34     at 0x019C\n+    Utf8 \"LineNumberTable\"; \/\/ #35     at 0x01A3\n+    Utf8 \"MethodParameters\"; \/\/ #36     at 0x01B5\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #37     at 0x01C8\n+    Utf8 \"()I\"; \/\/ #38     at 0x01DF\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #39     at 0x01E5\n+    Utf8 \"()Ljava\/lang\/runtime\/PatternHandle;\"; \/\/ #40     at 0x01FD\n+    Utf8 \"SourceFile\"; \/\/ #41     at 0x0223\n+    Utf8 \"superNotJLRecordOK.java\"; \/\/ #42     at 0x0230\n+    Utf8 \"Record\"; \/\/ #43     at 0x0245\n+    Utf8 \"BootstrapMethods\"; \/\/ #44     at 0x024E\n+    MethodHandle 6b #46; \/\/ #45     at 0x0261\n+    Method #47 #48; \/\/ #46     at 0x0265\n+    class #49; \/\/ #47     at 0x026A\n+    NameAndType #50 #51; \/\/ #48     at 0x026D\n+    Utf8 \"java\/lang\/runtime\/ObjectMethods\"; \/\/ #49     at 0x0272\n+    Utf8 \"bootstrap\"; \/\/ #50     at 0x029A\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/TypeDescriptor;Ljava\/lang\/Class;Ljava\/lang\/String;[Ljava\/lang\/invoke\/MethodHandle;)Ljava\/lang\/Object;\"; \/\/ #51     at 0x02A6\n+    String #53; \/\/ #52     at 0x035A\n+    Utf8 \"x;y\"; \/\/ #53     at 0x035D\n+    MethodHandle 1b #7; \/\/ #54     at 0x0363\n+    MethodHandle 1b #13; \/\/ #55     at 0x0367\n+    MethodHandle 6b #57; \/\/ #56     at 0x036B\n+    Method #58 #59; \/\/ #57     at 0x036F\n+    class #60; \/\/ #58     at 0x0374\n+    NameAndType #61 #62; \/\/ #59     at 0x0377\n+    Utf8 \"java\/lang\/runtime\/PatternHandles\"; \/\/ #60     at 0x037C\n+    Utf8 \"ofLazyProjection\"; \/\/ #61     at 0x039F\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/Class;Ljava\/lang\/Class;[Ljava\/lang\/invoke\/MethodHandle;)Ljava\/lang\/runtime\/PatternHandle;\"; \/\/ #62     at 0x03B2\n+    Utf8 \"InnerClasses\"; \/\/ #63     at 0x0453\n+    class #65; \/\/ #64     at 0x0462\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #65     at 0x0465\n+    class #67; \/\/ #66     at 0x048D\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #67     at 0x0490\n+    Utf8 \"Lookup\"; \/\/ #68     at 0x04B1\n+  } \/\/ Constant Pool\n+\n+  0x0030; \/\/ access [ ACC_SUPER ACC_FINAL ]\n+  #8;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0x04C4\n+      0x8012; \/\/ access\n+      #11; \/\/ name_cpx\n+      #12; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x04CC\n+      0x8012; \/\/ access\n+      #15; \/\/ name_cpx\n+      #16; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [7] { \/\/ methods\n+    { \/\/ Member at 0x04D6\n+      0x0001; \/\/ access\n+      #5; \/\/ name_cpx\n+      #33; \/\/ sig_cpx\n+      [2] { \/\/ Attributes\n+        Attr(#34, 39) { \/\/ Code at 0x04DE\n+          2; \/\/ max_stack\n+          3; \/\/ max_locals\n+          Bytes[15]{\n+            0x2AB700012A1BB500;\n+            0x072A2CB5000DB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#35, 6) { \/\/ LineNumberTable at 0x04FF\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x050B\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+        ;\n+        Attr(#36, 9) { \/\/ MethodParameters at 0x050B\n+          0x02000B8000000F80;\n+          0x00;\n+        } \/\/ end MethodParameters\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x051A\n+      0x8001; \/\/ access\n+      #19; \/\/ name_cpx\n+      #37; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#34, 31) { \/\/ Code at 0x0522\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00110000B0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#35, 6) { \/\/ LineNumberTable at 0x053B\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0547\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0547\n+      0x8011; \/\/ access\n+      #23; \/\/ name_cpx\n+      #38; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#34, 31) { \/\/ Code at 0x054F\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00150000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#35, 6) { \/\/ LineNumberTable at 0x0568\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0574\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0574\n+      0x8011; \/\/ access\n+      #27; \/\/ name_cpx\n+      #39; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#34, 32) { \/\/ Code at 0x057C\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA00190000AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#35, 6) { \/\/ LineNumberTable at 0x0596\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x05A2\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x05A2\n+      0x8001; \/\/ access\n+      #11; \/\/ name_cpx\n+      #38; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#34, 29) { \/\/ Code at 0x05AA\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40007AC;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#35, 6) { \/\/ LineNumberTable at 0x05C1\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x05CD\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x05CD\n+      0x8001; \/\/ access\n+      #15; \/\/ name_cpx\n+      #37; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#34, 29) { \/\/ Code at 0x05D5\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB4000DB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#35, 6) { \/\/ LineNumberTable at 0x05EC\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x05F8\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x05F8\n+      0x0009; \/\/ access\n+      #31; \/\/ name_cpx\n+      #40; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#34, 27) { \/\/ Code at 0x0600\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[3]{\n+            0x121DB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#35, 6) { \/\/ LineNumberTable at 0x0615\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0621\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [4] { \/\/ Attributes\n+    Attr(#41, 2) { \/\/ SourceFile at 0x0623\n+      #42;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#43, 14) { \/\/ Record at 0x062B\n+      0x0002000B000C0000;\n+      0x000F00100000;\n+    } \/\/ end Record\n+    ;\n+    Attr(#44, 24) { \/\/ BootstrapMethods at 0x063F\n+      [2] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #45; \/\/ bootstrap_method_ref\n+          [4] { \/\/ bootstrap_arguments\n+            #8; \/\/  at 0x064D\n+            #52; \/\/  at 0x064F\n+            #54; \/\/  at 0x0651\n+            #55; \/\/  at 0x0653\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+        ;\n+        {  \/\/  bootstrap_method\n+          #56; \/\/ bootstrap_method_ref\n+          [3] { \/\/ bootstrap_arguments\n+            #8; \/\/  at 0x0659\n+            #54; \/\/  at 0x065B\n+            #55; \/\/  at 0x065D\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#63, 10) { \/\/ InnerClasses at 0x065D\n+      [1] { \/\/ InnerClasses\n+        #64 #66 #68 25; \/\/  at 0x066D\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class superNotJLRecordOK\n","filename":"test\/hotspot\/jtreg\/runtime\/records\/superNotJLRecord.jcod","additions":330,"deletions":3,"binary":false,"changes":333,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-  65535; \/\/ minor version\n+  0; \/\/ minor version\n","filename":"test\/hotspot\/jtreg\/runtime\/records\/twoRecordAttributes.jcod","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -131,1 +131,1 @@\n-            \"java.lang.VerifyError: class Overrider overrides final method HasFinal.m(Ljava\/lang\/String;)V\");\n+            \"java.lang.IncompatibleClassChangeError: class Overrider overrides final method HasFinal.m(Ljava\/lang\/String;)V\");\n","filename":"test\/hotspot\/jtreg\/runtime\/verifier\/OverriderMsg.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,3 +33,3 @@\n- *     Try to load anonymous class derived from java.lang.System. The verification\n- *     system (split verifier and system class loader) should reject such attempt and\n- *     throw VerifyError.\n+ *     Try to load anonymous class derived from java.lang.System. The class file\n+ *     loader should reject such attempt and throw IncompatibleClassChangeError\n+ *     because java.lang.System is a final class.\n@@ -47,1 +47,1 @@\n- *      -requireExceptions java.lang.VerifyError\n+ *      -requireExceptions java.lang.IncompatibleClassChangeError\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/anonloader\/func\/finalSuperclass\/TestDescription.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,1 +126,1 @@\n-        b.test().loadClass(I).throws_(VerifyError.class).done()\n+        b.test().loadClass(I).throws_(IncompatibleClassChangeError.class).done()\n@@ -161,1 +161,1 @@\n-        b.test().loadClass(I).throws_(VerifyError.class).done()\n+        b.test().loadClass(I).throws_(IncompatibleClassChangeError.class).done()\n@@ -177,1 +177,1 @@\n-        b.test().loadClass(I).throws_(VerifyError.class).done()\n+        b.test().loadClass(I).throws_(IncompatibleClassChangeError.class).done()\n@@ -211,1 +211,1 @@\n-        b.test().loadClass(I).throws_(VerifyError.class).done()\n+        b.test().loadClass(I).throws_(IncompatibleClassChangeError.class).done()\n@@ -227,1 +227,1 @@\n-        b.test().loadClass(I).throws_(VerifyError.class).done()\n+        b.test().loadClass(I).throws_(IncompatibleClassChangeError.class).done()\n@@ -243,1 +243,1 @@\n-        b.test().loadClass(I).throws_(VerifyError.class).done()\n+        b.test().loadClass(I).throws_(IncompatibleClassChangeError.class).done()\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/runtime\/defmeth\/ObjectMethodOverridesTest.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -563,0 +563,1 @@\n+java\/foreign\/TestMismatch.java 8255270 generic-i586\n@@ -762,1 +763,0 @@\n-javax\/swing\/JTabbedPane\/7024235\/Test7024235.java 8028281 macosx-all\n@@ -778,1 +778,0 @@\n-javax\/swing\/SwingWorker\/6493680\/bug6493680.java 8198410 windows-all\n@@ -780,9 +779,0 @@\n-javax\/swing\/DataTransfer\/8059739\/bug8059739.java 8199074 generic-all\n-javax\/swing\/SwingWorker\/6432565\/bug6432565.java 8199077 generic-all\n-javax\/swing\/SwingWorker\/6880336\/NestedWorkers.java 8199049 windows-all\n-javax\/swing\/text\/DefaultCaret\/6938583\/bug6938583.java 8199058 generic-all\n-javax\/swing\/text\/html\/parser\/Parser\/6990651\/bug6990651.java 8199060 generic-all\n-javax\/swing\/text\/html\/parser\/Parser\/HtmlCommentTagParseTest\/HtmlCommentTagParseTest.java 8199073 generic-all\n-javax\/swing\/text\/StyledEditorKit\/8016833\/bug8016833.java 8199055 generic-all\n-javax\/swing\/text\/Utilities\/8134721\/bug8134721.java 8199062 generic-all\n-javax\/swing\/tree\/DefaultTreeCellRenderer\/7142955\/bug7142955.java 8199076 generic-all\n@@ -790,1 +780,0 @@\n-javax\/swing\/UIDefaults\/8149879\/InternalResourceBundle.java 8199054 windows-all\n@@ -792,1 +781,0 @@\n-javax\/swing\/JTextArea\/TextViewOOM\/TextViewOOM.java 8167355 generic-all\n@@ -798,1 +786,0 @@\n-javax\/swing\/ToolTipManager\/Test6256140.java 8233560 macosx-all\n@@ -802,1 +789,0 @@\n-javax\/swing\/text\/html\/HTMLEditorKit\/5043626\/bug5043626.java 233570 macosx-all\n@@ -807,4 +793,1 @@\n-javax\/swing\/JPopupMenu\/6827786\/bug6827786.java 8233556 macosx-all\n-javax\/swing\/JPopupMenu\/6544309\/bug6544309.java 8233556 macosx-all\n-javax\/swing\/JPopupMenu\/4634626\/bug4634626.java 8233556 macosx-all\n-javax\/swing\/JPopupMenu\/4458079\/bug4458079.java 8233556 macosx-all\n+javax\/swing\/JPopupMenu\/4634626\/bug4634626.java 8017175 macosx-all\n@@ -814,2 +797,0 @@\n-javax\/swing\/JMenu\/4692443\/bug4692443.java 8171998 macosx-all\n-javax\/swing\/plaf\/basic\/BasicComboPopup\/JComboBoxPopupLocation\/JComboBoxPopupLocation.java 8238720 windows-all\n@@ -893,0 +874,29 @@\n+\n+# Client manual tests\n+\n+java\/awt\/event\/MouseEvent\/SpuriousExitEnter\/SpuriousExitEnter_1.java 7131438,8022539 generic-all\n+java\/awt\/event\/MouseEvent\/SpuriousExitEnter\/SpuriousExitEnter_2.java 7131438,8022539 generic-all\n+java\/awt\/Modal\/WsDisabledStyle\/CloseBlocker\/CloseBlocker.java 7187741 linux-all,macosx-all\n+java\/awt\/Component\/UpdatingBootTime\/UpdatingBootTime.html 7194219 linux-all\n+java\/awt\/xembed\/server\/TestXEmbedServerJava.java 8001150,8004031 generic-all\n+java\/awt\/TextArea\/MouseOverScrollbarWhenTyping\/Test1.java 8005970 macosx-all,windows-all\n+javax\/swing\/JFileChooser\/6698013\/bug6698013.java 8024419 macosx-all\n+javax\/swing\/JColorChooser\/8065098\/bug8065098.java 8065647 macosx-all\n+java\/awt\/Modal\/PrintDialogsTest\/PrintDialogsTest.java 8068378 generic-all\n+java\/awt\/dnd\/DnDFileGroupDescriptor\/DnDFileGroupDescriptor.html 8080185 macosx-all,linux-all\n+javax\/swing\/JTabbedPane\/4666224\/bug4666224.html 8144124  macosx-all\n+java\/awt\/event\/MouseEvent\/AltGraphModifierTest\/AltGraphModifierTest.java 8162380 generic-all\n+java\/awt\/Window\/TranslucentJAppletTest\/TranslucentJAppletTest.java 8163086 macosx-all\n+java\/awt\/image\/multiresolution\/MultiResolutionIcon\/IconTest.java 8250804 macosx-all,linux-all\n+java\/awt\/image\/VolatileImage\/VolatileImageConfigurationTest.java 8171069 macosx-all,linux-all\n+java\/awt\/Modal\/InvisibleParentTest\/InvisibleParentTest.java 8172245 linux-all\n+java\/awt\/print\/Dialog\/RestoreActiveWindowTest\/RestoreActiveWindowTest.java 8185429 macosx-all\n+java\/awt\/TrayIcon\/DblClickActionEventTest\/DblClickActionEventTest.html 8203867 macosx-all\n+java\/awt\/Frame\/FrameStateTest\/FrameStateTest.html 8203920 macosx-all,linux-all\n+javax\/swing\/SwingUtilities\/TestTextPosInPrint.java 8227025 windows-all\n+java\/awt\/print\/PrinterJob\/ScaledText\/ScaledText.java 8231226 macosx-all\n+java\/awt\/font\/TextLayout\/TestJustification.html 8250791 macosx-all\n+javax\/swing\/JTabbedPane\/4209065\/bug4209065.java 8251177 macosx-all\n+java\/awt\/TrayIcon\/DragEventSource\/DragEventSource.java 8252242 macosx-all\n+\n+############################################################################\n","filename":"test\/jdk\/ProblemList.txt","additions":31,"deletions":21,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -61,1 +61,2 @@\n-    release.implementor\n+    release.implementor \\\n+    jdk.containerized\n","filename":"test\/jdk\/TEST.ROOT","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,2 +115,2 @@\n-            log(\"cleaning...\");\n-            \/\/ Attach to server debuggee and resume it so it can exit\n+            log(\"final attach...\");\n+            \/\/ Attach to server debuggee to ensure it's still available to attach and resume it so it can exit\n@@ -118,5 +118,28 @@\n-            Map<String, Argument> conn_args = conn.defaultArguments();\n-            Connector.IntegerArgument port_arg =\n-                    (Connector.IntegerArgument)conn_args.get(\"port\");\n-            port_arg.setValue(port);\n-            VirtualMachine vm = conn.attach(conn_args);\n+            retryDelay = 20;\n+            for (int retry = 0; retry < 5; retry++) {\n+                if (error != null) {\n+                    try {\n+                        Thread.sleep(retryDelay);\n+                    } catch (InterruptedException ex) {\n+                        \/\/ ignore\n+                    }\n+                    retryDelay *= 2;\n+                    error = null;\n+                }\n+                try {\n+                    log(\"retry: \" + retry);\n+                    Map<String, Argument> conn_args = conn.defaultArguments();\n+                    Connector.IntegerArgument port_arg =\n+                            (Connector.IntegerArgument)conn_args.get(\"port\");\n+                    port_arg.setValue(port);\n+                    VirtualMachine vm = conn.attach(conn_args);\n+\n+                    \/\/ The first event is always a VMStartEvent, and it is always in\n+                    \/\/ an EventSet by itself.  Wait for it.\n+                    EventSet evtSet = vm.eventQueue().remove();\n+                    for (Event event : evtSet) {\n+                        if (event instanceof VMStartEvent) {\n+                            break;\n+                        }\n+                        throw new RuntimeException(\"Test failed - debuggee did not start properly\");\n+                    }\n@@ -124,5 +147,2 @@\n-            \/\/ The first event is always a VMStartEvent, and it is always in\n-            \/\/ an EventSet by itself.  Wait for it.\n-            EventSet evtSet = vm.eventQueue().remove();\n-            for (Event event : evtSet) {\n-                if (event instanceof VMStartEvent) {\n+                    vm.eventRequestManager().deleteAllBreakpoints();\n+                    vm.resume();\n@@ -130,0 +150,3 @@\n+                } catch (ConnectException ex) {\n+                    log(\"got exception: \" + ex.toString());\n+                    error = ex;\n@@ -131,1 +154,3 @@\n-                throw new RuntimeException(\"Test failed - debuggee did not start properly\");\n+            }\n+            if (error != null) {\n+                throw error;\n@@ -134,3 +159,1 @@\n-            vm.eventRequestManager().deleteAllBreakpoints();\n-            vm.resume();\n-\n+            \/\/ give the debuggee some time to exit before forcibly terminating it\n","filename":"test\/jdk\/com\/sun\/jdi\/BadHandshakeTest.java","additions":40,"deletions":17,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,8 @@\n-import java.awt.*;\n-import java.awt.event.*;\n+import java.awt.Choice;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.event.InputEvent;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n@@ -43,2 +49,1 @@\n-    static boolean passed = false;\n-    static Robot robot = null;\n+    static volatile boolean passed = false;\n@@ -46,2 +51,2 @@\n-    public static void main(String args[])\n-    {\n+    public static void main(String args[]) throws Exception {\n+        Frame f = null;\n@@ -49,2 +54,2 @@\n-            robot = new Robot();\n-            robot.setAutoDelay(50);\n+            Robot robot = new Robot();\n+            robot.setAutoDelay(150);\n@@ -52,1 +57,1 @@\n-            Frame f = new Frame(\"choice test\");\n+            f = new Frame(\"choice test\");\n@@ -73,8 +78,1 @@\n-\n-            f.addWindowListener(new WindowAdapter() {\n-                public void windowClosing(WindowEvent we) {\n-                    System.err.println(\"Test passed\");\n-                    passed = true;\n-                }\n-            });\n-\n+            f.setLocationRelativeTo(null);\n@@ -91,2 +89,2 @@\n-            robot.mousePress(InputEvent.BUTTON2_MASK);\n-            robot.mouseRelease(InputEvent.BUTTON2_MASK);\n+            robot.mousePress(InputEvent.BUTTON2_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON2_DOWN_MASK);\n@@ -94,3 +92,3 @@\n-        } catch (Throwable e) {\n-            if (robot == null){\n-                throw new RuntimeException( \"Test failed.Unable to initialize Robot \"+e);\n+        } finally {\n+            if (f != null) {\n+                f.dispose();\n@@ -98,1 +96,0 @@\n-            throw new RuntimeException( \"Test failed due to thrown exception \"+e);\n","filename":"test\/jdk\/java\/awt\/Choice\/GetSizeTest\/GetSizeTest.java","additions":21,"deletions":24,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.color.ColorSpace;\n+import java.awt.color.ICC_Profile;\n+import java.awt.color.ICC_ProfileGray;\n+import java.awt.color.ProfileDataException;\n+\n+\/**\n+ * @test\n+ * @bug 8254370\n+ * @summary Tests basic ICC_ProfileGray functionality\n+ *\/\n+public final class ICC_ProfileGrayTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        ICC_Profile csProfile = ICC_Profile.getInstance(ColorSpace.CS_GRAY);\n+        ICC_Profile dataProfile = ICC_Profile.getInstance(csProfile.getData());\n+        ICC_Profile stringProfile = ICC_Profile.getInstance(\"GRAY.pf\");\n+        test(csProfile);\n+        test(dataProfile);\n+        test(stringProfile);\n+    }\n+\n+    private static void test(ICC_Profile profile) {\n+        \/\/ Gray profile should be implemented as ICC_ProfileGray and includes\n+        \/\/ the mediaWhitePointTag and grayTRCTag tags\n+        if (!(profile instanceof ICC_ProfileGray)\n+                || profile.getData(ICC_Profile.icSigMediaWhitePointTag) == null\n+                || profile.getData(ICC_Profile.icSigGrayTRCTag) == null) {\n+            throw new RuntimeException(\"Wrong profile: \" + profile);\n+        }\n+\n+        ICC_ProfileGray gray = (ICC_ProfileGray) profile;\n+\n+        int length = gray.getMediaWhitePoint().length;\n+        if (length != 3) {\n+            throw new RuntimeException(\"Wrong data length: \" + length);\n+        }\n+\n+        \/\/ if getTRC() throws an exception then getGamma() should work\n+        boolean trc = false;\n+        try {\n+            gray.getTRC();\n+            trc = true;\n+            System.out.println(\"getTRC() works fine\");\n+        } catch (ProfileDataException ignore) {\n+            gray.getGamma();\n+        }\n+        \/\/ if getGamma() throws an exception then getTRC() should work\n+        boolean gamma = false;\n+        try {\n+            gray.getGamma();\n+            gamma = true;\n+            System.out.println(\"getGamma() works fine\");\n+        } catch (ProfileDataException ignore) {\n+            gray.getTRC();\n+        }\n+\n+        if (gamma == trc) {\n+            \/\/ only one should work\n+            throw new RuntimeException(\"Only one operation should work\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/color\/ICC_ProfileGrayTest.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,167 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.color.ColorSpace;\n+import java.awt.color.ICC_Profile;\n+import java.awt.color.ICC_ProfileRGB;\n+import java.awt.color.ProfileDataException;\n+import java.util.Arrays;\n+\n+\/**\n+ * @test\n+ * @bug 8254370\n+ * @summary Tests basic ICC_ProfileRGB functionality\n+ *\/\n+public final class ICC_ProfileRGBTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        ICC_Profile csProfile = ICC_Profile.getInstance(ColorSpace.CS_sRGB);\n+        ICC_Profile dataProfile = ICC_Profile.getInstance(csProfile.getData());\n+        ICC_Profile string2Profile = ICC_Profile.getInstance(\"sRGB.pf\");\n+        ICC_Profile string1Profile = ICC_Profile.getInstance(\"LINEAR_RGB.pf\");\n+        test(csProfile);\n+        test(dataProfile);\n+        test(string1Profile);\n+        test(string2Profile);\n+    }\n+\n+    private static void test(ICC_Profile profile) {\n+        \/\/ RGB profile should be implemented as ICC_ProfileRGB and includes the\n+        \/\/ redColorantTag, greenColorantTag, blueColorantTag, redTRCTag,\n+        \/\/ greenTRCTag, blueTRCTag, mediaWhitePointTag tags\n+        if (!(profile instanceof ICC_ProfileRGB)\n+                || profile.getData(ICC_Profile.icSigRedColorantTag) == null\n+                || profile.getData(ICC_Profile.icSigGreenColorantTag) == null\n+                || profile.getData(ICC_Profile.icSigBlueColorantTag) == null\n+                || profile.getData(ICC_Profile.icSigRedTRCTag) == null\n+                || profile.getData(ICC_Profile.icSigGreenTRCTag) == null\n+                || profile.getData(ICC_Profile.icSigBlueTRCTag) == null\n+                || profile.getData(ICC_Profile.icSigMediaWhitePointTag) == null)\n+        {\n+            throw new RuntimeException(\"Wrong profile: \" + profile);\n+        }\n+\n+        ICC_ProfileRGB rgb = (ICC_ProfileRGB) profile;\n+\n+        int length = rgb.getMediaWhitePoint().length;\n+        if (length != 3) {\n+            throw new RuntimeException(\"Wrong data length: \" + length);\n+        }\n+\n+        \/\/ if getTRC() throws an exception then getGamma() should work\n+        boolean trc = false;\n+        try {\n+            rgb.getTRC(ICC_ProfileRGB.REDCOMPONENT);\n+            rgb.getTRC(ICC_ProfileRGB.GREENCOMPONENT);\n+            rgb.getTRC(ICC_ProfileRGB.BLUECOMPONENT);\n+            trc = true;\n+            System.out.println(\"getTRC() works fine\");\n+        } catch (ProfileDataException ignore) {\n+            rgb.getGamma(ICC_ProfileRGB.REDCOMPONENT);\n+            rgb.getGamma(ICC_ProfileRGB.GREENCOMPONENT);\n+            rgb.getGamma(ICC_ProfileRGB.BLUECOMPONENT);\n+        }\n+        \/\/ if getGamma() throws an exception then getTRC() should work\n+        boolean gamma = false;\n+        try {\n+            rgb.getGamma(ICC_ProfileRGB.REDCOMPONENT);\n+            rgb.getGamma(ICC_ProfileRGB.GREENCOMPONENT);\n+            rgb.getGamma(ICC_ProfileRGB.BLUECOMPONENT);\n+            gamma = true;\n+            System.out.println(\"getGamma() works fine\");\n+        } catch (ProfileDataException ignore) {\n+            rgb.getTRC(ICC_ProfileRGB.REDCOMPONENT);\n+            rgb.getTRC(ICC_ProfileRGB.GREENCOMPONENT);\n+            rgb.getTRC(ICC_ProfileRGB.BLUECOMPONENT);\n+        }\n+\n+        if (gamma == trc) {\n+            \/\/ only one should work fine\n+            throw new RuntimeException(\"Only one operation should work\");\n+        }\n+\n+        \/\/ IllegalArgumentException if the component is invalid\n+        try {\n+            rgb.getGamma(10);\n+            throw new RuntimeException(\"IllegalArgumentException was expected\");\n+        } catch (IllegalArgumentException ignored) {}\n+        try {\n+            rgb.getGamma(-1);\n+            throw new RuntimeException(\"IllegalArgumentException was expected\");\n+        } catch (IllegalArgumentException ignored) {}\n+        try {\n+            rgb.getTRC(10);\n+            throw new RuntimeException(\"IllegalArgumentException was expected\");\n+        } catch (IllegalArgumentException ignored) {}\n+        try {\n+            rgb.getTRC(-1);\n+            throw new RuntimeException(\"IllegalArgumentException was expected\");\n+        } catch (IllegalArgumentException ignored) {}\n+\n+        \/\/ Validates content of ICC_ProfileRGB.getMatrix()\n+        float[][] matrix = rgb.getMatrix(); \/\/ current implementation\n+        float[][] old = getMatrix(rgb); \/\/ old implementation\n+        if (!Arrays.deepEquals(matrix, old)) {\n+            System.err.println(\"Expected: \" + Arrays.deepToString(old));\n+            System.err.println(\"Actual: \" + Arrays.deepToString(matrix));\n+            throw new RuntimeException(\"Wrong matrix\");\n+        }\n+    }\n+\n+    \/**\n+     * Old implementation of ICC_ProfileRGB.getMatrix().\n+     *\/\n+    private static float[][] getMatrix(ICC_ProfileRGB profile) {\n+        float[] tmpMatrix = getXYZTag(profile, ICC_Profile.icSigRedColorantTag);\n+        float[][] theMatrix = new float[3][3];\n+        theMatrix[0][0] = tmpMatrix[0];\n+        theMatrix[1][0] = tmpMatrix[1];\n+        theMatrix[2][0] = tmpMatrix[2];\n+        tmpMatrix = getXYZTag(profile, ICC_Profile.icSigGreenColorantTag);\n+        theMatrix[0][1] = tmpMatrix[0];\n+        theMatrix[1][1] = tmpMatrix[1];\n+        theMatrix[2][1] = tmpMatrix[2];\n+        tmpMatrix = getXYZTag(profile, ICC_Profile.icSigBlueColorantTag);\n+        theMatrix[0][2] = tmpMatrix[0];\n+        theMatrix[1][2] = tmpMatrix[1];\n+        theMatrix[2][2] = tmpMatrix[2];\n+        return theMatrix;\n+    }\n+\n+    private static float[] getXYZTag(ICC_ProfileRGB profile, int theTagSignature) {\n+        byte[] theData = profile.getData(theTagSignature);\n+        float[] theXYZNumber = new float[3];\n+        for (int i1 = 0, i2 = profile.icXYZNumberX; i1 < 3; i1++, i2 += 4) {\n+            int theS15Fixed16 = intFromBigEndian(theData, i2);\n+            theXYZNumber [i1] = theS15Fixed16 \/ 65536.0f;\n+        }\n+        return theXYZNumber;\n+    }\n+\n+    static int intFromBigEndian(byte[] array, int index) {\n+        return (((array[index]   & 0xff) << 24) |\n+                ((array[index+1] & 0xff) << 16) |\n+                ((array[index+2] & 0xff) <<  8) |\n+                (array[index+3] & 0xff));\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/color\/ICC_ProfileRGBTest.java","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,1 @@\n-        System.out.println(\"Starting external clipborad modifier...\");\n+        System.out.println(\"Starting external clipboard modifier...\");\n@@ -109,1 +109,1 @@\n-            throw new RuntimeException(\"No LostOwnership event received.\");\n+            throw new RuntimeException(\"No FlavorsChanged event received.\");\n","filename":"test\/jdk\/java\/awt\/datatransfer\/ClipboardInterVMTest\/ClipboardInterVMTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+        \"Please select the RadioButton for applet size labeled \\\"variable\\\" radiobutton in test harness window.\",\n@@ -172,1 +173,3 @@\n-\n+            double imgX = pageFormat.getImageableX();\n+            double imgY = pageFormat.getImageableY();\n+            ((Graphics2D)graphics).translate(imgX, imgY);\n","filename":"test\/jdk\/java\/awt\/print\/bug8023392\/bug8023392.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8246774\n@@ -27,3 +28,2 @@\n- * @compile --enable-preview -source ${jdk.version} AbsentStreamValuesTest.java\n- * @run testng\/othervm --enable-preview AbsentStreamValuesTest\n- * @run testng\/othervm\/java.security.policy=empty_security.policy --enable-preview AbsentStreamValuesTest\n+ * @run testng AbsentStreamValuesTest\n+ * @run testng\/othervm\/java.security.policy=empty_security.policy AbsentStreamValuesTest\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/AbsentStreamValuesTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8246774\n@@ -30,2 +31,1 @@\n- * @compile --enable-preview -source ${jdk.version} BadCanonicalCtrTest.java\n- * @run testng\/othervm --enable-preview BadCanonicalCtrTest\n+ * @run testng BadCanonicalCtrTest\n@@ -62,1 +62,0 @@\n-    private static final String VERSION = Integer.toString(Runtime.version().feature());\n@@ -82,2 +81,1 @@\n-                    \"public record R1 () implements java.io.Serializable { }\",\n-                    \"--enable-preview\", \"-source\", VERSION);\n+                    \"public record R1 () implements java.io.Serializable { }\");\n@@ -92,2 +90,1 @@\n-                    \"public record R2 (int x, int y) implements java.io.Serializable { }\",\n-                    \"--enable-preview\", \"-source\", VERSION);\n+                    \"public record R2 (int x, int y) implements java.io.Serializable { }\");\n@@ -104,2 +101,1 @@\n-                    \"    public void readExternal(java.io.ObjectInput in)    { } }\",\n-                    \"--enable-preview\", \"-source\", VERSION);\n+                    \"    public void readExternal(java.io.ObjectInput in)    { } }\");\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/BadCanonicalCtrTest.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8246774\n@@ -27,3 +28,2 @@\n- * @compile --enable-preview -source ${jdk.version} BasicRecordSer.java\n- * @run testng\/othervm --enable-preview BasicRecordSer\n- * @run testng\/othervm\/java.security.policy=empty_security.policy --enable-preview BasicRecordSer\n+ * @run testng BasicRecordSer\n+ * @run testng\/othervm\/java.security.policy=empty_security.policy BasicRecordSer\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/BasicRecordSer.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8246774\n@@ -28,3 +29,2 @@\n- * @compile --enable-preview -source ${jdk.version} ConstructorAccessTest.java\n- * @run testng\/othervm --enable-preview ConstructorAccessTest\n- * @run testng\/othervm\/java.security.policy=empty_security.policy --enable-preview ConstructorAccessTest\n+ * @run testng ConstructorAccessTest\n+ * @run testng\/othervm\/java.security.policy=empty_security.policy ConstructorAccessTest\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/ConstructorAccessTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8246774\n@@ -28,2 +29,1 @@\n- * @compile --enable-preview -source ${jdk.version} ConstructorPermissionTest.java\n- * @run testng\/othervm\/java.security.policy=empty_security.policy --enable-preview ConstructorPermissionTest\n+ * @run testng\/othervm\/java.security.policy=empty_security.policy ConstructorPermissionTest\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/ConstructorPermissionTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8246774\n@@ -27,3 +28,2 @@\n- * @compile --enable-preview -source ${jdk.version} CycleTest.java\n- * @run testng\/othervm --enable-preview CycleTest\n- * @run testng\/othervm\/java.security.policy=empty_security.policy --enable-preview CycleTest\n+ * @run testng CycleTest\n+ * @run testng\/othervm\/java.security.policy=empty_security.policy CycleTest\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/CycleTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8246774\n@@ -28,3 +29,2 @@\n- * @compile --enable-preview -source ${jdk.version} DifferentStreamFieldsTest.java\n- * @run testng\/othervm --enable-preview DifferentStreamFieldsTest\n- * @run testng\/othervm\/java.security.policy=empty_security.policy --enable-preview DifferentStreamFieldsTest\n+ * @run testng DifferentStreamFieldsTest\n+ * @run testng\/othervm\/java.security.policy=empty_security.policy DifferentStreamFieldsTest\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/DifferentStreamFieldsTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8246774\n@@ -29,2 +30,1 @@\n- * @compile --enable-preview -source ${jdk.version} ProhibitedMethods.java\n- * @run testng\/othervm --enable-preview ProhibitedMethods\n+ * @run testng ProhibitedMethods\n@@ -72,1 +72,0 @@\n-    private static final String VERSION = Integer.toString(Runtime.version().feature());\n@@ -109,2 +108,1 @@\n-                    \"public record Foo () implements java.io.Serializable { }\",\n-                    \"--enable-preview\", \"-source\", VERSION);\n+                    \"public record Foo () implements java.io.Serializable { }\");\n@@ -118,2 +116,1 @@\n-                    \"public record Bar (int x, int y) implements java.io.Serializable { }\",\n-                    \"--enable-preview\", \"-source\", VERSION);\n+                    \"public record Bar (int x, int y) implements java.io.Serializable { }\");\n@@ -128,2 +125,1 @@\n-                    \"public record Baz<U extends Serializable,V extends Serializable>(U u, V v) implements Serializable { }\",\n-                    \"--enable-preview\", \"-source\", VERSION);\n+                    \"public record Baz<U extends Serializable,V extends Serializable>(U u, V v) implements Serializable { }\");\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/ProhibitedMethods.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8246774\n@@ -27,3 +28,2 @@\n- * @compile --enable-preview -source ${jdk.version} ReadResolveTest.java\n- * @run testng\/othervm --enable-preview ReadResolveTest\n- * @run testng\/othervm\/java.security.policy=empty_security.policy --enable-preview ReadResolveTest\n+ * @run testng ReadResolveTest\n+ * @run testng\/othervm\/java.security.policy=empty_security.policy ReadResolveTest\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/ReadResolveTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8246774\n@@ -27,3 +28,2 @@\n- * @compile --enable-preview -source ${jdk.version} RecordClassTest.java\n- * @run testng\/othervm --enable-preview RecordClassTest\n- * @run testng\/othervm\/java.security.policy=empty_security.policy --enable-preview RecordClassTest\n+ * @run testng RecordClassTest\n+ * @run testng\/othervm\/java.security.policy=empty_security.policy RecordClassTest\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/RecordClassTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8246774\n@@ -29,2 +30,1 @@\n- * @compile --enable-preview -source ${jdk.version} SerialPersistentFieldsTest.java\n- * @run testng\/othervm --enable-preview SerialPersistentFieldsTest\n+ * @run testng SerialPersistentFieldsTest\n@@ -65,1 +65,0 @@\n-    private static final String VERSION = Integer.toString(Runtime.version().feature());\n@@ -86,2 +85,1 @@\n-                    \"public record R1 () implements java.io.Serializable { }\",\n-                    \"--enable-preview\", \"-source\", VERSION);\n+                    \"public record R1 () implements java.io.Serializable { }\");\n@@ -99,2 +97,1 @@\n-                    \"public record R2 (int x) implements java.io.Serializable { }\",\n-                    \"--enable-preview\", \"-source\", VERSION);\n+                    \"public record R2 (int x) implements java.io.Serializable { }\");\n@@ -109,2 +106,1 @@\n-                    \"public record R3 (int x, int y) implements java.io.Serializable { }\",\n-                    \"--enable-preview\", \"-source\", VERSION);\n+                    \"public record R3 (int x, int y) implements java.io.Serializable { }\");\n@@ -118,2 +114,1 @@\n-                    \"public record R4<U extends Serializable,V extends Serializable>(U u, V v) implements Serializable { }\",\n-                    \"--enable-preview\", \"-source\", VERSION);\n+                    \"public record R4<U extends Serializable,V extends Serializable>(U u, V v) implements Serializable { }\");\n@@ -135,2 +130,1 @@\n-                    \"    }  }\",\n-                    \"--enable-preview\", \"-source\", VERSION);\n+                    \"    }  }\");\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/SerialPersistentFieldsTest.java","additions":7,"deletions":13,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8246774\n@@ -27,3 +28,2 @@\n- * @compile --enable-preview -source ${jdk.version} SerialVersionUIDTest.java\n- * @run testng\/othervm --enable-preview SerialVersionUIDTest\n- * @run testng\/othervm\/java.security.policy=empty_security.policy --enable-preview SerialVersionUIDTest\n+ * @run testng SerialVersionUIDTest\n+ * @run testng\/othervm\/java.security.policy=empty_security.policy SerialVersionUIDTest\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/SerialVersionUIDTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8246774\n@@ -27,2 +28,1 @@\n- * @compile --enable-preview -source ${jdk.version} StreamRefTest.java\n- * @run testng\/othervm --enable-preview StreamRefTest\n+ * @run testng StreamRefTest\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/StreamRefTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8246774\n@@ -27,3 +28,2 @@\n- * @compile --enable-preview -source ${jdk.version} ThrowingConstructorTest.java\n- * @run testng\/othervm --enable-preview ThrowingConstructorTest\n- * @run testng\/othervm\/java.security.policy=empty_security.policy --enable-preview ThrowingConstructorTest\n+ * @run testng ThrowingConstructorTest\n+ * @run testng\/othervm\/java.security.policy=empty_security.policy ThrowingConstructorTest\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/ThrowingConstructorTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8238763\n+ * @bug 8238763 8246774\n@@ -28,2 +28,1 @@\n- * @compile --enable-preview -source ${jdk.version} UnsharedTest.java\n- * @run testng\/othervm --enable-preview UnsharedTest\n+ * @run testng UnsharedTest\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/UnsharedTest.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8246774\n@@ -27,3 +28,2 @@\n- * @compile --enable-preview -source ${jdk.version} WriteReplaceTest.java\n- * @run testng\/othervm --enable-preview WriteReplaceTest\n- * @run testng\/othervm\/java.security.policy=empty_security.policy --enable-preview WriteReplaceTest\n+ * @run testng WriteReplaceTest\n+ * @run testng\/othervm\/java.security.policy=empty_security.policy WriteReplaceTest\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/WriteReplaceTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,2 +47,0 @@\n-    private static final String VERSION = Integer.toString(Runtime.version().feature());\n-\n@@ -62,1 +60,0 @@\n-                   \"--enable-preview\", \"-source\", VERSION,\n@@ -66,1 +63,0 @@\n-                   \"--enable-preview\", \"-source\", VERSION,\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/migration\/AbstractTest.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8246774\n@@ -29,3 +30,3 @@\n- * @compile --enable-preview -source ${jdk.version} AssignableFrom.java Point.java\n- *          DefaultValues.java SuperStreamFields.java AssignableFromTest.java\n- * @run testng\/othervm --enable-preview AssignableFromTest\n+ * @compile AssignableFrom.java Point.java\n+ *          DefaultValues.java SuperStreamFields.java\n+ * @run testng AssignableFromTest\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/migration\/AssignableFromTest.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8246774\n@@ -29,3 +30,2 @@\n- * @compile --enable-preview -source ${jdk.version} AssignableFrom.java Point.java\n- *          DefaultValues.java SuperStreamFields.java DefaultValuesTest.java\n- * @run testng\/othervm --enable-preview DefaultValuesTest\n+ * @compile AssignableFrom.java Point.java DefaultValues.java SuperStreamFields.java\n+ * @run testng DefaultValuesTest\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/migration\/DefaultValuesTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8246774\n@@ -29,3 +30,2 @@\n- * @compile --enable-preview -source ${jdk.version} AssignableFrom.java Point.java\n- *          DefaultValues.java SuperStreamFields.java SuperStreamFieldsTest.java\n- * @run testng\/othervm --enable-preview SuperStreamFieldsTest\n+ * @compile AssignableFrom.java Point.java DefaultValues.java SuperStreamFields.java\n+ * @run testng SuperStreamFieldsTest\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/migration\/SuperStreamFieldsTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8246774\n@@ -36,9 +37,8 @@\n- * @compile --enable-preview -source ${jdk.version} Host\/Host.java\n- * @compile --enable-preview -source ${jdk.version} TestRecordAttr.java\n- * @run main\/othervm -javaagent:redefineagent.jar --enable-preview -Xlog:redefine+class+record=trace TestRecordAttr Host\n- * @compile --enable-preview -source ${jdk.version} HostA\/Host.java\n- * @run main\/othervm -javaagent:redefineagent.jar --enable-preview -Xlog:redefine+class+record=trace TestRecordAttr HostA\n- * @compile --enable-preview -source ${jdk.version} HostAB\/Host.java\n- * @run main\/othervm -javaagent:redefineagent.jar --enable-preview -Xlog:redefine+class+record=trace TestRecordAttr HostAB\n- * @compile --enable-preview -source ${jdk.version} HostABC\/Host.java\n- * @run main\/othervm -javaagent:redefineagent.jar --enable-preview -Xlog:redefine+class+record=trace TestRecordAttr HostABC\n+ * @compile Host\/Host.java\n+ * @run main\/othervm -javaagent:redefineagent.jar -Xlog:redefine+class+record=trace TestRecordAttr Host\n+ * @compile HostA\/Host.java\n+ * @run main\/othervm -javaagent:redefineagent.jar -Xlog:redefine+class+record=trace TestRecordAttr HostA\n+ * @compile HostAB\/Host.java\n+ * @run main\/othervm -javaagent:redefineagent.jar -Xlog:redefine+class+record=trace TestRecordAttr HostAB\n+ * @compile HostABC\/Host.java\n+ * @run main\/othervm -javaagent:redefineagent.jar -Xlog:redefine+class+record=trace TestRecordAttr HostABC\n@@ -272,3 +272,1 @@\n-                              false \/* don't recurse *\/,\n-                              \"--enable-preview\",\n-                              \"--source\", VERSION);\n+                              false \/* don't recurse *\/);\n","filename":"test\/jdk\/java\/lang\/instrument\/RedefineRecordAttr\/TestRecordAttr.java","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8246774\n@@ -36,5 +37,4 @@\n- * @compile --enable-preview --source ${jdk.version} Host\/Host.java\n- * @compile --enable-preview --source ${jdk.version} TestRecordAttrGenericSig.java\n- * @run main\/othervm -javaagent:redefineagent.jar -Xlog:redefine+class+record=trace --enable-preview TestRecordAttrGenericSig Host\n- * @compile --enable-preview --source ${jdk.version} HostA\/Host.java\n- * @run main\/othervm -javaagent:redefineagent.jar -Xlog:redefine+class+record=trace --enable-preview TestRecordAttrGenericSig HostA\n+ * @compile Host\/Host.java\n+ * @run main\/othervm -javaagent:redefineagent.jar -Xlog:redefine+class+record=trace TestRecordAttrGenericSig Host\n+ * @compile HostA\/Host.java\n+ * @run main\/othervm -javaagent:redefineagent.jar -Xlog:redefine+class+record=trace TestRecordAttrGenericSig HostA\n@@ -210,3 +210,1 @@\n-                              false \/* don't recurse *\/,\n-                              \"--enable-preview\",\n-                              \"--source\", VERSION);\n+                              false \/* don't recurse *\/);\n","filename":"test\/jdk\/java\/lang\/instrument\/RedefineRecordAttrGenericSig\/TestRecordAttrGenericSig.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-public class MethodHandlesPermuteArgumentsTest extends MethodHandlesTest {\n+public class MethodHandlesPermuteArgumentsTest extends test.java.lang.invoke.MethodHandlesTest {\n@@ -61,0 +61,5 @@\n+\n+        testBadReorderArrayLength();\n+        testBadReorderIndex();\n+        testReturnTypeMismatch();\n+        testReorderTypeMismatch();\n@@ -194,0 +199,53 @@\n+\n+    public void testBadReorderArrayLength() throws Throwable {\n+        MethodHandle mh = MethodHandles.empty(MethodType.methodType(void.class, int.class, int.class, String.class));\n+        MethodType newType = MethodType.methodType(void.class, int.class, String.class);\n+        assertThrows(() -> MethodHandles.permuteArguments(mh, newType, 0, 1),\n+                IllegalArgumentException.class, \".*old type parameter count and reorder array length do not match.*\");\n+    }\n+\n+    public void testBadReorderIndex() throws Throwable {\n+        MethodHandle mh = MethodHandles.empty(MethodType.methodType(void.class, int.class, int.class, String.class));\n+        MethodType newType = MethodType.methodType(void.class, int.class, String.class);\n+        assertThrows(() -> MethodHandles.permuteArguments(mh, newType, 0, 0, 2),\n+                IllegalArgumentException.class, \".*index is out of bounds for new type.*\");\n+        assertThrows(() -> MethodHandles.permuteArguments(mh, newType, 0, 0, -1),\n+                IllegalArgumentException.class, \".*index is out of bounds for new type.*\");\n+    }\n+\n+    public void testReturnTypeMismatch() throws Throwable {\n+        MethodHandle mh = MethodHandles.empty(MethodType.methodType(void.class, int.class, int.class, String.class));\n+        MethodType newType = MethodType.methodType(int.class, int.class, String.class);\n+        assertThrows(() -> MethodHandles.permuteArguments(mh, newType, 0, 0, 1),\n+                IllegalArgumentException.class, \".*return types do not match.*\");\n+    }\n+\n+    public void testReorderTypeMismatch() throws Throwable {\n+        MethodHandle mh = MethodHandles.empty(MethodType.methodType(void.class, int.class, int.class, String.class));\n+        MethodType newType = MethodType.methodType(void.class, double.class, String.class);\n+        assertThrows(() -> MethodHandles.permuteArguments(mh, newType, 0, 0, 1),\n+                IllegalArgumentException.class, \".*parameter types do not match after reorder.*\");\n+    }\n+\n+    private interface RunnableX {\n+        void run() throws Throwable;\n+    }\n+\n+    private static void assertThrows(RunnableX r, Class<?> exceptionClass, String messagePattern) throws Throwable {\n+        try {\n+            r.run();\n+            fail(\"Exception expected\");\n+        } catch (Throwable e) {\n+            if (exceptionClass.isInstance(e)) {\n+                assertMatches(e.getMessage(), messagePattern);\n+            } else {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    private static void assertMatches(String str, String pattern) {\n+        if (!str.matches(pattern)) {\n+            throw new AssertionError(\"'\" + str + \"' did not match the pattern '\" + pattern + \"'.\");\n+        }\n+    }\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandlesPermuteArgumentsTest.java","additions":59,"deletions":1,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,2 @@\n- * @bug 8227415\n- * @run main p.SuperMethodTest\n+ * @bug 8227415 8254975\n+ * @run testng\/othervm p.SuperMethodTest\n@@ -29,2 +29,2 @@\n- *          superclass in a different package must be accessed via\n- *          a bridge method.  Lambda proxy class has no access to it.\n+ *          superclass in a different runtime package where\n+ *          lambda proxy class has no access to it.\n@@ -38,0 +38,8 @@\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Files;\n@@ -42,0 +50,3 @@\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n@@ -43,1 +54,2 @@\n-    public static void main(String... args) {\n+    @Test\n+    public static void remotePackageSameLoader() {\n@@ -65,0 +77,64 @@\n+\n+    @Test\n+    public static void splitPackage() throws Throwable {\n+        ClassLoader parent = new Loader(\"loader-A\", null, A.class);\n+        ClassLoader loader = new Loader(\"loader-B\", parent, B.class);\n+        Class<?> aClass = Class.forName(A.class.getName(), false, loader);\n+        Class<?> bClass = Class.forName(B.class.getName(), false, loader);\n+        assertTrue(aClass.getClassLoader() == parent);\n+        assertTrue(bClass.getClassLoader() == loader);\n+        assertEquals(aClass.getPackageName(), bClass.getPackageName());\n+\n+        Object b = bClass.getDeclaredConstructor().newInstance();\n+\n+        \/\/ verify subclass can access a protected member inherited from\n+        \/\/ its superclass in a split package\n+        MethodHandle test = MethodHandles.lookup()\n+                .findVirtual(bClass, \"test\", MethodType.methodType(void.class));\n+        test.invoke(b);\n+\n+        \/\/ verify lambda can access a protected member inherited from\n+        \/\/ a superclass of the host class where the superclass is in\n+        \/\/ a split package (not the same runtime package as the host class)\n+        MethodHandle get = MethodHandles.lookup()\n+                .findVirtual(bClass, \"get\", MethodType.methodType(Runnable.class));\n+        ((Runnable) get.invoke(b)).run();\n+    }\n+\n+    static class Loader extends URLClassLoader {\n+        static final Path CLASSES_DIR = Paths.get(System.getProperty(\"test.class.path\"));\n+        private final Class<?> c;\n+        Loader(String name, ClassLoader parent, Class<?> c) {\n+            super(name, new URL[]{}, parent);\n+            this.c = c;\n+        }\n+\n+        @Override\n+        protected Class<?> findClass(String name) throws ClassNotFoundException {\n+            if (name.equals(c.getName())) {\n+                try {\n+                    String path = name.replace('.', '\/') + \".class\";\n+                    byte[] bytes = Files.readAllBytes(CLASSES_DIR.resolve(path));\n+                    return defineClass(name, bytes, 0, bytes.length);\n+                } catch (IOException e) {\n+                    throw new UncheckedIOException(e);\n+                }\n+            }\n+\n+            return super.findClass(name);\n+        }\n+\n+    }\n+\n+    public static class A {\n+        protected void func() { }\n+    }\n+\n+    public static class B extends A {\n+        public Runnable get() {\n+            return this::func;\n+        }\n+        public void test() {\n+            func();\n+        }\n+    }\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/superProtectedMethod\/SuperMethodTest.java","additions":82,"deletions":6,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8246774\n@@ -27,3 +28,2 @@\n- * @compile --enable-preview -source ${jdk.version} ObjectMethodsTest.java\n- * @run testng\/othervm --enable-preview ObjectMethodsTest\n- * @run testng\/othervm\/java.security.policy=empty.policy --enable-preview ObjectMethodsTest\n+ * @run testng ObjectMethodsTest\n+ * @run testng\/othervm\/java.security.policy=empty.policy ObjectMethodsTest\n","filename":"test\/jdk\/java\/lang\/runtime\/ObjectMethodsTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8231358\n+ * @compile ..\/..\/nio\/file\/spi\/TestProvider.java AddressTest.java\n+ * @run testng\/othervm AddressTest\n+ *\/\n+\n+import java.net.UnixDomainSocketAddress;\n+import java.net.URI;\n+import java.nio.file.FileSystems;\n+import java.nio.file.spi.FileSystemProvider;\n+import java.nio.file.Path;\n+\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertThrows;\n+\n+\/**\n+ * Verify that UnixDomainSocketAddress.of(path) throws IAE\n+ * if given a Path that does not originate from system default\n+ * file system.\n+ *\/\n+public class AddressTest {\n+\n+    \/\/ Expected exception\n+    private static final Class<IllegalArgumentException> IAE =\n+        IllegalArgumentException.class;\n+\n+    @Test\n+    public static void runTest() throws Exception {\n+        TestProvider prov = new TestProvider(FileSystems.getDefault().provider());\n+        Path path = prov.getPath(URI.create(\"file:\/\"));\n+        assertThrows(IAE, () -> UnixDomainSocketAddress.of(path));\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/UnixDomainSocketAddress\/AddressTest.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test UnixDomainSocketAddress constructor\n+ * @library \/test\/lib\n+ * @run testng\/othervm LengthTest\n+ *\/\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static java.lang.System.out;\n+import static java.net.StandardProtocolFamily.UNIX;\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n+import java.net.UnixDomainSocketAddress;\n+import java.io.IOException;\n+import java.nio.channels.SocketChannel;\n+import java.nio.file.Path;\n+\n+public class LengthTest {\n+    final int namelen = 100;    \/\/ length close to max\n+\n+    @DataProvider(name = \"strings\")\n+    public Object[][] strings() {\n+        if (namelen == -1)\n+            return new Object[][] {new String[]{\"\"}};\n+\n+        return new Object[][]{\n+                {\"\"},\n+                {new String(new char[100]).replaceAll(\"\\0\", \"x\")},\n+                {new String(new char[namelen]).replaceAll(\"\\0\", \"x\")},\n+                {new String(new char[namelen-1]).replaceAll(\"\\0\", \"x\")},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"strings\")\n+    public void expectPass(String s) {\n+        var addr = UnixDomainSocketAddress.of(s);\n+        assertTrue(addr.getPath().toString().equals(s), \"getPathName.equals(s)\");\n+        var p = Path.of(s);\n+        addr = UnixDomainSocketAddress.of(p);\n+        assertTrue(addr.getPath().equals(p), \"getPath.equals(p)\");\n+    }\n+\n+    @Test\n+    public void expectNPE() {\n+        try {\n+            String s = null;\n+            UnixDomainSocketAddress.of(s);\n+            throw new RuntimeException(\"Expected NPE\");\n+        } catch (NullPointerException npe) {\n+            out.println(\"\\tCaught expected exception: \" + npe);\n+        }\n+        try {\n+            Path p = null;\n+            UnixDomainSocketAddress.of(p);\n+            throw new RuntimeException(\"Expected NPE\");\n+        } catch (NullPointerException npe) {\n+            out.println(\"\\tCaught expected exception: \" + npe);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/UnixDomainSocketAddress\/LengthTest.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectStreamClass;\n+import java.io.Serializable;\n+import java.net.UnixDomainSocketAddress;\n+import java.nio.file.Path;\n+import static java.io.ObjectStreamConstants.*;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.expectThrows;\n+\n+\/*\n+ * @test\n+ * @summary UnixDomainSocketAddress serialization test\n+ * @run testng\/othervm UnixDomainSocketAddressSerializationTest\n+ *\/\n+\n+@Test\n+public class UnixDomainSocketAddressSerializationTest {\n+    private static final UnixDomainSocketAddress addr =\n+            UnixDomainSocketAddress.of(Path.of(\"test.sock\"));\n+\n+    public static void test() throws Exception {\n+        assertTrue(addr instanceof Serializable);\n+\n+        byte[] serialized = serialize(addr);\n+        assertTrue(serialized.length > 0);\n+\n+        UnixDomainSocketAddress deserialized =\n+                deserialize(serialized, UnixDomainSocketAddress.class);\n+        assertEquals(deserialized.getPath(), addr.getPath());\n+        assertEquals(deserialized.toString(), addr.toString());\n+        assertEquals(deserialized.hashCode(), addr.hashCode());\n+        assertEquals(deserialized, addr);\n+    }\n+\n+    static final Class<InvalidObjectException> IOE = InvalidObjectException.class;\n+    static final Class<NullPointerException> NPE = NullPointerException.class;\n+\n+    \/** Tests that UnixDomainSocketAddress in the byte-stream is disallowed. *\/\n+    public static void testUnixDomainSocketAddressInStream() throws Exception {\n+        long suid = ObjectStreamClass.lookup(UnixDomainSocketAddress.class).getSerialVersionUID();\n+        byte[] bytes = byteStreamFor(UnixDomainSocketAddress.class.getName(), suid);\n+        expectThrows(IOE, () -> deserialize(bytes, UnixDomainSocketAddress.class));\n+    }\n+\n+    \/** Tests that SerialProxy with a null\/absent path value in the byte-stream is disallowed. *\/\n+    public static void testSerialProxyNoStreamValues() throws Exception {\n+        Class<?> c = Class.forName(\"java.net.UnixDomainSocketAddress$Ser\");\n+        long suid = ObjectStreamClass.lookup(c).getSerialVersionUID();\n+        byte[] bytes = byteStreamFor(c.getName(), suid);\n+        expectThrows(NPE, () -> deserialize(bytes, UnixDomainSocketAddress.class));\n+    }\n+\n+    private static <T extends Serializable> byte[] serialize(T t)\n+            throws IOException {\n+        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(bos);\n+        oos.writeObject(t);\n+        oos.flush();\n+        oos.close();\n+        return bos.toByteArray();\n+    }\n+\n+    private static <T extends Serializable> T deserialize(byte[] b, Class<T> cl)\n+            throws IOException, ClassNotFoundException {\n+        try (ObjectInputStream ois =\n+                     new ObjectInputStream(new ByteArrayInputStream(b))) {\n+            Object o = ois.readObject();\n+            return cl.cast(o);\n+        }\n+    }\n+\n+    \/**\n+     * Returns a stream with the given classname and suid. The stream will have\n+     * no stream field values.\n+     *\/\n+    static byte[] byteStreamFor(String classname, long suid) throws Exception {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        DataOutputStream dos = new DataOutputStream(baos);\n+        dos.writeShort(STREAM_MAGIC);\n+        dos.writeShort(STREAM_VERSION);\n+        dos.writeByte(TC_OBJECT);\n+        dos.writeByte(TC_CLASSDESC);\n+        dos.writeUTF(classname);\n+        dos.writeLong(suid);\n+        dos.writeByte(SC_SERIALIZABLE);\n+        dos.writeShort(0);                \/\/ number of stream fields\n+        dos.writeByte(TC_ENDBLOCKDATA);   \/\/ no annotations\n+        dos.writeByte(TC_NULL);           \/\/ no superclasses\n+        dos.write(TC_ENDBLOCKDATA);       \/\/ end block - for SC_WRITE_METHOD\n+        dos.close();\n+        return baos.toByteArray();\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/UnixDomainSocketAddress\/UnixDomainSocketAddressSerializationTest.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n- * @author Mike McCloskey\n@@ -35,1 +34,5 @@\n-\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.stream.Stream;\n@@ -46,3 +49,8 @@\n-        Reactor r = new Reactor();\n-        Actor a = new Actor(r.port());\n-        invoke(a, r);\n+        ExecutorService threadPool = Executors.newCachedThreadPool();\n+        try (Reactor r = new Reactor();\n+             Actor a = new Actor(r.getSocketAddress())\n+        ) {\n+            invoke(threadPool, a, r);\n+        } finally {\n+            threadPool.shutdown();\n+        }\n@@ -51,13 +59,4 @@\n-    static void invoke(Sprintable reader, Sprintable writer) throws Exception {\n-\n-        Thread writerThread = new Thread(writer);\n-        writerThread.start();\n-\n-        Thread readerThread = new Thread(reader);\n-        readerThread.start();\n-\n-        writerThread.join();\n-        readerThread.join();\n-\n-        reader.throwException();\n-        writer.throwException();\n+    static void invoke(ExecutorService e, Runnable reader, Runnable writer) throws CompletionException {\n+        CompletableFuture<Void> f1 = CompletableFuture.runAsync(writer, e);\n+        CompletableFuture<Void> f2 = CompletableFuture.runAsync(reader, e);\n+        wait(f1, f2);\n@@ -66,3 +65,0 @@\n-    public interface Sprintable extends Runnable {\n-        public void throwException() throws Exception;\n-    }\n@@ -70,3 +66,11 @@\n-    public static class Actor implements Sprintable {\n-        final int port;\n-        Exception e = null;\n+    \/\/ This method waits for either one of the given futures to complete exceptionally\n+    \/\/ or for all of the given futures to complete successfully.\n+    private static void wait(CompletableFuture<?>... futures) throws CompletionException {\n+        CompletableFuture<?> future = CompletableFuture.allOf(futures);\n+        Stream.of(futures)\n+                .forEach(f -> f.exceptionally(ex -> {\n+                    future.completeExceptionally(ex);\n+                    return null;\n+                }));\n+        future.join();\n+    }\n@@ -74,3 +78,3 @@\n-        Actor(int port) {\n-            this.port = port;\n-        }\n+    public static class Actor implements AutoCloseable, Runnable {\n+        final SocketAddress socketAddress;\n+        final DatagramChannel dc;\n@@ -78,3 +82,3 @@\n-        public void throwException() throws Exception {\n-            if (e != null)\n-                throw e;\n+        Actor(SocketAddress socketAddress) throws IOException {\n+            this.socketAddress = socketAddress;\n+            dc = DatagramChannel.open();\n@@ -85,3 +89,0 @@\n-                DatagramChannel dc = DatagramChannel.open();\n-\n-                \/\/ Send a message\n@@ -91,6 +92,4 @@\n-                InetAddress address = InetAddress.getLocalHost();\n-                if (address.isLoopbackAddress()) {\n-                    address = InetAddress.getLoopbackAddress();\n-                }\n-                InetSocketAddress isa = new InetSocketAddress(address, port);\n-                dc.connect(isa);\n+                dc.connect(socketAddress);\n+\n+                \/\/ Send a message\n+                log.println(\"Actor attempting to write to Reactor at \" + socketAddress.toString());\n@@ -100,2 +99,0 @@\n-                address = InetAddress.getLocalHost();\n-                InetSocketAddress bogus = new InetSocketAddress(address, 3333);\n@@ -103,2 +100,6 @@\n-                    dc.send(bb, bogus);\n-                    throw new RuntimeException(\"Allowed bogus send while connected\");\n+                    int port = dc.socket().getLocalPort();\n+                    InetAddress loopback = InetAddress.getLoopbackAddress();\n+                    InetSocketAddress otherAddress = new InetSocketAddress(loopback, (port == 3333 ? 3332 : 3333));\n+                    log.println(\"Testing if Actor throws AlreadyConnectedException\" + otherAddress.toString());\n+                    dc.send(bb, otherAddress);\n+                    throw new RuntimeException(\"Actor allowed send to other address while already connected\");\n@@ -111,0 +112,1 @@\n+                log.println(\"Actor waiting to read\");\n@@ -113,7 +115,3 @@\n-                CharBuffer cb = Charset.forName(\"US-ASCII\").\n-                newDecoder().decode(bb);\n-                log.println(\"From Reactor: \"+isa+ \" said \" +cb);\n-\n-                \/\/ Clean up\n-                dc.disconnect();\n-                dc.close();\n+                CharBuffer cb = StandardCharsets.US_ASCII.\n+                        newDecoder().decode(bb);\n+                log.println(\"Actor received from Reactor at \" + socketAddress + \": \" + cb);\n@@ -121,1 +119,4 @@\n-                e = ex;\n+                log.println(\"Actor threw exception: \" + ex);\n+                throw new RuntimeException(ex);\n+            } finally {\n+                log.println(\"Actor finished\");\n@@ -124,0 +125,5 @@\n+\n+        @Override\n+        public void close() throws IOException {\n+            dc.close();\n+        }\n@@ -126,1 +132,1 @@\n-    public static class Reactor implements Sprintable {\n+    public static class Reactor implements AutoCloseable, Runnable {\n@@ -128,1 +134,0 @@\n-        Exception e = null;\n@@ -131,1 +136,1 @@\n-            dc = DatagramChannel.open().bind(new InetSocketAddress(0));\n+            dc = DatagramChannel.open().bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n@@ -134,7 +139,2 @@\n-        int port() {\n-            return dc.socket().getLocalPort();\n-        }\n-\n-        public void throwException() throws Exception {\n-            if (e != null)\n-                throw e;\n+        SocketAddress getSocketAddress() throws IOException {\n+            return dc.getLocalAddress();\n@@ -147,0 +147,1 @@\n+                log.println(\"Reactor waiting to receive\");\n@@ -149,3 +150,3 @@\n-                CharBuffer cb = Charset.forName(\"US-ASCII\").\n-                newDecoder().decode(bb);\n-                log.println(\"From Actor: \"+sa+ \" said \" +cb);\n+                CharBuffer cb = StandardCharsets.US_ASCII.\n+                        newDecoder().decode(bb);\n+                log.println(\"Reactor received from Actor at\" + sa +  \": \" + cb);\n@@ -156,0 +157,1 @@\n+                log.println(\"Reactor attempting to write: \" + dc.getRemoteAddress().toString());\n@@ -157,4 +159,0 @@\n-\n-                \/\/ Clean up\n-                dc.disconnect();\n-                dc.close();\n@@ -162,1 +160,4 @@\n-                e = ex;\n+                log.println(\"Reactor threw exception: \" + ex);\n+                throw new RuntimeException(ex);\n+            } finally {\n+                log.println(\"Reactor finished\");\n@@ -165,0 +166,5 @@\n+\n+        @Override\n+        public void close() throws IOException {\n+            dc.close();\n+        }\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/Connect.java","additions":76,"deletions":70,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import static org.testng.Assert.assertEquals;\n@@ -308,1 +309,1 @@\n-        return family == null ? SocketChannel.open()\n+        SocketChannel sc = family == null ? SocketChannel.open()\n@@ -310,0 +311,1 @@\n+        return sc;\n@@ -314,1 +316,1 @@\n-        return family == null ? ServerSocketChannel.open()\n+        ServerSocketChannel ssc = family == null ? ServerSocketChannel.open()\n@@ -316,0 +318,1 @@\n+        return ssc;\n@@ -320,1 +323,1 @@\n-        return family == null ? DatagramChannel.open()\n+        DatagramChannel dc = family == null ? DatagramChannel.open()\n@@ -322,0 +325,1 @@\n+        return dc;\n@@ -328,0 +332,1 @@\n+            default -> throw new RuntimeException(\"Unexpected protocol family\");\n","filename":"test\/jdk\/java\/nio\/channels\/etc\/ProtocolFamilies.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * service then delays\/lingers for 15 seconds before shuting down. To\n+ * service then delays\/lingers for 15 seconds before shutting down. To\n@@ -57,2 +57,1 @@\n-\n-        SocketChannel sc = Launcher.launchWithSocketChannel(\"EchoService\", service_args);\n+        SocketChannel sc = Launcher.launchWithInetSocketChannel(\"EchoService\", null, service_args);\n","filename":"test\/jdk\/java\/nio\/channels\/spi\/SelectorProvider\/inheritedChannel\/CloseTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-        SocketChannel sc = Launcher.launchWithSocketChannel(ECHO_SERVICE, null);\n+        SocketChannel sc = Launcher.launchWithInetSocketChannel(ECHO_SERVICE, null);\n","filename":"test\/jdk\/java\/nio\/channels\/spi\/SelectorProvider\/inheritedChannel\/EchoTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -88,0 +88,1 @@\n+\n","filename":"test\/jdk\/java\/nio\/channels\/spi\/SelectorProvider\/inheritedChannel\/InheritedChannelTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-\n@@ -3,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +31,3 @@\n+import java.net.SocketAddress;\n+import java.net.StandardProtocolFamily;\n+import java.net.UnixDomainSocketAddress;\n@@ -35,0 +37,3 @@\n+import java.nio.file.Files;\n+\n+import static java.net.StandardProtocolFamily.UNIX;\n@@ -66,1 +71,0 @@\n-\n@@ -68,3 +72,3 @@\n-     * Launch 'java' with specified class using a UnixDomainSocket pair linking calling\n-     * process to the child VM. UnixDomainSocket is a simplified interface to PF_UNIX sockets\n-     * which supports byte a time reads and writes.\n+     * Launch 'java' with specified class. The launched process will inherit\n+     * a connected Unix Domain socket. The remote endpoint will be the\n+     * SocketChannel returned by this method.\n@@ -72,5 +76,15 @@\n-    public static UnixDomainSocket launchWithUnixDomainSocket(String className) throws IOException {\n-        UnixDomainSocket[] socks = UnixDomainSocket.socketpair();\n-        launch(className, null, null, socks[0].fd());\n-        socks[0].close();\n-        return socks[1];\n+    public static SocketChannel launchWithUnixSocketChannel(String className)\n+            throws IOException\n+    {\n+        UnixDomainSocketAddress addr = null;\n+        try (ServerSocketChannel ssc = ServerSocketChannel.open(UNIX)) {\n+            addr = (UnixDomainSocketAddress)ssc.bind(null).getLocalAddress();\n+            SocketChannel sc1 = SocketChannel.open(addr);\n+            try (SocketChannel sc2 = ssc.accept()) {\n+                launch(className, null, null, Util.getFD(sc2));\n+            }\n+            return sc1;\n+        } finally {\n+            if (addr != null)\n+                Files.delete(addr.getPath());\n+        }\n@@ -80,9 +94,0 @@\n-     * Launch specified class with an AF_UNIX socket created externally, and one String arg to child VM\n-     *\/\n-    public static void launchWithUnixDomainSocket(String className, UnixDomainSocket socket, String arg) throws IOException {\n-        String[] args = new String[1];\n-        args[0] = arg;\n-        launch(className, null, args, socket.fd());\n-    }\n-\n-    \/*\n@@ -93,4 +98,8 @@\n-    public static SocketChannel launchWithSocketChannel(String className, String options[], String args[]) throws IOException {\n-        ServerSocketChannel ssc = ServerSocketChannel.open();\n-        ssc.socket().bind(new InetSocketAddress(InetAddress.getLocalHost(), 0));\n-        InetSocketAddress isa = new InetSocketAddress(InetAddress.getLocalHost(),\n+    public static SocketChannel launchWithInetSocketChannel(String className,\n+                                                        String options[],\n+                                                        String... args)\n+            throws IOException\n+    {\n+        try (ServerSocketChannel ssc = ServerSocketChannel.open()) {\n+            ssc.socket().bind(new InetSocketAddress(InetAddress.getLocalHost(), 0));\n+            InetSocketAddress isa = new InetSocketAddress(InetAddress.getLocalHost(),\n@@ -98,10 +107,6 @@\n-        SocketChannel sc1 = SocketChannel.open(isa);\n-        SocketChannel sc2 = ssc.accept();\n-        launch(className, options, args, Util.getFD(sc2));\n-        sc2.close();\n-        ssc.close();\n-        return sc1;\n-    }\n-\n-    public static SocketChannel launchWithSocketChannel(String className, String args[]) throws IOException {\n-        return launchWithSocketChannel(className, null, args);\n+            SocketChannel sc1 = SocketChannel.open(isa);\n+            try (SocketChannel sc2 = ssc.accept()) {\n+                launch(className, options, args, Util.getFD(sc2));\n+            }\n+            return sc1;\n+        }\n@@ -110,2 +115,8 @@\n-    public static SocketChannel launchWithSocketChannel(String className) throws IOException {\n-        return launchWithSocketChannel(className, null);\n+    \/**\n+     * Launch specified class with a SocketChannel created externally.\n+     *\/\n+    public static void launchWithSocketChannel(String className,\n+                                               SocketChannel sc,\n+                                               String[] options,\n+                                               String... args) throws Exception {\n+        launch(className, options, args, Util.getFD(sc));\n@@ -114,1 +125,1 @@\n-    \/*\n+    \/**\n@@ -120,2 +131,4 @@\n-    public static SocketChannel launchWithServerSocketChannel(String className, String options[], String args[])\n-        throws IOException\n+    public static SocketChannel launchWithInetServerSocketChannel(String className,\n+                                                              String[] options,\n+                                                              String... args)\n+            throws IOException\n@@ -123,7 +136,7 @@\n-        ServerSocketChannel ssc = ServerSocketChannel.open();\n-        ssc.socket().bind(new InetSocketAddress(InetAddress.getLocalHost(), 0));\n-        int port = ssc.socket().getLocalPort();\n-        launch(className, options, args, Util.getFD(ssc));\n-        ssc.close();\n-        InetSocketAddress isa = new InetSocketAddress(InetAddress.getLocalHost(), port);\n-        return SocketChannel.open(isa);\n+        try (ServerSocketChannel ssc = ServerSocketChannel.open()) {\n+            ssc.socket().bind(new InetSocketAddress(InetAddress.getLocalHost(), 0));\n+            int port = ssc.socket().getLocalPort();\n+            launch(className, options, args, Util.getFD(ssc));\n+            InetSocketAddress isa = new InetSocketAddress(InetAddress.getLocalHost(), port);\n+            return SocketChannel.open(isa);\n+        }\n@@ -132,2 +145,7 @@\n-    public static SocketChannel launchWithServerSocketChannel(String className, String args[]) throws IOException {\n-        return launchWithServerSocketChannel(className, null, args);\n+    public static SocketChannel launchWithUnixServerSocketChannel(String className) throws IOException {\n+        ServerSocketChannel ssc = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+        ssc.bind(null);\n+        var addr = ssc.getLocalAddress();\n+        launch(className, null, null, Util.getFD(ssc));\n+        ssc.close();\n+        return SocketChannel.open(addr);\n@@ -136,2 +154,9 @@\n-    public static SocketChannel launchWithServerSocketChannel(String className) throws IOException {\n-        return launchWithServerSocketChannel(className, null);\n+    \/**\n+     * Launch specified class with a ServerSocketChannel created externally.\n+     *\/\n+    public static void launchWithServerSocketChannel(String className,\n+                                                     ServerSocketChannel ssc,\n+                                                     String[] options,\n+                                                     String... args)\n+            throws Exception {\n+        launch(className, options, args, Util.getFD(ssc));\n@@ -140,1 +165,1 @@\n-    \/*\n+    \/**\n@@ -148,3 +173,4 @@\n-    public static DatagramChannel launchWithDatagramChannel(String className, String options[], String args[])\n-        throws IOException\n-    {\n+    public static DatagramChannel launchWithDatagramChannel(String className,\n+                                                            String[] options,\n+                                                            String... args)\n+            throws IOException {\n@@ -168,8 +194,0 @@\n-\n-    public static DatagramChannel launchWithDatagramChannel(String className, String args[]) throws IOException {\n-        return launchWithDatagramChannel(className, null, args);\n-    }\n-\n-    public static DatagramChannel launchWithDatagramChannel(String className) throws IOException {\n-        return launchWithDatagramChannel(className, null);\n-    }\n","filename":"test\/jdk\/java\/nio\/channels\/spi\/SelectorProvider\/inheritedChannel\/Launcher.java","additions":80,"deletions":62,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -173,2 +173,2 @@\n-        System.err.println(\"launchWithSocketChannel\");\n-        SocketChannel sc = Launcher.launchWithSocketChannel(TEST_SERVICE, options, arg);\n+        System.err.println(\"launchWithInetSocketChannel\");\n+        SocketChannel sc = Launcher.launchWithInetSocketChannel(TEST_SERVICE, options, arg);\n@@ -184,2 +184,2 @@\n-        System.err.println(\"launchWithServerSocketChannel\");\n-        sc = Launcher.launchWithServerSocketChannel(TEST_SERVICE, options, arg);\n+        System.err.println(\"launchWithInetServerSocketChannel\");\n+        sc = Launcher.launchWithInetServerSocketChannel(TEST_SERVICE, options, arg);\n","filename":"test\/jdk\/java\/nio\/channels\/spi\/SelectorProvider\/inheritedChannel\/StateTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * The test checks that the channel returned by System.inheritiedChannel\n+ * The test checks that the channel returned by System.inheritedChannel\n","filename":"test\/jdk\/java\/nio\/channels\/spi\/SelectorProvider\/inheritedChannel\/StateTestService.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,3 @@\n+import java.io.IOException;\n+import java.net.SocketAddress;\n+import java.net.UnixDomainSocketAddress;\n@@ -26,1 +29,4 @@\n-import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import static java.net.StandardProtocolFamily.UNIX;\n@@ -30,1 +36,1 @@\n- * Make sure that System.inheritedChannel returns null when given a UNIX domain socket\n+ * Make sure that System.inheritedChannel returns the correct type\n@@ -34,0 +40,4 @@\n+    private static final UnixDomainSocketAddress SOCK_ADDR =\n+            UnixDomainSocketAddress.of(Path.of(\"foo.socket\"));\n+\n+    private static boolean passed = true;\n@@ -37,2 +47,2 @@\n-            \/\/ we just want to make sure that System.inheritedChannel either\n-            \/\/ returns a connected channel, or null if it is given a listener\n+            \/\/ we want to make sure that System.inheritedChannel either\n+            \/\/ returns a ServerSocketChannel or a SocketChannel\n@@ -42,4 +52,5 @@\n-                \/\/ socket is writeable\n-                ByteChannel bc = (ByteChannel)channel;\n-                ByteBuffer buf = ByteBuffer.wrap(result.getBytes(ISO_8859_1));\n-                bc.write(buf);\n+                if (channel instanceof SocketChannel) {\n+                    SocketChannel sc = (SocketChannel) channel;\n+                    ByteBuffer buf = ByteBuffer.wrap(result.getBytes(ISO_8859_1));\n+                    sc.write(buf);\n+                }\n@@ -47,6 +58,6 @@\n-                \/\/ in this case the socket is a listener\n-                \/\/ we can't write to it. So, use UnixDatagramSocket\n-                \/\/ to accept a writeable socket\n-                UnixDomainSocket listener = new UnixDomainSocket(0); \/\/ fd 0\n-                UnixDomainSocket sock = listener.accept();\n-                sock.write((int)result.charAt(0));\n+                if (channel instanceof ServerSocketChannel) {\n+                    ServerSocketChannel server = (ServerSocketChannel) channel;\n+                    SocketChannel sc = server.accept();\n+                    ByteBuffer buf = ByteBuffer.wrap(result.getBytes(ISO_8859_1));\n+                    sc.write(buf);\n+                }\n@@ -57,2 +68,0 @@\n-    static boolean passed = true;\n-\n@@ -67,6 +76,0 @@\n-    private static void closeAll(UnixDomainSocket... sockets) {\n-        for (UnixDomainSocket sock : sockets) {\n-            sock.close();\n-        }\n-    }\n-\n@@ -75,10 +78,18 @@\n-        UnixDomainSocket listener = new UnixDomainSocket();\n-        listener.bind(\"foo.socket\");\n-        UnixDomainSocket sock1 = new UnixDomainSocket();\n-        sock1.connect(\"foo.socket\");\n-        UnixDomainSocket sock2 = listener.accept();\n-\n-        Launcher.launchWithUnixDomainSocket(\"UnixDomainChannelTest$Child\", sock2, \"test1\");\n-        int c = sock1.read();\n-        if (c != 'Y') {\n-            System.err.printf(\"test1: failed %d d\\n\", c );\n+        ServerSocketChannel listener = ServerSocketChannel.open(UNIX);\n+        listener.bind(SOCK_ADDR);\n+        SocketChannel sock1 = SocketChannel.open(SOCK_ADDR);\n+        SocketChannel sock2 = listener.accept();\n+        System.out.println(\"test1: launching child\");\n+        Launcher.launchWithSocketChannel(\n+                \"UnixDomainChannelTest$Child\", sock2, null, \"test1\");\n+        ByteBuffer bb = ByteBuffer.allocate(10);\n+        int c = sock1.read(bb);\n+        if (c != 1) {\n+            System.err.printf(\"test1: failed \" +\n+                    \"- unexpected number of bytes read %d d\\n\", c);\n+            passed = false;\n+        }\n+        byte b = bb.get(0);\n+        if (b != 'Y') {\n+            System.err.printf(\"test1: failed \" +\n+                    \"- unexpected byte read %d d\\n\", b);\n@@ -88,0 +99,1 @@\n+        Files.deleteIfExists(SOCK_ADDR.getPath());\n@@ -92,1 +104,4 @@\n-        UnixDomainSocket[] pair = UnixDomainSocket.socketpair();\n+        ServerSocketChannel listener = ServerSocketChannel.open(UNIX);\n+        SocketAddress addr = listener.bind(null).getLocalAddress();\n+        SocketChannel sock1 = SocketChannel.open(addr);\n+        SocketChannel sock2 = listener.accept();\n@@ -94,3 +109,13 @@\n-        Launcher.launchWithUnixDomainSocket(\"UnixDomainChannelTest$Child\", pair[0], \"test2\");\n-        if (pair[1].read() != 'Y') {\n-            System.err.println(\"test2: failed\");\n+        Launcher.launchWithSocketChannel(\n+                \"UnixDomainChannelTest$Child\", sock2, null, \"test2\");\n+        ByteBuffer bb = ByteBuffer.allocate(10);\n+        int c = sock1.read(bb);\n+        if (c != 1) {\n+            System.err.printf(\"test3: failed \" +\n+                    \"- unexpected number of bytes read %d d\\n\", c);\n+            passed = false;\n+        }\n+        byte b = bb.get(0);\n+        if (b != 'Y') {\n+            System.err.printf(\"test3: failed \" +\n+                    \"- unexpected byte read %d d\\n\", b);\n@@ -99,1 +124,2 @@\n-        closeAll(pair[0], pair[1]);\n+        closeAll(listener, sock1, sock2);\n+        Files.deleteIfExists(((UnixDomainSocketAddress)addr).getPath());\n@@ -104,3 +130,3 @@\n-        UnixDomainSocket listener = new UnixDomainSocket();\n-        listener.bind(\"foo.socket\");\n-        UnixDomainSocket sock1 = new UnixDomainSocket();\n+        ServerSocketChannel listener = ServerSocketChannel.open(UNIX);\n+        listener.bind(SOCK_ADDR);\n+        SocketChannel sock1 = SocketChannel.open(UNIX);\n@@ -108,4 +134,14 @@\n-        Launcher.launchWithUnixDomainSocket(\"UnixDomainChannelTest$Child\", listener, \"test3\");\n-        sock1.connect(\"foo.socket\");\n-        if (sock1.read() != 'N') {\n-            System.err.println(\"test3: failed\");\n+        Launcher.launchWithServerSocketChannel(\n+                \"UnixDomainChannelTest$Child\", listener, null, \"test3\");\n+        sock1.connect(SOCK_ADDR);\n+        ByteBuffer bb = ByteBuffer.allocate(10);\n+        int c = sock1.read(bb);\n+        if (c != 1) {\n+            System.err.printf(\"test3: failed \" +\n+                    \"- unexpected number of bytes read %d d\\n\", c);\n+            passed = false;\n+        }\n+        byte b = bb.get(0);\n+        if (b != 'Y') {\n+            System.err.printf(\"test3: failed \" +\n+                    \"- unexpected byte read %d d\\n\", b);\n@@ -115,0 +151,1 @@\n+        Files.deleteIfExists(SOCK_ADDR.getPath());\n@@ -117,0 +154,10 @@\n+    private static void closeAll(Channel... channels) {\n+        for (Channel c : channels) {\n+            try {\n+                if (c != null)\n+                    c.close();\n+            } catch (IOException e) {\n+                throw new RuntimeException(\"Could not close channel \" + c);\n+            }\n+        }\n+    }\n","filename":"test\/jdk\/java\/nio\/channels\/spi\/SelectorProvider\/inheritedChannel\/UnixDomainChannelTest.java","additions":92,"deletions":45,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -1,101 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * A simplified Unix domain socket which can read and write bytes at a time\n- * used for simulating external launchers which use UNIX sockets to talk\n- * the VM.\n- *\/\n-\n-import java.io.IOException;\n-\n-public class UnixDomainSocket {\n-\n-    static {\n-        System.loadLibrary(\"InheritedChannel\");\n-        init();\n-    }\n-\n-    private final int fd;\n-    private volatile String name;\n-\n-    public UnixDomainSocket() throws IOException {\n-        this.fd = create();\n-    }\n-\n-    public void bind(String name) throws IOException {\n-        bind0(fd, name);\n-        this.name = name;\n-    }\n-\n-    public UnixDomainSocket accept() throws IOException {\n-        int newsock = accept0(fd);\n-        return new UnixDomainSocket(newsock);\n-    }\n-\n-    public UnixDomainSocket(int fd) {\n-        this.fd = fd;\n-    }\n-\n-    public void connect(String dest) throws IOException {\n-        connect0(fd, dest);\n-    }\n-\n-    public int read() throws IOException {\n-        return read0(fd);\n-    }\n-\n-    public String name() {\n-        return name;\n-    }\n-\n-    public void write(int w) throws IOException {\n-        write0(fd, w);\n-    }\n-\n-    public void close() {\n-        close0(fd, name); \/\/ close0 will unlink name if non-null\n-    }\n-\n-    public int fd() {\n-        return fd;\n-    }\n-\n-    public String toString() {\n-        return \"UnixDomainSocket: fd=\" + Integer.toString(fd);\n-    }\n-\n-    private static native int create() throws IOException;\n-    private static native void bind0(int fd, String name) throws IOException;\n-    private static native int accept0(int fd) throws IOException;\n-    private static native int connect0(int fd, String name) throws IOException;\n-\n-    \/* read and write bytes with UNIX domain sockets *\/\n-\n-    private static native int read0(int fd) throws IOException;\n-    private static native void write0(int fd, int w) throws IOException;\n-    private static native void close0(int fd, String name);\n-    private static native void init();\n-    public static native UnixDomainSocket[] socketpair();\n-}\n-\n","filename":"test\/jdk\/java\/nio\/channels\/spi\/SelectorProvider\/inheritedChannel\/UnixDomainSocket.java","additions":0,"deletions":101,"binary":false,"changes":101,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,8 +24,0 @@\n-\/*\n- * If the platform has IPv6 we spawn a child process simulating the\n- * effect of being launched from node.js. We check that IPv6 is available in the child\n- * and report back as appropriate.\n- *\/\n-\n-import jdk.test.lib.Utils;\n-import java.io.*;\n@@ -35,0 +27,5 @@\n+import java.net.UnixDomainSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.SocketChannel;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.file.Files;\n@@ -38,0 +35,2 @@\n+import static java.net.StandardProtocolFamily.UNIX;\n+\n@@ -40,9 +39,9 @@\n-    static boolean hasIPv6() throws Exception {\n-        Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n-        for (NetworkInterface netint : Collections.list(nets)) {\n-            Enumeration<InetAddress> inetAddresses = netint.getInetAddresses();\n-            for (InetAddress inetAddress : Collections.list(inetAddresses)) {\n-                if (inetAddress instanceof Inet6Address) {\n-                    return true;\n-                }\n-            }\n+    public static class Child1 {\n+        public static void main(String[] args) throws Exception {\n+            SocketChannel chan = (SocketChannel)System.inheritedChannel();\n+            ByteBuffer bb = ByteBuffer.allocate(2);\n+            bb.put((byte)'X');\n+            bb.put((byte)'Y');\n+            bb.flip();\n+            chan.write(bb);\n+            chan.close();\n@@ -50,1 +49,0 @@\n-        return false;\n@@ -53,1 +51,1 @@\n-    public static class Child {\n+    public static class Child2 {\n@@ -55,6 +53,11 @@\n-            System.out.write('X');\n-            System.out.flush();\n-            if (hasIPv6()) {\n-                System.out.println(\"Y\"); \/\/ GOOD\n-            } else\n-                System.out.println(\"N\"); \/\/ BAD\n+            ServerSocketChannel server = (ServerSocketChannel)System.inheritedChannel();\n+            SocketChannel chan = server.accept();\n+            UnixDomainSocketAddress sa = (UnixDomainSocketAddress)server.getLocalAddress();\n+            Files.delete(sa.getPath());\n+            server.close();\n+            ByteBuffer bb = ByteBuffer.allocate(2);\n+            bb.put((byte)'X');\n+            bb.put((byte)'Y');\n+            bb.flip();\n+            chan.write(bb);\n+            chan.close();\n@@ -65,3 +68,5 @@\n-\n-        if (!hasIPv6()) {\n-            return; \/\/ can only test if IPv6 is present\n+        SocketChannel sc = Launcher.launchWithUnixSocketChannel(\"UnixSocketTest$Child1\");\n+        ByteBuffer bb = ByteBuffer.allocate(10);\n+        sc.read(bb);\n+        if (bb.get(0) != 'X') {\n+            System.exit(-2);\n@@ -69,2 +74,9 @@\n-        UnixDomainSocket sock = Launcher.launchWithUnixDomainSocket(\"UnixSocketTest$Child\");\n-        if (sock.read() != 'X') {\n+        if (bb.get(1) != 'Y') {\n+            System.exit(-2);\n+        }\n+        sc.close();\n+\n+        sc = Launcher.launchWithUnixServerSocketChannel(\"UnixSocketTest$Child2\");\n+        bb.clear();\n+        sc.read(bb);\n+        if (bb.get(0) != 'X') {\n@@ -73,1 +85,1 @@\n-        if (sock.read() != 'Y') {\n+        if (bb.get(1) != 'Y') {\n","filename":"test\/jdk\/java\/nio\/channels\/spi\/SelectorProvider\/inheritedChannel\/UnixSocketTest.java","additions":44,"deletions":32,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include <sys\/un.h>\n@@ -43,3 +42,0 @@\n-static jclass unixSocketClass;\n-static jmethodID unixSocketCtor;\n-\n@@ -88,1 +84,0 @@\n-\n@@ -148,1 +143,1 @@\n-     * get the list of open file descriptos we read through \/proc\/self\/fd (\/dev\/fd)\n+     * get the list of open file descriptors we read through \/proc\/self\/fd (\/dev\/fd)\n@@ -187,128 +182,0 @@\n-\n-JNIEXPORT void JNICALL Java_UnixDomainSocket_init(JNIEnv *env, jclass cls) {\n-    CHECK(unixSocketClass = (*env)->FindClass(env, \"UnixDomainSocket\"));\n-    CHECK(unixSocketClass = (*env)->NewGlobalRef(env, unixSocketClass));\n-    CHECK(unixSocketCtor = (*env)->GetMethodID(env, unixSocketClass, \"<init>\", \"(I)V\"));\n-}\n-\n-\/*\n- * Class:     UnixDomainSocket\n- * Method:    socketpair\n- * Signature: ()[LUnixDomainSocket\n- *\/\n-JNIEXPORT jobjectArray JNICALL Java_UnixDomainSocket_socketpair\n-  (JNIEnv *env, jclass cls)\n-{\n-    int fds[2];\n-    jobject socket;\n-    jobjectArray result = (*env)->NewObjectArray(env, 2, unixSocketClass, 0);\n-    if (socketpair(AF_UNIX, SOCK_STREAM, 0, fds) < 0) {\n-        perror(\"socketpair\");\n-        return result;\n-    }\n-    socket = (*env)->NewObject(env, unixSocketClass, unixSocketCtor, fds[0]);\n-    (*env)->SetObjectArrayElement(env, result, 0, socket);\n-    socket = (*env)->NewObject(env, unixSocketClass, unixSocketCtor, fds[1]);\n-    (*env)->SetObjectArrayElement(env, result, 1, socket);\n-    return result;\n-}\n-\n-JNIEXPORT jint JNICALL Java_UnixDomainSocket_create\n-  (JNIEnv *env, jclass cls)\n-{\n-    int sock = socket(AF_UNIX, SOCK_STREAM, 0);\n-    if (sock == -1) {\n-        ThrowException(env, \"java\/io\/IOException\", \"socket create error\");\n-    }\n-    return sock;\n-}\n-\n-JNIEXPORT void JNICALL Java_UnixDomainSocket_bind0\n-  (JNIEnv *env, jclass cls, jint sock, jstring name)\n-{\n-    struct sockaddr_un addr;\n-    const char *nameUtf = (*env)->GetStringUTFChars(env, name, NULL);\n-    int ret = -1;\n-    int length = sizeof(addr.sun_path);\n-    unlink(nameUtf);\n-    memset(&addr, 0, sizeof(addr));\n-    addr.sun_family = AF_UNIX;\n-    strncpy(addr.sun_path, nameUtf, length);\n-    addr.sun_path[length - 1] = '\\0';\n-    ret = bind(sock, (const struct sockaddr*)&addr, sizeof(addr));\n-    if (ret == -1) {\n-        ThrowException(env, \"java\/io\/IOException\", \"socket bind error\");\n-    }\n-    ret = listen(sock, 5);\n-    if (ret == -1) {\n-        ThrowException(env, \"java\/io\/IOException\", \"socket bind error\");\n-    }\n-    (*env)->ReleaseStringUTFChars(env, name, nameUtf);\n-}\n-\n-JNIEXPORT jint JNICALL Java_UnixDomainSocket_accept0\n-  (JNIEnv *env, jclass cls, jint sock)\n-{\n-    struct sockaddr_storage addr;\n-    socklen_t len = sizeof(addr);\n-    int ret = accept(sock, (struct sockaddr *)&addr, &len);\n-    if (ret == -1)\n-        ThrowException(env, \"java\/io\/IOException\", \"socket accept error\");\n-    return ret;\n-}\n-\n-JNIEXPORT void JNICALL Java_UnixDomainSocket_connect0\n-  (JNIEnv *env, jclass cls, jint fd, jstring name)\n-{\n-    struct sockaddr_un addr;\n-    const char *nameUtf = (*env)->GetStringUTFChars(env, name, NULL);\n-    int ret = -1;\n-    int length = sizeof(addr.sun_path);\n-    memset(&addr, 0, sizeof(addr));\n-    addr.sun_family = AF_UNIX;\n-    strncpy(addr.sun_path, nameUtf, length);\n-    addr.sun_path[length - 1] = '\\0';\n-    ret = connect(fd, (const struct sockaddr*)&addr, sizeof(addr));\n-    if (ret == -1) {\n-        ThrowException(env, \"java\/io\/IOException\", \"socket connect error\");\n-    }\n-    (*env)->ReleaseStringUTFChars(env, name, nameUtf);\n-}\n-\n-\n-JNIEXPORT jint JNICALL Java_UnixDomainSocket_read0\n-  (JNIEnv *env, jclass cls, jint fd)\n-{\n-    int ret;\n-    unsigned char res;\n-    ret = read(fd, &res, 1);\n-    if (ret == 0)\n-        return -1; \/* EOF *\/\n-    else if (ret < 0) {\n-        ThrowException(env, \"java\/io\/IOException\", \"read error\");\n-        return -1;\n-    }\n-    return res;\n-}\n-\n-JNIEXPORT void JNICALL Java_UnixDomainSocket_write0\n-  (JNIEnv *env, jclass cls, jint fd, jint byte)\n-{\n-    int ret;\n-    unsigned char w = (unsigned char)byte;\n-    ret = write(fd, &w, 1);\n-    if (ret < 0) {\n-        ThrowException(env, \"java\/io\/IOException\", \"write error\");\n-    }\n-}\n-\n-JNIEXPORT void JNICALL Java_UnixDomainSocket_close0\n-  (JNIEnv *env, jclass cls, jint fd, jstring name)\n-{\n-    close(fd);\n-    if (name != NULL) {\n-        const char *nameUtf = (*env)->GetStringUTFChars(env, name, NULL);\n-        unlink(nameUtf);\n-        (*env)->ReleaseStringUTFChars(env, name, nameUtf);\n-    }\n-}\n","filename":"test\/jdk\/java\/nio\/channels\/spi\/SelectorProvider\/inheritedChannel\/libInheritedChannel.c","additions":1,"deletions":134,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -0,0 +1,329 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8245194\n+ * @library \/test\/lib\n+ * @run main\/othervm Bind\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.nio.channels.*;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import jtreg.SkippedException;\n+\n+\/**\n+ * Check that all bind variations work\n+ *\/\n+public class Bind {\n+\n+    static Path spath, cpath;\n+\n+    static UnixDomainSocketAddress sAddr, cAddr, UNNAMED, nullAddr;\n+    static ServerSocketChannel server;\n+    static SocketChannel client, accept1;\n+\n+    public static void main(String args[]) throws Exception {\n+        checkSupported();\n+        spath = Path.of(\"server.sock\");\n+        cpath = Path.of(\"client.sock\");\n+        sAddr = UnixDomainSocketAddress.of(spath);\n+        cAddr = UnixDomainSocketAddress.of(cpath);\n+        nullAddr = UnixDomainSocketAddress.of(\"\");\n+        UNNAMED = nullAddr;\n+        runTests();\n+    }\n+\n+    static void checkSupported() {\n+        try {\n+            SocketChannel.open(StandardProtocolFamily.UNIX).close();\n+        } catch (UnsupportedOperationException e) {\n+            throw new SkippedException(\"Unix domain channels not supported\");\n+        } catch (Exception e) {\n+            \/\/ continue test to see what problem is\n+        }\n+    }\n+\n+    static interface ThrowingRunnable {\n+        public void run() throws Exception;\n+    }\n+\n+    static void init() throws IOException {\n+        Files.deleteIfExists(cpath);\n+        Files.deleteIfExists(spath);\n+        client = null; server = null; accept1 = null;\n+    }\n+\n+    static void checkNormal(ThrowingRunnable r) {\n+        try {\n+            init();\n+            r.run();\n+            System.out.println(\"PASS:\");\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            cleanup();\n+        }\n+    }\n+\n+    static void checkException(Class<? extends Exception> expected, ThrowingRunnable r) {\n+        try {\n+            init();\n+            r.run();\n+            throw new RuntimeException(\"Exception expected\");\n+        } catch (Exception e) {\n+            if (!expected.isAssignableFrom(e.getClass())) {\n+                String msg = \"Expected: \" + expected + \" Got: \" + e.getClass();\n+                throw new RuntimeException(msg);\n+            }\n+            System.out.println(\"PASS: Got \" + e);\n+        } finally {\n+            cleanup();\n+        }\n+    }\n+\n+    static void cleanup() {\n+        try {\n+            if (server != null)\n+                server.close();\n+            if (client != null)\n+                client.close();\n+            if (accept1 != null)\n+                accept1.close();\n+        } catch (IOException e) {}\n+    }\n+\n+    static void assertClientAddress(SocketAddress a) {\n+        assertAddress(a, cAddr, \"client\");\n+    }\n+\n+    static void assertServerAddress(SocketAddress a) {\n+        assertAddress(a, sAddr, \"server\");\n+    }\n+\n+    static void assertAddress(SocketAddress a, UnixDomainSocketAddress a1, String s) {\n+        if (!(a instanceof UnixDomainSocketAddress)) {\n+            throw new RuntimeException(\"wrong address type\");\n+        }\n+        UnixDomainSocketAddress ua = (UnixDomainSocketAddress)a;\n+        if (!a.equals(a1))\n+            throw new RuntimeException(\"this is not the \" + s + \" address\");\n+    }\n+\n+    static void assertEquals(Object a, Object b) {\n+        if (!a.equals(b))\n+            throw new RuntimeException(\"identity check failed\");\n+    }\n+\n+    public static void runTests() throws IOException {\n+        checkNormal(() -> {\n+            client = SocketChannel.open(StandardProtocolFamily.UNIX);\n+            client.bind(cAddr);\n+        });\n+        checkNormal(() -> {\n+            server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+            server.bind(sAddr);\n+        });\n+        \/\/ Repeat first two to make sure they are repeatable\n+        checkNormal(() -> {\n+            client = SocketChannel.open(StandardProtocolFamily.UNIX);\n+            client.bind(cAddr);\n+        });\n+        checkNormal(() -> {\n+            server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+            server.bind(sAddr);\n+        });\n+        \/\/ address with space should work\n+        checkNormal(() -> {\n+            server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+            UnixDomainSocketAddress usa =  UnixDomainSocketAddress.of(\"with space\"); \/\/ relative to CWD\n+            Files.deleteIfExists(usa.getPath());\n+            server.bind(usa);\n+            client = SocketChannel.open(usa);\n+            Files.delete(usa.getPath());\n+            assertAddress(client.getRemoteAddress(), usa, \"address\");\n+        });\n+        \/\/ client bind to null: allowed\n+        checkNormal(() -> {\n+            client = SocketChannel.open(StandardProtocolFamily.UNIX);\n+            client.bind(null);\n+            SocketAddress a = client.getLocalAddress();\n+            assertAddress(a, nullAddr, \"null address\");\n+            assertEquals(a, UNNAMED);\n+        });\n+        \/\/ client bind to UNNAMED: allowed\n+        checkNormal(() -> {\n+            client = SocketChannel.open(StandardProtocolFamily.UNIX);\n+            client.bind(UNNAMED);\n+            SocketAddress a = client.getLocalAddress();\n+            assertAddress(a, nullAddr, \"null address\");\n+            assertEquals(a, UNNAMED);\n+        });\n+        \/\/ server bind to null: should bind to a local address\n+        checkNormal(() -> {\n+            server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+            server.bind(null);\n+            UnixDomainSocketAddress usa = (UnixDomainSocketAddress)server.getLocalAddress();\n+            if (usa.getPath().toString().isEmpty())\n+                throw new RuntimeException(\"expected non zero address length\");\n+            System.out.println(\"Null server address: \" + server.getLocalAddress());\n+        });\n+        \/\/ server no bind : not allowed\n+        checkException(\n+            NotYetBoundException.class, () -> {\n+                server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+                server.accept();\n+            }\n+        );\n+\n+        \/\/ client implicit bind and connect\n+        checkNormal(() -> {\n+            server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+            client = SocketChannel.open(StandardProtocolFamily.UNIX);\n+            server.bind(sAddr);\n+            client.connect(sAddr);\n+            SocketAddress cAddr = client.getLocalAddress();\n+            assertAddress(cAddr, nullAddr, \"null address\");\n+            assertEquals(cAddr, UNNAMED);\n+            assertServerAddress(server.getLocalAddress());\n+        });\n+        \/\/ client null bind and connect (check all addresses)\n+        checkNormal(() -> {\n+            server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+            client = SocketChannel.open(StandardProtocolFamily.UNIX);\n+            server.bind(sAddr);\n+            client.bind(null);\n+            client.connect(sAddr);\n+            assertAddress(client.getLocalAddress(), UNNAMED, \"unnamed address\");\n+            assertServerAddress(server.getLocalAddress());\n+        });\n+        \/\/ client explicit bind and connect (check all addresses)\n+        checkNormal(() -> {\n+            server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+            client = SocketChannel.open(StandardProtocolFamily.UNIX);\n+            server.bind(sAddr);\n+            client.bind(cAddr);\n+            client.connect(sAddr);\n+            accept1 = server.accept();\n+            assertClientAddress(client.getLocalAddress());\n+            assertServerAddress(server.getLocalAddress());\n+            assertAddress(client.getRemoteAddress(), sAddr, \"client's remote server address\");\n+            assertAddress(accept1.getLocalAddress(), sAddr, \"accepted local address (server)\");\n+            assertAddress(accept1.getRemoteAddress(), cAddr, \"accepted remote address (client)\");\n+        });\n+        \/\/ server multiple bind : not allowed\n+        checkException(\n+            AlreadyBoundException.class, () -> {\n+                server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+                server.bind(sAddr);\n+                server.bind(sAddr);\n+            }\n+        );\n+        \/\/ client multiple bind : not allowed\n+        checkException(\n+            AlreadyBoundException.class, () -> {\n+                client = SocketChannel.open(StandardProtocolFamily.UNIX);\n+                client.bind(cAddr);\n+                client.bind(cAddr);\n+            }\n+        );\n+        \/\/ client multiple bind to different addresses: not allowed\n+        checkException(\n+            AlreadyBoundException.class, () -> {\n+                client = SocketChannel.open(StandardProtocolFamily.UNIX);\n+                client.bind(cAddr);\n+                client.bind(sAddr);\n+            }\n+        );\n+        \/\/ client multiple bind to differnt addresses, incl null: not allowed\n+        checkException(\n+            AlreadyBoundException.class, () -> {\n+                client = SocketChannel.open(StandardProtocolFamily.UNIX);\n+                client.bind(null);\n+                client.bind(cAddr);\n+            }\n+        );\n+\n+        \/\/ server bind to existing name: not allowed\n+\n+        checkException(\n+            BindException.class, () -> {\n+                var path = Files.createFile(Path.of(\"moo.sock\"));\n+                var addr = UnixDomainSocketAddress.of(path);\n+                server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+                try {\n+                    server.bind(addr);\n+                } finally {\n+                    Files.deleteIfExists(path);\n+                }\n+            }\n+        );\n+\n+\n+        \/\/ client bind to existing name: not allowed\n+        checkException(\n+            BindException.class, () -> {\n+                var path = Path.of(\"temp.sock\");\n+                Files.deleteIfExists(path);\n+                Files.createFile(path);\n+                var addr = UnixDomainSocketAddress.of(path);\n+                client = SocketChannel.open(StandardProtocolFamily.UNIX);\n+                try {\n+                    client.bind(addr);\n+                } finally {\n+                    Files.deleteIfExists(path);\n+                }\n+            }\n+        );\n+\n+        \/\/ bind and connect to name of close to max size\n+        checkNormal(() -> {\n+            int len = 100;\n+            char[] chars = new char[len];\n+            Arrays.fill(chars, 'x');\n+            String name = new String(chars);\n+            UnixDomainSocketAddress address = UnixDomainSocketAddress.of(name);\n+            ServerSocketChannel server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+            server.bind(address);\n+            SocketChannel client = SocketChannel.open(address);\n+            assertAddress(server.getLocalAddress(), address, \"server\");\n+            assertAddress(client.getRemoteAddress(), address, \"client\");\n+            Files.delete(address.getPath());\n+        });\n+\n+        \/\/ implicit server bind\n+        checkNormal(() -> {\n+            server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+            server.bind(null);\n+            UnixDomainSocketAddress usa = (UnixDomainSocketAddress)server.getLocalAddress();\n+            client = SocketChannel.open(usa);\n+            accept1 = server.accept();\n+            assertAddress(client.getRemoteAddress(), usa, \"server\");\n+            Files.delete(usa.getPath());\n+        });\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/Bind.java","additions":329,"deletions":0,"binary":false,"changes":329,"status":"added"},{"patch":"@@ -0,0 +1,1243 @@\n+\/*\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8245194\n+ * @run testng\/othervm IOExchanges\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.nio.channels.*;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static java.lang.System.out;\n+import static java.net.StandardProtocolFamily.*;\n+import static java.nio.channels.SelectionKey.OP_ACCEPT;\n+import static java.nio.channels.SelectionKey.OP_READ;\n+import static java.nio.channels.SelectionKey.OP_WRITE;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+public class IOExchanges {\n+    static boolean unixDomainSupported = true;\n+\n+\n+    @BeforeTest()\n+    public void setup() {\n+        try {\n+            SocketChannel.open(UNIX);\n+        } catch (IOException | UnsupportedOperationException e) {\n+            unixDomainSupported = false;\n+            out.println(\"Unix domain channels not supported\");\n+        }\n+    }\n+\n+    static SocketChannel openSocketChannel(ProtocolFamily family)\n+            throws IOException {\n+        return family == UNIX ? SocketChannel.open(family)\n+                : SocketChannel.open();\n+    }\n+\n+    static ServerSocketChannel openServerSocketChannel(ProtocolFamily family)\n+             throws IOException {\n+        return family == UNIX ? ServerSocketChannel.open(family)\n+                     : ServerSocketChannel.open();\n+    }\n+\n+    public static void deleteFile(SocketAddress addr) throws Exception {\n+        if (addr instanceof UnixDomainSocketAddress) {\n+            Files.deleteIfExists(((UnixDomainSocketAddress) addr).getPath());\n+        }\n+    }\n+\n+    \/*\n+     The following, non-exhaustive set, of tests exercise different combinations\n+     of blocking and non-blocking accept\/connect calls along with I\/O\n+     operations, that exchange a single byte. The intent it to test a reasonable\n+     set of blocking and non-blocking scenarios.\n+\n+     The individual test method names follow their test scenario.\n+        [BAccep|SELNBAccep|SPINNBAccep] - Accept either:\n+                         blocking, select-non-blocking, spinning-non-blocking\n+        [BConn|NBConn] - blocking connect \/ non-blocking connect\n+        [BIO|NBIO]     - blocking \/ non-blocking I\/O operations (read\/write)\n+        [WR|RW] - connecting thread write\/accepting thread reads first, and vice-versa\n+        [Id]    - unique test Id\n+\n+        BAccep_BConn_BIO_WR_1\n+        BAccep_BConn_BIO_RW_2\n+        SELNBAccep_BConn_BIO_WR_3\n+        SELNBAccep_BConn_BIO_RW_4\n+        SPINNBAccep_BConn_BIO_WR_5\n+        SPINNBAccep_BConn_BIO_RW_6\n+        BAccep_NBConn_BIO_WR_7\n+        BAccep_NBConn_BIO_RW_8\n+        SELNBAccep_NBConn_BIO_WR_9\n+        SELNBAccep_NBConn_BIO_RW_10\n+        SPINNBAccep_NBConn_BIO_WR_11\n+        SPINNBAccep_NBConn_BIO_RW_12\n+\n+        BAccep_BConn_NBIO_WR_1a         \/\/ Non-Blocking I\/O\n+        BAccep_BConn_NBIO_RW_2a\n+        SELNBAccep_BConn_NBIO_WR_3a\n+        SELNBAccep_BConn_NBIO_RW_4a\n+        SPINNBAccep_BConn_NBIO_WR_5a\n+        SPINNBAccep_BConn_NBIO_RW_6a\n+        BAccep_NBConn_NBIO_WR_7a\n+        BAccep_NBConn_NBIO_RW_8a\n+        SELNBAccep_NBConn_NBIO_WR_9a\n+        SELNBAccep_NBConn_NBIO_RW_10a\n+        SPINBAccep_NBConn_NBIO_WR_11a\n+        SPINBAccep_NBConn_NBIO_RW_12a\n+    *\/\n+\n+    @DataProvider(name = \"family\")\n+    public Object[][] family() {\n+        return unixDomainSupported ?\n+                new Object[][] {\n+                    { UNIX },\n+                    { INET }}\n+                : new Object[][] {\n+                    { INET }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void BAccep_BConn_BIO_WR_1(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            TestThread t = TestThread.of(\"t1\", () -> {\n+                try (SocketChannel sc = openSocketChannel(family)) {\n+                    assertTrue(sc.connect(addr));\n+                    ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x01).flip();\n+                    assertEquals(sc.write(bb), 1);\n+                    out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                    assertEquals(sc.read(bb.clear()), -1);\n+                }\n+            });\n+            t.start();\n+\n+            try (SocketChannel sc = ssc.accept()) {\n+                ByteBuffer bb = ByteBuffer.allocate(10);\n+                assertEquals(sc.read(bb), 1);\n+                out.printf(\"read:  0x%x%n\", bb.get(0));\n+                assertEquals(bb.get(0), 0x01);\n+            }\n+            t.awaitCompletion();\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void BAccep_BConn_BIO_RW_2(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            TestThread t = TestThread.of(\"t2\", () -> {\n+                try (SocketChannel sc = openSocketChannel(family)) {\n+                    assertTrue(sc.connect(addr));\n+                    ByteBuffer bb = ByteBuffer.allocate(10);\n+                    assertEquals(sc.read(bb), 1);\n+                    out.printf(\"read:  0x%x%n\", bb.get(0));\n+                    assertEquals(bb.get(0), 0x02);\n+                }\n+            });\n+            t.start();\n+\n+            try (SocketChannel sc = ssc.accept()) {\n+                ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x02).flip();\n+                assertEquals(sc.write(bb), 1);\n+                out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                assertEquals(sc.read(bb.clear()), -1);\n+            }\n+            t.awaitCompletion();\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SELNBAccep_BConn_BIO_WR_3(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family);\n+             Selector selector = Selector.open()) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            TestThread t = TestThread.of(\"t3\", () -> {\n+                try (SocketChannel sc = openSocketChannel(family)) {\n+                    assertTrue(sc.connect(addr));\n+                    ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x03).flip();\n+                    assertEquals(sc.write(bb), 1);\n+                    out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                    assertEquals(sc.read(bb.clear()), -1);\n+                }\n+            });\n+            t.start();\n+\n+            ssc.configureBlocking(false).register(selector, OP_ACCEPT);\n+            assertEquals(selector.select(), 1);\n+\n+            try (SocketChannel sc = ssc.accept()) {\n+                ByteBuffer bb = ByteBuffer.allocate(10);\n+                assertEquals(sc.read(bb), 1);\n+                out.printf(\"read:  0x%x%n\", bb.get(0));\n+                assertEquals(bb.get(0), 0x03);\n+            }\n+            t.awaitCompletion();\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SELNBAccep_BConn_BIO_RW_4(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family);\n+             Selector selector = Selector.open()) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            TestThread t = TestThread.of(\"t4\", () -> {\n+                try (SocketChannel sc = openSocketChannel(family)) {\n+                    assertTrue(sc.connect(addr));\n+                    ByteBuffer bb = ByteBuffer.allocate(10);\n+                    assertEquals(sc.read(bb), 1);\n+                    out.printf(\"read:  0x%x%n\", bb.get(0));\n+                    assertEquals(bb.get(0), 0x04);\n+                }\n+            });\n+            t.start();\n+\n+            ssc.configureBlocking(false).register(selector, OP_ACCEPT);\n+            assertEquals(selector.select(), 1);\n+\n+            try (SocketChannel sc = ssc.accept()) {\n+                ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x04).flip();\n+                assertEquals(sc.write(bb), 1);\n+                out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                assertEquals(sc.read(bb.clear()), -1);\n+\n+            }\n+            t.awaitCompletion();\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SPINNBAccep_BConn_BIO_WR_5(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            TestThread t = TestThread.of(\"t5\", () -> {\n+                try (SocketChannel sc = openSocketChannel(family)) {\n+                    assertTrue(sc.connect(addr));\n+                    ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x05).flip();\n+                    assertEquals(sc.write(bb), 1);\n+                    out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                    assertEquals(sc.read(bb.clear()), -1);\n+                }\n+            });\n+            t.start();\n+\n+            SocketChannel accepted;\n+            for (; ; ) {\n+                accepted = ssc.accept();\n+                if (accepted != null) {\n+                    out.println(\"accepted new connection\");\n+                    break;\n+                }\n+                Thread.onSpinWait();\n+            }\n+\n+            try (SocketChannel sc = accepted) {\n+                ByteBuffer bb = ByteBuffer.allocate(10);\n+                assertEquals(sc.read(bb), 1);\n+                out.printf(\"read:  0x%x%n\", bb.get(0));\n+                assertEquals(bb.get(0), 0x05);\n+            }\n+            t.awaitCompletion();\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SPINNBAccep_BConn_BIO_RW_6(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            TestThread t = TestThread.of(\"t6\", () -> {\n+                try (SocketChannel sc = openSocketChannel(family)) {\n+                    assertTrue(sc.connect(addr));\n+                    ByteBuffer bb = ByteBuffer.allocate(10);\n+                    assertEquals(sc.read(bb), 1);\n+                    out.printf(\"read:  0x%x%n\", bb.get(0));\n+                    assertEquals(bb.get(0), 0x06);\n+                }\n+            });\n+            t.start();\n+\n+            SocketChannel accepted;\n+            for (; ; ) {\n+                accepted = ssc.accept();\n+                if (accepted != null) {\n+                    out.println(\"accepted new connection\");\n+                    break;\n+                }\n+                Thread.onSpinWait();\n+            }\n+\n+            try (SocketChannel sc = accepted) {\n+                ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x06).flip();\n+                assertEquals(sc.write(bb), 1);\n+                out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                assertEquals(sc.read(bb.clear()), -1);\n+\n+            }\n+            t.awaitCompletion();\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    \/\/ Similar to the previous six scenarios, but with same-thread\n+    \/\/ non-blocking connect.\n+\n+    @Test(dataProvider = \"family\")\n+    public void BAccep_NBConn_BIO_WR_7(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            try (SocketChannel sc = openSocketChannel(family)) {\n+                sc.configureBlocking(false);\n+                sc.connect(addr);\n+\n+                try (SocketChannel sc2 = ssc.accept()) {\n+                    assertTrue(sc.finishConnect());\n+                    sc.configureBlocking(true);\n+                    TestThread t = TestThread.of(\"t7\", () -> {\n+                        ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x07).flip();\n+                        assertEquals(sc.write(bb), 1);\n+                        out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                        assertEquals(sc.read(bb.clear()), -1);\n+                    });\n+                    t.start();\n+\n+                    ByteBuffer bb = ByteBuffer.allocate(10);\n+                    assertEquals(sc2.read(bb), 1);\n+                    out.printf(\"read:  0x%x%n\", bb.get(0));\n+                    assertEquals(bb.get(0), 0x07);\n+                    sc2.shutdownOutput();\n+                    t.awaitCompletion();\n+                }\n+            }\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void BAccep_NBConn_BIO_RW_8(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            try (SocketChannel sc = openSocketChannel(family)) {\n+                sc.configureBlocking(false);\n+                sc.connect(addr);\n+\n+                try (SocketChannel sc2 = ssc.accept()) {\n+                    assertTrue(sc.finishConnect());\n+                    sc.configureBlocking(true);\n+                    TestThread t = TestThread.of(\"t8\", () -> {\n+                        ByteBuffer bb = ByteBuffer.allocate(10);\n+                        assertEquals(sc.read(bb), 1);\n+                        out.printf(\"read:  0x%x%n\", bb.get(0));\n+                        assertEquals(bb.get(0), 0x08);\n+                        sc.shutdownOutput();\n+                    });\n+                    t.start();\n+\n+                    ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x08).flip();\n+                    assertEquals(sc2.write(bb), 1);\n+                    out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                    assertEquals(sc2.read(bb.clear()), -1);\n+                    t.awaitCompletion();\n+                }\n+            }\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SELNBAccep_NBConn_BIO_WR_9(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            try (SocketChannel sc = openSocketChannel(family);\n+                 Selector selector = Selector.open()) {\n+                sc.configureBlocking(false);\n+                sc.connect(addr);\n+\n+                ssc.configureBlocking(false).register(selector, OP_ACCEPT);\n+                assertEquals(selector.select(), 1);\n+\n+                try (SocketChannel sc2 = ssc.accept()) {\n+                    assertTrue(sc.finishConnect());\n+                    sc.configureBlocking(true);\n+                    TestThread t = TestThread.of(\"t9\", () -> {\n+                        ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x09).flip();\n+                        assertEquals(sc.write(bb), 1);\n+                        out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                        assertEquals(sc.read(bb.clear()), -1);\n+                    });\n+                    t.start();\n+\n+                    ByteBuffer bb = ByteBuffer.allocate(10);\n+                    assertEquals(sc2.read(bb), 1);\n+                    out.printf(\"read:  0x%x%n\", bb.get(0));\n+                    assertEquals(bb.get(0), 0x09);\n+                    sc2.shutdownOutput();\n+                    t.awaitCompletion();\n+                }\n+            }\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SELNBAccep_NBConn_BIO_RW_10(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            try (SocketChannel sc = openSocketChannel(family);\n+                 Selector selector = Selector.open()) {\n+                sc.configureBlocking(false);\n+                sc.connect(addr);\n+\n+                ssc.configureBlocking(false).register(selector, OP_ACCEPT);\n+                assertEquals(selector.select(), 1);\n+\n+                try (SocketChannel sc2 = ssc.accept()) {\n+                    assertTrue(sc.finishConnect());\n+                    sc.configureBlocking(true);\n+                    TestThread t = TestThread.of(\"t10\", () -> {\n+                        ByteBuffer bb = ByteBuffer.allocate(10);\n+                        assertEquals(sc.read(bb), 1);\n+                        out.printf(\"read:  0x%x%n\", bb.get(0));\n+                        assertEquals(bb.get(0), 0x10);\n+                        sc.shutdownOutput();\n+                    });\n+                    t.start();\n+\n+                    ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x10).flip();\n+                    assertEquals(sc2.write(bb), 1);\n+                    out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                    assertEquals(sc2.read(bb.clear()), -1);\n+                    t.awaitCompletion();\n+                }\n+            }\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SPINNBAccep_NBConn_BIO_WR_11(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            try (SocketChannel sc = openSocketChannel(family)) {\n+                sc.configureBlocking(false);\n+                sc.connect(addr);\n+\n+                SocketChannel accepted;\n+                for (; ; ) {\n+                    accepted = ssc.accept();\n+                    if (accepted != null) {\n+                        out.println(\"accepted new connection\");\n+                        break;\n+                    }\n+                    Thread.onSpinWait();\n+                }\n+\n+                try (SocketChannel sc2 = accepted) {\n+                    assertTrue(sc.finishConnect());\n+                    sc.configureBlocking(true);\n+                    TestThread t = TestThread.of(\"t11\", () -> {\n+                        ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x11).flip();\n+                        assertEquals(sc.write(bb), 1);\n+                        out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                        assertEquals(sc.read(bb.clear()), -1);\n+                    });\n+                    t.start();\n+\n+                    ByteBuffer bb = ByteBuffer.allocate(10);\n+                    assertEquals(sc2.read(bb), 1);\n+                    out.printf(\"read:  0x%x%n\", bb.get(0));\n+                    assertEquals(bb.get(0), 0x11);\n+                    sc2.shutdownOutput();\n+                    t.awaitCompletion();\n+                }\n+            }\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SPINNBAccep_NBConn_BIO_RW_12(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            try (SocketChannel sc = openSocketChannel(family)) {\n+                sc.configureBlocking(false);\n+                sc.connect(addr);\n+\n+                SocketChannel accepted;\n+                for (; ; ) {\n+                    accepted = ssc.accept();\n+                    if (accepted != null) {\n+                        out.println(\"accepted new connection\");\n+                        break;\n+                    }\n+                    Thread.onSpinWait();\n+                }\n+\n+                try (SocketChannel sc2 = accepted) {\n+                    assertTrue(sc.finishConnect());\n+                    sc.configureBlocking(true);\n+                    TestThread t = TestThread.of(\"t12\", () -> {\n+                        ByteBuffer bb = ByteBuffer.allocate(10);\n+                        assertEquals(sc.read(bb), 1);\n+                        out.printf(\"read:  0x%x%n\", bb.get(0));\n+                        assertEquals(bb.get(0), 0x12);\n+                        sc.shutdownOutput();\n+                    });\n+                    t.start();\n+\n+                    ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x12).flip();\n+                    assertEquals(sc2.write(bb), 1);\n+                    out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                    assertEquals(sc2.read(bb.clear()), -1);\n+                    t.awaitCompletion();\n+                }\n+            }\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    \/\/ ---\n+    \/\/ Similar to the previous twelve scenarios but with non-blocking IO\n+    \/\/ ---\n+\n+    @Test(dataProvider = \"family\")\n+    public void BAccep_BConn_NBIO_WR_1a(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            TestThread t = TestThread.of(\"t1a\", () -> {\n+                try (SocketChannel sc = openSocketChannel(family);\n+                     Selector selector = Selector.open()) {\n+                    assertTrue(sc.connect(addr));\n+                    ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x1A).flip();\n+                    sc.configureBlocking(false);\n+                    SelectionKey k = sc.register(selector, OP_WRITE);\n+                    selector.select();\n+                    int c;\n+                    while ((c = sc.write(bb)) < 1) ;\n+                    assertEquals(c, 1);\n+                    out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                    k.interestOps(OP_READ);\n+                    selector.select();\n+                    bb.clear();\n+                    while ((c = sc.read(bb)) == 0) ;\n+                    assertEquals(c, -1);\n+                }\n+            });\n+            t.start();\n+\n+            try (SocketChannel sc = ssc.accept();\n+                 Selector selector = Selector.open()) {\n+                ByteBuffer bb = ByteBuffer.allocate(10);\n+                sc.configureBlocking(false);\n+                sc.register(selector, OP_READ);\n+                selector.select();\n+                int c;\n+                while ((c = sc.read(bb)) == 0) ;\n+                assertEquals(c, 1);\n+                out.printf(\"read:  0x%x%n\", bb.get(0));\n+                assertEquals(bb.get(0), 0x1A);\n+            }\n+            t.awaitCompletion();\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void BAccep_BConn_NBIO_RW_2a(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            TestThread t = TestThread.of(\"t2a\", () -> {\n+                try (SocketChannel sc = openSocketChannel(family);\n+                     Selector selector = Selector.open()) {\n+                    assertTrue(sc.connect(addr));\n+                    ByteBuffer bb = ByteBuffer.allocate(10);\n+                    sc.configureBlocking(false);\n+                    sc.register(selector, OP_READ);\n+                    selector.select();\n+                    int c;\n+                    while ((c = sc.read(bb)) == 0) ;\n+                    assertEquals(c, 1);\n+                    out.printf(\"read:  0x%x%n\", bb.get(0));\n+                    assertEquals(bb.get(0), 0x2A);\n+                }\n+            });\n+            t.start();\n+\n+            try (SocketChannel sc = ssc.accept();\n+                 Selector selector = Selector.open()) {\n+                ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x2A).flip();\n+                sc.configureBlocking(false);\n+                SelectionKey k = sc.register(selector, OP_WRITE);\n+                selector.select();\n+                int c;\n+                while ((c = sc.write(bb)) < 1) ;\n+                assertEquals(c, 1);\n+                out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                k.interestOps(OP_READ);\n+                selector.select();\n+                bb.clear();\n+                while ((c = sc.read(bb)) == 0) ;\n+                assertEquals(c, -1);\n+            }\n+            t.awaitCompletion();\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SELNBAccep_BConn_NBIO_WR_3a(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family);\n+             Selector aselector = Selector.open()) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            TestThread t = TestThread.of(\"t3a\", () -> {\n+                try (SocketChannel sc = openSocketChannel(family);\n+                     Selector selector = Selector.open()) {\n+                    assertTrue(sc.connect(addr));\n+                    ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x3A).flip();\n+                    sc.configureBlocking(false);\n+                    SelectionKey k = sc.register(selector, OP_WRITE);\n+                    selector.select();\n+                    int c;\n+                    while ((c = sc.write(bb)) < 1) ;\n+                    assertEquals(c, 1);\n+                    out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                    k.interestOps(OP_READ);\n+                    selector.select();\n+                    bb.clear();\n+                    while ((c = sc.read(bb)) == 0) ;\n+                    assertEquals(c, -1);\n+                }\n+            });\n+            t.start();\n+\n+            ssc.configureBlocking(false).register(aselector, OP_ACCEPT);\n+            assertEquals(aselector.select(), 1);\n+\n+            try (SocketChannel sc = ssc.accept();\n+                 Selector selector = Selector.open()) {\n+                ByteBuffer bb = ByteBuffer.allocate(10);\n+                sc.configureBlocking(false);\n+                sc.register(selector, OP_READ);\n+                selector.select();\n+                int c;\n+                while ((c = sc.read(bb)) == 0) ;\n+                assertEquals(c, 1);\n+                out.printf(\"read:  0x%x%n\", bb.get(0));\n+                assertEquals(bb.get(0), 0x3A);\n+            }\n+            t.awaitCompletion();\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SELNBAccep_BConn_NBIO_RW_4a(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family);\n+             Selector aselector = Selector.open()) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            TestThread t = TestThread.of(\"t4a\", () -> {\n+                try (SocketChannel sc = openSocketChannel(family);\n+                     Selector selector = Selector.open()) {\n+                    assertTrue(sc.connect(addr));\n+                    ByteBuffer bb = ByteBuffer.allocate(10);\n+                    sc.configureBlocking(false);\n+                    sc.register(selector, OP_READ);\n+                    selector.select();\n+                    int c;\n+                    while ((c = sc.read(bb)) == 0) ;\n+                    assertEquals(c, 1);\n+                    out.printf(\"read:  0x%x%n\", bb.get(0));\n+                    assertEquals(bb.get(0), 0x4A);\n+                }\n+            });\n+            t.start();\n+\n+            ssc.configureBlocking(false).register(aselector, OP_ACCEPT);\n+            assertEquals(aselector.select(), 1);\n+\n+            try (SocketChannel sc = ssc.accept();\n+                 Selector selector = Selector.open()) {\n+                ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x4A).flip();\n+                sc.configureBlocking(false);\n+                SelectionKey k = sc.register(selector, OP_WRITE);\n+                selector.select();\n+                int c;\n+                while ((c = sc.write(bb)) < 1) ;\n+                assertEquals(c, 1);\n+                out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                k.interestOps(OP_READ);\n+                selector.select();\n+                bb.clear();\n+                while ((c = sc.read(bb)) == 0) ;\n+                assertEquals(c, -1);\n+            }\n+            t.awaitCompletion();\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SPINNBAccep_BConn_NBIO_WR_5a(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            TestThread t = TestThread.of(\"t5a\", () -> {\n+                try (SocketChannel sc = openSocketChannel(family);\n+                     Selector selector = Selector.open()) {\n+                    assertTrue(sc.connect(addr));\n+                    ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x5A).flip();\n+                    sc.configureBlocking(false);\n+                    SelectionKey k = sc.register(selector, OP_WRITE);\n+                    selector.select();\n+                    int c;\n+                    while ((c = sc.write(bb)) < 1) ;\n+                    assertEquals(c, 1);\n+                    out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                    k.interestOps(OP_READ);\n+                    selector.select();\n+                    bb.clear();\n+                    while ((c = sc.read(bb)) == 0) ;\n+                    assertEquals(c, -1);\n+                }\n+            });\n+            t.start();\n+\n+            SocketChannel accepted;\n+            for (; ; ) {\n+                accepted = ssc.accept();\n+                if (accepted != null) {\n+                    out.println(\"accepted new connection\");\n+                    break;\n+                }\n+                Thread.onSpinWait();\n+            }\n+\n+            try (SocketChannel sc = accepted;\n+                 Selector selector = Selector.open()) {\n+                ByteBuffer bb = ByteBuffer.allocate(10);\n+                sc.configureBlocking(false);\n+                sc.register(selector, OP_READ);\n+                selector.select();\n+                int c;\n+                while ((c = sc.read(bb)) == 0) ;\n+                assertEquals(c, 1);\n+                out.printf(\"read:  0x%x%n\", bb.get(0));\n+                assertEquals(bb.get(0), 0x5A);\n+            }\n+            t.awaitCompletion();\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SPINNBAccep_BConn_NBIO_RW_6a(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            TestThread t = TestThread.of(\"t6a\", () -> {\n+                try (SocketChannel sc = openSocketChannel(family);\n+                     Selector selector = Selector.open()) {\n+                    assertTrue(sc.connect(addr));\n+                    ByteBuffer bb = ByteBuffer.allocate(10);\n+                    sc.configureBlocking(false);\n+                    sc.register(selector, OP_READ);\n+                    selector.select();\n+                    int c;\n+                    while ((c = sc.read(bb)) == 0) ;\n+                    assertEquals(c, 1);\n+                    out.printf(\"read:  0x%x%n\", bb.get(0));\n+                    assertEquals(bb.get(0), 0x6A);\n+                }\n+            });\n+            t.start();\n+\n+            SocketChannel accepted;\n+            for (; ; ) {\n+                accepted = ssc.accept();\n+                if (accepted != null) {\n+                    out.println(\"accepted new connection\");\n+                    break;\n+                }\n+                Thread.onSpinWait();\n+            }\n+\n+            try (SocketChannel sc = accepted;\n+                 Selector selector = Selector.open()) {\n+                ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x6A).flip();\n+                sc.configureBlocking(false);\n+                SelectionKey k = sc.register(selector, OP_WRITE);\n+                selector.select();\n+                int c;\n+                while ((c = sc.write(bb)) < 1) ;\n+                assertEquals(c, 1);\n+                out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                k.interestOps(OP_READ);\n+                selector.select();\n+                bb.clear();\n+                while ((c = sc.read(bb)) == 0) ;\n+                assertEquals(c, -1);\n+\n+            }\n+            t.awaitCompletion();\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    \/\/ Similar to the previous six scenarios but with same-thread\n+    \/\/ non-blocking connect.\n+\n+    @Test(dataProvider = \"family\")\n+    public void BAccep_NBConn_NBIO_WR_7a(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            try (SocketChannel sc = openSocketChannel(family)) {\n+                sc.configureBlocking(false);\n+                sc.connect(addr);\n+\n+                try (SocketChannel sc2 = ssc.accept()) {\n+                    assertTrue(sc.finishConnect());\n+                    TestThread t = TestThread.of(\"t7a\", () -> {\n+                        try (Selector selector = Selector.open()) {\n+                            ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x7A).flip();\n+                            sc.configureBlocking(false);\n+                            SelectionKey k = sc.register(selector, OP_WRITE);\n+                            selector.select();\n+                            int c;\n+                            while ((c = sc.write(bb)) < 1) ;\n+                            assertEquals(c, 1);\n+                            out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                            k.interestOps(OP_READ);\n+                            selector.select();\n+                            bb.clear();\n+                            while ((c = sc.read(bb)) == 0) ;\n+                            assertEquals(c, -1);\n+                        }\n+                    });\n+                    t.start();\n+\n+                    ByteBuffer bb = ByteBuffer.allocate(10);\n+                    sc2.configureBlocking(false);\n+                    try (Selector selector = Selector.open()) {\n+                        sc2.register(selector, OP_READ);\n+                        selector.select();\n+                        int c;\n+                        while ((c = sc2.read(bb)) == 0) ;\n+                        assertEquals(c, 1);\n+                        out.printf(\"read:  0x%x%n\", bb.get(0));\n+                        assertEquals(bb.get(0), 0x7A);\n+                        sc2.shutdownOutput();\n+                    }\n+                    t.awaitCompletion();\n+                }\n+            }\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void BAccep_NBConn_NBIO_RW_8a(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            try (SocketChannel sc = openSocketChannel(family)) {\n+                sc.configureBlocking(false);\n+                sc.connect(addr);\n+\n+                try (SocketChannel sc2 = ssc.accept()) {\n+                    assertTrue(sc.finishConnect());\n+                    TestThread t = TestThread.of(\"t8a\", () -> {\n+                        try (Selector selector = Selector.open()) {\n+                            ByteBuffer bb = ByteBuffer.allocate(10);\n+                            sc.register(selector, OP_READ);\n+                            selector.select();\n+                            int c;\n+                            while ((c = sc.read(bb)) == 0) ;\n+                            assertEquals(c, 1);\n+                            out.printf(\"read:  0x%x%n\", bb.get(0));\n+                            assertEquals(bb.get(0), (byte) 0x8A);\n+                            sc.shutdownOutput();\n+                        }\n+                    });\n+                    t.start();\n+\n+                    ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x8A).flip();\n+                    sc2.configureBlocking(false);\n+                    try (Selector selector = Selector.open()) {\n+                        SelectionKey k = sc2.register(selector, OP_WRITE);\n+                        selector.select();\n+                        int c;\n+                        while ((c = sc2.write(bb)) < 1) ;\n+                        assertEquals(c, 1);\n+                        out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                        k.interestOps(OP_READ);\n+                        selector.select();\n+                        bb.clear();\n+                        while ((c = sc2.read(bb)) == 0) ;\n+                        assertEquals(c, -1);\n+                    }\n+                    t.awaitCompletion();\n+                }\n+            }\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SELNBAccep_NBConn_NBIO_WR_9a(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            try (SocketChannel sc = openSocketChannel(family)) {\n+                sc.configureBlocking(false);\n+                sc.connect(addr);\n+\n+                Selector aselector = Selector.open();\n+                ssc.configureBlocking(false).register(aselector, OP_ACCEPT);\n+                assertEquals(aselector.select(), 1);\n+\n+                try (SocketChannel sc2 = ssc.accept()) {\n+                    assertTrue(sc.finishConnect());\n+                    TestThread t = TestThread.of(\"t9a\", () -> {\n+                        try (Selector selector = Selector.open()) {\n+                            ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x9A).flip();\n+                            sc.configureBlocking(false);\n+                            SelectionKey k = sc.register(selector, OP_WRITE);\n+                            selector.select();\n+                            int c;\n+                            while ((c = sc.write(bb)) < 1) ;\n+                            assertEquals(c, 1);\n+                            out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                            k.interestOps(OP_READ);\n+                            selector.select();\n+                            bb.clear();\n+                            while ((c = sc.read(bb)) == 0) ;\n+                            assertEquals(c, -1);\n+                        }\n+                    });\n+                    t.start();\n+\n+                    ByteBuffer bb = ByteBuffer.allocate(10);\n+                    sc2.configureBlocking(false);\n+                    try (Selector selector = Selector.open()) {\n+                        sc2.register(selector, OP_READ);\n+                        selector.select();\n+                        int c;\n+                        while ((c = sc2.read(bb)) == 0) ;\n+                        assertEquals(c, 1);\n+                        out.printf(\"read:  0x%x%n\", bb.get(0));\n+                        assertEquals(bb.get(0), (byte) 0x9A);\n+                        sc2.shutdownOutput();\n+                    }\n+                    t.awaitCompletion();\n+                }\n+            }\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SELNBAccep_NBConn_NBIO_RW_10a(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            try (SocketChannel sc = openSocketChannel(family)) {\n+                sc.configureBlocking(false);\n+                sc.connect(addr);\n+\n+                Selector aselector = Selector.open();\n+                ssc.configureBlocking(false).register(aselector, OP_ACCEPT);\n+                assertEquals(aselector.select(), 1);\n+\n+                try (SocketChannel sc2 = ssc.accept()) {\n+                    assertTrue(sc.finishConnect());\n+                    TestThread t = TestThread.of(\"t10a\", () -> {\n+                        try (Selector selector = Selector.open()) {\n+                            ByteBuffer bb = ByteBuffer.allocate(10);\n+                            sc.register(selector, OP_READ);\n+                            selector.select();\n+                            int c;\n+                            while ((c = sc.read(bb)) == 0) ;\n+                            assertEquals(c, 1);\n+                            out.printf(\"read:  0x%x%n\", bb.get(0));\n+                            assertEquals(bb.get(0), (byte) 0xAA);\n+                            sc.shutdownOutput();\n+                        }\n+                    });\n+                    t.start();\n+\n+                    ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0xAA).flip();\n+                    sc2.configureBlocking(false);\n+                    try (Selector selector = Selector.open()) {\n+                        SelectionKey k = sc2.register(selector, OP_WRITE);\n+                        selector.select();\n+                        int c;\n+                        while ((c = sc2.write(bb)) < 1) ;\n+                        assertEquals(c, 1);\n+                        out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                        k.interestOps(OP_READ);\n+                        selector.select();\n+                        bb.clear();\n+                        while ((c = sc2.read(bb)) == 0) ;\n+                        assertEquals(c, -1);\n+                    }\n+                    t.awaitCompletion();\n+                }\n+            }\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SPINBAccep_NBConn_NBIO_WR_11a(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            try (SocketChannel sc = openSocketChannel(family)) {\n+                sc.configureBlocking(false);\n+                sc.connect(addr);\n+\n+                SocketChannel accepted;\n+                for (; ; ) {\n+                    accepted = ssc.accept();\n+                    if (accepted != null) {\n+                        out.println(\"accepted new connection\");\n+                        break;\n+                    }\n+                    Thread.onSpinWait();\n+                }\n+\n+                try (SocketChannel sc2 = accepted) {\n+                    assertTrue(sc.finishConnect());\n+                    TestThread t = TestThread.of(\"t11a\", () -> {\n+                        try (Selector selector = Selector.open()) {\n+                            ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0xBA).flip();\n+                            sc.configureBlocking(false);\n+                            SelectionKey k = sc.register(selector, OP_WRITE);\n+                            selector.select();\n+                            int c;\n+                            while ((c = sc.write(bb)) < 1) ;\n+                            assertEquals(c, 1);\n+                            out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                            k.interestOps(OP_READ);\n+                            selector.select();\n+                            bb.clear();\n+                            while ((c = sc.read(bb)) == 0) ;\n+                            assertEquals(c, -1);\n+                        }\n+                    });\n+                    t.start();\n+\n+                    ByteBuffer bb = ByteBuffer.allocate(10);\n+                    sc2.configureBlocking(false);\n+                    try (Selector selector = Selector.open()) {\n+                        sc2.register(selector, OP_READ);\n+                        selector.select();\n+                        int c;\n+                        while ((c = sc2.read(bb)) == 0) ;\n+                        assertEquals(c, 1);\n+                        out.printf(\"read:  0x%x%n\", bb.get(0));\n+                        assertEquals(bb.get(0), (byte) 0xBA);\n+                        sc2.shutdownOutput();\n+                    }\n+                    t.awaitCompletion();\n+                }\n+            }\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SPINBAccep_NBConn_NBIO_RW_12a(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            try (SocketChannel sc = openSocketChannel(family)) {\n+                sc.configureBlocking(false);\n+                sc.connect(addr);\n+\n+                SocketChannel accepted;\n+                for (; ; ) {\n+                    accepted = ssc.accept();\n+                    if (accepted != null) {\n+                        out.println(\"accepted new connection\");\n+                        break;\n+                    }\n+                    Thread.onSpinWait();\n+                }\n+\n+                try (SocketChannel sc2 = accepted) {\n+                    assertTrue(sc.finishConnect());\n+                    TestThread t = TestThread.of(\"t10a\", () -> {\n+                        try (Selector selector = Selector.open()) {\n+                            ByteBuffer bb = ByteBuffer.allocate(10);\n+                            sc.register(selector, OP_READ);\n+                            selector.select();\n+                            int c;\n+                            while ((c = sc.read(bb)) == 0) ;\n+                            assertEquals(c, 1);\n+                            out.printf(\"read:  0x%x%n\", bb.get(0));\n+                            assertEquals(bb.get(0), (byte) 0xCA);\n+                            sc.shutdownOutput();\n+                        }\n+                    });\n+                    t.start();\n+\n+                    ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0xCA).flip();\n+                    sc2.configureBlocking(false);\n+                    try (Selector selector = Selector.open()) {\n+                        SelectionKey k = sc2.register(selector, OP_WRITE);\n+                        selector.select();\n+                        int c;\n+                        while ((c = sc2.write(bb)) < 1) ;\n+                        assertEquals(c, 1);\n+                        out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                        k.interestOps(OP_READ);\n+                        selector.select();\n+                        bb.clear();\n+                        while ((c = sc2.read(bb)) == 0) ;\n+                        assertEquals(c, -1);\n+                    }\n+                    t.awaitCompletion();\n+                }\n+            }\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    \/\/ --\n+\n+    static class TestThread extends Thread {\n+        private final UncheckedRunnable runnable;\n+        private volatile Throwable throwable;\n+\n+        TestThread(UncheckedRunnable runnable, String name) {\n+            super(name);\n+            this.runnable = runnable;\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                runnable.run();\n+            } catch (Throwable t) {\n+                out.printf(\"[%s] caught unexpected: %s%n\", getName(), t);\n+                throwable = t;\n+            }\n+        }\n+\n+        interface UncheckedRunnable {\n+            void run() throws Throwable;\n+        }\n+\n+        static TestThread of(String name, UncheckedRunnable runnable) {\n+            return new TestThread(runnable, name);\n+        }\n+\n+        void awaitCompletion() throws Throwable {\n+            this.join();\n+            if (throwable != null)\n+                throw throwable;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/IOExchanges.java","additions":1243,"deletions":0,"binary":false,"changes":1243,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8245194\n+ * @library \/test\/lib\n+ * @run main\/othervm NonBlockingAccept\n+ *\/\n+\n+import java.net.StandardProtocolFamily;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import jtreg.SkippedException;\n+\n+public class NonBlockingAccept {\n+\n+    static void checkSupported() {\n+        try {\n+            SocketChannel.open(StandardProtocolFamily.UNIX).close();\n+        } catch (UnsupportedOperationException e) {\n+            throw new SkippedException(\"Unix domain sockets not supported\");\n+        } catch (Exception e) {\n+            \/\/ continue\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        checkSupported();\n+\n+        try (ServerSocketChannel serverSocketChannel =\n+                                 ServerSocketChannel.open(StandardProtocolFamily.UNIX)) {\n+            \/\/non blocking mode\n+            serverSocketChannel.configureBlocking(false);\n+            serverSocketChannel.bind(null);\n+            SocketChannel socketChannel = serverSocketChannel.accept();\n+            System.out.println(\"The socketChannel is : expected Null \" + socketChannel);\n+            if (socketChannel != null)\n+                throw new RuntimeException(\"expected null\");\n+            \/\/ or exception could be thrown otherwise\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/NonBlockingAccept.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8245194\n+ * @run testng NullTest\n+ *\/\n+\n+import java.net.ProtocolFamily;\n+import java.net.SocketAddress;\n+import java.net.UnixDomainSocketAddress;\n+import java.nio.channels.*;\n+import java.nio.file.Path;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertThrows;\n+\n+\/**\n+ * Check for NPE\n+ *\/\n+public class NullTest {\n+\n+    \/\/ Expected exception\n+    private static final Class<NullPointerException> NPE =\n+        NullPointerException.class;\n+\n+    @Test\n+    public static void runTest() throws Exception {\n+        assertThrows(NPE, () -> SocketChannel.open((ProtocolFamily)null));\n+        assertThrows(NPE, () -> SocketChannel.open((SocketAddress)null));\n+        assertThrows(NPE, () -> ServerSocketChannel.open((ProtocolFamily)null));\n+        assertThrows(NPE, () -> UnixDomainSocketAddress.of((Path)null));\n+        assertThrows(NPE, () -> UnixDomainSocketAddress.of((String)null));\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/NullTest.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8245194\n+ * @run main\/othervm\/java.security.policy=policy1 Security policy1\n+ * @run main\/othervm\/java.security.policy=policy2 Security policy2\n+ * @run main\/othervm Security policy3\n+ * @summary Security test for Unix Domain socket and server socket channels\n+ *\/\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.SocketAddress;\n+import java.net.UnixDomainSocketAddress;\n+import java.nio.channels.*;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Comparator;\n+\n+import static java.net.StandardProtocolFamily.UNIX;\n+\n+\/**\n+ * Tests required all with security manager\n+ *\/\n+\n+public class Security {\n+\n+    static interface Command {\n+        public void run() throws Exception;\n+    }\n+\n+    static <T extends Exception> void call(Command r, Class<? extends Exception> expectedException) {\n+        boolean threw = false;\n+        try {\n+            r.run();\n+        } catch (Throwable t) {\n+            if (expectedException == null) {\n+                t.printStackTrace();\n+                throw new RuntimeException(\"an exception was thrown but was not expected\");\n+            }\n+            threw = true;\n+            if (!(expectedException.isAssignableFrom(t.getClass()))) {\n+                throw new RuntimeException(\"wrong exception type thrown \" + t.toString());\n+            }\n+        }\n+        if (expectedException != null && !threw) {\n+            \/\/ should have thrown\n+            throw new RuntimeException(\"% was expected\".formatted(expectedException.getName()));\n+        }\n+    }\n+\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+           SocketChannel.open(UNIX);\n+        } catch (UnsupportedOperationException e) {\n+            System.out.println(\"Unix domain not supported\");\n+            return;\n+        }\n+\n+        String policy = args[0];\n+        switch (policy) {\n+            case \"policy1\":\n+                testPolicy1();\n+                break;\n+            case \"policy2\":\n+                testPolicy2();\n+                break;\n+            case \"policy3\":\n+                testPolicy3();\n+                break;\n+        }\n+    }\n+\n+    static void setSecurityManager(String policy) {\n+        String testSrc = System.getProperty(\"test.src\");\n+        \/\/ Three \/\/\/ required for Windows below\n+        String policyURL = \"file:\/\/\/\" + testSrc + File.separator + policy;\n+        System.out.println(\"POLICY: \" + policyURL);\n+        System.setProperty(\"java.security.policy\", policyURL);\n+        System.setSecurityManager(new SecurityManager());\n+    }\n+\n+    static void close(NetworkChannel... channels) {\n+\n+        for (NetworkChannel chan : channels) {\n+            try {\n+                chan.close();\n+            } catch (Exception e) {\n+            }\n+        }\n+    }\n+\n+    private static final Class<SecurityException> SE = SecurityException.class;\n+    private static final Class<IOException> IOE = IOException.class;\n+\n+    \/\/ No permission\n+\n+    public static void testPolicy1() throws Exception {\n+        Path servername = Path.of(\"sock\");\n+        Files.deleteIfExists(servername);\n+        \/\/ Permission exists to bind a ServerSocketChannel\n+        final UnixDomainSocketAddress saddr = UnixDomainSocketAddress.of(servername);\n+        try (final ServerSocketChannel server = ServerSocketChannel.open(UNIX)) {\n+            try (final SocketChannel client = SocketChannel.open(UNIX)) {\n+                call(() -> {\n+                    server.bind(saddr);\n+                }, SE);\n+                call(() -> {\n+                    client.connect(saddr);\n+                }, SE);\n+            }\n+        } finally {\n+            Files.deleteIfExists(servername);\n+        }\n+    }\n+\n+    \/\/ All permissions\n+\n+    public static void testPolicy2() throws Exception {\n+        Path servername = Path.of(\"sock\");\n+        Files.deleteIfExists(servername);\n+        final UnixDomainSocketAddress saddr = UnixDomainSocketAddress.of(servername);\n+        try (final ServerSocketChannel server = ServerSocketChannel.open(UNIX)) {\n+            try (final SocketChannel client = SocketChannel.open(UNIX)) {\n+                call(() -> {\n+                    server.bind(saddr);\n+                }, null);\n+                call(() -> {\n+                    client.connect(saddr);\n+                }, null);\n+            }\n+        } finally {\n+            Files.deleteIfExists(servername);\n+        }\n+    }\n+\n+    public static void testPolicy3() throws Exception {\n+        Path sock1 = Path.of(\"sock3\");\n+        Files.deleteIfExists(sock1);\n+        final UnixDomainSocketAddress saddr = UnixDomainSocketAddress.of(sock1);\n+        try (var s1 = ServerSocketChannel.open(UNIX)) {\n+            s1.bind(saddr);\n+            try (var s2 = ServerSocketChannel.open(UNIX)) {\n+                s2.bind(null);\n+                var add2 = (UnixDomainSocketAddress)s2.getLocalAddress();\n+                saddr.getPath().toFile().deleteOnExit();\n+                add2.getPath().toFile().deleteOnExit();\n+\n+                \/\/ Now set security manager and check if we can see addresses\n+\n+                setSecurityManager(\"policy3\");\n+\n+                if (((UnixDomainSocketAddress)s1\n+                            .getLocalAddress())\n+                            .getPath()\n+                            .toString()\n+                            .length() != 0)\n+                {\n+                    throw new RuntimeException(\"address should have been empty\");\n+                }\n+\n+                if (((UnixDomainSocketAddress)s2\n+                            .getLocalAddress())\n+                            .getPath()\n+                            .toString()\n+                            .length() != 0)\n+                {\n+                    throw new RuntimeException(\"address should have been empty\");\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/Security.java","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8245194\n+ * @run main\/othervm Shutdown\n+ *\/\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.net.*;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.*;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.util.Arrays;\n+\n+\/**\n+ * Check that half close works\n+ *\/\n+public class Shutdown {\n+\n+    public static void main(String args[]) throws Exception {\n+        if (!supported()) {\n+            System.out.println(\"Unix domain channels not supported\");\n+            return;\n+        }\n+        runTest();\n+    }\n+\n+    static boolean supported() {\n+        try {\n+            SocketChannel.open(StandardProtocolFamily.UNIX).close();\n+        } catch (UnsupportedOperationException e) {\n+            return false;\n+        } catch (Exception e) {\n+            return true; \/\/ continue test to see what problem is\n+        }\n+        return true;\n+    }\n+\n+    static void assertTrue(boolean condition, String error) {\n+        if (!condition)\n+            throw new RuntimeException(error);\n+    }\n+\n+    public static void runTest() throws IOException {\n+        ServerSocketChannel server = null;\n+        SocketChannel client = null;\n+        SocketChannel acceptee = null;\n+        UnixDomainSocketAddress usa = null;\n+\n+        try {\n+            server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+            server.bind(null);\n+            usa = (UnixDomainSocketAddress)server.getLocalAddress();\n+            System.out.println(\"Local address \" + usa);\n+            client = SocketChannel.open(usa);\n+            acceptee = server.accept();\n+            ByteBuffer buf = ByteBuffer.wrap(\"Hello world\".getBytes(StandardCharsets.ISO_8859_1));\n+            ByteBuffer rx = ByteBuffer.allocate(buf.capacity());\n+            client.write(buf);\n+            buf.rewind();\n+            while (rx.hasRemaining())\n+                acceptee.read(rx);\n+\n+            assertTrue(Arrays.equals(buf.array(), rx.array()), \"array contents not equal\");\n+\n+            client.shutdownOutput();\n+            try {\n+                client.write(buf);\n+                throw new RuntimeException(\"shutdown error\");\n+            } catch (ClosedChannelException e) {\n+            }\n+\n+            rx.clear();\n+            int c = acceptee.read(rx);\n+            assertTrue(c == -1, \"read after remote shutdown\");\n+\n+            client.configureBlocking(false);\n+            c = client.read(rx);\n+            assertTrue(c == 0, \"expected c == 0\");\n+            client.shutdownInput();\n+            c = client.read(rx);\n+            assertTrue(c == -1, \"expected c == -1\");\n+        } finally {\n+            close(server);\n+            close(client);\n+            close(acceptee);\n+            if (usa != null)\n+                Files.delete(usa.getPath());\n+        }\n+        System.out.println(\"OK\");\n+    }\n+\n+    static void close(Closeable c) {\n+        try {\n+            if (c != null)\n+                c.close();\n+        } catch (IOException e) {}\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/Shutdown.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8245194\n+ * @run main\/othervm SocketOptions\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.*;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import jdk.net.UnixDomainPrincipal;\n+import static jdk.net.ExtendedSocketOptions.SO_PEERCRED;\n+\n+\/**\n+ * Check that all supported options can actually be set and got\n+ *\/\n+public class SocketOptions {\n+\n+    public static void main(String args[]) throws Exception {\n+        if (!supported()) {\n+            System.out.println(\"Unix domain channels not supported\");\n+            return;\n+        }\n+        test(ServerSocketChannel.open(StandardProtocolFamily.UNIX));\n+        test(SocketChannel.open(StandardProtocolFamily.UNIX));\n+        testPeerCred();\n+    }\n+\n+    static void testPeerCred() throws Exception {\n+        UnixDomainSocketAddress addr = null;\n+        UnixDomainPrincipal p;\n+        try (ServerSocketChannel s = ServerSocketChannel.open(StandardProtocolFamily.UNIX)) {\n+            s.bind(null);\n+            addr = (UnixDomainSocketAddress)s.getLocalAddress();\n+            try (SocketChannel c = SocketChannel.open(addr)) {\n+                if (!c.supportedOptions().contains(SO_PEERCRED)) {\n+                    return;\n+                }\n+                Files.deleteIfExists(addr.getPath());\n+                p = c.getOption(SO_PEERCRED);\n+                String s1 = p.user().getName();\n+                System.out.println(s1);\n+                System.out.println(p.group().getName());\n+                String s2 = System.getProperty(\"user.name\");\n+\n+                \/\/ Check returned user name\n+\n+                if (!s1.equals(s2)) {\n+                    throw new RuntimeException(\"wrong username\");\n+                }\n+\n+                \/\/ Try setting the option: Read only\n+\n+                try {\n+                    c.setOption(SO_PEERCRED, p);\n+                    throw new RuntimeException(\"should have thrown SocketException\");\n+                } catch (SocketException e) {}\n+            }\n+        } finally {\n+            if (addr != null)\n+                Files.deleteIfExists(addr.getPath());\n+        }\n+\n+        \/\/ Try getting from unconnected socket\n+\n+        try (var c = SocketChannel.open(StandardProtocolFamily.UNIX)) {\n+            try {\n+                p = c.getOption(SO_PEERCRED);\n+                System.out.println(p.user());\n+                throw new RuntimeException(\"should have thrown SocketException\");\n+            } catch (SocketException e) {}\n+        }\n+\n+        \/\/ Try getting from ServerSocketChannel\n+\n+        try (var server = ServerSocketChannel.open(StandardProtocolFamily.UNIX)) {\n+            try {\n+                p = server.getOption(SO_PEERCRED);\n+                System.out.println(p.user());\n+                throw new RuntimeException(\"should have thrown USE\");\n+            } catch (UnsupportedOperationException e) {}\n+        }\n+    }\n+\n+    static boolean supported() {\n+        try {\n+            SocketChannel.open(StandardProtocolFamily.UNIX).close();\n+        } catch (UnsupportedOperationException e) {\n+            return false;\n+        } catch (Exception e) {\n+            return true; \/\/ continue test to see what problem is\n+        }\n+        return true;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static void test(NetworkChannel chan) throws IOException {\n+        System.out.println(\"Checking: \" + chan.getClass());\n+        Set<SocketOption<?>> supported = chan.supportedOptions();\n+        for (SocketOption<?> option : supported) {\n+            String name = option.name();\n+            System.out.println(\"Checking option \" + name);\n+            if (option.type() == Boolean.class) {\n+                chan.setOption((SocketOption<Boolean>)option, true);\n+                chan.setOption((SocketOption<Boolean>)option, false);\n+                chan.getOption(option);\n+            } else if (option.type() == Integer.class) {\n+                chan.setOption((SocketOption<Integer>)option, 10);\n+                chan.getOption(option);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/SocketOptions.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+grant {\n+    \/\/ No permission\n+    permission java.io.FilePermission \"sock\", \"delete\";\n+};\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/policy1","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+grant {\n+    \/\/ permission to bind a SocketChannel in sockets directory\n+    permission java.net.NetPermission \"accessUnixDomainSocket\";\n+\n+    permission java.io.FilePermission \"sock\", \"delete\";\n+};\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/policy2","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+grant {\n+    \/\/ No permission\n+    permission java.io.FilePermission \"sock\", \"delete\";\n+};\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/policy3","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 6850113 8032446\n+ * @bug 6850113 8032446 8255242\n@@ -1400,0 +1400,6 @@\n+            if (!e.getMessage().equals(\n+                    \"Value start 0 is out of range 0 to \" + (textLength + 1) +\n+                    \", or limit \" + (textLength + 1) + \" is beyond the text length \" + textLength)) {\n+                errorHandling(\"requiresBidi() should throw an IAE\" +\n+                        \" mentioning limit is beyond the text length. Message: \" + e.getMessage());\n+            }\n","filename":"test\/jdk\/java\/text\/Bidi\/BidiConformance.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+            robo.setAutoDelay(100);\n@@ -61,0 +62,1 @@\n+            robo.delay(1000);\n@@ -63,1 +65,0 @@\n-            robo.setAutoDelay(100);\n@@ -82,0 +83,1 @@\n+\n@@ -112,1 +114,1 @@\n-        mainFrame.setLocation(200, 200);\n+        mainFrame.setLocationRelativeTo(null);\n","filename":"test\/jdk\/javax\/swing\/JMenu\/4692443\/bug4692443.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-        robot.waitForIdle();\n+        robot.setAutoDelay(100);\n@@ -50,0 +50,1 @@\n+        robot.waitForIdle();\n@@ -57,2 +58,2 @@\n-        robot.setAutoDelay(50);\n-\n+        robot.waitForIdle();\n+        robot.delay(1000);\n@@ -62,1 +63,0 @@\n-        Thread.sleep(1000);\n@@ -68,1 +68,0 @@\n-        Thread.sleep(1000);\n","filename":"test\/jdk\/javax\/swing\/JPopupMenu\/4458079\/bug4458079.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-  @key headful\n+   @key headful\n@@ -29,3 +29,0 @@\n-   @author Mikhail Lapshin\n-   @library \/lib\/client\n-   @build ExtendedRobot\n@@ -34,1 +31,1 @@\n-\n+import java.awt.Robot;\n@@ -47,1 +44,1 @@\n-    private static ExtendedRobot robot;\n+    private static Robot robot;\n@@ -50,1 +47,2 @@\n-        robot = new ExtendedRobot();\n+        robot = new Robot();\n+        robot.setAutoDelay(100);\n@@ -53,0 +51,2 @@\n+        robot.waitForIdle();\n+\n@@ -60,0 +60,2 @@\n+            robot.waitForIdle();\n+            robot.delay(1000);\n@@ -98,1 +100,2 @@\n-        robot.type(KeyEvent.VK_DOWN);\n+        robot.keyPress(KeyEvent.VK_DOWN);\n+        robot.keyRelease(KeyEvent.VK_DOWN);\n@@ -101,1 +104,2 @@\n-        robot.type(KeyEvent.VK_DOWN);\n+        robot.keyPress(KeyEvent.VK_DOWN);\n+        robot.keyRelease(KeyEvent.VK_DOWN);\n@@ -104,1 +108,2 @@\n-        robot.type(KeyEvent.VK_SPACE);\n+        robot.keyPress(KeyEvent.VK_SPACE);\n+        robot.keyRelease(KeyEvent.VK_SPACE);\n","filename":"test\/jdk\/javax\/swing\/JPopupMenu\/6544309\/bug6544309.java","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-            robot.setAutoDelay(50);\n+            robot.setAutoDelay(100);\n@@ -54,1 +54,2 @@\n-           robot.mouseMove(100,100);\n+            robot.mouseMove(100,100);\n+            robot.waitForIdle();\n@@ -64,0 +65,1 @@\n+            robot.delay(1000);\n","filename":"test\/jdk\/javax\/swing\/JPopupMenu\/6827786\/bug6827786.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,0 @@\n-\n@@ -28,1 +27,1 @@\n-import java.awt.Toolkit;\n+import java.awt.Robot;\n@@ -32,2 +31,0 @@\n-import javax.swing.JTabbedPane;\n-\n@@ -35,0 +32,1 @@\n+import javax.swing.JTabbedPane;\n@@ -44,3 +42,0 @@\n- * @library \/lib\/client\/\n- * @build ExtendedRobot\n- * @author Sergey Malenkov\n@@ -57,1 +52,3 @@\n-            UIManager.setLookAndFeel(info.getClassName());\n+            String className = info.getClassName();\n+            System.out.println(\"className = \" + className);\n+            UIManager.setLookAndFeel(className);\n@@ -61,2 +58,3 @@\n-                ExtendedRobot robot = new ExtendedRobot();\n-                robot.waitForIdle(1000);\n+                Robot robot = new Robot();\n+                robot.waitForIdle();\n+                robot.delay(1000);\n@@ -84,0 +82,1 @@\n+            frame.setLocationRelativeTo(null);\n@@ -108,0 +107,3 @@\n+            if (bounds == null) {\n+                continue;\n+            }\n","filename":"test\/jdk\/javax\/swing\/JTabbedPane\/7024235\/Test7024235.java","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Phil Milne\n@@ -30,3 +29,4 @@\n-import java.awt.*;\n-import java.lang.reflect.InvocationTargetException;\n-import java.util.*;\n+\n+import java.awt.Font;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n@@ -34,1 +34,10 @@\n-import javax.swing.*;\n+\n+import javax.swing.BorderFactory;\n+import javax.swing.JTextField;\n+import javax.swing.Spring;\n+import javax.swing.SpringLayout;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+import javax.swing.UnsupportedLookAndFeelException;\n+\n+import static javax.swing.UIManager.getInstalledLookAndFeels;\n@@ -43,11 +52,9 @@\n-    public static void main(String[] args) {\n-        try {\n-            SwingUtilities.invokeAndWait(new Runnable() {\n-                @Override\n-                public void run() {\n-                    int minLevel = 2;\n-                    int maxLevel = 2;\n-                    for (int i = minLevel; i <= maxLevel; i++) {\n-                        test(i, true);\n-                        test(i, false);\n-                    }\n+    public static void main(String[] args) throws Exception {\n+        for (final UIManager.LookAndFeelInfo laf : getInstalledLookAndFeels()) {\n+            SwingUtilities.invokeAndWait(() -> setLookAndFeel(laf));\n+            SwingUtilities.invokeAndWait(() -> {\n+                int minLevel = 2;\n+                int maxLevel = 2;\n+                for (int i = minLevel; i <= maxLevel; i++) {\n+                    test(i, true);\n+                    test(i, false);\n@@ -56,3 +63,12 @@\n-        } catch (InterruptedException | InvocationTargetException ex) {\n-            ex.printStackTrace();\n-            throw new RuntimeException(\"FAILED: SwingUtilities.invokeAndWait method failed!\");\n+        }\n+    }\n+\n+    private static void setLookAndFeel(UIManager.LookAndFeelInfo laf) {\n+        try {\n+            System.out.println(\"LookAndFeel: \" + laf.getClassName());\n+            UIManager.setLookAndFeel(laf.getClassName());\n+        } catch (UnsupportedLookAndFeelException ignored){\n+            System.out.println(\"Unsupported LookAndFeel: \" + laf.getClassName());\n+        } catch (ClassNotFoundException | InstantiationException |\n+                IllegalAccessException e) {\n+            throw new RuntimeException(e);\n@@ -67,0 +83,1 @@\n+        tf.setBorder(BorderFactory.createEmptyBorder());\n","filename":"test\/jdk\/javax\/swing\/SpringLayout\/4726194\/bug4726194.java","additions":37,"deletions":20,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+    private static JFrame frame;\n@@ -45,7 +46,24 @@\n-\n-        Robot robot = new Robot();\n-        robot.setAutoDelay(10);\n-\n-        SwingUtilities.invokeAndWait(new Runnable() {\n-            public void run() {\n-                createAndShowGUI();\n+        try {\n+            Robot robot = new Robot();\n+            robot.setAutoDelay(100);\n+\n+            SwingUtilities.invokeAndWait(new Runnable() {\n+                public void run() {\n+                    createAndShowGUI();\n+                }\n+            });\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+\n+            Point point = ft.getLocationOnScreen();\n+            robot.mouseMove(point.x, point.y);\n+            robot.waitForIdle();\n+            robot.mouseMove(point.x + 3, point.y + 3);\n+            robot.waitForIdle();\n+\n+            robot.keyPress(KeyEvent.VK_A);\n+            robot.keyRelease(KeyEvent.VK_A);\n+            robot.waitForIdle();\n+\n+            if (!isTooltipShowning()) {\n+                throw new RuntimeException(\"Tooltip is not shown\");\n@@ -53,6 +71,0 @@\n-        });\n-        robot.waitForIdle();\n-\n-        Point point = ft.getLocationOnScreen();\n-        robot.mouseMove(point.x, point.y);\n-        robot.mouseMove(point.x + 3, point.y + 3);\n@@ -60,7 +72,3 @@\n-        robot.keyPress(KeyEvent.VK_A);\n-        robot.keyRelease(KeyEvent.VK_A);\n-        robot.waitForIdle();\n-\n-        if (!isTooltipShowning()) {\n-            throw new RuntimeException(\"Tooltip is not shown\");\n-        }\n+            robot.keyPress(KeyEvent.VK_ESCAPE);\n+            robot.keyRelease(KeyEvent.VK_ESCAPE);\n+            robot.waitForIdle();\n@@ -68,7 +76,3 @@\n-        robot.keyPress(KeyEvent.VK_ESCAPE);\n-        robot.keyRelease(KeyEvent.VK_ESCAPE);\n-        robot.waitForIdle();\n-\n-        if (isTooltipShowning()) {\n-            throw new RuntimeException(\"Tooltip must be hidden now\");\n-        }\n+            if (isTooltipShowning()) {\n+                throw new RuntimeException(\"Tooltip must be hidden now\");\n+            }\n@@ -76,3 +80,3 @@\n-        if (isTextEqual()) {\n-            throw new RuntimeException(\"FormattedTextField must *not* cancel the updated value this time\");\n-        }\n+            if (isTextEqual()) {\n+                throw new RuntimeException(\"FormattedTextField must *not* cancel the updated value this time\");\n+            }\n@@ -80,3 +84,3 @@\n-        robot.keyPress(KeyEvent.VK_ESCAPE);\n-        robot.keyRelease(KeyEvent.VK_ESCAPE);\n-        robot.waitForIdle();\n+            robot.keyPress(KeyEvent.VK_ESCAPE);\n+            robot.keyRelease(KeyEvent.VK_ESCAPE);\n+            robot.waitForIdle();\n@@ -84,2 +88,7 @@\n-        if (!isTextEqual()) {\n-            throw new RuntimeException(\"FormattedTextField must cancel the updated value\");\n+            if (!isTextEqual()) {\n+                throw new RuntimeException(\"FormattedTextField must cancel the updated value\");\n+            }\n+        } finally {\n+            if (frame != null) {\n+                SwingUtilities.invokeAndWait(frame::dispose);\n+            }\n@@ -119,1 +128,1 @@\n-        final JFrame frame = new JFrame();\n+        frame = new JFrame();\n","filename":"test\/jdk\/javax\/swing\/ToolTipManager\/Test6256140.java","additions":45,"deletions":36,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,6 +65,0 @@\n-\n-            if (\"Aqua\".equals(UIManager.getLookAndFeel().getID())) {\n-                Util.hitKeys(robo, KeyEvent.VK_HOME);\n-            } else {\n-                Util.hitKeys(robo, KeyEvent.VK_CONTROL, KeyEvent.VK_HOME);\n-            }\n@@ -155,0 +149,1 @@\n+        frame.setLocationRelativeTo(null);\n","filename":"test\/jdk\/javax\/swing\/text\/DefaultEditorKit\/4278839\/bug4278839.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,3 +29,0 @@\n- * @author Alexander Potochkin\n- * @library ..\/..\/..\/..\/regtesthelpers\n- * @build Util\n@@ -46,0 +43,1 @@\n+    private static JFrame frame;\n@@ -48,1 +46,3 @@\n-        robot = new Robot();\n+        try {\n+            robot = new Robot();\n+            robot.setAutoDelay(100);\n@@ -50,5 +50,5 @@\n-        SwingUtilities.invokeAndWait(new Runnable() {\n-            public void run() {\n-                createAndShowGUI();\n-            }\n-        });\n+            SwingUtilities.invokeAndWait(new Runnable() {\n+                public void run() {\n+                    createAndShowGUI();\n+                }\n+            });\n@@ -56,1 +56,2 @@\n-        robot.waitForIdle();\n+            robot.waitForIdle();\n+            robot.delay(1000);\n@@ -58,2 +59,4 @@\n-        Util.hitKeys(robot, KeyEvent.VK_HOME);\n-        Util.hitKeys(robot, KeyEvent.VK_1);\n+            robot.keyPress(KeyEvent.VK_HOME);\n+            robot.keyRelease(KeyEvent.VK_HOME);\n+            robot.keyPress(KeyEvent.VK_1);\n+            robot.keyRelease(KeyEvent.VK_1);\n@@ -61,1 +64,1 @@\n-        robot.waitForIdle();\n+            robot.waitForIdle();\n@@ -63,1 +66,1 @@\n-        String test = getText();\n+            String test = getText();\n@@ -65,3 +68,3 @@\n-        if (!\"1test\".equals(test)) {\n-            throw new RuntimeException(\"Begin line action set cursor inside <head> tag\");\n-        }\n+            if (!\"1test\".equals(test)) {\n+                throw new RuntimeException(\"Begin line action set cursor inside <head> tag\");\n+            }\n@@ -69,2 +72,4 @@\n-        Util.hitKeys(robot, KeyEvent.VK_HOME);\n-        Util.hitKeys(robot, KeyEvent.VK_2);\n+            robot.keyPress(KeyEvent.VK_HOME);\n+            robot.keyRelease(KeyEvent.VK_HOME);\n+            robot.keyPress(KeyEvent.VK_2);\n+            robot.keyRelease(KeyEvent.VK_2);\n@@ -72,1 +77,1 @@\n-        robot.waitForIdle();\n+            robot.waitForIdle();\n@@ -74,1 +79,1 @@\n-        test = getText();\n+            test = getText();\n@@ -76,2 +81,7 @@\n-        if (!\"21test\".equals(test)) {\n-            throw new RuntimeException(\"Begin action set cursor inside <head> tag\");\n+            if (!\"21test\".equals(test)) {\n+                throw new RuntimeException(\"Begin action set cursor inside <head> tag\");\n+            }\n+        } finally {\n+            if (frame != null) {\n+                SwingUtilities.invokeAndWait(frame::dispose);\n+            }\n@@ -98,1 +108,1 @@\n-        JFrame frame = new JFrame();\n+        frame = new JFrame();\n@@ -107,0 +117,1 @@\n+        frame.setLocationRelativeTo(null);\n","filename":"test\/jdk\/javax\/swing\/text\/html\/HTMLEditorKit\/5043626\/bug5043626.java","additions":35,"deletions":24,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -803,1 +803,1 @@\n-        int rp = 0, dp = 0;\n+\n@@ -805,0 +805,3 @@\n+        int size_diff = bsize - asize;\n+        ByteOrder bo = ByteOrder.nativeOrder();\n+        int rp = 0, dp = 0;\n@@ -806,1 +809,10 @@\n-            int nextrp = rp + bsize;\n+            if (bo == ByteOrder.BIG_ENDIAN) {\n+                if (size_diff > 0) {\n+                    byte sign = (byte)(data[dp] >> 7); \/\/ sign extend\n+                    for (int j = 0; j < size_diff; j++) {\n+                        result[rp++] = sign;\n+                    }\n+                } else {\n+                    dp -= size_diff; \/\/ step forward if needed\n+                }\n+            }\n@@ -808,1 +820,1 @@\n-            for (int j = 0; j < asize; j++) {\n+            for (int j = 0; j < minsize; j++) {\n@@ -810,1 +822,11 @@\n-                if (j < minsize)  result[rp++] = b;\n+                result[rp++] = b;\n+            }\n+            if (bo == ByteOrder.LITTLE_ENDIAN) {\n+                if (size_diff > 0) {\n+                    byte sign = (byte)(b >> 7); \/\/ sign extend\n+                    for (int j = 0; j < size_diff; j++) {\n+                        result[rp++] = sign;\n+                    }\n+                } else {\n+                    dp -= size_diff; \/\/ step forward if needed\n+                }\n@@ -812,2 +834,0 @@\n-            b >>= 7;  \/\/ sign extend\n-            while (rp < nextrp)  result[rp++] = b;\n@@ -817,0 +837,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/VectorReshapeTests.java","additions":27,"deletions":6,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -53,0 +53,2 @@\n+    private Path cgroupv1CgroupsJoinControllers;\n+    private Path cgroupv1MountInfoJoinControllers;\n@@ -60,0 +62,2 @@\n+    private Path cgroupv1MntInfoDoubleCpusets;\n+    private Path cgroupv1MntInfoDoubleCpusets2;\n@@ -61,0 +65,15 @@\n+    private String cgroupsNonZeroJoinControllers =\n+            \"#subsys_name hierarchy num_cgroups enabled\\n\" +\n+            \"cpuset\\t3\\t1\\t1\\n\" +\n+            \"cpu\\t4\\t153\\t1\\n\" +\n+            \"cpuacct\\t4\\t153\\t1\\n\" +\n+            \"blkio\\t7\\t87\\t1\\n\" +\n+            \"memory\\t4\\t153\\t1\\n\" +\n+            \"devices\\t6\\t87\\t1\\n\" +\n+            \"freezer\\t9\\t1\\t1\\n\" +\n+            \"net_cls\\t4\\t153\\t1\\n\" +\n+            \"perf_event\\t2\\t1\\t1\\n\" +\n+            \"net_prio\\t4\\t153\\t1\\n\" +\n+            \"hugetlb\\t4\\t153\\t1\\n\" +\n+            \"pids\\t5\\t95\\t1\\n\" +\n+            \"rdma\\t8\\t1\\t1\\n\";\n@@ -74,12 +93,24 @@\n-            \"31 30 0:27 \/ \/sys\/fs\/cgroup\/unified rw,nosuid,nodev,noexec,relatime shared:5 - cgroup2 cgroup2 rw,seclabel,nsdelegate\\n\" +\n-            \"32 30 0:28 \/ \/sys\/fs\/cgroup\/systemd rw,nosuid,nodev,noexec,relatime shared:6 - cgroup cgroup rw,seclabel,xattr,name=systemd\\n\" +\n-            \"35 30 0:31 \/ \/sys\/fs\/cgroup\/memory rw,nosuid,nodev,noexec,relatime shared:7 - cgroup cgroup rw,seclabel,memory\\n\" +\n-            \"36 30 0:32 \/ \/sys\/fs\/cgroup\/pids rw,nosuid,nodev,noexec,relatime shared:8 - cgroup cgroup rw,seclabel,pids\\n\" +\n-            \"37 30 0:33 \/ \/sys\/fs\/cgroup\/perf_event rw,nosuid,nodev,noexec,relatime shared:9 - cgroup cgroup rw,seclabel,perf_event\\n\" +\n-            \"38 30 0:34 \/ \/sys\/fs\/cgroup\/net_cls,net_prio rw,nosuid,nodev,noexec,relatime shared:10 - cgroup cgroup rw,seclabel,net_cls,net_prio\\n\" +\n-            \"39 30 0:35 \/ \/sys\/fs\/cgroup\/hugetlb rw,nosuid,nodev,noexec,relatime shared:11 - cgroup cgroup rw,seclabel,hugetlb\\n\" +\n-            \"40 30 0:36 \/ \/sys\/fs\/cgroup\/cpu,cpuacct rw,nosuid,nodev,noexec,relatime shared:12 - cgroup cgroup rw,seclabel,cpu,cpuacct\\n\" +\n-            \"41 30 0:37 \/ \/sys\/fs\/cgroup\/devices rw,nosuid,nodev,noexec,relatime shared:13 - cgroup cgroup rw,seclabel,devices\\n\" +\n-            \"42 30 0:38 \/ \/sys\/fs\/cgroup\/cpuset rw,nosuid,nodev,noexec,relatime shared:14 - cgroup cgroup rw,seclabel,cpuset\\n\" +\n-            \"43 30 0:39 \/ \/sys\/fs\/cgroup\/blkio rw,nosuid,nodev,noexec,relatime shared:15 - cgroup cgroup rw,seclabel,blkio\\n\" +\n-            \"44 30 0:40 \/ \/sys\/fs\/cgroup\/freezer rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,seclabel,freezer\";\n+            \"31 30 0:27 \/ \/sys\/fs\/cgroup\/unified rw,nosuid,nodev,noexec,relatime shared:5 - cgroup2 none rw,seclabel,nsdelegate\\n\" +\n+            \"32 30 0:28 \/ \/sys\/fs\/cgroup\/systemd rw,nosuid,nodev,noexec,relatime shared:6 - cgroup none rw,seclabel,xattr,name=systemd\\n\" +\n+            \"35 30 0:31 \/ \/sys\/fs\/cgroup\/memory rw,nosuid,nodev,noexec,relatime shared:7 - cgroup none rw,seclabel,memory\\n\" +\n+            \"36 30 0:32 \/ \/sys\/fs\/cgroup\/pids rw,nosuid,nodev,noexec,relatime shared:8 - cgroup none rw,seclabel,pids\\n\" +\n+            \"37 30 0:33 \/ \/sys\/fs\/cgroup\/perf_event rw,nosuid,nodev,noexec,relatime shared:9 - cgroup none rw,seclabel,perf_event\\n\" +\n+            \"38 30 0:34 \/ \/sys\/fs\/cgroup\/net_cls,net_prio rw,nosuid,nodev,noexec,relatime shared:10 - cgroup none rw,seclabel,net_cls,net_prio\\n\" +\n+            \"39 30 0:35 \/ \/sys\/fs\/cgroup\/hugetlb rw,nosuid,nodev,noexec,relatime shared:11 - cgroup none rw,seclabel,hugetlb\\n\" +\n+            \"40 30 0:36 \/ \/sys\/fs\/cgroup\/cpu,cpuacct rw,nosuid,nodev,noexec,relatime shared:12 - cgroup none rw,seclabel,cpu,cpuacct\\n\" +\n+            \"41 30 0:37 \/ \/sys\/fs\/cgroup\/devices rw,nosuid,nodev,noexec,relatime shared:13 - cgroup none rw,seclabel,devices\\n\" +\n+            \"42 30 0:38 \/ \/sys\/fs\/cgroup\/cpuset rw,nosuid,nodev,noexec,relatime shared:14 - cgroup none rw,seclabel,cpuset\\n\" +\n+            \"43 30 0:39 \/ \/sys\/fs\/cgroup\/blkio rw,nosuid,nodev,noexec,relatime shared:15 - cgroup none rw,seclabel,blkio\\n\" +\n+            \"44 30 0:40 \/ \/sys\/fs\/cgroup\/freezer rw,nosuid,nodev,noexec,relatime shared:16 - cgroup none rw,seclabel,freezer\\n\";\n+    private String mntInfoCgroupv1JoinControllers =\n+            \"31 22 0:26 \/ \/sys\/fs\/cgroup ro,nosuid,nodev,noexec shared:9 - tmpfs tmpfs ro,mode=755\\n\" +\n+            \"32 31 0:27 \/ \/sys\/fs\/cgroup\/unified rw,nosuid,nodev,noexec,relatime shared:10 - cgroup2 cgroup2 rw,nsdelegate\\n\" +\n+            \"33 31 0:28 \/ \/sys\/fs\/cgroup\/systemd rw,nosuid,nodev,noexec,relatime shared:11 - cgroup cgroup rw,xattr,name=systemd\\n\" +\n+            \"36 31 0:31 \/ \/sys\/fs\/cgroup\/perf_event rw,nosuid,nodev,noexec,relatime shared:15 - cgroup cgroup rw,perf_event\\n\" +\n+            \"37 31 0:32 \/ \/sys\/fs\/cgroup\/cpuset rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,cpuset\\n\" +\n+            \"38 31 0:33 \/ \/sys\/fs\/cgroup\/cpu,cpuacct,net_cls,net_prio,hugetlb,memory rw,nosuid,nodev,noexec,relatime shared:17 - cgroup cgroup rw,cpu,cpuacct,memory,net_cls,net_prio,hugetlb\\n\" +\n+            \"39 31 0:34 \/ \/sys\/fs\/cgroup\/pids rw,nosuid,nodev,noexec,relatime shared:18 - cgroup cgroup rw,pids\\n\" +\n+            \"40 31 0:35 \/ \/sys\/fs\/cgroup\/devices rw,nosuid,nodev,noexec,relatime shared:19 - cgroup cgroup rw,devices\\n\" +\n+            \"41 31 0:36 \/ \/sys\/fs\/cgroup\/blkio rw,nosuid,nodev,noexec,relatime shared:20 - cgroup cgroup rw,blkio\\n\" +\n+            \"42 31 0:37 \/ \/sys\/fs\/cgroup\/rdma rw,nosuid,nodev,noexec,relatime shared:21 - cgroup cgroup rw,rdma\\n\" +\n+            \"43 31 0:38 \/ \/sys\/fs\/cgroup\/freezer rw,nosuid,nodev,noexec,relatime shared:22 - cgroup cgroup rw,freezer\\n\";\n@@ -101,1 +132,1 @@\n-            \"28 21 0:25 \/ \/sys\/fs\/cgroup rw,nosuid,nodev,noexec,relatime shared:4 - cgroup2 cgroup2 rw,seclabel,nsdelegate\";\n+            \"28 21 0:25 \/ \/sys\/fs\/cgroup rw,nosuid,nodev,noexec,relatime shared:4 - cgroup2 none rw,seclabel,nsdelegate\";\n@@ -105,0 +136,3 @@\n+    private String mntInfoCgroupv1MoreCpusetLine = \"121 32 0:37 \/ \/cpuset rw,relatime shared:69 - cgroup none rw,cpuset\\n\";\n+    private String mntInfoCgroupsV1DoubleCpuset = mntInfoHybrid + mntInfoCgroupv1MoreCpusetLine;\n+    private String mntInfoCgroupsV1DoubleCpuset2 = mntInfoCgroupv1MoreCpusetLine + mntInfoHybrid;\n@@ -128,0 +162,12 @@\n+\n+            cgroupv1MntInfoDoubleCpusets = Paths.get(existingDirectory.toString(), \"mountinfo_cgroupv1_double_cpuset\");\n+            Files.writeString(cgroupv1MntInfoDoubleCpusets, mntInfoCgroupsV1DoubleCpuset);\n+\n+            cgroupv1MntInfoDoubleCpusets2 = Paths.get(existingDirectory.toString(), \"mountinfo_cgroupv1_double_cpuset2\");\n+            Files.writeString(cgroupv1MntInfoDoubleCpusets2, mntInfoCgroupsV1DoubleCpuset2);\n+\n+            cgroupv1CgroupsJoinControllers = Paths.get(existingDirectory.toString(), \"cgroups_cgv1_join_controllers\");\n+            Files.writeString(cgroupv1CgroupsJoinControllers, cgroupsNonZeroJoinControllers);\n+\n+            cgroupv1MountInfoJoinControllers = Paths.get(existingDirectory.toString(), \"mntinfo_cgv1_join_controllers\");\n+            Files.writeString(cgroupv1MountInfoJoinControllers, mntInfoCgroupv1JoinControllers);\n@@ -142,0 +188,11 @@\n+    @Test\n+    public void testCgroupv1JoinControllerCombo() throws IOException {\n+        String cgroups = cgroupv1CgroupsJoinControllers.toString();\n+        String mountInfo = cgroupv1MountInfoJoinControllers.toString();\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+\n+        assertTrue(\"Expected non-empty cgroup result\", result.isPresent());\n+        CgroupTypeResult res = result.get();\n+        assertFalse(\"Join controller combination expected as cgroups v1\", res.isCgroupV2());\n+    }\n+\n@@ -151,0 +208,16 @@\n+    @Test\n+    public void testCgroupv1MultipleCpusetMounts() throws IOException {\n+        doMultipleCpusetMountsTest(cgroupv1MntInfoDoubleCpusets);\n+        doMultipleCpusetMountsTest(cgroupv1MntInfoDoubleCpusets2);\n+    }\n+\n+    private void doMultipleCpusetMountsTest(Path info) throws IOException {\n+        String cgroups = cgroupv1CgInfoNonZeroHierarchy.toString();\n+        String mountInfo = info.toString();\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+\n+        assertTrue(\"Expected non-empty cgroup result\", result.isPresent());\n+        CgroupTypeResult res = result.get();\n+        assertFalse(\"Duplicate cpusets should not influence detection heuristic\", res.isCgroupV2());\n+    }\n+\n","filename":"test\/jdk\/jdk\/internal\/platform\/cgroup\/TestCgroupSubsystemFactory.java","additions":86,"deletions":13,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8255078\n+ * @summary verify that datetime in MDTM and MLSD responses are properly parsed\n+ * @library \/test\/lib\n+ * @modules java.base\/sun.net.ftp\n+ * @build jdk.test.lib.Asserts\n+ * @run main\/othervm -Duser.timezone=UTC TestFtpTimeValue\n+ * @run main\/othervm -Duser.timezone=America\/Los_Angeles TestFtpTimeValue\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import sun.net.ftp.FtpClient;\n+\n+import java.io.*;\n+import java.net.*;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.TimeZone;\n+\n+\n+public class TestFtpTimeValue {\n+    private enum TestCase {\n+        AmTimeNoMilli(2019, 4, 20, 10, 57, 13, 0),\n+        AmTimeWithMilli(2019, 4, 20, 10, 57, 13, 50),\n+        PmTimeNoMilli(2019, 4, 20, 22, 57, 13, 0),\n+        PmTimeWithMilli(2019, 4, 20, 22, 57, 13, 50),\n+        ;\n+\n+        public final Date expectedCreated;\n+        public final Date expectedModified;\n+        public final String create;\n+        public final String modify;\n+\n+        TestCase(int year, int month, int day, int hrs, int min, int sec, int milliseconds) {\n+            var calendar = GregorianCalendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n+            \/\/ month is 0-based in Calendar\n+            calendar.set(year, month - 1, day, hrs, min, sec);\n+            calendar.set(Calendar.MILLISECOND, milliseconds);\n+            expectedCreated = calendar.getTime();\n+            var s = String.format(\"%4d%02d%02d%02d%02d%02d\", year, month, day, hrs, min, sec);\n+            if (milliseconds != 0) {\n+                s += \".\" + String.format(\"%03d\", milliseconds);\n+            }\n+            create = s;\n+\n+            calendar.add(GregorianCalendar.SECOND, 1);\n+            expectedModified = calendar.getTime();\n+            s = String.format(\"%4d%02d%02d%02d%02d%02d\", year, month, day, hrs, min, sec + 1);\n+            if (milliseconds != 0) {\n+                s += \".\" + String.format(\"%03d\", milliseconds);\n+            }\n+            modify = s;\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        System.out.println(\"user.timezone: \" + System.getProperty(\"user.timezone\"));\n+        try (FtpServer server = new FtpServer();\n+             FtpClient client = FtpClient.create()) {\n+            (new Thread(server)).start();\n+            int port = server.getPort();\n+            var loopback = InetAddress.getLoopbackAddress();\n+            client.connect(new InetSocketAddress(loopback, port));\n+            client.enablePassiveMode(true);\n+            for (var testCase : TestCase.values()) {\n+                Asserts.assertEQ(testCase.expectedModified, client.getLastModified(testCase.name()),\n+                        \"wrong modified date from MDTM for \" + testCase);\n+            }\n+            for (var it = client.listFiles(null); it.hasNext(); ) {\n+                var e = it.next();\n+                Asserts.assertEQ(TestCase.valueOf(e.getName()).expectedCreated, e.getCreated(),\n+                        \"wrong created date from MLSD for \" + e.getName());\n+                Asserts.assertEQ(TestCase.valueOf(e.getName()).expectedModified, e.getLastModified(),\n+                        \"wrong modified date from MLSD for \" + e.getName());\n+            }\n+        }\n+    }\n+\n+    private static class FtpServer implements AutoCloseable, Runnable {\n+        private final ServerSocket serverSocket;\n+        private final ServerSocket pasv;\n+\n+        FtpServer() throws IOException {\n+            var loopback = InetAddress.getLoopbackAddress();\n+            serverSocket = new ServerSocket();\n+            serverSocket.bind(new InetSocketAddress(loopback, 0));\n+            pasv = new ServerSocket();\n+            pasv.bind(new InetSocketAddress(loopback, 0));\n+        }\n+\n+        public void handleClient(Socket client) throws IOException {\n+            String str;\n+\n+            client.setSoTimeout(2000);\n+            BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()));\n+            PrintWriter out = new PrintWriter(client.getOutputStream(), true);\n+            out.println(\"220 FTP serverSocket is ready.\");\n+            boolean done = false;\n+            while (!done) {\n+                try {\n+                    str = in.readLine();\n+                } catch (SocketException e) {\n+                    done = true;\n+                    continue;\n+                }\n+                String cmd = str.substring(0, str.indexOf(\" \") > 0 ? str.indexOf(\" \") : str.length());\n+                String args = (cmd.equals(str)) ? \"\" : str.substring(str.indexOf(\" \") + 1);\n+                System.err.println(\"C> \" + str);\n+                switch (cmd) {\n+                    case \"QUIT\":\n+                        out.println(\"221 Goodbye.\");\n+                        System.err.println(\"S> 221\");\n+                        done = true;\n+                        break;\n+                    case \"MDTM\": {\n+                        var testCase = TestCase.valueOf(args);\n+                        out.println(\"213 \" + testCase.modify);\n+                        System.err.println(\"S> 213\");\n+                        break;\n+                    }\n+                    case \"MLSD\":\n+                        try (var socket = pasv.accept();\n+                             var dout = new PrintWriter(socket.getOutputStream(), true)) {\n+                            out.println(\"150 MLSD start\");\n+                            System.err.println(\"S> 150\");\n+                            for (var testCase : TestCase.values()) {\n+                                dout.printf(\"modify=%s;create=%s; %s%n\",\n+                                            testCase.modify, testCase.create, testCase.name());\n+                            }\n+                        }\n+                        out.println(\"226 MLSD done.\");\n+                        System.err.println(\"S> 226\");\n+                        break;\n+                    case \"EPSV\":\n+                        if (\"all\".equalsIgnoreCase(args)) {\n+                            out.println(\"200 EPSV ALL command successful.\");\n+                            System.err.println(\"S> 200\");\n+                            continue;\n+                        }\n+                        out.println(\"229 Entering Extended Passive Mode (|||\" + pasv.getLocalPort() + \"|)\");\n+                        System.err.println(\"S> 229\");\n+                        break;\n+                    default:\n+                        System.err.println(\"S> 500\");\n+                        out.println(\"500 unsupported command: \" + str);\n+                }\n+            }\n+        }\n+\n+        public int getPort() {\n+            return serverSocket.getLocalPort();\n+        }\n+\n+        public void close() throws IOException {\n+            serverSocket.close();\n+            pasv.close();\n+        }\n+\n+        @Override\n+        public void run() {\n+            try (Socket client = serverSocket.accept()) {\n+                handleClient(client);\n+            } catch (Throwable t) {\n+                t.printStackTrace();\n+                throw new RuntimeException(\"Problem in test execution\", t);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/net\/ftp\/TestFtpTimeValue.java","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8149411\n+ * @bug 8149411 8007632\n@@ -28,0 +28,3 @@\n+ * @run main P12SecretKey pkcs12 AES 128\n+ * @run main P12SecretKey pkcs12 DES 56\n+ * @run main P12SecretKey pkcs12 DESede 168\n@@ -46,5 +49,4 @@\n-        String keystoreType = \"pkcs12\";\n-        if (args != null && args.length > 0) {\n-            keystoreType = args[0];\n-        }\n-        testp12.run(keystoreType);\n+        String keystoreType = args[0];\n+        String algName = args[1];\n+        int keySize = Integer.parseInt(args[2]);\n+        testp12.run(keystoreType, algName, keySize);\n@@ -53,1 +55,1 @@\n-    private void run(String keystoreType) throws Exception {\n+    private void run(String keystoreType, String algName, int keySize) throws Exception {\n@@ -58,2 +60,2 @@\n-        KeyGenerator kg = KeyGenerator.getInstance(\"AES\");\n-        kg.init(128);\n+        KeyGenerator kg = KeyGenerator.getInstance(algName);\n+        kg.init(keySize);\n","filename":"test\/jdk\/sun\/security\/pkcs12\/P12SecretKey.java","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @modules java.base\/sun.security.util\n+ * @modules java.base\/sun.security.util:+open\n@@ -38,1 +38,0 @@\n-import jdk.test.lib.hexdump.HexPrinter;\n","filename":"test\/jdk\/sun\/security\/util\/DerValue\/Indefinite.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -121,0 +121,1 @@\n+        map.put(\"jdk.containerized\", this::jdkContainerized);\n@@ -548,0 +549,5 @@\n+    private String jdkContainerized() {\n+        String isEnabled = System.getenv(\"TEST_JDK_CONTAINERIZED\");\n+        return \"\" + \"true\".equalsIgnoreCase(isEnabled);\n+    }\n+\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug      8236539\n+ * @bug      8236539 8246774\n@@ -31,1 +31,0 @@\n- * @compile TestRecordLinks.java\n@@ -77,1 +76,0 @@\n-                \"--enable-preview\", \"--source\", thisRelease,\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testRecordLinks\/TestRecordLinks.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug      8225055 8239804\n+ * @bug      8225055 8239804 8246774\n@@ -31,2 +31,1 @@\n- * @compile --enable-preview --source ${jdk.version} TestRecordTypes.java\n- * @run main\/othervm --enable-preview TestRecordTypes\n+ * @run main TestRecordTypes\n@@ -72,1 +71,0 @@\n-                \"--enable-preview\", \"--source\", thisRelease,\n@@ -94,1 +92,0 @@\n-                \"--enable-preview\", \"--source\", thisRelease,\n@@ -116,1 +113,0 @@\n-                \"--enable-preview\", \"--source\", thisRelease,\n@@ -142,1 +138,0 @@\n-                \"--enable-preview\", \"--source\", thisRelease,\n@@ -174,1 +169,0 @@\n-                \"--enable-preview\", \"--source\", thisRelease,\n@@ -207,1 +201,0 @@\n-                \"--enable-preview\", \"--source\", thisRelease,\n@@ -271,1 +264,0 @@\n-                \"--enable-preview\", \"--source\", thisRelease,\n@@ -352,1 +344,0 @@\n-                \"--enable-preview\", \"--source\", thisRelease,\n@@ -378,1 +369,0 @@\n-                \"--enable-preview\", \"--source\", thisRelease,\n@@ -409,1 +399,0 @@\n-                \"--enable-preview\", \"--source\", thisRelease,\n@@ -418,1 +407,0 @@\n-                \"--enable-preview\", \"--source\", thisRelease,\n@@ -424,1 +412,0 @@\n-    @SuppressWarnings(\"preview\")\n@@ -471,1 +458,0 @@\n-                \"--enable-preview\", \"--source\", thisRelease,\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testRecordTypes\/TestRecordTypes.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 6493690\n+ * @bug 6493690 8246774\n@@ -81,1 +81,1 @@\n-                        \"compiler.err.expected3\",   \/\/ class, interface, enum, or __datum expected\n+                        \"compiler.err.expected4\",   \/\/ class, interface, enum, or record expected\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/api\/basic\/GetTask_DiagListenerTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8149524 8131024 8165211 8080071 8130454 8167343 8129559 8114842 8182268 8223782 8235474\n+ * @bug 8149524 8131024 8165211 8080071 8130454 8167343 8129559 8114842 8182268 8223782 8235474 8246774\n@@ -382,6 +382,0 @@\n-\n-    @BeforeMethod\n-    public void setUp() {\n-        setUp(b -> b.compilerOptions(\"--enable-preview\", \"-source\", String.valueOf(SourceVersion.latest().ordinal())));\n-    }\n-\n","filename":"test\/langtools\/jdk\/jshell\/CompletenessTest.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8235474 8236715\n+ * @bug 8235474 8236715 8246774\n@@ -79,6 +79,0 @@\n-\n-    @BeforeMethod\n-    public void setUp() {\n-        setUp(b -> b.compilerOptions(\"--enable-preview\", \"-source\", String.valueOf(SourceVersion.latest().ordinal()))\n-                    .remoteVMOptions(\"--enable-preview\"));\n-    }\n","filename":"test\/langtools\/jdk\/jshell\/RecordsTest.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8153716 8143955 8151754 8150382 8153920 8156910 8131024 8160089 8153897 8167128 8154513 8170015 8170368 8172102 8172103  8165405 8173073 8173848 8174041 8173916 8174028 8174262 8174797 8177079 8180508 8177466 8172154 8192979 8191842 8198573 8198801 8210596 8210959 8215099 8199623 8236715 8239536 8247456\n+ * @bug 8153716 8143955 8151754 8150382 8153920 8156910 8131024 8160089 8153897 8167128 8154513 8170015 8170368 8172102 8172103  8165405 8173073 8173848 8174041 8173916 8174028 8174262 8174797 8177079 8180508 8177466 8172154 8192979 8191842 8198573 8198801 8210596 8210959 8215099 8199623 8236715 8239536 8247456 8246774\n@@ -33,1 +33,1 @@\n- * @run testng\/othervm ToolSimpleTest\n+ * @run testng ToolSimpleTest\n@@ -920,1 +920,1 @@\n-        test(new String[] {\"--enable-preview\"},\n+        test(new String[] {},\n","filename":"test\/langtools\/jdk\/jshell\/ToolSimpleTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * @bug 5012028 6384539 8074364 8250741\n+ * @bug 5012028 6384539 8074364 8250741 8246774\n@@ -7,1 +7,0 @@\n- * @compile\/fail\/ref=IllegalAnnotation.out -XDrawDiagnostics --enable-preview -source ${jdk.version} IllegalAnnotation.java\n","filename":"test\/langtools\/tools\/javac\/IllegalAnnotation.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-IllegalAnnotation.java:11:10: compiler.err.annotation.decl.not.allowed.here\n+IllegalAnnotation.java:10:10: compiler.err.annotation.decl.not.allowed.here\n","filename":"test\/langtools\/tools\/javac\/IllegalAnnotation.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * @bug 8242478\n+ * @bug 8242478 8246774\n@@ -5,2 +5,2 @@\n- * @compile\/fail\/ref=LocalInterface.out -XDrawDiagnostics LocalInterface.java\n- * @compile --enable-preview -source ${jdk.version} LocalInterface.java\n+ * @compile\/fail\/ref=LocalInterface.out -XDrawDiagnostics -source 15 LocalInterface.java\n+ * @compile LocalInterface.java\n","filename":"test\/langtools\/tools\/javac\/LocalInterface.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+- compiler.warn.source.no.system.modules.path: 15\n@@ -3,0 +4,1 @@\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/LocalInterface.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8242478\n+ * @bug 8242478 8246774\n@@ -28,1 +28,1 @@\n- * @compile --enable-preview -source ${jdk.version} LocalRecord.java\n+ * @compile LocalRecord.java\n","filename":"test\/langtools\/tools\/javac\/LocalRecord.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @bug 8241312\n+ * @bug 8241312 8246774\n@@ -31,2 +31,1 @@\n- * @compile --enable-preview -source ${jdk.version} ApplicableAnnotationsOnRecords.java\n- * @run main\/othervm --enable-preview ApplicableAnnotationsOnRecords\n+ * @run main ApplicableAnnotationsOnRecords\n","filename":"test\/langtools\/tools\/javac\/annotations\/ApplicableAnnotationsOnRecords.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug      7151010 8006547 8007766 8029017\n+ * @bug      7151010 8006547 8007766 8029017 8246774\n@@ -207,5 +207,2 @@\n-    \/\/ options to be passed if all targets, including RECORD_COMPONENTS, are to be considered\n-    List<String> previewOptions = List.of(\n-            \"--enable-preview\",\n-            \"-source\", Integer.toString(Runtime.version().feature())\n-    );\n+    \/\/ options to be passed if target RECORD_COMPONENT can't be considered\n+    List<String> source8 = List.of(\"-source\", \"8\");\n@@ -217,1 +214,1 @@\n-                new TestCase(noSet, noSet),\n+    \/*  0*\/     new TestCase(noSet, noSet),\n@@ -219,1 +216,1 @@\n-                new TestCase(noSet, empty),\n+    \/*  1*\/     new TestCase(noSet, empty),\n@@ -221,1 +218,1 @@\n-                new TestCase(noSet, less(jdk8, TYPE_PARAMETER)),\n+                new TestCase(noSet, less(jdk8, TYPE_PARAMETER), source8),\n@@ -223,1 +220,1 @@\n-                new TestCase(noSet, less(jdk8, TYPE_USE)),\n+                new TestCase(noSet, less(jdk8, TYPE_USE), source8),\n@@ -225,1 +222,1 @@\n-                new TestCase(noSet, jdk8),\n+                new TestCase(noSet, jdk8, source8),\n@@ -236,1 +233,1 @@\n-                new TestCase(noSet, plus(empty, METHOD)),\n+    \/*  10*\/    new TestCase(noSet, plus(empty, METHOD)),\n@@ -249,1 +246,1 @@\n-                new TestCase(empty, plus(empty, METHOD)),\n+    \/*  20*\/    new TestCase(empty, plus(empty, METHOD)),\n@@ -254,2 +251,2 @@\n-                new TestCase(empty, less(jdk8, TYPE_USE)),\n-                new TestCase(empty, less(jdk8, TYPE_PARAMETER)),\n+                new TestCase(empty, less(jdk8, TYPE_USE), source8),\n+                new TestCase(empty, less(jdk8, TYPE_PARAMETER), source8),\n@@ -257,8 +254,8 @@\n-                new TestCase(less(jdk7, TYPE), noSet),\n-                new TestCase(less(jdk7, PARAMETER), noSet),\n-                new TestCase(less(jdk7, PACKAGE), noSet),\n-                new TestCase(less(jdk7, METHOD), noSet),\n-                new TestCase(less(jdk7, LOCAL_VARIABLE), noSet),\n-                new TestCase(less(jdk7, FIELD), noSet),\n-                new TestCase(less(jdk7, CONSTRUCTOR), noSet),\n-                new TestCase(less(jdk7, ANNOTATION_TYPE), noSet),\n+                new TestCase(less(jdk7, TYPE), noSet, source8),\n+                new TestCase(less(jdk7, PARAMETER), noSet, source8),\n+                new TestCase(less(jdk7, PACKAGE), noSet, source8),\n+    \/*  30*\/    new TestCase(less(jdk7, METHOD), noSet, source8),\n+                new TestCase(less(jdk7, LOCAL_VARIABLE), noSet, source8),\n+                new TestCase(less(jdk7, FIELD), noSet, source8),\n+                new TestCase(less(jdk7, CONSTRUCTOR), noSet, source8),\n+                new TestCase(less(jdk7, ANNOTATION_TYPE), noSet, source8),\n@@ -268,1 +265,1 @@\n-                new TestCase(jdk7, noSet),\n+                new TestCase(jdk7, noSet, source8),\n@@ -270,3 +267,3 @@\n-                new TestCase(plus(jdk7, TYPE_USE), noSet),\n-                new TestCase(plus(jdk7, TYPE_PARAMETER), noSet),\n-                new TestCase(allTargets, noSet, previewOptions),\n+                new TestCase(plus(jdk7, TYPE_USE), noSet, source8),\n+                new TestCase(plus(jdk7, TYPE_PARAMETER), noSet, source8),\n+                new TestCase(allTargets, noSet, null),\n@@ -274,1 +271,1 @@\n-                new TestCase(plus(empty, TYPE), empty),\n+    \/*  40*\/    new TestCase(plus(empty, TYPE), empty),\n@@ -285,1 +282,1 @@\n-                new TestCase(allTargets, allTargets, previewOptions),\n+    \/*  50*\/    new TestCase(allTargets, allTargets),\n@@ -287,10 +284,10 @@\n-                new TestCase(allTargets, less(allTargets, TYPE), previewOptions),\n-                new TestCase(allTargets, less(allTargets, PARAMETER), previewOptions),\n-                new TestCase(allTargets, less(allTargets, PACKAGE), previewOptions),\n-                new TestCase(allTargets, less(allTargets, METHOD), previewOptions),\n-                new TestCase(allTargets, less(allTargets, LOCAL_VARIABLE), previewOptions),\n-                new TestCase(allTargets, less(allTargets, FIELD), previewOptions),\n-                new TestCase(allTargets, less(allTargets, CONSTRUCTOR), previewOptions),\n-                new TestCase(allTargets, less(allTargets, ANNOTATION_TYPE), previewOptions),\n-                new TestCase(allTargets, less(allTargets, TYPE_USE), previewOptions),\n-                new TestCase(allTargets, less(allTargets, TYPE_PARAMETER), previewOptions),\n+                new TestCase(allTargets, less(allTargets, TYPE)),\n+                new TestCase(allTargets, less(allTargets, PARAMETER)),\n+                new TestCase(allTargets, less(allTargets, PACKAGE)),\n+                new TestCase(allTargets, less(allTargets, METHOD)),\n+                new TestCase(allTargets, less(allTargets, LOCAL_VARIABLE)),\n+                new TestCase(allTargets, less(allTargets, FIELD)),\n+                new TestCase(allTargets, less(allTargets, CONSTRUCTOR)),\n+                new TestCase(allTargets, less(allTargets, ANNOTATION_TYPE)),\n+                new TestCase(allTargets, less(allTargets, TYPE_USE)),\n+    \/*  60*\/    new TestCase(allTargets, less(allTargets, TYPE_PARAMETER)),\n@@ -298,10 +295,10 @@\n-                new TestCase(less(allTargets, TYPE), allTargets, previewOptions),\n-                new TestCase(less(allTargets, PARAMETER), allTargets, previewOptions),\n-                new TestCase(less(allTargets, PACKAGE), allTargets, previewOptions),\n-                new TestCase(less(allTargets, METHOD), allTargets, previewOptions),\n-                new TestCase(less(allTargets, LOCAL_VARIABLE), allTargets, previewOptions),\n-                new TestCase(less(allTargets, FIELD), allTargets, previewOptions),\n-                new TestCase(less(allTargets, CONSTRUCTOR), allTargets, previewOptions),\n-                new TestCase(less(allTargets, ANNOTATION_TYPE), allTargets, previewOptions),\n-                new TestCase(less(allTargets, TYPE_USE), allTargets, previewOptions),\n-                new TestCase(less(allTargets, TYPE_PARAMETER), allTargets, previewOptions)));\n+                new TestCase(less(allTargets, TYPE), allTargets),\n+                new TestCase(less(allTargets, PARAMETER), allTargets),\n+                new TestCase(less(allTargets, PACKAGE), allTargets),\n+                new TestCase(less(allTargets, METHOD), allTargets),\n+                new TestCase(less(allTargets, LOCAL_VARIABLE), allTargets),\n+                new TestCase(less(allTargets, FIELD), allTargets),\n+                new TestCase(less(allTargets, CONSTRUCTOR), allTargets),\n+                new TestCase(less(allTargets, ANNOTATION_TYPE), allTargets),\n+                new TestCase(less(allTargets, TYPE_USE), allTargets),\n+    \/*  70*\/    new TestCase(less(allTargets, TYPE_PARAMETER), allTargets)));\n@@ -312,1 +309,1 @@\n-                testCases.add(new TestCase(plus(empty, b), plus(empty, c), previewOptions));\n+                testCases.add(new TestCase(plus(empty, b), plus(empty, c)));\n@@ -459,1 +456,1 @@\n-                    errMesg = \"Test failed, compiled unexpectedly.\";\n+                    errMesg = \"Test failed, should have compiled successfully.\";\n","filename":"test\/langtools\/tools\/javac\/annotations\/repeatingAnnotations\/combo\/TargetAnnoCombo.java","additions":48,"deletions":51,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8246774\n@@ -35,2 +36,1 @@\n- * @compile --enable-preview -source ${jdk.version} TypeAnnotationsPositionsOnRecords.java\n- * @run main\/othervm --enable-preview TypeAnnotationsPositionsOnRecords\n+ * @run main TypeAnnotationsPositionsOnRecords\n@@ -108,1 +108,0 @@\n-                .options(\"--enable-preview\", \"-source\", Integer.toString(Runtime.version().feature()))\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/TypeAnnotationsPositionsOnRecords.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-AnnotatedImport.java:10:16: compiler.err.expected3: class, interface, enum\n+AnnotatedImport.java:10:16: compiler.err.expected4: class, interface, enum, record\n@@ -4,1 +4,1 @@\n-AnnotatedImport.java:11:11: compiler.err.expected3: class, interface, enum\n+AnnotatedImport.java:11:11: compiler.err.expected4: class, interface, enum, record\n@@ -6,1 +6,1 @@\n-AnnotatedImport.java:12:21: compiler.err.expected3: class, interface, enum\n+AnnotatedImport.java:12:21: compiler.err.expected4: class, interface, enum, record\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/failures\/AnnotatedImport.out","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-AnnotatedPackage1.java:9:17: compiler.err.expected3: class, interface, enum\n+AnnotatedPackage1.java:9:17: compiler.err.expected4: class, interface, enum, record\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/failures\/AnnotatedPackage1.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-AnnotatedPackage2.java:9:12: compiler.err.expected3: class, interface, enum\n+AnnotatedPackage2.java:9:12: compiler.err.expected4: class, interface, enum, record\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/failures\/AnnotatedPackage2.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8205418 8207229 8207230 8230847 8245786 8247334 8248641 8240658\n+ * @bug 8205418 8207229 8207230 8230847 8245786 8247334 8248641 8240658 8246774\n@@ -32,1 +32,0 @@\n- * @compile TestGetScopeResult.java\n@@ -562,3 +561,1 @@\n-            List<String> options = List.of(\"--enable-preview\",\n-                                           \"-source\", System.getProperty(\"java.specification.version\"));\n-            JavacTask t = (JavacTask) c.getTask(null, fm, null, options, null,\n+            JavacTask t = (JavacTask) c.getTask(null, fm, null, null, null,\n@@ -639,3 +636,1 @@\n-                List<String> options = List.of(\"--enable-preview\",\n-                                               \"-source\", System.getProperty(\"java.specification.version\"));\n-                JavacTask t = (JavacTask) c.getTask(null, fm, null, options, null,\n+                JavacTask t = (JavacTask) c.getTask(null, fm, null, null, null,\n","filename":"test\/langtools\/tools\/javac\/api\/TestGetScopeResult.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,3 +26,0 @@\n-\/\/ key: compiler.note.preview.filename\n-\/\/ key: compiler.note.preview.recompile\n-\/\/ options: --enable-preview -source ${jdk.version}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/AccessorCantBeGeneric.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,3 +26,0 @@\n-\/\/ key: compiler.note.preview.filename\n-\/\/ key: compiler.note.preview.recompile\n-\/\/ options: --enable-preview -source ${jdk.version}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/AccessorCantThrowException.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,3 +26,0 @@\n-\/\/ key: compiler.note.preview.filename\n-\/\/ key: compiler.note.preview.recompile\n-\/\/ options: --enable-preview -source ${jdk.version}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/AccessorMethodCantBeStatic.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,3 +26,0 @@\n-\/\/ key: compiler.note.preview.filename\n-\/\/ key: compiler.note.preview.recompile\n-\/\/ options: --enable-preview -source ${jdk.version}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/AccessorReturnTypeDoesntMatch.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-\/\/ key: compiler.note.preview.filename\n-\/\/ key: compiler.note.preview.recompile\n@@ -29,1 +27,0 @@\n-\/\/ options: --enable-preview -source ${jdk.version}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CanonicalCantHaveStrongerAccessPrivileges.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-\/\/ key: compiler.note.preview.filename\n-\/\/ key: compiler.note.preview.recompile\n@@ -29,1 +27,0 @@\n-\/\/ options: --enable-preview -source ${jdk.version}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CanonicalCantInvokeOtherConstructor.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-\/\/ key: compiler.note.preview.filename\n-\/\/ key: compiler.note.preview.recompile\n@@ -29,1 +27,0 @@\n-\/\/ options: --enable-preview -source ${jdk.version}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CanonicalConstructorArgumentMismatch.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-\/\/ key: compiler.note.preview.filename\n-\/\/ key: compiler.note.preview.recompile\n@@ -29,1 +27,0 @@\n-\/\/ options: --enable-preview -source ${jdk.version}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CanonicalConstructorCantHaveReturn.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-\/\/ key: compiler.note.preview.filename\n-\/\/ key: compiler.note.preview.recompile\n@@ -29,1 +27,0 @@\n-\/\/ options: --enable-preview -source ${jdk.version}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CanonicalConstructorCantHaveThrowsClause.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-\/\/ key: compiler.note.preview.filename\n-\/\/ key: compiler.note.preview.recompile\n@@ -29,1 +27,0 @@\n-\/\/ options: --enable-preview -source ${jdk.version}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CanonicalMustNotDeclareTypeVariables.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-\/\/ key: compiler.note.preview.filename\n-\/\/ key: compiler.note.preview.recompile\n@@ -29,1 +27,0 @@\n-\/\/ options: --enable-preview -source ${jdk.version}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ConstructorWithSameErasureAsCanonical.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+\/\/ key: compiler.warn.source.no.system.modules.path\n+\/\/ options: -source 15\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/Expected3.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-\/\/ key: compiler.note.preview.filename\n-\/\/ key: compiler.note.preview.recompile\n-\/\/ options: --enable-preview -source ${jdk.version}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/FirstInvocationMustBeAnotherConstructor.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-\/\/ key: compiler.note.preview.filename\n-\/\/ key: compiler.note.preview.recompile\n-\/\/ options: --enable-preview -source ${jdk.version}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/IllegalRecordComponentName.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-\/\/ key: compiler.note.preview.filename\n-\/\/ key: compiler.note.preview.recompile\n-\/\/ options: --enable-preview -source ${jdk.version}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/IncorrectRecordDeclaration.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-\/\/ key: compiler.note.preview.filename\n-\/\/ key: compiler.note.preview.recompile\n-\/\/ options: --enable-preview -source ${jdk.version}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/InstanceInitializersNotAllowedInRecords.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+\/\/ key: compiler.warn.source.no.system.modules.path\n+\/\/ options: -source 15\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/InterfaceNotAllowed.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-\/\/ options: --enable-preview -source ${jdk.version}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/InvalidSuperTypeRecord.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,3 +30,0 @@\n-\/\/ key: compiler.note.preview.filename\n-\/\/ key: compiler.note.preview.recompile\n-\/\/ key: compiler.note.note\n@@ -34,1 +31,0 @@\n-\/\/ options: --enable-preview -source ${jdk.version}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/KindnameRecord.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+\/\/ key: compiler.warn.source.no.system.modules.path\n+\/\/ options: -source 15\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/LocalEnum.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,3 +26,0 @@\n-\/\/ key: compiler.note.preview.filename\n-\/\/ key: compiler.note.preview.recompile\n-\/\/ options: --enable-preview -source ${jdk.version}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/MethodMustBePublic.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,2 +25,3 @@\n-\/\/ key: compiler.warn.preview.feature.use.plural\n-\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\/\/ key: compiler.err.feature.not.supported.in.source.plural\n+\/\/ key: compiler.warn.source.no.system.modules.path\n+\/\/ options: -source 15\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/Records.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-\/\/ key: compiler.note.preview.filename\n-\/\/ key: compiler.note.preview.recompile\n-\/\/ options: --enable-preview -source ${jdk.version}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/RecordsCanNotDeclareInstanceFields.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-\/\/ key: compiler.note.preview.filename\n-\/\/ key: compiler.note.preview.recompile\n-\/\/ options: --enable-preview -source ${jdk.version}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/RecordsCantDeclareComponentModifiers.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-\/\/ key: compiler.note.preview.filename\n-\/\/ key: compiler.note.preview.recompile\n-\/\/ options: --enable-preview -source ${jdk.version}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/RecordsComponentsCanNotDeclareCStyleArrays.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-\/\/ key: compiler.note.preview.filename\n-\/\/ key: compiler.note.preview.recompile\n-\/\/ options: --enable-preview -source ${jdk.version}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/RecordsNotAllowedInInnerClasses.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -8,1 +8,0 @@\n- * @compile\/fail\/ref=FauxEnum3.out -XDrawDiagnostics --enable-preview -source ${jdk.version} FauxEnum3.java\n","filename":"test\/langtools\/tools\/javac\/enum\/FauxEnum3.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,2 +1,2 @@\n-FauxEnum3.java:11:14: compiler.err.enum.types.not.extensible\n-1 error\n\\ No newline at end of file\n+FauxEnum3.java:10:14: compiler.err.enum.types.not.extensible\n+1 error\n","filename":"test\/langtools\/tools\/javac\/enum\/FauxEnum3.out","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * @bug 5019609\n+ * @bug 5019609 8246774\n@@ -6,2 +6,2 @@\n- * @compile\/fail\/ref=LocalEnum.out -XDrawDiagnostics  LocalEnum.java\n- * @compile --enable-preview -source ${jdk.version}  LocalEnum.java\n+ * @compile\/fail\/ref=LocalEnum.out -XDrawDiagnostics -source 15 LocalEnum.java\n+ * @compile LocalEnum.java\n","filename":"test\/langtools\/tools\/javac\/enum\/LocalEnum.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+- compiler.warn.source.no.system.modules.path: 15\n@@ -3,0 +4,1 @@\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/enum\/LocalEnum.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8192920 8204588\n+ * @bug 8192920 8204588 8246774\n@@ -302,1 +302,1 @@\n-            file + \":1: error: class, interface, or enum expected\\n\" +\n+            file + \":1: error: class, interface, enum, or record expected\\n\" +\n@@ -508,1 +508,1 @@\n-            file + \":1: error: class, interface, or enum expected\\n\" +\n+            file + \":1: error: class, interface, enum, or record expected\\n\" +\n","filename":"test\/langtools\/tools\/javac\/launcher\/SourceLauncherTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 7073631 7159445 7156633 8028235 8065753 8205418 8205913 8228451 8237041 8253584\n+ * @bug 7073631 7159445 7156633 8028235 8065753 8205418 8205913 8228451 8237041 8253584 8246774\n@@ -1002,1 +1002,1 @@\n-        String expectedErrors = \"Test.java:1:1: compiler.err.expected3: class, interface, enum\\n\" +\n+        String expectedErrors = \"Test.java:1:1: compiler.err.expected4: class, interface, enum, record\\n\" +\n","filename":"test\/langtools\/tools\/javac\/parser\/JavacParserTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-SingleCommaAnnotationValueFail.java:34:14: compiler.err.expected3: class, interface, enum\n+SingleCommaAnnotationValueFail.java:34:14: compiler.err.expected4: class, interface, enum, record\n","filename":"test\/langtools\/tools\/javac\/parser\/SingleCommaAnnotationValueFail.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8246774\n@@ -70,1 +71,0 @@\n-        System.out.println(System.getProperties());\n@@ -108,5 +108,3 @@\n-        List<String> expected = List.of(\"Note: field: i\",\n-                \"Note: record component: i\",\n-                \"Note: testQualifiedClassForProcessing\" + File.separator + \"src\" + File.separator\n-                     + \"R\" + File.separator + \"R.java uses preview language features.\",\n-                \"Note: Recompile with -Xlint:preview for details.\");\n+        List<String> expected = List.of(\n+                \"Note: field: i\",\n+                \"Note: record component: i\");\n@@ -116,3 +114,1 @@\n-                    .options(\"-processor\", QualifiedClassForProcessing.class.getName(),\n-                            \"--enable-preview\",\n-                            \"-source\", Integer.toString(Runtime.version().feature()))\n+                    .options(\"-processor\", QualifiedClassForProcessing.class.getName())\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/JavaxLangModelForRecords.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8241312\n+ * @bug 8241312 8246774\n@@ -50,2 +50,1 @@\n-        JavacTask t = (JavacTask) c.getTask(null, null, null,\n-                List.of(\"--enable-preview\", \"-source\", Integer.toString(Runtime.version().feature())), null,\n+        JavacTask t = (JavacTask) c.getTask(null, null, null, null, null,\n","filename":"test\/langtools\/tools\/javac\/records\/ElementFilterRecordComponentTest.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8242293\n+ * @bug 8242293 8246774\n@@ -33,2 +33,1 @@\n- * @compile --enable-preview -source ${jdk.version} LocalStaticDeclarations.java\n- * @run main\/othervm --enable-preview LocalStaticDeclarations\n+ * @run main LocalStaticDeclarations\n@@ -178,1 +177,0 @@\n-                .withOptions(new String[]{\"--enable-preview\", \"-source\", Integer.toString(Runtime.version().feature())})\n","filename":"test\/langtools\/tools\/javac\/records\/LocalStaticDeclarations.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8246774\n@@ -54,2 +55,1 @@\n-        JavacTask t = (JavacTask) c.getTask(null, null, null,\n-                List.of(\"--enable-preview\", \"-source\", Integer.toString(Runtime.version().feature())), null,\n+        JavacTask t = (JavacTask) c.getTask(null, null, null, null, null,\n","filename":"test\/langtools\/tools\/javac\/records\/MapAccessorToComponent.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,2 @@\n- * @test 8250629 8252307 8247352 8241151\n+ * @test\n+ * @bug 8250629 8252307 8247352 8241151 8246774\n@@ -38,3 +39,2 @@\n- * @compile --enable-preview -source ${jdk.version} RecordCompilationTests.java\n- * @run testng\/othervm -DuseAP=false --enable-preview RecordCompilationTests\n- * @run testng\/othervm -DuseAP=true --enable-preview RecordCompilationTests\n+ * @run testng\/othervm -DuseAP=false RecordCompilationTests\n+ * @run testng\/othervm -DuseAP=true RecordCompilationTests\n@@ -122,11 +122,1 @@\n-    \/\/ @@@ When records become a permanent feature, we don't need these any more\n-    private static String[] PREVIEW_OPTIONS = {\n-            \"--enable-preview\",\n-            \"-source\", Integer.toString(Runtime.version().feature())\n-    };\n-\n-    private static String[] PREVIEW_OPTIONS_WITH_AP = {\n-            \"--enable-preview\",\n-            \"-source\", Integer.toString(Runtime.version().feature()),\n-            \"-processor\", SimplestAP.class.getName()\n-    };\n+    private static String[] OPTIONS_WITH_AP = {\"-processor\", SimplestAP.class.getName()};\n@@ -153,1 +143,3 @@\n-        setCompileOptions(useAP ? PREVIEW_OPTIONS_WITH_AP : PREVIEW_OPTIONS);\n+        if (useAP) {\n+            setCompileOptions(OPTIONS_WITH_AP);\n+        }\n@@ -1013,1 +1005,1 @@\n-        assertOKWithWarning(\"compiler.warn.restricted.type.not.allowed.preview\",\n+        assertFail(\"compiler.err.illegal.start.of.type\",\n@@ -1065,2 +1057,0 @@\n-                \"--enable-preview\",\n-                \"-source\", Integer.toString(Runtime.version().feature()),\n","filename":"test\/langtools\/tools\/javac\/records\/RecordCompilationTests.java","additions":9,"deletions":19,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n- * RecordMemberTests\n- *\n@@ -30,2 +28,3 @@\n- * @compile --enable-preview -source ${jdk.version} RecordMemberTests.java\n- * @run testng\/othervm --enable-preview RecordMemberTests\n+ * @bug 8246774\n+ * @summary test several assertions on record classes members\n+ * @run testng RecordMemberTests\n","filename":"test\/langtools\/tools\/javac\/records\/RecordMemberTests.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,2 +36,0 @@\n- * VarargsRecordsTest\n- *\n@@ -39,2 +37,3 @@\n- * @compile --enable-preview -source ${jdk.version} VarargsRecordsTest.java\n- * @run testng\/othervm --enable-preview VarargsRecordsTest\n+ * @bug 8246774\n+ * @summary test for varargs record components\n+ * @run testng VarargsRecordsTest\n","filename":"test\/langtools\/tools\/javac\/records\/VarargsRecordsTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @bug 8246774\n@@ -35,1 +36,1 @@\n- * @run main\/othervm --enable-preview CheckRecordMembers\n+ * @run main CheckRecordMembers\n@@ -105,1 +106,0 @@\n-                .withOptions(new String[]{\"--enable-preview\", \"-source\", Integer.toString(Runtime.version().feature())})\n","filename":"test\/langtools\/tools\/javac\/records\/mandated_members\/CheckRecordMembers.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8246774\n@@ -27,2 +28,2 @@\n- * @compile --enable-preview -source ${jdk.version} Record.java\n- * @compile --enable-preview -source ${jdk.version} WriteReadTest.java\n+ * @compile Record.java\n+ * @compile WriteReadTest.java\n","filename":"test\/langtools\/tools\/javac\/records\/writeread\/WriteReadTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -82,0 +82,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCMethodDecl;\n@@ -422,0 +423,8 @@\n+        @Override\n+        public void visitMethodDef(JCMethodDecl tree) {\n+            \/\/ ignore compact record constructors\n+            if ((tree.mods.flags & Flags.COMPACT_RECORD_CONSTRUCTOR) == 0) {\n+                super.visitMethodDef(tree);\n+            }\n+        }\n+\n","filename":"test\/langtools\/tools\/javac\/tree\/TreePosTest.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8241312\n+ * @bug 8241312 8246774\n@@ -32,1 +32,0 @@\n- * @run main PubApisTest\n@@ -51,2 +50,1 @@\n-        JavacTask t = (JavacTask) c.getTask(null, null, null,\n-                List.of(\"--enable-preview\", \"-source\", Integer.toString(Runtime.version().feature())), null,\n+        JavacTask t = (JavacTask) c.getTask(null, null, null, null, null,\n","filename":"test\/langtools\/tools\/sjavac\/PubApisTest.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+ * @modules java.base\/sun.security.util\n","filename":"test\/lib-test\/jdk\/test\/lib\/hexdump\/ASN1FormatterTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -415,1 +415,0 @@\n-            findMatch.setAccessible(true);\n","filename":"test\/lib\/jdk\/test\/lib\/hexdump\/ASN1Formatter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-@Fork(value = 1, warmups = 0, jvmArgsAppend = \"--enable-preview\")\n+@Fork(value = 1, warmups = 0)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/io\/RecordDeserialization.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import org.openjdk.jmh.annotations.Param;\n@@ -30,0 +31,1 @@\n+import org.openjdk.jmh.annotations.Setup;\n@@ -32,0 +34,1 @@\n+import org.openjdk.jmh.infra.Blackhole;\n@@ -44,12 +47,31 @@\n-    private static final int loops = 100000;\n-    private static final Random rng = new Random(1999);\n-    private static final int pathCnt = 1000;\n-    private static final String [] latn1_short        = new String[pathCnt];\n-    private static final String [] latn1_sse4         = new String[pathCnt];\n-    private static final String [] latn1_avx2         = new String[pathCnt];\n-    private static final String [] latn1_mixedLength  = new String[pathCnt];\n-    private static final String [] utf16_short        = new String[pathCnt];\n-    private static final String [] utf16_sse4         = new String[pathCnt];\n-    private static final String [] utf16_avx2         = new String[pathCnt];\n-    private static final String [] utf16_mixedLength  = new String[pathCnt];\n-    static {\n+    @Param(\"100000\")\n+    private int loops;\n+\n+    @Param(\"1000\")\n+    private int pathCnt;\n+\n+    @Param(\"1999\")\n+    private int rngSeed;\n+\n+    private Random rng;\n+    private String[] latn1_short;\n+    private String[] latn1_sse4;\n+    private String[] latn1_avx2;\n+    private String[] latn1_mixedLength;\n+    private String[] utf16_short;\n+    private String[] utf16_sse4;\n+    private String[] utf16_avx2;\n+    private String[] utf16_mixedLength;\n+\n+    @Setup\n+    public void setup() {\n+        rng = new Random(rngSeed);\n+        latn1_short        = new String[pathCnt];\n+        latn1_sse4         = new String[pathCnt];\n+        latn1_avx2         = new String[pathCnt];\n+        latn1_mixedLength  = new String[pathCnt];\n+        utf16_short        = new String[pathCnt];\n+        utf16_sse4         = new String[pathCnt];\n+        utf16_avx2         = new String[pathCnt];\n+        utf16_mixedLength  = new String[pathCnt];\n+\n@@ -68,1 +90,1 @@\n-    private static String makeRndString(boolean isUtf16, int length) {\n+    private String makeRndString(boolean isUtf16, int length) {\n@@ -84,2 +106,1 @@\n-    public void latin1_mixed_char() {\n-        int ret = 0;\n+    public void latin1_mixed_char(Blackhole bh) {\n@@ -87,1 +108,1 @@\n-            ret += what.indexOf('a');\n+            bh.consume(what.indexOf('a'));\n@@ -92,2 +113,1 @@\n-    public void utf16_mixed_char() {\n-        int ret = 0;\n+    public void utf16_mixed_char(Blackhole bh) {\n@@ -95,1 +115,1 @@\n-            ret += what.indexOf('a');\n+            bh.consume(what.indexOf('a'));\n@@ -100,2 +120,1 @@\n-    public void latin1_mixed_String() {\n-        int ret = 0;\n+    public void latin1_mixed_String(Blackhole bh) {\n@@ -103,1 +122,1 @@\n-            ret += what.indexOf(\"a\");\n+            bh.consume(what.indexOf(\"a\"));\n@@ -108,2 +127,1 @@\n-    public void utf16_mixed_String() {\n-        int ret = 0;\n+    public void utf16_mixed_String(Blackhole bh) {\n@@ -111,1 +129,1 @@\n-            ret += what.indexOf(\"a\");\n+            bh.consume(what.indexOf(\"a\"));\n@@ -118,2 +136,1 @@\n-    public void latin1_Short_char() {\n-        int ret = 0;\n+    public void latin1_Short_char(Blackhole bh) {\n@@ -121,1 +138,1 @@\n-            ret += what.indexOf('a');\n+            bh.consume(what.indexOf('a'));\n@@ -126,2 +143,1 @@\n-    public void latin1_SSE4_char() {\n-        int ret = 0;\n+    public void latin1_SSE4_char(Blackhole bh) {\n@@ -129,1 +145,1 @@\n-            ret += what.indexOf('a');\n+            bh.consume(what.indexOf('a'));\n@@ -134,2 +150,1 @@\n-    public void latin1_AVX2_char() {\n-        int ret = 0;\n+    public void latin1_AVX2_char(Blackhole bh) {\n@@ -137,1 +152,1 @@\n-            ret += what.indexOf('a');\n+            bh.consume(what.indexOf('a'));\n@@ -142,2 +157,1 @@\n-    public int utf16_Short_char() {\n-        int ret = 0;\n+    public void utf16_Short_char(Blackhole bh) {\n@@ -145,1 +159,1 @@\n-            ret += what.indexOf('a');\n+            bh.consume(what.indexOf('a'));\n@@ -147,1 +161,0 @@\n-        return ret;\n@@ -151,2 +164,1 @@\n-    public int utf16_SSE4_char() {\n-        int ret = 0;\n+    public void utf16_SSE4_char(Blackhole bh) {\n@@ -154,1 +166,1 @@\n-            ret += what.indexOf('a');\n+            bh.consume(what.indexOf('a'));\n@@ -156,1 +168,0 @@\n-        return ret;\n@@ -160,2 +171,1 @@\n-    public int utf16_AVX2_char() {\n-        int ret = 0;\n+    public void utf16_AVX2_char(Blackhole bh) {\n@@ -163,1 +173,1 @@\n-            ret += what.indexOf('a');\n+            bh.consume(what.indexOf('a'));\n@@ -165,1 +175,0 @@\n-        return ret;\n@@ -169,2 +178,1 @@\n-    public int latin1_Short_String() {\n-        int ret = 0;\n+    public void latin1_Short_String(Blackhole bh) {\n@@ -172,1 +180,1 @@\n-            ret += what.indexOf(\"a\");\n+            bh.consume(what.indexOf(\"a\"));\n@@ -174,1 +182,0 @@\n-        return ret;\n@@ -178,2 +185,1 @@\n-    public int latin1_SSE4_String() {\n-        int ret = 0;\n+    public void latin1_SSE4_String(Blackhole bh) {\n@@ -181,1 +187,1 @@\n-            ret += what.indexOf(\"a\");\n+            bh.consume(what.indexOf(\"a\"));\n@@ -183,1 +189,0 @@\n-        return ret;\n@@ -187,2 +192,1 @@\n-    public int latin1_AVX2_String() {\n-        int ret = 0;\n+    public void latin1_AVX2_String(Blackhole bh) {\n@@ -190,1 +194,1 @@\n-            ret += what.indexOf(\"a\");\n+            bh.consume(what.indexOf(\"a\"));\n@@ -192,1 +196,0 @@\n-        return ret;\n@@ -196,2 +199,1 @@\n-    public int utf16_Short_String() {\n-        int ret = 0;\n+    public void utf16_Short_String(Blackhole bh) {\n@@ -199,1 +201,1 @@\n-            ret += what.indexOf(\"a\");\n+            bh.consume(what.indexOf(\"a\"));\n@@ -201,1 +203,0 @@\n-        return ret;\n@@ -205,2 +206,1 @@\n-    public int utf16_SSE4_String() {\n-        int ret = 0;\n+    public void utf16_SSE4_String(Blackhole bh) {\n@@ -208,1 +208,1 @@\n-            ret += what.indexOf(\"a\");\n+            bh.consume(what.indexOf(\"a\"));\n@@ -210,1 +210,0 @@\n-        return ret;\n@@ -214,2 +213,1 @@\n-    public int utf16_AVX2_String() {\n-        int ret = 0;\n+    public void utf16_AVX2_String(Blackhole bh) {\n@@ -217,1 +215,1 @@\n-            ret += what.indexOf(\"a\");\n+            bh.consume(what.indexOf(\"a\"));\n@@ -219,1 +217,0 @@\n-        return ret;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringIndexOfChar.java","additions":67,"deletions":70,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import org.openjdk.jmh.annotations.Param;\n@@ -48,1 +49,1 @@\n-    private BigInteger[] hugeArray, largeArray, smallArray, shiftArray;\n+    private BigInteger[] hugeArray, largeArray, smallArray, shiftArray, smallShiftArray;\n@@ -53,0 +54,3 @@\n+    @Param({\"32\", \"64\", \"96\", \"128\", \"160\", \"192\", \"224\", \"256\"})\n+    private int maxNumbits;\n+\n@@ -75,0 +79,3 @@\n+        smallShiftArray = new BigInteger[TESTSIZE]; \/*\n+        * Small numbers, bits count in range [maxNumbits - 31, maxNumbits]\n+        *\/\n@@ -87,0 +94,1 @@\n+            smallShiftArray[i] = new BigInteger(Math.max(maxNumbits - value % 32, 0), r);\n@@ -180,0 +188,26 @@\n+\n+    \/** Invokes the shiftLeft method of small BigInteger with different values. *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testSmallLeftShift(Blackhole bh) {\n+        Random rand = new Random();\n+        int shift = rand.nextInt(30) + 1;\n+        BigInteger tmp = null;\n+        for (BigInteger s : smallShiftArray) {\n+            tmp = s.shiftLeft(shift);\n+            bh.consume(tmp);\n+        }\n+    }\n+\n+    \/** Invokes the shiftRight method of small BigInteger with different values. *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testSmallRightShift(Blackhole bh) {\n+        Random rand = new Random();\n+        int shift = rand.nextInt(30) + 1;\n+        BigInteger tmp = null;\n+        for (BigInteger s : smallShiftArray) {\n+            tmp = s.shiftRight(shift);\n+            bh.consume(tmp);\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/BigIntegers.java","additions":36,"deletions":2,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -0,0 +1,193 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.net;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.StandardProtocolFamily;\n+import java.net.UnixDomainSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.nio.file.*;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.RunnerException;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+\n+\/**\n+ * Tests sending a 128 byte message on a second, to a thread which\n+ * echo's it back and received by the original thread.\n+ * Benchmark is performed for \"inet\" channels over TCP\/IP\n+ * and \"unix\" domain channels.\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+public class SocketChannelCompare {\n+\n+    static final int BUFSIZE = 128; \/\/ message size sent and received\n+    private ServerSocketChannel ssc;\n+    private SocketChannel s1, s2;\n+    private EchoThread rt;\n+    private ByteBuffer bb = ByteBuffer.allocate(BUFSIZE);\n+\n+    private static volatile String tempDir;\n+    private static final AtomicInteger count = new AtomicInteger(0);\n+    private volatile Path socket;\n+\n+    @Param({\"inet\", \"unix\"})\n+    private volatile String family;\n+\n+    static {\n+        try {\n+            Path p = Files.createTempDirectory(\"readWriteTest\");\n+            tempDir = p.toString();\n+        } catch (IOException e) {\n+            tempDir = null;\n+        }\n+    }\n+\n+    private ServerSocketChannel getServerSocketChannel() throws IOException {\n+        if (family.equals(\"inet\"))\n+            return getInetServerSocketChannel();\n+        else if (family.equals(\"unix\"))\n+            return getUnixServerSocketChannel();\n+        throw new InternalError();\n+    }\n+\n+\n+    private ServerSocketChannel getInetServerSocketChannel() throws IOException {\n+        InetAddress iaddr = InetAddress.getLoopbackAddress();\n+        return ServerSocketChannel.open().bind(null);\n+    }\n+\n+    private ServerSocketChannel getUnixServerSocketChannel() throws IOException {\n+        int next = count.incrementAndGet();\n+        socket = Paths.get(tempDir, Integer.toString(next));\n+        UnixDomainSocketAddress addr = UnixDomainSocketAddress.of(socket);\n+        return ServerSocketChannel.open(StandardProtocolFamily.UNIX).bind(addr);\n+    }\n+\n+    @Setup(Level.Trial)\n+    public void beforeRun() throws IOException {\n+        ssc = getServerSocketChannel();\n+        s1 = SocketChannel.open(ssc.getLocalAddress());\n+        s2 = ssc.accept();\n+\n+        rt = new EchoThread(s2);\n+        rt.start();\n+    }\n+\n+    @TearDown(Level.Trial)\n+    public void afterRun() throws IOException, InterruptedException {\n+        s1.close();\n+        s2.close();\n+        ssc.close();\n+        if (family.equals(\"unix\")) {\n+            Files.delete(socket);\n+            Files.delete(Path.of(tempDir));\n+        }\n+        rt.join();\n+    }\n+\n+    @Benchmark\n+    public void test() throws IOException {\n+        bb.position(0).limit(BUFSIZE);\n+        s1.write(bb);\n+        bb.clear();\n+        readFully(s1, bb);\n+    }\n+\n+    \/\/ read until buf is full, or EOF. Always returns number of bytes read\n+\n+    static int readFully(SocketChannel chan, ByteBuffer buf) throws IOException {\n+        int n = buf.remaining();\n+        int count = 0;\n+        while (n > 0) {\n+            int c = chan.read(buf);\n+            if (c == -1)\n+                return count;\n+            n -= c;\n+            count += c;\n+        }\n+        return count;\n+    }\n+\n+    static class EchoThread extends Thread {\n+        private SocketChannel sc;\n+\n+        public EchoThread(SocketChannel s2) {\n+            this.sc = s2;\n+        }\n+\n+        public void run() {\n+            try {\n+                ByteBuffer bb = ByteBuffer.allocate(BUFSIZE);\n+                while (true) {\n+                    bb.clear();\n+                    int c = readFully(sc, bb);\n+                    if (c == 0) {\n+                        sc.close();\n+                        return;\n+                    }\n+                    bb.flip();\n+                    sc.write(bb);\n+                }\n+            } catch (ClosedChannelException ex) {\n+                \/\/ shutdown time\n+            } catch (IOException ioex) {\n+                ioex.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws RunnerException {\n+        Options opt = new OptionsBuilder()\n+                .include(org.openjdk.bench.java.net.SocketChannelCompare.class.getSimpleName())\n+                .warmupForks(1)\n+                .warmupIterations(2)\n+                .measurementIterations(2)\n+                .forks(2)\n+                .build();\n+\n+        new Runner(opt).run();\n+\n+        opt = new OptionsBuilder()\n+                .include(org.openjdk.bench.java.net.SocketChannelCompare.class.getSimpleName())\n+                .warmupForks(1)\n+                .warmupIterations(2)\n+                .measurementIterations(2)\n+                .jvmArgsPrepend(\"-Djdk.net.useFastTcpLoopback=true\")\n+                .forks(3)\n+                .build();\n+\n+        new Runner(opt).run();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/net\/SocketChannelCompare.java","additions":193,"deletions":0,"binary":false,"changes":193,"status":"added"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.net;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.StandardProtocolFamily;\n+import java.net.UnixDomainSocketAddress;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.nio.file.*;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.RunnerException;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+\n+\/**\n+ * Measures connection setup times\n+ *\/\n+@BenchmarkMode(Mode.SingleShotTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+public class SocketChannelConnectionSetup {\n+\n+    private ServerSocketChannel ssc;\n+    private SocketChannel s1, s2;\n+\n+    private static volatile String tempDir;\n+    private static final AtomicInteger count = new AtomicInteger(0);\n+    private volatile Path socket;\n+\n+    @Param({\"inet\", \"unix\"})\n+    private volatile String family;\n+\n+    static {\n+        try {\n+            Path p = Files.createTempDirectory(\"readWriteTest\");\n+            tempDir = p.toString();\n+        } catch (IOException e) {\n+            tempDir = null;\n+        }\n+    }\n+\n+    private ServerSocketChannel getServerSocketChannel() throws IOException {\n+        if (family.equals(\"inet\"))\n+            return getInetServerSocketChannel();\n+        else if (family.equals(\"unix\"))\n+            return getUnixServerSocketChannel();\n+        throw new InternalError();\n+    }\n+\n+\n+    private ServerSocketChannel getInetServerSocketChannel() throws IOException {\n+        InetAddress iaddr = InetAddress.getLoopbackAddress();\n+        return ServerSocketChannel.open().bind(null);\n+    }\n+\n+    private ServerSocketChannel getUnixServerSocketChannel() throws IOException {\n+        int next = count.incrementAndGet();\n+        socket = Paths.get(tempDir, Integer.toString(next));\n+        UnixDomainSocketAddress addr = UnixDomainSocketAddress.of(socket);\n+        return ServerSocketChannel.open(StandardProtocolFamily.UNIX).bind(addr);\n+    }\n+\n+    @Setup(Level.Trial)\n+    public void beforeRun() throws IOException {\n+        ssc = getServerSocketChannel();\n+    }\n+\n+    @TearDown(Level.Trial)\n+    public void afterRun() throws IOException, InterruptedException {\n+        ssc.close();\n+        if (family.equals(\"unix\")) {\n+            Files.delete(socket);\n+            Files.delete(Path.of(tempDir));\n+        }\n+    }\n+\n+    @Benchmark\n+    @Measurement(iterations = 5, batchSize=200)\n+    public void test() throws IOException {\n+        s1 = SocketChannel.open(ssc.getLocalAddress());\n+        s2 = ssc.accept();\n+        s1.close();\n+        s2.close();\n+    }\n+\n+    public static void main(String[] args) throws RunnerException {\n+        Options opt = new OptionsBuilder()\n+                .include(org.openjdk.bench.java.net.SocketChannelConnectionSetup.class.getSimpleName())\n+                .warmupForks(1)\n+                .forks(2)\n+                .build();\n+\n+        new Runner(opt).run();\n+\n+        opt = new OptionsBuilder()\n+                .include(org.openjdk.bench.java.net.SocketChannelConnectionSetup.class.getSimpleName())\n+                .jvmArgsPrepend(\"-Djdk.net.useFastTcpLoopback=true\")\n+                .warmupForks(1)\n+                .forks(2)\n+                .build();\n+\n+        new Runner(opt).run();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/net\/SocketChannelConnectionSetup.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.net;\n+\n+import java.io.IOException;\n+import java.net.StandardProtocolFamily;\n+import java.net.UnixDomainSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.nio.file.*;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+\/**\n+ * Tests the overheads of I\/O API.\n+ * This test is known to depend heavily on network conditions and paltform.\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+public class UnixSocketChannelReadWrite {\n+\n+    private ServerSocketChannel ssc;\n+    private SocketChannel s1, s2;\n+    private ReadThread rt;\n+    private ByteBuffer bb = ByteBuffer.allocate(1);\n+\n+    private static volatile String tempDir;\n+    private static final AtomicInteger count = new AtomicInteger(0);\n+    private volatile Path socket;\n+\n+    static {\n+        try {\n+            Path p = Files.createTempDirectory(\"readWriteTest\");\n+            tempDir = p.toString();\n+        } catch (IOException e) {\n+            tempDir = null;\n+        }\n+    }\n+\n+    private ServerSocketChannel getServerSocketChannel() throws IOException {\n+        int next = count.incrementAndGet();\n+        socket = Paths.get(tempDir, Integer.toString(next));\n+        UnixDomainSocketAddress addr = UnixDomainSocketAddress.of(socket);\n+        ServerSocketChannel c = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+        c.bind(addr);\n+        return c;\n+    }\n+\n+    @Setup(Level.Trial)\n+    public void beforeRun() throws IOException {\n+        ssc = getServerSocketChannel();\n+        s1 = SocketChannel.open(ssc.getLocalAddress());\n+        s2 = ssc.accept();\n+\n+        rt = new ReadThread(s2);\n+        rt.start();\n+\n+        bb.put((byte) 47);\n+        bb.flip();\n+    }\n+\n+    @TearDown(Level.Trial)\n+    public void afterRun() throws IOException, InterruptedException {\n+        s1.close();\n+        s2.close();\n+        ssc.close();\n+        Files.delete(socket);\n+        Files.delete(Path.of(tempDir));\n+        rt.join();\n+    }\n+\n+    @Benchmark\n+    public void test() throws IOException {\n+        s1.write(bb);\n+        bb.flip();\n+    }\n+\n+    static class ReadThread extends Thread {\n+        private SocketChannel sc;\n+\n+        public ReadThread(SocketChannel s2) {\n+            this.sc = s2;\n+        }\n+\n+        public void run() {\n+            try {\n+                ByteBuffer bb = ByteBuffer.allocate(1);\n+                while (sc.read(bb) > 0) {\n+                    bb.flip();\n+                }\n+            } catch (ClosedChannelException ex) {\n+                \/\/ shutdown time\n+            } catch (IOException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/net\/UnixSocketChannelReadWrite.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"}]}