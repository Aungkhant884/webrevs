{"files":[{"patch":"@@ -33,1 +33,0 @@\n-import jdk.internal.jextract.impl.LayoutUtils.CanonicalABIType;\n@@ -43,2 +42,0 @@\n-import static jdk.internal.jextract.impl.LayoutUtils.CANONICAL_FIELD;\n-\n@@ -101,1 +98,1 @@\n-            Bool(\"_Bool\", CLinker.C_CHAR.withAttribute(CANONICAL_FIELD, CanonicalABIType.C_CHAR)),\n+            Bool(\"_Bool\", CLinker.C_CHAR),\n@@ -105,1 +102,1 @@\n-            Char(\"char\", CLinker.C_CHAR.withAttribute(CANONICAL_FIELD, CanonicalABIType.C_CHAR)),\n+            Char(\"char\", CLinker.C_CHAR),\n@@ -117,1 +114,1 @@\n-            Short(\"short\", CLinker.C_SHORT.withAttribute(CANONICAL_FIELD, CanonicalABIType.C_SHORT)),\n+            Short(\"short\", CLinker.C_SHORT),\n@@ -121,1 +118,1 @@\n-            Int(\"int\", CLinker.C_INT.withAttribute(CANONICAL_FIELD, CanonicalABIType.C_INT)),\n+            Int(\"int\", CLinker.C_INT),\n@@ -125,1 +122,1 @@\n-            Long(\"long\", CLinker.C_LONG.withAttribute(CANONICAL_FIELD, CanonicalABIType.C_LONG)),\n+            Long(\"long\", CLinker.C_LONG),\n@@ -129,1 +126,1 @@\n-            LongLong(\"long long\", CLinker.C_LONGLONG.withAttribute(CANONICAL_FIELD, CanonicalABIType.C_LONGLONG)),\n+            LongLong(\"long long\", CLinker.C_LONGLONG),\n@@ -137,1 +134,1 @@\n-            Float(\"float\", CLinker.C_FLOAT.withAttribute(CANONICAL_FIELD, CanonicalABIType.C_FLOAT)),\n+            Float(\"float\", CLinker.C_FLOAT),\n@@ -141,1 +138,1 @@\n-            Double(\"double\",CLinker.C_DOUBLE.withAttribute(CANONICAL_FIELD, CanonicalABIType.C_DOUBLE)),\n+            Double(\"double\",CLinker.C_DOUBLE),\n@@ -145,1 +142,1 @@\n-            LongDouble(\"long double\", CLinker.C_LONGDOUBLE.withAttribute(CANONICAL_FIELD, CanonicalABIType.C_LONGDOUBLE)),\n+            LongDouble(\"long double\", CLinker.C_LONGDOUBLE),\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/incubator\/jextract\/Type.java","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.GroupLayout;\n@@ -34,3 +33,0 @@\n-import jdk.incubator.foreign.SequenceLayout;\n-import jdk.incubator.foreign.ValueLayout;\n-import jdk.internal.jextract.impl.LayoutUtils.CanonicalABIType;\n@@ -47,1 +43,0 @@\n-import java.lang.constant.ConstantDescs;\n@@ -57,1 +52,0 @@\n-import java.util.ArrayList;\n@@ -61,1 +55,0 @@\n-import java.util.Optional;\n@@ -63,2 +56,0 @@\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n@@ -69,1 +60,0 @@\n-import static jdk.internal.jextract.impl.LayoutUtils.CANONICAL_FIELD;\n@@ -78,5 +68,0 @@\n-    private static final ClassDesc CD_MEMORY_LAYOUT = desc(MemoryLayout.class);\n-    private static final ClassDesc CD_Constable = desc(Constable.class);\n-    private static final ClassDesc CD_GROUP_LAYOUT = desc(GroupLayout.class);\n-    private static final ClassDesc CD_SEQUENCE_LAYOUT = desc(SequenceLayout.class);\n-    private static final ClassDesc CD_FUNCTION_DESC = desc(FunctionDescriptor.class);\n@@ -310,6 +295,0 @@\n-        if (constable instanceof MemoryLayout) {\n-            return (T) describeLayout((MemoryLayout) constable);\n-        } else if (constable instanceof FunctionDescriptor) {\n-            return (T) describeDescriptor((FunctionDescriptor) constable);\n-        }\n-\n@@ -319,114 +298,0 @@\n-    private static final MethodHandleDesc MH_VOID_FUNCTION\n-        = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC, CD_FUNCTION_DESC, \"ofVoid\",\n-                MethodTypeDesc.of(CD_FUNCTION_DESC, CD_MEMORY_LAYOUT.arrayType()));\n-\n-    private static final MethodHandleDesc MH_FUNCTION\n-        = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC, CD_FUNCTION_DESC, \"of\",\n-                MethodTypeDesc.of(CD_FUNCTION_DESC, CD_MEMORY_LAYOUT, CD_MEMORY_LAYOUT.arrayType()));\n-\n-    private static ConstantDesc describeDescriptor(FunctionDescriptor descriptor) {\n-        List<ConstantDesc> constants = new ArrayList<>();\n-        boolean hasReturn = descriptor.returnLayout().isPresent();\n-        constants.add(hasReturn ? MH_FUNCTION : MH_VOID_FUNCTION);\n-        if (hasReturn) {\n-            constants.add(describeLayout(descriptor.returnLayout().get()));\n-        }\n-        for (MemoryLayout argLayout : descriptor.argumentLayouts()) {\n-            constants.add(describeLayout(argLayout));\n-        }\n-        return DynamicConstantDesc.ofNamed(\n-            ConstantDescs.BSM_INVOKE, \"function\", CD_FUNCTION_DESC, constants.toArray(ConstantDesc[]::new));\n-    }\n-\n-    private static ConstantDesc describeLayout(MemoryLayout layout) {\n-        if (layout instanceof GroupLayout) {\n-            return describeGroupLayout((GroupLayout) layout);\n-        } else if (layout instanceof SequenceLayout) {\n-            return describeSequenceLayout((SequenceLayout) layout);\n-        } else if(layout instanceof ValueLayout) {\n-            return describeValueLayout((ValueLayout) layout);\n-        }\n-\n-        return layout.describeConstable().orElseThrow();\n-    }\n-\n-    private static final MethodHandleDesc MH_WITH_BIT_ALIGNMENT\n-        = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_VIRTUAL, CD_MEMORY_LAYOUT, \"withBitAlignment\",\n-                MethodTypeDesc.of(CD_MEMORY_LAYOUT, CD_long));\n-\n-    private static final MethodHandleDesc MH_WITH_ATTRIBUTE\n-        = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_VIRTUAL, CD_MEMORY_LAYOUT, \"withAttribute\",\n-                MethodTypeDesc.of(CD_MEMORY_LAYOUT, CD_String, CD_Constable));\n-\n-    private static <T> DynamicConstantDesc<T> decorateLayoutConstant(MemoryLayout layout, DynamicConstantDesc<T> desc) {\n-        return decorateLayoutConstant(layout, desc, layout.attributes());\n-    }\n-\n-    private static <T> DynamicConstantDesc<T> decorateLayoutConstant(MemoryLayout layout, DynamicConstantDesc<T> desc,\n-                                                                     Stream<String> attributes) {\n-        if (!hasNaturalAlignment(layout)) {\n-            desc = DynamicConstantDesc.ofNamed(BSM_INVOKE, \"withBitAlignment\", desc.constantType(), MH_WITH_BIT_ALIGNMENT,\n-                    desc, layout.bitAlignment());\n-        }\n-        for (String name : attributes.collect(Collectors.toList())) {\n-            Constable value = layout.attribute(name).get();\n-            desc = DynamicConstantDesc.ofNamed(BSM_INVOKE, \"withAttribute\", desc.constantType(), MH_WITH_ATTRIBUTE,\n-                    desc, name, value.describeConstable().orElseThrow());\n-        }\n-\n-        return desc;\n-    }\n-\n-    private static boolean hasNaturalAlignment(MemoryLayout layout) {\n-        return layout.hasSize() && layout.bitSize() == layout.bitAlignment();\n-    }\n-\n-    private static final MethodHandleDesc MH_STRUCT\n-        = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_MEMORY_LAYOUT, \"ofStruct\",\n-                MethodTypeDesc.of(CD_GROUP_LAYOUT, CD_MEMORY_LAYOUT.arrayType()));\n-\n-    private static final MethodHandleDesc MH_UNION\n-        = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_MEMORY_LAYOUT, \"ofUnion\",\n-                MethodTypeDesc.of(CD_GROUP_LAYOUT, CD_MEMORY_LAYOUT.arrayType()));\n-\n-    private static ConstantDesc describeGroupLayout(GroupLayout layout) {\n-        List<MemoryLayout> elements = layout.memberLayouts();\n-        ConstantDesc[] constants = new ConstantDesc[1 + elements.size()];\n-        constants[0] = layout.isStruct() ? MH_STRUCT : MH_UNION;\n-        for (int i = 0 ; i < elements.size() ; i++) {\n-            constants[i + 1] = describeLayout(elements.get(i));\n-        }\n-        return decorateLayoutConstant(layout, DynamicConstantDesc.ofNamed(\n-                ConstantDescs.BSM_INVOKE, layout.isStruct() ? \"struct\" : \"union\",\n-                CD_GROUP_LAYOUT, constants));\n-    }\n-\n-    private static final MethodHandleDesc MH_SIZED_SEQUENCE\n-        = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_MEMORY_LAYOUT, \"ofSequence\",\n-                MethodTypeDesc.of(CD_SEQUENCE_LAYOUT, CD_long, CD_MEMORY_LAYOUT));\n-\n-    private static final MethodHandleDesc MH_UNSIZED_SEQUENCE\n-         = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_MEMORY_LAYOUT, \"ofSequence\",\n-                MethodTypeDesc.of(CD_SEQUENCE_LAYOUT, CD_MEMORY_LAYOUT));\n-\n-    private static ConstantDesc describeSequenceLayout(SequenceLayout layout) {\n-        return decorateLayoutConstant(layout, layout.elementCount().isPresent() ?\n-            DynamicConstantDesc.ofNamed(ConstantDescs.BSM_INVOKE, \"value\",\n-                    CD_SEQUENCE_LAYOUT, MH_SIZED_SEQUENCE,\n-                    layout.elementCount().getAsLong(), describeLayout(layout.elementLayout())) :\n-            DynamicConstantDesc.ofNamed(ConstantDescs.BSM_INVOKE, \"value\",\n-                    CD_SEQUENCE_LAYOUT, MH_UNSIZED_SEQUENCE,\n-                    describeLayout(layout.elementLayout())));\n-    }\n-\n-    private static ConstantDesc describeValueLayout(ValueLayout layout) {\n-        Optional<Constable> constantNameOp = layout.attribute(CANONICAL_FIELD);\n-        if (constantNameOp.isPresent()) {\n-            CanonicalABIType canonicalABIType = (CanonicalABIType) constantNameOp.get();\n-            return decorateLayoutConstant(layout, canonicalABIType.descriptor(),\n-                layout.attributes().filter(attr -> !CANONICAL_FIELD.equals(attr) && !attr.startsWith(\"abi\/\")));\n-        }\n-\n-        return layout.describeConstable().orElseThrow();\n-    }\n-\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/ClassConstantHelper.java","additions":0,"deletions":135,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.incubator.foreign.CLinker;\n@@ -32,1 +31,0 @@\n-import jdk.incubator.foreign.ValueLayout;\n@@ -37,1 +35,0 @@\n-import java.lang.constant.DynamicConstantDesc;\n@@ -41,1 +38,1 @@\n-import static java.lang.constant.ConstantDescs.BSM_GET_STATIC_FINAL;\n+import static jdk.incubator.foreign.CLinker.C_POINTER;\n@@ -47,4 +44,0 @@\n-    public static final String CANONICAL_FIELD = \"jextract\/constant_name\";\n-    private static final ValueLayout POINTER_LAYOUT = CLinker.C_POINTER\n-            .withAttribute(CANONICAL_FIELD, CanonicalABIType.C_POINTER);\n-\n@@ -118,1 +111,1 @@\n-                return POINTER_LAYOUT;\n+                return C_POINTER;\n@@ -145,1 +138,1 @@\n-                return POINTER_LAYOUT;\n+                return C_POINTER;\n@@ -217,31 +210,0 @@\n-\n-    public enum CanonicalABIType {\n-        C_CHAR(canonicalLayoutConstantDesc(\"C_CHAR\")),\n-        C_SHORT(canonicalLayoutConstantDesc(\"C_SHORT\")),\n-        C_INT(canonicalLayoutConstantDesc(\"C_INT\")),\n-        C_LONG(canonicalLayoutConstantDesc(\"C_LONG\")),\n-        C_LONGLONG(canonicalLayoutConstantDesc(\"C_LONGLONG\")),\n-        C_FLOAT(canonicalLayoutConstantDesc(\"C_FLOAT\")),\n-        C_DOUBLE(canonicalLayoutConstantDesc(\"C_DOUBLE\")),\n-        C_LONGDOUBLE(canonicalLayoutConstantDesc(\"C_LONGDOUBLE\")),\n-        C_POINTER(canonicalLayoutConstantDesc(\"C_POINTER\"));\n-\n-        private final DynamicConstantDesc<ValueLayout> descriptor;\n-\n-        CanonicalABIType(DynamicConstantDesc<ValueLayout> descriptor) {\n-            this.descriptor = descriptor;\n-        }\n-\n-        public DynamicConstantDesc<ValueLayout> descriptor() {\n-            return descriptor;\n-        }\n-\n-        private static DynamicConstantDesc<ValueLayout> canonicalLayoutConstantDesc(String name) {\n-            return DynamicConstantDesc.ofNamed(\n-                BSM_GET_STATIC_FINAL,\n-                name,\n-                ValueLayout.class.describeConstable().orElseThrow(),\n-                CLinker.class.describeConstable().orElseThrow()\n-            );\n-        }\n-    }\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/LayoutUtils.java","additions":3,"deletions":41,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.CLinker;\n@@ -35,1 +36,0 @@\n-import jdk.internal.jextract.impl.LayoutUtils.CanonicalABIType;\n@@ -51,1 +51,0 @@\n-import static jdk.internal.jextract.impl.LayoutUtils.CANONICAL_FIELD;\n@@ -448,4 +447,11 @@\n-        return vl.attribute(CANONICAL_FIELD)\n-            .map(CanonicalABIType.class::cast)\n-            .map(CanonicalABIType::name)\n-            .orElseThrow(() -> new RuntimeException(\"should not reach here, problematic layout: \" + vl));\n+        return switch (((CLinker.CValueLayout) vl).kind()) {\n+            case CHAR -> \"C_CHAR\";\n+            case SHORT -> \"C_SHORT\";\n+            case INT -> \"C_INT\";\n+            case LONG -> \"C_LONG\";\n+            case LONGLONG -> \"C_LONGLONG\";\n+            case FLOAT -> \"C_FLOAT\";\n+            case DOUBLE -> \"C_DOUBLE\";\n+            case LONGDOUBLE -> \"C_LONGDOUBLE\";\n+            case POINTER -> \"C_POINTER\";\n+        };\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/SourceConstantHelper.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"}]}