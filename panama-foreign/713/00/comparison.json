{"files":[{"patch":"@@ -29,3 +29,2 @@\n-import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n-import java.util.stream.Stream;\n+\n+import jdk.internal.foreign.FunctionDescriptorImpl;\n@@ -41,1 +40,1 @@\n- * This class is immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ * Implementing classes are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n@@ -47,9 +46,1 @@\n-public sealed class FunctionDescriptor {\n-\n-    private final MemoryLayout resLayout;\n-    private final List<MemoryLayout> argLayouts;\n-\n-    private FunctionDescriptor(MemoryLayout resLayout, List<MemoryLayout> argLayouts) {\n-        this.resLayout = resLayout;\n-        this.argLayouts = argLayouts;\n-    }\n+public sealed interface FunctionDescriptor permits FunctionDescriptorImpl {\n@@ -60,3 +51,1 @@\n-    public Optional<MemoryLayout> returnLayout() {\n-        return Optional.ofNullable(resLayout);\n-    }\n+    Optional<MemoryLayout> returnLayout();\n@@ -67,39 +56,1 @@\n-    public List<MemoryLayout> argumentLayouts() {\n-        return Collections.unmodifiableList(argLayouts);\n-    }\n-\n-    \/**\n-     * Creates a function descriptor with the given return and argument layouts.\n-     * @param resLayout the return layout.\n-     * @param argLayouts the argument layouts.\n-     * @return the new function descriptor.\n-     *\/\n-    public static FunctionDescriptor of(MemoryLayout resLayout, MemoryLayout... argLayouts) {\n-        Objects.requireNonNull(resLayout);\n-        \/\/ Null checks are implicit in List.of(argLayouts)\n-        return new FunctionDescriptor(resLayout, List.of(argLayouts));\n-    }\n-\n-    \/**\n-     * Creates a function descriptor with the given argument layouts and no return layout.\n-     * @param argLayouts the argument layouts.\n-     * @return the new function descriptor.\n-     *\/\n-    public static FunctionDescriptor ofVoid(MemoryLayout... argLayouts) {\n-        \/\/ Null checks are implicit in List.of(argLayouts)\n-        return new FunctionDescriptor(null, List.of(argLayouts));\n-    }\n-\n-    \/**\n-     * Creates a specialized variadic function descriptor, by appending given variadic layouts to this\n-     * function descriptor argument layouts. The resulting function descriptor can report the position\n-     * of the {@linkplain #firstVariadicArgumentIndex() first variadic argument}, and cannot be altered\n-     * in any way: for instance, calling {@link #changeReturnLayout(MemoryLayout)} on the resulting descriptor\n-     * will throw an {@link UnsupportedOperationException}.\n-     * @param variadicLayouts the variadic argument layouts to be appended to this descriptor argument layouts.\n-     * @return a variadic function descriptor, or this descriptor if {@code variadicLayouts.length == 0}.\n-     *\/\n-    public FunctionDescriptor asVariadic(MemoryLayout... variadicLayouts) {\n-        \/\/ Null checks are implicit in the constructor of VariadicFunction\n-        return variadicLayouts.length == 0 ? this : new VariadicFunction(this, variadicLayouts);\n-    }\n+    List<MemoryLayout> argumentLayouts();\n@@ -112,3 +63,1 @@\n-    public int firstVariadicArgumentIndex() {\n-        return -1;\n-    }\n+    int firstVariadicArgumentIndex();\n@@ -122,3 +71,1 @@\n-    public FunctionDescriptor appendArgumentLayouts(MemoryLayout... addedLayouts) {\n-        return insertArgumentLayouts(argLayouts.size(), addedLayouts);\n-    }\n+    FunctionDescriptor appendArgumentLayouts(MemoryLayout... addedLayouts);\n@@ -134,10 +81,1 @@\n-    public FunctionDescriptor insertArgumentLayouts(int index, MemoryLayout... addedLayouts) {\n-        if (index < 0 || index > argLayouts.size())\n-            throw new IllegalArgumentException(\"Index out of bounds: \" + index);\n-        List<MemoryLayout> added = List.of(addedLayouts); \/\/ null check on array and its elements\n-        List<MemoryLayout> newLayouts = new ArrayList<>(argLayouts.size() + addedLayouts.length);\n-        newLayouts.addAll(argLayouts.subList(0, index));\n-        newLayouts.addAll(added);\n-        newLayouts.addAll(argLayouts.subList(index, argLayouts.size()));\n-        return new FunctionDescriptor(resLayout, newLayouts);\n-    }\n+    FunctionDescriptor insertArgumentLayouts(int index, MemoryLayout... addedLayouts);\n@@ -150,4 +88,1 @@\n-    public FunctionDescriptor changeReturnLayout(MemoryLayout newReturn) {\n-        Objects.requireNonNull(newReturn);\n-        return new FunctionDescriptor(newReturn, argLayouts);\n-    }\n+    FunctionDescriptor changeReturnLayout(MemoryLayout newReturn);\n@@ -160,3 +95,1 @@\n-    public FunctionDescriptor dropReturnLayout() {\n-        return new FunctionDescriptor(null, argLayouts);\n-    }\n+    FunctionDescriptor dropReturnLayout();\n@@ -165,1 +98,7 @@\n-     * {@return the string representation of this function descriptor}\n+     * Creates a specialized variadic function descriptor, by appending given variadic layouts to this\n+     * function descriptor argument layouts. The resulting function descriptor can report the position\n+     * of the {@linkplain #firstVariadicArgumentIndex() first variadic argument}, and cannot be altered\n+     * in any way: for instance, calling {@link #changeReturnLayout(MemoryLayout)} on the resulting descriptor\n+     * will throw an {@link UnsupportedOperationException}.\n+     * @param variadicLayouts the variadic argument layouts to be appended to this descriptor argument layouts.\n+     * @return a variadic function descriptor, or this descriptor if {@code variadicLayouts.length == 0}.\n@@ -167,9 +106,1 @@\n-    @Override\n-    public String toString() {\n-        return String.format(\"(%s)%s\",\n-                IntStream.range(0, argLayouts.size())\n-                        .mapToObj(i -> (i == firstVariadicArgumentIndex() ?\n-                                \"...\" : \"\") + argLayouts.get(i))\n-                        .collect(Collectors.joining()),\n-                returnLayout().map(Object::toString).orElse(\"v\"));\n-    }\n+    FunctionDescriptor asVariadic(MemoryLayout... variadicLayouts);\n@@ -178,10 +109,4 @@\n-     * Compares the specified object with this function descriptor for equality. Returns {@code true} if and only if the specified\n-     * object is also a function descriptor, and all the following conditions are met:\n-     * <ul>\n-     *     <li>the two function descriptors have equals return layouts (see {@link MemoryLayout#equals(Object)}), or both have no return layout;<\/li>\n-     *     <li>the two function descriptors have argument layouts that are pair-wise {@linkplain MemoryLayout#equals(Object) equal}; and<\/li>\n-     *     <li>the two function descriptors have the same leading {@linkplain #firstVariadicArgumentIndex() variadic argument index}<\/li>\n-     * <\/ul>\n-     *\n-     * @param other the object to be compared for equality with this function descriptor.\n-     * @return {@code true} if the specified object is equal to this function descriptor.\n+     * Creates a function descriptor with the given return and argument layouts.\n+     * @param resLayout the return layout.\n+     * @param argLayouts the argument layouts.\n+     * @return the new function descriptor.\n@@ -189,6 +114,4 @@\n-    @Override\n-    public boolean equals(Object other) {\n-        return other instanceof FunctionDescriptor f &&\n-                Objects.equals(resLayout, f.resLayout) &&\n-                Objects.equals(argLayouts, f.argLayouts) &&\n-                firstVariadicArgumentIndex() == f.firstVariadicArgumentIndex();\n+    static FunctionDescriptor of(MemoryLayout resLayout, MemoryLayout... argLayouts) {\n+        Objects.requireNonNull(resLayout);\n+        \/\/ Null checks are implicit in List.of(argLayouts)\n+        return FunctionDescriptorImpl.of(resLayout, List.of(argLayouts));\n@@ -198,1 +121,3 @@\n-     * {@return the hash code value for this function descriptor}\n+     * Creates a function descriptor with the given argument layouts and no return layout.\n+     * @param argLayouts the argument layouts.\n+     * @return the new function descriptor.\n@@ -200,3 +125,3 @@\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(argLayouts, resLayout, firstVariadicArgumentIndex());\n+    static FunctionDescriptor ofVoid(MemoryLayout... argLayouts) {\n+        \/\/ Null checks are implicit in List.of(argLayouts)\n+        return FunctionDescriptorImpl.ofVoid(List.of(argLayouts));\n@@ -205,42 +130,0 @@\n-    static final class VariadicFunction extends FunctionDescriptor {\n-\n-        private final int firstVariadicIndex;\n-\n-        \/**\n-         * Constructor.\n-         *\n-         * @param descriptor the original functional descriptor\n-         * @param argLayouts the memory layouts to apply\n-         * @throws NullPointerException if any of the provided parameters or array elements are {@code null}\n-         *\/\n-        VariadicFunction(FunctionDescriptor descriptor, MemoryLayout... argLayouts) {\n-            super(descriptor.returnLayout().orElse(null),\n-                    Stream.concat(descriptor.argumentLayouts().stream(), Arrays.stream(argLayouts).map(Objects::requireNonNull)).toList());\n-            this.firstVariadicIndex = descriptor.argumentLayouts().size();\n-        }\n-\n-        @Override\n-        public int firstVariadicArgumentIndex() {\n-            return firstVariadicIndex;\n-        }\n-\n-        @Override\n-        public FunctionDescriptor appendArgumentLayouts(MemoryLayout... addedLayouts) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        @Override\n-        public FunctionDescriptor insertArgumentLayouts(int index, MemoryLayout... addedLayouts) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        @Override\n-        public FunctionDescriptor changeReturnLayout(MemoryLayout newReturn) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        @Override\n-        public FunctionDescriptor dropReturnLayout() {\n-            throw new UnsupportedOperationException();\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/FunctionDescriptor.java","additions":33,"deletions":150,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -0,0 +1,238 @@\n+\/*\n+ *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+package jdk.internal.foreign;\n+\n+import java.lang.foreign.*;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+\/**\n+ * @implSpec This class and its subclasses are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ *\/\n+public sealed class FunctionDescriptorImpl implements FunctionDescriptor {\n+\n+    private final MemoryLayout resLayout; \/\/ Nullable\n+    private final List<MemoryLayout> argLayouts;\n+\n+    private FunctionDescriptorImpl(MemoryLayout resLayout, List<MemoryLayout> argLayouts) {\n+        this.resLayout = resLayout;\n+        this.argLayouts = List.copyOf(argLayouts);\n+    }\n+\n+    \/**\n+     * {@return the return layout (if any) associated with this function descriptor}\n+     *\/\n+    public final Optional<MemoryLayout> returnLayout() {\n+        return Optional.ofNullable(resLayout);\n+    }\n+\n+    \/**\n+     * {@return the argument layouts associated with this function descriptor (as an immutable list)}.\n+     *\/\n+    public final List<MemoryLayout> argumentLayouts() {\n+        return argLayouts;\n+    }\n+\n+    \/**\n+     * Creates a specialized variadic function descriptor, by appending given variadic layouts to this\n+     * function descriptor argument layouts. The resulting function descriptor can report the position\n+     * of the {@linkplain #firstVariadicArgumentIndex() first variadic argument}, and cannot be altered\n+     * in any way: for instance, calling {@link #changeReturnLayout(MemoryLayout)} on the resulting descriptor\n+     * will throw an {@link UnsupportedOperationException}.\n+     *\n+     * @param variadicLayouts the variadic argument layouts to be appended to this descriptor argument layouts.\n+     * @return a variadic function descriptor, or this descriptor if {@code variadicLayouts.length == 0}.\n+     *\/\n+    public final FunctionDescriptorImpl asVariadic(MemoryLayout... variadicLayouts) {\n+        \/\/ Null checks are implicit in the constructor of VariadicFunction\n+        return variadicLayouts.length == 0 ? this : new VariadicFunctionDescriptor(this, variadicLayouts);\n+    }\n+\n+    \/**\n+     * The index of the first variadic argument layout (where defined).\n+     *\n+     * @return The index of the first variadic argument layout, or {@code -1} if this is not a\n+     * {@linkplain #asVariadic(MemoryLayout...) variadic} layout.\n+     *\/\n+    public int firstVariadicArgumentIndex() {\n+        return -1;\n+    }\n+\n+    \/**\n+     * Returns a function descriptor with the given argument layouts appended to the argument layout array\n+     * of this function descriptor.\n+     *\n+     * @param addedLayouts the argument layouts to append.\n+     * @return the new function descriptor.\n+     *\/\n+    public final FunctionDescriptorImpl appendArgumentLayouts(MemoryLayout... addedLayouts) {\n+        return insertArgumentLayouts(argLayouts.size(), addedLayouts);\n+    }\n+\n+    \/**\n+     * Returns a function descriptor with the given argument layouts inserted at the given index, into the argument\n+     * layout array of this function descriptor.\n+     *\n+     * @param index        the index at which to insert the arguments\n+     * @param addedLayouts the argument layouts to insert at given index.\n+     * @return the new function descriptor.\n+     * @throws IllegalArgumentException if {@code index < 0 || index > argumentLayouts().size()}.\n+     *\/\n+    public FunctionDescriptorImpl insertArgumentLayouts(int index, MemoryLayout... addedLayouts) {\n+        checkIndex(index);\n+        List<MemoryLayout> added = List.of(addedLayouts); \/\/ null check on array and its elements\n+        List<MemoryLayout> newLayouts = new ArrayList<>(argLayouts.size() + addedLayouts.length);\n+        newLayouts.addAll(argLayouts.subList(0, index));\n+        newLayouts.addAll(added);\n+        newLayouts.addAll(argLayouts.subList(index, argLayouts.size()));\n+        return new FunctionDescriptorImpl(resLayout, newLayouts);\n+    }\n+\n+    \/**\n+     * Returns a function descriptor with the given memory layout as the new return layout.\n+     *\n+     * @param newReturn the new return layout.\n+     * @return the new function descriptor.\n+     *\/\n+    public FunctionDescriptorImpl changeReturnLayout(MemoryLayout newReturn) {\n+        requireNonNull(newReturn);\n+        return new FunctionDescriptorImpl(newReturn, argLayouts);\n+    }\n+\n+    \/**\n+     * Returns a function descriptor with the return layout dropped. This is useful to model functions\n+     * which return no values.\n+     *\n+     * @return the new function descriptor.\n+     *\/\n+    public FunctionDescriptorImpl dropReturnLayout() {\n+        return new FunctionDescriptorImpl(null, argLayouts);\n+    }\n+\n+    \/**\n+     * {@return the string representation of this function descriptor}\n+     *\/\n+    @Override\n+    public final String toString() {\n+        return String.format(\"(%s)%s\",\n+                IntStream.range(0, argLayouts.size())\n+                        .mapToObj(i -> (i == firstVariadicArgumentIndex() ?\n+                                \"...\" : \"\") + argLayouts.get(i))\n+                        .collect(Collectors.joining()),\n+                returnLayout().map(Object::toString).orElse(\"v\"));\n+    }\n+\n+    \/**\n+     * Compares the specified object with this function descriptor for equality. Returns {@code true} if and only if the specified\n+     * object is also a function descriptor, and all the following conditions are met:\n+     * <ul>\n+     *     <li>the two function descriptors have equals return layouts (see {@link MemoryLayout#equals(Object)}), or both have no return layout;<\/li>\n+     *     <li>the two function descriptors have argument layouts that are pair-wise {@linkplain MemoryLayout#equals(Object) equal}; and<\/li>\n+     *     <li>the two function descriptors have the same leading {@linkplain #firstVariadicArgumentIndex() variadic argument index}<\/li>\n+     * <\/ul>\n+     *\n+     * @param other the object to be compared for equality with this function descriptor.\n+     * @return {@code true} if the specified object is equal to this function descriptor.\n+     *\/\n+    @Override\n+    public final boolean equals(Object other) {\n+        return other instanceof FunctionDescriptorImpl f &&\n+                Objects.equals(resLayout, f.resLayout) &&\n+                Objects.equals(argLayouts, f.argLayouts) &&\n+                firstVariadicArgumentIndex() == f.firstVariadicArgumentIndex();\n+    }\n+\n+    \/**\n+     * {@return the hash code value for this function descriptor}\n+     *\/\n+    @Override\n+    public final int hashCode() {\n+        return Objects.hash(argLayouts, resLayout, firstVariadicArgumentIndex());\n+    }\n+\n+    final void checkIndex(int index) {\n+        if (index < 0 || index > argLayouts.size())\n+            throw new IllegalArgumentException(\"Index out of bounds: \" + index);\n+    }\n+\n+    public static FunctionDescriptor of(MemoryLayout resLayout, List<MemoryLayout> argLayouts) {\n+        return new FunctionDescriptorImpl(resLayout, argLayouts);\n+    }\n+\n+    public static FunctionDescriptor ofVoid(List<MemoryLayout> argLayouts) {\n+        return new FunctionDescriptorImpl(null, argLayouts);\n+    }\n+\n+    static final class VariadicFunctionDescriptor extends FunctionDescriptorImpl {\n+\n+        private final int firstVariadicIndex;\n+\n+        \/**\n+         * Constructor.\n+         *\n+         * @param descriptor the original functional descriptor\n+         * @param argLayouts the memory layouts to apply\n+         * @throws NullPointerException if any of the provided parameters or array elements are {@code null}\n+         *\/\n+        VariadicFunctionDescriptor(FunctionDescriptorImpl descriptor, MemoryLayout... argLayouts) {\n+            super(descriptor.returnLayout().orElse(null),\n+                    Stream.concat(descriptor.argumentLayouts().stream(), Arrays.stream(argLayouts).map(Objects::requireNonNull)).toList());\n+            this.firstVariadicIndex = descriptor.argumentLayouts().size();\n+        }\n+\n+        @Override\n+        public int firstVariadicArgumentIndex() {\n+            return firstVariadicIndex;\n+        }\n+\n+        @Override\n+        public FunctionDescriptorImpl insertArgumentLayouts(int index, MemoryLayout... addedLayouts) {\n+            checkIndex(index);\n+            for (MemoryLayout layout : addedLayouts) {\n+                requireNonNull(layout);\n+            }\n+            throw newUnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public FunctionDescriptorImpl changeReturnLayout(MemoryLayout newReturn) {\n+            requireNonNull(newReturn);\n+            throw newUnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public FunctionDescriptorImpl dropReturnLayout() {\n+            throw newUnsupportedOperationException();\n+        }\n+\n+        private UnsupportedOperationException newUnsupportedOperationException() {\n+            return new UnsupportedOperationException(\"Method not supported by \" + VariadicFunctionDescriptor.class.getSimpleName());\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/FunctionDescriptorImpl.java","additions":238,"deletions":0,"binary":false,"changes":238,"status":"added"}]}