{"files":[{"patch":"@@ -168,2 +168,1 @@\n-     * given variable arity callsite. Alternatively, where the foreign library allows it, clients might be able to\n-     * interact with variadic functions by passing a trailing parameter of type {@link VaList} (e.g. as in {@code vsprintf}).\n+     * given variable arity callsite.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,350 +0,0 @@\n-\/*\n- *  Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-package java.lang.foreign;\n-\n-import java.util.NoSuchElementException;\n-import java.util.Objects;\n-import java.util.function.Consumer;\n-\n-import jdk.internal.foreign.abi.SharedUtils;\n-import jdk.internal.foreign.abi.aarch64.linux.LinuxAArch64VaList;\n-import jdk.internal.foreign.abi.aarch64.macos.MacOsAArch64VaList;\n-import jdk.internal.foreign.abi.x64.sysv.SysVVaList;\n-import jdk.internal.foreign.abi.x64.windows.WinVaList;\n-import jdk.internal.javac.PreviewFeature;\n-import jdk.internal.reflect.CallerSensitive;\n-import jdk.internal.reflect.Reflection;\n-\n-\/**\n- * Helper class to create and manipulate variable argument lists, similar in functionality to a C {@code va_list}.\n- * <p>\n- * A variable argument list can be created using the {@link #make(Consumer, SegmentScope)} factory, as follows:\n- * {@snippet lang = java:\n- * VaList vaList = VaList.make(builder ->\n- *                                    builder.addVarg(C_INT, 42)\n- *                                           .addVarg(C_DOUBLE, 3.8d));\n- *}\n- * Once created, clients can obtain the platform-dependent {@linkplain #segment() memory segment} associated with a variable\n- * argument list, which can then be passed to {@linkplain Linker#downcallHandle(FunctionDescriptor, Linker.Option...) downcall method handles}\n- * targeting native functions using the C {@code va_list} type.\n- * <p>\n- * The contents of a foreign memory segment modelling a variable argument list can be accessed by <em>unsafely<\/em> creating\n- * a variable argument list, as follows:\n- * {@snippet lang = java:\n- * void upcall(int n, MemorySegment vaListSegment) {\n- *    try (Arena arena = Arena.openConfined()) {\n- *        VaList vaList = VaList.ofAddress(vaListSegment.address(), arena.scope());\n- *        VaList copy = vaList.copy();\n- *        int i = vaList.nextVarg(C_INT);\n- *        double d = vaList.nextVarg(C_DOUBLE);\n- *        \/\/ and again\n- *        int i = copy.nextVarg(C_INT);\n- *        double d = copy.nextVarg(C_DOUBLE);\n- *     }\n- * }\n- *}\n- * The above method receives a foreign segment modelling a variable argument list; the contents of the segment are accessed by creating\n- * a new variable argument list, from the segment address. Note that the variable argument list is first copied into\n- * a second list before any element is accessed: this will allow us to iterate through the elements twice. Elements in\n- * the variable argument list are accessed using {@link #nextVarg(ValueLayout.OfInt)} and\n- * {@link #nextVarg(ValueLayout.OfDouble)}. These methods (as well as other access methods in the {@link VaList} class)\n- * take the layout of the element that needs to be accessed and perform all the necessary alignment checks as well\n- * as endianness conversions.\n- * <p>\n- * Per the C specification (see C99 standard 6.5.2.2 Function calls - item 6),\n- * arguments to variadic calls are erased by way of 'default argument promotions',\n- * which erases integral types by way of integer promotion (see C99 standard 6.3.1.1 - item 2),\n- * and which erases all {@code float} arguments to {@code double}.\n- * <p>\n- * As such, this interface only supports reading {@code int}, {@code double},\n- * and any other type that fits into a {@code long}.\n- * <h2 id=\"safety\">Safety considerations<\/h2>\n- * Accessing a value through a variable argument list using the wrong memory layout will result in undefined behavior.\n- * For instance, if a variable argument list currently points at a C {@code int} value, then accessing it using\n- * {@link #nextVarg(ValueLayout.OfLong)} is illegal. Similarly, accessing the variable argument list with\n- * {@link #skip(MemoryLayout...)}, and providing a layout other than {@link ValueLayout.OfInt} is illegal.\n- * Any such illegal accesses might not be detected by the implementation, and can corrupt the variable argument list,\n- * so that the behavior of subsequent accesses is also undefined.\n- * <p>\n- * It is possible for clients to access elements outside the spatial bounds of a variable argument list.\n- * Variable argument list implementations will try to detect out-of-bounds reads on a best-effort basis.\n- * <p>\n- * Whether this detection succeeds depends on the factory method used to create the variable argument list:\n- * <ul>\n- *     <li>Variable argument lists created <em>safely<\/em>, using {@link #make(Consumer, SegmentScope)} are capable of detecting out-of-bounds reads;<\/li>\n- *     <li>Variable argument lists created <em>unsafely<\/em>, using {@link #ofAddress(long, SegmentScope)} are not capable of detecting out-of-bounds reads<\/li>\n- * <\/ul>\n- * <p>\n- * This class is not thread safe, and all accesses should occur within a single thread\n- * (regardless of the scope used to obtain the variable arity list).\n- *\n- * @since 19\n- *\/\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n-public sealed interface VaList permits WinVaList, SysVVaList, LinuxAArch64VaList, MacOsAArch64VaList, SharedUtils.EmptyVaList {\n-\n-    \/**\n-     * Reads the next value as an {@code int} and advances this variable argument list's position. The behavior of this\n-     * method is equivalent to the C {@code va_arg} function.\n-     *\n-     * @param layout the layout of the value to be read.\n-     * @return the {@code int} value read from this variable argument list.\n-     * @throws IllegalStateException if the scope associated with this variable argument list is not\n-     * {@linkplain SegmentScope#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread {@code T},\n-     * such that {@code segment().scope().isAccessibleBy(T) == false}.\n-     * @throws NoSuchElementException if an <a href=VaList.html#safety>out-of-bounds<\/a> read is detected.\n-     *\/\n-    int nextVarg(ValueLayout.OfInt layout);\n-\n-    \/**\n-     * Reads the next value as a {@code long} and advances this variable argument list's position. The behavior of this\n-     * method is equivalent to the C {@code va_arg} function.\n-     *\n-     * @param layout the layout of the value to be read.\n-     * @return the {@code long} value read from this variable argument list.\n-     * @throws IllegalStateException if the scope associated with this variable argument list is not\n-     * {@linkplain SegmentScope#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread {@code T},\n-     * such that {@code segment().scope().isAccessibleBy(T) == false}.\n-     * @throws NoSuchElementException if an <a href=VaList.html#safety>out-of-bounds<\/a> read is detected.\n-     *\/\n-    long nextVarg(ValueLayout.OfLong layout);\n-\n-    \/**\n-     * Reads the next value as a {@code double} and advances this variable argument list's position. The behavior of this\n-     * method is equivalent to the C {@code va_arg} function.\n-     *\n-     * @param layout the layout of the value\n-     * @return the {@code double} value read from this variable argument list.\n-     * @throws IllegalStateException if the scope associated with this variable argument list is not\n-     * {@linkplain SegmentScope#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread {@code T},\n-     * such that {@code segment().scope().isAccessibleBy(T) == false}.\n-     * @throws NoSuchElementException if an <a href=VaList.html#safety>out-of-bounds<\/a> read is detected.\n-     *\/\n-    double nextVarg(ValueLayout.OfDouble layout);\n-\n-    \/**\n-     * Reads the next address value, wraps it into a native segment, and advances this variable argument list's position.\n-     * The behavior of this method is equivalent to the C {@code va_arg} function. The returned segment's base\n-     * {@linkplain MemorySegment#address()} is set to the value read from the variable argument list, and the segment\n-     * is associated with the {@linkplain SegmentScope#global() global scope}. Under normal conditions, the size of the returned\n-     * segment is {@code 0}. However, if the provided layout is an {@linkplain ValueLayout.OfAddress#asUnbounded() unbounded}\n-     * address layout, then the size of the returned segment is {@code Long.MAX_VALUE}.\n-     *\n-     * @param layout the layout of the value to be read.\n-     * @return a native segment whose {@linkplain MemorySegment#address() address} is the value read from\n-     * this variable argument list.\n-     * @throws IllegalStateException if the scope associated with this variable argument list is not\n-     * {@linkplain SegmentScope#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread {@code T},\n-     * such that {@code segment().scope().isAccessibleBy(T) == false}.\n-     * @throws NoSuchElementException if an <a href=VaList.html#safety>out-of-bounds<\/a> read is detected.\n-     *\/\n-    MemorySegment nextVarg(ValueLayout.OfAddress layout);\n-\n-    \/**\n-     * Reads the next composite value into a new {@code MemorySegment}, allocated with the provided allocator,\n-     * and advances this variable argument list's position. The behavior of this method is equivalent to the C\n-     * {@code va_arg} function. The provided group layout must correspond to a C struct or union type.\n-     * <p>\n-     * How the value is read in the returned segment is ABI-dependent: calling this method on a group layout\n-     * with member layouts {@code L_1, L_2, ... L_n} is not guaranteed to be semantically equivalent to perform distinct\n-     * calls to {@code nextVarg} for each of the layouts in {@code L_1, L_2, ... L_n}.\n-     * <p>\n-     * The memory segment returned by this method will be allocated using the given {@link SegmentAllocator}.\n-     *\n-     * @param layout the layout of the value to be read.\n-     * @param allocator the allocator to be used to create a segment where the contents of the variable argument list\n-     *                  will be copied.\n-     * @return the {@code MemorySegment} value read from this variable argument list.\n-     * @throws IllegalStateException if the scope associated with this variable argument list is not\n-     * {@linkplain SegmentScope#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread {@code T},\n-     * such that {@code segment().scope().isAccessibleBy(T) == false}.\n-     * @throws NoSuchElementException if an <a href=VaList.html#safety>out-of-bounds<\/a> read is detected.\n-     *\/\n-    MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator);\n-\n-    \/**\n-     * Skips a number of elements with the given memory layouts, and advances this variable argument list's position.\n-     *\n-     * @param layouts the layouts of the values to be skipped.\n-     * @throws IllegalStateException if the scope associated with this variable argument list is not\n-     * {@linkplain SegmentScope#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread {@code T},\n-     * such that {@code segment().scope().isAccessibleBy(T) == false}.\n-     * @throws NoSuchElementException if an <a href=VaList.html#safety>out-of-bounds<\/a> read is detected.\n-     *\/\n-    void skip(MemoryLayout... layouts);\n-\n-    \/**\n-     * Copies this variable argument list at its current position into a new variable argument list associated\n-     * with the same scope as this variable argument list. The behavior of this method is equivalent to the C\n-     * {@code va_copy} function.\n-     * <p>\n-     * Copying is useful to traverse the variable argument list elements, starting from the current position,\n-     * without affecting the state of the original variable argument list, essentially allowing the elements to be\n-     * traversed multiple times.\n-     *\n-     * @return a copy of this variable argument list.\n-     * @throws IllegalStateException if the scope associated with this variable argument list is not\n-     * {@linkplain SegmentScope#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread {@code T},\n-     * such that {@code segment().scope().isAccessibleBy(T) == false}.\n-     *\/\n-    VaList copy();\n-\n-    \/**\n-     * Returns a zero-length {@linkplain MemorySegment memory segment} associated with this variable argument list.\n-     * The contents of the returned memory segment are platform-dependent. Whether and how the contents of\n-     * the returned segment are updated when iterating the contents of a variable argument list is also\n-     * platform-dependent.\n-     * @return a zero-length {@linkplain MemorySegment memory segment} associated with this variable argument list.\n-     *\/\n-    MemorySegment segment();\n-\n-    \/**\n-     * Creates a variable argument list from the give address value and scope. The address is typically obtained\n-     * by calling {@link MemorySegment#address()} on a foreign memory segment instance. The provided scope determines\n-     * the lifecycle of the returned variable argument list: the returned variable argument list will no longer be accessible,\n-     * and its associated off-heap memory region will be deallocated when the scope becomes not\n-     * {@linkplain SegmentScope#isAlive() alive}.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param address the address of the variable argument list.\n-     * @param scope the scope associated with the returned variable argument list.\n-     * @return a new variable argument list backed by an off-heap region of memory starting at the given address value.\n-     * @throws IllegalStateException         if {@code scope} is not {@linkplain SegmentScope#isAlive() alive}.\n-     * @throws WrongThreadException          if this method is called from a thread {@code T},\n-     *                                       such that {@code scope.isAccessibleBy(T) == false}.\n-     * @throws UnsupportedOperationException if the underlying native platform is not supported.\n-     * @throws IllegalCallerException If the caller is in a module that does not have native access enabled.\n-     *\/\n-    @CallerSensitive\n-    static VaList ofAddress(long address, SegmentScope scope) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), VaList.class, \"ofAddress\");\n-        Objects.requireNonNull(scope);\n-        return SharedUtils.newVaListOfAddress(address, scope);\n-    }\n-\n-    \/**\n-     * Creates a variable argument list using a builder (see {@link Builder}), with the given\n-     * scope. The provided scope determines the lifecycle of the returned variable argument list: the\n-     * returned variable argument list will no longer be accessible, and its associated off-heap memory region will be\n-     * deallocated when the scope becomes not {@linkplain SegmentScope#isAlive() alive}.\n-     * <p>\n-     * Note that when there are no elements added to the created va list,\n-     * this method will return the same as {@link #empty()}.\n-     *\n-     * @implNote variable argument lists created using this method can detect <a href=VaList.html#safety>out-of-bounds<\/a> reads.\n-     *\n-     * @param actions a consumer for a builder (see {@link Builder}) which can be used to specify the elements\n-     *                of the underlying variable argument list.\n-     * @param scope the scope to be associated with the new variable arity list.\n-     * @return a new variable argument list.\n-     * @throws UnsupportedOperationException if the underlying native platform is not supported.\n-     * @throws IllegalStateException if {@code scope} is not {@linkplain SegmentScope#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread {@code T},\n-     * such that {@code scope.isAccessibleBy(T) == false}.\n-     *\/\n-    static VaList make(Consumer<Builder> actions, SegmentScope scope) {\n-        Objects.requireNonNull(actions);\n-        Objects.requireNonNull(scope);\n-        return SharedUtils.newVaList(actions, scope);\n-    }\n-\n-    \/**\n-     * Returns an empty variable argument list, associated with the {@linkplain SegmentScope#global() global scope}.\n-     * The resulting variable argument list does not contain any argument, and throws {@link UnsupportedOperationException}\n-     * on all operations, except for {@link VaList#segment()}, {@link VaList#copy()}.\n-     * @return an empty variable argument list.\n-     * @throws UnsupportedOperationException if the underlying native platform is not supported.\n-     *\/\n-    static VaList empty() {\n-        return SharedUtils.emptyVaList();\n-    }\n-\n-    \/**\n-     * A builder used to construct a {@linkplain VaList variable argument list}.\n-     *\n-     * @since 19\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n-    sealed interface Builder permits WinVaList.Builder, SysVVaList.Builder, LinuxAArch64VaList.Builder, MacOsAArch64VaList.Builder {\n-\n-        \/**\n-         * Writes an {@code int} value to the variable argument list being constructed.\n-         *\n-         * @param layout the layout of the value to be written.\n-         * @param value the {@code int} value to be written.\n-         * @return this builder.\n-         *\/\n-        Builder addVarg(ValueLayout.OfInt layout, int value);\n-\n-        \/**\n-         * Writes a {@code long} value to the variable argument list being constructed.\n-         *\n-         * @param layout the layout of the value to be written.\n-         * @param value the {@code long} value to be written.\n-         * @return this builder.\n-         *\/\n-        Builder addVarg(ValueLayout.OfLong layout, long value);\n-\n-        \/**\n-         * Writes a {@code double} value to the variable argument list being constructed.\n-         *\n-         * @param layout the layout of the value to be written.\n-         * @param value the {@code double} value to be written.\n-         * @return this builder.\n-         *\/\n-        Builder addVarg(ValueLayout.OfDouble layout, double value);\n-\n-        \/**\n-         * Writes the {@linkplain MemorySegment#address() address} of the provided native segment\n-         * to the variable argument list being constructed.\n-         *\n-         * @param layout the layout of the value to be written.\n-         * @param segment the segment whose {@linkplain MemorySegment#address() address} is to be written.\n-         * @return this builder.\n-         *\/\n-        Builder addVarg(ValueLayout.OfAddress layout, MemorySegment segment);\n-\n-        \/**\n-         * Writes a {@code MemorySegment}, with the given layout, to the variable argument list being constructed.\n-         *\n-         * @param layout the layout of the value to be written.\n-         * @param value the {@code MemorySegment} whose contents will be copied.\n-         * @return this builder.\n-         *\/\n-        Builder addVarg(GroupLayout layout, MemorySegment value);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/VaList.java","additions":0,"deletions":350,"binary":false,"changes":350,"status":"deleted"},{"patch":"@@ -44,1 +44,0 @@\n-import java.lang.foreign.VaList;\n@@ -291,27 +290,0 @@\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, SegmentScope scope) {\n-        return switch (CABI.current()) {\n-            case WIN_64 -> Windowsx64Linker.newVaList(actions, scope);\n-            case SYS_V -> SysVx64Linker.newVaList(actions, scope);\n-            case LINUX_AARCH_64 -> LinuxAArch64Linker.newVaList(actions, scope);\n-            case MAC_OS_AARCH_64 -> MacOsAArch64Linker.newVaList(actions, scope);\n-        };\n-    }\n-\n-    public static VaList newVaListOfAddress(long address, SegmentScope scope) {\n-        return switch (CABI.current()) {\n-            case WIN_64 -> Windowsx64Linker.newVaListOfAddress(address, scope);\n-            case SYS_V -> SysVx64Linker.newVaListOfAddress(address, scope);\n-            case LINUX_AARCH_64 -> LinuxAArch64Linker.newVaListOfAddress(address, scope);\n-            case MAC_OS_AARCH_64 -> MacOsAArch64Linker.newVaListOfAddress(address, scope);\n-        };\n-    }\n-\n-    public static VaList emptyVaList() {\n-        return switch (CABI.current()) {\n-            case WIN_64 -> Windowsx64Linker.emptyVaList();\n-            case SYS_V -> SysVx64Linker.emptyVaList();\n-            case LINUX_AARCH_64 -> LinuxAArch64Linker.emptyVaList();\n-            case MAC_OS_AARCH_64 -> MacOsAArch64Linker.emptyVaList();\n-        };\n-    }\n-\n@@ -325,4 +297,0 @@\n-    public static NoSuchElementException newVaListNSEE(MemoryLayout layout) {\n-        return new NoSuchElementException(\"No such element: \" + layout);\n-    }\n-\n@@ -343,53 +311,0 @@\n-    public static final class EmptyVaList implements VaList {\n-\n-        private final MemorySegment address;\n-\n-        public EmptyVaList(MemorySegment address) {\n-            this.address = address;\n-        }\n-\n-        private static UnsupportedOperationException uoe() {\n-            return new UnsupportedOperationException(\"Empty VaList\");\n-        }\n-\n-        @Override\n-        public int nextVarg(ValueLayout.OfInt layout) {\n-            throw uoe();\n-        }\n-\n-        @Override\n-        public long nextVarg(ValueLayout.OfLong layout) {\n-            throw uoe();\n-        }\n-\n-        @Override\n-        public double nextVarg(ValueLayout.OfDouble layout) {\n-            throw uoe();\n-        }\n-\n-        @Override\n-        public MemorySegment nextVarg(ValueLayout.OfAddress layout) {\n-            throw uoe();\n-        }\n-\n-        @Override\n-        public MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator) {\n-            throw uoe();\n-        }\n-\n-        @Override\n-        public void skip(MemoryLayout... layouts) {\n-            throw uoe();\n-        }\n-\n-        @Override\n-        public VaList copy() {\n-            return this;\n-        }\n-\n-        @Override\n-        public MemorySegment segment() {\n-            return address;\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":0,"deletions":85,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import java.lang.foreign.VaList;\n@@ -67,14 +66,0 @@\n-\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, SegmentScope scope) {\n-        LinuxAArch64VaList.Builder builder = LinuxAArch64VaList.builder(scope);\n-        actions.accept(builder);\n-        return builder.build();\n-    }\n-\n-    public static VaList newVaListOfAddress(long address, SegmentScope scope) {\n-        return LinuxAArch64VaList.ofAddress(address, scope);\n-    }\n-\n-    public static VaList emptyVaList() {\n-        return LinuxAArch64VaList.empty();\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1,568 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, 2021, Arm Limited. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.foreign.abi.aarch64.linux;\n-\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.ValueLayout;\n-import java.lang.foreign.VaList;\n-import java.lang.foreign.SegmentAllocator;\n-import jdk.internal.foreign.abi.aarch64.TypeClass;\n-import jdk.internal.foreign.MemorySessionImpl;\n-import jdk.internal.foreign.Utils;\n-import jdk.internal.foreign.abi.SharedUtils;\n-\n-import java.lang.invoke.VarHandle;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n-\n-import static jdk.internal.foreign.PlatformLayouts.AArch64;\n-\n-import static java.lang.foreign.MemoryLayout.PathElement.groupElement;\n-import static jdk.internal.foreign.abi.SharedUtils.SimpleVaArg;\n-import static jdk.internal.foreign.abi.SharedUtils.THROWING_ALLOCATOR;\n-import static jdk.internal.foreign.abi.aarch64.CallArranger.MAX_REGISTER_ARGUMENTS;\n-\n-\/**\n- * Standard va_list implementation as defined by AAPCS document and used on\n- * Linux. Variadic parameters may be passed in registers or on the stack.\n- *\/\n-public non-sealed class LinuxAArch64VaList implements VaList {\n-\n-    \/\/ See AAPCS Appendix B \"Variable Argument Lists\" for definition of\n-    \/\/ va_list on AArch64.\n-    \/\/\n-    \/\/ typedef struct __va_list {\n-    \/\/     void *__stack;   \/\/ next stack param\n-    \/\/     void *__gr_top;  \/\/ end of GP arg reg save area\n-    \/\/     void *__vr_top;  \/\/ end of FP\/SIMD arg reg save area\n-    \/\/     int __gr_offs;   \/\/ offset from __gr_top to next GP register arg\n-    \/\/     int __vr_offs;   \/\/ offset from __vr_top to next FP\/SIMD register arg\n-    \/\/ } va_list;\n-\n-    static final GroupLayout LAYOUT = MemoryLayout.structLayout(\n-        AArch64.C_POINTER.withName(\"__stack\"),\n-        AArch64.C_POINTER.withName(\"__gr_top\"),\n-        AArch64.C_POINTER.withName(\"__vr_top\"),\n-        AArch64.C_INT.withName(\"__gr_offs\"),\n-        AArch64.C_INT.withName(\"__vr_offs\")\n-    ).withName(\"__va_list\");\n-\n-    private static final long STACK_SLOT_SIZE = 8;\n-\n-    private static final MemoryLayout GP_REG\n-        = MemoryLayout.paddingLayout(64).withBitAlignment(64);\n-    private static final MemoryLayout FP_REG\n-        = MemoryLayout.paddingLayout(128).withBitAlignment(128);\n-\n-    private static final MemoryLayout LAYOUT_GP_REGS\n-        = MemoryLayout.sequenceLayout(MAX_REGISTER_ARGUMENTS, GP_REG);\n-    private static final MemoryLayout LAYOUT_FP_REGS\n-        = MemoryLayout.sequenceLayout(MAX_REGISTER_ARGUMENTS, FP_REG);\n-\n-    private static final int GP_SLOT_SIZE = (int) GP_REG.byteSize();\n-    private static final int FP_SLOT_SIZE = (int) FP_REG.byteSize();\n-\n-    private static final int MAX_GP_OFFSET = (int) LAYOUT_GP_REGS.byteSize();\n-    private static final int MAX_FP_OFFSET = (int) LAYOUT_FP_REGS.byteSize();\n-\n-    private static final VarHandle VH_stack = LAYOUT.varHandle(groupElement(\"__stack\"));\n-    private static final VarHandle VH_gr_top = LAYOUT.varHandle(groupElement(\"__gr_top\"));\n-    private static final VarHandle VH_vr_top = LAYOUT.varHandle(groupElement(\"__vr_top\"));\n-    private static final VarHandle VH_gr_offs\n-        = LAYOUT.varHandle(groupElement(\"__gr_offs\"));\n-    private static final VarHandle VH_vr_offs\n-        = LAYOUT.varHandle(groupElement(\"__vr_offs\"));\n-\n-    private static final VaList EMPTY\n-        = new SharedUtils.EmptyVaList(emptyListAddress());\n-\n-    private final MemorySegment segment;\n-    private MemorySegment stack;\n-    private final MemorySegment gpRegsArea;\n-    private final long gpLimit;\n-    private final MemorySegment fpRegsArea;\n-    private final long fpLimit;\n-\n-    private LinuxAArch64VaList(MemorySegment segment, MemorySegment stack,\n-                               MemorySegment gpRegsArea, long gpLimit, MemorySegment fpRegsArea, long fpLimit) {\n-        this.segment = segment;\n-        this.stack = stack;\n-        this.gpRegsArea = gpRegsArea;\n-        this.gpLimit = gpLimit;\n-        this.fpRegsArea = fpRegsArea;\n-        this.fpLimit = fpLimit;\n-    }\n-\n-    private static LinuxAArch64VaList readFromAddress(long address, SegmentScope scope) {\n-        MemorySegment segment = MemorySegment.ofAddress(address, LAYOUT.byteSize(), scope);\n-        MemorySegment stack = stackPtr(segment); \/\/ size unknown\n-        MemorySegment gpRegsArea = MemorySegment.ofAddress(grTop(segment).address() - MAX_GP_OFFSET, MAX_GP_OFFSET, scope);\n-        MemorySegment fpRegsArea = MemorySegment.ofAddress(vrTop(segment).address() - MAX_FP_OFFSET, MAX_FP_OFFSET, scope);\n-        return new LinuxAArch64VaList(segment, stack, gpRegsArea, MAX_GP_OFFSET, fpRegsArea, MAX_FP_OFFSET);\n-    }\n-\n-    private static MemorySegment emptyListAddress() {\n-        MemorySegment ms = MemorySegment.allocateNative(LAYOUT, SegmentScope.auto());\n-        VH_stack.set(ms, MemorySegment.NULL);\n-        VH_gr_top.set(ms, MemorySegment.NULL);\n-        VH_vr_top.set(ms, MemorySegment.NULL);\n-        VH_gr_offs.set(ms, 0);\n-        VH_vr_offs.set(ms, 0);\n-        return ms.asSlice(0, 0);\n-    }\n-\n-    public static VaList empty() {\n-        return EMPTY;\n-    }\n-\n-    private MemorySegment grTop() {\n-        return grTop(segment);\n-    }\n-\n-    private static MemorySegment grTop(MemorySegment segment) {\n-        return (MemorySegment) VH_gr_top.get(segment);\n-    }\n-\n-    private MemorySegment vrTop() {\n-        return vrTop(segment);\n-    }\n-\n-    private static MemorySegment vrTop(MemorySegment segment) {\n-        return (MemorySegment) VH_vr_top.get(segment);\n-    }\n-\n-    private int grOffs() {\n-        final int offs = (int) VH_gr_offs.get(segment);\n-        assert offs <= 0;\n-        return offs;\n-    }\n-\n-    private int vrOffs() {\n-        final int offs = (int) VH_vr_offs.get(segment);\n-        assert offs <= 0;\n-        return offs;\n-    }\n-\n-    private static MemorySegment stackPtr(MemorySegment segment) {\n-        return (MemorySegment) VH_stack.get(segment);\n-    }\n-\n-    private MemorySegment stackPtr() {\n-        return stackPtr(segment);\n-    }\n-\n-    private void setStack(MemorySegment newStack) {\n-        stack = newStack;\n-        VH_stack.set(segment, stack);\n-    }\n-\n-    private void consumeGPSlots(int num) {\n-        final int old = (int) VH_gr_offs.get(segment);\n-        VH_gr_offs.set(segment, old + num * GP_SLOT_SIZE);\n-    }\n-\n-    private void consumeFPSlots(int num) {\n-        final int old = (int) VH_vr_offs.get(segment);\n-        VH_vr_offs.set(segment, old + num * FP_SLOT_SIZE);\n-    }\n-\n-    private long currentGPOffset() {\n-        \/\/ Offset from start of GP register segment. __gr_top points to the top\n-        \/\/ (highest address) of the GP registers area. __gr_offs is the negative\n-        \/\/ offset of next saved register from the top.\n-\n-        return gpRegsArea.byteSize() + grOffs();\n-    }\n-\n-    private long currentFPOffset() {\n-        \/\/ Offset from start of FP register segment. __vr_top points to the top\n-        \/\/ (highest address) of the FP registers area. __vr_offs is the negative\n-        \/\/ offset of next saved register from the top.\n-\n-        return fpRegsArea.byteSize() + vrOffs();\n-    }\n-\n-    private long preAlignOffset(MemoryLayout layout) {\n-        long alignmentOffset = 0;\n-        if (layout.byteAlignment() > STACK_SLOT_SIZE) {\n-            long addr = stack.address();\n-            alignmentOffset = Utils.alignUp(addr, 16) - addr;\n-        }\n-        return alignmentOffset;\n-    }\n-\n-    private void preAlignStack(MemoryLayout layout) {\n-        setStack(stack.asSlice(preAlignOffset(layout)));\n-    }\n-\n-    private void postAlignStack(MemoryLayout layout) {\n-        setStack(stack.asSlice(Utils.alignUp(layout.byteSize(), STACK_SLOT_SIZE)));\n-    }\n-\n-    @Override\n-    public int nextVarg(ValueLayout.OfInt layout) {\n-        return (int) read(layout);\n-    }\n-\n-    @Override\n-    public long nextVarg(ValueLayout.OfLong layout) {\n-        return (long) read(layout);\n-    }\n-\n-    @Override\n-    public double nextVarg(ValueLayout.OfDouble layout) {\n-        return (double) read(layout);\n-    }\n-\n-    @Override\n-    public MemorySegment nextVarg(ValueLayout.OfAddress layout) {\n-        return (MemorySegment) read(layout);\n-    }\n-\n-    @Override\n-    public MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator) {\n-        Objects.requireNonNull(allocator);\n-        return (MemorySegment) read( layout, allocator);\n-    }\n-\n-    private Object read(MemoryLayout layout) {\n-        return read(layout, THROWING_ALLOCATOR);\n-    }\n-\n-    private Object read(MemoryLayout layout, SegmentAllocator allocator) {\n-        Objects.requireNonNull(layout);\n-        TypeClass typeClass = TypeClass.classifyLayout(layout);\n-        if (isRegOverflow(currentGPOffset(), currentFPOffset(), typeClass, layout)) {\n-            checkStackElement(layout);\n-            preAlignStack(layout);\n-            return switch (typeClass) {\n-                case STRUCT_REGISTER, STRUCT_HFA, STRUCT_REFERENCE -> {\n-                    MemorySegment slice = stack.asSlice(0, layout.byteSize());\n-                    MemorySegment seg = allocator.allocate(layout);\n-                    seg.copyFrom(slice);\n-                    postAlignStack(layout);\n-                    yield seg;\n-                }\n-                case POINTER, INTEGER, FLOAT -> {\n-                    VarHandle reader = layout.varHandle();\n-                    MemorySegment slice = stack.asSlice(0, layout.byteSize());\n-                    Object res = reader.get(slice);\n-                    postAlignStack(layout);\n-                    yield res;\n-                }\n-            };\n-        } else {\n-            return switch (typeClass) {\n-                case STRUCT_REGISTER -> {\n-                    checkGPElement(layout, numSlots(layout));\n-                    \/\/ Struct is passed packed in integer registers.\n-                    MemorySegment value = allocator.allocate(layout);\n-                    long offset = 0;\n-                    while (offset < layout.byteSize()) {\n-                        final long copy = Math.min(layout.byteSize() - offset, 8);\n-                        MemorySegment.copy(gpRegsArea, currentGPOffset(), value, offset, copy);\n-                        consumeGPSlots(1);\n-                        offset += copy;\n-                    }\n-                    yield value;\n-                }\n-                case STRUCT_HFA -> {\n-                    checkFPElement(layout, numSlots(layout));\n-                    \/\/ Struct is passed with each element in a separate floating\n-                    \/\/ point register.\n-                    MemorySegment value = allocator.allocate(layout);\n-                    GroupLayout group = (GroupLayout)layout;\n-                    long offset = 0;\n-                    for (MemoryLayout elem : group.memberLayouts()) {\n-                        assert elem.byteSize() <= 8;\n-                        final long copy = elem.byteSize();\n-                        MemorySegment.copy(fpRegsArea, currentFPOffset(), value, offset, copy);\n-                        consumeFPSlots(1);\n-                        offset += copy;\n-                    }\n-                    yield value;\n-                }\n-                case STRUCT_REFERENCE -> {\n-                    checkGPElement(layout, 1);\n-                    \/\/ Struct is passed indirectly via a pointer in an integer register.\n-                    VarHandle ptrReader = AArch64.C_POINTER.varHandle();\n-                    MemorySegment ptr = (MemorySegment) ptrReader.get(\n-                        gpRegsArea.asSlice(currentGPOffset()));\n-                    consumeGPSlots(1);\n-\n-                    MemorySegment slice = MemorySegment.ofAddress(ptr.address(), layout.byteSize(), segment.scope());\n-                    MemorySegment seg = allocator.allocate(layout);\n-                    seg.copyFrom(slice);\n-                    yield seg;\n-                }\n-                case POINTER, INTEGER -> {\n-                    checkGPElement(layout, 1);\n-                    VarHandle reader = layout.varHandle();\n-                    Object res = reader.get(gpRegsArea.asSlice(currentGPOffset()));\n-                    consumeGPSlots(1);\n-                    yield res;\n-                }\n-                case FLOAT -> {\n-                    checkFPElement(layout, 1);\n-                    VarHandle reader = layout.varHandle();\n-                    Object res = reader.get(fpRegsArea.asSlice(currentFPOffset()));\n-                    consumeFPSlots(1);\n-                    yield res;\n-                }\n-            };\n-        }\n-    }\n-\n-    private void checkGPElement(MemoryLayout layout, long slots) {\n-        if ((grOffs() + MAX_GP_OFFSET) + (slots * GP_SLOT_SIZE) > gpLimit) {\n-            throw SharedUtils.newVaListNSEE(layout);\n-        }\n-    }\n-\n-    private void checkFPElement(MemoryLayout layout, long slots) {\n-        if ((vrOffs() + MAX_FP_OFFSET) + (slots * FP_SLOT_SIZE) > fpLimit) {\n-            throw SharedUtils.newVaListNSEE(layout);\n-        }\n-    }\n-\n-    private void checkStackElement(MemoryLayout layout) {\n-        if (preAlignOffset(layout) + layout.byteSize() > stack.byteSize()) {\n-            throw SharedUtils.newVaListNSEE(layout);\n-        }\n-    }\n-\n-    @Override\n-    public void skip(MemoryLayout... layouts) {\n-        Objects.requireNonNull(layouts);\n-        ((MemorySessionImpl) segment.scope()).checkValidState();\n-        for (MemoryLayout layout : layouts) {\n-            Objects.requireNonNull(layout);\n-            TypeClass typeClass = TypeClass.classifyLayout(layout);\n-            if (isRegOverflow(currentGPOffset(), currentFPOffset(), typeClass, layout)) {\n-                checkStackElement(layout);\n-                preAlignStack(layout);\n-                postAlignStack(layout);\n-            } else if (typeClass == TypeClass.FLOAT || typeClass == TypeClass.STRUCT_HFA) {\n-                long slots = numSlots(layout);\n-                checkFPElement(layout, slots);\n-                consumeFPSlots((int) slots);\n-            } else if (typeClass == TypeClass.STRUCT_REFERENCE) {\n-                checkGPElement(layout, 1);\n-                consumeGPSlots(1);\n-            } else {\n-                long slots = numSlots(layout);\n-                checkGPElement(layout, slots);\n-                consumeGPSlots((int) slots);\n-            }\n-        }\n-    }\n-\n-    static LinuxAArch64VaList.Builder builder(SegmentScope scope) {\n-        return new LinuxAArch64VaList.Builder(scope);\n-    }\n-\n-    public static VaList ofAddress(long address, SegmentScope scope) {\n-        return readFromAddress(address, scope);\n-    }\n-\n-    @Override\n-    public VaList copy() {\n-        MemorySegment copy = MemorySegment.allocateNative(LAYOUT, segment.scope());\n-        copy.copyFrom(segment);\n-        return new LinuxAArch64VaList(copy, stack, gpRegsArea, gpLimit, fpRegsArea, fpLimit);\n-    }\n-\n-    @Override\n-    public MemorySegment segment() {\n-        \/\/ make sure that returned segment cannot be accessed\n-        return segment.asSlice(0, 0);\n-    }\n-\n-    private static long numSlots(MemoryLayout layout) {\n-        return Utils.alignUp(layout.byteSize(), STACK_SLOT_SIZE) \/ STACK_SLOT_SIZE;\n-    }\n-\n-    private static boolean isRegOverflow(long currentGPOffset, long currentFPOffset,\n-                                         TypeClass typeClass, MemoryLayout layout) {\n-        if (typeClass == TypeClass.FLOAT || typeClass == TypeClass.STRUCT_HFA) {\n-            return currentFPOffset > MAX_FP_OFFSET - numSlots(layout) * FP_SLOT_SIZE;\n-        } else if (typeClass == TypeClass.STRUCT_REFERENCE) {\n-            return currentGPOffset > MAX_GP_OFFSET - GP_SLOT_SIZE;\n-        } else {\n-            return currentGPOffset > MAX_GP_OFFSET - numSlots(layout) * GP_SLOT_SIZE;\n-        }\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"LinuxAArch64VaList{\"\n-            + \"__stack=\" + stackPtr()\n-            + \", __gr_top=\" + grTop()\n-            + \", __vr_top=\" + vrTop()\n-            + \", __gr_offs=\" + grOffs()\n-            + \", __vr_offs=\" + vrOffs()\n-            + '}';\n-    }\n-\n-    public static non-sealed class Builder implements VaList.Builder {\n-        private final SegmentScope scope;\n-        private final MemorySegment gpRegs;\n-        private final MemorySegment fpRegs;\n-\n-        private long currentGPOffset = 0;\n-        private long currentFPOffset = 0;\n-        private final List<SimpleVaArg> stackArgs = new ArrayList<>();\n-\n-        Builder(SegmentScope scope) {\n-            this.scope = scope;\n-            this.gpRegs = MemorySegment.allocateNative(LAYOUT_GP_REGS, scope);\n-            this.fpRegs = MemorySegment.allocateNative(LAYOUT_FP_REGS, scope);\n-        }\n-\n-        @Override\n-        public Builder addVarg(ValueLayout.OfInt layout, int value) {\n-            return arg(layout, value);\n-        }\n-\n-        @Override\n-        public Builder addVarg(ValueLayout.OfLong layout, long value) {\n-            return arg(layout, value);\n-        }\n-\n-        @Override\n-        public Builder addVarg(ValueLayout.OfDouble layout, double value) {\n-            return arg(layout, value);\n-        }\n-\n-        @Override\n-        public Builder addVarg(ValueLayout.OfAddress layout, MemorySegment value) {\n-            return arg(layout, value);\n-        }\n-\n-        @Override\n-        public Builder addVarg(GroupLayout layout, MemorySegment value) {\n-            return arg(layout, value);\n-        }\n-\n-        private Builder arg(MemoryLayout layout, Object value) {\n-            Objects.requireNonNull(layout);\n-            Objects.requireNonNull(value);\n-            TypeClass typeClass = TypeClass.classifyLayout(layout);\n-            if (isRegOverflow(currentGPOffset, currentFPOffset, typeClass, layout)) {\n-                stackArgs.add(new SimpleVaArg(layout, value));\n-            } else {\n-                switch (typeClass) {\n-                    case STRUCT_REGISTER -> {\n-                        \/\/ Struct is passed packed in integer registers.\n-                        MemorySegment valueSegment = (MemorySegment) value;\n-                        long offset = 0;\n-                        while (offset < layout.byteSize()) {\n-                            final long copy = Math.min(layout.byteSize() - offset, 8);\n-                            MemorySegment.copy(valueSegment, offset, gpRegs, currentGPOffset, copy);\n-                            currentGPOffset += GP_SLOT_SIZE;\n-                            offset += copy;\n-                        }\n-                    }\n-                    case STRUCT_HFA -> {\n-                        \/\/ Struct is passed with each element in a separate floating\n-                        \/\/ point register.\n-                        MemorySegment valueSegment = (MemorySegment) value;\n-                        GroupLayout group = (GroupLayout)layout;\n-                        long offset = 0;\n-                        for (MemoryLayout elem : group.memberLayouts()) {\n-                            assert elem.byteSize() <= 8;\n-                            final long copy = elem.byteSize();\n-                            MemorySegment.copy(valueSegment, offset, fpRegs, currentFPOffset, copy);\n-                            currentFPOffset += FP_SLOT_SIZE;\n-                            offset += copy;\n-                        }\n-                    }\n-                    case STRUCT_REFERENCE -> {\n-                        \/\/ Struct is passed indirectly via a pointer in an integer register.\n-                        MemorySegment valueSegment = (MemorySegment) value;\n-                        VarHandle writer = AArch64.C_POINTER.varHandle();\n-                        writer.set(gpRegs.asSlice(currentGPOffset),\n-                                   valueSegment);\n-                        currentGPOffset += GP_SLOT_SIZE;\n-                    }\n-                    case POINTER, INTEGER -> {\n-                        VarHandle writer = layout.varHandle();\n-                        writer.set(gpRegs.asSlice(currentGPOffset), value);\n-                        currentGPOffset += GP_SLOT_SIZE;\n-                    }\n-                    case FLOAT -> {\n-                        VarHandle writer = layout.varHandle();\n-                        writer.set(fpRegs.asSlice(currentFPOffset), value);\n-                        currentFPOffset += FP_SLOT_SIZE;\n-                    }\n-                }\n-            }\n-            return this;\n-        }\n-\n-        private boolean isEmpty() {\n-            return currentGPOffset == 0 && currentFPOffset == 0 && stackArgs.isEmpty();\n-        }\n-\n-        public VaList build() {\n-            if (isEmpty()) {\n-                return EMPTY;\n-            }\n-\n-            MemorySegment vaListSegment = MemorySegment.allocateNative(LAYOUT, scope);\n-            MemorySegment stackArgsSegment;\n-            if (!stackArgs.isEmpty()) {\n-                long stackArgsSize = stackArgs.stream()\n-                    .reduce(0L, (acc, e) -> acc + Utils.alignUp(e.layout.byteSize(), STACK_SLOT_SIZE), Long::sum);\n-                stackArgsSegment = MemorySegment.allocateNative(stackArgsSize, 16, scope);\n-                MemorySegment writeCursor = stackArgsSegment;\n-                for (SimpleVaArg arg : stackArgs) {\n-                    final long alignedSize = Utils.alignUp(arg.layout.byteSize(), STACK_SLOT_SIZE);\n-                    writeCursor = Utils.alignUp(writeCursor, alignedSize);\n-                    VarHandle writer = arg.varHandle();\n-                    writer.set(writeCursor, arg.value);\n-                    writeCursor = writeCursor.asSlice(alignedSize);\n-                }\n-            } else {\n-                stackArgsSegment = MemorySegment.NULL;\n-            }\n-\n-            VH_gr_top.set(vaListSegment, gpRegs.asSlice(gpRegs.byteSize()));\n-            VH_vr_top.set(vaListSegment, fpRegs.asSlice(fpRegs.byteSize()));\n-            VH_stack.set(vaListSegment, stackArgsSegment);\n-            VH_gr_offs.set(vaListSegment, -MAX_GP_OFFSET);\n-            VH_vr_offs.set(vaListSegment, -MAX_FP_OFFSET);\n-\n-            assert MemorySessionImpl.sameOwnerThread(gpRegs.scope(), vaListSegment.scope());\n-            assert MemorySessionImpl.sameOwnerThread(fpRegs.scope(), vaListSegment.scope());\n-            return new LinuxAArch64VaList(vaListSegment, stackArgsSegment, gpRegs, currentGPOffset, fpRegs, currentFPOffset);\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64VaList.java","additions":0,"deletions":568,"binary":false,"changes":568,"status":"deleted"},{"patch":"@@ -35,1 +35,0 @@\n-import java.lang.foreign.VaList;\n@@ -67,14 +66,0 @@\n-\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, SegmentScope scope) {\n-        MacOsAArch64VaList.Builder builder = MacOsAArch64VaList.builder(scope);\n-        actions.accept(builder);\n-        return builder.build();\n-    }\n-\n-    public static VaList newVaListOfAddress(long address, SegmentScope scope) {\n-        return MacOsAArch64VaList.ofAddress(address, scope);\n-    }\n-\n-    public static VaList emptyVaList() {\n-        return MacOsAArch64VaList.empty();\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1,257 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2021, Arm Limited. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.foreign.abi.aarch64.macos;\n-\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.SegmentAllocator;\n-import java.lang.foreign.VaList;\n-import java.lang.foreign.ValueLayout;\n-import jdk.internal.foreign.abi.aarch64.TypeClass;\n-import jdk.internal.foreign.MemorySessionImpl;\n-import jdk.internal.foreign.abi.SharedUtils;\n-import jdk.internal.foreign.abi.SharedUtils.SimpleVaArg;\n-\n-import java.lang.invoke.VarHandle;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n-\n-import static jdk.internal.foreign.PlatformLayouts.AArch64.C_POINTER;\n-import static jdk.internal.foreign.abi.SharedUtils.alignUp;\n-\n-\/**\n- * Simplified va_list implementation used on macOS where all variadic\n- * parameters are passed on the stack and the type of va_list decays to\n- * char* instead of the structure defined in the AAPCS.\n- *\/\n-public non-sealed class MacOsAArch64VaList implements VaList {\n-    private static final long VA_SLOT_SIZE_BYTES = 8;\n-    private static final VarHandle VH_address = C_POINTER.varHandle();\n-\n-    private static final VaList EMPTY = new SharedUtils.EmptyVaList(MemorySegment.NULL);\n-\n-    private MemorySegment segment;\n-\n-    private MacOsAArch64VaList(MemorySegment segment) {\n-        this.segment = segment;\n-    }\n-\n-    public static VaList empty() {\n-        return EMPTY;\n-    }\n-\n-    @Override\n-    public int nextVarg(ValueLayout.OfInt layout) {\n-        return (int) read(layout);\n-    }\n-\n-    @Override\n-    public long nextVarg(ValueLayout.OfLong layout) {\n-        return (long) read(layout);\n-    }\n-\n-    @Override\n-    public double nextVarg(ValueLayout.OfDouble layout) {\n-        return (double) read(layout);\n-    }\n-\n-    @Override\n-    public MemorySegment nextVarg(ValueLayout.OfAddress layout) {\n-        return (MemorySegment) read(layout);\n-    }\n-\n-    @Override\n-    public MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator) {\n-        Objects.requireNonNull(allocator);\n-        return (MemorySegment) read(layout, allocator);\n-    }\n-\n-    private Object read(MemoryLayout layout) {\n-        return read(layout, SharedUtils.THROWING_ALLOCATOR);\n-    }\n-\n-    private Object read(MemoryLayout layout, SegmentAllocator allocator) {\n-        Objects.requireNonNull(layout);\n-        Object res;\n-        if (layout instanceof GroupLayout) {\n-            TypeClass typeClass = TypeClass.classifyLayout(layout);\n-            res = switch (typeClass) {\n-                case STRUCT_REFERENCE -> {\n-                    checkElement(layout, VA_SLOT_SIZE_BYTES);\n-                    MemorySegment structAddr = (MemorySegment) VH_address.get(segment);\n-                    MemorySegment struct = MemorySegment.ofAddress(structAddr.address(), layout.byteSize(), segment.scope());\n-                    MemorySegment seg = allocator.allocate(layout);\n-                    seg.copyFrom(struct);\n-                    segment = segment.asSlice(VA_SLOT_SIZE_BYTES);\n-                    yield seg;\n-                }\n-                case STRUCT_REGISTER, STRUCT_HFA -> {\n-                    long size = alignUp(layout.byteSize(), VA_SLOT_SIZE_BYTES);\n-                    checkElement(layout, size);\n-                    MemorySegment struct = allocator.allocate(layout)\n-                            .copyFrom(segment.asSlice(0, layout.byteSize()));\n-                    segment = segment.asSlice(size);\n-                    yield struct;\n-                }\n-                default -> throw new IllegalStateException(\"Unexpected TypeClass: \" + typeClass);\n-            };\n-        } else {\n-            checkElement(layout, VA_SLOT_SIZE_BYTES);\n-            VarHandle reader = layout.varHandle();\n-            res = reader.get(segment);\n-            segment = segment.asSlice(VA_SLOT_SIZE_BYTES);\n-        }\n-        return res;\n-    }\n-\n-    private static long sizeOf(MemoryLayout layout) {\n-        return switch (TypeClass.classifyLayout(layout)) {\n-            case STRUCT_REGISTER, STRUCT_HFA -> alignUp(layout.byteSize(), VA_SLOT_SIZE_BYTES);\n-            default -> VA_SLOT_SIZE_BYTES;\n-        };\n-    }\n-\n-    @Override\n-    public void skip(MemoryLayout... layouts) {\n-        Objects.requireNonNull(layouts);\n-        ((MemorySessionImpl) segment.scope()).checkValidState();\n-\n-        for (MemoryLayout layout : layouts) {\n-            Objects.requireNonNull(layout);\n-            long size = sizeOf(layout);\n-            checkElement(layout, size);\n-            segment = segment.asSlice(size);\n-        }\n-    }\n-\n-    private void checkElement(MemoryLayout layout, long size) {\n-        if (segment.byteSize() < size) {\n-            throw SharedUtils.newVaListNSEE(layout);\n-        }\n-    }\n-\n-    static MacOsAArch64VaList ofAddress(long address, SegmentScope session) {\n-        MemorySegment segment = MemorySegment.ofAddress(address, Long.MAX_VALUE, session);\n-        return new MacOsAArch64VaList(segment);\n-    }\n-\n-    static Builder builder(SegmentScope session) {\n-        return new Builder(session);\n-    }\n-\n-    @Override\n-    public VaList copy() {\n-        ((MemorySessionImpl) segment.scope()).checkValidState();\n-        return new MacOsAArch64VaList(segment);\n-    }\n-\n-    @Override\n-    public MemorySegment segment() {\n-        \/\/ make sure that returned segment cannot be accessed\n-        return segment.asSlice(0, 0);\n-    }\n-\n-    public static non-sealed class Builder implements VaList.Builder {\n-\n-        private final SegmentScope session;\n-        private final List<SimpleVaArg> args = new ArrayList<>();\n-\n-        public Builder(SegmentScope session) {\n-            ((MemorySessionImpl) session).checkValidState();\n-            this.session = session;\n-        }\n-\n-        private Builder arg(MemoryLayout layout, Object value) {\n-            Objects.requireNonNull(layout);\n-            Objects.requireNonNull(value);\n-            args.add(new SimpleVaArg(layout, value));\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder addVarg(ValueLayout.OfInt layout, int value) {\n-            return arg(layout, value);\n-        }\n-\n-        @Override\n-        public Builder addVarg(ValueLayout.OfLong layout, long value) {\n-            return arg(layout, value);\n-        }\n-\n-        @Override\n-        public Builder addVarg(ValueLayout.OfDouble layout, double value) {\n-            return arg(layout, value);\n-        }\n-\n-        @Override\n-        public Builder addVarg(ValueLayout.OfAddress layout, MemorySegment value) {\n-            return arg(layout, value);\n-        }\n-\n-        @Override\n-        public Builder addVarg(GroupLayout layout, MemorySegment value) {\n-            return arg(layout, value);\n-        }\n-\n-        public VaList build() {\n-            if (args.isEmpty()) {\n-                return EMPTY;\n-            }\n-\n-            long allocationSize = args.stream().reduce(0L, (acc, e) -> acc + sizeOf(e.layout), Long::sum);\n-            MemorySegment segment = MemorySegment.allocateNative(allocationSize, session);\n-            MemorySegment cursor = segment;\n-\n-            for (SimpleVaArg arg : args) {\n-                if (arg.layout instanceof GroupLayout) {\n-                    MemorySegment msArg = ((MemorySegment) arg.value);\n-                    TypeClass typeClass = TypeClass.classifyLayout(arg.layout);\n-                    switch (typeClass) {\n-                        case STRUCT_REFERENCE -> {\n-                            MemorySegment copy = MemorySegment.allocateNative(arg.layout, session);\n-                            copy.copyFrom(msArg); \/\/ by-value\n-                            VH_address.set(cursor, copy);\n-                            cursor = cursor.asSlice(VA_SLOT_SIZE_BYTES);\n-                        }\n-                        case STRUCT_REGISTER, STRUCT_HFA ->\n-                            cursor.copyFrom(msArg.asSlice(0, arg.layout.byteSize()))\n-                                    .asSlice(alignUp(arg.layout.byteSize(), VA_SLOT_SIZE_BYTES));\n-                        default -> throw new IllegalStateException(\"Unexpected TypeClass: \" + typeClass);\n-                    }\n-                } else {\n-                    VarHandle writer = arg.varHandle();\n-                    writer.set(cursor, arg.value);\n-                    cursor = cursor.asSlice(VA_SLOT_SIZE_BYTES);\n-                }\n-            }\n-\n-            return new MacOsAArch64VaList(segment);\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64VaList.java","additions":0,"deletions":257,"binary":false,"changes":257,"status":"deleted"},{"patch":"@@ -1,479 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-package jdk.internal.foreign.abi.x64.sysv;\n-\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.SegmentAllocator;\n-import java.lang.foreign.VaList;\n-import java.lang.foreign.ValueLayout;\n-\n-import jdk.internal.foreign.MemorySessionImpl;\n-import jdk.internal.foreign.Utils;\n-import jdk.internal.foreign.abi.SharedUtils;\n-\n-import java.lang.invoke.VarHandle;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n-\n-import static jdk.internal.foreign.PlatformLayouts.SysV;\n-\n-import static java.lang.foreign.MemoryLayout.PathElement.groupElement;\n-import static jdk.internal.foreign.abi.SharedUtils.SimpleVaArg;\n-import static jdk.internal.foreign.abi.SharedUtils.THROWING_ALLOCATOR;\n-\n-\/\/ See https:\/\/software.intel.com\/sites\/default\/files\/article\/402129\/mpx-linux64-abi.pdf \"3.5.7 Variable Argument Lists\"\n-public non-sealed class SysVVaList implements VaList {\n-\n-\/\/    struct typedef __va_list_tag __va_list_tag {\n-\/\/        unsigned int               gp_offset;            \/*     0     4 *\/\n-\/\/        unsigned int               fp_offset;            \/*     4     4 *\/\n-\/\/        void *                     overflow_arg_area;    \/*     8     8 *\/\n-\/\/        void *                     reg_save_area;        \/*    16     8 *\/\n-\/\/\n-\/\/        \/* size: 24, cachelines: 1, members: 4 *\/\n-\/\/        \/* last cacheline: 24 bytes *\/\n-\/\/    };\n-    static final GroupLayout LAYOUT = MemoryLayout.structLayout(\n-        SysV.C_INT.withName(\"gp_offset\"),\n-        SysV.C_INT.withName(\"fp_offset\"),\n-        SysV.C_POINTER.withName(\"overflow_arg_area\"),\n-        SysV.C_POINTER.withName(\"reg_save_area\")\n-    ).withName(\"__va_list_tag\");\n-\n-    private static final long STACK_SLOT_SIZE = 8;\n-\n-    private static final MemoryLayout GP_REG = MemoryLayout.paddingLayout(64).withBitAlignment(64);\n-    private static final MemoryLayout FP_REG = MemoryLayout.paddingLayout(128).withBitAlignment(128);\n-\n-    private static final GroupLayout LAYOUT_REG_SAVE_AREA = MemoryLayout.structLayout(\n-        GP_REG.withName(\"%rdi\"),\n-        GP_REG.withName(\"%rsi\"),\n-        GP_REG.withName(\"%rdx\"),\n-        GP_REG.withName(\"%rcx\"),\n-        GP_REG.withName(\"%r8\"),\n-        GP_REG.withName(\"%r9\"),\n-        FP_REG.withName(\"%xmm0\"),\n-        FP_REG.withName(\"%xmm1\"),\n-        FP_REG.withName(\"%xmm2\"),\n-        FP_REG.withName(\"%xmm3\"),\n-        FP_REG.withName(\"%xmm4\"),\n-        FP_REG.withName(\"%xmm5\"),\n-        FP_REG.withName(\"%xmm6\"),\n-        FP_REG.withName(\"%xmm7\")\n-\/\/ specification and implementation differ as to whether the following are part of a reg save area\n-\/\/ Let's go with the implementation, since then it actually works :)\n-\/\/        FP_REG.withName(\"%xmm8\"),\n-\/\/        FP_REG.withName(\"%xmm9\"),\n-\/\/        FP_REG.withName(\"%xmm10\"),\n-\/\/        FP_REG.withName(\"%xmm11\"),\n-\/\/        FP_REG.withName(\"%xmm12\"),\n-\/\/        FP_REG.withName(\"%xmm13\"),\n-\/\/        FP_REG.withName(\"%xmm14\"),\n-\/\/        FP_REG.withName(\"%xmm15\")\n-    );\n-\n-    private static final long FP_OFFSET = LAYOUT_REG_SAVE_AREA.byteOffset(groupElement(\"%xmm0\"));\n-\n-    private static final int GP_SLOT_SIZE = (int) GP_REG.byteSize();\n-    private static final int FP_SLOT_SIZE = (int) FP_REG.byteSize();\n-\n-    private static final int MAX_GP_OFFSET = (int) FP_OFFSET; \/\/ 6 regs used\n-    private static final int MAX_FP_OFFSET = (int) LAYOUT_REG_SAVE_AREA.byteSize(); \/\/ 8 16 byte regs\n-\n-    private static final VarHandle VH_fp_offset = LAYOUT.varHandle(groupElement(\"fp_offset\"));\n-    private static final VarHandle VH_gp_offset = LAYOUT.varHandle(groupElement(\"gp_offset\"));\n-    private static final VarHandle VH_overflow_arg_area = LAYOUT.varHandle(groupElement(\"overflow_arg_area\"));\n-    private static final VarHandle VH_reg_save_area = LAYOUT.varHandle(groupElement(\"reg_save_area\"));\n-\n-    private static final VaList EMPTY = new SharedUtils.EmptyVaList(emptyListAddress());\n-\n-    private final MemorySegment segment;\n-    private MemorySegment overflowArgArea;\n-    private final MemorySegment regSaveArea;\n-    private final long gpLimit;\n-    private final long fpLimit;\n-\n-    private SysVVaList(MemorySegment segment,\n-                       MemorySegment overflowArgArea,\n-                       MemorySegment regSaveArea, long gpLimit, long fpLimit) {\n-        this.segment = segment;\n-        this.overflowArgArea = overflowArgArea;\n-        this.regSaveArea = regSaveArea;\n-        this.gpLimit = gpLimit;\n-        this.fpLimit = fpLimit;\n-    }\n-\n-    private static SysVVaList readFromAddress(long address, SegmentScope scope) {\n-        MemorySegment segment = MemorySegment.ofAddress(address, LAYOUT.byteSize(), scope);\n-        MemorySegment regSaveArea = getRegSaveArea(segment);\n-        MemorySegment overflowArgArea = getArgOverflowArea(segment);\n-        return new SysVVaList(segment, overflowArgArea, regSaveArea, MAX_GP_OFFSET, MAX_FP_OFFSET);\n-    }\n-\n-    private static MemorySegment emptyListAddress() {\n-        MemorySegment base = MemorySegment.allocateNative(LAYOUT, SegmentScope.auto());\n-        VH_gp_offset.set(base, MAX_GP_OFFSET);\n-        VH_fp_offset.set(base, MAX_FP_OFFSET);\n-        VH_overflow_arg_area.set(base, MemorySegment.NULL);\n-        VH_reg_save_area.set(base, MemorySegment.NULL);\n-        return base.asSlice(0, 0);\n-    }\n-\n-    public static VaList empty() {\n-        return EMPTY;\n-    }\n-\n-    private int currentGPOffset() {\n-        return (int) VH_gp_offset.get(segment);\n-    }\n-\n-    private void currentGPOffset(int i) {\n-        VH_gp_offset.set(segment, i);\n-    }\n-\n-    private int currentFPOffset() {\n-        return (int) VH_fp_offset.get(segment);\n-    }\n-\n-    private void currentFPOffset(int i) {\n-        VH_fp_offset.set(segment, i);\n-    }\n-\n-    private static MemorySegment getRegSaveArea(MemorySegment segment) {\n-        return ((MemorySegment)VH_reg_save_area.get(segment))\n-                .asSlice(0, LAYOUT_REG_SAVE_AREA.byteSize());\n-    }\n-\n-    private static MemorySegment getArgOverflowArea(MemorySegment segment) {\n-        return (MemorySegment)VH_overflow_arg_area.get(segment); \/\/ size unknown\n-    }\n-\n-    private long preAlignOffset(MemoryLayout layout) {\n-        long alignmentOffset = 0;\n-        if (layout.byteAlignment() > STACK_SLOT_SIZE) {\n-            long addr = overflowArgArea.address();\n-            alignmentOffset = Utils.alignUp(addr, 16) - addr;\n-        }\n-        return alignmentOffset;\n-    }\n-\n-    private void setOverflowArgArea(MemorySegment newSegment) {\n-        overflowArgArea = newSegment;\n-        VH_overflow_arg_area.set(segment, overflowArgArea);\n-    }\n-\n-    private void preAlignStack(MemoryLayout layout) {\n-        setOverflowArgArea(overflowArgArea.asSlice(preAlignOffset(layout)));\n-    }\n-\n-    private void postAlignStack(MemoryLayout layout) {\n-        setOverflowArgArea(overflowArgArea.asSlice(Utils.alignUp(layout.byteSize(), STACK_SLOT_SIZE)));\n-    }\n-\n-    @Override\n-    public int nextVarg(ValueLayout.OfInt layout) {\n-        return (int) read(layout);\n-    }\n-\n-    @Override\n-    public long nextVarg(ValueLayout.OfLong layout) {\n-        return (long) read(layout);\n-    }\n-\n-    @Override\n-    public double nextVarg(ValueLayout.OfDouble layout) {\n-        return (double) read(layout);\n-    }\n-\n-    @Override\n-    public MemorySegment nextVarg(ValueLayout.OfAddress layout) {\n-        return (MemorySegment) read(layout);\n-    }\n-\n-    @Override\n-    public MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator) {\n-        Objects.requireNonNull(allocator);\n-        return (MemorySegment) read(layout, allocator);\n-    }\n-\n-    private Object read(MemoryLayout layout) {\n-        return read(layout, THROWING_ALLOCATOR);\n-    }\n-\n-    private Object read(MemoryLayout layout, SegmentAllocator allocator) {\n-        Objects.requireNonNull(layout);\n-        TypeClass typeClass = TypeClass.classifyLayout(layout);\n-        if (isRegOverflow(currentGPOffset(), currentFPOffset(), typeClass)\n-                || typeClass.inMemory()) {\n-            checkStackElement(layout);\n-            preAlignStack(layout);\n-            return switch (typeClass.kind()) {\n-                case STRUCT -> {\n-                    MemorySegment slice = overflowArgArea.asSlice(0, layout.byteSize());\n-                    MemorySegment seg = allocator.allocate(layout);\n-                    seg.copyFrom(slice);\n-                    postAlignStack(layout);\n-                    yield seg;\n-                }\n-                case POINTER, INTEGER, FLOAT -> {\n-                    VarHandle reader = layout.varHandle();\n-                    MemorySegment slice = overflowArgArea.asSlice(0, layout.byteSize());\n-                    Object res = reader.get(slice);\n-                    postAlignStack(layout);\n-                    yield res;\n-                }\n-            };\n-        } else {\n-            checkRegSaveAreaElement(layout, typeClass);\n-            return switch (typeClass.kind()) {\n-                case STRUCT -> {\n-                    MemorySegment value = allocator.allocate(layout);\n-                    int classIdx = 0;\n-                    long offset = 0;\n-                    while (offset < layout.byteSize()) {\n-                        final long copy = Math.min(layout.byteSize() - offset, 8);\n-                        boolean isSSE = typeClass.classes.get(classIdx++) == ArgumentClassImpl.SSE;\n-                        if (isSSE) {\n-                            MemorySegment.copy(regSaveArea, currentFPOffset(), value, offset, copy);\n-                            currentFPOffset(currentFPOffset() + FP_SLOT_SIZE);\n-                        } else {\n-                            MemorySegment.copy(regSaveArea, currentGPOffset(), value, offset, copy);\n-                            currentGPOffset(currentGPOffset() + GP_SLOT_SIZE);\n-                        }\n-                        offset += copy;\n-                    }\n-                    yield value;\n-                }\n-                case POINTER, INTEGER -> {\n-                    VarHandle reader = layout.varHandle();\n-                    Object res = reader.get(regSaveArea.asSlice(currentGPOffset()));\n-                    currentGPOffset(currentGPOffset() + GP_SLOT_SIZE);\n-                    yield res;\n-                }\n-                case FLOAT -> {\n-                    VarHandle reader = layout.varHandle();\n-                    Object res = reader.get(regSaveArea.asSlice(currentFPOffset()));\n-                    currentFPOffset(currentFPOffset() + FP_SLOT_SIZE);\n-                    yield res;\n-                }\n-            };\n-        }\n-    }\n-\n-    private void checkRegSaveAreaElement(MemoryLayout layout, TypeClass typeClass) {\n-        long gpSize = typeClass.nIntegerRegs() * GP_SLOT_SIZE;\n-        long fpSize = typeClass.nVectorRegs() * FP_SLOT_SIZE;\n-        if (currentGPOffset() + gpSize > gpLimit\n-            || currentFPOffset() + fpSize > fpLimit) {\n-            throw SharedUtils.newVaListNSEE(layout);\n-        }\n-    }\n-\n-    private void checkStackElement(MemoryLayout layout) {\n-        long offset = preAlignOffset(layout);\n-        if (offset + layout.byteSize() > overflowArgArea.byteSize()) {\n-            throw SharedUtils.newVaListNSEE(layout);\n-        }\n-    }\n-\n-    @Override\n-    public void skip(MemoryLayout... layouts) {\n-        Objects.requireNonNull(layouts);\n-        ((MemorySessionImpl) segment.scope()).checkValidState();\n-        for (MemoryLayout layout : layouts) {\n-            Objects.requireNonNull(layout);\n-            TypeClass typeClass = TypeClass.classifyLayout(layout);\n-            if (isRegOverflow(currentGPOffset(), currentFPOffset(), typeClass)) {\n-                checkStackElement(layout);\n-                preAlignStack(layout);\n-                postAlignStack(layout);\n-            } else {\n-                checkRegSaveAreaElement(layout, typeClass);\n-                currentGPOffset(currentGPOffset() + (((int) typeClass.nIntegerRegs()) * GP_SLOT_SIZE));\n-                currentFPOffset(currentFPOffset() + (((int) typeClass.nVectorRegs()) * FP_SLOT_SIZE));\n-            }\n-        }\n-    }\n-\n-    static SysVVaList.Builder builder(SegmentScope scope) {\n-        return new SysVVaList.Builder(scope);\n-    }\n-\n-    public static VaList ofAddress(long address, SegmentScope scope) {\n-        return readFromAddress(address, scope);\n-    }\n-\n-    @Override\n-    public VaList copy() {\n-        MemorySegment copy = MemorySegment.allocateNative(LAYOUT, segment.scope());\n-        copy.copyFrom(segment);\n-        return new SysVVaList(copy, overflowArgArea, regSaveArea, gpLimit, fpLimit);\n-    }\n-\n-    @Override\n-    public MemorySegment segment() {\n-        \/\/ make sure that returned segment cannot be accessed\n-        return segment.asSlice(0, 0);\n-    }\n-\n-    private static boolean isRegOverflow(long currentGPOffset, long currentFPOffset, TypeClass typeClass) {\n-        return currentGPOffset > MAX_GP_OFFSET - typeClass.nIntegerRegs() * GP_SLOT_SIZE\n-                || currentFPOffset > MAX_FP_OFFSET - typeClass.nVectorRegs() * FP_SLOT_SIZE;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"SysVVaList{\"\n-               + \"gp_offset=\" + currentGPOffset()\n-               + \", fp_offset=\" + currentFPOffset()\n-               + \", overflow_arg_area=\" + overflowArgArea\n-               + \", reg_save_area=\" + regSaveArea\n-               + '}';\n-    }\n-\n-    public static non-sealed class Builder implements VaList.Builder {\n-        private final SegmentScope scope;\n-        private final MemorySegment reg_save_area;\n-        private long currentGPOffset = 0;\n-        private long currentFPOffset = FP_OFFSET;\n-        private final List<SimpleVaArg> stackArgs = new ArrayList<>();\n-\n-        public Builder(SegmentScope scope) {\n-            this.scope = scope;\n-            this.reg_save_area = MemorySegment.allocateNative(LAYOUT_REG_SAVE_AREA, scope);\n-        }\n-\n-        @Override\n-        public Builder addVarg(ValueLayout.OfInt layout, int value) {\n-            return arg(layout, value);\n-        }\n-\n-        @Override\n-        public Builder addVarg(ValueLayout.OfLong layout, long value) {\n-            return arg(layout, value);\n-        }\n-\n-        @Override\n-        public Builder addVarg(ValueLayout.OfDouble layout, double value) {\n-            return arg(layout, value);\n-        }\n-\n-        @Override\n-        public Builder addVarg(ValueLayout.OfAddress layout, MemorySegment value) {\n-            return arg(layout, value);\n-        }\n-\n-        @Override\n-        public Builder addVarg(GroupLayout layout, MemorySegment value) {\n-            return arg(layout, value);\n-        }\n-\n-        private Builder arg(MemoryLayout layout, Object value) {\n-            Objects.requireNonNull(layout);\n-            Objects.requireNonNull(value);\n-            TypeClass typeClass = TypeClass.classifyLayout(layout);\n-            if (isRegOverflow(currentGPOffset, currentFPOffset, typeClass)\n-                    || typeClass.inMemory()) {\n-                \/\/ stack it!\n-                stackArgs.add(new SimpleVaArg(layout, value));\n-            } else {\n-                switch (typeClass.kind()) {\n-                    case STRUCT -> {\n-                        MemorySegment valueSegment = (MemorySegment) value;\n-                        int classIdx = 0;\n-                        long offset = 0;\n-                        while (offset < layout.byteSize()) {\n-                            final long copy = Math.min(layout.byteSize() - offset, 8);\n-                            boolean isSSE = typeClass.classes.get(classIdx++) == ArgumentClassImpl.SSE;\n-                            if (isSSE) {\n-                                MemorySegment.copy(valueSegment, offset, reg_save_area, currentFPOffset, copy);\n-                                currentFPOffset += FP_SLOT_SIZE;\n-                            } else {\n-                                MemorySegment.copy(valueSegment, offset, reg_save_area, currentGPOffset, copy);\n-                                currentGPOffset += GP_SLOT_SIZE;\n-                            }\n-                            offset += copy;\n-                        }\n-                    }\n-                    case POINTER, INTEGER -> {\n-                        VarHandle writer = layout.varHandle();\n-                        writer.set(reg_save_area.asSlice(currentGPOffset), value);\n-                        currentGPOffset += GP_SLOT_SIZE;\n-                    }\n-                    case FLOAT -> {\n-                        VarHandle writer = layout.varHandle();\n-                        writer.set(reg_save_area.asSlice(currentFPOffset), value);\n-                        currentFPOffset += FP_SLOT_SIZE;\n-                    }\n-                }\n-            }\n-            return this;\n-        }\n-\n-        private boolean isEmpty() {\n-            return currentGPOffset == 0 && currentFPOffset == FP_OFFSET && stackArgs.isEmpty();\n-        }\n-\n-        public VaList build() {\n-            if (isEmpty()) {\n-                return EMPTY;\n-            }\n-\n-            MemorySegment vaListSegment = MemorySegment.allocateNative(LAYOUT, scope);\n-            MemorySegment stackArgsSegment;\n-            if (!stackArgs.isEmpty()) {\n-                long stackArgsSize = stackArgs.stream().reduce(0L,\n-                        (acc, e) -> acc + Utils.alignUp(e.layout.byteSize(), STACK_SLOT_SIZE), Long::sum);\n-                stackArgsSegment = MemorySegment.allocateNative(stackArgsSize, 16, scope);\n-                MemorySegment writeCursor = stackArgsSegment;\n-                for (SimpleVaArg arg : stackArgs) {\n-                    if (arg.layout.byteSize() > 8) {\n-                        writeCursor = Utils.alignUp(writeCursor, Math.min(16, arg.layout.byteSize()));\n-                    }\n-                    if (arg.layout instanceof GroupLayout) {\n-                        writeCursor.copyFrom((MemorySegment) arg.value);\n-                    } else {\n-                        VarHandle writer = arg.varHandle();\n-                        writer.set(writeCursor, arg.value);\n-                    }\n-                    writeCursor = writeCursor.asSlice(Utils.alignUp(arg.layout.byteSize(), STACK_SLOT_SIZE));\n-                }\n-            } else {\n-                stackArgsSegment = MemorySegment.NULL;\n-            }\n-\n-            VH_fp_offset.set(vaListSegment, (int) FP_OFFSET);\n-            VH_overflow_arg_area.set(vaListSegment, stackArgsSegment);\n-            VH_reg_save_area.set(vaListSegment, reg_save_area);\n-            assert MemorySessionImpl.sameOwnerThread(reg_save_area.scope(), vaListSegment.scope());\n-            return new SysVVaList(vaListSegment, stackArgsSegment, reg_save_area, currentGPOffset, currentFPOffset);\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":0,"deletions":479,"binary":false,"changes":479,"status":"deleted"},{"patch":"@@ -34,1 +34,0 @@\n-import java.lang.foreign.VaList;\n@@ -65,14 +64,0 @@\n-\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, SegmentScope scope) {\n-        SysVVaList.Builder builder = SysVVaList.builder(scope);\n-        actions.accept(builder);\n-        return builder.build();\n-    }\n-\n-    public static VaList newVaListOfAddress(long address, SegmentScope scope) {\n-        return SysVVaList.ofAddress(address, scope);\n-    }\n-\n-    public static VaList emptyVaList() {\n-        return SysVVaList.empty();\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1,246 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-package jdk.internal.foreign.abi.x64.windows;\n-\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.SegmentAllocator;\n-import java.lang.foreign.VaList;\n-import java.lang.foreign.ValueLayout;\n-\n-import jdk.internal.foreign.MemorySessionImpl;\n-import jdk.internal.foreign.abi.SharedUtils;\n-import jdk.internal.foreign.abi.SharedUtils.SimpleVaArg;\n-\n-import java.lang.invoke.VarHandle;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n-\n-import static jdk.internal.foreign.PlatformLayouts.Win64.C_POINTER;\n-\n-\/\/ see vadefs.h (VC header)\n-\/\/\n-\/\/ in short\n-\/\/ -> va_list is just a pointer to a buffer with 64 bit entries.\n-\/\/ -> non-power-of-two-sized, or larger than 64 bit types passed by reference.\n-\/\/ -> other types passed in 64 bit slots by normal function calling convention.\n-\/\/\n-\/\/ X64 va_arg impl:\n-\/\/\n-\/\/    typedef char* va_list;\n-\/\/\n-\/\/    #define __crt_va_arg(ap, t)                                               \\\n-\/\/        ((sizeof(t) > sizeof(__int64) || (sizeof(t) & (sizeof(t) - 1)) != 0) \\\n-\/\/            ? **(t**)((ap += sizeof(__int64)) - sizeof(__int64))             \\\n-\/\/            :  *(t* )((ap += sizeof(__int64)) - sizeof(__int64)))\n-\/\/\n-public non-sealed class WinVaList implements VaList {\n-    private static final long VA_SLOT_SIZE_BYTES = 8;\n-    private static final VarHandle VH_address = C_POINTER.varHandle();\n-\n-    private static final VaList EMPTY = new SharedUtils.EmptyVaList(MemorySegment.NULL);\n-\n-    private MemorySegment segment;\n-\n-    private WinVaList(MemorySegment segment) {\n-        this.segment = segment;\n-    }\n-\n-    public static final VaList empty() {\n-        return EMPTY;\n-    }\n-\n-    @Override\n-    public int nextVarg(ValueLayout.OfInt layout) {\n-        return (int) read(layout);\n-    }\n-\n-    @Override\n-    public long nextVarg(ValueLayout.OfLong layout) {\n-        return (long) read(layout);\n-    }\n-\n-    @Override\n-    public double nextVarg(ValueLayout.OfDouble layout) {\n-        return (double) read(layout);\n-    }\n-\n-    @Override\n-    public MemorySegment nextVarg(ValueLayout.OfAddress layout) {\n-        return (MemorySegment) read(layout);\n-    }\n-\n-    @Override\n-    public MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator) {\n-        Objects.requireNonNull(allocator);\n-        return (MemorySegment) read(layout, allocator);\n-    }\n-\n-    private Object read(MemoryLayout layout) {\n-        return read(layout, SharedUtils.THROWING_ALLOCATOR);\n-    }\n-\n-    private Object read(MemoryLayout layout, SegmentAllocator allocator) {\n-        Objects.requireNonNull(layout);\n-        Object res;\n-        checkElement(layout);\n-        if (layout instanceof GroupLayout) {\n-            TypeClass typeClass = TypeClass.typeClassFor(layout, false);\n-            res = switch (typeClass) {\n-                case STRUCT_REFERENCE -> {\n-                    MemorySegment structAddr = (MemorySegment) VH_address.get(segment);\n-                    MemorySegment struct = MemorySegment.ofAddress(structAddr.address(), layout.byteSize(), segment.scope());\n-                    MemorySegment seg = allocator.allocate(layout);\n-                    seg.copyFrom(struct);\n-                    yield seg;\n-                }\n-                case STRUCT_REGISTER ->\n-                    allocator.allocate(layout).copyFrom(segment.asSlice(0, layout.byteSize()));\n-                default -> throw new IllegalStateException(\"Unexpected TypeClass: \" + typeClass);\n-            };\n-        } else {\n-            VarHandle reader = layout.varHandle();\n-            res = reader.get(segment);\n-        }\n-        segment = segment.asSlice(VA_SLOT_SIZE_BYTES);\n-        return res;\n-    }\n-\n-    private void checkElement(MemoryLayout layout) {\n-        if (segment.byteSize() < VA_SLOT_SIZE_BYTES) {\n-            throw SharedUtils.newVaListNSEE(layout);\n-        }\n-    }\n-\n-    @Override\n-    public void skip(MemoryLayout... layouts) {\n-        Objects.requireNonNull(layouts);\n-        ((MemorySessionImpl) segment.scope()).checkValidState();\n-        for (MemoryLayout layout : layouts) {\n-            Objects.requireNonNull(layout);\n-            checkElement(layout);\n-            segment = segment.asSlice(VA_SLOT_SIZE_BYTES);\n-        }\n-    }\n-\n-    static WinVaList ofAddress(long address, SegmentScope scope) {\n-        return new WinVaList(MemorySegment.ofAddress(address, Long.MAX_VALUE, scope));\n-    }\n-\n-    static Builder builder(SegmentScope scope) {\n-        return new Builder(scope);\n-    }\n-\n-    @Override\n-    public VaList copy() {\n-        ((MemorySessionImpl) segment.scope()).checkValidState();\n-        return new WinVaList(segment);\n-    }\n-\n-    @Override\n-    public MemorySegment segment() {\n-        \/\/ make sure that returned segment cannot be accessed\n-        return segment.asSlice(0, 0);\n-    }\n-\n-    public static non-sealed class Builder implements VaList.Builder {\n-\n-        private final SegmentScope scope;\n-        private final List<SimpleVaArg> args = new ArrayList<>();\n-\n-        public Builder(SegmentScope scope) {\n-            ((MemorySessionImpl) scope).checkValidState();\n-            this.scope = scope;\n-        }\n-\n-        private Builder arg(MemoryLayout layout, Object value) {\n-            Objects.requireNonNull(layout);\n-            Objects.requireNonNull(value);\n-            args.add(new SimpleVaArg(layout, value));\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder addVarg(ValueLayout.OfInt layout, int value) {\n-            return arg(layout, value);\n-        }\n-\n-        @Override\n-        public Builder addVarg(ValueLayout.OfLong layout, long value) {\n-            return arg(layout, value);\n-        }\n-\n-        @Override\n-        public Builder addVarg(ValueLayout.OfDouble layout, double value) {\n-            return arg(layout, value);\n-        }\n-\n-        @Override\n-        public Builder addVarg(ValueLayout.OfAddress layout, MemorySegment value) {\n-            return arg(layout, value);\n-        }\n-\n-        @Override\n-        public Builder addVarg(GroupLayout layout, MemorySegment value) {\n-            return arg(layout, value);\n-        }\n-\n-        public VaList build() {\n-            if (args.isEmpty()) {\n-                return EMPTY;\n-            }\n-\n-            MemorySegment segment = MemorySegment.allocateNative(VA_SLOT_SIZE_BYTES * args.size(), scope);\n-            MemorySegment cursor = segment;\n-\n-            for (SimpleVaArg arg : args) {\n-                if (arg.layout instanceof GroupLayout) {\n-                    MemorySegment msArg = ((MemorySegment) arg.value);\n-                    TypeClass typeClass = TypeClass.typeClassFor(arg.layout, false);\n-                    switch (typeClass) {\n-                        case STRUCT_REFERENCE -> {\n-                            MemorySegment copy = MemorySegment.allocateNative(arg.layout, scope);\n-                            copy.copyFrom(msArg); \/\/ by-value\n-                            VH_address.set(cursor, copy);\n-                        }\n-                        case STRUCT_REGISTER ->\n-                            cursor.copyFrom(msArg.asSlice(0, VA_SLOT_SIZE_BYTES));\n-                        default -> throw new IllegalStateException(\"Unexpected TypeClass: \" + typeClass);\n-                    }\n-                } else {\n-                    VarHandle writer = arg.varHandle();\n-                    writer.set(cursor, arg.value);\n-                }\n-                cursor = cursor.asSlice(VA_SLOT_SIZE_BYTES);\n-            }\n-\n-            return new WinVaList(segment);\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":0,"deletions":246,"binary":false,"changes":246,"status":"deleted"},{"patch":"@@ -33,1 +33,0 @@\n-import java.lang.foreign.VaList;\n@@ -64,14 +63,0 @@\n-\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, SegmentScope scope) {\n-        WinVaList.Builder builder = WinVaList.builder(scope);\n-        actions.accept(builder);\n-        return builder.build();\n-    }\n-\n-    public static VaList newVaListOfAddress(long address, SegmentScope scope) {\n-        return WinVaList.ofAddress(address, scope);\n-    }\n-\n-    public static VaList emptyVaList() {\n-        return WinVaList.empty();\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-import java.lang.foreign.VaList;\n@@ -115,14 +114,0 @@\n-    @Test(expectedExceptions = IllegalStateException.class)\n-    public void testClosedVaList() throws Throwable {\n-        VaList list;\n-        try (Arena arena = Arena.openConfined()) {\n-            list = VaList.make(b -> b.addVarg(C_INT, 42), arena.scope());\n-        }\n-        assertFalse(list.segment().scope().isAlive());\n-        MethodHandle handle = Linker.nativeLinker().downcallHandle(\n-                findNativeOrThrow(\"addr_func\"),\n-                FunctionDescriptor.ofVoid(C_POINTER));\n-\n-        handle.invokeExact(list.segment());\n-    }\n-\n@@ -146,12 +131,0 @@\n-    @Test\n-    public void testClosedVaListCallback() throws Throwable {\n-        MethodHandle handle = Linker.nativeLinker().downcallHandle(\n-                findNativeOrThrow(\"addr_func_cb\"),\n-                FunctionDescriptor.ofVoid(C_POINTER, C_POINTER));\n-\n-        try (Arena arena = Arena.openConfined()) {\n-            VaList list = VaList.make(b -> b.addVarg(C_INT, 42), arena.scope());\n-            handle.invokeExact(list.segment(), sessionChecker(arena));\n-        }\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/SafeFunctionAccessTest.java","additions":0,"deletions":27,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-import java.util.function.BiConsumer;\n@@ -138,15 +137,0 @@\n-    @Test(dataProvider = \"printfArgs\")\n-    void test_vprintf(List<PrintfArg> args) throws Throwable {\n-        String formatArgs = args.stream()\n-                .map(a -> a.format)\n-                .collect(Collectors.joining(\",\"));\n-\n-        String formatString = \"hello(\" + formatArgs + \")\\n\";\n-\n-        String expected = String.format(formatString, args.stream()\n-                .map(a -> a.javaValue).toArray());\n-\n-        int found = stdLibHelper.vprintf(formatString, args);\n-        assertEquals(found, expected.length());\n-    }\n-\n@@ -308,8 +292,0 @@\n-        int vprintf(String format, List<PrintfArg> args) throws Throwable {\n-            try (var arena = Arena.openConfined()) {\n-                MemorySegment formatStr = arena.allocateUtf8String(format);\n-                VaList vaList = VaList.make(b -> args.forEach(a -> a.accept(b, arena)), arena.scope());\n-                return (int)vprintf.invokeExact(formatStr, vaList.segment());\n-            }\n-        }\n-\n@@ -387,1 +363,1 @@\n-    enum PrintfArg implements BiConsumer<VaList.Builder, Arena> {\n+    enum PrintfArg {\n@@ -389,1 +365,1 @@\n-        INTEGRAL(int.class, C_INT, \"%d\", arena -> 42, 42, VaList.Builder::addVarg),\n+        INTEGRAL(int.class, C_INT, \"%d\", arena -> 42, 42),\n@@ -392,3 +368,3 @@\n-        }, \"str\", VaList.Builder::addVarg),\n-        CHAR(byte.class, C_CHAR, \"%c\", arena -> (byte) 'h', 'h', (builder, layout, value) -> builder.addVarg(C_INT, (int)value)),\n-        DOUBLE(double.class, C_DOUBLE, \"%.4f\", arena ->1.2345d, 1.2345d, VaList.Builder::addVarg);\n+        }, \"str\"),\n+        CHAR(byte.class, C_CHAR, \"%c\", arena -> (byte) 'h', 'h'),\n+        DOUBLE(double.class, C_DOUBLE, \"%.4f\", arena ->1.2345d, 1.2345d);\n@@ -401,2 +377,0 @@\n-        @SuppressWarnings(\"rawtypes\")\n-        final VaListBuilderCall builderCall;\n@@ -404,1 +378,1 @@\n-        <Z, L extends ValueLayout> PrintfArg(Class<?> carrier, L layout, String format, Function<Arena, Z> nativeValueFactory, Object javaValue, VaListBuilderCall<Z, L> builderCall) {\n+        <Z, L extends ValueLayout> PrintfArg(Class<?> carrier, L layout, String format, Function<Arena, Z> nativeValueFactory, Object javaValue) {\n@@ -410,11 +384,0 @@\n-            this.builderCall = builderCall;\n-        }\n-\n-        @Override\n-        @SuppressWarnings(\"unchecked\")\n-        public void accept(VaList.Builder builder, Arena arena) {\n-            builderCall.build(builder, layout, nativeValueFactory.apply(arena));\n-        }\n-\n-        interface VaListBuilderCall<V, L> {\n-            void build(VaList.Builder builder, L layout, V value);\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":6,"deletions":43,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-import java.util.concurrent.atomic.AtomicReference;\n@@ -101,2 +100,0 @@\n-            VaList.class,\n-            VaList.Builder.class,\n@@ -184,2 +181,0 @@\n-        addDefaultMapping(VaList.class, VaListHelper.vaList);\n-        addDefaultMapping(VaList.Builder.class, VaListHelper.vaListBuilder);\n@@ -193,14 +188,0 @@\n-    static class VaListHelper {\n-        static final VaList vaList;\n-        static final VaList.Builder vaListBuilder;\n-\n-        static {\n-            AtomicReference<VaList.Builder> builderRef = new AtomicReference<>();\n-            vaList = VaList.make(b -> {\n-                builderRef.set(b);\n-                b.addVarg(JAVA_LONG, 42L);\n-            }, SegmentScope.auto());\n-            vaListBuilder = builderRef.get();\n-        }\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.foreign.MemoryLayout;\n@@ -36,1 +35,0 @@\n-import java.lang.foreign.VaList;\n@@ -122,2 +120,0 @@\n-        ScopedOperation.ofScope(session -> VaList.make(b -> b.addVarg(JAVA_INT, 42), session), \"VaList::make\");\n-        ScopedOperation.ofScope(session -> VaList.ofAddress(42, session), \"VaList::make\");\n@@ -129,9 +125,0 @@\n-        \/\/ valist operations\n-        ScopedOperation.ofVaList(VaList::copy, \"VaList::copy\");\n-        ScopedOperation.ofVaList(list -> list.nextVarg(ValueLayout.ADDRESS), \"VaList::nextVarg\/address\");\n-        ScopedOperation.ofVaList(list -> list.nextVarg(ValueLayout.JAVA_INT), \"VaList::nextVarg\/int\");\n-        ScopedOperation.ofVaList(list -> list.nextVarg(ValueLayout.JAVA_LONG), \"VaList::nextVarg\/long\");\n-        ScopedOperation.ofVaList(list -> list.nextVarg(ValueLayout.JAVA_DOUBLE), \"VaList::nextVarg\/double\");\n-        ScopedOperation.ofVaList(VaList::skip, \"VaList::skip\");\n-        ScopedOperation.ofVaList(list -> list.nextVarg(MemoryLayout.structLayout(ValueLayout.JAVA_INT),\n-                SegmentAllocator.prefixAllocator(MemorySegment.ofArray(new byte[4]))), \"VaList::nextVargs\/segment\");\n@@ -194,5 +181,0 @@\n-        static void ofVaList(Consumer<VaList> vaListConsumer, String name) {\n-            scopedOperations.add(new ScopedOperation<>(session -> VaList.make(builder -> builder.addVarg(JAVA_LONG, 42), session),\n-                    vaListConsumer, name));\n-        }\n-\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -32,3 +32,0 @@\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.VaList;\n-import java.lang.foreign.ValueLayout;\n@@ -44,15 +41,0 @@\n-\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testEmptyVaList() {\n-        VaList.empty();\n-    }\n-\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testNonEmptyVaList() {\n-        VaList.make(builder -> builder.addVarg(ValueLayout.JAVA_INT, 42), SegmentScope.auto());\n-    }\n-\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testUnsafeVaList() {\n-        VaList.ofAddress(0L, SegmentScope.auto());\n-    }\n","filename":"test\/jdk\/java\/foreign\/TestUnsupportedLinker.java","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1,910 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @enablePreview\n- * @library ..\/\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n- * @modules java.base\/jdk.internal.foreign\n- *          java.base\/jdk.internal.foreign.abi\n- *          java.base\/jdk.internal.foreign.abi.x64\n- *          java.base\/jdk.internal.foreign.abi.x64.sysv\n- *          java.base\/jdk.internal.foreign.abi.x64.windows\n- *          java.base\/jdk.internal.foreign.abi.aarch64\n- *          java.base\/jdk.internal.foreign.abi.aarch64.linux\n- *          java.base\/jdk.internal.foreign.abi.aarch64.macos\n- *          java.base\/jdk.internal.foreign.abi.aarch64.windows\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED VaListTest\n- *\/\n-\n-import java.lang.foreign.*;\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.VaList;\n-import jdk.internal.foreign.abi.aarch64.linux.LinuxAArch64Linker;\n-import jdk.internal.foreign.abi.aarch64.macos.MacOsAArch64Linker;\n-import jdk.internal.foreign.abi.x64.sysv.SysVx64Linker;\n-import jdk.internal.foreign.abi.x64.windows.Windowsx64Linker;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandleProxies;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.invoke.VarHandle;\n-import java.util.List;\n-import java.util.NoSuchElementException;\n-import java.util.function.BiFunction;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-import java.util.stream.DoubleStream;\n-import java.util.stream.IntStream;\n-\n-import static java.lang.foreign.MemoryLayout.PathElement.groupElement;\n-import static java.lang.foreign.ValueLayout.ADDRESS;\n-import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-import static java.lang.foreign.ValueLayout.JAVA_LONG;\n-import static jdk.internal.foreign.PlatformLayouts.*;\n-import static org.testng.Assert.*;\n-\n-public class VaListTest extends NativeTestHelper {\n-\n-    private static final Linker abi = Linker.nativeLinker();\n-    static {\n-        System.loadLibrary(\"VaList\");\n-    }\n-\n-    private static final MethodHandle VALIST_TO_ADDRESS;\n-    private static final MethodHandle SEGMENT_TO_VALIST;\n-\n-    static {\n-        try {\n-            VALIST_TO_ADDRESS = MethodHandles.lookup().findVirtual(VaList.class, \"segment\", MethodType.methodType(MemorySegment.class));\n-            SEGMENT_TO_VALIST = MethodHandles.lookup().findStatic(VaListTest.class, \"segmentToValist\", MethodType.methodType(VaList.class, MemorySegment.class));\n-        } catch (Throwable ex) {\n-            throw new ExceptionInInitializerError(ex);\n-        }\n-    }\n-\n-\n-    private static final MethodHandle MH_sumInts = linkVaList(\"sumInts\",\n-            FunctionDescriptor.of(C_INT, C_INT, C_POINTER));\n-    private static final MethodHandle MH_sumDoubles = linkVaList(\"sumDoubles\",\n-            FunctionDescriptor.of(C_DOUBLE, C_INT, C_POINTER));\n-    private static final MethodHandle MH_getInt = linkVaList(\"getInt\",\n-            FunctionDescriptor.of(C_INT, C_POINTER));\n-    private static final MethodHandle MH_sumStruct = linkVaList(\"sumStruct\",\n-            FunctionDescriptor.of(C_INT, C_POINTER));\n-    private static final MethodHandle MH_sumBigStruct = linkVaList(\"sumBigStruct\",\n-            FunctionDescriptor.of(C_LONG_LONG, C_POINTER));\n-    private static final MethodHandle MH_sumHugeStruct = linkVaList(\"sumHugeStruct\",\n-            FunctionDescriptor.of(C_LONG_LONG, C_POINTER));\n-    private static final MethodHandle MH_sumFloatStruct = linkVaList(\"sumFloatStruct\",\n-            FunctionDescriptor.of(C_FLOAT, C_POINTER));\n-    private static final MethodHandle MH_sumStack = linkVaList(\"sumStack\",\n-            FunctionDescriptor.ofVoid(C_POINTER, C_POINTER, C_POINTER));\n-\n-    private static MethodHandle link(String symbol, FunctionDescriptor fd) {\n-        return linkInternal(symbol, fd);\n-    }\n-\n-    private static MethodHandle linkVaList(String symbol, FunctionDescriptor fd) {\n-        return MethodHandles.filterArguments(linkInternal(symbol, fd), fd.argumentLayouts().size() - 1, VALIST_TO_ADDRESS);\n-    }\n-\n-\n-    private static MethodHandle linkInternal(String symbol, FunctionDescriptor fd) {\n-        return abi.downcallHandle(findNativeOrThrow(symbol), fd);\n-    }\n-\n-    private static MethodHandle linkVaListCB(String symbol) {\n-        return link(symbol,\n-                FunctionDescriptor.ofVoid(C_POINTER));\n-\n-    }\n-\n-    private static final Function<Consumer<VaList.Builder>, VaList> winVaListFactory\n-            = actions -> Windowsx64Linker.newVaList(actions, SegmentScope.auto());\n-    private static final Function<Consumer<VaList.Builder>, VaList> sysvVaListFactory\n-            = actions -> SysVx64Linker.newVaList(actions, SegmentScope.auto());\n-    private static final Function<Consumer<VaList.Builder>, VaList> linuxAArch64VaListFactory\n-            = actions -> LinuxAArch64Linker.newVaList(actions, SegmentScope.auto());\n-    private static final Function<Consumer<VaList.Builder>, VaList> macAArch64VaListFactory\n-            = actions -> MacOsAArch64Linker.newVaList(actions, SegmentScope.auto());\n-    private static final Function<Consumer<VaList.Builder>, VaList> platformVaListFactory\n-            = (builder) -> VaList.make(builder, SegmentScope.auto());\n-\n-    private static final BiFunction<Consumer<VaList.Builder>, SegmentScope, VaList> winVaListScopedFactory\n-            = Windowsx64Linker::newVaList;\n-    private static final BiFunction<Consumer<VaList.Builder>, SegmentScope, VaList> sysvVaListScopedFactory\n-            = SysVx64Linker::newVaList;\n-    private static final BiFunction<Consumer<VaList.Builder>, SegmentScope, VaList> linuxAArch64VaListScopedFactory\n-            = LinuxAArch64Linker::newVaList;\n-    private static final BiFunction<Consumer<VaList.Builder>, SegmentScope, VaList> macAArch64VaListScopedFactory\n-            = MacOsAArch64Linker::newVaList;\n-    private static final BiFunction<Consumer<VaList.Builder>, SegmentScope, VaList> platformVaListScopedFactory\n-            = VaList::make;\n-\n-    @DataProvider\n-    @SuppressWarnings(\"unchecked\")\n-    public static Object[][] sumInts() {\n-        Function<ValueLayout.OfInt, BiFunction<Integer, VaList, Integer>> sumIntsJavaFact = layout ->\n-                (num, list) -> IntStream.generate(() -> list.nextVarg(layout)).limit(num).sum();\n-        BiFunction<Integer, VaList, Integer> sumIntsNative\n-                = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumInts);\n-        return new Object[][]{\n-                { winVaListFactory,          sumIntsJavaFact.apply(Win64.C_INT),   Win64.C_INT   },\n-                { sysvVaListFactory,         sumIntsJavaFact.apply(SysV.C_INT),    SysV.C_INT    },\n-                { linuxAArch64VaListFactory, sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },\n-                { macAArch64VaListFactory,   sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },\n-                { platformVaListFactory,     sumIntsNative,                        C_INT         },\n-        };\n-    }\n-\n-    @Test(dataProvider = \"sumInts\")\n-    public void testIntSum(Function<Consumer<VaList.Builder>, VaList> vaListFactory,\n-                           BiFunction<Integer, VaList, Integer> sumInts,\n-                           ValueLayout.OfInt intLayout) {\n-        VaList vaList = vaListFactory.apply(b ->\n-                b.addVarg(intLayout, 10)\n-                        .addVarg(intLayout, 15)\n-                        .addVarg(intLayout, 20));\n-        int x = sumInts.apply(3, vaList);\n-        assertEquals(x, 45);\n-    }\n-\n-    @DataProvider\n-    @SuppressWarnings(\"unchecked\")\n-    public static Object[][] sumDoubles() {\n-        Function<ValueLayout.OfDouble, BiFunction<Integer, VaList, Double>> sumDoublesJavaFact  = layout ->\n-                (num, list) -> DoubleStream.generate(() -> list.nextVarg(layout)).limit(num).sum();\n-        BiFunction<Integer, VaList, Double> sumDoublesNative\n-                = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumDoubles);\n-        return new Object[][]{\n-                { winVaListFactory,          sumDoublesJavaFact.apply(Win64.C_DOUBLE),   Win64.C_DOUBLE   },\n-                { sysvVaListFactory,         sumDoublesJavaFact.apply(SysV.C_DOUBLE),    SysV.C_DOUBLE    },\n-                { linuxAArch64VaListFactory, sumDoublesJavaFact.apply(AArch64.C_DOUBLE), AArch64.C_DOUBLE },\n-                { macAArch64VaListFactory,   sumDoublesJavaFact.apply(AArch64.C_DOUBLE), AArch64.C_DOUBLE },\n-                { platformVaListFactory,     sumDoublesNative,                           C_DOUBLE         },\n-        };\n-    }\n-\n-    @Test(dataProvider = \"sumDoubles\")\n-    public void testDoubleSum(Function<Consumer<VaList.Builder>, VaList> vaListFactory,\n-                              BiFunction<Integer, VaList, Double> sumDoubles,\n-                              ValueLayout.OfDouble doubleLayout) {\n-        VaList vaList = vaListFactory.apply(b ->\n-                b.addVarg(doubleLayout, 3.0D)\n-                        .addVarg(doubleLayout, 4.0D)\n-                        .addVarg(doubleLayout, 5.0D));\n-        double x = sumDoubles.apply(3, vaList);\n-        assertEquals(x, 12.0D);\n-    }\n-\n-    @DataProvider\n-    @SuppressWarnings(\"unchecked\")\n-    public static Object[][] pointers() {\n-        Function<ValueLayout.OfAddress, Function<VaList, Integer>> getIntJavaFact = layout ->\n-                list -> {\n-                    MemorySegment ma = list.nextVarg(layout);\n-                    return ma.get(JAVA_INT, 0);\n-                };\n-        Function<VaList, Integer> getIntNative = MethodHandleProxies.asInterfaceInstance(Function.class, MH_getInt);\n-        return new Object[][]{\n-                { winVaListFactory,          getIntJavaFact.apply(Win64.C_POINTER),   Win64.C_POINTER   },\n-                { sysvVaListFactory,         getIntJavaFact.apply(SysV.C_POINTER),    SysV.C_POINTER    },\n-                { linuxAArch64VaListFactory, getIntJavaFact.apply(AArch64.C_POINTER), AArch64.C_POINTER },\n-                { macAArch64VaListFactory,   getIntJavaFact.apply(AArch64.C_POINTER), AArch64.C_POINTER },\n-                { platformVaListFactory,     getIntNative,                            C_POINTER         },\n-        };\n-    }\n-\n-    @Test(dataProvider = \"pointers\")\n-    public void testVaListMemorySegment(Function<Consumer<VaList.Builder>, VaList> vaListFactory,\n-                                        Function<VaList, Integer> getFromPointer,\n-                                        ValueLayout.OfAddress pointerLayout) {\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment msInt = MemorySegment.allocateNative(JAVA_INT, arena.scope());;\n-            msInt.set(JAVA_INT, 0, 10);\n-            VaList vaList = vaListFactory.apply(b -> b.addVarg(pointerLayout, msInt));\n-            int x = getFromPointer.apply(vaList);\n-            assertEquals(x, 10);\n-        }\n-    }\n-\n-    interface TriFunction<S, T, U, R> {\n-        R apply(S s, T t, U u);\n-    }\n-\n-    @DataProvider\n-    @SuppressWarnings(\"unchecked\")\n-    public static Object[][] structs() {\n-        TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Integer>> sumStructJavaFact\n-                = (pointLayout, VH_Point_x, VH_Point_y) ->\n-                list -> {\n-                    MemorySegment struct = MemorySegment.allocateNative(pointLayout, SegmentScope.auto());\n-                    list.nextVarg(pointLayout, SegmentAllocator.prefixAllocator(struct));\n-                    int x = (int) VH_Point_x.get(struct);\n-                    int y = (int) VH_Point_y.get(struct);\n-                    return x + y;\n-                };\n-\n-        TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Integer>> sumStructNativeFact\n-                = (pointLayout, VH_Point_x, VH_Point_y) ->\n-                MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumStruct);\n-\n-        TriFunction<Function<Consumer<VaList.Builder>, VaList>, MemoryLayout,\n-                TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Integer>>, Object[]> argsFact\n-                = (vaListFact, intLayout, sumStructFact) -> {\n-            GroupLayout pointLayout =  MemoryLayout.structLayout(\n-                    intLayout.withName(\"x\"),\n-                    intLayout.withName(\"y\")\n-            );\n-            VarHandle VH_Point_x = pointLayout.varHandle(groupElement(\"x\"));\n-            VarHandle VH_Point_y = pointLayout.varHandle(groupElement(\"y\"));\n-            return new Object[] { vaListFact, sumStructFact.apply(pointLayout, VH_Point_x, VH_Point_y),\n-                    pointLayout, VH_Point_x, VH_Point_y  };\n-        };\n-        return new Object[][]{\n-                argsFact.apply(winVaListFactory,          Win64.C_INT,   sumStructJavaFact),\n-                argsFact.apply(sysvVaListFactory,         SysV.C_INT,    sumStructJavaFact),\n-                argsFact.apply(linuxAArch64VaListFactory, AArch64.C_INT, sumStructJavaFact),\n-                argsFact.apply(macAArch64VaListFactory,   AArch64.C_INT, sumStructJavaFact),\n-                argsFact.apply(platformVaListFactory,     C_INT,         sumStructNativeFact),\n-        };\n-    }\n-\n-    @Test(dataProvider = \"structs\")\n-    public void testStruct(Function<Consumer<VaList.Builder>, VaList> vaListFactory,\n-                           Function<VaList, Integer> sumStruct,\n-                           GroupLayout Point_LAYOUT, VarHandle VH_Point_x, VarHandle VH_Point_y) {\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT, arena.scope());;\n-            VH_Point_x.set(struct, 5);\n-            VH_Point_y.set(struct, 10);\n-\n-            VaList vaList = vaListFactory.apply(b -> b.addVarg(Point_LAYOUT, struct));\n-            int sum = sumStruct.apply(vaList);\n-            assertEquals(sum, 15);\n-        }\n-    }\n-\n-    @DataProvider\n-    @SuppressWarnings(\"unchecked\")\n-    public static Object[][] bigStructs() {\n-        TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Long>> sumStructJavaFact\n-                = (BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y) ->\n-                list -> {\n-                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, SegmentScope.auto());\n-                    list.nextVarg(BigPoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n-                    long x = (long) VH_BigPoint_x.get(struct);\n-                    long y = (long) VH_BigPoint_y.get(struct);\n-                    return x + y;\n-                };\n-\n-        TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Long>> sumStructNativeFact\n-                = (pointLayout, VH_BigPoint_x, VH_BigPoint_y) ->\n-                MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumBigStruct);\n-\n-        TriFunction<Function<Consumer<VaList.Builder>, VaList>, MemoryLayout,\n-                TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Long>>, Object[]> argsFact\n-                = (vaListFact, longLongLayout, sumBigStructFact) -> {\n-            GroupLayout BigPoint_LAYOUT =  MemoryLayout.structLayout(\n-                    longLongLayout.withName(\"x\"),\n-                    longLongLayout.withName(\"y\")\n-            );\n-            VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(groupElement(\"x\"));\n-            VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(groupElement(\"y\"));\n-            return new Object[] { vaListFact, sumBigStructFact.apply(BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y),\n-                    BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y  };\n-        };\n-        return new Object[][]{\n-                argsFact.apply(winVaListFactory,          Win64.C_LONG_LONG,   sumStructJavaFact),\n-                argsFact.apply(sysvVaListFactory,         SysV.C_LONG_LONG,    sumStructJavaFact),\n-                argsFact.apply(linuxAArch64VaListFactory, AArch64.C_LONG_LONG, sumStructJavaFact),\n-                argsFact.apply(macAArch64VaListFactory,   AArch64.C_LONG_LONG, sumStructJavaFact),\n-                argsFact.apply(platformVaListFactory,     C_LONG_LONG,         sumStructNativeFact),\n-        };\n-    }\n-\n-    @Test(dataProvider = \"bigStructs\")\n-    public void testBigStruct(Function<Consumer<VaList.Builder>, VaList> vaListFactory,\n-                              Function<VaList, Long> sumBigStruct,\n-                              GroupLayout BigPoint_LAYOUT, VarHandle VH_BigPoint_x, VarHandle VH_BigPoint_y) {\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, arena.scope());;\n-            VH_BigPoint_x.set(struct, 5);\n-            VH_BigPoint_y.set(struct, 10);\n-\n-            VaList vaList = vaListFactory.apply(b -> b.addVarg(BigPoint_LAYOUT, struct));\n-            long sum = sumBigStruct.apply(vaList);\n-            assertEquals(sum, 15);\n-        }\n-    }\n-\n-    @DataProvider\n-    @SuppressWarnings(\"unchecked\")\n-    public static Object[][] floatStructs() {\n-        TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Float>> sumStructJavaFact\n-                = (FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y) ->\n-                list -> {\n-                    MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT, SegmentScope.auto());\n-                    list.nextVarg(FloatPoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n-                    float x = (float) VH_FloatPoint_x.get(struct);\n-                    float y = (float) VH_FloatPoint_y.get(struct);\n-                    return x + y;\n-                };\n-\n-        TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Float>> sumStructNativeFact\n-                = (pointLayout, VH_FloatPoint_x, VH_FloatPoint_y) ->\n-                MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumFloatStruct);\n-\n-        TriFunction<Function<Consumer<VaList.Builder>, VaList>, MemoryLayout,\n-                TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Float>>, Object[]> argsFact\n-                = (vaListFact, floatLayout, sumFloatStructFact) -> {\n-            GroupLayout FloatPoint_LAYOUT = MemoryLayout.structLayout(\n-                    floatLayout.withName(\"x\"),\n-                    floatLayout.withName(\"y\")\n-            );\n-            VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(groupElement(\"x\"));\n-            VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(groupElement(\"y\"));\n-            return new Object[] { vaListFact, sumFloatStructFact.apply(FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y),\n-                    FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y  };\n-        };\n-        return new Object[][]{\n-                argsFact.apply(winVaListFactory,          Win64.C_FLOAT,   sumStructJavaFact),\n-                argsFact.apply(sysvVaListFactory,         SysV.C_FLOAT,    sumStructJavaFact),\n-                argsFact.apply(linuxAArch64VaListFactory, AArch64.C_FLOAT, sumStructJavaFact),\n-                argsFact.apply(macAArch64VaListFactory,   AArch64.C_FLOAT, sumStructJavaFact),\n-                argsFact.apply(platformVaListFactory,     C_FLOAT,         sumStructNativeFact),\n-        };\n-    }\n-\n-    @Test(dataProvider = \"floatStructs\")\n-    public void testFloatStruct(Function<Consumer<VaList.Builder>, VaList> vaListFactory,\n-                                Function<VaList, Float> sumFloatStruct,\n-                                GroupLayout FloatPoint_LAYOUT,\n-                                VarHandle VH_FloatPoint_x, VarHandle VH_FloatPoint_y) {\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT, arena.scope());;\n-            VH_FloatPoint_x.set(struct, 1.234f);\n-            VH_FloatPoint_y.set(struct, 3.142f);\n-\n-            VaList vaList = vaListFactory.apply(b -> b.addVarg(FloatPoint_LAYOUT, struct));\n-            float sum = sumFloatStruct.apply(vaList);\n-            assertEquals(sum, 4.376f, 0.00001f);\n-        }\n-    }\n-\n-    interface QuadFunc<T0, T1, T2, T3, R> {\n-        R apply(T0 t0, T1 t1, T2 t2, T3 t3);\n-    }\n-\n-    @DataProvider\n-    @SuppressWarnings(\"unchecked\")\n-    public static Object[][] hugeStructs() {\n-        QuadFunc<GroupLayout, VarHandle, VarHandle, VarHandle, Function<VaList, Long>> sumStructJavaFact\n-                = (HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z) ->\n-                list -> {\n-                    MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT, SegmentScope.auto());\n-                    list.nextVarg(HugePoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n-                    long x = (long) VH_HugePoint_x.get(struct);\n-                    long y = (long) VH_HugePoint_y.get(struct);\n-                    long z = (long) VH_HugePoint_z.get(struct);\n-                    return x + y + z;\n-                };\n-\n-        QuadFunc<GroupLayout, VarHandle, VarHandle, VarHandle, Function<VaList, Long>> sumStructNativeFact\n-                = (pointLayout, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z) ->\n-                MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumHugeStruct);\n-\n-        TriFunction<Function<Consumer<VaList.Builder>, VaList>, MemoryLayout,\n-                QuadFunc<GroupLayout, VarHandle, VarHandle, VarHandle, Function<VaList, Long>>, Object[]> argsFact\n-                = (vaListFact, longLongLayout, sumBigStructFact) -> {\n-            GroupLayout HugePoint_LAYOUT = MemoryLayout.structLayout(\n-                    longLongLayout.withName(\"x\"),\n-                    longLongLayout.withName(\"y\"),\n-                    longLongLayout.withName(\"z\")\n-            );\n-            VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(groupElement(\"x\"));\n-            VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(groupElement(\"y\"));\n-            VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(groupElement(\"z\"));\n-            return new Object[] { vaListFact,\n-                    sumBigStructFact.apply(HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z),\n-                    HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z  };\n-        };\n-        return new Object[][]{\n-                argsFact.apply(winVaListFactory,          Win64.C_LONG_LONG,   sumStructJavaFact),\n-                argsFact.apply(sysvVaListFactory,         SysV.C_LONG_LONG,    sumStructJavaFact),\n-                argsFact.apply(linuxAArch64VaListFactory, AArch64.C_LONG_LONG, sumStructJavaFact),\n-                argsFact.apply(macAArch64VaListFactory,   AArch64.C_LONG_LONG, sumStructJavaFact),\n-                argsFact.apply(platformVaListFactory,     C_LONG_LONG,         sumStructNativeFact),\n-        };\n-    }\n-\n-    @Test(dataProvider = \"hugeStructs\")\n-    public void testHugeStruct(Function<Consumer<VaList.Builder>, VaList> vaListFactory,\n-                               Function<VaList, Long> sumHugeStruct,\n-                               GroupLayout HugePoint_LAYOUT,\n-                               VarHandle VH_HugePoint_x, VarHandle VH_HugePoint_y, VarHandle VH_HugePoint_z) {\n-        \/\/ On AArch64 a struct needs to be larger than 16 bytes to be\n-        \/\/ passed by reference.\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT, arena.scope());;\n-            VH_HugePoint_x.set(struct, 1);\n-            VH_HugePoint_y.set(struct, 2);\n-            VH_HugePoint_z.set(struct, 3);\n-\n-            VaList vaList = vaListFactory.apply(b -> b.addVarg(HugePoint_LAYOUT, struct));\n-            long sum = sumHugeStruct.apply(vaList);\n-            assertEquals(sum, 6);\n-        }\n-    }\n-\n-    public interface SumStackFunc {\n-        void invoke(MemorySegment longSum, MemorySegment doubleSum, VaList list);\n-    }\n-\n-    @DataProvider\n-    public static Object[][] sumStack() {\n-        BiFunction<ValueLayout.OfLong, ValueLayout.OfDouble, SumStackFunc> sumStackJavaFact = (longLayout, doubleLayout) ->\n-                (longSum, doubleSum, list) -> {\n-                    long lSum = 0L;\n-                    for (int i = 0; i < 16; i++) {\n-                        lSum += list.nextVarg(longLayout);\n-                    }\n-                    longSum.set(JAVA_LONG, 0, lSum);\n-                    double dSum = 0D;\n-                    for (int i = 0; i < 16; i++) {\n-                        dSum += list.nextVarg(doubleLayout);\n-                    }\n-                    doubleSum.set(JAVA_DOUBLE, 0, dSum);\n-                };\n-        SumStackFunc sumStackNative = (longSum, doubleSum, list) -> {\n-            try {\n-                MH_sumStack.invokeExact(longSum, doubleSum, list);\n-            } catch (Throwable ex) {\n-                throw new AssertionError(ex);\n-            }\n-        };\n-        return new Object[][]{\n-                { winVaListFactory,           sumStackJavaFact.apply(Win64.C_LONG_LONG, Win64.C_DOUBLE),     Win64.C_LONG_LONG,   Win64.C_DOUBLE   },\n-                { sysvVaListFactory,          sumStackJavaFact.apply(SysV.C_LONG_LONG, SysV.C_DOUBLE),       SysV.C_LONG_LONG,    SysV.C_DOUBLE    },\n-                { linuxAArch64VaListFactory,  sumStackJavaFact.apply(AArch64.C_LONG_LONG, AArch64.C_DOUBLE), AArch64.C_LONG_LONG, AArch64.C_DOUBLE },\n-                { macAArch64VaListFactory,    sumStackJavaFact.apply(AArch64.C_LONG_LONG, AArch64.C_DOUBLE), AArch64.C_LONG_LONG, AArch64.C_DOUBLE },\n-                { platformVaListFactory,      sumStackNative,                                                C_LONG_LONG,         C_DOUBLE         },\n-        };\n-    }\n-\n-    @Test(dataProvider = \"sumStack\")\n-    public void testStack(Function<Consumer<VaList.Builder>, VaList> vaListFactory,\n-                          SumStackFunc sumStack,\n-                          ValueLayout.OfLong longLayout,\n-                          ValueLayout.OfDouble doubleLayout) {\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment longSum = MemorySegment.allocateNative(longLayout, arena.scope());;\n-            MemorySegment doubleSum = MemorySegment.allocateNative(doubleLayout, arena.scope());;\n-            longSum.set(JAVA_LONG, 0, 0L);\n-            doubleSum.set(JAVA_DOUBLE, 0, 0D);\n-\n-            VaList list = vaListFactory.apply(b -> {\n-                for (long l = 1; l <= 16L; l++) {\n-                    b.addVarg(longLayout, l);\n-                }\n-                for (double d = 1; d <= 16D; d++) {\n-                    b.addVarg(doubleLayout, d);\n-                }\n-            });\n-\n-            sumStack.invoke(longSum, doubleSum, list);\n-\n-            long lSum = longSum.get(JAVA_LONG, 0);\n-            double dSum = doubleSum.get(JAVA_DOUBLE, 0);\n-\n-            assertEquals(lSum, 136L);\n-            assertEquals(dSum, 136D);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"upcalls\")\n-    public void testUpcall(MethodHandle target, MethodHandle callback) throws Throwable {\n-        FunctionDescriptor desc = FunctionDescriptor.ofVoid(C_POINTER);\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment stub = abi.upcallStub(callback, desc, arena.scope());\n-            target.invokeExact(stub);\n-        }\n-    }\n-\n-    @DataProvider\n-    public Object[][] emptyVaLists() {\n-        return new Object[][] {\n-                { Windowsx64Linker.emptyVaList()           },\n-                { winVaListFactory.apply(b -> {})          },\n-                { SysVx64Linker.emptyVaList()              },\n-                { sysvVaListFactory.apply(b -> {})         },\n-                { LinuxAArch64Linker.emptyVaList()         },\n-                { linuxAArch64VaListFactory.apply(b -> {}) },\n-                { MacOsAArch64Linker.emptyVaList()         },\n-                { macAArch64VaListFactory.apply(b -> {})   },\n-        };\n-    }\n-\n-    @DataProvider\n-    @SuppressWarnings(\"unchecked\")\n-    public static Object[][] sumIntsScoped() {\n-        Function<ValueLayout.OfInt, BiFunction<Integer, VaList, Integer>> sumIntsJavaFact = layout ->\n-                (num, list) -> IntStream.generate(() -> list.nextVarg(layout)).limit(num).sum();\n-        BiFunction<Integer, VaList, Integer> sumIntsNative\n-                = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumInts);\n-        return new Object[][]{\n-                { winVaListScopedFactory,          sumIntsJavaFact.apply(Win64.C_INT),   Win64.C_INT   },\n-                { sysvVaListScopedFactory,         sumIntsJavaFact.apply(SysV.C_INT),    SysV.C_INT    },\n-                { linuxAArch64VaListScopedFactory, sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },\n-                { macAArch64VaListScopedFactory,   sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },\n-                { platformVaListScopedFactory,     sumIntsNative,                        C_INT         },\n-        };\n-    }\n-\n-    @Test(dataProvider = \"sumIntsScoped\")\n-    public void testScopedVaList(BiFunction<Consumer<VaList.Builder>, SegmentScope, VaList> vaListFactory,\n-                                 BiFunction<Integer, VaList, Integer> sumInts,\n-                                 ValueLayout.OfInt intLayout) {\n-        VaList listLeaked;\n-        try (Arena arena = Arena.openConfined()) {\n-            VaList list = vaListFactory.apply(b -> b.addVarg(intLayout, 4)\n-                    .addVarg(intLayout, 8), arena.scope());\n-            int x = sumInts.apply(2, list);\n-            assertEquals(x, 12);\n-            listLeaked = list;\n-        }\n-        assertFalse(listLeaked.segment().scope().isAlive());\n-    }\n-\n-    @Test(dataProvider = \"structs\")\n-    public void testScopeMSRead(Function<Consumer<VaList.Builder>, VaList> vaListFactory,\n-                                Function<VaList, Integer> sumStruct, \/\/ ignored\n-                                GroupLayout Point_LAYOUT, VarHandle VH_Point_x, VarHandle VH_Point_y) {\n-        MemorySegment pointOut;\n-        try (Arena arena = Arena.openConfined()) {\n-            try (Arena innerArena = Arena.openConfined()) {\n-                MemorySegment pointIn = MemorySegment.allocateNative(Point_LAYOUT, innerArena.scope());;\n-                VH_Point_x.set(pointIn, 3);\n-                VH_Point_y.set(pointIn, 6);\n-                VaList list = vaListFactory.apply(b -> b.addVarg(Point_LAYOUT, pointIn));\n-                pointOut = MemorySegment.allocateNative(Point_LAYOUT, arena.scope());;\n-                list.nextVarg(Point_LAYOUT, SegmentAllocator.prefixAllocator(pointOut));\n-                assertEquals((int) VH_Point_x.get(pointOut), 3);\n-                assertEquals((int) VH_Point_y.get(pointOut), 6);\n-                assertTrue(pointOut.scope().isAlive()); \/\/ after VaList freed\n-            }\n-            assertTrue(pointOut.scope().isAlive()); \/\/ after inner session freed\n-        }\n-        assertFalse(pointOut.scope().isAlive()); \/\/ after outer session freed\n-    }\n-\n-    @DataProvider\n-    public Object[][] copy() {\n-        return new Object[][] {\n-                { winVaListScopedFactory,          Win64.C_INT   },\n-                { sysvVaListScopedFactory,         SysV.C_INT    },\n-                { linuxAArch64VaListScopedFactory, AArch64.C_INT },\n-                { macAArch64VaListScopedFactory,   AArch64.C_INT },\n-        };\n-    }\n-\n-    @Test(dataProvider = \"copy\")\n-    public void testCopy(BiFunction<Consumer<VaList.Builder>, SegmentScope, VaList> vaListFactory, ValueLayout.OfInt intLayout) {\n-        try (var arena = Arena.openConfined()) {\n-            VaList list = vaListFactory.apply(b -> b.addVarg(intLayout, 4)\n-                    .addVarg(intLayout, 8), arena.scope());\n-            VaList copy = list.copy();\n-            assertEquals(copy.nextVarg(intLayout), 4);\n-            assertEquals(copy.nextVarg(intLayout), 8);\n-\n-            \/\/        try { \/\/ this logic only works on Windows!\n-            \/\/            int x = copy.vargAsInt(intLayout);\n-            \/\/            fail();\n-            \/\/        } catch (IndexOutOfBoundsException ex) {\n-            \/\/            \/\/ ok - we exhausted the list\n-            \/\/        }\n-\n-            assertEquals(list.nextVarg(intLayout), 4);\n-            assertEquals(list.nextVarg(intLayout), 8);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"copy\",\n-            expectedExceptions = IllegalStateException.class)\n-    public void testCopyUnusableAfterOriginalClosed(BiFunction<Consumer<VaList.Builder>, SegmentScope, VaList> vaListFactory,\n-                                                    ValueLayout.OfInt intLayout) {\n-        VaList copy;\n-        try (var arena = Arena.openConfined()) {\n-            VaList list = vaListFactory.apply(b -> b.addVarg(intLayout, 4)\n-                    .addVarg(intLayout, 8), arena.scope());\n-            copy = list.copy();\n-        }\n-\n-        copy.nextVarg(intLayout); \/\/ should throw\n-    }\n-\n-    @DataProvider\n-    public static Object[][] upcalls() {\n-        GroupLayout BigPoint_LAYOUT = MemoryLayout.structLayout(\n-                C_LONG_LONG.withName(\"x\"),\n-                C_LONG_LONG.withName(\"y\")\n-        );\n-        VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(groupElement(\"x\"));\n-        VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(groupElement(\"y\"));\n-        GroupLayout Point_LAYOUT = MemoryLayout.structLayout(\n-                C_INT.withName(\"x\"),\n-                C_INT.withName(\"y\")\n-        );\n-        VarHandle VH_Point_x = Point_LAYOUT.varHandle(groupElement(\"x\"));\n-        VarHandle VH_Point_y = Point_LAYOUT.varHandle(groupElement(\"y\"));\n-        GroupLayout FloatPoint_LAYOUT = MemoryLayout.structLayout(\n-                C_FLOAT.withName(\"x\"),\n-                C_FLOAT.withName(\"y\")\n-        );\n-        VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(groupElement(\"x\"));\n-        VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(groupElement(\"y\"));\n-        GroupLayout HugePoint_LAYOUT = MemoryLayout.structLayout(\n-                C_LONG_LONG.withName(\"x\"),\n-                C_LONG_LONG.withName(\"y\"),\n-                C_LONG_LONG.withName(\"z\")\n-        );\n-        VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(groupElement(\"x\"));\n-        VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(groupElement(\"y\"));\n-        VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(groupElement(\"z\"));\n-\n-        return new Object[][]{\n-                { linkVaListCB(\"upcallBigStruct\"), VaListConsumer.mh(vaList -> {\n-                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, SegmentScope.auto());\n-                    vaList.nextVarg(BigPoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n-                    assertEquals((long) VH_BigPoint_x.get(struct), 8);\n-                    assertEquals((long) VH_BigPoint_y.get(struct), 16);\n-                })},\n-                { linkVaListCB(\"upcallBigStruct\"), VaListConsumer.mh(vaList -> {\n-                    VaList copy = vaList.copy();\n-                    MemorySegment struct =  MemorySegment.allocateNative(BigPoint_LAYOUT, SegmentScope.auto());\n-                    vaList.nextVarg(BigPoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n-                    assertEquals((long) VH_BigPoint_x.get(struct), 8);\n-                    assertEquals((long) VH_BigPoint_y.get(struct), 16);\n-\n-                    VH_BigPoint_x.set(struct, 0);\n-                    VH_BigPoint_y.set(struct, 0);\n-\n-                    \/\/ should be independent\n-                    copy.nextVarg(BigPoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n-                    assertEquals((long) VH_BigPoint_x.get(struct), 8);\n-                    assertEquals((long) VH_BigPoint_y.get(struct), 16);\n-                })},\n-                { linkVaListCB(\"upcallBigStructPlusScalar\"), VaListConsumer.mh(vaList -> {\n-                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, SegmentScope.auto());\n-                    vaList.nextVarg(BigPoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n-                    assertEquals((long) VH_BigPoint_x.get(struct), 8);\n-                    assertEquals((long) VH_BigPoint_y.get(struct), 16);\n-\n-                    assertEquals(vaList.nextVarg(C_LONG_LONG), 42);\n-                })},\n-                { linkVaListCB(\"upcallBigStructPlusScalar\"), VaListConsumer.mh(vaList -> {\n-                    vaList.skip(BigPoint_LAYOUT);\n-                    assertEquals(vaList.nextVarg(C_LONG_LONG), 42);\n-                })},\n-                { linkVaListCB(\"upcallStruct\"), VaListConsumer.mh(vaList -> {\n-                    MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT, SegmentScope.auto());\n-                    vaList.nextVarg(Point_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n-                    assertEquals((int) VH_Point_x.get(struct), 5);\n-                    assertEquals((int) VH_Point_y.get(struct), 10);\n-                })},\n-                { linkVaListCB(\"upcallHugeStruct\"), VaListConsumer.mh(vaList -> {\n-                    MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT, SegmentScope.auto());\n-                    vaList.nextVarg(HugePoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n-                    assertEquals((long) VH_HugePoint_x.get(struct), 1);\n-                    assertEquals((long) VH_HugePoint_y.get(struct), 2);\n-                    assertEquals((long) VH_HugePoint_z.get(struct), 3);\n-                })},\n-                { linkVaListCB(\"upcallFloatStruct\"), VaListConsumer.mh(vaList -> {\n-                    MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT, SegmentScope.auto());\n-                    vaList.nextVarg(FloatPoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n-                    assertEquals((float) VH_FloatPoint_x.get(struct), 1.0f);\n-                    assertEquals((float) VH_FloatPoint_y.get(struct), 2.0f);\n-                })},\n-                { linkVaListCB(\"upcallMemoryAddress\"), VaListConsumer.mh(vaList -> {\n-                    MemorySegment intPtr = vaList.nextVarg(C_POINTER);\n-                    int x = intPtr.get(JAVA_INT, 0);\n-                    assertEquals(x, 10);\n-                })},\n-                { linkVaListCB(\"upcallDoubles\"), VaListConsumer.mh(vaList -> {\n-                    assertEquals(vaList.nextVarg(C_DOUBLE), 3.0);\n-                    assertEquals(vaList.nextVarg(C_DOUBLE), 4.0);\n-                    assertEquals(vaList.nextVarg(C_DOUBLE), 5.0);\n-                })},\n-                { linkVaListCB(\"upcallInts\"), VaListConsumer.mh(vaList -> {\n-                    assertEquals(vaList.nextVarg(C_INT), 10);\n-                    assertEquals(vaList.nextVarg(C_INT), 15);\n-                    assertEquals(vaList.nextVarg(C_INT), 20);\n-                })},\n-                { linkVaListCB(\"upcallStack\"), VaListConsumer.mh(vaList -> {\n-                    \/\/ skip all registers\n-                    for (long l = 1; l <= 16; l++) {\n-                        assertEquals(vaList.nextVarg(C_LONG_LONG), l);\n-                    }\n-                    for (double d = 1; d <= 16; d++) {\n-                        assertEquals(vaList.nextVarg(C_DOUBLE), d);\n-                    }\n-\n-                    \/\/ test some arbitrary values on the stack\n-                    assertEquals((byte) vaList.nextVarg(C_INT), (byte) 1);\n-                    assertEquals((char) vaList.nextVarg(C_INT), 'a');\n-                    assertEquals((short) vaList.nextVarg(C_INT), (short) 3);\n-                    assertEquals(vaList.nextVarg(C_INT), 4);\n-                    assertEquals(vaList.nextVarg(C_LONG_LONG), 5L);\n-                    assertEquals((float) vaList.nextVarg(C_DOUBLE), 6.0F);\n-                    assertEquals(vaList.nextVarg(C_DOUBLE), 7.0D);\n-                    assertEquals((byte) vaList.nextVarg(C_INT), (byte) 8);\n-                    assertEquals((char) vaList.nextVarg(C_INT), 'b');\n-                    assertEquals((short) vaList.nextVarg(C_INT), (short) 10);\n-                    assertEquals(vaList.nextVarg(C_INT), 11);\n-                    assertEquals(vaList.nextVarg(C_LONG_LONG), 12L);\n-                    assertEquals((float) vaList.nextVarg(C_DOUBLE), 13.0F);\n-                    assertEquals(vaList.nextVarg(C_DOUBLE), 14.0D);\n-\n-                    MemorySegment buffer = MemorySegment.allocateNative(BigPoint_LAYOUT, SegmentScope.auto());\n-                    SegmentAllocator bufferAllocator = SegmentAllocator.prefixAllocator(buffer);\n-\n-                    MemorySegment point = vaList.nextVarg(Point_LAYOUT, bufferAllocator);\n-                    assertEquals((int) VH_Point_x.get(point), 5);\n-                    assertEquals((int) VH_Point_y.get(point), 10);\n-\n-                    VaList copy = vaList.copy();\n-                    MemorySegment bigPoint = vaList.nextVarg(BigPoint_LAYOUT, bufferAllocator);\n-                    assertEquals((long) VH_BigPoint_x.get(bigPoint), 15);\n-                    assertEquals((long) VH_BigPoint_y.get(bigPoint), 20);\n-\n-                    VH_BigPoint_x.set(bigPoint, 0);\n-                    VH_BigPoint_y.set(bigPoint, 0);\n-\n-                    \/\/ should be independent\n-                    MemorySegment struct = copy.nextVarg(BigPoint_LAYOUT, bufferAllocator);\n-                    assertEquals((long) VH_BigPoint_x.get(struct), 15);\n-                    assertEquals((long) VH_BigPoint_y.get(struct), 20);\n-                })},\n-                \/\/ test skip\n-                { linkVaListCB(\"upcallStack\"), VaListConsumer.mh(vaList -> {\n-                    vaList.skip(C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG);\n-                    assertEquals(vaList.nextVarg(C_LONG_LONG), 5L);\n-                    vaList.skip(C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG);\n-                    assertEquals(vaList.nextVarg(C_LONG_LONG), 10L);\n-                    vaList.skip(C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG);\n-                    assertEquals(vaList.nextVarg(C_DOUBLE), 1.0D);\n-                    vaList.skip(C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE);\n-                    assertEquals(vaList.nextVarg(C_DOUBLE), 6.0D);\n-                })},\n-        };\n-    }\n-\n-    interface VaListConsumer {\n-        void accept(VaList list);\n-\n-        static MethodHandle mh(VaListConsumer instance) {\n-            try {\n-                MethodHandle handle = MethodHandles.lookup().findVirtual(VaListConsumer.class, \"accept\",\n-                        MethodType.methodType(void.class, VaList.class)).bindTo(instance);\n-                return MethodHandles.filterArguments(handle, 0,\n-                        SEGMENT_TO_VALIST);\n-            } catch (ReflectiveOperationException e) {\n-                throw new InternalError(e);\n-            }\n-        }\n-    }\n-\n-    static VaList segmentToValist(MemorySegment segment) {\n-        return VaList.ofAddress(segment.address(), SegmentScope.auto());\n-    }\n-\n-    @DataProvider\n-    public static Object[][] overflow() {\n-        List<Function<Consumer<VaList.Builder>, VaList>> factories = List.of(\n-            winVaListFactory,\n-            sysvVaListFactory,\n-            linuxAArch64VaListFactory,\n-            macAArch64VaListFactory\n-        );\n-        List<List<MemoryLayout>> contentsCases = List.of(\n-            List.of(JAVA_INT),\n-            List.of(JAVA_LONG),\n-            List.of(JAVA_DOUBLE),\n-            List.of(ADDRESS),\n-            List.of(JAVA_LONG, JAVA_LONG, JAVA_LONG, JAVA_LONG, JAVA_LONG, JAVA_LONG, JAVA_LONG, JAVA_LONG,\n-                    JAVA_LONG, JAVA_LONG, JAVA_LONG, JAVA_LONG, JAVA_LONG, JAVA_LONG, JAVA_LONG, JAVA_LONG,\n-                    JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE,\n-                    JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE,\n-                    JAVA_INT, JAVA_LONG, JAVA_DOUBLE, ADDRESS)\n-        );\n-        List<MemoryLayout> overflowCases = List.of(\n-            JAVA_INT,\n-            JAVA_LONG,\n-            JAVA_DOUBLE,\n-            ADDRESS\n-        );\n-        return factories.stream()\n-                .<Object[]>mapMulti((factory, sink) -> {\n-                    for (List<MemoryLayout> content : contentsCases) {\n-                        for (MemoryLayout overflow : overflowCases) {\n-                            sink.accept(new Object[]{ factory, content, overflow });\n-                        }\n-                    }\n-                })\n-                .toArray(Object[][]::new);\n-    }\n-\n-    private static void buildVaList(VaList.Builder builder, List<MemoryLayout> contents) {\n-        for (MemoryLayout layout : contents) {\n-            if (layout instanceof ValueLayout.OfInt ofInt) {\n-                 builder.addVarg(ofInt, 1);\n-            } else if (layout instanceof ValueLayout.OfLong ofLong) {\n-                 builder.addVarg(ofLong, 1L);\n-            } else if (layout instanceof ValueLayout.OfDouble ofDouble) {\n-                 builder.addVarg(ofDouble, 1D);\n-            } else if (layout instanceof ValueLayout.OfAddress ofAddress) {\n-                 builder.addVarg(ofAddress, MemorySegment.ofAddress(1));\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"overflow\")\n-    public void testSkipOverflow(Function<Consumer<VaList.Builder>, VaList> vaListFactory,\n-                                 List<MemoryLayout> contents,\n-                                 MemoryLayout skipped) {\n-        VaList vaList = vaListFactory.apply(b -> buildVaList(b, contents));\n-        vaList.skip(contents.toArray(MemoryLayout[]::new));\n-        assertThrows(NoSuchElementException.class, () -> vaList.skip(skipped));\n-    }\n-\n-    private static void nextVarg(VaList vaList, MemoryLayout layout) {\n-        if (layout instanceof ValueLayout.OfInt ofInt) {\n-            assertEquals(vaList.nextVarg(ofInt), 1);\n-        } else if (layout instanceof ValueLayout.OfLong ofLong) {\n-            assertEquals(vaList.nextVarg(ofLong), 1L);\n-        } else if (layout instanceof ValueLayout.OfDouble ofDouble) {\n-            assertEquals(vaList.nextVarg(ofDouble), 1D);\n-        } else if (layout instanceof ValueLayout.OfAddress ofAddress) {\n-            assertEquals(vaList.nextVarg(ofAddress), MemorySegment.ofAddress(1));\n-        }\n-    }\n-\n-    @Test(dataProvider = \"overflow\")\n-    public void testVargOverflow(Function<Consumer<VaList.Builder>, VaList> vaListFactory,\n-                                 List<MemoryLayout> contents,\n-                                 MemoryLayout next) {\n-        VaList vaList = vaListFactory.apply(b -> buildVaList(b, contents));\n-        for (MemoryLayout layout : contents) {\n-            nextVarg(vaList, layout);\n-        }\n-        assertThrows(NoSuchElementException.class, () -> nextVarg(vaList, next));\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":0,"deletions":910,"binary":false,"changes":910,"status":"deleted"},{"patch":"@@ -1,188 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-#include <stdarg.h>\n-\n-#ifdef _WIN64\n-#define EXPORT __declspec(dllexport)\n-#else\n-#define EXPORT\n-#endif\n-\n-\/\/ ###### Down calls\n-\n-EXPORT int sumInts(int argNum, va_list list) {\n-    int sum = 0;\n-    for (int i = 0; i < argNum; i++) {\n-        sum += va_arg(list, int);\n-    }\n-    return sum;\n-}\n-\n-EXPORT double sumDoubles(int argNum, va_list list) {\n-    double sum = 0;\n-    for (int i = 0; i < argNum; i++) {\n-        sum += va_arg(list, double);\n-    }\n-    return sum;\n-}\n-\n-EXPORT int getInt(va_list list) {\n-    int* ptr = va_arg(list, int*);\n-    return *ptr;\n-}\n-\n-typedef struct {\n-    int x;\n-    int y;\n-} Point;\n-\n-EXPORT int sumStruct(va_list list) {\n-    Point point = va_arg(list, Point);\n-    return point.x + point.y;\n-}\n-\n-typedef struct {\n-    long long x;\n-    long long y;\n-} BigPoint;\n-\n-EXPORT long long sumBigStruct(va_list list) {\n-    BigPoint point = va_arg(list, BigPoint);\n-    return point.x + point.y;\n-}\n-\n-typedef struct {\n-    long long x;\n-    long long y;\n-    long long z;\n-} HugePoint;\n-\n-EXPORT long long sumHugeStruct(va_list list) {\n-    HugePoint point = va_arg(list, HugePoint);\n-    return point.x + point.y + point.z;\n-}\n-\n-typedef struct {\n-    float x;\n-    float y;\n-} FloatPoint;\n-\n-EXPORT float sumFloatStruct(va_list list) {\n-    FloatPoint point = va_arg(list, FloatPoint);\n-    return point.x + point.y;\n-}\n-\n-EXPORT void sumStack(long long* longSum, double* doubleSum, va_list list) {\n-    long long lSum = 0;\n-    for (int i = 0; i < 16; i++) {\n-        lSum += va_arg(list, long long);\n-    }\n-    *longSum = lSum;\n-    double dSum = 0.0;\n-    for (int i = 0; i < 16; i++) {\n-        dSum += va_arg(list, double);\n-    }\n-    *doubleSum = dSum;\n-}\n-\n-\/\/ ###### Up calls\n-\n-typedef void CB(va_list);\n-\n-static void passToUpcall(CB cb, int numArgs, ...) {\n-    va_list list;\n-    va_start(list, numArgs);\n-    cb(list);\n-    va_end(list);\n-}\n-\n-EXPORT void upcallInts(CB cb) {\n-    passToUpcall(cb, 3, 10, 15, 20);\n-}\n-\n-EXPORT void upcallDoubles(CB cb) {\n-    passToUpcall(cb, 3, 3.0, 4.0, 5.0);\n-}\n-\n-EXPORT void upcallStack(CB cb) {\n-    Point point;\n-    point.x = 5;\n-    point.y = 10;\n-\n-    BigPoint bigPoint;\n-    bigPoint.x = 15;\n-    bigPoint.y = 20;\n-\n-    passToUpcall(cb, 32 + 14,\n-        1LL, 2LL, 3LL, 4LL, 5LL, 6LL, 7LL, 8LL,\n-        9LL, 10LL, 11LL, 12LL, 13LL, 14LL, 15LL, 16LL,\n-        1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0,\n-        9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0,\n-        \/\/ should all be passed on the stack\n-        1, 'a', 3,  4,  5LL,  6.0f,  7.0,\n-        8, 'b', 10, 11, 12LL, 13.0f, 14.0,\n-        point, bigPoint);\n-}\n-\n-EXPORT void upcallMemoryAddress(CB cb) {\n-    int x = 10;\n-    passToUpcall(cb, 1, &x);\n-}\n-\n-EXPORT void upcallStruct(CB cb) {\n-    Point point;\n-    point.x = 5;\n-    point.y = 10;\n-    passToUpcall(cb, 1, point);\n-}\n-\n-EXPORT void upcallFloatStruct(CB cb) {\n-    FloatPoint point;\n-    point.x = 1.0f;\n-    point.y = 2.0f;\n-    passToUpcall(cb, 1, point);\n-}\n-\n-EXPORT void upcallBigStruct(CB cb) {\n-    BigPoint point;\n-    point.x = 8;\n-    point.y = 16;\n-    passToUpcall(cb, 1, point);\n-}\n-\n-EXPORT void upcallBigStructPlusScalar(CB cb) {\n-    BigPoint point;\n-    point.x = 8;\n-    point.y = 16;\n-    passToUpcall(cb, 2, point, 42);\n-}\n-\n-EXPORT void upcallHugeStruct(CB cb) {\n-    HugePoint point;\n-    point.x = 1;\n-    point.y = 2;\n-    point.z = 3;\n-    passToUpcall(cb, 1, point);\n-}\n","filename":"test\/jdk\/java\/foreign\/valist\/libVaList.c","additions":0,"deletions":188,"binary":false,"changes":188,"status":"deleted"},{"patch":"@@ -1,84 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.java.lang.foreign;\n-\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.FunctionDescriptor;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.lang.foreign.SymbolLookup;\n-import java.lang.invoke.MethodHandle;\n-import java.util.concurrent.TimeUnit;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@State(org.openjdk.jmh.annotations.Scope.Thread)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n-public class VaList extends CLayouts {\n-\n-    static final Linker linker = Linker.nativeLinker();\n-    static {\n-        System.loadLibrary(\"VaList\");\n-    }\n-\n-    static final MethodHandle MH_ellipsis;\n-    static final MethodHandle MH_vaList;\n-\n-    static {\n-        SymbolLookup loaderLibs = SymbolLookup.loaderLookup();\n-        MH_ellipsis = linker.downcallHandle(loaderLibs.find(\"ellipsis\").get(),\n-                FunctionDescriptor.ofVoid(C_INT, C_INT, C_DOUBLE, C_LONG_LONG),\n-                Linker.Option.firstVariadicArg(1));\n-        MH_vaList = linker.downcallHandle(loaderLibs.find(\"vaList\").get(),\n-                FunctionDescriptor.ofVoid(C_INT, C_POINTER));\n-    }\n-\n-    @Benchmark\n-    public void ellipsis() throws Throwable {\n-        MH_ellipsis.invokeExact(3,\n-                                1, 2D, 3L);\n-    }\n-\n-    @Benchmark\n-    public void vaList() throws Throwable {\n-        try (Arena arena = Arena.openConfined()) {\n-            java.lang.foreign.VaList vaList = java.lang.foreign.VaList.make(b ->\n-                    b.addVarg(C_INT, 1)\n-                            .addVarg(C_DOUBLE, 2D)\n-                            .addVarg(C_LONG_LONG, 3L), arena.scope());\n-            MH_vaList.invokeExact(3,\n-                    vaList.segment());\n-        }\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/VaList.java","additions":0,"deletions":84,"binary":false,"changes":84,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdarg.h>\n-\n-#ifdef _WIN64\n-#define EXPORT __declspec(dllexport)\n-#else\n-#define EXPORT\n-#endif\n-\n-EXPORT void vaList(int argCount, va_list list) {\n-    \/\/...\n-}\n-\n-EXPORT void ellipsis(int argCount, ...) {\n-    va_list list;\n-    va_start(list, argCount);\n-    vaList(argCount, list);\n-    va_end(list);\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/libVaList.c","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"}]}